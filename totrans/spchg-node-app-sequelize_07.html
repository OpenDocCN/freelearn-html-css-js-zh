<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-150"><a id="_idTextAnchor159"/>7</h1>
<h1 id="_idParaDest-151"><a id="_idTextAnchor160"/>Handling Customized, JSON, and Blob Data Types</h1>
<p>Some database management systems offer a way of storing niche column types such as JSON and Blob-related data. These column types are useful for rapid prototyping, handling schemaless data, and sending and receiving buffered data.</p>
<p>Typically, an application <a id="_idIndexMarker615"/>would use a <strong class="bold">NoSQL</strong> database, such as MongoDB, to process and query JSON documents, but this comes with a set of its own problems. We can no longer adhere to some sort of normalization for our structures without an extensive list of validations, and the NoSQL database cannot perform transactions nor provide ACID-compliant capabilities. </p>
<p class="callout-heading">Note</p>
<p class="callout">Some NoSQL databases claim to offer ACID compliance, but they often come with stipulations and limitations such as a maximum number of documents that can be updated in a single transaction, or a transaction cannot take longer than some temporal window; otherwise, you will lose all of the performance advantages of NoSQL over SQL databases.</p>
<p>There are several use cases for JSON and Blob column data types. With JSON, you can store a record set of non-deterministic values, which is great for use cases such as creating receipts of transactions and auditing systems. A Blob column data type can store any file that helps centralize retrieving and inserting from one location, but internally, the DBMS could shard or distribute that file.</p>
<p>Usually, it is not recommended to store files within a DBMS due to losing external access control lists, clogging Write-Ahead log files, and a false sense of security for storing those files. We could also run into increased page sizes, which would increase the time it takes to retrieve records. As a general rule, for quick prototyping of handling files, using a DBMS is fine but not for a production environment.</p>
<p class="callout-heading">Note</p>
<p class="callout">An example of using a JSON column type for auditing would be PGAudit’s Postgres extension. This extension will convert the previous and new record sets as JSON data types for storing differentiating values. You may refer to <a href="https://www.pgaudit.org/">https://www.pgaudit.org/</a> for more information on how this works.</p>
<p>Sequelize is capable of handling custom and Blob types for all supported DBMSs, and JSON column types for SQLite, MySQL, MariaDB, and PostgreSQL only. There is a workaround for MSSQL, which will be explained in detail under the <em class="italic">Working with JSON</em> section of this chapter.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Querying JSON and JSONB data</li>
<li>Using the <code>BLOB</code> column type</li>
<li>Creating custom data types</li>
</ul>
<h1 id="_idParaDest-152">Technical requiremen<a id="_idTextAnchor161"/>ts</h1>
<p>You can find the code files of this chapter at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch7">https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch7</a>.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor162"/>Querying JSON and JSONB data</h1>
<p>As stated previously, JSON column types are only available for SQLite, MySQL, MariaDB, and PostgreSQL. The JSONB column is only supported on the PostgreSQL DBMS. The difference <a id="_idIndexMarker616"/>between the two column types is that JSONB will store additional <a id="_idIndexMarker617"/>information related to the fields within the JSON document internally. This will increase the requirements for disk space but will help make querying the data quicker.</p>
<p>For this section, presume that we have the following model within our application:</p>
<pre class="source-code">
class Receipts extends Model {}
Receipts.init({
  receipt: DataTypes.JSON
});</pre>
<p>Now, we <a id="_idIndexMarker618"/>can <a id="_idIndexMarker619"/>create our document:</p>
<pre class="source-code">
await Receipts.create({
    receipt: {
        name: {
            first: "Bob",
            last: "Smith"
        },
        items: [
            {
                sku: "abc123",
                quantity: 10
            },
            {
                sku: "xyz321",
                quantity: 1
            }
        ],
        subtotal: 100
    }
});</pre>
<p>We can now query for our document using the traditional Sequelize methods:</p>
<pre class="source-code">
await Receipts.findOne({
    where: {
        receipt: {
            name: {
                first: "Bob",
                last: "Smith"
            }
        }
    }
});</pre>
<p>Or we <a id="_idIndexMarker620"/>can use <a id="_idIndexMarker621"/>a special dot-notation style:</p>
<pre class="source-code">
await Receipts.findOne({
    where: {
        "receipts.name.first": "Bob",
        "receipts.name.last": "Smith"
    }
});</pre>
<p>The dot-notation method will also work on other finder attributes such as <code>order</code>:</p>
<pre class="source-code">
const receipts = await Receipts.findAll({
    where: {
      receipt: {
        name: {
          last: "Smith",
        },
      },
    },
    order: [
      ["receipt.name.first"]
    ]
});</pre>
<p>We would <a id="_idIndexMarker622"/>have to re-insert the entire document like traditional <a id="_idIndexMarker623"/>NoSQL document storage systems when updating records:</p>
<pre class="source-code">
await Receipts.update({
    receipt: {
        name: {
            first: "Bob",
            last: "Smith"
        },
        items: [
            {
                sku: "abc123",
                quantity: 10
            },
            {
                sku: "xyz321",
                quantity: 1
            }
        ],
        subtotal: 120
    }
  }, {
    where: {
      "receipt.name.first": "Bob"
    }
});</pre>
<p>If we wanted <a id="_idIndexMarker624"/>to query for a value within an array, we may need to <a id="_idIndexMarker625"/>use the <code>Sequelize.literal</code> function if our DBMS does not natively support the <code>Op.contains</code> operator (PostgreSQL only). The following is an example of how to query an array’s value with PostgreSQL’s <code>@&gt;</code> operator:</p>
<pre class="source-code">
const receipts = await Receipts.findAll({
    where: {
        receipt: {
            items: {
                [Op.contains]: {
                    sku: "abc123"
                }
            }
        }
    }
});</pre>
<p>Since MySQL does not support a <code>contains</code> operator, the equivalent of the previous query would look like the following:</p>
<pre class="source-code">
const receipts = await Receipts.findAll({
    where: Sequelize.literal(`JSON_CONTAINS(JSON_EXTRACT
        (receipt, '$.items[*].sku', '"abc123"')`)
});</pre>
<p>MSSQL can <a id="_idIndexMarker626"/>also perform basic operations for JSON. The following is <a id="_idIndexMarker627"/>an example of how to query JSON data with MSSQL and Sequelize:</p>
<pre class="source-code">
class Users extends Model {}
Users.init({
    metadata: DataTypes.STRING
});
await Users.create({
    metadata: JSON.stringify({
        first_name: "Bob",
        last_name: "Smith"
    })
});
await Users.findAll({
    where: sequelize.where(
        sequelize.fn('JSON_VALUE', sequelize.col('metadata'), '$.first_name'),
        'Bob'
    )
});</pre>
<p>Unfortunately for MSSQL, to search through nested arrays would require a cross-join and a few <a id="_idIndexMarker628"/>more topics that are out of this book’s scope, such as OpenJSON (which can be referenced at <a href="https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql?view=sql-server-ver15">https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql?view=sql-server-ver15</a>).</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor163"/>Using the BLOB column type</h1>
<p>Sometimes, our <a id="_idIndexMarker629"/>application will require us to store buffer or binary data in our system. The following is a quick example of how to create and read binary data with Sequelize: </p>
<ol>
<li>We will start with our definition:<pre>class Users extends Model {}
Users.init({
    avatar: DataTypes.BLOB,
    keycode: DataTypes.BLOB
});</pre></li>
<li>Next, we can insert our record, like so:<pre>await Users.create({
    avatar: require("fs").readFileSync
            ("/some/path/avatar.jpg"),
    keycode: Buffer.from("secretpassword")
});</pre></li>
<li>To retrieve and use the buffered data, we can simply use a finder method and write directly using Node.js’ <code>fs</code> module:<pre>const user = await Users.findOne({});
require("fs").writeFileSync(
    "/some/path/to/write/avatar.jpg",
    user.avatar
);</pre></li>
</ol>
<p>Now that we have gone through all of the built-in data types, we can now begin creating our own custom data type. Custom data types can also be useful for just extending several validations together or creating several rulesets into one data type.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor164"/>Creating custom data types</h1>
<p>Sequelize offers <a id="_idIndexMarker630"/>us a way to create custom types by extending the <code>DataTypes.ABSTRACT</code> abstraction class. This allows us to keep our code base more organized and consistent. Suppose our application required a lot of columns all abiding by the laws of natural numbers. A quick demonstration would look like this:</p>
<pre class="source-code">
class Stats extends Model {}
Stats.init({
    A: {
        type: Sequelize.INTEGER(11).UNSIGNED.ZEROFILL,
        validate: {
            min: 1
        }
    },
    B: {
        type: Sequelize.INTEGER(11).UNSIGNED.ZEROFILL,
        validate: {
            min: 1
        }
    },
    C: {
        type: Sequelize.INTEGER(11).UNSIGNED.ZEROFILL,
        validate: {
            min: 1
        }
    },
});</pre>
<p>If we had <a id="_idIndexMarker631"/>hundreds of these columns, writing these columns out could be tiresome. A way to resolve this issue would be to create our own custom attribute. Let’s look at the steps:</p>
<ol>
<li value="1">The first step is to extend the <code>ABSTRACT</code> class:<pre>class NATURAL_NUMBER extends DataTypes.ABSTRACT {</pre></li>
<li>Then, we will need to tell Sequelize how to translate this data type into a column type. We can do this by defining a <code>toSql</code> method within the class:<pre>    toSql() {
        return 'INTEGER(11) UNSIGNED ZEROFILL'
    }</pre></li>
</ol>
<p>This will tell Sequelize that we want a zero-filled and unsigned integer. </p>
<ol>
<li value="3">Next, we can enforce a validation rule by creating a <code>validate</code> method:<pre>    validate(value, options) {
        const isNumber = Number.isInteger(value);
        const isAboveZero = Number.parseInt(value) &gt; 0;
      
        return isNumber &amp;&amp; isAboveZero;
    }</pre></li>
</ol>
<p>Sequelize will automatically check whether the value is an integer and above zero for this attribute type. </p>
<ol>
<li value="4">The next step is optional, but for completeness, the following methods are for writing and reading to and from the database, respectively:<pre>    _stringify(value) {
      return value.toString();
    }
    static parse(value) {
      return Number.parseInt(value);
    }</pre></li>
</ol>
<p>The <code>_stringify</code> method will convert the value into a string before sending it off to your database, and the <code>parse</code> method will transform the returned value from the database. </p>
<ol>
<li value="5">Now, we can <a id="_idIndexMarker632"/>close our class and invoke some mandatory methods:<pre>}
NATURAL_NUMBER.prototype.key = NATURAL_NUMBER.key = 'NATURAL_NUMBER';
DataTypes.NATURAL_NUMBER = Sequelize.Utils.classToInvokable(NATURAL_NUMBER);</pre></li>
</ol>
<p>Sequelize will identify your attribute’s data type by mapping out the <code>key</code> value from your class. The next line will add your custom data type to Sequelize’s <code>DataTypes</code> namespace. The <code>classToInvokable</code> method will simply wrap your class’s constructor and return a new instance so that you do not have to explicitly call <code>new DataTypes.NATURAL_NUMBER()</code> when defining your models.</p>
<ol>
<li value="6">Now we can define our previous model, like so:<pre>class Stats extends Model {}
Stats.init({
    A: DataTypes.NATURAL_NUMBER,
    B: DataTypes.NATURAL_NUMBER,
    C: DataTypes.NATURAL_NUMBER
});</pre></li>
</ol>
<p>And when we <a id="_idIndexMarker633"/>go to create or update, our attributes will abide by the rules that we previously set. The following three examples will return a validation error due to the value of the <code>C</code> column not being a natural number:</p>
<pre class="source-code">
await Stats.create({
    A: 100,
    B: 20,
    C: "NotANumber" // not an number
});
await Stats.create({
    A: 100,
    B: 20,
    C: 1.1 // not an integer
});
await Stats.create({
    A: 100,
    B: 20,
    C: -3 // not a natural number
});</pre>
<p>When we change <code>C</code> to a natural number (as shown in the following code), our query will now successfully create the record:</p>
<pre class="source-code">
await Stats.create({
    A: 100,
    B: 20,
    C: 10
}); // success!</pre>
<p>So far, we have <a id="_idIndexMarker634"/>gone over how to handle JSON and BLOB data types using Sequelize’s built-in classes. We also created our own custom data types by extending the Sequelize <code>ABSTRACT</code> data type class. Now, we can start using some of these data types in our project. </p>
<p>Now that we have a better understanding of how to handle JSON data types explicitly, we can start using that type in our Avalon Airlines project.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor165"/>Putting it all together</h1>
<p>Our business partner just informed us that we want to be able to record transaction receipts for every applicable event. This could be for the boarding ticket, extra luggage, or an additional water bottle, which means there is no deterministic structure for our data. For this task, we will need to generate a new model, <code>Receipts</code>, and update our <code>BoardingTicket</code> model. Here are the steps:</p>
<ol>
<li value="1">First, we can begin by generating a new model called <code>Receipts</code> for storing transaction events:<pre><strong class="bold">sequelize-cli model:generate --name Receipts --attributes receipt:json</strong></pre></li>
<li>Then, run our migration:<pre><strong class="bold">sequelize db:migrate</strong></pre></li>
<li>Next, we will want to add another life cycle event to our <code>BoardingTicket</code> model located in <code>models/boardingticket.js</code> by adding the following code at the end of the <code>module.exports</code> block:<pre>  BoardingTicket.afterSave('saveReceipt', 
      async(ticket, options) =&gt; {
    await sequelize.models.Receipts.create({
      receipt: ticket.get()
    }, {
      transaction: options.transaction
    });
  });</pre></li>
</ol>
<p>That wraps up our changes to the Avalon Airlines project. We implemented a new model for storing receipt data using JSON, and we added a life cycle event after creating or updating the <code>BoardingTicket</code> model. This should complete the requirements for our next investor meeting.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor166"/>Summary</h1>
<p>In this chapter, we went through different ways of reading and writing attributes with specific data types such as JSON and <code>BLOB</code>. We also learned how to create custom data types by extending the <code>ABSTRACT</code> class in order to create a more ergonomic code base that is easier to maintain overall. </p>
<p>In the next chapter, we will be covering how to monitor and log queries from your application. The following chapter will also contain further instructions on completing the Avalon Airlines project.</p>
</div>
</div>

<div><div><div></div>
</div>
<div><h1 id="_idParaDest-158"><a id="_idTextAnchor167"/>Part 3 – Advanced Queries, Using Adapters, and Logging Queries</h1>
<p>In this part, you will understand how to monitor and measure metrics for your application’s performance. You will use third-party applications that integrate with Sequelize and logging queries. You will also learn how to deploy your application to a cloud application platform.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B17841_08.xhtml#_idTextAnchor168"><em class="italic">Chapter 8</em></a>, <em class="italic">Logging and Monitoring Your Application</em></li>
<li><a href="B17841_09.xhtml#_idTextAnchor177"><em class="italic">Chapter 9</em></a>, <em class="italic">Using and Creating Adapters</em></li>
<li><a href="B17841_10.xhtml#_idTextAnchor184"><em class="italic">Chapter 10</em></a>, <em class="italic">Deploying a Sequelize Application</em></li>
</ul>
</div>
</div></body></html>