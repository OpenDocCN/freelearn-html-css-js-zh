<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. The Browser Environment</h1></div></div></div><p>You know that JavaScript programs need a host environment. Most of what you learned so far in this book was related to core ECMAScript/JavaScript and can be used in many different host environments. Now, let's shift the focus to the browser as this is the most popular and natural host environment for JavaScript programs. In this chapter, you will learn the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>Browser Object Model</strong> (<strong>BOM</strong>)</li><li class="listitem" style="list-style-type: disc">The <strong>Document Object Model</strong> (<strong>DOM</strong>)</li><li class="listitem" style="list-style-type: disc">Browser events</li><li class="listitem" style="list-style-type: disc">The <code class="literal">XMLHttpRequest</code> object</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec77"/>Including JavaScript in an HTML page</h1></div></div></div><p>To include JavaScript in an HTML page, you will need to use the <code class="literal">&lt;script&gt;</code> tag as follows:</p><pre class="programlisting">    &lt;!DOCTYPE&gt; &#13;
    &lt;html&gt; &#13;
      &lt;head&gt; &#13;
        &lt;title&gt;JS test&lt;/title&gt; &#13;
        &lt;script src="img/somefile.js"&gt;&lt;/script&gt; &#13;
      &lt;/head&gt; &#13;
      &lt;body&gt; &#13;
        &lt;script&gt; &#13;
          var a = 1; &#13;
          a++; &#13;
        &lt;/script&gt; &#13;
      &lt;/body&gt; &#13;
    &lt;/html&gt; &#13;
</pre><p>In this example, the first <code class="literal">&lt;script&gt;</code> tag includes an external file, <code class="literal">somefile.js</code>, which contains JavaScript code. The second <code class="literal">&lt;script&gt;</code> tag includes the JavaScript code directly in the HTML code of the page. The browser executes the JavaScript code in the sequence it finds it on the page and all the code in all tags share the same global namespace. This means that when you define a variable in <code class="literal">somefile.js</code>, it also exists in the second <code class="literal">&lt;script&gt;</code> block.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec78"/>BOM and DOM - an overview</h1></div></div></div><p>The JavaScript code in a page has access to a number of objects. These objects can be divided into the following types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Core ECMAScript objects</strong>: This consists of all the objects mentioned in the previous chapters</li><li class="listitem" style="list-style-type: disc"><strong>DOM</strong>: This consists of objects that have to do with the currently loaded page, which is also called the document</li><li class="listitem" style="list-style-type: disc"><strong>BOM</strong>: This consists of objects that deal with everything outside the page-the browser window and the desktop screen</li></ul></div><p>DOM stands for Document Object Model and BOM for Browser Object Model.</p><p>The DOM is a standard governed by the <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>) and has different versions, called levels, such as DOM Level 1, DOM Level 2, and so on. Browsers in use today have different degrees of compliance with the standard, but in general, they almost all completely implement DOM Level 1. The DOM was standardized post factum after the browser vendors had each implemented their own ways to access the document. The legacy part from before the W3C took over is still around and is referred to as DOM 0, although, no real DOM Level 0 standard exists. Some parts of DOM 0 have become de facto standards as all major browsers support them; some of these were added to the DOM Level 1 standard. The rest of DOM 0 that didn't find its way to DOM 1 is too browser specific and won't be discussed here.</p><p>Historically, BOM was not a part of any standard. Similar to DOM 0, it has a subset of objects that is supported by all major browsers, and another subset that is browser-specific. The HTML5 standard codifies common behavior among browsers, and it includes common BOM objects. Additionally, mobile devices come with their specific objects (and HTML5 aims to standardize those as well), which traditionally were not necessary for desktop computers, but make sense in a mobile world, for example, geolocation, camera access, vibration, touch events, telephony, and SMS.</p><p>This chapter discusses only cross-browser subsets of BOM and DOM Level 1, unless noted otherwise in the text. Even these safe subsets constitute a large topic, and a full reference is beyond the scope of this book. You can also consult the following references:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mozilla DOM reference (<a class="ulink" href="http://developer.mozilla.org/en/docs/Gecko_DOM_Reference">http://developer.mozilla.org/en/docs/Gecko_DOM_Reference</a>)</li><li class="listitem" style="list-style-type: disc">Mozilla's HTML5 wiki (<a class="ulink" href="https://developer.mozilla.org/en-US/docs/HTML/HTML5">https://developer.mozilla.org/en-US/docs/HTML/HTML5</a>)</li><li class="listitem" style="list-style-type: disc">Microsoft's documentation for Internet Explorer (<a class="ulink" href="http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx">http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx</a>)</li><li class="listitem" style="list-style-type: disc">W3C's DOM specifications (<a class="ulink" href="http://www.w3.org/DOM/DOMTR">http://www.w3.org/DOM/DOMTR</a>)</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec79"/>BOM</h1></div></div></div><p>The BOM is a collection of objects that give you access to the browser and the computer screen. These objects are accessible through the global object <code class="literal">window</code>.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec112"/>The window object revisited</h2></div></div></div><p>As you already know, in JavaScript, there's a global object provided by the host environment. In the browser environment, this global object is accessible using <code class="literal">window</code>. All global variables are also accessible as properties of the <code class="literal">window</code> object. For example, take a look at the following code:</p><pre class="programlisting">    &gt; window.somevar = 1; &#13;
           1 &#13;
    &gt; somevar; &#13;
           1 &#13;
</pre><p>Additionally, all the core JavaScript functions, discussed in <a class="link" href="ch02.html" title="Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions">Chapter 2</a>, <em>Primitive Data Types, Arrays, Loops, and Conditions</em>, are methods of the global object. Consider the following piece of code:</p><pre class="programlisting">    &gt; parseInt('123a456'); &#13;
           123 &#13;
    &gt; window.parseInt('123a456'); &#13;
           123 &#13;
</pre><p>In addition to being a reference to the global object, the <code class="literal">window</code> object also serves a second purpose-providing information about the browser environment. There's a <code class="literal">window</code> object for every frame, iframe, pop up, or browser tab.</p><p>Let's see some of the browser-related properties of the <code class="literal">window</code> object. Again, these can vary from one browser to another, so let's only consider the properties that are implemented consistently and reliably across all major browsers.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec113"/>Using window.navigator property</h2></div></div></div><p>The <code class="literal">navigator</code> is an object that has some information about the browser and its capabilities. One property is <code class="literal">navigator.userAgent</code>, which is a long string of browser identification. In Firefox, you'll get the following output:</p><pre class="programlisting">    &gt; window.navigator.userAgent; &#13;
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) &#13;
          AppleWebKit/536.28.10&#13;
          (KHTML, like Gecko) Version/6.0.3 Safari/536.28.10" &#13;
</pre><p>The <code class="literal">userAgent</code> string in Microsoft Internet Explorer is something as follows:</p><pre class="programlisting">       "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)" &#13;
</pre><p>As the browsers have different capabilities, developers are using the <code class="literal">userAgent</code> string to identify the browser and provide different versions of the code. For example, the following code snippet searches for the presence of the <code class="literal">MSIE</code> string to identify Internet Explorer:</p><pre class="programlisting">    if (navigator.userAgent.indexOf('MSIE') !== -1) { &#13;
      // this is IE &#13;
    } else { &#13;
      // not IE &#13;
    } &#13;
</pre><p>It's better not to rely on the <code class="literal">userAgent</code> string, but to use feature sniffing (also called capability detection) instead. The reason for this is that it's hard to keep track of all browsers and their different versions. It's much easier to simply check if the feature you intend to use is indeed available in the user's browser. For example, take a look at the following code snippet:</p><pre class="programlisting">    if (typeof window.addEventListener === 'function') { &#13;
      // feature is supported, let's use it &#13;
    } else { &#13;
      // hmm, this feature is not supported, will have to &#13;
      // think of another way &#13;
    } &#13;
</pre><p>Another reason to avoid <code class="literal">userAgent</code> sniffing is that some browsers allow users to modify the string and pretend they are using a different browser.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec114"/>Your console is a cheat sheet</h2></div></div></div><p>The console lets you inspect what's in an object and this includes all the BOM and DOM properties. Just type the following code:</p><pre class="programlisting">    &gt; navigator; &#13;
</pre><p>Then click on the result. The result is a list of properties and their values, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_10_001-e1482822786978.jpg" alt="Your console is a cheat sheet"/></div><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec115"/>Using window.location property</h2></div></div></div><p>The <code class="literal">location</code> property points to an object that contains information about the URL of the currently loaded page. For example, <code class="literal">location.href</code> is the full URL and <code class="literal">location.hostname</code> is only the domain. With a simple loop, you can see the full list of properties of the <code class="literal">location</code> object.</p><p>Imagine you're on a page with the following URL:</p><p>
<a class="ulink" href="http://search.phpied.com:8080/search?q=java&amp;what=script#results">http://search.phpied.com:8080/search?q=java&amp;what=script#results</a>.</p><p>Consider the following code:</p><pre class="programlisting">    for (var i in location) { &#13;
      if (typeof location[i] === "string") { &#13;
        console.log(i + ' = "' + location[i] + '"'); &#13;
      } &#13;
    } &#13;
           href = "http://search.phpied.com:8080/search?&#13;
             q=java&amp;what=script#results" &#13;
           hash = "#results" &#13;
           host = "search.phpied.com:8080" &#13;
           hostname = "search.phpied.com" &#13;
           pathname = "/search" &#13;
           port = &lt;&lt;8080&gt;&gt; &#13;
           protocol = &lt;&lt;http:&gt;&gt; &#13;
           search = "?q=java&amp;what=script" &#13;
</pre><p>There are also three methods that <code class="literal">location</code> property provides, namely <code class="literal">reload()</code>, <code class="literal">assign()</code>, and <code class="literal">replace()</code>.</p><p>It's interesting how many different ways exist for you to navigate to another page. The following are a few ways:</p><pre class="programlisting">    &gt; window.location.href = 'http://www.packtpub.com'; &#13;
    &gt; location.href = 'http://www.packtpub.com'; &#13;
    &gt; location = 'http://www.packtpub.com'; &#13;
    &gt; location.assign('http://www.packtpub.com'); &#13;
</pre><p>The <code class="literal">replace()</code> method is almost the same as <code class="literal">assign()</code>. The difference is that it doesn't create an entry in the browser's history list as follows:</p><pre class="programlisting">    &gt; location.replace('http://www.yahoo.com'); &#13;
</pre><p>To reload a page, you can use the following code:</p><pre class="programlisting">    &gt; location.reload(); &#13;
</pre><p>Alternatively, you can use <code class="literal">location.href</code> to point it to itself, as follows:</p><pre class="programlisting">    &gt; window.location.href = window.location.href; &#13;
</pre><p>Or, simply use the following code:</p><pre class="programlisting">    &gt; location = location; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec116"/>Using window.history property</h2></div></div></div><p>The <code class="literal">window.history</code> property allows limited access to the previously visited pages in the same browser session. For example, you can see how many pages the user has visited before coming to your page, as follows:</p><pre class="programlisting">    &gt; window.history.length; &#13;
           5 &#13;
</pre><p>You cannot see the actual URLs though. For privacy reasons, this doesn't work. See the following code:</p><pre class="programlisting">    &gt; window.history[0]; &#13;
</pre><p>You can, however, navigate back and forth through the user's session as if the user had clicked on the back/forward browser buttons, as follows:</p><pre class="programlisting">    &gt; history.forward(); &#13;
    &gt; history.back(); &#13;
</pre><p>You can also skip pages back and forth with <code class="literal">history.go()</code>. This is the same as calling <code class="literal">history.back()</code>. The code for <code class="literal">history.go()</code> is as follows:</p><pre class="programlisting">    &gt; history.go(-1); &#13;
</pre><p>To go two pages back, use the following code:</p><pre class="programlisting">    &gt; history.go(-2); &#13;
</pre><p>Reload the current page using the following code:</p><pre class="programlisting">    &gt; history.go(0); &#13;
</pre><p>More recent browsers also support HTML5 history API, which lets you change the URL without reloading the page. This is perfect for dynamic pages because they can allow users to bookmark a specific URL, which represents the state of the application, and when they come back, or share with their friends, the page can restore the application state based on the URL. To get a sense of the history API, go to any page and write the following lines of code in the console:</p><pre class="programlisting">    &gt; history.pushState({a: 1}, "", "hello"); &#13;
    &gt; history.pushState({b: 2}, "", "hello-you-too"); &#13;
    &gt; history.state; &#13;
</pre><p>Notice how the URL changes, but the page is the same. Now, experiment with back and forward buttons in the browser and inspect the <code class="literal">history.state</code> object again.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec117"/>using window.frames property</h2></div></div></div><p>The <code class="literal">window.frames</code> property is a collection of all of the frames in the current page. It doesn't distinguish between frames and iframes (inline frames). Regardless of whether there are frames on the page or not, <code class="literal">window.frames</code> always exists and points to <code class="literal">window</code>, as follows:</p><pre class="programlisting">    &gt; window.frames === window; &#13;
           true &#13;
</pre><p>Let's consider an example where you have a page with one iframe, as follows:</p><pre class="programlisting">    &lt;iframe name="myframe" src="img/hello.html" /&gt; &#13;
</pre><p>In order to tell if there are any frames on the page, you can check the <code class="literal">length</code> property. In case of one iframe, you'll see the following output:</p><pre class="programlisting">    &gt; frames.length &#13;
           1 &#13;
</pre><p>Each frame contains another page, which has its own global <code class="literal">window</code> object.</p><p>To get access to the iframe's <code class="literal">window</code>, you can execute any of the following:</p><pre class="programlisting">    &gt; window.frames[0]; &#13;
    &gt; window.frames[0].window; &#13;
    &gt; window.frames[0].window.frames; &#13;
    &gt; frames[0].window; &#13;
    &gt; frames[0]; &#13;
</pre><p>From the parent page, you can access properties of the child frame as well. For example, you can reload the frame as follows:</p><pre class="programlisting">    &gt; frames[0].window.location.reload(); &#13;
</pre><p>From inside the child, you can access the parent as follows:</p><pre class="programlisting">    &gt; frames[0].parent === window; &#13;
           true &#13;
</pre><p>Using a property called <code class="literal">top</code>, you can access the top-most page-the one that contains all the other frames-from within any frame, as follows:</p><pre class="programlisting">    &gt; window.frames[0].window.top === window; &#13;
           true &#13;
    &gt; window.frames[0].window.top === window.top; &#13;
           true &#13;
    &gt; window.frames[0].window.top === top; &#13;
           true &#13;
</pre><p>In addition, <code class="literal">self</code> is the same as <code class="literal">window</code>, as you can see in the following code snippet:</p><pre class="programlisting">    &gt; self === window; &#13;
           true &#13;
    &gt; frames[0].self == frames[0].window; &#13;
           true &#13;
</pre><p>If a frame has a <code class="literal">name</code> attribute, you cannot only access the frame by name, but also by index, as shown in the following piece of code:</p><pre class="programlisting">    &gt; window.frames['myframe'] === window.frames[0]; &#13;
           true &#13;
</pre><p>Or, alternatively, you can use the following code:</p><pre class="programlisting">    &gt; frames.myframe === window.frames[0]; &#13;
           true &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec118"/>Using window.screen property</h2></div></div></div><p>The <code class="literal">screen</code> property provides information about the environment outside the browser. For example, the <code class="literal">screen.colorDepth</code> property contains the color bit depth (the color quality) of the monitor. This is mostly used for statistical purposes. Take a look at the following line of code:</p><pre class="programlisting">    &gt; window.screen.colorDepth; &#13;
           32 &#13;
</pre><p>You can also check the available screen real estate (the resolution), as follows:</p><pre class="programlisting">    &gt; screen.width; &#13;
           1440 &#13;
    &gt; screen.availWidth; &#13;
           1440 &#13;
    &gt; screen.height; &#13;
           900 &#13;
    &gt; screen.availHeight; &#13;
           847 &#13;
</pre><p>The difference between <code class="literal">height</code> and <code class="literal">availHeight</code> is that <code class="literal">height</code> is the whole screen, while <code class="literal">availHeight</code> subtracts any operating system menus, such as the Windows task bar. The same is the case for <code class="literal">width</code> and <code class="literal">availWidth</code>.</p><p>Somewhat related is the property mentioned in the following code:</p><pre class="programlisting">    &gt; window.devicePixelRatio; &#13;
           1 &#13;
</pre><p>It tells you the difference (ratio) between physical pixels and device pixels in the retina displays in mobile devices, for example, value 2 in iPhone.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec119"/>window.open()/close() method</h2></div></div></div><p>Having explored some of the most common cross-browser properties of the <code class="literal">window</code> object, let's move to some of the methods. One such method is <code class="literal">open()</code>, which allows you to open new browser windows (pop ups). Various browser policies and user settings may prevent you from opening a pop up (due to abuse of the technique for marketing purposes), but generally, you should be able to open a new window if it was initiated by the user. Otherwise, if you try to open a pop up as the page loads, it will most likely be blocked, because the user didn't initiate it explicitly.</p><p>The <code class="literal">window.open()</code> method accepts the following parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">URL to load in the new window</li><li class="listitem" style="list-style-type: disc">Name of the new window that can be used as the value of a form's <code class="literal">target</code> attribute</li><li class="listitem" style="list-style-type: disc">Comma-separated list of features, which is as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">resizable</code>: Should the user be able to resize the new window</li><li class="listitem" style="list-style-type: disc"><code class="literal">width</code>, <code class="literal">height</code>: Width and height of the pop up</li><li class="listitem" style="list-style-type: disc"><code class="literal">status</code>: Should the status bar be visible</li></ul></div><p>
</p></li></ul></div><p>The <code class="literal">window.open()</code> method returns a reference to the <code class="literal">window</code> object of the newly created browser instance. The following is an example:</p><pre class="programlisting">    var win = window.open('http://www.packtpub.com', 'packt', &#13;
      'width=300,height=300,resizable=yes'); &#13;
</pre><p>The<code class="literal"> win</code> variable points to the <code class="literal">window</code> object of the pop up. You can check if <code class="literal">win</code> has a falsy value, which means that the pop up was blocked.</p><p>The<code class="literal"> win.close()</code> method closes the new window.</p><p>It's best to stay away from opening new windows for accessibility and usability reasons. If you don't like sites popping up windows to you, why do it to your users? There are legitimate purposes, such as providing help information while filling out a form, but often, the same can be achieved with alternative solutions, such as using a floating <code class="literal">&lt;div&gt;</code> inside the page.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec120"/>window.moveTo() and window.resizeTo() methods</h2></div></div></div><p>Continuing with the shady practices from the past, the following are more methods to irritate your users, provided their browser and personal settings allow you to do so:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">window.moveTo(100, 100)</code>: This moves the browser window to screen location <code class="literal">x = 100</code> and <code class="literal">y = 100</code>, which is counted from the top-left corner</li><li class="listitem" style="list-style-type: disc"><code class="literal">window.moveBy(10, -10)</code>: This moves the window 10 pixels to the right and 10 pixels up from its current location</li><li class="listitem" style="list-style-type: disc"><code class="literal">window.resizeTo(x, y)</code> and <code class="literal">window.resizeBy(x, y)</code>: These accept the same parameters as the move methods, but they resize the window as opposed to moving it</li></ul></div><p>Again, try to solve the problem you're facing without resorting to these methods.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec121"/>window.alert(), window.prompt(), and window.confirm() methods</h2></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions">Chapter 2</a>, <em>Primitive Data Types, Arrays, Loops, and Conditions</em>, we talked about the <code class="literal">alert()</code> function. Now you know that global functions are accessible as methods of the global object, so <code class="literal">alert('Watch</code>
<code class="literal">out!')</code> and <code class="literal">window.alert('Watch</code>
<code class="literal">out!')</code> are exactly the same.</p><p>The <code class="literal">alert()</code> function is not an ECMAScript function but a BOM method. In addition to it, two other BOM methods allow you to interact with the user through system messages. The following are the methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">confirm()</code>: This gives the user two options, <strong>OK</strong> and <strong>Cancel</strong></li><li class="listitem" style="list-style-type: disc"><code class="literal">prompt()</code>: This collects textual input</li></ul></div><p>This is how it works:</p><pre class="programlisting">    &gt; var answer = confirm('Are you cool?');  &#13;
    &gt; answer; &#13;
</pre><p>It presents you with a window similar to the following screenshot (the exact look depends on the browser and the operating system):</p><p>
</p><div><img src="img/image_10_002.jpg" alt="window.alert(), window.prompt(), and window.confirm() methods"/></div><p>
</p><p>You'll notice the following things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Nothing gets written to the console until you close this message, which means that any JavaScript code execution freezes, waiting for the user's answer</li><li class="listitem" style="list-style-type: disc">Clicking on <strong>OK</strong> returns <code class="literal">true</code>, clicking on <strong>Cancel</strong> or closing the message using the <strong>X</strong> icon, or the <strong>ESC</strong> key, returns <code class="literal">false</code></li></ul></div><p>This is handy to confirm user actions, as shown in the following piece of code:</p><pre class="programlisting">    if (confirm('Sure you want to delete this?')) { &#13;
      // delete &#13;
    } else { &#13;
      // abort &#13;
    } &#13;
</pre><p>Make sure you provide an alternative way to confirm user actions for people who have disabled JavaScript, or for search engine spiders.</p><p>The <code class="literal">window.prompt()</code> method presents the user with a dialog to enter text, as follows:</p><pre class="programlisting">    &gt; var answer = prompt('And your name was?');  &#13;
    &gt; answer; &#13;
</pre><p>This results in the following dialog box (Chrome, MacOS):</p><p>
</p><div><img src="img/image_10_003-e1482823176627.jpg" alt="window.alert(), window.prompt(), and window.confirm() methods"/></div><p>
</p><p>The value of <code class="literal">answer</code> is one of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">null</code>: This happens if you click on <strong>Cancel</strong>, the <strong>X</strong> icon, or press <strong>ESC</strong> key</li><li class="listitem" style="list-style-type: disc"><code class="literal">""</code> (empty string): This happens if you click on OK or press Enter without typing anything</li><li class="listitem" style="list-style-type: disc">A text string: This is if you type something and then click on <strong>OK</strong> or press <strong>Enter</strong></li></ul></div><p>The function also takes a string as a second parameter and displays it as a default value prefilled into the input field.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec122"/>Using window.setTimeout() and window.setInterval() methods</h2></div></div></div><p>The <code class="literal">setTimeout()</code>and <code class="literal">setInterval()</code> methods allow scheduling the execution of a piece of code. The <code class="literal">setTimeout()</code> method attempts to execute the given code once, after a specified number of milliseconds. The <code class="literal">setInterval()</code> method attempts to execute it repeatedly after a specified number of milliseconds has passed.</p><p>This shows an alert after approximately 2 seconds (2000 milliseconds). Consider the following code:</p><pre class="programlisting">    &gt; function boo() { alert('Boo!'); } &#13;
    &gt; setTimeout(boo, 2000); &#13;
           4 &#13;
</pre><p>As you can see, the function returned an integer (in this case, <code class="literal">4</code>) representing the ID of the timeout. You can use this ID to cancel the timeout using <code class="literal">clearTimeout()</code>. In the following example, if you're quick enough, and clear the timeout before 2 seconds have passed, the alert will never be shown, as you can see in the following code:</p><pre class="programlisting">    &gt; var id = setTimeout(boo, 2000); &#13;
    &gt; clearTimeout(id); &#13;
</pre><p>Let's change <code class="literal">boo()</code>to something less intrusive, as follows:</p><pre class="programlisting">    &gt; function boo() { console.log('boo'); } &#13;
</pre><p>Now, using <code class="literal">setInterval()</code>, you can schedule <code class="literal">boo()</code> to execute every 2 seconds, until you cancel the scheduled execution with <code class="literal">clearInterval()</code>. Consider the following code:</p><pre class="programlisting">    &gt; var id = setInterval(boo, 2000); &#13;
           boo &#13;
           boo &#13;
           boo &#13;
           boo &#13;
           boo &#13;
           boo &#13;
    &gt; clearInterval(id); &#13;
</pre><p>Note that both functions accept a pointer to a callback function as a first parameter. They can also accept a string, which is evaluated with <code class="literal">eval();</code> however, as you know, <code class="literal">eval()</code> is evil, so it should be avoided. Moreover, what if you want to pass arguments to the function? In such cases, you can just wrap the function call inside another function.</p><p>The following code is valid, but not recommended:</p><pre class="programlisting">    // bad idea &#13;
    var id = setInterval("alert('boo, boo')", 2000); &#13;
</pre><p>This alternative is preferred:</p><pre class="programlisting">    var id = setInterval( &#13;
      function () { &#13;
        alert('boo, boo'); &#13;
      }, &#13;
      2000 &#13;
    ); &#13;
</pre><p>Be aware that scheduling a function in some amount of milliseconds is not a guarantee that it will execute exactly at that time. One reason is that most browsers don't have millisecond resolution time. If you schedule something in 3 milliseconds, it will execute after a minimum of 15 in older IEs and sooner in more modern browsers, but most likely, not in 1 millisecond. The other reason is that the browsers maintain a queue of what you request them to do. 100 milliseconds timeout means add to the queue after 100 milliseconds. However, if the queue is delayed by something slow happening, your function will have to wait and execute after, say, 120 milliseconds.</p><p>More recent browsers implement the <code class="literal">requestAnimationFrame()</code> function. It's preferable to the timeout functions because you're asking the browser to call your function whenever it has available resources, not after a predefined time in milliseconds. Try executing the following code snippet in your console:</p><pre class="programlisting">    function animateMe() { &#13;
      webkitRequestAnimationFrame(function(){ &#13;
        console.log(new Date()); &#13;
        animateMe(); &#13;
      }); &#13;
    } &#13;
 &#13;
    animateMe(); &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec123"/>window.document property</h2></div></div></div><p>The <code class="literal">window.document</code> property is a BOM object that refers to the currently loaded document (page). Its methods and properties fall into the DOM category of objects. Take a deep breath (and maybe first look at the BOM exercises at the end of the chapter) and let's dive into the DOM.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec80"/>DOM</h1></div></div></div><p>The DOM represents an XML or an HTML document as a tree of nodes. Using DOM methods and properties, you can access any element on the page, modify or remove elements, or add new ones. The DOM is a language-independent API and can be implemented not only in JavaScript, but also in any other language. For example, you can generate pages on the server-side with PHP's DOM implementation (<a class="ulink" href="http://php.net/dom">http://php.net/dom</a>).</p><p>Take a look at this example HTML page:</p><pre class="programlisting">    &lt;!DOCTYPE html&gt; &#13;
    &lt;html&gt; &#13;
      &lt;head&gt; &#13;
        &lt;title&gt;My page&lt;/title&gt; &#13;
      &lt;/head&gt; &#13;
      &lt;body&gt; &#13;
        &lt;p class="opener"&gt;first paragraph&lt;/p&gt; &#13;
        &lt;p&gt;&lt;em&gt;second&lt;/em&gt; paragraph&lt;/p&gt; &#13;
        &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
        &lt;!-- and that's about it --&gt; &#13;
      &lt;/body&gt; &#13;
    &lt;/html&gt; &#13;
</pre><p>Consider the second paragraph <code class="literal">(&lt;p&gt;&lt;em&gt;second&lt;/em&gt; paragraph&lt;/p&gt;</code>). You will see that it's a <code class="literal">&lt;p&gt;</code> tag, and it's contained in the <code class="literal">&lt;body&gt;</code> tag. If you think in terms of family relationships, you can say that <code class="literal">&lt;body&gt;</code> is the parent of <code class="literal">&lt;p&gt;</code> and <code class="literal">&lt;p&gt;</code> is the child. The first and the third paragraphs would also be children of the <code class="literal">&lt;body&gt;</code> tag, and at the same time, siblings of the second paragraph. The <code class="literal">&lt;em&gt;</code> tag is a child of the second <code class="literal">&lt;p&gt;</code>, so <code class="literal">&lt;p&gt;</code> is its parent. The parent-child relationships can be represented graphically in an ancestry tree, called the DOM tree:</p><p>
</p><div><img src="img/image_10_004.jpg" alt="DOM"/></div><p>
</p><p>The previous screenshot shows what you'll see in the WebKit console's <strong>Elements</strong> tab after you expand each node.</p><p>You can see how all of the tags are shown as expandable nodes on the tree. Although not shown, there exists the so-called text nodes, for example, the text inside the <code class="literal">&lt;em&gt;</code> tag (the word second) is a text node. Whitespace is also considered a text node. Comments inside the HTML code are also nodes in the tree, the <code class="literal">&lt;!- and that's about it -&gt;</code> comment in the HTML source is a comment node in the tree.</p><p>Every node in the DOM tree is an object and the <strong>Properties</strong> section on the right lists all of the properties and methods you can use to work with these objects, following the inheritance chain of how this object was created:</p><p>
</p><div><img src="img/image_10_005.jpg" alt="DOM"/></div><p>
</p><p>You can also see the constructor function that was used behind the scenes to create each of these objects. Although, this is not too practical for day-to-day tasks, it may be interesting to know that, for example, <code class="literal">&lt;p&gt;</code> is created by the <code class="literal">HTMLParagraphElement()</code> constructor, the object that represents the <code class="literal">head</code> tag is created by <code class="literal">HTMLHeadElement()</code>, and so on. You cannot create objects using these constructors directly, though.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec124"/>Core DOM and HTML DOM</h2></div></div></div><p>One last diversion before moving on to more practical examples. As you now know, the DOM represents both XML documents and HTML documents. In fact, HTML documents are XML documents, but a little more specific. Therefore, as part of DOM Level 1, there is a Core DOM specification that is applicable to all XML documents, and there is also an HTML DOM specification, which extends and builds upon the core DOM. Of course, the HTML DOM doesn't apply to all XML documents, but only to HTML documents. Let's see some examples of Core DOM and HTML DOM constructors:</p><div><table border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th>
<p>
<strong>Constructor</strong>
</p>
</th><th>
<p>
<strong>Inherits from</strong>
</p>
</th><th>
<p>
<strong>Core or HTML</strong>
</p>
</th><th>
<p>
<strong>Comment</strong>
</p>
</th></tr></thead><tbody><tr><td>
<p>
<code class="literal">Node</code>
</p>
</td><td>
</td><td>
<p>Core</p>
</td><td>
<p>Any node on the tree</p>
</td></tr><tr><td>
<p>
<code class="literal">Document</code>
</p>
</td><td>
<p>
<code class="literal">Node</code>
</p>
</td><td>
<p>Core</p>
</td><td>
<p>The document object, the main entry point to any XML document</p>
</td></tr><tr><td>
<p>
<code class="literal">HTMLDocument</code>
</p>
</td><td>
<p>
<code class="literal">Document</code>
</p>
</td><td>
<p>HTML</p>
</td><td>
<p>This is window.document or simply document, the HTML-specific version of the previous object, which you'll use extensively</p>
</td></tr><tr><td>
<p>
<code class="literal">Element</code>
</p>
</td><td>
<p>
<code class="literal">Node</code>
</p>
</td><td>
<p>Core</p>
</td><td>
<p>Every tag in the source is represented by an element. That's why you say-the <code class="literal">P</code> element meaning the <code class="literal">&lt;p&gt;&lt;/p&gt;</code> tag</p>
</td></tr><tr><td>
<p>
<code class="literal">HTMLElement</code>
</p>
</td><td>
<p>
<code class="literal">Element</code>
</p>
</td><td>
<p>HTML</p>
</td><td>
<p>General-purpose constructor, all constructors for HTML elements inherit from it</p>
</td></tr><tr><td>
<p>
<code class="literal">HTMLBodyElement</code>
</p>
</td><td>
<p>
<code class="literal">HTMLElement</code>
</p>
</td><td>
<p>HTML</p>
</td><td>
<p>Element representing the <code class="literal">&lt;body&gt;</code> tag</p>
</td></tr><tr><td>
<p>
<code class="literal">HTMLLinkElement</code>
</p>
</td><td>
<p>
<code class="literal">HTMLElement</code>
</p>
</td><td>
<p>HTML</p>
</td><td>
<p>An A element: an <code class="literal">&lt;a href="..."&gt;&lt;/a&gt;</code> tag</p>
</td></tr><tr><td>
<p>And other such constructors</p>
</td><td>
<p>
<code class="literal">HTMLElement</code>
</p>
</td><td>
<p>HTML</p>
</td><td>
<p>All the rest of the HTML elements</p>
</td></tr><tr><td>
<p>
<code class="literal">CharacterData</code>
</p>
</td><td>
<p>
<code class="literal">Node</code>
</p>
</td><td>
<p>Core</p>
</td><td>
<p>General-purpose constructor for dealing with texts</p>
</td></tr><tr><td>
<p>
<code class="literal">Text</code>
</p>
</td><td>
<p>
<code class="literal">CharacterData</code>
</p>
</td><td>
<p>Core</p>
</td><td>
<p>Text node inside a tag; in <code class="literal">&lt;em&gt;</code>second<code class="literal">&lt;/em&gt;</code>, you have the element node <code class="literal">EM</code> and the text node with value second</p>
</td></tr><tr><td>
<p>
<code class="literal">Comment</code>
</p>
</td><td>
<p>
<code class="literal">CharacterData</code>
</p>
</td><td>
<p>Core</p>
</td><td>
<p>
<code class="literal">&lt;!-- any comment --&gt;</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">Attr</code>
</p>
</td><td>
<p>
<code class="literal">Node</code>
</p>
</td><td>
<p>Core</p>
</td><td>
<p>Represents an attribute of a tag; in <code class="literal">&lt;p id="closer"&gt;</code>, the <code class="literal">id</code> attribute is a DOM object created by the <code class="literal">Attr()</code> constructor</p>
</td></tr><tr><td>
<p>
<code class="literal">NodeList</code>
</p>
</td><td>
</td><td>
<p>Core</p>
</td><td>
<p>A list of nodes, an array-like object that has a <code class="literal">length</code> property</p>
</td></tr><tr><td>
<p>
<code class="literal">NamedNodeMap</code>
</p>
</td><td>
</td><td>
<p>Core</p>
</td><td>
<p>Same as <code class="literal">NodeList</code>, but the nodes can be accessed by name, not only by numeric index.</p>
</td></tr><tr><td>
<p>
<code class="literal">HTMLCollection</code>
</p>
</td><td>
</td><td>
<p>HTML</p>
</td><td>
<p>Similar to <code class="literal">NamedNodeMap</code> but specific for HTML.</p>
</td></tr></tbody></table></div><p>These are, by no means, all of the Core DOM and HTML DOM objects. For the full list, consult <a class="ulink" href="http://www.w3.org/TR/DOM-Level-1/">http://www.w3.org/TR/DOM-Level-1/</a>.</p><p>Now that this bit of the DOM theory is behind you, let's focus on the practical side of working with the DOM. In the following sections, you'll learn how to do the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access DOM nodes</li><li class="listitem" style="list-style-type: disc">Modify nodes</li><li class="listitem" style="list-style-type: disc">Create new nodes</li><li class="listitem" style="list-style-type: disc">Remove nodes</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec125"/>Accessing DOM nodes</h2></div></div></div><p>Before you can validate the user input in a form on a page or swap an image, you need to get access to the element you want to inspect or modify. Luckily, there are many ways to get to any element, either by navigating around traversing the DOM tree or by using a shortcut.</p><p>It's best if you start experimenting with all of the new objects and methods. The examples you'll see use the same simple document that you saw at the beginning of the DOM section, and which you can access at <a class="ulink" href="http://www.phpied.com/files/jsoop/ch7.html">http://www.phpied.com/files/jsoop/ch7.html</a>. Open your console, and let's get started.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec58"/>The document node</h3></div></div></div><p>The <code class="literal">document</code> node gives you access to the current document. To explore this object, you can use your console as a cheat sheet. Type <code class="literal">console.dir</code>(document) and click on the result:</p><p>
</p><div><img src="img/image_10_006.jpg" alt="The document node"/></div><p>
</p><p>Alternatively, you can browse all of the properties and methods of the <code class="literal">document</code> object DOM properties in the <strong>Elements</strong> panel:</p><p>
</p><div><img src="img/image_10_007.jpg" alt="The document node"/></div><p>
</p><p>All nodes, including the document node, text nodes, element nodes, and attribute nodes have <code class="literal">nodeType</code>, <code class="literal">nodeName</code> and <code class="literal">nodeValue</code> properties:</p><pre class="programlisting">    &gt; document.nodeType; &#13;
           9 &#13;
</pre><p>There are 12 node types, represented by integers. As you can see, the document node type is <code class="literal">9</code>. The most commonly used are <code class="literal">1</code> (element), <code class="literal">2</code> (attribute), and <code class="literal">3</code> (text).</p><p>Nodes also have names. For HTML tags, the node name is the tag name (<code class="literal">tagName</code> property). For text nodes, it's <code class="literal">#text</code>, and for document nodes, the name is as follows:</p><pre class="programlisting">    &gt; document.nodeName; &#13;
           "#document" &#13;
</pre><p>Nodes can also have node values. For example, for text nodes, the value is the actual text. The document node doesn't have a value, which can be seen as follows:</p><pre class="programlisting">    &gt; document.nodeValue; &#13;
           null &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec59"/>documentElement</h3></div></div></div><p>Now, let's move around the tree. XML documents always have one root node that wraps the rest of the document. For HTML documents, the root is the <code class="literal">&lt;html&gt;</code> tag. To access the root, you will use the <code class="literal">documentElement</code> property of the <code class="literal">document</code> object.</p><pre class="programlisting">    &gt; document.documentElement; &#13;
           &lt;html&gt;...&lt;/html&gt; &#13;
</pre><p>
<code class="literal">nodeType</code> is <code class="literal">1</code> (an element node) which can be seen as follows:</p><pre class="programlisting">    &gt; document.documentElement.nodeType; &#13;
           1 &#13;
</pre><p>For element nodes, both <code class="literal">nodeName</code> and <code class="literal">tagName</code> properties contain the name of the tag, as seen in the following output:</p><pre class="programlisting">    &gt; document.documentElement.nodeName; &#13;
           "HTML" &#13;
    &gt; document.documentElement.tagName; &#13;
           "HTML" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec60"/>Child nodes</h3></div></div></div><p>In order to tell if a node has any children, you will use <code class="literal">hasChildNodes()</code>, as follows:</p><pre class="programlisting">    &gt; document.documentElement.hasChildNodes(); &#13;
           true &#13;
</pre><p>The HTML element has three children, the <code class="literal">head</code> and the <code class="literal">body</code> elements and the whitespace between them (whitespace is counted in most, but not all browsers). You can access them using the <code class="literal">childNodes</code> array-like collection, as follows:</p><pre class="programlisting">    &gt; document.documentElement.childNodes.length; &#13;
           3 &#13;
    &gt; document.documentElement.childNodes[0]; &#13;
           &lt;head&gt;...&lt;/head&gt; &#13;
    &gt; document.documentElement.childNodes[1]; &#13;
           #text &#13;
    &gt; document.documentElement.childNodes[2]; &#13;
           &lt;body&gt;...&lt;/body&gt; &#13;
</pre><p>Any child has access to its parent through the <code class="literal">parentNode</code> property, as seen in the following code:</p><pre class="programlisting">    &gt; document.documentElement.childNodes[1].parentNode; &#13;
           &lt;html&gt;...&lt;/html&gt; &#13;
</pre><p>Let's assign a reference to body to a variable, as follows:</p><pre class="programlisting">    &gt; var bd = document.documentElement.childNodes[2]; &#13;
</pre><p>How many children does the <code class="literal">body</code> element have? Consider the following piece of code</p><pre class="programlisting">    &gt; bd.childNodes.length; &#13;
           9 &#13;
</pre><p>As a refresher, here, again, is the body of the document:</p><pre class="programlisting">      &lt;body&gt; &#13;
        &lt;p class="opener"&gt;first paragraph&lt;/p&gt; &#13;
        &lt;p&gt;&lt;em&gt;second&lt;/em&gt; paragraph&lt;/p&gt; &#13;
        &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
        &lt;!-- and that's about it --&gt; &#13;
      &lt;/body&gt; &#13;
</pre><p>How come body has <code class="literal">9</code> children? Well, three paragraphs plus one comment makes four nodes. The whitespace between these four nodes makes three more text nodes. This makes a total of seven so far. The whitespace between <code class="literal">&lt;body&gt;</code> and the first <code class="literal">&lt;p&gt;</code> is the eighth node. The whitespace between the comment and the closing <code class="literal">&lt;/body&gt;</code> is another text node. This makes a total of nine child nodes. Just type <code class="literal">bd.childNodes</code> in the console to inspect them all.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec61"/>Attributes</h3></div></div></div><p>As the first child of the body is a whitespace, the second child (index 1) is the first paragraph. Refer to the following piece of code:</p><pre class="programlisting">    &gt; bd.childNodes[1]; &#13;
           &lt;p class="opener"&gt;first paragraph&lt;/p&gt; &#13;
</pre><p>You can check whether an element has attributes using <code class="literal">hasAttributes()</code>, as follows:</p><pre class="programlisting">    &gt; bd.childNodes[1].hasAttributes(); &#13;
            true &#13;
</pre><p>How many attributes? In this example, one is the <code class="literal">class</code> attribute, which can be seen as follows:</p><pre class="programlisting">    &gt; bd.childNodes[1].attributes.length; &#13;
            1 &#13;
</pre><p>You can access the attributes by index and name. You can also get the value using the <code class="literal">getAttribute()</code> method, which is as follows:</p><pre class="programlisting">    &gt; bd.childNodes[1].attributes[0].nodeName; &#13;
           "class" &#13;
    &gt; bd.childNodes[1].attributes[0].nodeValue; &#13;
           "opener" &#13;
    &gt; bd.childNodes[1].attributes['class'].nodeValue; &#13;
           "opener" &#13;
    &gt; bd.childNodes[1].getAttribute('class'); &#13;
           "opener" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec62"/>Accessing the content inside a tag</h3></div></div></div><p>Let's take a look at the first paragraph:</p><pre class="programlisting">    &gt; bd.childNodes[1].nodeName; &#13;
           "P" &#13;
</pre><p>You can get the text contained in the paragraph using the <code class="literal">textContent</code> property. It doesn't exist in older IEs, but another property called <code class="literal">innerText</code> returns the same value, as seen in the following output:</p><pre class="programlisting">    &gt; bd.childNodes[1].textContent; &#13;
           "first paragraph" &#13;
</pre><p>There is also the <code class="literal">innerHTML</code> property. It's a relatively new addition to the DOM standard, despite the fact that it previously existed in all major browsers. It returns (or sets) HTML code contained in a node. You can see how this is a little inconsistent as DOM treats the document as a tree of nodes, not as a string of tags. However, <code class="literal">innerHTML</code> is so convenient to use that you'll see it everywhere. Refer to the following code:</p><pre class="programlisting">    &gt; bd.childNodes[1].innerHTML; &#13;
           "first paragraph" &#13;
</pre><p>The first paragraph contains only text, so <code class="literal">innerHTML</code> is the same as <code class="literal">textContent</code> (or <code class="literal">innerText</code> in IE). However, the second paragraph does contain an <code class="literal">em</code> node, so you can see the difference as follows:</p><pre class="programlisting">    &gt; bd.childNodes[3].innerHTML; &#13;
           "&lt;em&gt;second&lt;/em&gt; paragraph" &#13;
    &gt; bd.childNodes[3].textContent; &#13;
           "second paragraph" &#13;
</pre><p>Another way to get the text contained in the first paragraph is by using the <code class="literal">nodeValue</code> method of the text node contained inside the <code class="literal">p</code> node, as follows:</p><pre class="programlisting">    &gt; bd.childNodes[1].childNodes.length; &#13;
            1 &#13;
    &gt; bd.childNodes[1].childNodes[0].nodeName; &#13;
           "#text" &#13;
    &gt; bd.childNodes[1].childNodes[0].nodeValue; &#13;
           "first paragraph" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec63"/>DOM access shortcuts</h3></div></div></div><p>Using <code class="literal">childNodes</code>, <code class="literal">parentNode</code>, <code class="literal">nodeName</code>, <code class="literal">nodeValue</code>, and <code class="literal">attributes</code>, you can navigate up and down the tree and do anything with the document. However, the fact that whitespace is a text node makes this a fragile way of working with the DOM. If the page changes, your script may no longer work correctly. Also, if you want to get to a node deeper in the tree, it could take a bit of code before you get there. That's why you have shortcut methods, namely, <code class="literal">getElementsByTagName()</code>, <code class="literal">getElementsByName()</code>, and <code class="literal">getElementById()</code>.</p><p>The <code class="literal">getElementsByTagName()</code> method takes a tag name (the name of an element node) and returns an HTML collection (array-like object) of nodes with the matching tag name. For example, the following example asks-give me a count of all paragraphs, which is given as follows:</p><pre class="programlisting">    &gt; document.getElementsByTagName('p').length; &#13;
            3 &#13;
</pre><p>You can access an item in the list using the brackets notation, or the <code class="literal">item()</code>method, and passing the index (0 for the first element). Using <code class="literal">item()</code> is discouraged, as array brackets are more consistent and also shorter to type. Refer to the following piece of code:</p><pre class="programlisting">    &gt; document.getElementsByTagName('p')[0]; &#13;
            &lt;p class="opener"&gt;first paragraph&lt;/p&gt; &#13;
    &gt; document.getElementsByTagName('p').item(0); &#13;
            &lt;p class="opener"&gt;first paragraph&lt;/p&gt; &#13;
</pre><p>Getting the contents of the first <code class="literal">p</code> can be done as follows:</p><pre class="programlisting">    &gt; document.getElementsByTagName('p')[0].innerHTML; &#13;
           "first paragraph" &#13;
</pre><p>Accessing the last <code class="literal">p</code> can be done as follows:</p><pre class="programlisting">    &gt; document.getElementsByTagName('p')[2]; &#13;
            &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
</pre><p>To access the attributes of an element, you can use the <code class="literal">attributes</code> collection or <code class="literal">getAttribute()</code>, as shown previously. However, a shorter way is to use the attribute name as a property of the element you're working with. So, to get the value of the <code class="literal">id</code> attribute, you will just use <code class="literal">id</code> as a property, which is as follows:</p><pre class="programlisting">    &gt; document.getElementsByTagName('p')[2].id; &#13;
           "closer" &#13;
</pre><p>Getting the <code class="literal">class</code> attribute of the first paragraph won't work though. It's an exception because it just happens so that class is a reserved word in ECMAScript. You can use <code class="literal">className</code> instead, as follows:</p><pre class="programlisting">    &gt; document.getElementsByTagName('p')[0].className; &#13;
           "opener" &#13;
</pre><p>Using <code class="literal">getElementsByTagName()</code>, you can get all of the elements on the page, as follows:</p><pre class="programlisting">    &gt; document.getElementsByTagName('*').length; &#13;
            8 &#13;
</pre><p>In earlier versions of IE before IE7, <code class="literal">*</code> is not acceptable as a tag name. To get all elements, you can use IE's proprietary <code class="literal">document.all</code> collection, although, selecting every element is rarely needed.</p><p>The other shortcut mentioned is <code class="literal">getElementById()</code>. This is probably the most common way of accessing an element. You just assign IDs to the elements you plan to play with and they'll be easy to access later on, as seen in the following code:</p><pre class="programlisting">    &gt; document.getElementById('closer'); &#13;
    &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
</pre><p>Additional shortcut methods in more recent browsers include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getElementByClassName()</code>:This method finds elements using their class attribute</li><li class="listitem" style="list-style-type: disc"><code class="literal">querySelector()</code>: This method finds an element using a CSS selector string</li><li class="listitem" style="list-style-type: disc"><code class="literal">querySelectorAll()</code>: This method is the same as the previous one but returns all matching elements, not just the first</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec64"/>Siblings, body, first, and last child</h3></div></div></div><p>The <code class="literal">nextSibling</code> and <code class="literal">previousSibling</code> are two other convenient properties to navigate the DOM tree once you have a reference to one element. Consider the following code:</p><pre class="programlisting">    &gt; var para = document.getElementById('closer'); &#13;
    &gt; para.nextSibling; &#13;
           #text &#13;
    &gt; para.previousSibling; &#13;
           #text &#13;
    &gt; para.previousSibling.previousSibling; &#13;
           &lt;p&gt;...&lt;/p&gt; &#13;
    &gt; para.previousSibling.previousSibling.previousSibling; &#13;
           #text &#13;
    &gt; para.previousSibling.previousSibling.nextSibling.nextSibling; &#13;
           &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
</pre><p>The <code class="literal">body</code> element is used so often that it has its own shortcut, which is as follows:</p><pre class="programlisting">    &gt; document.body; &#13;
            &lt;body&gt;...&lt;/body&gt; &#13;
    &gt; document.body.nextSibling; &#13;
            null &#13;
    &gt; document.body.previousSibling.previousSibling; &#13;
            &lt;head&gt;...&lt;/head&gt; &#13;
</pre><p>The <code class="literal">firstChild</code> and <code class="literal">lastChild</code> properties are also convenient. The <code class="literal">firstChild</code> property is the same as <code class="literal">childNodes[0]</code> and <code class="literal">lastChild</code> is the same as <code class="literal">childNodes[childNodes.length - 1]</code> properties:</p><pre class="programlisting">    &gt; document.body.firstChild; &#13;
           #text &#13;
    &gt; document.body.lastChild; &#13;
           #text &#13;
    &gt; document.body.lastChild.previousSibling; &#13;
            &lt;!-- and that's about it --&gt; &#13;
    &gt; document.body.lastChild.previousSibling.nodeValue; &#13;
           " and that's about it " &#13;
</pre><p>The following screenshot shows the family relationships between the body and the three paragraphs in it. For simplicity, all the whitespace text nodes are removed from the screenshot:</p><p>
</p><div><img src="img/image_10_008.jpg" alt="Siblings, body, first, and last child"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec65"/>Walk the DOM</h3></div></div></div><p>To wrap up, here's a function that takes any node and walks through the DOM tree recursively, starting from the given node, as follows:</p><pre class="programlisting">   function walkDOM(n) { &#13;
      do { &#13;
        console.log(n); &#13;
        if (n.hasChildNodes()) { &#13;
          walkDOM(n.firstChild); &#13;
        } &#13;
      } while (n = n.nextSibling); &#13;
    } &#13;
</pre><p>You can test the function as follows:</p><pre class="programlisting">    &gt; walkDOM(document.documentElement); &#13;
    &gt; walkDOM(document.body); &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec126"/>Modifying DOM nodes</h2></div></div></div><p>Now that you know a whole lot of methods to access any node of the DOM tree and its properties, let's see how you can modify these nodes:</p><p>Let's assign a pointer to the last paragraph to the variable <code class="literal">my</code>, as follows:</p><pre class="programlisting">    &gt; var my = document.getElementById('closer'); &#13;
</pre><p>Now, changing the text of the paragraph can be as easy as changing the <code class="literal">innerHTML</code> value, which is as follows:</p><pre class="programlisting">    &gt; my.innerHTML = 'final!!!'; &#13;
           "final!!!" &#13;
</pre><p>As <code class="literal">innerHTML</code> accepts a string of HTML source code, you can also create a new <code class="literal">em</code> node in the DOM tree as follows:</p><pre class="programlisting">    &gt; my.innerHTML = '&lt;em&gt;my&lt;/em&gt; final'; &#13;
           "&lt;em&gt;my&lt;/em&gt; final" &#13;
</pre><p>The new <code class="literal">em</code> node becomes a part of the tree. Lets take a look at the following code:</p><pre class="programlisting">    &gt; my.firstChild; &#13;
           &lt;em&gt;my&lt;/em&gt; &#13;
    &gt; my.firstChild.firstChild; &#13;
           "my" &#13;
</pre><p>Another way to change text is to get the actual text node and change its <code class="literal">nodeValue</code>, as shown in the following piece of code:</p><pre class="programlisting">    &gt; my.firstChild.firstChild.nodeValue = 'your'; &#13;
           "your" &#13;
</pre><div><div><div><div><h3 class="title"><a id="ch10lvl3sec66"/>Modifying styles</h3></div></div></div><p>Often you don't change the content of a node, but its presentation. The elements have a <code class="literal">style</code> property, which in turn has a property mapped to each CSS property. For example, changing the style of the paragraph to add a red border, as follows:</p><pre class="programlisting">    &gt; my.style.border = "1px solid red"; &#13;
           "1px solid red" &#13;
</pre><p>CSS properties often have dashes, but dashes are not acceptable in JavaScript identifiers. In such cases, you skip the dash and uppercase the next letter. So, <code class="literal">padding-top</code> becomes <code class="literal">paddingTop</code>, <code class="literal">margin-left</code> becomes <code class="literal">marginLeft</code>, and so on. Take a look at the following code:</p><pre class="programlisting">    &gt; my.style.fontWeight = 'bold'; &#13;
           "bold" &#13;
</pre><p>You also have access to the <code class="literal">cssText</code> property of <code class="literal">style</code>, which lets you work with styles as strings, as you can see in the following code snippet:</p><pre class="programlisting">    &gt; my.style.cssText; &#13;
           "border: 1px solid red; font-weight: bold;" &#13;
</pre><p>Moreover, modifying styles is a string manipulation:</p><pre class="programlisting">    &gt; my.style.cssText += " border-style: dashed;" &#13;
    "border: 1px dashed red; font-weight: bold; border-style: dashed;" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec67"/>Fun with forms</h3></div></div></div><p>As mentioned earlier, JavaScript is great for client-side input validation and can save a few round-trip to the server. Let's practice form manipulations and play a little bit with a form located on a popular page, <a class="ulink" href="http://www.google.com">www.google.com</a>:</p><p>
</p><div><img src="img/image_10_009.jpg" alt="Fun with forms"/></div><p>
</p><p>Finding the first text input using the <code class="literal">querySelector()</code> method and a CSS selector string is as follows:</p><pre class="programlisting">    &gt; var input = document.querySelector('input[type=text]'); &#13;
</pre><p>Accessing the search box. Consider the following code:</p><pre class="programlisting">    &gt; input.name; &#13;
           "q" &#13;
</pre><p>Changing the search query by setting the text contained in the <code class="literal">value</code> attribute is done as follows:</p><pre class="programlisting">    &gt; input.value = 'my query'; &#13;
<strong>           "my query"</strong>
</pre><p>Now, let's have some fun and change the word <strong>Lucky</strong> with <strong>Tricky</strong> in the button:</p><pre class="programlisting">    &gt; var feeling = document.querySelectorAll("button")[2]; &#13;
    &gt; feeling.textContent = feelingtextContent.replace(/Lu/, 'Tri'); &#13;
<strong>           "I'm Feeling Tricky"</strong>
</pre><p>
</p><div><img src="img/image_10_010.jpg" alt="Fun with forms"/></div><p>
</p><p>Now, let's implement the tricky part and make that button show and hide for one second. You can do this with a simple function. Let's call it <code class="literal">toggle()</code>. Every time you call the function, it checks the value of the CSS property <code class="literal">visibility</code>, and sets it to visible if it's hidden and vice versa using the following code snippet:</p><pre class="programlisting">    function toggle() { &#13;
      var st = document.querySelectorAll('button')[2].style; &#13;
      st.visibility = (st.visibility === 'hidden') &#13;
        ? 'visible' &#13;
        : 'hidden'; &#13;
    } &#13;
</pre><p>Instead of calling the function manually, let's set an interval and call it every second:</p><pre class="programlisting">    &gt; var myint = setInterval(toggle, 1000); &#13;
</pre><p>The result? The button starts blinking, making it trickier to click. When you're tired of chasing it, just remove the timeout interval by writing the following line of code:</p><pre class="programlisting">    &gt; clearInterval(myint); &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec127"/>Creating new nodes</h2></div></div></div><p>To create new nodes, you can use the <code class="literal">createElement()</code> and <code class="literal">createTextNode()</code> methods. Once you have the new nodes, you can add them to the DOM tree using <code class="literal">appendChild()</code>, <code class="literal">insertBefore()</code>, or <code class="literal">replaceChild()</code>.</p><p>Reload <a class="ulink" href="http://www.phpied.com/files/jsoop/ch7.html">http://www.phpied.com/files/jsoop/ch7.html</a> and let's play.</p><p>Create a new <code class="literal">p</code> element and set its <code class="literal">innerHTML</code>, as shown in the following code:</p><pre class="programlisting">    &gt; var myp = document.createElement('p'); &#13;
    &gt; myp.innerHTML = 'yet another'; &#13;
           "yet another" &#13;
</pre><p>The new element automatically gets all the default properties, such as <code class="literal">style</code>, which you can modify as follows:</p><pre class="programlisting">    &gt; myp.style; &#13;
           CSSStyleDeclaration &#13;
    &gt; myp.style.border = '2px dotted blue'; &#13;
           "2px dotted blue" &#13;
</pre><p>Using <code class="literal">appendChild()</code>, you can add the new node to the DOM tree. Calling this method on the <code class="literal">document.body</code> node means creating one more child node right after the last child, as follows:</p><pre class="programlisting">    &gt; document.body.appendChild(myp); &#13;
           &lt;p style="border: 2px dotted blue;"&gt;yet another&lt;/p&gt; &#13;
</pre><p>Here's an illustration of how the page looks like after the new node is appended:</p><p>
</p><div><img src="img/image_10_011.jpg" alt="Creating new nodes"/></div><p>
</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec68"/>DOM-only method</h3></div></div></div><p>The <code class="literal">innerHTML</code> property gets things done a little more quickly than using pure DOM. In pure DOM, you will need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new text node containing yet another text.</li><li class="listitem">Create a new paragraph node.</li><li class="listitem">Append the text node as a child to the paragraph.</li><li class="listitem">Append the paragraph as a child to the body.</li></ol></div><p>This way, you can create any number of text nodes and elements and nest them, however you like. Let's say, you want to add the following HTML to the end of the body:</p><pre class="programlisting">    &lt;p&gt;one more paragraph&lt;strong&gt;bold&lt;/strong&gt;&lt;/p&gt; &#13;
</pre><p>Presenting the preceding code as a hierarchy would be something like the following code snippet:</p><pre class="programlisting">    P element &#13;
        text node with value "one more paragraph" &#13;
        STRONG element &#13;
            text node with value "bold" &#13;
</pre><p>The code that accomplishes this is as follows:</p><pre class="programlisting">    // create P &#13;
    var myp = document.createElement('p'); &#13;
    // create text node and append to P &#13;
    var myt = document.createTextNode('one more paragraph'); &#13;
    myp.appendChild(myt); &#13;
    // create STRONG and append another text node to it &#13;
    var str = document.createElement('strong'); &#13;
    str.appendChild(document.createTextNode('bold')); &#13;
    // append STRONG to P &#13;
    myp.appendChild(str); &#13;
    // append P to BODY &#13;
    document.body.appendChild(myp); &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec69"/>Using cloneNode() method</h3></div></div></div><p>Another way to create nodes is by copying or cloning existing ones. The <code class="literal">cloneNode()</code> method does this and accepts a Boolean parameter (<code class="literal">true</code> = deep copy with all the children, <code class="literal">false</code> = shallow copy, only this node). Let's test the method.</p><p>Getting a reference to the element you want to clone can be done as follows:</p><pre class="programlisting">    &gt; var el = document.getElementsByTagName('p')[1]; &#13;
</pre><p>Now, <code class="literal">el</code> refers to the second paragraph on the page that looks like the following code:</p><pre class="programlisting">    &lt;p&gt;&lt;em&gt;second&lt;/em&gt; paragraph&lt;/p&gt; &#13;
</pre><p>Let's create a shallow clone of <code class="literal">el</code> and append it to the <code class="literal">body</code> as follows:</p><pre class="programlisting">    &gt; document.body.appendChild(el.cloneNode(false)); &#13;
</pre><p>You won't see a difference on the page because the shallow copy only copied the <code class="literal">P</code> node without any children. This means that the text inside the paragraph, which is a text node child, was not cloned. The preceding line will be equivalent to the following code line:</p><pre class="programlisting">    &gt; document.body.appendChild(document.createElement('p')); &#13;
</pre><p>However, if you create a deep copy, the whole DOM subtree starting from <code class="literal">P</code> is copied, and this includes text nodes and the <code class="literal">EM</code> element. This line copies (visually too) the second paragraph to the end of the document. Consider the following line of code:</p><pre class="programlisting">    &gt; document.body.appendChild(el.cloneNode(true)); &#13;
</pre><p>You can also copy only the <code class="literal">EM</code> if you want, as shown in the following lines of code:</p><pre class="programlisting">    &gt; document.body.appendChild(el.firstChild.cloneNode(true)); &#13;
           &lt;em&gt;second&lt;/em&gt; &#13;
</pre><p>Or, you can copy only the text node with value <code class="literal">second</code>, as follows:</p><pre class="programlisting">    &gt; document.body.appendChild( &#13;
        el.firstChild.firstChild.cloneNode(false)); &#13;
           "second" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec70"/>Using insertBefore() method</h3></div></div></div><p>Using <code class="literal">appendChild()</code>, you can only add new children at the end of the selected element. For more control over the exact location, there is <code class="literal">insertBefore()</code>. This is the same as <code class="literal">appendChild()</code>, but accepts an extra parameter specifying where (before which element) to insert the new node. For example, the following code inserts a text node at the end of the <code class="literal">body</code> element:</p><pre class="programlisting">    &gt; document.body.appendChild(document.createTextNode('boo!')); &#13;
</pre><p>Moreover, this creates another text node and adds it as the first child of the <code class="literal">body</code> element:</p><pre class="programlisting">    document.body.insertBefore( &#13;
      document.createTextNode('first boo!'), &#13;
      document.body.firstChild &#13;
    ); &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec128"/>Removing nodes</h2></div></div></div><p>To remove nodes from the DOM tree, you can use the <code class="literal">removeChild()</code> method. Again, let's start fresh with the same page with the body:</p><pre class="programlisting">      &lt;body&gt; &#13;
        &lt;p class="opener"&gt;first paragraph&lt;/p&gt; &#13;
        &lt;p&gt;&lt;em&gt;second&lt;/em&gt; paragraph&lt;/p&gt; &#13;
        &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
        &lt;!-- and that's about it --&gt; &#13;
      &lt;/body&gt; &#13;
</pre><p>Here's how you can remove the second paragraph:</p><pre class="programlisting">    &gt; var myp = document.getElementsByTagName('p')[1]; &#13;
    &gt; var removed = document.body.removeChild(myp); &#13;
</pre><p>The method returns the removed node if you want to use it later. You can still use all the DOM methods even though the element is no longer in the tree. Lets take a look on the following code:</p><pre class="programlisting">    &gt; removed; &#13;
           &lt;p&gt;...&lt;/p&gt; &#13;
    &gt; removed.firstChild; &#13;
           &lt;em&gt;second&lt;/em&gt; &#13;
</pre><p>There's also the <code class="literal">replaceChild()</code>method that removes a node and puts another one in its place.</p><p>After removing the node, the tree looks as follows:</p><pre class="programlisting">      &lt;body&gt; &#13;
        &lt;p class="opener"&gt;first paragraph&lt;/p&gt; &#13;
        &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
        &lt;!-- and that's about it --&gt; &#13;
      &lt;/body&gt; &#13;
</pre><p>Now, the second paragraph is the one with the ID <code class="literal">"closer"</code>, which is as follows:</p><pre class="programlisting">    &gt; var p = document.getElementsByTagName('p')[1]; &#13;
    &gt; p; &#13;
           &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
</pre><p>Let's replace this paragraph with the one in the <code class="literal">removed</code> variable. Consider the following code:</p><pre class="programlisting">    &gt; var replaced = document.body.replaceChild(removed, p); &#13;
</pre><p>Just like <code class="literal">removeChild()</code>, <code class="literal">replaceChild()</code> returns a reference to the node that is now out of the tree:</p><pre class="programlisting">    &gt; replaced; &#13;
           &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
</pre><p>Now, the body looks like the following piece of code:</p><pre class="programlisting">      &lt;body&gt; &#13;
        &lt;p class="opener"&gt;first paragraph&lt;/p&gt; &#13;
        &lt;p&gt;&lt;em&gt;second&lt;/em&gt; paragraph&lt;/p&gt; &#13;
        &lt;!-- and that's about it --&gt; &#13;
      &lt;/body&gt; &#13;
</pre><p>A quick way to wipe out all of the content of a subtree is to set <code class="literal">innerHTML</code> to a blank string. This removes all the children of the <code class="literal">body</code> element:</p><pre class="programlisting">    &gt; document.body.innerHTML = ''; &#13;
           "" &#13;
</pre><p>Testing is done as follows:</p><pre class="programlisting">    &gt; document.body.firstChild; &#13;
           null &#13;
</pre><p>Removing with <code class="literal">innerHTML</code> is fast and easy. The DOM-only way will be to go over all of the child nodes and remove each one individually. Here's a little function that removes all nodes from a given start node:</p><pre class="programlisting">    function removeAll(n) { &#13;
      while (n.firstChild) { &#13;
        n.removeChild(n.firstChild); &#13;
      } &#13;
    } &#13;
</pre><p>If you want to delete all the children from the <code class="literal">body</code> element and leave the page with an empty <code class="literal">&lt;body&gt;&lt;/body&gt;</code>, use the following code:</p><pre class="programlisting">    &gt; removeAll(document.body); &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec129"/>HTML - only DOM objects</h2></div></div></div><p>As you already know, the DOM applies to both XML and HTML documents. What you've learned earlier about traversing the tree and then adding, removing, or modifying nodes, applies to any XML document. There are, however, some HTML-only objects and properties.</p><p>The <code class="literal">document.body</code> is one such HTML-only object. It's so common to have a <code class="literal">&lt;body&gt;</code> tag in HTML documents, and it's accessed so often, that it makes sense to have an object that's shorter and friendlier than the equivalent <code class="literal">document.getElementsByTagName('body')[0]</code>.</p><p>The <code class="literal">document.body</code> element is one example of a <code class="literal">legacy</code> object inherited from the prehistoric DOM Level 0 and moved to the HTML extension of the DOM specification. There are other objects similar to <code class="literal">document.body</code> element. For some of them, there is no core DOM equivalent, for others, there is an equivalent; however, the DOM 0 original was anyway ported for simplicity and legacy purposes. Let's see some of those objects.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec71"/>Primitive ways to access the document</h3></div></div></div><p>to the elements of an HTML document. This was done mainly through a number of collections, which are as follows:
Unlike the DOM, which gives you access to any element, and even comments and whitespace, initially, JavaScript had only limited access to the elements of an HTML document. This was done mainly through a number of collections, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">document.images</code>: This is a collection of all of the images on the page. The Core DOM equivalent is <code class="literal">document.getElementsByTagName('img')</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">document.applets</code>: This is the same as <code class="literal">document.getElementsByTagName('applet')</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">document.links</code>: The document.links collection contains a list of all <code class="literal">&lt;a href="..."&gt;&lt;/a&gt;</code> tags on the page, meaning the <code class="literal">&lt;a&gt;</code> tags that have an <code class="literal">href</code> attribute.</li><li class="listitem" style="list-style-type: disc"><code class="literal">document.anchors</code>: The document.anchors collection contains all links with a name attribute (<code class="literal">&lt;a name="..."&gt;&lt;/a&gt;</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">document.forms</code>: One of the most widely used collections is <code class="literal">document.forms</code>, which contains a list of <code class="literal">&lt;form&gt;</code> elements.</li></ul></div><p>Let's play with a page that contains a form and an input (<a class="ulink" href="http://www.phpied.com/files/jsoop/ch7-form.html">http://www.phpied.com/files/jsoop/ch7-form.html</a>). The following line of code gives you access to the first form on the page:</p><pre class="programlisting">    &gt; document.forms[0]; &#13;
</pre><p>It's the same as the following line of code:</p><pre class="programlisting">    &gt; document.getElementsByTagName('forms')[0]; &#13;
</pre><p>The <code class="literal">document.forms</code> collection contains collections of input fields and buttons, accessible through the <code class="literal">elements</code> property. Here's how to access the first input of the first form on the page:</p><pre class="programlisting">    &gt; document.forms[0].elements[0]; &#13;
</pre><p>Once you have access to an element, you can access its attributes as object properties. The first field of the first form in the test page is as follows:</p><pre class="programlisting">    &lt;input name="search" id="search" type="text" size="50" &#13;
        maxlength="255" value="Enter email..." /&gt; &#13;
</pre><p>You can change the text in the field (the value of the <code class="literal">value</code> attribute) using the following code:</p><pre class="programlisting">    &gt; document.forms[0].elements[0].value = 'me@example.org'; &#13;
        "me@example.org" &#13;
</pre><p>If you want to disable the field dynamically, use the following code:</p><pre class="programlisting">    &gt; document.forms[0].elements[0].disabled = true; &#13;
</pre><p>When forms or <code class="literal">form</code> elements have a <code class="literal">name</code> attribute, you can access them by name too, as shown in the following code:</p><pre class="programlisting">    &gt; document.forms[0].elements['search']; // array notation &#13;
    &gt; document.forms[0].elements.search;    // object property &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec72"/>Using document.write() method</h3></div></div></div><p>The <code class="literal">document.write()</code> method allows you to insert HTML into the page while the page is being loaded. You can have something like the following code:</p><pre class="programlisting">    &lt;p&gt;It is now  &#13;
      &lt;script&gt; &#13;
        document.write("&lt;em&gt;" + new Date() + "&lt;/em&gt;"); &#13;
      &lt;/script&gt; &#13;
    &lt;/p&gt; &#13;
</pre><p>This is the same as if you had the date directly in the source of the HTML document, as follows:</p><pre class="programlisting">    &lt;p&gt;It is now&#13;
      &lt;em&gt;Fri Apr 26 2013 16:55:16 GMT-0700 (PDT)&lt;/em&gt; &#13;
    &lt;/p&gt; &#13;
</pre><p>Note that you can only use <code class="literal">document.write()</code> method while the page is being loaded. If you try it after page load, it will replace the content of the whole page.</p><p>It's rare that you would need <code class="literal">document.write()</code> method, and if you think you do, try an alternative approach. The ways to modify the contents of the page provided by DOM Level 1 are preferred and are much more flexible.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec73"/>Cookies, title, referrer, and domain</h3></div></div></div><p>The four additional properties of <code class="literal">document</code> you'll see in this section are also ported from DOM Level 0 to the HTML extension of DOM Level 1. Unlike the previous ones, for these properties, there are no core DOM equivalents.</p><p>The <code class="literal">document.cookie</code> is a property that contains a string. This string is the content of the cookies exchanged between the server and the client. When the server sends a page to the browser, it may include the <code class="literal">Set-Cookie</code> HTTP header. When the client sends a request to the server, it sends the cookie information back with the <code class="literal">Cookie</code> header. Using <code class="literal">document.cookie</code>, you can alter the cookies the browser sends to the server. For example, visiting <code class="literal">cnn.com</code> and typing <code class="literal">document.cookie</code> in the console gives you the following output:</p><pre class="programlisting">    &gt; document.cookie;&#13;
      "mbox=check#true#1356053765|session#1356053704195-121286#1356055565;... &#13;
</pre><p>The <code class="literal">document.title</code> property allows you to change the title of the page displayed in the browser window. For example, see the following code:</p><pre class="programlisting">    &gt; document.title = 'My title'; &#13;
       "My title" &#13;
</pre><p>Note that this doesn't change the value of the <code class="literal">&lt;title&gt;</code> element, but only the display in the browser window, so it's not equivalent to <code class="literal">document.querySelector('title')</code>.</p><p>The <code class="literal">document.referrer</code> property tells you the URL of the previously visited page. This is the same value the browser sends in the <code class="literal">Referer</code> HTTP header when requesting the page. (Note that <code class="literal">Referer</code> is misspelled in the HTTP headers, but is correct in JavaScript's <code class="literal">document.referrer</code>). If you've visited the CNN page by searching on Yahoo first, you can see something like the following:</p><pre class="programlisting">    &gt; document.referrer; &#13;
       "http://search.yahoo.com/search?p=cnn&amp;ei=UTF-8&amp;fr=moz2" &#13;
</pre><p>The <code class="literal">document.domain</code> property gives you access to the domain name of the currently loaded page. This is commonly used when you need to perform so-called domain relaxation. Imagine your page is <code class="literal">www.yahoo.com</code>, and inside it, you have an iframe hosted on <code class="literal">music.yahoo.com</code> subdomain. These are two separate domains, so the browser's security restrictions won't allow the page and the iframe to communicate. To resolve this, you can set <code class="literal">document.domain</code> property on both pages to <code class="literal">yahoo.com</code> and they'll be able to talk to each other.</p><p>Note that you can only set the domain to a less specific one, for example, you can change <code class="literal">www.yahoo.com</code> to <code class="literal">yahoo.com</code>, but you cannot change <code class="literal">yahoo.com</code> to <code class="literal">www.yahoo.com</code>, or any other non-yahoo domain. Consider the following code:</p><pre class="programlisting">    &gt; document.domain; &#13;
       "www.yahoo.com" &#13;
    &gt; document.domain = 'yahoo.com'; &#13;
       "yahoo.com" &#13;
    &gt; document.domain = 'www.yahoo.com'; &#13;
       Error: SecurityError: DOM Exception 18 &#13;
    &gt; document.domain = 'www.example.org'; &#13;
       Error: SecurityError: DOM Exception 18 &#13;
</pre><p>Previously, in this chapter, you saw the <code class="literal">window.location</code> object. Well, the same functionality is also available as <code class="literal">document.location</code> object:</p><pre class="programlisting">    &gt; window.location === document.location; &#13;
       true &#13;
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec81"/>Events</h1></div></div></div><p>Imagine you are listening to a radio program and they announce, "Big event! Huge! Aliens have landed on Earth!" You might think, "Yeah, whatever"; some other listeners might think "They come in peace"; and some might think, "We're all gonna die!". Similarly, the browser broadcasts events, and your code can be notified should it decide to tune in and listen to the events as they happen. Some example events are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user clicks a button</li><li class="listitem" style="list-style-type: disc">The user types a character in a form field</li><li class="listitem" style="list-style-type: disc">The page finishes loading</li></ul></div><p>You can attach a JavaScript function called event listener or event handler to a specific event and the browser will invoke your function as soon as the event occurs. Let's see how this is done.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec130"/>Inline HTML attributes</h2></div></div></div><p>Adding specific attributes to a tag is the laziest but the least maintainable way; take the following line of code as an example:</p><pre class="programlisting">    &lt;div onclick="alert('Ouch!')"&gt;click&lt;/div&gt; &#13;
</pre><p>In this case, when the user clicks on <code class="literal">&lt;div&gt;</code>, the click event fires and the string of JavaScript code contained in the <code class="literal">onclick</code> attribute is executed. There's no explicit function that listens to the click event; however, behind the scenes, a function is still created, and it contains the code you specified as a value of the <code class="literal">onclick</code> attribute.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec131"/>Element Properties</h2></div></div></div><p>Another way to have some code executed when a click event fires is to assign a function to the <code class="literal">onclick</code> property of a DOM node element. For example, take a look at the following piece of code:</p><pre class="programlisting">    &lt;div id="my-div"&gt;click&lt;/div&gt; &#13;
    &lt;script&gt; &#13;
      var myelement = document.getElementById('my-div'); &#13;
      myelement.onclick = function () { &#13;
        alert('Ouch!'); &#13;
        alert('And double ouch!'); &#13;
      }; &#13;
    &lt;/script&gt; &#13;
</pre><p>This way is better because it helps you keep your <code class="literal">&lt;div&gt;</code> tag clean of any JavaScript code. Always keep in mind that HTML is for content, JavaScript for behavior, and CSS for formatting, and you should keep these three separate as much as possible.</p><p>This method has the drawback that you can attach only one function to the event, as if the radio program has only one listener. It's true that you can have a lot happening inside the same function, but this is not always convenient, as if all the radio listeners are in the same room.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec132"/>DOM event listeners</h2></div></div></div><p>The best way to work with browser events is to use the event listener approach outlined in DOM Level 2, where you can have many functions listening to an event. When an event fires, all the functions are executed. All of the listeners don't need to know about each other and can work independently. They can tune in and out at any time, without affecting the other listeners.</p><p>Let's use the same simple markup from the previous section, which is available for you to play with at <a class="ulink" href="http://www.phpied.com/files/jsoop/ch7.html">http://www.phpied.com/files/jsoop/ch7.html</a>. It has this piece of markup, which is as follows:</p><pre class="programlisting">    &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
</pre><p>Your JavaScript code can assign listeners to the click event using the <code class="literal">addEventListener()</code> method. Let's attach two listeners as follows:</p><pre class="programlisting">    var mypara = document.getElementById('closer'); &#13;
    mypara.addEventListener('click', function () { &#13;
      alert('Boo!'); &#13;
    }, false); &#13;
    mypara.addEventListener( &#13;
      'click', console.log.bind(console), false); &#13;
</pre><p>As you can see, <code class="literal">addEventListeners</code>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec133"/>Capturing and bubbling</h2></div></div></div><p>In the calls to <code class="literal">addEventListener()</code>, there was a third parameter-<code class="literal">false</code>. Let's see what it is for.</p><p>Let's say you have a link inside an unordered list, which is as follows:</p><pre class="programlisting">    &lt;body&gt; &#13;
      &lt;ul&gt; &#13;
        &lt;li&gt;&lt;a href="http://phpied.com"&gt;my blog&lt;/a&gt;&lt;/li&gt; &#13;
      &lt;/ul&gt; &#13;
    &lt;/body&gt; &#13;
</pre><p>When you click on the link, you're actually also clicking on the list item, <code class="literal">&lt;li&gt;</code>, the <code class="literal">&lt;ul&gt;</code> list, the <code class="literal">&lt;body&gt;</code> tag, and eventually, the document as a whole. This is called event propagation. A click on a link can also be seen as a click on the document. The process of propagating an event can be implemented in the two following ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Event capturing</strong>: This click happens in the document first, then it propagates down to the body, the list, the list item, and finally, to the link</li><li class="listitem" style="list-style-type: disc"><strong>Event bubbling</strong>: This click happens on the link and then bubbles up to the document</li></ul></div><p>DOM level 2 events specification suggests that the events propagate in three phases, namely, capturing, at target, and bubbling. This means that the event propagates from the document to the link (target) and then bubbles back up to the document. The event objects have an <code class="literal">eventPhase</code> property, which reflects the current phase:</p><p>
</p><div><img src="img/image_10_012.jpg" alt="Capturing and bubbling"/></div><p>
</p><p>Historically, IE and Netscape (working on their own and without a standard to follow) implemented the exact opposites. IE implemented only bubbling and Netscape only capturing. Today, long after the DOM specification, modern browsers implement all three phases.</p><p>The practical implications related to the event propagation are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The third parameter to <code class="literal">addEventListener()</code> specifies whether or not capturing should be used. In order to have your code more portable across browsers, it's better to always set this parameter to <code class="literal">false</code> and use bubbling only.</li><li class="listitem" style="list-style-type: disc">You can stop the propagation of the event in your listeners so that it stops bubbling up and never reaches the document. To do this, you can call the <code class="literal">stopPropagation()</code> method of the event object; there is an example in the next section.</li><li class="listitem" style="list-style-type: disc">You can also use event delegation. If you have ten buttons inside <code class="literal">&lt;div&gt;</code>, you can always attach ten event listeners, one for each button. However, a smarter thing to do is to attach only one listener to the wrapping <code class="literal">&lt;div&gt;</code> and once the event happens, check which button was the target of the click.</li></ul></div><p>As a side note, there is a way to use event capturing in old IEs too (using <code class="literal">setCapture()</code> and <code class="literal">releaseCapture()</code> methods) but only for mouse events. Capturing any other events (keystroke events for example) is not supported.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec134"/>Stop propagation</h2></div></div></div><p>Let's see an example of how you can stop the event from bubbling up. Going back to the test document, there is this piece of code:</p><pre class="programlisting">    &lt;p id="closer"&gt;final&lt;/p&gt; &#13;
</pre><p>Let's define a function that handles clicks on the paragraph, as follows:</p><pre class="programlisting">    function paraHandler() { &#13;
      alert('clicked paragraph'); &#13;
    } &#13;
</pre><p>Now, let's attach this function as a listener to the click event:</p><pre class="programlisting">    var para = document.getElementById('closer'); &#13;
    para.addEventListener('click', paraHandler, false); &#13;
</pre><p>Let's also attach listeners to the click event on the body, the document, and the browser window:</p><pre class="programlisting">    document.body.addEventListener('click', function () { &#13;
      alert('clicked body'); &#13;
    }, false); &#13;
    document.addEventListener('click', function () { &#13;
      alert('clicked doc'); &#13;
    }, false); &#13;
    window.addEventListener('click', function () { &#13;
      alert('clicked window'); &#13;
    }, false); &#13;
</pre><p>Note that the DOM specifications don't say anything about events on the window. And why would they, as DOM deals with the document and not the browser. So browsers implement window events inconsistently.</p><p>Now, if you click on the paragraph, you'll see four alerts saying:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">clicked paragraph</li><li class="listitem" style="list-style-type: disc">clicked body</li><li class="listitem" style="list-style-type: disc">clicked doc</li><li class="listitem" style="list-style-type: disc">clicked window</li></ul></div><p>This illustrates how the same single click event propagates (bubbles up) from the target all the way up to the window.</p><p>The opposite of <code class="literal">addEventLister()</code> is <code class="literal">removeEventListener()</code>, and it accepts exactly the same parameters. Let's remove the listener attached to the paragraph by writing the following line of code:</p><pre class="programlisting">    &gt; para.removeEventListener('click', paraHandler, false); &#13;
</pre><p>If you try now, you'll see alerts only for the click event on the body, document, and window, but not on the paragraph.</p><p>Now, let's stop the propagation of the event. The function you add as a listener receives the event object as a parameter, and you can call the <code class="literal">stopPropagation()</code> method of that event object as follows:</p><pre class="programlisting">    function paraHandler(e) { &#13;
      alert('clicked paragraph'); &#13;
      e.stopPropagation(); &#13;
    } &#13;
</pre><p>Adding the modified listener is done as follows:</p><pre class="programlisting">    para.addEventListener('click', paraHandler, false); &#13;
</pre><p>Now, when you click on the paragraph, you will see only one alert because the event doesn't bubble up to the body, the document, or the window.</p><p>Note that when you remove a listener, you have to pass a pointer to the same function you previously attached. Otherwise, doing the following does not work because the second argument is a new function, not the same you passed when adding the event listener, even if the body is exactly the same. Consider the following code:</p><pre class="programlisting">    document.body.removeEventListener('click',  &#13;
      function () { &#13;
        alert('clicked body'); &#13;
      },  &#13;
    false); //  does NOT remove the handler &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec135"/>Prevent default behavior</h2></div></div></div><p>Some browser events have a predefined behavior. For example, clicking a link causes the browser to navigate to another page. You can attach listeners to clicks on a link, and you can also disable the default behavior by calling the <code class="literal">preventDefault()</code> method on the event object.</p><p>Let's see how you can annoy your visitors by asking "Are you sure you want to follow this link?" every time they click a link? If the user clicks on <strong>Cancel</strong> (causing <code class="literal">confirm()</code> to return <code class="literal">false</code>), the <code class="literal">preventDefault()</code> method is called, which is shown as follows:</p><pre class="programlisting">    // all links &#13;
    var all_links = document.getElementsByTagName('a');  &#13;
    for (var i = 0; i &lt; all_links.length; i++) { // loop all links &#13;
      all_links[i].addEventListener( &#13;
        'click',       // event type &#13;
        function (e) { // handler &#13;
          if (!confirm('Sure you want to follow this link?')) { &#13;
            e.preventDefault(); &#13;
          } &#13;
        }, &#13;
        false // don't use capturing &#13;
      );  &#13;
    } &#13;
</pre><p>Note that not all events allow you to prevent the default behavior. Most do, but if you want to be sure, you can check the <code class="literal">cancellable</code> property of the event object.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec136"/>Cross-browser event listeners</h2></div></div></div><p>As you already know, most modern browsers almost fully implement the DOM Level 1 specification. However, the events were not standardized until DOM 2. As a result, there are quite a few differences in how IE, before version 9, implements this functionality compared to modern browsers.</p><p>Check out an example that causes <code class="literal">nodeName</code> of a clicked element (the target element) to be written to the console:</p><pre class="programlisting">    document.addEventListener('click', function (e) { &#13;
      console.log(e.target.nodeName); &#13;
    }, false); &#13;
</pre><p>Now, let's take a look at how IE is different:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In IE, there's no <code class="literal">addEventListener()</code> method; although, since IE Version 5, there is an equivalent <code class="literal">attachEvent()</code> method. For earlier versions, your only choice is accessing the property directly, such as <code class="literal">onclick</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">click</code> event becomes <code class="literal">onclick</code> when using <code class="literal">attachEvent()</code>.</li><li class="listitem" style="list-style-type: disc">If you listen to events the old fashioned way (for example, by setting a function value to the <code class="literal">onclick</code> property), when the callback function is invoked, it doesn't get an event object passed as a parameter. However, regardless of how you attach the listener in IE, there is always a global object <code class="literal">window.event</code> that points to the latest event.</li><li class="listitem" style="list-style-type: disc">In IE, the event object doesn't get a target attribute telling you the element on which the event fired, but it does have an equivalent property called <code class="literal">srcElement</code>.</li><li class="listitem" style="list-style-type: disc">As mentioned earlier, event capturing doesn't apply to all events, so only bubbling should be used.</li><li class="listitem" style="list-style-type: disc">There's no <code class="literal">stopPropagation()</code> method, but you can set the IE-only <code class="literal">cancelBubble</code> property to <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc">There's no <code class="literal">preventDefault()</code> method, but you can set the IE-only <code class="literal">returnValue</code> property to <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc">To stop listening to an event, instead of <code class="literal">removeEventListener()</code> in IE, you'll need <code class="literal">detachEvent()</code>.</li></ul></div><p>So, here's the revised version of the previous code that works across browsers:</p><pre class="programlisting">    function callback(evt) { &#13;
      // prep work &#13;
      evt = evt || window.event; &#13;
      var target = evt.target || evt.srcElement; &#13;
 &#13;
     // actual callback work &#13;
      console.log(target.nodeName); &#13;
    } &#13;
 &#13;
    //  start listening for click events &#13;
    if (document.addEventListener) { // Modern browsers &#13;
      document.addEventListener('click', callback, false); &#13;
    } else if (document.attachEvent) { // old IE &#13;
      document.attachEvent('onclick', callback); &#13;
    } else { &#13;
      document.onclick = callback; // ancient &#13;
    } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec137"/>Types of events</h2></div></div></div><p>Now you know how to handle cross-browser events. However, all of the preceding examples used only click events. What other events are happening out there? As you can probably guess, different browsers provide different events. There is a subset of cross-browser events, and some browser-specific ones. For a full list of events, you should consult the browser's documentation, but here's a selection of cross-browser events:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mouse events<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mouseup</code>, <code class="literal">mousedown</code>, <code class="literal">click</code> (the sequence is mousedown-up-click), <code class="literal">dblclick</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseover</code> (mouse is over an element), <code class="literal">mouseout</code> (mouse was over an element but left it), <code class="literal">mousemove</code></li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc">Keyboard events<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">keydown</code>, <code class="literal">keypress</code>, <code class="literal">keyup</code> (occur in this sequence)</li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc">Loading/window events<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">load</code> (an image or a page and all of its components are done loading), <code class="literal">unload</code> (user leaves the page), <code class="literal">beforeunload</code> (the script can provide the user with an option to stop the unload)</li><li class="listitem" style="list-style-type: disc"><code class="literal">abort</code> (user stops loading the page or an image in IE), <code class="literal">error</code> (a JavaScript error, also when an image cannot be loaded in IE)</li><li class="listitem" style="list-style-type: disc"><code class="literal">resize</code> (the browser window is resized), <code class="literal">scroll</code> (the page is scrolled), <code class="literal">contextmenu</code> (the right-click menu appears)</li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc">Form events<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">focus</code> (enter a form field), <code class="literal">blur</code> (leave the form field)</li><li class="listitem" style="list-style-type: disc"><code class="literal">change</code> (leave a field after the value has changed), <code class="literal">select</code> (select text in a text field)</li><li class="listitem" style="list-style-type: disc"><code class="literal">reset</code> (wipe out all user input), <code class="literal">submit</code> (send the form)</li></ul></div><p>
</p></li></ul></div><p>Additionally, modern browsers provide drag events (<code class="literal">dragstart</code>, <code class="literal">dragend</code>, <code class="literal">drop</code>, and among others) and touch devices provide <code class="literal">touchstart</code>, <code class="literal">touchmove</code>, and <code class="literal">touchend</code>.</p><p>This concludes the discussion of events. Refer to the exercise section at the end of this chapter for a little challenge of creating your own event utility to handle cross-browser events.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec82"/>XMLHttpRequest</h1></div></div></div><p>
<code class="literal">XMLHttpRequest()</code> is an object (a constructor function) that allows you to send HTTP requests from JavaScript. Historically, XHR (<code class="literal">XMLHttpRequest</code>) was introduced in IE and was implemented as an ActiveX object. Starting with IE7, it's a native browser object, the same way as it's in the other browsers. The common implementation of this object across browsers gave birth to the so-called Ajax applications, where it's no longer necessary to refresh the whole page every time you need new content. With JavaScript, you can make an HTTP request to the server, get the response, and update only a part of the page. This way, you can build much more responsive and desktop-like web pages.</p><p>
<strong>Ajax</strong> stands for <strong>Asynchronous JavaScript and XML</strong>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Asynchronous because, after sending an HTTP request, your code doesn't need to wait for the response; however, it can do other stuff and be notified, through an event, when the response arrives.</li><li class="listitem" style="list-style-type: disc">JavaScript because it's obvious that XHR objects are created with JavaScript.</li><li class="listitem" style="list-style-type: disc">XML because initially developers were making HTTP requests for XML documents and were using the data contained in them to update the page. This is no longer a common practice, though, as you can request data in plain text, in the much more convenient JSON format, or simply as HTML ready to be inserted into the page.</li></ul></div><p>There are two steps to using the <code class="literal">XMLHttpRequest</code> object, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Send the request</strong>: This includes creating an <code class="literal">XMLHttpRequest</code> object and attaching an event listener</li><li class="listitem" style="list-style-type: disc"><strong>Process the response</strong>: This happens when your event listener gets notified that the response has arrived, and your code gets busy doing something amazing with the response</li></ul></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec138"/>Sending the request</h2></div></div></div><p>In order to create an object, you will simply use the following code (let's deal with browser inconsistencies in just a bit):</p><pre class="programlisting">    var xhr = new XMLHttpRequest(); &#13;
</pre><p>The next thing is to attach an event listener to the <code class="literal">readystatechange</code> event fired by the object:</p><pre class="programlisting">    xhr.onreadystatechange = myCallback; &#13;
</pre><p>Then, you will need to call the <code class="literal">open()</code> method, as follows:</p><pre class="programlisting">    xhr.open('GET', 'somefile.txt', true); &#13;
</pre><p>The first parameter specifies the type of HTTP request, such as <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">HEAD</code>, and so on. <code class="literal">GET</code> and <code class="literal">POST</code> are the most common ones. Use <code class="literal">GET</code> when you don't need to send much data with the request and your request doesn't modify (write) data on the server, otherwise, use <code class="literal">POST</code>. The second parameter is the URL you are requesting. In this example, it's the text file <code class="literal">somefile.txt</code> located in the same directory as the page. The last parameter is a Boolean specifying whether the request is asynchronous (<code class="literal">true</code>, always prefer this) or not (<code class="literal">false</code>, blocks all the JavaScript execution and waits until the response arrives).</p><p>The last step is to fire off the request, which is done as follows:</p><pre class="programlisting">    xhr.send(''); &#13;
</pre><p>The <code class="literal">send()</code> method accepts any data you want to send with the request. For <code class="literal">GET</code> requests, this is an empty string because the data is in the URL. For <code class="literal">POST</code> request, it's a query string in the <code class="literal">key=value&amp;key2=value2</code> form.</p><p>At this point, the request is sent and your code and the user can move on to other tasks. The callback function, <code class="literal">myCallback</code>, will be invoked when the response comes back from the server.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec139"/>Processing the response</h2></div></div></div><p>A listener is attached to the <code class="literal">readystatechange</code> event. So, what exactly is the ready state and how does it change?</p><p>There is a property of the XHR object called <code class="literal">readyState</code>. Every time it changes, the <code class="literal">readystatechange</code> event fires. The possible values of the <code class="literal">readyState</code> property are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0-uninitialized</li><li class="listitem" style="list-style-type: disc">1-loading</li><li class="listitem" style="list-style-type: disc">2-loaded</li><li class="listitem" style="list-style-type: disc">3-interactive</li><li class="listitem" style="list-style-type: disc">4-complete</li></ul></div><p>When <code class="literal">readyState</code> gets the value of <code class="literal">4</code>, it means the response is back and ready to be processed. In <code class="literal">myCallback</code>, after you make sure <code class="literal">readyState</code> is <code class="literal">4</code>, the other thing to check is the status code of the HTTP request. You might have requested a non-existing URL, for example, and got a <code class="literal">404</code> (File not found) status code. The interesting code is the <code class="literal">200</code> (<code class="literal">OK</code>) code, so <code class="literal">myCallback</code> should check for this value. The status code is available in the <code class="literal">status</code> property of the XHR object.</p><p>Once <code class="literal">xhr.readyState</code> is <code class="literal">4</code> and <code class="literal">xhr.status</code> is <code class="literal">200</code>, you can access the contents of the requested URL using the <code class="literal">xhr.responseText</code> property. Let's see how <code class="literal">myCallback</code> can be implemented to simply <code class="literal">alert()</code> the contents of the requested URL:</p><pre class="programlisting">    function myCallback() { &#13;
 &#13;
      if (xhr.readyState &lt; 4) { &#13;
        return; // not ready yet &#13;
      } &#13;
  &#13;
      if (xhr.status !== 200) { &#13;
        alert('Error!'); // the HTTP status code is not OK &#13;
        return; &#13;
      } &#13;
 &#13;
      //  all is fine, do the work &#13;
      alert(xhr.responseText); &#13;
    } &#13;
</pre><p>Once you've received the new content you requested, you can add it to the page, use it for some calculations, or for any other purpose you find suitable.</p><p>Overall, this two-step process (send request and process response) is the core of the whole XHR/Ajax functionality. Now that you know the basics, you can move on to building the next Gmail. Oh yes, let's take a look at some minor browser inconsistencies.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec140"/>Creating XMLHttpRequest objects in IE prior to Version 7</h2></div></div></div><p>In Internet Explorer, prior to version 7, the <code class="literal">XMLHttpRequest</code> object was an ActiveX object, so creating an XHR instance is a little different. It goes as follows:</p><pre class="programlisting">    var xhr = new ActiveXObject('MSXML2.XMLHTTP.3.0'); &#13;
</pre><p>
<code class="literal">MSXML2.XMLHTTP.3.0</code> is the identifier of the object you want to create. There are several versions of the <code class="literal">XMLHttpRequest</code> object, and if your page visitor doesn't have the latest one installed, you can try two older ones before you give up.</p><p>For a fully-cross-browser solution, you should first test to see if the user's browser supports <code class="literal">XMLHttpRequest</code> as a native object, and if not, try the IE way. Therefore, the whole process of creating an XHR instance could be like the following:</p><pre class="programlisting">    var ids = ['MSXML2.XMLHTTP.3.0', &#13;
           'MSXML2.XMLHTTP', &#13;
           'Microsoft.XMLHTTP']; &#13;
            &#13;
    var xhr; &#13;
    if (XMLHttpRequest) { &#13;
      xhr = new XMLHttpRequest(); &#13;
    } else { &#13;
      // IE: try to find an ActiveX object to use &#13;
      for (var i = 0; i &lt; ids.length; i++) { &#13;
        try { &#13;
          xhr = new ActiveXObject(ids[i]); &#13;
          break; &#13;
        } catch (e) {} &#13;
      } &#13;
    } &#13;
</pre><p>What is this doing? The <code class="literal">ids</code> array contains a list of ActiveX program IDs to try. The <code class="literal">xhr</code> variable points to the new XHR object. The code first checks to see if <code class="literal">XMLHttpRequest</code> exists. If so, this means that the browser supports <code class="literal">XMLHttpRequest()</code> natively, so the browser is relatively modern. If it is not, the code loops through ids trying to create an object. The <code class="literal">catch(e)</code> block quietly ignores failures and the loop continues. As soon as an <code class="literal">xhr</code> object is created, you break out of the loop.</p><p>As you can see, this is quite a bit of code, so it's best to abstract it into a function. Actually, one of the exercises at the end of the chapter prompts you to create your own Ajax utility.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec141"/>A is for Asynchronous</h2></div></div></div><p>Now you know how to create an XHR object, give it a URL and handle the response to the request. What happens when you send two requests asynchronously? What if the response to the second request comes before the first?</p><p>In the preceding example, the XHR object was global and <code class="literal">myCallback</code> was relying on the presence of this global object in order to access its <code class="literal">readyState</code>, <code class="literal">status</code>, and <code class="literal">responseText</code> properties. Another way, which prevents you from relying on global variables, is to wrap the callback in a closure. Let's see how:</p><pre class="programlisting">    var xhr = new XMLHttpRequest(); &#13;
 &#13;
    xhr.onreadystatechange = (function (myxhr) { &#13;
      return function () {  &#13;
        myCallback(myxhr);  &#13;
      }; &#13;
    }(xhr)); &#13;
 &#13;
    xhr.open('GET', 'somefile.txt', true); &#13;
    xhr.send(''); &#13;
</pre><p>In this case, <code class="literal">myCallback()</code> receives the XHR object as a parameter and will not go looking for it in the global space. This also means that at the time the response is received, the original <code class="literal">xhr</code> might be reused for a second request. The closure keeps pointing to the original object.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec142"/>X is for XML</h2></div></div></div><p>Although these days JSON (discussed in the next chapter) is preferred over XML as a data transfer format, XML is still an option. In addition to the <code class="literal">responseText</code> property, the XHR objects also have another property called <code class="literal">responseXML</code>. When you send an HTTP request for an XML document, <code class="literal">responseXML</code> points to an XML DOM document object. To work with this document, you can use all of the core DOM methods discussed previously in this chapter, such as <code class="literal">getElementsByTagName()</code>, <code class="literal">getElementById()</code>, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec143"/>An example</h2></div></div></div><p>Let's wrap up the different XHR topics with an example. You can visit the page located at <a class="ulink" href="http://www.phpied.com/files/jsoop/xhr.html">http://www.phpied.com/files/jsoop/xhr.html</a> to work on the example yourself.</p><p>The main page, <code class="literal">xhr.html</code>, is a simple static page that contains nothing but three <code class="literal">&lt;div&gt;</code> tags, which are as follows:</p><pre class="programlisting">    &lt;div id="text"&gt;Text will be here&lt;/div&gt; &#13;
    &lt;div id="html"&gt;HTML will be here&lt;/div&gt; &#13;
    &lt;div id="xml"&gt;XML will be here&lt;/div&gt; &#13;
</pre><p>Using the console, you can write code that requests three files and loads their respective contents into each <code class="literal">&lt;div&gt;</code>.</p><p>The three files to load are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">content.txt</code>: This is a simple text file containing the text <code class="literal">I am a text file</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">content.html</code>: This is a file containing HTML code <code class="literal">I am &lt;strong&gt;formatted&lt;/strong&gt; &lt;em&gt;HTML&lt;/em&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">content.xml</code>: This is an XML file containing the following code:<pre class="programlisting">    &lt;?xml version="1.0" ?&gt; &#13;
    &lt;root&gt; &#13;
        I'm XML data. &#13;
    &lt;/root&gt; &#13;
</pre></li></ul></div><p>All of the files are stored in the same directory as <code class="literal">xhr.html</code>.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>For security reasons, you can only use the original <code class="literal">XMLHttpRequest</code> to request files that are on the same domain. However, modern browsers support XHR2, which lets you make cross-domain requests, provided that the appropriate Access-Control-Allow-Origin HTTP header is in place.</p></div></div><p>First, let's create a function to abstract the request/response part:</p><pre class="programlisting">    function request(url, callback) { &#13;
      var xhr = new XMLHttpRequest();  &#13;
      xhr.onreadystatechange = (function (myxhr) { &#13;
        return function () { &#13;
          if (myxhr.readyState === 4 &amp;&amp; myxhr.status === 200) { &#13;
            callback(myxhr); &#13;
          } &#13;
        }; &#13;
      }(xhr)); &#13;
      xhr.open('GET', url, true); &#13;
      xhr.send(''); &#13;
    } &#13;
</pre><p>This function accepts a URL to request and a callback function to call once the response arrives. Let's call the function three times, once for each file, as follows:</p><pre class="programlisting">    request( &#13;
      'http://www.phpied.com/files/jsoop/content.txt', &#13;
      function (o) { &#13;
        document.getElementById('text').innerHTML = &#13;
          o.responseText; &#13;
      } &#13;
    ); &#13;
    request( &#13;
      'http://www.phpied.com/files/jsoop/content.html', &#13;
      function (o) { &#13;
        document.getElementById('html').innerHTML = &#13;
          o.responseText; &#13;
      } &#13;
    ); &#13;
    request( &#13;
      'http://www.phpied.com/files/jsoop/content.xml', &#13;
      function (o) { &#13;
        document.getElementById('xml').innerHTML = &#13;
          o.responseXML &#13;
           .getElementsByTagName('root')[0] &#13;
           .firstChild &#13;
           .nodeValue; &#13;
      }   &#13;
    ); &#13;
</pre><p>The callback functions are defined inline. The first two are identical. They just replace the HTML of the corresponding <code class="literal">&lt;div&gt;</code> with the contents of the requested file. The third one is a little different as it deals with the XML document. First, you will access the XML DOM object as <code class="literal">o.responseXML</code>. Then, using <code class="literal">getElementsByTagName()</code>, you will get a list of all the <code class="literal">&lt;root&gt;</code> tags (there is only one). The <code class="literal">firstChild</code> of <code class="literal">&lt;root&gt;</code> is a text node and <code class="literal">nodeValue</code> is the text contained in it (<code class="literal">I'm XML data)</code>. Then, just replace the HTML of <code class="literal">&lt;div id="xml"&gt;</code> with the new content. The result is shown in the following screenshot:</p><p>
</p><div><img src="img/image_10_013.jpg" alt="An example"/></div><p>
</p><p>When working with the XML document, you can also use <code class="literal">o.responseXML.documentElement</code> to get to the <code class="literal">&lt;root&gt;</code> element instead of <code class="literal">o.responseXML.getElementsByTagName('root')[0]</code>. Remember that <code class="literal">documentElement</code> gives you the root node of an XML document. The root in HTML documents is always the <code class="literal">&lt;html&gt;</code> tag.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec83"/>Exercises</h1></div></div></div><p>In the previous chapters, the solutions to the exercises could be found in the text of the chapter. This time, some of the exercises require you to do some more reading, or experimentation, outside this book.</p><div><ol class="orderedlist arabic"><li class="listitem">BOM: As a BOM exercise, try coding something wrong, obtrusive, user-unfriendly, and all in all, very Web 1.0, the shaking browser window. Try implementing code that opens a 200 x 200 pop up window and then resizes it slowly and gradually to 400 x 400. Next, move the window around as if there's an earthquake. All you'll need is one of the move<code class="literal">*()</code> functions, one or more calls to <code class="literal">setInterval()</code>, and maybe one to <code class="literal">setTimeout()</code>/<code class="literal">clearInterval()</code> to stop the whole thing. Or, here's an easier one-print the current date/time in <code class="literal">document.title</code> and update it every second, like a clock.</li><li class="listitem">DOM:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implement <code class="literal">walkDOM()</code> differently. Also, make it accept a callback function instead of hard coding <code class="literal">console.log()</code>.</li><li class="listitem" style="list-style-type: disc">Removing content with <code class="literal">innerHTML</code> is easy (<code class="literal">document.body.innerHTML = ''</code>), but not always best. The problem will be when there are event listeners attached to the removed elements; they won't be removed in IE, causing the browser to leak memory because it stores references to something that doesn't exist. Implement a general-purpose function that deletes DOM nodes, but removes any event listeners first. You can loop through the attributes of a node and check if the value is a function. If it is, it's most likely an attribute like <code class="literal">onclick</code>. You need to set it to <code class="literal">null</code> before removing the element from the tree.</li><li class="listitem" style="list-style-type: disc">Create a function called <code class="literal">include()</code> that includes external scripts on demand. This means you need to create a new <code class="literal">&lt;script&gt;</code> tag dynamically, set its <code class="literal">src</code> attribute, and append to the document's <code class="literal">&lt;head&gt;</code>. Test it by using the following code:<pre class="programlisting">        &gt; include('somescript.js'); &#13;
</pre></li></ul></div></li><li class="listitem">Events:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create an event utility (object) called <code class="literal">myevent</code>, which has the following methods working cross-browser:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<code class="literal"> addListener</code><code class="literal">(element</code>, <code class="literal">event_name</code>, <code class="literal">callback)</code>, where <code class="literal">element</code> can also be an array of elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeListener</code><code class="literal">(element</code>, <code class="literal">event_name</code>, <code class="literal">callback)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getEvent(event)</code> just to check for a <code class="literal">window.event</code> for older versions of IE</li><li class="listitem" style="list-style-type: disc">getTarget(event)</li><li class="listitem" style="list-style-type: disc">stopPropagation(event)</li><li class="listitem" style="list-style-type: disc">preventDefault(event)</li></ul></div></li><li class="listitem" style="list-style-type: disc">Usage example is as follows:<pre class="programlisting">        function myCallback(e) { &#13;
          e = myevent.getEvent(e); &#13;
          alert(myevent.getTarget(e).href); &#13;
          myevent.stopPropagation(e); &#13;
          myevent.preventDefault(e); &#13;
        } &#13;
        myevent.addListener(document.links, 'click', myCallback); &#13;
</pre></li><li class="listitem" style="list-style-type: disc">The result of the example code should be that all of the links in the document lead nowhere, but only alert the <code class="literal">href</code> attribute.</li><li class="listitem" style="list-style-type: disc">Create an absolutely positioned <code class="literal">&lt;div&gt;</code>, say at <code class="literal">x = 100px</code>, <code class="literal">y = 100px</code>. Write the code to be able to move div around the page using the arrow keys or the <em>J</em> (left), <em>K</em> (right), <em>M</em> (down), and <em>I</em> (up) keys. Reuse your own event utility from 3.1.</li></ul></div></li><li class="listitem">XMLHttpRequest:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create your own XHR utility (object) called <code class="literal">ajax</code>. For example, take a look at the following code:<pre class="programlisting">        function myCallback(xhr) { &#13;
          alert(xhr.responseText); &#13;
        } &#13;
        ajax.request('somefile.txt', 'get', myCallback); &#13;
        ajax.request('script.php', 'post', myCallback, &#13;
        'first=John&amp;last=Smith'); &#13;
</pre></li></ul></div></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec84"/>Summary</h1></div></div></div><p>You learned quite a bit in this chapter. You learned the following cross-browser BOM objects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Properties of the global <code class="literal">window</code> object, such as <code class="literal">navigator</code>, <code class="literal">location</code>, <code class="literal">history</code>, <code class="literal">frames</code>, <code class="literal">screen</code></li><li class="listitem" style="list-style-type: disc">Methods such as <code class="literal">setInterval()</code> and <code class="literal">setTimeout()</code>; <code class="literal">alert()</code>, <code class="literal">confirm()</code> and <code class="literal">prompt()</code>; <code class="literal">moveTo/By()</code> and <code class="literal">resizeTo/By()</code></li></ul></div><p>Then, you learned about the DOM, an API to represent an HTML or XML document as a tree structure, where each tag or text is a node on the tree. You also learned how to perform the following actions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accessing nodes:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using parent/child relationship properties, such as <code class="literal">parentNode</code>, <code class="literal">childNodes</code>, <code class="literal">firstChild</code>, <code class="literal">lastChild</code>, <code class="literal">nextSibling</code>, and <code class="literal">previousSibling</code></li><li class="listitem" style="list-style-type: disc">Using <code class="literal">getElementsById()</code>, <code class="literal">getElementsByTagName()</code>, <code class="literal">getElementsByName()</code>, and <code class="literal">querySelectorAll()</code></li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc">Modifying nodes:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using <code class="literal">innerHTML</code> or <code class="literal">innerText/textContent</code></li><li class="listitem" style="list-style-type: disc">Using <code class="literal">nodeValue</code> or <code class="literal">setAttribute()</code>, or just using attributes as object properties</li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc">Removing nodes with <code class="literal">removeChild()</code> or <code class="literal">replaceChild()</code></li><li class="listitem" style="list-style-type: disc">Adding new ones with <code class="literal">appendChild()</code>, <code class="literal">cloneNode()</code>, and <code class="literal">insertBefore()</code></li></ul></div><p>You also learned the following DOM 0 (pre-standardization) properties, ported to DOM Level 1:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collections, such as <code class="literal">document.forms</code>, <code class="literal">images</code>, <code class="literal">links</code>, <code class="literal">anchors</code>, <code class="literal">applets</code>. Using these are discouraged as DOM1 has the much more flexible <code class="literal">getElementsByTagName()</code> method.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">document.body</code> element, which gives you convenient access to <code class="literal">&lt;body&gt;</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">document.title</code>, <code class="literal">cookie</code>, <code class="literal">referrer</code>, and <code class="literal">domain</code>.</li></ul></div><p>Next, you learned how the browser broadcasts events that you can listen to. It's not straightforward to do this in a cross-browser manner, but it's possible. Events bubble up, so you can use event delegation to listen to events more globally. You can also stop the propagation of events and interfere with the default browser behavior.</p><p>Finally, you learned about the <code class="literal">XMLHttpRequest</code> object that allows you to build responsive web pages that do the following tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make HTTP requests to the server to get pieces of data</li><li class="listitem" style="list-style-type: disc">Process the response to update portions of the page</li></ul></div></div></body></html>