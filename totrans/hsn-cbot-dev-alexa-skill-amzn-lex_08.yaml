- en: Improving the User Experience for Your Bots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having learned how to create Alexa Skills and Lex chatbots, we will now
    learn how we can improve the user experience. This is important, as adding images
    to your Lex chatbot or having a better voice model for Alexa can make a huge difference
    to whether the user enjoys interacting with your chatbot. Adding these features
    will also make your chatbots stand out from the basic, text-only chatbots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding response cards to Lex chatbots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using phrase slots to create a more refined voice model for Alexa Skills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using utterance monitoring with Amazon Lex to refine interaction models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be modifying our existing Lambda functions, so we'll
    be deploying them using the local development setup that we created [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml),
    *Getting Started with AWS and Amazon CLI*.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code and data required for this chapter can be found at [http://bit.ly/chatbot-ch8](http://bit.ly/chatbot-ch8).
  prefs: []
  type: TYPE_NORMAL
- en: Response cards in Amazon Lex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cards give you a way to offer a richer in-conversation experience than just
    text messages by integrating buttons, images, and more. Cards can be used for
    many purposes, such as displaying product information, asking the message recipient
    to choose from a predetermined set of options, and showing search results. If
    you are integrating your cards into Slack or Facebook, then they will be shown
    on those platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01ef9d44-c468-47f8-9e93-a2f5a66064fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Example cards in Facebook
  prefs: []
  type: TYPE_NORMAL
- en: Creating a card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a card, we need to change the format of the response that we are
    sending back to Lex. This means we need to change the functions in `LexResponses`
    by passing in a `responseCard` attribute. We can then add this `responseCard`
    to the `dialogAction` object. If we don''t pass in a response card parameter,
    we still want the function to work so we default it to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This needs to be done for `elicitSlot`, `close`, `elicitIntent`, and `confirmIntent`,
    but not for `delegate` as that function doesn't send messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a response card, we need to make sure that the response is also in the
    correct format. To make this easier for ourselves, we can make a new function
    inside `LexResponses` called `createCardFormat`. This will take a single attribute
    of cards, which is an array of objects containing a `title`, `subtitle`, `imageUrl`,
    `linkUrl`, and `buttons`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using cards in chats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our modified `LexResponses` class, we can now start adding cards to our
    existing Lex Lambdas. One obvious place to use cards is in the shopping app to
    display the items we found based on the user's search. This means we are going
    to alter our `productFind` Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the message telling the user how many of the items we have in
    stock (line 77 of `productFind`/`index.js`), we can create our first card.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is going to be a single card with a title of the item, a subtitle of the
    stock, an image, and `Add to Cart` and `Not Now` buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are giving the buttons a different value to their text. This
    allows the response we receive to be different from the button that the user clicks.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have also added an image using `item.imageURL`
    but this never existed in our original data. We need to go through and add this
    to each of the items in the stock data. Luckily, we can use the same image for
    the different sizes of clothes. The stock data with images is available to download
    at [bit.ly/chatbot-ch8](http://bit.ly/chatbot-ch8).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we deploy these changes, we can test it out in the Lex chat window. We
    can go through the normal `productFind` flow up to the point where we are shown
    the product selected. When we are told how many are in stock, we are also shown
    a card displaying the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4393720f-7b1f-46aa-9e1a-1190ccbf44a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Chat card
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have the Facebook or Slack integrations hooked up from the previous chapters,
    then our new cards should work on there too. Lex does a lot of clever logic to
    translate the card into the correct format needed for each platform and then uses
    them in the replies. It should be noted that Facebook crops the images to a 1:1.9
    ratio, so selecting your images with that in mind is a good idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef8c6998-4329-493d-bf3f-f5428ee288be.png)'
  prefs: []
  type: TYPE_IMG
- en: Facebook card
  prefs: []
  type: TYPE_NORMAL
- en: Alexa search queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alexa is great when you know the sort of responses that your users are going
    to be saying, but what if they ask for something you aren't expecting? Even using
    custom slot types can be limiting, which could result in a user's request being
    incorrectly handled. Luckily, Amazon has introduced the Search Query slot type.
  prefs: []
  type: TYPE_NORMAL
- en: This slot type for Alexa is designed to be able to take a much wider range of
    values so that you can handle more requests.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to add a new intent onto our existing Weather Gods skill that uses
    a Search Query slot type to allow users to search for places in a city. We'll
    be using Google Maps API to power the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your Alexa developer''s console and open the `WeatherGods` skill. Add
    a new intent called `searchIntent` and we can start by creating the different
    slots that we''ll be using. Create two slots, one called `query` and the other
    called `city`. Our query slot can be given a slot type of AMAZON.SearchQuery and
    our city slot will be AMAZON.US_CITY:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/701adf1a-5e6a-467c-ac4c-de7438360c94.png)'
  prefs: []
  type: TYPE_IMG
- en: Search slots
  prefs: []
  type: TYPE_NORMAL
- en: 'With the slots completed, we can start populating the utterances. Unfortunately,
    we can''t have a search query slot in an utterance with another slot so we''ll
    have to fill one slot at a time. We should allow a user to ask about a city or
    ask a query to start the intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aba3813d-d8f6-45fc-97c8-1383604cd57a.png)'
  prefs: []
  type: TYPE_IMG
- en: Utterances for search query
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our slots and utterances completed, we can modify our existing
    `weatherGods` Lambda to handle the new intent. Find the Lambda in your editor,
    open the `index.js` file, and go into the `handlers` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `handlers` object, we need to add a new handler called `searchIntent`.
    This handler will start by getting the city and query slot values and checking
    whether they exist. If they don''t, we''ll ask the user to tell us the missing
    information. We check `cityValue` first, so we can specify the city when we ask
    for the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we have both the city and query values, then we can use these to make a request
    to Google's Maps API.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Google Maps API, we need to set up a Google Cloud Platform developers
    account. We can get one by going to [cloud.google.com/](https://cloud.google.com/)
    and clicking Try free. You need to sign in to a Google account, confirm terms
    and conditions, and then enter payment information. Don't worry; you get $300
    of free credit when you start, so you shouldn't get billed any time soon.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we need to create a project by clicking Select a project in the upper-left
    corner and then choosing NEW PROJECT. Now we can name our new project `WeatherGodsAPI`
    and click CREATE.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our project created, we need to check that it is selected in the upper-left
    corner of the page and then we can start to set up this project. In the search
    box, we can search for `Places API` and enable it for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f61fe323-d4bc-4822-83c7-d33f324e06ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Places API
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Places API has been enabled on this project, we need to generate an
    API key so we can access it from our Lambda. Click on Credentials and, from the
    Create Credentials drop-down menu, select API Key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/374b1877-cdf4-402d-b6d9-f53da14d5abd.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating an API key
  prefs: []
  type: TYPE_NORMAL
- en: You need to copy this API key, as we'll be using it in our Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing Lambda building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have an API key that we can use to hit the Google Places API. Copy it
    and open your Lambda in the Lambda console. Scroll down to Environment variables,
    and create a new variable with a key of GOOGLE_API_KEY, and paste the API key
    as the value. Make sure not to remove the other API key, which is for `openWeatherMaps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7374ea69-a4d1-45fe-a4a3-95b836298239.png)'
  prefs: []
  type: TYPE_IMG
- en: Storing environment variables
  prefs: []
  type: TYPE_NORMAL
- en: 'With our Google API key stored as an environment variable, we can create our
    request that we''ll be sending to Google. The format of the API request URL is
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it easier for ourselves, we can store most sections of this as constants,
    even the Google API key. In our `index.js` file, we can add these constants to
    the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With these constants accessible, the only part that we need to generate is
    our search. To do this, we can take our `queryValue` and our `cityValue` and turn
    it into a search phrase. This can be done by joining `{queryValue}` and `{cityValue}`
    into a basic sentence. Because we are inserting this into a URL, we need to use
    `%20` instead of spaces and then we can build our request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With our request URL built, we can make our request to Google. To catch any
    errors, we can use our `to` method and then check that there are no errors and
    that there is a `response.data` field. If we didn''t get what we expect, we can
    tell the user that we couldn''t find that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If our request did successfully return some data, then we can build a response
    for the user. First, we can tell them how many of their query there are in that
    city, and then we can list the names of each of those places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've now completed our updated Lambda and can deploy it to AWS using our build
    script from [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting
    Started with AWS and Amazon CLI*.
  prefs: []
  type: TYPE_NORMAL
- en: Rebuilding the skill and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in our skill in the Alexa Console, we can check our modified skill and
    make sure to save it and rebuild it. When it has finished building, we can click
    Test to try it out. You can test the old intents that we built in [Chapter 4](7567de44-8fd8-4f0a-b304-adfe6006e0a3.xhtml),
    *Connecting your Alexa Skill to External APIs*, and they should all work as before,
    but we really want to test our new intent.
  prefs: []
  type: TYPE_NORMAL
- en: You can now ask the weather gods what there is in Manchester and say that you're
    looking for a Catholic cathedral, and your skill will ask Google for Catholic
    cathedral in Manchester. It should tell you there is one called Salford Cathedral.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is good, we could have used a custom slot type and listed lots of
    things that a user might ask for. This is where search queries are really useful:
    they can handle far less common requests. We can ask for Saint Paul''s primary
    school in Manchester, and we''ll get a result. There is no way we could have created
    a custom slot that would be large enough to include every school name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf5dc87b-fb31-43eb-89fe-968144e108be.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing search query
  prefs: []
  type: TYPE_NORMAL
- en: Lex utterance monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create your intents and generate the list of utterances, you try your
    best to cover everything that a user might say. Unfortunately, people often come
    up with unique ways of saying something that you've not thought of. In this case,
    the user will get an "*I don't understand*" message from Lex. This obviously isn't
    great for providing a good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Lex has built-in monitoring to allow you to see the utterances that
    the users have been saying. To get to these, we need to click on the Monitoring
    tab in Lex. Lex utterances are stored for a specific chatbot version, so we need
    to select a value from the dropdown next to our chatbot name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have a screen of graphs showing the Lex usage. This can be useful,
    but we''re looking for the tables of utterances, found in the menu on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f910f7dd-78ba-4d85-bfe7-d3ae09682177.png)'
  prefs: []
  type: TYPE_IMG
- en: Utterance monitoring
  prefs: []
  type: TYPE_NORMAL
- en: You should now see a table with a toggle in the center for Detected/Missed.
    The Detected utterances can be useful for seeing how most of your users are interacting
    with the chatbot. This can help you work out which areas you can develop to improve
    your chatbot for the largest portion of your audience.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see any utterances, then there are a few things to check. You need
    to make sure that in the general settings of the chatbot, COPPA is set to No.
    Next, you should try changing the version of the chatbot (next to the chatbot
    name) as utterances are saved to a specific version. Utterances show up in these
    tables if they are between 24 hours and 15 days old. If you still don't see any
    utterances, then you may just need to wait until you have utterances within this
    range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Utterance monitoring is very useful when users have said something that Lex
    couldn''t match to one of your example utterances. The Missed utterances give
    you a list of all of the utterances where this has happened. Although some of
    them will be gibberish or typos, some of them will be valid utterances that you
    might not have thought about:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/313bf545-433f-4bac-bb04-bbcf38ef9a05.png)'
  prefs: []
  type: TYPE_IMG
- en: Missed utterances
  prefs: []
  type: TYPE_NORMAL
- en: Looking through the missed intents, you may realize that the user has typed
    an utterance that you hadn't thought of. You can easily add this to your intent
    by selecting the missed utterance and then selecting the intent from the dropdown
    that is just above the table. This saves manually copying and pasting the utterances
    into the intents.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've moved all of the valid missed utterances into the correct intents,
    you need to make sure you build and deploy your updated chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked into three ways to improve the user experience
    of both Alexa Skills and Lex chatbots.
  prefs: []
  type: TYPE_NORMAL
- en: We started by creating cards in Lex chats to increase the visual information
    provided to a user. These cards are a great way to make your Lex chatbots stand
    out from just text-based chatbots.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved over to Alexa, where we learned about Search Query slots. This
    slot type allows users to enter a wider range of values to fill a slot than we
    could allow using custom slot types.
  prefs: []
  type: TYPE_NORMAL
- en: The final tool we learned to use to improve the user experience was *utterance
    monitoring*. Seeing what your users are really saying to your chatbot helps you
    increase the example utterances for each intent. This results in a chatbot that
    can successfully handle a wider range of user utterances.
  prefs: []
  type: TYPE_NORMAL
- en: All of these things will provide more information or reduce the chance that
    the chatbots can't handle a user's requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter we'll discuss a few of the best ways to continue your learning.
    We'll also talk about the future of chatbots and how they will become part of
    our everyday lives.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits of using cards in Lex conversations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you need to use an image in a Lex card?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you choose to use search query slot type over a default or custom
    slot type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you populate a search query slot from the user utterance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you find out which Lex utterances weren't matched to an intent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
