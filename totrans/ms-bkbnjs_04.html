<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Modular Code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Modular Code</h1></div></div></div><p>As your project's code grows, the number of scripts in the project will be more and more, incrementing script-loading complexity. The classic way to load JavaScript files is to write a<code class="literal">&lt;script&gt;</code> tags for every script you have, but you have to do it in the right order; if you don't, your code could stop working. That's not an efficient way for medium-size projects.</p><p>What happens if you forget the order of loading? What if you make a refactorization on the code and the order of the script changes? It will be a pain to fix it and keep track of all the code and its dependencies.</p><p>This problem has been addressed in different ways. One is to create a module syntax to create, load, and declare explicitly the dependencies of modules; the syntax is called <span class="strong"><strong>AMD</strong></span> (<span class="strong"><strong>Asynchronous Module Definition</strong></span>). The<a id="id138" class="indexterm"/> AMD modules define a list of module dependencies, and the code inside the module will be executed only after the dependencies are fully loaded.</p><p>The dependencies are loaded asynchronously; that means that you don't need to load all the scripts in the HTML page through <code class="literal">&lt;script&gt;</code> tags. AMD modules are better than plain JavaScript because they define dependencies explicitly and can be loaded automatically.</p><p>Although AMD modules are better than <code class="literal">&lt;script&gt;</code> tags, working with AMD modules can be a pain when unit testing comes in because you need to know the intricacies of how the library loads the modules; when you want to do unit testing, you need to isolate the pieces of code under test, but is hard to do it in RequireJS, and even if you do it the result can be buggy.</p><p>Recently another module loader and dependency manager has arrived; Browserify seems to be the most popular at the moment. However, it is not the only one; there are many other potentially strong choices such as jspm and steal.js.</p><p>In this book, we will work with Browserify because of its popularity, so you can find a lot of information and documentation about it on the Web; another good reason is that many projects have been built with it, which demonstrates its maturity and that it's production-ready. Browserify uses the same Node module syntax to define modules and dependencies, so that if you already know about Node you can go directly to the Browserify section.</p><div class="section" title="CommonJS modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>CommonJS modules</h1></div></div></div><p>In recent years, Node has been gaining popularity in the software industry; indeed it is becoming a very popular<a id="id139" class="indexterm"/> choice for backend development in a full JavaScript technology stack. If you don't know about Node, you can think about it as JavaScript used in the server instead of a browser.</p><p>Node uses the CommonJS module syntax for its modules; a CommonJS module is a file that exports a single value to be used for other modules. It is useful to use CommonJS because it provides a clean way to manage JavaScript modules and dependencies.</p><p>To support CommonJS, Node uses the<a id="id140" class="indexterm"/> <code class="literal">require()</code> function. With <code class="literal">require()</code> you can load JavaScript files without the need to use <code class="literal">&lt;script&gt;</code> tags, instead calling <code class="literal">require()</code> with the name of the module/dependency that you need and assigning it to a variable.</p><p>To illustrate how CommonJS modules work, let's write a Node module and see how to use the <code class="literal">require()</code> function. The following code shows a simple module that exposes a simple object with the method <code class="literal">sayHello()</code>:</p><div class="informalexample"><pre class="programlisting">hello = {
  sayHello(name) {
    name = name || 'world';
    console.log('hello', name);
  }
}

module.exports = hello;</pre></div><p>This script can be placed in a file named <code class="literal">hello.js</code>, for example. The hello module can be loaded from another module by calling the <code class="literal">require()</code> function, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var hello = require('./hello');
hello.sayHello('world); // prints "hello world"</pre></div><p>When we require a script with the <code class="literal">require()</code> function we don't need to add the .js extension, Node will do it for us automatically. Note that, if you add the extension to the script name, Node will add the extension anyway and you will get an error because the <code class="literal">hello.js.js</code> file does not exist.</p><p>That's the way you can define CommonJS modules for your projects: we just export the variable that we want to expose to the outside of the module with <code class="literal">module.exports</code> and then load the module where needed with <code class="literal">require()</code>.</p><p>CommonJS modules are singletons, which means that every time you load a module you will get the same<a id="id141" class="indexterm"/> instance of the object. Node will cache the returned value when it's called for the first time and will reuse it for the next calls.</p></div></div>
<div class="section" title="NPM and package.json"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>NPM and package.json</h1></div></div></div><p>With Browserify, we can create CommonJS modules that can be executed in the browser. When you use CommonJS modules in the browser, Browserify will provide the necessary tools to load the modules, which includes a definition for the <code class="literal">require()</code> function.</p><p>When you use<a id="id142" class="indexterm"/> Browserify, you can use the Node package manager to install and define dependencies for your projects. A useful tool is the npm command tool, used to<a id="id143" class="indexterm"/> install and manage project dependencies.</p><p>The <code class="literal">package.json</code> file in a Node project is a JSON file used to define, install, and manage the version of the libraries that your project depends on. A <code class="literal">package.json</code> file can contain many<a id="id144" class="indexterm"/> configuration options; you can see the complete documentation on the Node website at <a class="ulink" href="https://docs.npmjs.com/">https://docs.npmjs.com/</a>. Here is a list of the main values.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Name</code> – The name <a id="id145" class="indexterm"/>of the project without spaces</li><li class="listitem" style="list-style-type: disc"><code class="literal">Description</code> – A short<a id="id146" class="indexterm"/> description of the project</li><li class="listitem" style="list-style-type: disc"><code class="literal">Version</code> – A version number for<a id="id147" class="indexterm"/> the project, typically starting with 0.0.1</li><li class="listitem" style="list-style-type: disc"><code class="literal">Dependencies</code> – A list of<a id="id148" class="indexterm"/> libraries with the version number that the project depends on</li><li class="listitem" style="list-style-type: disc"><code class="literal">devDependencies</code> – Same as <a id="id149" class="indexterm"/>dependencies, but this list is used only for development environments—useful for putting libraries for testing, for instance</li><li class="listitem" style="list-style-type: disc"><code class="literal">licence</code> – A license name for<a id="id150" class="indexterm"/> the project code</li></ul></div><p>We can start with a very simple <code class="literal">package.json</code> file that contains only some basic fields, and then we can extend it as needed:</p><div class="informalexample"><pre class="programlisting">{
  "name": "backbone-contacts ",
  "version": "0.0.1",
  "description": "Example code for the book Mastering Backbone.js",
  "author": "Abiee Alejandro &lt;abiee.alejandro@gmail.com&gt;",
  "license": "ISC",
  "dependencies": {
  },
  "devDependencies": {
  }
}</pre></div><p>As you can see, we don't have any dependency yet. We can install our first dependency with <code class="literal">npm</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save underscore jquery backbone bootstrap</strong></span>
</pre></div><p>This <a id="id151" class="indexterm"/>command will install the basic dependencies to work with <code class="literal">backbone</code>; the save flag will update automatically the <code class="literal">package.json</code> file, adding the library <a id="id152" class="indexterm"/>names and its current versions:</p><div class="informalexample"><pre class="programlisting">  "dependencies": {
    "backbone": "^1.2.1",
    "bootstrap": "^3.3.5",
    "jquery": "^2.1.4",
    "underscore": "^1.8.3"
  }</pre></div><p>The format of the library version follows the <code class="literal">semver</code> standard; you can see more about this format in the official <code class="literal">semver</code> website.</p><p>One advantage of using the <code class="literal">package.json</code> file in your project is that, the next time you want to install the dependencies, you don't need to remember the libraries and their versions; you can just hit <span class="strong"><strong>Install</strong></span> without any argument and Node will read the <code class="literal">package.json</code> file and make the installs for you:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install</strong></span>
</pre></div><p>With <code class="literal">npm</code> you can install development packages such as the mocha testing library, but instead of using<a id="id153" class="indexterm"/> the save flag use <code class="literal">save-dev</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev mocha</strong></span>
</pre></div><p>Now that you know how to install dependencies and save them in the <code class="literal">package.json</code> file, we can start <a id="id154" class="indexterm"/>using Browserify in the Contacts app.</p></div>
<div class="section" title="Browserify"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Browserify</h1></div></div></div><p>With Browserify we can use Node modules directly in the browser. This means that you can build your projects with the power of the npm package manager and the Node module syntax exposed in the previous sections. Then Browserify can take your source code and apply <a id="id155" class="indexterm"/>some transformations to be able to run your code in the<a id="id156" class="indexterm"/> browser environment.</p><p>A very simple module that exposes an object with a method that prints a hello message can be written as a Node module:</p><div class="informalexample"><pre class="programlisting">// hello.js
module.exports = {
  sayHello: function(name) {
    name = name || 'world';
    console.log('hello', name);
  }
}</pre></div><p>This simple piece of code can be loaded from another script as shown next:</p><div class="informalexample"><pre class="programlisting">// main.js
var hello = require('./hello');
hello.sayHello();        // hello world
hello.sayHello('abiee'); // hello abiee</pre></div><p>This code works perfectly with Node. You can run it as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ node main.js</strong></span>
</pre></div><p>However this code will not run in the browser because the <code class="literal">require</code> function and the module object are not defined. Browserify takes your project entry code and tracks all the dependencies to create a single file with all the scripts concatenated:</p><div class="informalexample"><pre class="programlisting">$ browserify main.js
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  sayHello: function(name) {
    name = name || 'world';
    console.log('hello', name);
  }
}

},{}],2:[function(require,module,exports){
var hello = require('./hello');

hello.sayHello();
hello.sayHello('abiee');

},{"./hello":1}]},{},[2]);</pre></div><div class="mediaobject"><img src="graphics/B01962_04_01.jpg" alt="Browserify"/><div class="caption"><p>Figure 4.1 Bundling with Browserify</p></div></div><p>Note that <a id="id157" class="indexterm"/>our code is still in there; Browserify makes the definition of the missing objects and concatenates all the script in a single file. Figure 4.1 shows a graphical representation of what happens. If you use libraries such as Backbone, then your final script will contain all the Backbone code in the output file.</p><p>To tell Browserify that you want to create a file instead of just putting the result in the standard output, use the <code class="literal">-o</code> flag:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ browserify main.js -o app.js</strong></span>
</pre></div><p>That will create an app.js<a id="id158" class="indexterm"/> file with the contents of the <code class="literal">hello.js</code> and <code class="literal">main.js</code> files.</p></div>
<div class="section" title="Application dependency"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Application dependency</h1></div></div></div><p>When the <a id="id159" class="indexterm"/>application is loaded in the browser, it loads all the JavaScript files in a specific order. The order is important because it represents the chain of dependencies.</p><div class="informalexample"><pre class="programlisting">&lt;script src="js/vendor/jquery-2.1.4.min.js"&gt;&lt;/script&gt;
&lt;script src="js/vendor/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;script src="js/vendor/sweetalert.min.js"&gt;&lt;/script&gt;
&lt;script src="js/vendor/jquery.noty.packaged.min.js"&gt;&lt;/script&gt;
&lt;script src="js/vendor/underscore-min.js"&gt;&lt;/script&gt;
&lt;script src="js/vendor/backbone-min.js"&gt;&lt;/script&gt;
&lt;script src="js/vendor/backbone-validation-min.js"&gt;&lt;/script&gt;

&lt;script src="js/common.js"&gt;&lt;/script&gt;
&lt;script src="js/app.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/router.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/models/contact.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/models/phone.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/models/email.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/collections/contactCollection.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/collections/phoneCollection.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/collections/emailCollection.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/contactList.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/contactViewer.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/contactEditor.js"&gt;&lt;/script&gt;
&lt;script src="js/apps/contacts/app.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;App.start();&lt;/script&gt;</pre></div><p>This is the standard way of script loading; the browser is responsible to parse these script tags, fetch the script files from the assets server, and then execute them in that order. So that the Browser will execute jQuery, then Bootstrap, then Underscore and so on.</p><p>As you know, Backbone depends on Underscore and jQuery to work; it uses jQuery to handle DOM selections in Backbone views and Underscore as the utility library. For this reason, jQuery and Underscore should be loaded before Backbone.</p><p>In the project code, <code class="literal">app.js</code> depends on Backbone, so that it's loaded after Backbone. The <code class="literal">apps/contacts/app.js</code> module is the application façade. It depends on all the other modules in the subapplications, which is why it's loaded last.</p><p>Figure 4.2 shows the dependency of the modules graphically. Note that it's a simplification and<a id="id160" class="indexterm"/> not all the dependencies are shown.</p><div class="mediaobject"><img src="graphics/B01962_04_02.jpg" alt="Application dependency"/><div class="caption"><p>Figure 4.2 Dependency graph</p></div></div></div>
<div class="section" title="Using Browserify in the app"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Using Browserify in the app</h1></div></div></div><p>Until now we have<a id="id161" class="indexterm"/> learned about what Browserify is and how to<a id="id162" class="indexterm"/> use it. Now we will apply that background to our contacts app to load all the code as Node modules.</p><p>Before we continue, ensure that you have installed all the required dependencies for the project:</p><div class="informalexample"><pre class="programlisting">{
  "name": "mastering-backbone-04",
  // ...
  "dependencies": {
    "backbone": "^1.2.3",
    "backbone-validation": "^0.11.5",
    "body-parser": "^1.14.1",
    "bootstrap": "^3.3.5",
    "browser-sync": "^2.9.11",
    "crispy-string": "0.0.2",
    "express": "^4.13.3",
    "http-proxy": "^1.11.3",
    "jquery": "^2.1.4",
    "lodash": "^3.10.1",
    "morgan": "^1.6.1",
    "sweetalert": "^1.1.3",
    "underscore": "^1.8.3"
  }
}</pre></div><p>The easiest modules to convert are Models and Collections because they don't have huge dependencies.</p><div class="informalexample"><pre class="programlisting">// apps/contacts/models/contact.js
'use strict'

var Backbone = require('backbone');

class Contact extends Backbone.Model {
  // ...
}

module.exports = Contact;</pre></div><p>As you can see, the module remains almost the same. We have just added the <code class="literal">require()</code> calls and the export statement at the end of the file:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactCollection.js
'use strict';

var Backbone = require('backbone');
var Contact = require('../models/contact');

class ContactCollection extends Backbone.Collection {
  // ...

  get model() {
return Contact;
  }
}

module.exports = ContactCollection;</pre></div><p>Views are easy to<a id="id163" class="indexterm"/> convert, too. We just have to add the <code class="literal">require()</code> calls as we did with the <code class="literal">Contact</code> and <code class="literal">ContactCollection</code> modules. Before we continue, we need an extra step with the views; currently all the views for a given controller are contained in a single script; <code class="literal">contactEditor.js</code> for example contains <code class="literal">ContactForm</code>, <code class="literal">ContactPreview</code>, and <code class="literal">PhoneList</code>, and<a id="id164" class="indexterm"/> so on.</p><p>As we are modularizing the project, it's a good idea to put each view in its own file and require it when we need it. The following shows this idea. You have many good reasons to do this: to isolate your components for testing, to keep your files small, to improve maintenance, and to get interchangeable modules.</p><div class="mediaobject"><img src="graphics/B01962_04_03.jpg" alt="Using Browserify in the app"/><div class="caption"><p>Figure 4.3 Splitting views to their own files</p></div></div><div class="informalexample"><pre class="programlisting">'use strict';

var Layout = require('../../common').Layout;

class ContactFormLayout extends Layout {
// ...
}

module.exports = ContactFormLayout;</pre></div><p>As you can see, the conversion of plain JavaScript files to Node modules is very easy to do. The code of the<a id="id165" class="indexterm"/> business logic is exactly the same. The<a id="id166" class="indexterm"/> subapplication controller depends on the views that we have converted on the previous step.</p><div class="informalexample"><pre class="programlisting">'use strict';

var _ = require('underscore');
var Backbone = require('backbone');
var App = require('../../app');
var ContactFormLayout = require('./views/contactFormLayout');
var ContactPreview = require('./views/contactPreview');
var PhoneListView = require('./views/phoneListView');
var EmailListView = require('./views/emailListView');
var ContactForm = require('./views/contactForm');
var PhoneCollection = require('./collections/phoneCollection');
var EmailCollection = require('./collections/emailCollection');

class ContactEditor {
  // ...
}

module.exports = ContactEditor;</pre></div><p>The application façade<a id="id167" class="indexterm"/> depends on many subapplication controllers, the models, and the collections:</p><div class="informalexample"><pre class="programlisting">'use strict';

var App = require('../../app');
var ContactList = require('./contactList');
var ContactViewer = require('./contactViewer');
var ContactEditor = require('./contactEditor');
var Contact = require('./models/contact');
var ContactCollection = require('./collections/contactCollection');

function ContactsApp(options) {
  // ...
}

// ...

module.exports = ContactsApp;</pre></div><p>The routers depend<a id="id168" class="indexterm"/> on the subapplication façade and the application infrastructure:</p><div class="informalexample"><pre class="programlisting">'use strict';

var Backbone = require('backbone');
var App = require('../../app');
var ContactsApp = require('./app');

var ContactsRouter = Backbone.Router.extend({
  // ...
});

module.exports = new ContactsRouter();</pre></div><p>The App object is<a id="id169" class="indexterm"/> responsible for loading all the subapplication routers and then starting the history module:</p><div class="informalexample"><pre class="programlisting">'use strict';

var _ = require('underscore');
var Backbone = require('backbone');
var BackboneValidation = require('backbone-validation');
var swal = require('sweetalert');
var noty = require('noty');
var Region = require('./common').Region;

// Initialize all available routes
require('./apps/contacts/router');

var App = {
start() {
    // The common place where sub-applications will be showed
    App.mainRegion = new Region({el: '#main'});

    // Create a global router to enable sub-applications to
    // redirect to other URLs
    App.router = new DefaultRouter();
    Backbone.history.start();
  },

// ...
};

// ...

module.exports = App;</pre></div><p>The next step is to start the application by calling the <code class="literal">start()</code> method on the App object; this is done from<a id="id170" class="indexterm"/> the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;App.start();&lt;/script&gt;</pre></div><p>As we are re-packing the application with Browserify, it's better to create a new file to the main entry point:</p><div class="informalexample"><pre class="programlisting">// main.js
var App = require('./app');

App.start();</pre></div><p>Once our application is written as Node modules, we can use Browserify to bundle the code in a single script:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir –p .tmp/js</strong></span>
<span class="strong"><strong>$ cd app/js</strong></span>
<span class="strong"><strong>$ browserify main.js -o ../../.tmp/js/app.js</strong></span>
</pre></div><p>This will create a<a id="id171" class="indexterm"/> bundled file with all the dependencies on it. To use the bundled version of the code, we have to change the <code class="literal">index.htm</code> file to load it instead of loading all the individual files:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
    // ...
&lt;/head&gt;
&lt;body&gt;
// ...
&lt;script src="js/app.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>That should be <a id="id172" class="indexterm"/>enough; however, the application won't start because we have a cyclic dependency issue.</p><div class="section" title="Solving cyclic dependency"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Solving cyclic dependency</h2></div></div></div><p>Having two modules that depend on each other is<a id="id173" class="indexterm"/> called <span class="strong"><strong>cyclic dependency</strong></span>. In our Contacts <a id="id174" class="indexterm"/>application, the<a id="id175" class="indexterm"/> infrastructure application depends on the subapplication routers, and the routers depend on the application infrastructure to load the subapplication controllers and facades. Figure 4.4 shows how this looks.</p><div class="mediaobject"><img src="graphics/B01962_04_04.jpg" alt="Solving cyclic dependency"/><div class="caption"><p>Figure 4.4 Cyclic dependencies</p></div></div><p>It is not possible to<a id="id176" class="indexterm"/> run the application properly because of the cyclic dependency. Here is what happens in detail.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The App<a id="id177" class="indexterm"/> module is executed</li><li class="listitem" style="list-style-type: disc">The App requires <code class="literal">ContactsRouter</code>:<div class="informalexample"><pre class="programlisting">var ContactsRouter = require('./apps/contacts/router');</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">ContactsRouter</code> requires the App module but the App module is not exported yet:<div class="informalexample"><pre class="programlisting">var App = require('../../app'); // returns undefined</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">ContactsRouter</code> receives an <code class="literal">undefined</code> value for the App variable</li><li class="listitem" style="list-style-type: disc">The App module continue the execution and finally exposes the App value:<div class="informalexample"><pre class="programlisting">var App = {
  // ...
};

module.exports = App;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">ContactsRouter</code> matches a route, but as the App value is undefined it triggers an error:<div class="informalexample"><pre class="programlisting">startApp() {
  // App = undefined
  return App.startSubApplication(ContactsApp);
}</pre></div></li></ul></div><p>We should break the cycle in some way. An easy approach to do it is to require the App module after it is exported. Instead of requiring the <code class="literal">App</code> module from <code class="literal">ContactsRouter</code> on top of the<a id="id178" class="indexterm"/> file, we can do it only when it's necessary:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/router.js
class ContactsRouter extends Backbone.Router {
  // ...

  startApp() {
    var App = require('../../app');
    var ContactsApp = require('./app');
    return App.startSubApplication(ContactsApp);
  }
}</pre></div><p>This is a simple but<a id="id179" class="indexterm"/> effective way to break a cyclic dependency. Now you can re-bundle the application and run the application again. It should work:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir –p .tmp/js</strong></span>
<span class="strong"><strong>$ cd app/js</strong></span>
<span class="strong"><strong>$ browserify main.js -o ../../.tmp/js/app.js</strong></span>
</pre></div></div></div>
<div class="section" title="Modularizing templates"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Modularizing templates</h1></div></div></div><p>Until now, templates have been declared as script tags in the <code class="literal">index.html</code> file. While this is a good approach for small projects, it is not a good idea to put all your templates directly in the HTML file.</p><p>With Browserify, you can extract all your template files into individual files, with the advantage of modularization and a cleaner <code class="literal">index.html</code> file. Another benefit of modularizing<a id="id180" class="indexterm"/> templates is that you can pre-compile all the templates, saving resources in your users' browsers.</p><p>With Browserify, you can modularize almost any template format: jade, Handlebars, Underscore, and so on. It uses a transformation process described in Figure 4.5. If you have worked with other bundler tools such as webpack, transformations are analogous to pre-processors.</p><div class="mediaobject"><img src="graphics/B01962_04_05.jpg" alt="Modularizing templates"/><div class="caption"><p>Figure 4.5 The transformation process</p></div></div><p>Templates are in plain text; the text is passed to a function that compiles it into a JavaScript function that Browserify can process as a regular JavaScript file. To apply the necessary transformation to the templates, you will need to install a transformation plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev jstify</strong></span>
</pre></div><p>The transformation process take place when you instruct webpack to use jstify at compilation time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ browserify main.js -t [ jstify --engine underscore ] -o ../../.tmp/js/app.js</strong></span>
</pre></div><p>Templates are easy to modularize; just extract the text in the script tags and put it in a new file:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/templates/contactListLayout.tpl
&lt;div class="actions-bar-container"&gt;&lt;/div&gt;
&lt;div class="list-container"&gt;&lt;/div&gt;
&lt;div class="footer text-muted"&gt;
  © 2015. &lt;a href="#"&gt;Mastering Backbone.js&lt;/a&gt; by &lt;a href="https://twitter.com/abieealejandro" target="_blank"&gt;Abiee Alejandro&lt;/a&gt;
&lt;/div&gt;</pre></div><p>The <code class="literal">contactListLayout.tpl</code> now contains the text of the layout template for the contact list. In the <code class="literal">ContactListLayout</code> view you can import the template as a regular JavaScript file <a id="id181" class="indexterm"/>but do not forget to include the <code class="literal">tpl</code> extension:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/views/contactListLayout.js
'use strict';

var Layout = require('../../../common').Layout;
var template = require('../templates/contactListLayout.tpl');

class ContactListLayout extends Layout {
  constructor(options) {
    super(options);
    this.template = template;
    this.regions = {
      actions: '.actions-bar-container',
      list: '.list-container'
    };
  }

  get className() {
    return 'row page-container';
  }
}

module.exports = ContactListLayout;</pre></div><p>When you import the<a id="id182" class="indexterm"/> template, you will use a function. Because our common views support both CSS selectors and pre-compiled templates it should work properly:</p><div class="informalexample"><pre class="programlisting">// common.js
render() {
  // Get JSON representation of the model
  var data = this.serializeData();
  var renderedHtml;

  // If template is a function assume that is a compiled
  // template, if not assume that is a CSS selector where
  // the template is defined and is compatible with
  // underscore templates
  if (_.isFunction(this.template)) {
    renderedHtml = this.template(data);
  } else if (_.isString(this.template)) {
    var compiledTemplate = this.compileTemplate();
    renderedHtml = compiledTemplate(data);
  }

  this.$el.html(renderedHtml);

  // Call onRender callback if is available
  if (this.onRender) {
    this.onRender();
  }

  return this;
}</pre></div><p>Now you have <a id="id183" class="indexterm"/>a fully modularized project where each piece of code is in a small file; one advantage of this is that you can focus on small chunks of code instead and avoid the overhead of large files.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we have learned what Browserify is and how you can organize your projects into Node modules to manage your code and dependencies in a cleaner way. To make the Contacts project compatible with <code class="literal">npm</code>, we had to alter the code of the project; however, the changes are minimal.</p><p>There are other alternatives to Browserify, too; require.js and the AMD module definition are good to work with. However testing with require.js could be very difficult; I don't recommend you use <code class="literal">require.js</code> if you want to test isolated modules (unit testing).</p><p>Webpack is another popular choice to bundle and organize your code base. Its main purpose is to work with frontend dependencies; it can load CommonJS modules and AMD modules. However, webpack is more complicated to configure and manage.</p><p>Browserify is the most popular choice for bundling JavaScript projects and is easier to configure and maintain than webpack; it is useful to use the same tools that Node uses to manage its dependencies and it does a great job.</p><p>In the next chapter, we will explore how to deal with files in a Backbone project; handling files over a RESTful API is a common issue, so we will discover what the common patterns and strategies are.</p><p>In Chapter 7, we will explore how to build applications with automation tools; instead of manually running the Browserify command each time we change the code, we will create the necessary scripts that will do it for us.</p></div></body></html>