- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Modules and Secrets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和秘密
- en: While routing is certainly important to SvelteKit, there is far more to it than
    just that. Throughout this book, we’ve utilized multiple different SvelteKit modules.
    For instance, we’ve imported bindings from `$app/forms`, `$app/environment`, and
    `$app/stores`, to name a few. But we have yet to explore what these modules are
    or how they work. In this chapter, we’ll give a brief overview of some of the
    modules we’ve seen previously as well as some we have not yet seen. We’ll also
    cover some of the modules used for managing secrets and when to use which ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然路由对于 SvelteKit 来说确实很重要，但它远不止于此。在这本书的整个过程中，我们使用了多个不同的 SvelteKit 模块。例如，我们已从
    `$app/forms`、`$app/environment` 和 `$app/stores` 等模块中导入绑定，仅举几个例子。但我们尚未探讨这些模块是什么，以及它们是如何工作的。在本章中，我们将简要概述我们之前看到的一些模块以及我们尚未看到的一些模块。我们还将涵盖一些用于管理秘密的模块以及何时使用哪个模块。
- en: 'In this chapter, we’ll examine the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查以下内容：
- en: SvelteKit Module Summaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SvelteKit 模块摘要
- en: Keeping Secrets Safe
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护秘密安全
- en: Having covered various modules, as well as examining our previous example of
    storing GitHub API secrets, we’ll have a clear understanding of when best to harness
    the power of each individual module.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了各种模块，并检查了我们之前存储 GitHub API 秘密的示例之后，我们将清楚地了解何时最好利用每个单独模块的力量。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter11](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter11).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在 GitHub 上找到：[https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter11](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter11)。
- en: SvelteKit Module Summaries
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SvelteKit 模块摘要
- en: In previous chapters, we’ve used several different modules but only provided
    short explanations. While the analysis in this section will also be brief, it
    should provide a broad enough insight that prospective SvelteKit developers feel
    familiar with the workings of available modules. We have encountered a few listed
    here but there are some that we are yet to cover. For more in-depth explanations,
    see the resources at the end of this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了几个不同的模块，但只提供了简短的说明。虽然本节的分析也将是简短的，但它应该提供足够广泛的洞察，让潜在的 SvelteKit 开发者熟悉现有模块的工作原理。我们已经遇到了这里列出的几个，但还有一些我们尚未涉及。对于更深入的解释，请参阅本章末尾的资源。
- en: $app/environment
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $app/environment
- en: To begin our analysis of modules, let’s start with one that we have used relatively
    recently. In [*Chapter 9*](B19024_09_Final_AM.xhtml#_idTextAnchor116), while attempting
    to throw an error in the client, we used the `$app/environment` module and imported
    `browser`. As we’ve come to expect with SvelteKit naming conventions, all of the
    bindings exported from this module pertain to the application environment. This
    makes it trivial to identify the purpose of each of the bindings by their names.
    For instance, we saw that `browser` returns a Boolean value based on whether or
    not the environment it is being run in is the client. Likewise, `building` and
    `dev` will return Boolean values based on whether or not the code is being run
    during the build process or in our development environment, respectively. The
    final export from `$app/environment` is `version`. While `version` is still appropriately
    named, it’s important to note that it doesn’t refer to the version of SvelteKit.
    Rather, it refers to the version of the application build. The value of `version`
    is determined by the Unix timestamp at the time of building. SvelteKit uses this
    string value to check for a new version when client-side navigation encounters
    an error and defaults to standard navigation practices by making a full-page load.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始对模块的分析，让我们从一个我们相对近期使用过的模块开始。在 [*第 9 章*](B19024_09_Final_AM.xhtml#_idTextAnchor116)
    中，当我们试图在客户端抛出错误时，我们使用了 `$app/environment` 模块并导入了 `browser`。正如我们预期的那样，根据 SvelteKit
    命名约定，从这个模块导出的所有绑定都与应用程序环境相关。这使得通过它们的名称识别每个绑定的目的变得非常简单。例如，我们看到 `browser` 返回一个布尔值，基于它正在运行的运行环境是否是客户端。同样，`building`
    和 `dev` 将根据代码是否在构建过程中运行或在我们的开发环境中运行分别返回布尔值。`$app/environment` 的最后一个导出是 `version`。虽然
    `version` 的命名仍然很合适，但重要的是要注意，它并不指代 SvelteKit 的版本。相反，它指的是应用程序构建的版本。`version` 的值由构建时的
    Unix 时间戳确定。SvelteKit 使用这个字符串值在客户端导航遇到错误时检查新版本，并通过执行完整页面加载来默认使用标准导航实践。
- en: $app/forms
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $app/forms
- en: When we utilized `enhance` from `$app/forms` in [*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060),
    we saw how it could *progressively enhance* our form submissions by sending data
    in the background instead of requiring our entire page to be reloaded when submitting
    the form. If the default behavior of `enhance` has not quite satisfied our needs,
    it can be customized. If we decide to change its default behavior and provide
    it with a custom callback function, `applyAction` can be used to update the data
    within the `form` property of our components. The final binding we can import
    from `$app/forms` is `deserialize`, which is a helpful function when deserializing
    response data from a form submission.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [*第四章*](B19024_04_Final_AM.xhtml#_idTextAnchor060) 中使用 `$app/forms` 的 `enhance`
    时，我们看到了它如何通过在提交表单时在后台发送数据而不是要求整个页面重新加载来 *渐进式增强* 我们的表单提交。如果 `enhance` 的默认行为没有完全满足我们的需求，它可以被自定义。如果我们决定改变其默认行为并提供一个自定义的回调函数，可以使用
    `applyAction` 来更新组件 `form` 属性中的数据。我们可以从 `$app/forms` 中导入的最后一个绑定是 `deserialize`，这是一个在反序列化表单提交的响应数据时非常有用的函数。
- en: $app/navigation
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$app/navigation`'
- en: As expected, `$app/navigation` provides tools pertaining to navigation. We previously
    used `invalidateAll` in [*Chapter 5*](B19024_05_Final_AM.xhtml#_idTextAnchor072)
    and `invalidate` in [*Chapter 9*](B19024_09_Final_AM.xhtml#_idTextAnchor116) from
    this module. In both of those instances, we did so to force `load()` to run again.
    Some other helpful bindings from this module are `afterNavigate` and `beforeNavigate`.
    Both of these bindings run callback functions at specific timings within the SvelteKit
    life cycle. With `afterNavigate`, the provided callback is executed once the current
    component has mounted and after the user has navigated to a new URL. The callback
    function for `beforeNavigate` is run just before navigating to a new URL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`$app/navigation` 提供了与导航相关的工具。我们之前从这个模块中使用了 `invalidateAll` 在 [*第五章*](B19024_05_Final_AM.xhtml#_idTextAnchor072)
    和 `invalidate` 在 [*第九章*](B19024_09_Final_AM.xhtml#_idTextAnchor116)。在这两个实例中，我们这样做是为了强制
    `load()` 再次运行。从这个模块中还有其他一些有用的绑定，如 `afterNavigate` 和 `beforeNavigate`。这两个绑定在 SvelteKit
    生命周期中的特定时间运行回调函数。使用 `afterNavigate`，提供的回调函数在当前组件挂载后以及用户导航到新 URL 后执行。`beforeNavigate`
    的回调函数在导航到新 URL 前运行。
- en: Some other bindings available from this particular module include `disableScrollHandling`,
    `goto`, `preloadCode`, and `preloadData`. If we wanted to change how SvelteKit
    manages the browser window scrolling position, we could disable it entirely by
    calling `disableScrollHandling()`. The `goto()` function provides developers with
    the ability to navigate to another URL while also including options that allow
    for the management browser history, keeping focus applied to a particular element,
    and even triggering the rerun of `load()` functions. The `preloadCode()` function
    allows developers to import the code for a particular route before that route
    has been navigated to, while `preloadData()` will do the same as well as calling
    the route’s `load()` function. The same behavior of `preloadData()` is found when
    `<a>` elements are given the `data-sveltekit-preload-data` attribute.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个特定模块中可用的其他绑定包括 `disableScrollHandling`、`goto`、`preloadCode` 和 `preloadData`。如果我们想改变
    SvelteKit 管理浏览器窗口滚动位置的方式，我们可以通过调用 `disableScrollHandling()` 完全禁用它。`goto()` 函数为开发者提供了在导航到另一个
    URL 的同时，包括允许管理浏览器历史记录、保持特定元素的关注焦点以及触发 `load()` 函数重新运行的功能。`preloadCode()` 函数允许开发者在使用特定路由之前导入该路由的代码，而
    `preloadData()` 将执行相同的功能，同时也会调用路由的 `load()` 函数。当 `<a>` 元素被赋予 `data-sveltekit-preload-data`
    属性时，也会发现 `preloadData()` 的相同行为。
- en: $app/paths
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$app/paths`'
- en: When we need to manipulate file paths or create links to routes for our application
    that reside in a sub-directory, we can rely on `$app/paths`. Both `assets` and
    `base` will return a string value that can be customized in `svelte.config.js`
    under `config.kit.paths`. If the application is being served from a subdirectory,
    we can prepend manually written routes with the `{base}` text to ensure our application
    serves the route from the correct directory and does not attempt to serve the
    route from the domain root directory. The value provided by `base` must always
    be a root-relative path that begins with a `/` but never ends with one. Conversely,
    `assets` will always be an absolute path to the application files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要操作文件路径或为位于子目录中的应用程序创建路由链接时，我们可以依赖 `$app/paths`。`assets` 和 `base` 都将返回一个字符串值，该值可以在
    `svelte.config.js` 中的 `config.kit.paths` 下自定义。如果应用程序是从子目录中提供的，我们可以手动将 `{base}`
    文本添加到路由之前，以确保我们的应用程序从正确的目录中提供路由，而不是尝试从域名根目录提供路由。`base` 提供的值必须始终是一个以 `/` 开始但永不以
    `/` 结尾的根相关路径。相反，`assets` 将始终是应用程序文件的绝对路径。
- en: $app/stores
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $app/stores
- en: The SvelteKit developers were kind enough to provide developers with a few readable
    stores that can supply us with helpful information. When importing from `$app/stores`,
    we’ll have access to `navigating`, `page`, `updated`, and `getStores`. During
    navigation, `navigating` will be populated with an object consisting of metadata
    such as where the navigation event started, where it is going, and the type of
    navigation. The type can range from a form submission to a link click, or even
    a browser back-and-forward event. Once navigation has been completed, the value
    of this store will return to `null`. Meanwhile, `page` serves as a store that
    contains information related to the currently viewed page. We used it back in
    [*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060) to display the current
    page’s error message. The `updated` store will return a Boolean value after SvelteKit
    has checked whether or not a new version of the application has been detected.
    All of these stores can be retrieved by calling `getStores()`but doing so is not
    recommended and should only be done when the store subscription needs to be paused
    until after a component has mounted. Otherwise, all store values can be accessed
    by prefixing the store name with the `$` symbol, which will automatically handle
    the subscription process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SvelteKit 开发者非常慷慨，为开发者提供了一些可读的存储，这些存储可以为我们提供有用的信息。当我们从 `$app/stores` 导入时，我们将能够访问
    `navigating`、`page`、`updated` 和 `getStores`。在导航期间，`navigating` 将填充一个包含元数据的对象，例如导航事件开始的位置、目的地以及导航类型。类型可以从表单提交到链接点击，甚至浏览器的前进和后退事件。一旦导航完成，此存储的值将返回
    `null`。同时，`page` 作为包含与当前查看页面相关信息的存储。我们曾在 [*第 4 章*](B19024_04_Final_AM.xhtml#_idTextAnchor060)
    中使用它来显示当前页面的错误消息。`updated` 存储在 SvelteKit 检查是否检测到应用程序的新版本后，将返回一个布尔值。所有这些存储都可以通过调用
    `getStores()` 来检索，但这样做并不推荐，并且仅在需要暂停存储订阅直到组件挂载之后时才应这样做。否则，可以通过在存储名称前加上 `$` 符号来自动处理订阅过程来访问所有存储值。
- en: $service-worker
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $service-worker
- en: When building a `$service-worker` module, which can only be used within a service
    worker. When importing bindings, we’ll have access to `base`, `build`, `files`,
    `prerendered`, and `version`. Again, sane naming conventions come to our rescue
    and mostly explain the type of data returned from each of these bindings. We can
    receive a string value from `base`, which works similarly to the `base` from `$app/paths`.
    It will provide us with the base path to the application even if the application
    exists in a subdirectory. The array of strings from `build` will consist of URLs
    generated by Vite during the build process. Another array of strings, `files`,
    will provide details on static files or those included in `config.kit.files.assets`.
    For prerendered path names, we can retrieve the strings from the `prerendered`
    array. And finally, we can use `version` to determine the application version
    within our service worker code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个 `$service-worker` 模块时，它只能在服务工作者中使用。当导入绑定时，我们将能够访问 `base`、`build`、`files`、`prerendered`
    和 `version`。再次强调，合理的命名约定是我们的救星，并且主要解释了从每个绑定返回的数据类型。我们可以从 `base` 接收一个字符串值，它的工作方式与
    `$app/paths` 中的 `base` 类似。即使应用程序位于子目录中，它也会为我们提供应用程序的基本路径。`build` 返回的字符串数组将由 Vite
    在构建过程中生成的 URL 组成。另一个字符串数组 `files` 将提供有关静态文件或包含在 `config.kit.files.assets` 中的文件的详细信息。对于预渲染的路径名，我们可以从
    `prerendered` 数组中检索字符串。最后，我们可以使用 `version` 在我们的服务工作者代码中确定应用程序版本。
- en: This list of modules is by no means comprehensive. Before leaning on them too
    heavily, it’s recommended to read the official SvelteKit documentation listed
    at the end of this chapter. Now that we’ve examined some of these modules, let’s
    move on to the modules that help us keep sensitive information safe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Keeping secrets safe
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to keeping secrets such as API keys or database credentials safe,
    SvelteKit has us covered. As we saw in [*Chapter 9*](B19024_09_Final_AM.xhtml#_idTextAnchor116),
    we can import `.env` secrets from `$env/static/private`. But this is not the only
    module that allows us to import environment variables. In this section, we’ll
    examine more modules and how they all can help us import environment variables
    as well as secrets.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: $env/static/private
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beginning with the module we’ve already used, `$env/static/private` is great
    for importing environment variables like those specified in `.env` files or those
    set when starting the runtime. For instance, if we were to start our application
    with the `API_KEY="" node index.js` command, the `API_KEY` variable would be available,
    just as `GITHUB` was available after we imported `$env/static/private` in [*Chapter
    9*](B19024_09_Final_AM.xhtml#_idTextAnchor116). Any environment variables provided
    when starting the application will override the value of those provided in a `.env`
    file. The variables from this module are statically bundled within the application
    code at build time by Vite. This means less bundled code but also means that secrets
    will be included in the application build. We can confirm this by building the
    following commands:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Substituting `YOUR_API_KEY` with your personal access token provided by GitHub
    will show the text and the file in our build where our API key has been injected.
    As such, we should be cautious not to commit builds to version control as doing
    so could then expose secrets. Fortunately for us, this module will only work with
    server-side code and will cause a build to fail if we attempt to import it into
    client-side code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: $env/static/public
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can consider `$env/static/public` a sibling to `$env/static/private`. The
    major difference is that this module will only import variables that begin with
    the value set in `config.kit.env.publicPrefix`. By default, this value is `PUBLIC_`.
    This allows us to keep our secrets all in the same `.env` file while allowing
    us to specify which are safe to expose to clients and which are not. For example,
    the following `.env` file would allow for `PUBLIC_GITHUB_USER` to be imported
    into client-side code but not `GITHUB_TOKEN`. Even though both values exist in
    the same file, we can rest assured knowing that SvelteKit won’t tell our secrets
    to anyone other than the server we know we can trust:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: .env
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: $env/dynamic/private
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as we cannot import `$env/static/private` into client-side code, we cannot
    import `$env/dynamic/private` into client-side code either. The difference between
    these two modules is that while the `$env/static` modules have access to `.env`
    files, `$env/dynamic` has access to the environment variables specified by the
    adapter. Think back to [*Chapter 8*](B19024_08_Final_AM.xhtml#_idTextAnchor106)
    when we deployed our application to Cloudflare. When we did that, we specified
    the environment variable `NODE_VERSION`. Obtaining the Node version likely isn’t
    very useful to us but using `$env/dynamic/private` allows us to access other secrets
    set in our Cloudflare Pages project settings. This can be helpful when working
    in a team as sharing secrets can be done on the platform rather than passing around
    `.env` files. When the platform the project will be deployed to has its own means
    of setting environment variables, it’s very likely you’ll be relying on `$env/dynamic`
    to access them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们不能将 `$env/static/private` 导入客户端代码中一样，我们也不能将 `$env/dynamic/private` 导入客户端代码中。这两个模块之间的区别在于，虽然
    `$env/static` 模块可以访问 `.env` 文件，但 `$env/dynamic` 可以访问适配器指定的环境变量。回想一下[*第8章*](B19024_08_Final_AM.xhtml#_idTextAnchor106)，当我们将应用程序部署到
    Cloudflare 时。当我们这样做时，我们指定了环境变量 `NODE_VERSION`。获取 Node 版本可能对我们来说并不非常有用，但使用 `$env/dynamic/private`
    允许我们访问在 Cloudflare Pages 项目设置中设置的其它秘密。这在团队合作中非常有用，因为可以在平台上共享秘密，而不是传递 `.env` 文件。当项目将要部署的平台有自己的设置环境变量的方式时，你很可能要依赖
    `$env/dynamic` 来访问它们。
- en: $env/dynamic/public
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $env/dynamic/public
- en: By following the established pattern, this module should need little explanation.
    With `$env/dynamic/public`, we will only be able to import environment variables
    that begin with `PUBLIC_` or whatever value has been specified in `config.kit.env.publicPrefix`.
    This works in the same way as `$env/static/public`. Of course, it differs from
    `$env/static/public` because this is another dynamic module, which means it is
    specific to the configured environment adapter. For instance, if we were to add
    `PUBLIC_GITHUB_USER` to our Cloudflare Pages environment variables, we would then
    be able to access the value of that environment variable using this module.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照既定的模式，本模块应该只需要很少的解释。使用 `$env/dynamic/public`，我们只能导入以 `PUBLIC_` 或者在 `config.kit.env.publicPrefix`
    中指定的任何值开头的环境变量。这与 `$env/static/public` 的工作方式相同。当然，它与 `$env/static/public` 不同，因为这是一个另一个动态模块，这意味着它是特定于配置的环境适配器的。例如，如果我们把
    `PUBLIC_GITHUB_USER` 添加到我们的 Cloudflare Pages 环境变量中，那么我们就可以使用这个模块来访问该环境变量的值。
- en: Summary
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There are a great many modules available within SvelteKit. Hopefully, this brief
    overview has given enough insight so that we know where to start with each of
    them. In the next chapter, we’ll examine some best practices for enhancing accessibility,
    which can come with the added benefit of improving **Search Engine** **Optimization**
    (**SEO**).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SvelteKit 中有大量的模块可用。希望这个简要概述已经提供了足够的洞察力，以便我们知道如何开始使用每一个模块。在下一章中，我们将探讨一些增强可访问性的最佳实践，这可以带来提高**搜索引擎优化**（**SEO**）的额外好处。
- en: Resources
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: SvelteKit Module Documentation – [https://kit.svelte.dev/docs/modules](https://kit.svelte.dev/docs/modules)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SvelteKit 模块文档 – [https://kit.svelte.dev/docs/modules](https://kit.svelte.dev/docs/modules)
