- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: The Time-Traveler’s Dilemma – State-Driven End to End User Journeys
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间旅行者的困境——基于状态的端到端用户旅程
- en: This chapter addresses a different but common type of test automation – navigating
    through a survey, page by page, to reach a common endpoint. The challenge here
    is that decisions made by a user along the way can change the order of the pages
    displayed downstream – that’s if they appear at all. In this case, we need a fluid
    user journey that can take many branches to get to a common endpoint, as well
    as report if a path ended with an error page. It is inefficient to try to create
    an expanding path of pages for end-to-end automation. The amount of `if`/`then`
    branches or `select`/`case` options would be infinite and complex. To solve this,
    we will explore ways to identify each page by its URL and look at ways to decouple
    page paths, allowing tests to handle sequential pages in any order with minimal
    maintenance. Imagine this approach as a ball bouncing randomly through multiple
    pegs of a giant Pachinko game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了不同但常见的一种测试自动化类型——逐页导航通过调查，以达到一个共同终点。这里的挑战是，用户在途中做出的决定可能会改变下游显示的页面顺序——如果它们甚至出现的话。在这种情况下，我们需要一个灵活的用户旅程，可以走许多分支到达一个共同终点，并且能够报告是否有路径以错误页面结束。尝试为端到端自动化创建一个不断扩展的页面路径是不高效的。`if`/`then`分支或`select`/`case`选项的数量将是无限的且复杂。为了解决这个问题，我们将探讨通过URL识别每一页的方法，并查看解耦页面路径的方法，允许测试以任何顺序处理顺序页面，同时保持最小维护。想象这种方法就像是一个球在大型弹珠游戏中的多个柱子之间随机弹跳。
- en: 'This chapter covers the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Dividing by sections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按章节划分
- en: The happy path
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快乐路径
- en: Extracting page name from the current URL with `getPageName()`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getPageName()`从当前URL中提取页面名称
- en: A page processing loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面处理循环
- en: Common exit points
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见退出点
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All test examples can be found at this GitHub repository: [https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试示例都可以在这个GitHub仓库中找到：[https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO)。
- en: Divide and conquer!
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分而治之！
- en: In this approach, we will be considering a non-deterministic way to navigate
    from our start point to our endpoint. We will not be working on the traditional
    assumption that one page follows another. Instead, our script will pass through
    every potential page repeatedly and interact only if the current page matches
    one of the page classes. Then, based on high-level flow requirements, we can make
    different choices and even enter varied and unique data. We might even find a
    bug along the way!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们将考虑一种非确定性的导航方式，从起点到终点。我们不会基于一个页面跟随另一个页面的传统假设。相反，我们的脚本将反复通过每个潜在的页面，并且只有当当前页面匹配页面类之一时才会进行交互。然后，根据高级流程要求，我们可以做出不同的选择，甚至输入不同的和独特的数据。我们甚至可能会在途中发现一个错误！
- en: 'In this small example, we will automate the Halloween Party feature of the
    Candymapper website. This provides customers with a limited set of options to
    plan a themed party. Party guests use the same site to attend, or avoid, these
    spooktacular events. The following paths are included for customers and guests:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小型示例中，我们将自动化Candymapper网站的万圣节派对功能。这为顾客提供了一组有限的选项来计划主题派对。派对客人可以使用相同的网站参加或避免这些令人毛骨悚然的活动。以下路径包括客户和客人：
- en: Customers can choose to host a zombie theme party
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户可以选择举办僵尸主题派对
- en: Customers can choose to host a ghost theme party
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户可以选择举办幽灵主题派对
- en: Guests can choose to attend a Zombieton party
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客人可以选择参加Zombieton派对
- en: Attend a Ghostville party
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参加幽灵镇派对
- en: Scared guests can exit back to the **Host or Attend** choice page
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惊恐的客人可以退出到**主持人或参加者**选择页面
- en: At least one of these paths will go awry on the [www.Candymapper.com](http://www.Candymapper.com)
    production website. This journey is fixed on the new release of the website at
    [www.CandymapperR2.com](http://www.CandymapperR2.com), as well as the order of
    the pages and new options for attending guests to bring friends.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 至少这些路径中的一个会在[www.Candymapper.com](http://www.Candymapper.com)生产网站上出错。这次旅程在新网站的发布中得到了修正，即[www.CandymapperR2.com](http://www.CandymapperR2.com)，以及页面顺序和为参加派对的客人提供的新的带朋友选项。
- en: 'In the first four of these paths, we will end at the common **Party Countdown**
    timer page. In the last path, we will end up back at the **Halloween Party** Host
    or Attend page. The pages we will encounter include these actions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四条路径中的前四条中，我们将结束在共同的**派对倒计时**计时器页面。在最后一条路径中，我们将回到**万圣节派对**举办者或参加者页面。我们将遇到的页面包括以下操作：
- en: '**Main page**: clear the popup, and click **Halloween Party** in the page header.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：清除弹出窗口，并在页面标题中点击**万圣节派对**。'
- en: '**Halloween Party page**: a choice to host or attend a party'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**万圣节派对页面**：选择举办或参加派对'
- en: '**Host party page**: a location address and “a **Find Out More**” button (Guest
    Path Only)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**举办派对页面**：地点地址和“**了解更多**”按钮（仅限宾客路径）'
- en: '**Party location**: a page with a choice of Zombieton or Ghostville'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**派对地点**：一个可以选择Zombieton或Ghostville的页面'
- en: '**Attend Party page**: with two location choices and a **Scared** return button'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参加派对页面**：有两个地点选择和一个**害怕**返回按钮'
- en: '**Party Location choice page**: Zombieton or Ghostville:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**派对地点选择页面**：Zombieton 或 Ghostville：'
- en: A guest list (dev only)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: （仅限开发者）宾客名单
- en: An email field with “a **Remind Me**” button (dev only)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有“**提醒我**”按钮的电子邮件字段（仅限开发者）
- en: '**Party Time Countdown page**: the final destination'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**派对倒计时页面**：最终目的地'
- en: The core of this test is the `PartyPath()` driver, which takes a single string
    that can be parsed to make decision point changes at multiple milestones. This
    function is a giant loop that passes through every known page repeatedly. For
    each page, we will create an object model and a `build()` method. This method
    executes only if the current page matches the class page type. It returns `true`
    if all actions are successful. If the current page is not this page, it is a `null`
    function and returns `false`. This method will reference a test data model that
    is preconfigured with happy path data, which can be overridden from the `Switchboard`
    object. This will allow choices to be modified in the page flow from beginning
    to end.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试的核心是`PartyPath()`驱动程序，它接受一个可以解析以在多个里程碑处进行决策点更改的单个字符串。这个函数是一个巨大的循环，反复遍历每个已知的页面。对于每个页面，我们将创建一个对象模型和一个`build()`方法。此方法仅在当前页面与类页面类型匹配时执行。如果所有操作都成功，则返回`true`。如果当前页面不是此页面，则是一个`null`函数并返回`false`。此方法将引用一个预先配置了快乐路径数据的测试数据模型，可以从`Switchboard`对象中覆盖。这将允许从开始到结束修改页面流程中的选择。
- en: Simplifying the complexities of a dynamic journey
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化动态旅程的复杂性
- en: In a real-world application, we might be navigating through multiple pages of
    job applications with different data requirements on each one. Some decision points
    might include adding a current address, military status, prior employers’ contact
    information, and personal references. The application process flow might include
    additional pages for someone who is under 21 or a driver who requires proof of
    a specialized license to drive a truck. The multiple paths might ask increasingly
    more information from someone who is single, married, divorced, or widowed with
    dependents.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，我们可能会在多个具有不同数据要求的求职申请页面中导航。一些决策点可能包括添加当前地址、军事状态、前雇主联系信息和个人推荐人。申请流程可能包括为21岁以下的人或需要证明专业驾驶执照以驾驶卡车的驾驶员提供额外的页面。对于单身、已婚、离婚或丧偶且有子女的人，多个路径可能会要求提供越来越多的信息。
- en: The challenge is that no one can predict the next page in the user journey that
    eventually leads to the final successful page destination. However, each of those
    milestones can be described with high-level terms that indicate what to do at
    each decision point.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于没有人能预测用户旅程中的下一页，最终将引导到最终成功的页面目的地。然而，每个里程碑都可以用高级术语来描述，这些术语表明在每个决策点应该做什么。
- en: What if we had a dictionary of terms that could be passed to the tests in almost
    any order, describing the type of applicant applying for the real-world job?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个术语字典，可以按几乎任何顺序传递给测试，描述申请人在现实世界工作中申请的类型？
- en: '`Happy Path`: Single, civilian, over 21, no dependents, and no job history
    or references'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`快乐路径`：单身、平民、21岁以上、无子女、无工作历史或推荐人'
- en: '`married dependents cdl`: This path includes the spouse, children, and CDL
    license information'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已婚子女 cdl`：此路径包括配偶、子女和CDL驾驶执照信息'
- en: '`military underage cu dd`: Uses company-known acronyms for **Credit Union**
    and **Direct Deposit**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`军事未成年 cu dd`：使用公司已知的缩写词**信用合作社**和**直接存款**'
- en: 'For the Halloween Party example, these are the paths that we will follow:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于万圣节派对的例子，我们将遵循以下路径：
- en: '`Happy Path`: Host a zombie-themed party, with a countdown timer as the final
    destination'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`快乐路径`：举办一个以僵尸为主题的派对，倒计时计时器作为最终目的地'
- en: '`Attend`/ `""Attend zombie"":` Attends a party with a decision point for a
    zombie theme over the default ghost theme'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Attend`/ `""Attend zombie"":` 以僵尸主题的决策点参加派对，而不是默认的幽灵主题'
- en: '`Scared`: Begins the path to attend a party but returns to the main choice
    Host or Attend choice page'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scared`: 开始参加派对的路径，但返回到主选择“主机”或“参加”选择页面'
- en: The secret to this approach is a path generator, `partyPath()`. This is a loop
    that repeatedly executes every page `build()` method in the Page Object model
    until the final page is reached. Each page determines whether the current page
    is the one to process. Then, the test data is used to interact with the values
    on that page. Every field and list population method will be executed on their
    respective object. If there is no data provided for a particular input field,
    the interaction is executed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的秘密是一个路径生成器，`partyPath()`。这是一个循环，它反复执行页面对象模型中每个页面的 `build()` 方法，直到达到最终页面。每个页面都会确定当前页面是否是处理页面。然后，使用测试数据与该页面的值进行交互。每个字段和列表填充方法将在它们各自的对象上执行。如果没有为特定输入字段提供数据，则执行交互。
- en: 'There will be four reasons to exit the infinite loop:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 退出无限循环将有四个原因：
- en: The final Party Countdown page is reached (`Happy Path`)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 达到了最终的派对倒计时页面（`快乐路径`）
- en: An unknown page is encountered
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到了一个未知页面
- en: The same page persists after two loop attempts
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两次循环尝试后，页面保持不变
- en: The scared journey encounters the Host or Attend page
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恐惧之旅会遇到“主机”或“参加”页面
- en: Ultimately, the `build()` method will always attempt to explicitly move to the
    next page. In most cases, this would be a `Page` class, from which all other pages
    extend. In other cases, moving to the next page will be implicit by simply entering
    the final required field where no `clickIfExists()` feature mentioned in earlier
    chapters will come into play. The goal is always to try to reach the end of the
    process, not find bugs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`build()` 方法将始终尝试显式地移动到下一页。在大多数情况下，这将是一个 `Page` 类，所有其他页面都从中扩展。在其他情况下，移动到下一页将是通过简单地输入最终所需的字段来实现，其中不会涉及前面章节中提到的任何
    `clickIfExists()` 功能。目标始终是尝试到达过程的末尾，而不是寻找错误。
- en: It is expected in some cases that a page will not move on, expecting more data
    from the user after a selection has been made. While this might be handled within
    the same path, it could be a path detected on a second pass of the same page.
    So, if the navigation does not move forward after two loop attempts, the test
    exits with the user path incomplete, with a detailed error of the problem in the
    Allure report.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，页面可能不会继续前进，期望在做出选择后从用户那里获取更多信息。虽然这可能在同一路径内处理，但它可能是第二次遍历同一页面上检测到的路径。因此，如果在两次循环尝试后导航没有前进，测试将以用户路径不完整退出，并在Allure报告中详细说明问题。
- en: 'The first component we need to add is to determine which page we are currently
    on. While this is different from project to project, we often find that a unique
    identifier can be found in its URL. Let us begin by extracting a unique identifier
    from the last segment of the page URLs:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的第一个组件是确定我们当前所在的页面。虽然这因项目而异，但我们经常发现可以在其URL中找到一个唯一的标识符。让我们从提取页面URL的最后一段中的唯一标识符开始：
- en: '[https://candymapperr2.com/halloween-party](https://candymapperr2.com/halloween-party)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[糖果地图者2的万圣节派对](https://candymapperr2.com/halloween-party)'
- en: '[https://candymapperr2.com/party-location-1](https://candymapperr2.com/party-location-1)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[糖果地图者2的派对位置1](https://candymapperr2.com/party-location-1)'
- en: '[https://candymapperr2.com/party-time](https://candymapperr2.com/party-time)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[糖果地图者2的派对时间](https://candymapperr2.com/party-time)'
- en: To capture the URL that the framework has navigated, the `getPageName()` function
    will give us a description at the end of the URL. The following function would
    return `halloween-party`, `party-location-1`, and `party-time` from the aforementioned
    URLs, respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获框架导航到的URL，`getPageName()` 函数将给出URL末尾的描述。以下函数将分别从上述URL返回 `halloween-party`、`party-location-1`
    和 `party-time`。
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will be executed in the main `partyPath()` loop and stored in the automation
    Switchboard object’s `page` key. Note that we use only the ending portion of the
    URL, as this allows us to have similar functionality in different environments:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在主 `partyPath()` 循环中执行，并存储在自动化交换板对象的 `page` 键中。请注意，我们只使用URL的结尾部分，因为这允许我们在不同的环境中具有类似的功能：
- en: '[https://candymapper.com/party-time](https://candymapper.com/party-time)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://candymapper.com/party-time](https://candymapper.com/party-time)'
- en: '[https://candymapperr2.com/party-time](https://candymapperr2.com/party-time)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://candymapperr2.com/party-time](https://candymapperr2.com/party-time)'
- en: 'Each page class includes the `pages` object model that might be on the page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面类都包含可能出现在页面上的 `pages` 对象模型：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the generic locators use `normalize-space` and also skip the first
    letter in case capitalization changes. This makes them more robust and less likely
    to become stale, even if the text changes from release to release.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通用的定位器使用 `normalize-space`，并且如果首字母大小写发生变化，还会跳过第一个字母。这使得它们更加健壮，不太可能因为文本从发布到发布的变化而变得过时。
- en: 'Next, we have the `build()` method that is common for all pages. This will
    check first whether the identifier in the URL string matches the page and immediately
    returns `false` if it is not a match:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个对所有页面都通用的 `build()` 方法。这个方法首先会检查URL字符串中的标识符是否与页面匹配，如果不匹配则立即返回 `false`：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This path example by default will host a party. The `HostOrAttend` milestone
    in the switchboard can be switched to make it a user journey that attends a party
    instead. After the click, the next page that appears will be different, depending
    on which button we click, as well as which environment we run this test in. So,
    it is vitally important where we disassociate the expected page in the user journey,
    as it may not always be the same. However, we need to start somewhere and that
    is the happy path.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此路径示例默认将举办派对。在switchboard中的 `HostOrAttend` 里程碑可以被切换，使其成为一个参加派对的用户旅程。点击后，出现的下一页将根据我们点击的按钮以及运行此测试的环境而有所不同。因此，我们在哪里解耦用户旅程中预期的页面至关重要，因为这可能并不总是相同的。然而，我们需要从某个地方开始，那就是Happy
    Path。
- en: 'The last feature we would introduce is a `beforeEach()` function which will
    help us reduce our code significantly when writing the tests. Since we have multiple
    test cases and we are writing the [PRE3] each time. This can be simplified by
    placing the function in a `beforeEach()` function. This refactoring is performing
    the exact same process, but with less lines of code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要引入的最后一个特性是一个 `beforeEach()` 函数，这将在编写测试时显著减少我们的代码。由于我们有多个测试用例，并且每次都编写 [PRE3]。这可以通过将函数放在
    `beforeEach()` 函数中来实现。这个重构执行的是完全相同的过程，但代码行数更少：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this refactored version we move the await [PRE5] into the `beforeEach(async
    ()` function. This code will now execute before every test case.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构版本中，我们将 `await [PRE5]` 移入 `beforeEach(async ()` 函数中。现在，这段代码将在每个测试用例之前执行。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Keep in mind this works because we are not building a test that moves from one
    page to another specific page. We are simply populating whatever page is currently
    active, attempting to move to the next in a loop. Let’s take a look at our state-driven
    flow driver, `pathyPath(testData)` – which will navigate through the milestone
    decision points of our website.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是因为我们不是在构建一个从一个页面跳转到另一个特定页面的测试。我们只是在填充当前活动的页面，尝试在循环中移动到下一个页面。让我们看看我们的状态驱动流程驱动程序
    `pathyPath(testData)` – 它将导航到我们网站的里程碑决策点。
- en: The happy path
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Happy Path
- en: 'If the `testData` argument is empty, the default Happy Path will be performed.
    This is configured in a `userData.json` file in the `shared-data` folder. The
    two milestones include `HostOrAttend` and `location`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `testData` 参数为空，则将执行默认的Happy Path。这配置在 `shared-data` 文件夹中的 `userData.json`
    文件中。这两个里程碑包括 `HostOrAttend` 和 `location`：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rule of thumb – documenting JSON files
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则 - 记录JSON文件
- en: No developer worth their salt would ever design a data file without some documentation
    close at hand. However, JSON files do not allow for comments, as we can do in
    JavaScript files with double forward slashes (`//`). The workaround is to add
    a matching key, beginning with an underscore and ending with the word “`comment`”.
    Each key can now be documented to ensure others on the team can understand the
    intent behind the design.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 任何值得尊敬的开发者都不会在没有一些手头文档的情况下设计数据文件。然而，JSON文件不允许我们像在JavaScript文件中使用双斜杠（`//`）那样添加注释。解决方案是添加一个以下划线开头并以单词“`comment`”结尾的匹配键。现在，每个键都可以被记录下来，以确保团队中的其他人可以理解设计背后的意图。
- en: 'This file is first extracted into the Switchboard object. Then, any overriding
    values are parsed out of the `testData` argument or from a `JOURNEY` system variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件首先被提取到Switchboard对象中。然后，任何覆盖的值都会从 `testData` 参数或 `JOURNEY` 系统变量中解析出来：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, we must plan for the future. In our final chapter, we will drive
    these test cases from Jenkins using the `JOURNEY` system variable. If this variable
    is populated, it will supersede the `testData` argument.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须为未来做计划。在我们的最后一章中，我们将使用`JOURNEY`系统变量从Jenkins驱动这些测试用例。如果这个变量被填充，它将覆盖`testData`参数。
- en: When we build this driver, we should have a list of known company terms that
    can be used to adjust the milestone decision points.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建这个驱动程序时，我们应该有一个已知公司术语的列表，这些术语可以用来调整里程碑决策点。
- en: 'In our example, we have `host` and `attend` for the path verbs, and `zombie`
    and `ghost` and `scared` for decision points:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们有`host`和`attend`作为路径动词，以及`zombie`、`ghost`和`scared`作为决策点：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, the default data values are parsed into the ASB Switchboard:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，默认数据值会被解析到ASB交换板中：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, any overriding `key:value` data in the `testData` string is parsed into
    the ASB object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`testData`字符串中的任何覆盖`key:value`数据都会被解析到ASB对象中：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the test data string, we will allow the test to assign specific values
    to keys in our switchboard. For example, we might want to set a zip code to `12345`.
    In this case, we will need a regular expression to parse values that are connected
    with an equal sign. Strings with and without spaces can `be address=""123 main""`
    as well as `zip=12345`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试数据字符串内部，我们将允许测试为我们的交换板中的键分配特定的值。例如，我们可能想要将邮编设置为`12345`。在这种情况下，我们需要一个正则表达式来解析与等号相连的值。带有和不带有空格的字符串可以是`be
    address=""123 main""`以及`zip=12345`：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While the `testData` string argument tells us what will change at each milestone
    point, this is first transferred into the ASB switchboard object that all pages
    will reference when they execute. A data file will contain the default values
    that are populated into the switchboard, and then `testData` is parsed to customize
    these values. In preparation for our final chapter, this function also gets data
    from the `JOURNEY` system variable that will be sent from Jenkins:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`testData`字符串参数告诉我们每个里程碑点将发生什么变化，但这个信息首先被转移到ASB交换板对象中，所有页面在执行时都会引用这个对象。数据文件将包含填充到交换板中的默认值，然后`testData`被解析以自定义这些值。为了准备我们的最后一章，这个函数还会从`JOURNEY`系统变量中获取数据，该数据将由Jenkins发送：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The big driver loop
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要驱动循环
- en: 'The `partyPath()` method is actually a utility, rather than a test, so we will
    store it in a `Utilities` folder in the project root folder:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`partyPath()`方法实际上是一个实用工具，而不是一个测试，因此我们将它存储在项目根目录下的`Utilities`文件夹中：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to navigate the start of the Halloween Party path. This will
    require an `is a` loop that processes every page repeatedly, seeking one of four
    exit points:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是导航万圣节派对的起始路径。这需要处理每个页面的`is a`循环，重复寻找四个出口点之一：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This puts the name of the current page into the Switchboard. This object will
    be read in every page’s `build()` method. Next, we will call every known page,
    using logical `OR`, to determine whether any were successfully identified:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将当前页面的名称放入交换板中。这个对象将在每个页面的`build()`方法中被读取。接下来，我们将使用逻辑`OR`调用每个已知的页面，以确定是否有任何页面被成功识别：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that these pages do not need to be in any particular order. In fact, our
    designs have placed the first processing page list last and others in roughly
    reverse order. This tends to ensure only one page gets parsed per loop. Having
    multiple pages executing per loop is just as acceptable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些页面不需要按照任何特定的顺序排列。实际上，我们的设计将第一个处理页面列表放在最后，其他页面则大致按照相反的顺序排列。这样做通常可以确保每次循环只解析一个页面。每次循环执行多个页面也是可以接受的。
- en: Rule of thumb – refactoring
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则——重构
- en: In this small example, we are using only six pages. Real-world projects may
    have 50 to 100 web pages to navigate. It is always recommended to reduce code
    to smaller, more manageable units. In this case, the longer the lists of pages,
    the more they should be refactored into their own function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小型示例中，我们只使用了六个页面。现实世界的项目可能有50到100个网页需要导航。始终建议将代码缩减为更小、更易于管理的单元。在这种情况下，页面列表越长，就越应该将其重构为它们自己的函数。
- en: 'We now add the first of the four exit points. Note that in the preceding list
    of pages, one is missing – the final countdown page. This is the success page
    where our journey ends. Nothing else matters at this point:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加四个出口点中的第一个。注意，在前面的页面列表中，有一个缺失——最后的倒计时页面。这是我们的旅程结束的成功页面。此时，其他任何东西都不再重要：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If this page is processed, we report the successful end of the journey. It also
    sets out the `knownPage` flag as `true` for any additional reporting or cleanup
    at the end of the function. Then, we break out.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个页面被处理，我们报告旅程成功的结束。它还设置了`knownPage`标志为`true`，以便在函数结束时进行额外的报告或清理。然后，我们退出。
- en: Our job here is done, unless there is something unknown lurking out there?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的工作已经完成，除非有什么未知的东西潜伏在那里？
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, no page returned `true`. We output the name of the unknown page.
    We also use a clever `expect` to set the test to a failed status, while further
    documenting the issue at hand, the URL of the new page. In our example, the production
    website `Candymapper.com` will generate an `Error 404` page when a guest is too
    scared to go to a party and expects to return. This page is never expected, but
    if we can screen-capture it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有页面返回`true`。我们输出未知页面的名称。我们还使用一个巧妙的`expect`将测试设置为失败状态，同时进一步记录手头的问题，即新页面的URL。在我们的例子中，当访客因为害怕参加派对而期望返回时，生产网站`Candymapper.com`将生成一个`Error
    404`页面。这个页面从未被期望过，但如果我们能够截屏它。
- en: 'Next, we need to handle a situation where a page just did not move forward
    from the last one:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理一种情况，即页面并没有从上一个页面前进：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As superheroes, we are always open to second chances. In this case, a page could
    have two or three states itself. A point of sale page might add one product if
    the cart is empty and a different item if the cart has one item, before moving
    on. Calling such a method twice could be required and offer flexibility.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为超级英雄，我们总是对第二次机会持开放态度。在这种情况下，一个页面本身可能有两种或三种状态。一个销售点页面在购物车为空时可能添加一个产品，而在购物车有一个项目时添加不同的商品，然后继续前进。可能需要调用这样的方法两次，以提供灵活性。
- en: 'Lastly, there could be a journey that expects an alternative page as its final
    destination. This is rare but presented as an option. This path is one where we
    return to a prior step in the process. This works because the page was identified
    and processed as the first step in the loop, moving to the next page before reaching
    this point:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可能有一个期望以替代页面作为其最终目的地的旅程。这种情况很少见，但作为一个选项提供。这条路径是我们返回到过程中的一个先前步骤。这之所以有效，是因为页面在循环的第一步中被识别和处理，在到达这个点之前移动到下一个页面：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Is that all the exit points? We are certain there are other ways journeys must
    end prematurely. We can think of one more example – an infinite loop journey.
    This would require tracking an array of all the URLs visited. It would be triggered
    when a page has been visited for the third time. We have given you all the tips
    and tricks to pull this off. Now, it is time to work this one out on your own.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有的退出点吗？我们确信还有其他方式旅程必须提前结束。我们可以想到另一个例子——一个无限循环的旅程。这需要跟踪所有访问过的URL数组。当页面第三次被访问时，它会被触发。我们已经给了你所有实现这一点的技巧和窍门。现在，是时候自己解决这个问题了。
- en: 'Our final step before cycling back again is to set the current page name to
    the last page name:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次循环之前，我们的最后一步是将当前页面名称设置为最后一个页面名称：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This ensures that exit point #3 works correctly when determining whether we
    are stuck on the same page.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了在确定我们是否卡在同一个页面上时，退出点#3能够正确工作。
- en: Next, the test data file object is used to determine what fields are populated.
    If the test data object does not contain the data for a particular field, a warning
    is added to our results, but the test continues.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用测试数据文件对象来确定哪些字段被填充。如果测试数据对象不包含特定字段的资料，我们会在结果中添加一个警告，但测试会继续。
- en: Finally, the method to move on to the next page is performed. Note that we will
    use the `ClickIfExits()` method to ensure our engine remains robust, even if the
    element does not exist in future test environments.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行前进到下一个页面的方法。请注意，我们将使用`ClickIfExits()`方法来确保我们的引擎即使在未来的测试环境中元素不存在的情况下也能保持稳健。
- en: In the loop, we check to see whether the page has moved on with an increment
    counter, starting at 2\. If the page did not move on in the first loop, we decrement
    the loop counter. If the loop counter reaches 0, we have failed to successfully
    move on, and we exit. If successive loops do result in a new page URL, the counter
    is reset to perform two additional loops.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们检查页面是否通过递增计数器（从2开始）前进。如果页面在第一次循环中没有前进，我们减少循环计数器。如果循环计数器达到0，我们未能成功前进，并退出。如果连续的循环导致新的页面URL，计数器将重置以执行两个额外的循环。
- en: Some pages may have code that can resolve issues generated by incomplete data.
    This may not have been detected in the first execution of the `build` method for
    the page; thus, the build method must be executed at least twice before the test
    user journey is abandoned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一些页面可能有代码可以解决由不完整数据生成的问题。这可能在页面`build`方法的第一次执行中未被检测到；因此，在放弃测试用户旅程之前，必须至少执行`build`方法两次。
- en: Once we have completed this process for each page, we can begin to add milestones,
    based on the values passed from the `JOURNEY` user variable. In this example,
    we will have a path that plans a zombie party by default but will switch to a
    user attending a party, by passing `attend` in the `JOURNEY` string. This, in
    turn, will be injected into the test data object and read by the proper page.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完成每个页面的这个过程后，我们可以开始添加里程碑，基于从`JOURNEY`用户变量传递的值。在这个例子中，我们将有一个默认计划僵尸派对的路径，但将通过在`JOURNEY`字符串中传递`attend`来切换到用户参加派对。这将反过来注入到测试数据对象中，并由适当的页面读取。
- en: If we encounter a page that is new, the test will stop. We will report the URL
    of the page to Allure and provide a screen capture of the results. Our reporting
    automatically tells us the path that led us to that new endpoint.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到一个新页面，测试将停止。我们将向Allure报告页面的URL，并提供结果的屏幕截图。我们的报告自动告诉我们导致那个新端点的路径。
- en: It’s all in the details
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一切都在细节中
- en: Similarly, we could detect the string `error` in the URL on our page report
    with a screen capture, or we could capture all the text on the screen this way
    – `const allText =` `await $('body').getText();`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在我们的页面报告中通过屏幕截图检测URL中的字符串`error`，或者我们可以这样捕获屏幕上的所有文本 – `const allText
    =` `await $('body').getText();`。
- en: 'Another way to capture the scree text would be to send *Ctrl-A / Ctrl-V* to
    the browser and send the clipboard to the Allure report:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获屏幕文本的另一种方式是将*Ctrl-A / Ctrl-V*发送到浏览器，并将剪贴板发送到Allure报告：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This makes it more likely we will capture only the visible text of the browser.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们只捕获浏览器可见文本的可能性更大。
- en: 'This loop also provides the opportunity to interact with any known page, regardless
    of the order it appears in the path. Consider this path in the candymapperR2 website
    hosting a party:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环还提供了与任何已知页面交互的机会，无论它在路径中的顺序如何。考虑在candymapperR2网站上举办派对的这个路径：
- en: Host a Party
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 举办派对
- en: Party Venue Address Confirmed
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派对场地地址确认
- en: Party Theme
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派对主题
- en: Party Countdown
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派对倒计时
- en: 'And consider the path to attend a party:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑参加派对的路径：
- en: Attend a Party
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参加派对
- en: Choose a Party Venue or Return
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择派对场地或返回
- en: Party Venue Location Address
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派对场地地址
- en: Party Countdown
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派对倒计时
- en: Note that these two paths encounter the same **Party Venue Location Address**
    page but from different pages. In addition, the paths of these two journeys are
    different from the production Candymapper website. Thus, we can have the same
    test case run in two environments with dissimilar paths and still complete its
    goal.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两条路径遇到了相同的**派对场地地址**页面，但来自不同的页面。此外，这两条路径与生产Candymapper网站不同。因此，我们可以在两个具有不同路径但目标相同的环境中运行相同的测试用例。
- en: Our final path would be to set our final expected page. In this example, the
    path returns us to the `Plan` or `Attend` page indicating the user journey; although
    it did not end at the common endpoint, it was still a success.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的路径是设置我们的最终预期页面。在这个例子中，路径返回到`Plan`或`Attend`页面，指示用户旅程；尽管它没有结束在共同端点，但仍然是一个成功。
- en: Changing decision points
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变决策点
- en: 'The way we pass the string that customizes a path is through a single environmental
    variable, like so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过单个环境变量传递自定义路径的字符串，如下所示：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This way, we can create test several paths. In this example, the user does
    not attend the party and instead clicks the **I’m** **scared** button:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以创建多个测试路径。在这个例子中，用户没有参加派对，而是点击了**我害怕**按钮：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this example, the user takes the path to host the party with a zombie
    theme:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户选择了以僵尸为主题的举办派对的路径：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A single environmental value can modify multiple decision points from the Happy
    Path baseline. While an empty string by default will create a Happy Path, the
    best practice is to assign the string so that the path is shown in the results,
    with the parsing being case-insensitive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 单个环境值可以修改Happy Path基线中的多个决策点。虽然默认情况下空字符串将创建Happy Path，但最佳实践是分配字符串，以便路径在结果中显示，解析不区分大小写。
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that there is a space prepended to the journey variable. The reason for
    this is to make it less likely to match a similar string in the path. We have
    a `host` command and a `ghost` party. Writing this line of code could potentially
    take the `host` command from the `ghost` string:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在旅程变量之前有一个前置空格。这样做的原因是为了降低与路径中类似字符串匹配的可能性。我们有一个`host`命令和一个`ghost`派对。编写这一行代码可能会从`ghost`字符串中获取`host`命令：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is resolved, as every command that is acted upon always has a prepended
    space. Now, there is less chance of an incorrect path match. For our example,
    we will go one step further, making `Host` the default Happy Path and `Attend`
    the deviation from the path:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经解决了，因为每个被执行的命令总是有一个前置空格。现在，不正确路径匹配的机会更少了。以我们的示例为例，我们将更进一步，将`Host`作为默认的Happy
    Path，将`Attend`作为路径的偏差：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This completes the first method to choose a decision point on the first page.
    The function exits and loops around. The next page could be next, but it does
    not have to be in sequential order. It could be further down the list inside the
    loop. All the following pages will not match the URL, and the `build()` method
    will simply return immediately as a null function. The next page could be earlier
    in the loop. It would have executed as a null function before this page and now
    executes as the loop starts from the top again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了在第一页上选择决策点的第一种方法。函数退出并循环。下一页可能是下一个，但不必按顺序排列。它可能位于循环列表的更下方。所有后续的页面都不会匹配URL，并且`build()`方法将简单地立即返回一个空函数。下一页可能在循环的更早位置。它会在这一页之前作为空函数执行，现在随着循环从顶部再次开始执行。
- en: Wash, rinse, repeat
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洗，冲，重复
- en: 'The same principle applies to modifying the type of data in the page classes.
    As an example, the custom `date` tokens could be passed like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则适用于修改页面类中的数据类型。例如，自定义的`date`令牌可以像这样传递：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we have a date token extracted from the journey value. The token is passed
    to `dateField`, if it exists, and set to next week’s date. If there is no token,
    the date is set to an empty string, which the method will return immediately as
    there is nothing to do.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经从旅程值中提取了一个日期令牌。如果存在，令牌将传递到`dateField`，并设置为下周的日期。如果没有令牌，日期将设置为空字符串，方法将立即返回，因为没有要做的事情。
- en: At this point, we have covered all the processes of a non-deterministic engine.
    New pages will be reported in the results and must be added to extend the path
    coverage. If a page is never encountered in a particular path, it does not stop
    the test. If an error is encountered, it is reported. If the path gets stuck,
    it is also reported. The data and the paths can be customized. These build methods
    can be called from other test cases.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了非确定性引擎的所有过程。新页面将在结果中报告，并且必须添加以扩展路径覆盖率。如果一个页面在特定路径中从未遇到，它不会停止测试。如果遇到错误，它将被报告。如果路径卡住，它也将被报告。数据和路径可以自定义。这些构建方法可以从其他测试用例中调用。
- en: Why not generate these Artifacts with API calls?
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么不用API调用生成这些工件呢？
- en: Using API calls for a task does mean quicker and more stable testing, as it
    directly communicates with an application. It can be implemented earlier in the
    development process. This could lead to early detection of issues, making the
    development process more flexible and agile.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API调用进行任务确实意味着更快、更稳定的测试，因为它可以直接与应用程序通信。它可以在开发过程的早期实现。这可能导致问题的早期发现，使开发过程更加灵活和敏捷。
- en: Conversely, using an automated GUI could provide a richer understanding of the
    user experience, as it can simulate the exact paths a user might take, including
    interactions with visual elements that API tests might overlook. This approach
    might be more intuitive and can encompass a broader analysis, including the appearance
    and layout, which are crucial for user satisfaction.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用自动化的GUI可以提供对用户体验的更深入理解，因为它可以模拟用户可能采取的确切路径，包括与API测试可能忽略的视觉元素的交互。这种方法可能更直观，并且可以涵盖更广泛的分析，包括外观和布局，这对于用户满意度至关重要。
- en: 'In fact, there is no reason to support once approach over another. The GUI
    approach confirms the system works correctly for the user. The API approaches
    generate the artifacts with greater speed. We can implement the differences in
    the approaches by adding another keyword value to the journey parsing code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，没有理由支持一种方法而不是另一种方法。GUI方法确认系统对于用户来说是正确工作的。API方法以更快的速度生成工件。我们可以通过在旅程解析代码中添加另一个关键字值来实现方法之间的差异：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the default GUI approach is overridden with an API path in
    the same `build()` methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，默认的GUI方法在相同的`build()`方法中被API路径覆盖。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into a sophisticated approach to test automation,
    reminiscent of a superhero strategizing for dynamic and complex missions with
    multiple potential outcomes based on choices made. Our method involved a loop
    that continuously navigates through each page, engaging only upon recognizing
    a known resource. The journey is non-deterministic shaped by high-level objectives
    and occasionally encountering unexpected obstacles like dead ends or logic loops.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了一种复杂的自动化测试方法，这种方法让人联想到一个超级英雄在为动态且复杂的任务制定策略，这些任务基于所做选择有多种可能的结局。我们的方法涉及一个循环，它不断地导航到每一页，仅在识别到已知资源时才进行交互。旅程是非确定性的，由高级目标塑造，偶尔会遇到意外的障碍，如死胡同或逻辑循环。
- en: This approach is flexible, allowing for the adjustment of user paths based on
    various variables and can be adapted to different environments, highlighting its
    robustness and versatility. It also aids in data generation for manual testers,
    significantly reducing the time and effort needed to create data records for testing
    when paired with tools like Jenkins, enhancing the efficiency of the testing process
    overall.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很灵活，可以根据各种变量调整用户路径，并且可以适应不同的环境，突显其鲁棒性和多功能性。它还有助于为手动测试人员生成数据，与Jenkins等工具配合使用时，可以显著减少创建测试数据记录所需的时间和精力，从而提高整个测试过程的效率。
- en: In the final chapter, this approach will have additional advantages, making
    manual testers more efficient. The worst idea is to assume automation replaces
    “costly” manual testers. We should aways strive to augment their efforts. Manual
    testers could reduce a lot of setup time creating complex test artifacts when
    they only need to validate the results. But do we want to have them install a
    coding tool and teach them how to run a script like this? This is where we employ
    our final magical item and let a CI/CD tool provide an effortless way to do the
    heavy lifting. Something like a mystic sentient cloak of levitation perhaps?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，这种方法将具有额外的优势，使手动测试人员更加高效。最糟糕的想法是假设自动化取代了“昂贵”的手动测试人员。我们应该始终努力增强他们的工作。当手动测试人员只需要验证结果时，他们可以减少创建复杂测试工件所需的大量设置时间。但我们真的希望他们安装编码工具并教他们如何运行这样的脚本吗？这就是我们使用我们最后的神奇物品，让CI/CD工具提供一种轻松完成繁重工作的方法的地方。也许像一件神秘的感知悬浮斗篷？
