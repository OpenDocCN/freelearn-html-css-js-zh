<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Testing with Mocha, Karma, and More"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Testing with Mocha, Karma, and More</h1></div></div></div><p>Testing is an integral part of software development, especially when dealing with applications that interact with end-users and various clients, as is the case with JavaScript SPAs. The results of web application code can often be unpredictable due to the variety of clients potentially consuming the application, so all possible scenarios should be accounted for and tested appropriately.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is unit testing, integration testing, and <span class="strong"><strong>end-to-end</strong></span> (<span class="strong"><strong>E2E</strong></span>) testing?</li><li class="listitem" style="list-style-type: disc">How to perform JavaScript unit testing with Mocha, Chai, and Sinon.js</li><li class="listitem" style="list-style-type: disc">How to configure Karma with Jasmine to test AngularJS</li><li class="listitem" style="list-style-type: disc">How to perform unit testing with AngularJS</li><li class="listitem" style="list-style-type: disc">How to perform end-to-end testing with AngularJS</li></ul></div><div class="section" title="Types of testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec69"/>Types of testing</h1></div></div></div><p>There are various types of testing known throughout the software industry, but there are three main types that are consistently used, especially in web application development. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit testing</li><li class="listitem" style="list-style-type: disc">Integration testing</li><li class="listitem" style="list-style-type: disc">End-to-end testing, also known as <span class="emphasis"><em>functional</em></span> testing</li></ul></div><p>These three types of testing comprise what is known as the <span class="emphasis"><em>software testing pyramid</em></span>. The pyramid can be broken down into more granular forms of testing, but this is how it looks from a high vantage point:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_13_01.jpg" alt="Types of testing"/></div><p>
</p><div class="section" title="Unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec148"/>Unit testing</h2></div></div></div><p>The bottom level of the software testing pyramid is <span class="emphasis"><em>unit testing</em></span>. Unit testing targets the smallest pieces of an application, or units, in <span class="emphasis"><em>isolation</em></span> from the remainder of the application. A unit is typically an individual method or object instance. When you test a unit in isolation, it means that the test should not interact with any application dependencies, such as network access, database access, user sessions, and any other dependencies that may be needed in the real-world application context. Instead, a unit test should only perform operations within local memory.</p><p>The goal of any unit test should be to test only a single feature of the application, and that feature should be encapsulated within the unit. If that unit does have any dependencies, they should be <span class="emphasis"><em>mocked</em></span>, or simulated, instead of invoking the actual dependencies. We will discuss more about that later in the chapter.</p><p>Knowing that you will perform unit testing will help you write smaller and more focused methods in your application because they are easier to test. Many will argue that you should always write your tests first before writing any application code. This is not always practical, however, because you may have been pushed into a speedy development cycle that didn't allow time for the tedious process of writing unit tests. Writing unit tests against existing code may prove tedious as well, but it is quite acceptable, and better than having no unit tests at all.</p><p>Let's look at some well-known JavaScript unit testing frameworks that can quickly and easily be integrated into a new or existing application.</p><div class="section" title="Mocha"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec160"/>Mocha</h3></div></div></div><p>
<span class="emphasis"><em>Mocha</em></span> is a popular JavaScript unit testing framework that is commonly used throughout the Node.js community. Let's revisit our Node.js sample project from the beginning of the book and install Mocha so we can try out a few unit testing examples:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install mocha -g</strong></span>
</pre><p>Install <code class="literal">mocha</code> globally so that you can access it easily from any directory.</p><p>Now, let's create a <code class="literal">test</code> directory at the root of our project to store testing related files:</p><pre class="programlisting">
<span class="strong"><strong>$ mkdir test</strong></span>
</pre><p>Create a file in the <code class="literal">test</code> directory named <code class="literal">test.js</code> and open it for editing. Place the following code in the file and save it:</p><pre class="programlisting">var assert = require('assert'); &#13;
describe('String', function() { &#13;
    describe('#search()', function() { &#13;
        it('should return -1 when the value is not present', function() { &#13;
            assert.equal(-1, 'text'.search(/testing/)); &#13;
        }); &#13;
    }); &#13;
}); &#13;
</pre><p>To run the test, issue the following command from your console under the <code class="literal">test</code> directory:</p><pre class="programlisting">
<span class="strong"><strong>$ mocha test.js</strong></span>
</pre><p>You should then see the following output in your console:</p><pre class="programlisting">
<span class="strong"><strong> String</strong></span>
<span class="strong"><strong>    #search()</strong></span>
<span class="strong"><strong>       should return -1 when the value is not present</strong></span>
<span class="strong"><strong>  1 passing (8ms)</strong></span>
</pre><p>Using the Mocha <code class="literal">describe</code> method, this unit test performs a simple <span class="strong"><strong>assertion</strong></span> on the <code class="literal">search</code> method of the <code class="literal">String</code> constructor. An assertion in testing is simply an evaluation of whether something is <code class="literal">true</code> or not. In this example, we are testing the assertion that the <code class="literal">search</code> method returns <code class="literal">-1</code> when its argument is not found within the search context.</p><div class="section" title="Assertions with Chai"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec41"/>Assertions with Chai</h4></div></div></div><p>The previous example uses the Node.js <code class="literal">assert</code> module, but with Mocha, you will want to use a full-fledged assertion library for a substantive testing environment. Mocha is compatible with multiple JavaScript assertion libraries, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Should.js</li><li class="listitem" style="list-style-type: disc">Expect.js</li><li class="listitem" style="list-style-type: disc">Chai</li><li class="listitem" style="list-style-type: disc">Better-assert</li><li class="listitem" style="list-style-type: disc">Unexpected</li></ul></div><p>Chai is a popular and active open source assertion library, so we will use it for our Mocha assertion examples throughout this chapter. First, install <code class="literal">chai</code> in your local Node.js environment:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install chai --save-dev</strong></span>
</pre><p>Chai includes three styles of assertions, <code class="literal">should</code>, <code class="literal">expect</code>, and <code class="literal">assert</code>, allowing you to choose the flavor you like best.</p><p>
<span class="strong"><strong>Should-style assertions</strong></span>
</p><p>
<span class="emphasis"><em>Should</em></span>-style assertions are accessible in Chai using <code class="literal">chai.should()</code>. This interface allows for a chainable method syntax that is familiar to many JavaScript developers, especially if you have worked with libraries such as jQuery. The chainable method names use natural language to make writing the tests more fluid. Additionally, Chai's <code class="literal">should</code> method extends <code class="literal">Object.prototype</code> so that you can chain it directly to the variables you are testing, as follows:</p><pre class="programlisting">var should = require('chai').should(); // Execute the should function &#13;
var test = 'a string'; &#13;
test.should.be.a('string'); &#13;
</pre><p>This example will perform a simple assertion that the given variable is a string.</p><p>
<span class="strong"><strong>Expect-style assertions</strong></span>
</p><p>
<span class="emphasis"><em>Expect</em></span>-style assertions are accessible in Chai using <code class="literal">chai.expect</code>. This interface is similar to <code class="literal">should</code>, in that, it uses method chaining, but it does not extend <code class="literal">Object.prototype</code>, so it is used in a more traditional fashion, as follows:</p><pre class="programlisting">var expect = require('chai').expect; &#13;
var test = 'a string'; &#13;
expect(test).to.be.a('string); &#13;
</pre><p>This example performs the same assertion as the previous example, but with Chai's <code class="literal">expect</code> method instead of <code class="literal">should</code>. Notice that the <code class="literal">require</code> call to the <code class="literal">expect</code> method does not execute it, as is the case with <code class="literal">should</code>.</p><p>
<span class="strong"><strong>Assert-style assertions</strong></span>
</p><p>
<span class="emphasis"><em>Assert</em></span>-style assertions are accessible in Chai using <code class="literal">chai.assert</code>. This interface uses the more traditional style of assertions, much like the Node.js native <code class="literal">assert</code> module:</p><pre class="programlisting">var assert = require('chai').assert; &#13;
var test = 'a string'; &#13;
assert.typeOf(test, 'string'); &#13;
</pre><p>This example performs the same assertion as the two previous examples but with Chai's <code class="literal">assert</code> method. Notice that this example calls upon the <code class="literal">assert.typeOf</code> method, which is akin to the native JavaScript <code class="literal">typeof</code> operator, rather than using natural language method names as <code class="literal">should</code> and <code class="literal">expect</code> do.</p><p>Testing with Mocha and Chai does not favor any particular style of assertion available in Chai, but it is best to choose one and stick with it so that a testing pattern is established. We will use the <code class="literal">should</code> style of assertion for the remaining examples in this chapter.</p><p>
<span class="strong"><strong>Using Mocha with Chai-and Should-style assertions</strong></span>
</p><p>Now, let's go back to our original Mocha test example in <code class="literal">test.js</code> and add a similar test right under it, but use Chai's <code class="literal">should</code> assertion method instead:</p><pre class="programlisting">var should = require('chai').should(); &#13;
describe('String', function() { &#13;
    describe('#search()', function() { &#13;
        it('should return -1 when the value is not present', function() { &#13;
            'text'.search(/testing/).should.equal(-1); &#13;
        }); &#13;
    }); &#13;
}); &#13;
</pre><p>This performs the same test as shown earlier using the native Node.js <code class="literal">assert</code> module, but with Chai's <code class="literal">should</code> method instead. The advantage of working with Chai in this scenario, however, is that it provides additional tests beyond what Node.js can provide out of the box, and the Chai tests are also browser compatible.</p><p>Back in the console, run the Mochas tests:</p><pre class="programlisting">
<span class="strong"><strong>$ mocha test.js</strong></span>
</pre><p>This should yield the following output from your two tests:</p><pre class="programlisting">
<span class="strong"><strong>  String</strong></span>
<span class="strong"><strong>    #search()</strong></span>
<span class="strong"><strong>       should return -1 when the value is not present</strong></span>
<span class="strong"><strong>  String</strong></span>
<span class="strong"><strong>    #search()</strong></span>
<span class="strong"><strong>       should return -1 when the value is not present</strong></span>
<span class="strong"><strong>  2 passing (9ms)</strong></span>
</pre><p>Now, let's write a more interesting test that might be used in a real-world application context. A JavaScript SPA will often be dealing with the DOM, so we should test that interaction accordingly. Let's consider the following method as an example:</p><pre class="programlisting">module.exports = { &#13;
    addClass: function(elem, newClass) { &#13;
        if (elem.className.indexOf(newClass) !== -1) { &#13;
            return; &#13;
        } &#13;
        if (elem.className !== '') { &#13;
            newClass = ' ' + newClass; &#13;
        } &#13;
        elem.className += newClass; &#13;
    } &#13;
}; &#13;
</pre><p>The <code class="literal">addClass</code> method simply adds a <code class="literal">className</code> to a DOM element if it does not already have that <code class="literal">className</code>. We are defining it with <code class="literal">module.exports</code> so that it is consumable as a Node.js module. To test this code, save it in a new file named <code class="literal">addClass.js</code> under your <code class="literal">test</code> directory.</p><p>Now, back in the <code class="literal">test.js</code> file, add the following unit test code under the other two tests that we have written so far:</p><pre class="programlisting">var addClass = require('./addClass').addClass; &#13;
describe('addClass', function() { &#13;
    it('should add a new className if it does not exist', function() { &#13;
        var elem = { &#13;
            className: 'existing-class' &#13;
        }; &#13;
        addClass(elem, 'new-class'); &#13;
        elem.className.split(' ')[1].should.equal('new-class'); &#13;
    }); &#13;
}); &#13;
</pre><p>Due to the no-dependencies constraint of unit testing, we are faking, or <span class="strong"><strong>mocking</strong></span>, a DOM element here by defining a simple JavaScript object called <code class="literal">elem</code> and giving it a <code class="literal">className</code> property, just as a real DOM object would have. This test is written strictly to assert that calling <code class="literal">addClass</code> on an element with a new, non-existent <code class="literal">className</code> will, in fact, add that <code class="literal">className</code> to the element.</p><p>Running the tests from the command line should now yield the following output:</p><pre class="programlisting">
<span class="strong"><strong>  String</strong></span>
<span class="strong"><strong>    #search()</strong></span>
<span class="strong"><strong>       should return -1 when the value is not present</strong></span>
<span class="strong"><strong>  String</strong></span>
<span class="strong"><strong>    #search()</strong></span>
<span class="strong"><strong>       should return -1 when the value is not present</strong></span>
<span class="strong"><strong>  addClass</strong></span>
<span class="strong"><strong>     should add a new className if it does not exist</strong></span>
<span class="strong"><strong>  3 passing (10ms)</strong></span>
</pre></div><div class="section" title="Running Mocha tests in the browser"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec42"/>Running Mocha tests in the browser</h4></div></div></div><p>Mocha is easy enough to run from a CLI, but it also comes bundled with assets that allow you to easily run your tests in a browser. As we are currently working with frontend JavaScript code, it is best to test it in the environment it will actually be run. To do this, let's first create a file named <code class="literal">test.html</code> at the root of the project and add the following markup to it:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;head&gt; &#13;
        &lt;title&gt;Mocha Tests&lt;/title&gt; &#13;
        &lt;link rel="stylesheet" href="node_modules/mocha/mocha.css"&gt; &#13;
    &lt;/head&gt; &#13;
    &lt;body&gt; &#13;
        &lt;div id="mocha"&gt;&lt;/div&gt; &#13;
        &lt;script src="node_modules/mocha/mocha.js"&gt;&lt;/script&gt; &#13;
        &lt;script src="node_modules/chai/chai.js"&gt;&lt;/script&gt; &#13;
        &lt;script&gt;mocha.setup('bdd');&lt;/script&gt; &#13;
        &lt;script src="test/addClass.js"&gt;&lt;/script&gt; &#13;
        &lt;script src="test/test.js"&gt;&lt;/script&gt; &#13;
        &lt;script&gt; &#13;
            mocha.run(); &#13;
        &lt;/script&gt; &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Mocha provides CSS and JavaScript assets to view tests in a browser. All that is required of the DOM structure is to have a <code class="literal">&lt;div&gt;</code> defined with an ID of <code class="literal">mocha</code>. The styles should be included in <code class="literal">&lt;head&gt;</code>, and the JavaScript should be included under <code class="literal">&lt;div id="mocha"&gt;</code>. Additionally, the call to <code class="literal">mocha.setup('bdd')</code> tells the Mocha framework to use its <span class="strong"><strong>Behavior-Driven Development</strong></span>(<span class="strong"><strong>BDD</strong></span>) interface for testing.</p><p>Now, remember that our JavaScript files are written as Node.js modules, so we will have to modify their syntax to work properly in a browser context. For our <code class="literal">addClass.js</code> file, let's modify the method to be defined in a global <code class="literal">window</code> object named <code class="literal">DOM</code>:</p><pre class="programlisting">window.DOM = { &#13;
    addClass: function(elem, newClass) { &#13;
        if (elem.className.indexOf(newClass) !== -1) { &#13;
            return; &#13;
        } &#13;
        if (elem.className !== '') { &#13;
            newClass = ' ' + newClass; &#13;
        } &#13;
        elem.className += newClass; &#13;
    } &#13;
}; &#13;
</pre><p>Next, modify <code class="literal">test.js</code> to load <code class="literal">chai.should</code> and <code class="literal">DOM.addClass</code> from the <code class="literal">window</code> context, instead of as Node.js modules, and let's go ahead and remove the original Node.js <code class="literal">assert</code> module test that we created:</p><pre class="programlisting">// Chai.should assertion &#13;
var should = chai.should(); &#13;
describe('String', function() { &#13;
    describe('#search()', function() { &#13;
        it('should return -1 when the value is not present', function() { &#13;
            'text'.search(/testing/).should.equal(-1); &#13;
        }); &#13;
    }); &#13;
}); &#13;
 &#13;
// Test the addClass method &#13;
var addClass = DOM.addClass; &#13;
describe('addClass', function() { &#13;
    it('should add a new className if it does not exist', function() { &#13;
        var elem = { &#13;
            className: 'existing-class' &#13;
        }; &#13;
        addClass(elem, 'new-class'); &#13;
        elem.className.split(' ')[1].should.equal('new-class'); &#13;
    }); &#13;
}); &#13;
</pre><p>You should now have two tests contained in <code class="literal">test.js</code>. Finally, run a local Node.js server from the root of the project so that you can view the <code class="literal">test.html</code> page in a browser:</p><pre class="programlisting">
<span class="strong"><strong>$ http-server</strong></span>
</pre><p>Using the global <code class="literal">http-server</code> module, your local server will be accessible to your browser at <code class="literal">localhost:8080</code> and the test file at <code class="literal">localhost:8080/test.html</code>. Go to that page in a browser and you will see the tests run automatically. If everything is set up correctly, you should see the following output:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_002.jpg" alt="Running Mocha tests in the browser"/></div><p>
</p></div></div><div class="section" title="Sinon.js"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec161"/>Sinon.js</h3></div></div></div><p>Due to the requirement of isolation in unit testing, dependencies must often be simulated by providing <code class="literal">spies</code>, <code class="literal">stubs</code>, and <code class="literal">mocks</code> or objects that imitate the behavior of real objects. <span class="emphasis"><em>Sinon.js</em></span> is a popular JavaScript library that provides these tools for testing and it is compatible with any unit testing framework, including Mocha.</p><div class="section" title="Spies"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec43"/>Spies</h4></div></div></div><p>Test spies are functions that can be used in place of callback dependencies and also are used to <span class="emphasis"><em>spy</em></span> or record arguments, return values, and any other related data to other functions that is used throughout an application. Spies are available in Sinon.js through the <code class="literal">sinon.spy()</code> API. It can be used to create an anonymous function that records data on itself every time it is called throughout a test sequence:</p><pre class="programlisting">var spy = sinon.spy(); &#13;
</pre><p>An example use case of this is testing that a callback function is invoked properly from another function in a <code class="literal">publish</code> and <code class="literal">subscribe</code> design pattern, as follows:</p><pre class="programlisting">it('should invoke the callback on publish', function() { &#13;
    var spy = sinon.spy(); &#13;
    Payload.subscribe('test-event', spy); &#13;
    Payload.publish('test-event'); &#13;
    spy.called.should.equal(true); &#13;
}); &#13;
</pre><p>In this example, a spy is used to act as a callback for a <code class="literal">Payload.js</code> custom event. The callback is registered through the <code class="literal">Payload.subscribe</code> method and expected to be invoked upon publishing the custom event <code class="literal">test-event</code>. The <code class="literal">sinon.spy()</code> function will return an object with several properties available on it that give you information about the returned function. In this case, we are testing for the <code class="literal">spy.called</code> property, which will be <code class="literal">true</code> if the function was called at least once.</p><p>The <code class="literal">sinon.spy()</code> function can also be used to wrap another function and spy on it, as follows:</p><pre class="programlisting">var spy = sinon.spy(testFunc); &#13;
</pre><p>Additionally, <code class="literal">sinon.spy()</code> can be used to replace an existing method on an object and behave exactly like the original method, but with the added benefit of collecting data on that method through the API, as follows:</p><pre class="programlisting">var spy = sinon.spy(object, 'method'); &#13;
</pre></div><div class="section" title="Stubs"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec44"/>Stubs</h4></div></div></div><p>Test <code class="literal">stubs</code> build on top of <code class="literal">spies</code>. They are functions that are spies themselves with access to the full test spy API, but with added methods to alter their behavior. Stubs are most often used when you want to force certain things to happen inside of functions when a test is being run on it, and also when you want to prevent certain things from happening.</p><p>For example, say that we have a <code class="literal">userRegister</code> function that registers a new user to a database. This function has a callback that is returned when a user is successfully registered, but if saving the user fails, it should return an error in that callback, as follows:</p><pre class="programlisting">it('should pass the error into the callback if save fails', function() { &#13;
    var error = new Error('this is an error'); &#13;
    var save = sinon.stub().throws(error); &#13;
    var spy = sinon.spy(); &#13;
 &#13;
    registerUser({ name: 'Peebo' }, spy); &#13;
 &#13;
    save.restore(); &#13;
    sinon.assert.calledWith(spy, error); &#13;
}); &#13;
</pre><p>First, we will create an <code class="literal">Error</code> object to pass to our callback. Then, we will create a stub for our actual <code class="literal">save</code> method that replaces it and throws an error, passing the <code class="literal">Error</code> object to the callback. This replaces any actual database functionality as we cannot rely on real dependencies for unit testing. Finally, we will define the <code class="literal">callback</code> function as a spy. When we call the <code class="literal">registerUser</code> method for our test, we will pass the spy to it as its callback. In a scenario where we have a real <code class="literal">save</code> method, <code class="literal">save.restore()</code> will change it back to its original state and remove the stubbed behavior.</p><p>Sinon.js also has its own assertion library built in for added functionality when working with spies and stubs. In this case, we will call <code class="literal">sinon.assert.calledWith()</code> to assert that the spy was called with the expected error.</p></div><div class="section" title="Mocks"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec45"/>Mocks</h4></div></div></div><p>Mocks in Sinon.js build upon both spies and stubs. They are fake methods, like <code class="literal">spies</code>, with the ability to add additional behaviors, like <code class="literal">stubs</code>, but also give you the ability to define <span class="emphasis"><em>expectations</em></span> for the test before it is actually run.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>Mocks should only be used once per unit test. If you find yourself using more than one mock in a unit test, you are probably not using them as intended.</p></div></div><p>To demonstrate the use of a mock, let's consider an example using the Payload.js <code class="literal">localStorage</code> API methods. We can define a method called <code class="literal">incrementDataByOne</code> that is used to increment a <code class="literal">localStorage</code> value from <span class="strong"><strong>
<code class="literal">0</code>
</strong></span> to <code class="literal">1</code>:</p><pre class="programlisting">describe('incrementDataByOne', function() { &#13;
    it('should increment stored value by one', function() { &#13;
        var mock = sinon.mock(Payload.storage); &#13;
        mock.expects('get').withArgs('data').returns(0); &#13;
        mock.expects('set').once().withArgs('data', 1); &#13;
 &#13;
        incrementDataByOne(); &#13;
 &#13;
        mock.restore(); &#13;
        mock.verify(); &#13;
    }); &#13;
}); &#13;
</pre><p>Notice that instead of defining a spy or a stub here, we will define a mock variable that takes the <code class="literal">Payload.storage</code> object API as its only argument. A mock is then created on the object to test its methods for expectations. In this case, we will set up our expectations that the initial value of data should return 0 from the <code class="literal">Payload.storage.get</code> API method, and then after calling <code class="literal">Payload.storage.set</code> with 1, it should be incremented by 1 from its original value.</p></div></div><div class="section" title="Jasmine"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec162"/>Jasmine</h3></div></div></div><p>
<span class="emphasis"><em>Jasmine</em></span> is another popular unit testing framework in the Node.js community, and it is also used for most AngularJS applications and referenced throughout the AngularJS core documentation. Jasmine is similar to Mocha in many ways, but it includes its own assertion library. Jasmine uses <code class="literal">expect</code> style assertions, much like the Chai <code class="literal">expect</code> style assertions, which were covered earlier:</p><pre class="programlisting">describe('sorting the list of users', function() { &#13;
    it('sorts in ascending order by default', function() { &#13;
        var users = ['Kerri', 'Jeff', 'Brenda']; &#13;
        var sorted = sortUsers(users); &#13;
        expect(sorted).toEqual(['Brenda', 'Jeff', 'Kerri']); &#13;
    }); &#13;
}); &#13;
</pre><p>As you can see in this example, Jasmine uses <code class="literal">describe</code> and <code class="literal">it</code> method calls for its tests that are identical to those used in Mocha, so switching from one framework to the other is pretty straightforward. Having knowledge of both Mocha and Jasmine is quite useful as they are both used commonly throughout the JavaScript community.</p></div><div class="section" title="Karma test runner"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec163"/>Karma test runner</h3></div></div></div><p>
<span class="emphasis"><em>Karma</em></span> is a JavaScript <span class="emphasis"><em>test runner</em></span> that allows you to run your tests in browsers automatically. We have already demonstrated how to run Mocha unit tests in the browser manually, but when using a test runner such as <code class="literal">Karma</code>, this process is much easier to set up and work with.</p><div class="section" title="Testing with Karma, Mocha, and Chai"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec46"/>Testing with Karma, Mocha, and Chai</h4></div></div></div><p>Karma can be used with multiple unit testing frameworks, including Mocha. First, let's install the Node.js modules that we'll need to work with Karma, Mocha, and Chai:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install karma karma-mocha karma-chai --save-dev</strong></span>
</pre><p>This will install Karma and its Node.js plugins for Mocha and Chai to your local development environment and save them in your <code class="literal">package.json</code> file. Now, in order to have Karma launch tests in browsers on your system, we'll need to install plugins for those as well, which are as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install karma-chrome-launcher karma-firefox-launcher --save-dev</strong></span>
</pre><p>This will install the <code class="literal">launcher</code> modules for the Chrome and Firefox browsers. If you do not have one or both of these browsers on your system, then install the launchers for one or two that you do have. There are Karma launcher plugins for all major browsers.</p><p>Next, we will need to create a config file for Karma to run our tests and launch the appropriate browsers. Create a file at the root of the project named <code class="literal">karma.conf.js</code> and add the following code to it:</p><pre class="programlisting">module.exports = function(config) { &#13;
    'use strict'; &#13;
    config.set({ &#13;
        frameworks: ['mocha', 'chai'], &#13;
        files: ['test/*.js'], &#13;
        browsers: ['Chrome', 'Firefox'], &#13;
        singleRun: true &#13;
    }); &#13;
}; &#13;
</pre><p>This configuration simply tells Karma that we're using the Mocha and Chai testing frameworks, we want to load all JavaScript files under the test directory, and we want to launch the tests to run in the Chrome and Firefox browsers, or the browsers that you have chosen. The <code class="literal">singleRun</code> parameter tells Karma to run the tests and then exit, rather than continue to run.</p><p>Now, all we have to do is run Karma from the CLI to run our tests in the defined browsers. As Karma is installed locally, you will have to add the relative path from your project root to the module in order to run it, as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ ./node_modules/karma/bin/karma start karma.conf.js</strong></span>
</pre><p>You will notice that this command also specifies the configuration file you want to use for your Karma instance, but it will default to the <code class="literal">karma.conf.js</code> file that you created at the root directory if you exclude it in the command.</p><p>Alternatively, if you would like to run Karma from any directory globally, you can install the <code class="literal">karma-cli</code> module, just like you did with Grunt and <code class="literal">grunt-cli</code> in <span class="emphasis"><em>
<a class="link" href="ch01.html" title="Chapter 1. Getting Organized with NPM, Bower, and Grunt">Chapter 1</a>
</em></span>,<span class="emphasis"><em> Getting Organized with NPM, Bower, and Grunt</em></span>:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install karma-cli -g</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>Make sure that you add the <code class="literal">-g</code> parameter so that <code class="literal">karma</code> is available as a global Node.js module.</p></div></div><p>Now, you can simply run the following command from the CLI:</p><pre class="programlisting">
<span class="strong"><strong>$ karma start</strong></span>
</pre><p>Running this command will open the specified browsers automatically while yielding an output similar to the following command:</p><pre class="programlisting">
<span class="strong"><strong>28 08 2016 18:02:34.147:INFO [karma]: Karma v1.2.0 server started at&#13;
    http://localhost:9876/</strong></span>
<span class="strong"><strong>28 08 2016 18:02:34.147:INFO [launcher]: Launching browsers Chrome, Firefox&#13;
    with unlimited concurrency</strong></span>
<span class="strong"><strong>28 08 2016 18:02:34.157:INFO [launcher]: Starting browser Chrome</strong></span>
<span class="strong"><strong>28 08 2016 18:02:34.163:INFO [launcher]: Starting browser Firefox</strong></span>
<span class="strong"><strong>28 08 2016 18:02:35.301:INFO [Chrome 52.0.2743 (Mac OS X 10.11.6)]:&#13;
    Connected on socket /#TJZjs4nvaN-kNp3QAAAA with id 18074196</strong></span>
<span class="strong"><strong>28 08 2016 18:02:36.761:INFO [Firefox 48.0.0 (Mac OS X 10.11.0)]:&#13;
    Connected on socket /#74pJ5Vl1sLPwySk4AAAB with id 24041937</strong></span>
<span class="strong"><strong>Chrome 52.0.2743 (Mac OS X 10.11.6):&#13;
    Executed 2 of 2 SUCCESS (0.008 secs / 0.001 secs)</strong></span>
<span class="strong"><strong>Firefox 48.0.0 (Mac OS X 10.11.0):&#13;
    Executed 2 of 2 SUCCESS (0.002 secs / 0.002 secs)</strong></span>
<span class="strong"><strong>TOTAL: 4 SUCCESS</strong></span>
</pre><p>If you follow along from the beginning of this output, you can see that Karma launches its own server on <code class="literal">port 9876</code> and then launches the specified browsers once it is running. Your two tests are run in each browser with success, thus a total of <code class="literal">4 SUCCESS</code> is noted in the final line of the output.</p><p>The reason for doing this type of testing is so that your unit tests can run in multiple browsers and you can ensure that they pass in all of them. With frontend JavaScript, there is always the possibility that one browser will work differently than another, so as many scenarios as possible should be tested so you can be sure that your app won't have bugs in some browsers that may be experienced by any end users with those browsers.</p><p>This is also a great way to help you define the browsers you want to support for your application and which browsers you may want to detect and notify the user that it is not supported. This is a common practice when you want to use modern JavaScript techniques and methods that may not be supported by older, outdated browsers.</p></div><div class="section" title="Testing AngularJS with Karma and Jasmine"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec47"/>Testing AngularJS with Karma and Jasmine</h4></div></div></div><p>The AngularJS community has embraced Jasmine as its unit testing framework of choice, and it can also be used with Karma. Let's install our dependencies to work with Karma and Jasmine now:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install jasmine karma-jasmine --save-dev</strong></span>
</pre><p>This will install the Jasmine unit testing framework and its corresponding plugin for Karma, saving it to your <code class="literal">package.json</code> file.</p><p>Now, let's install AngularJS to our sample project, simply to test example code, so we can learn how to apply unit testing to our actual AngularJS app.</p><p>AngularJS is available on both NPM and Bower. We will use Bower for the following example, as this is for frontend code:</p><pre class="programlisting">
<span class="strong"><strong>$ bower install angular --save</strong></span>
</pre><p>Save <code class="literal">angular</code> as a dependency. Next, install the <code class="literal">angular-mocks</code> library as a development dependency:</p><pre class="programlisting">
<span class="strong"><strong>$ bower install angular-mocks --save-dev</strong></span>
</pre><p>The <code class="literal">angular-mocks</code> library gives you the <code class="literal">ngMock</code> module, which can be used in your AngularJS applications to mock services. Additionally, you can use it to extend other modules and make them behave synchronously, providing for more straightforward testing.</p><p>Now, let's change the <code class="literal">karma.conf.js</code> file to reflect the use of Jasmine instead of Mocha, and the addition of <code class="literal">angular-mocks</code>. Your configuration should look like the following code block:</p><pre class="programlisting">module.exports = function(config) { &#13;
    'use strict'; &#13;
    config.set({ &#13;
        frameworks: ['jasmine'], &#13;
        files: [ &#13;
            'bower_components/angular/angular.js', &#13;
            'bower_components/angular-mocks/angular-mocks.js', &#13;
            'test/angular-test.js' &#13;
        ], &#13;
        browsers: ['Chrome', 'Firefox'], &#13;
        singleRun: true &#13;
    }); &#13;
}; &#13;
</pre><p>Here, we have changed the <code class="literal">frameworks</code> parameter of the Karma configuration to use only Jasmine. Jasmine can be dropped in as a replacement for both Mocha and Chai because Jasmine includes its own assertion methods. Additionally, we have added <code class="literal">angular.js</code> and <code class="literal">angular-mocks.js</code> from the <code class="literal">bower_components</code> directory to our <code class="literal">files</code> array to test AngularJS code with <code class="literal">ngMock</code>. Under the test directory, we will load a new file named <code class="literal">angular-test.js</code>.</p><p>Now, let's use Jasmine and <code class="literal">ngMock</code> to write some tests for a simplified version of <code class="literal">DashMainController</code>, which we wrote for the gift app in <span class="emphasis"><em>
<a class="link" href="ch10.html" title="Chapter 10. Displaying Views">Chapter 10</a>
</em></span>, <span class="emphasis"><em>Displaying Views</em></span>. Create a file under the test directory named <code class="literal">angular-test.js</code> and add the following code:</p><pre class="programlisting">var giftappControllers = angular.module('giftappControllers', []); &#13;
angular.module('giftappControllers') &#13;
    .controller('DashMainController', ['$scope', function($scope, List) { &#13;
        $scope.lists = [ &#13;
            {'name': 'Christmas List'}, &#13;
            {'name': 'Birthday List'} &#13;
        ]; &#13;
    }]); &#13;
</pre><p>This will load the <code class="literal">giftappControllers</code> module into memory and subsequently register <code class="literal">DashMainController</code>. We are excluding any other services and factories here to ensure the isolated testing of the controller. Next, let's write a simple Jasmine test to assert that the length of the <code class="literal">$scope.lists</code> array is <code class="literal">2</code>:</p><pre class="programlisting">describe('DashMainController', function() { &#13;
    var $controller; &#13;
    beforeEach(module('giftappControllers')); &#13;
    beforeEach(inject(function(_$controller_) { &#13;
        $controller = _$controller_; &#13;
    })); &#13;
    describe('$scope.lists', function() { &#13;
        it('has a length of 2', function() { &#13;
            var $scope = {}; &#13;
            var testController = $controller('DashMainController', { &#13;
                $scope: $scope &#13;
            }); &#13;
            expect($scope.lists.length).toEqual(2); &#13;
        }); &#13;
    }); &#13;
}); &#13;
</pre><p>In the initial <code class="literal">describe</code> call for <code class="literal">DashMainController</code>, we will initialize a <code class="literal">$controller</code> variable that will be used to represent the AngularJS <code class="literal">$controller</code> service. Additionally, we will make two calls to the Jasmine <code class="literal">beforeEach</code> method. This allows code to be run before each test is run and do any setup that is needed. In this case, we will need to initialize the <code class="literal">giftappControllers</code> module, done in the first call to <code class="literal">beforeEach</code>, and next we must assign the local <code class="literal">$controller</code> variable to the AngularJS <code class="literal">$controller</code> service.</p><p>In order to access the AngularJS <code class="literal">$controller</code> service, we will use the angular-mock <code class="literal">inject</code> method, which wraps a function into an injectable function, making use of Angular's dependency injector. This method also includes a convention in which you can place an underscore on each side of an argument name and it will get injected properly without conflicting with your local variable names. Here, we will do this with the <code class="literal">_$controller_</code> argument, which is interpreted by the <code class="literal">inject</code> method as Angular's <code class="literal">$controller</code> service. This allows us to use the local <code class="literal">$controller</code> variable to take its place and keep the naming convention consistent.</p><p>With this code in place, you are ready to run the test, as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ karma start</strong></span>
</pre><p>This will yield an output similar to the following command:</p><pre class="programlisting">
<span class="strong"><strong>03 09 2016 01:42:58.563:INFO [karma]: Karma v1.2.0 server started at&#13;
    http://localhost:9876/</strong></span>
<span class="strong"><strong>03 09 2016 01:42:58.567:INFO [launcher]: Launching browsers Chrome, Firefox&#13;
    with unlimited concurrency</strong></span>
<span class="strong"><strong>03 09 2016 01:42:58.574:INFO [launcher]: Starting browser Chrome</strong></span>
<span class="strong"><strong>03 09 2016 01:42:58.580:INFO [launcher]: Starting browser Firefox</strong></span>
<span class="strong"><strong>03 09 2016 01:42:59.657:INFO [Chrome 52.0.2743 (Mac OS X 10.11.6)]:&#13;
    Connected on socket /#sXw8Utn7qjVLwiqKAAAA with id 15753343</strong></span>
<span class="strong"><strong>Chrome 52.0.2743 (Mac OS X 10.11.6):&#13;
    Executed 1 of 1 SUCCESS (0.038 secs / 0.03 secs)</strong></span>
<span class="strong"><strong>Chrome 52.0.2743 (Mac OS X 10.11.6):&#13;
    Executed 1 of 1 SUCCESS (0.038 secs / 0.03 secs)</strong></span>
<span class="strong"><strong>Firefox 48.0.0 (Mac OS X 10.11.0):&#13;
    Executed 1 of 1 SUCCESS (0.001 secs / 0.016 secs)</strong></span>
<span class="strong"><strong>TOTAL: 2 SUCCESS</strong></span>
</pre><p>You should see that the test passed in all browsers because the length of the <code class="literal">$scope.lists</code> array is <code class="literal">2</code>, as the Jasmine assertion tested for.</p></div></div></div><div class="section" title="Integration testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec149"/>Integration testing</h2></div></div></div><p>The second level of the software testing pyramid is <span class="emphasis"><em>integration testing</em></span>. Integration testing involves testing at least two units of code that interact with each other, so in its simplest form, an integration test will test the outcome of two unit tests, such that they <span class="emphasis"><em>integrate</em></span> with your application as expected.</p><p>The idea behind integration testing is to build upon your unit tests by testing larger pieces, or <span class="emphasis"><em>components</em></span>, of your application. It is possible that all of your unit tests may pass because they are tested in isolation, but when you start testing the interaction of those units with each other, the outcome may not be what you expect. This is why unit testing alone is not sufficient to adequately test a SPA. Integration testing allows you to test key functionality in various components of your application before you move on to end-to-end testing.</p></div><div class="section" title="End-to-end testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec150"/>End-to-end testing</h2></div></div></div><p>The top level of the software testing pyramid is <span class="emphasis"><em>end-to-end testing</em></span>, abbreviated as E2E, and also referred to as <span class="emphasis"><em>functional testing</em></span>. The goal of end-to-end testing is to test the true functionality of your application's features in their entirety. For example, if you have a user registration feature in your app, an end-to-end test will ensure that the user is able to register properly through the UI, added to the database, a message to the user that they were successfully registered displayed, and, potentially, an e-mail sent to the user, or any other follow-up actions that may be required by your application.</p><div class="section" title="The angular-seed project"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec164"/>The angular-seed project</h3></div></div></div><p>In order to demonstrate a simple AngularJS application with examples of both unit and end-to-end testing, AngularJS created the <code class="literal">angular-seed</code> project. It is an open source project that is available on GitHub. Let's install it now so that we can run some simple unit and end-to-end testing with AngularJS.</p><p>Let's clone the angular-seed repository from GitHub into a new, clean project directory, as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ git clone https://github.com/angular/angular-seed.git</strong></span>
<span class="strong"><strong>$ cd angular-seed</strong></span>
</pre><p>The angular-seed project has both NPM dependencies and Bower dependencies, but you only need to run the NPM install that will install the Bower dependencies for you:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install</strong></span>
</pre><p>This will install many tools and libraries, some of which you have seen already, including Jasmine, Karma, AngularJS, and angular-mocks. Next, all you have to do is start the NPM server using the following command line:</p><pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
</pre><p>This will run a few tasks and then start up a Node.js server for you. You should see the following output:</p><pre class="programlisting">
<span class="strong"><strong>&gt; angular-seed@0.0.0 prestart /angular-seed</strong></span>
<span class="strong"><strong>&gt; npm install</strong></span>
<span class="strong"><strong>&gt; angular-seed@0.0.0 postinstall /angular-seed</strong></span>
<span class="strong"><strong>&gt; bower install</strong></span>
<span class="strong"><strong>&gt; angular-seed@0.0.0 start /angular-seed</strong></span>
<span class="strong"><strong>&gt; http-server -a localhost -p 8000 -c-1 ./app</strong></span>
<span class="strong"><strong>Starting up http-server, serving ./app</strong></span>
<span class="strong"><strong>Available on:</strong></span>
<span class="strong"><strong>  http://localhost:8000</strong></span>
<span class="strong"><strong>Hit CTRL-C to stop the server</strong></span>
</pre><p>Now, go to http://localhost:8000 in a web browser and you will see a simple layout displayed. It consists of two view labels, <code class="literal">view1</code> and <code class="literal">view2</code>, with <code class="literal">view1</code> being displayed by default after the page loads. Each view requests a partial template file to be loaded upon the first view, and then caches it for any subsequent view.</p><p>Let's first run the angular-seed unit tests so we can see how they are set up. Karma is used to launch Jasmine unit tests, just as we did with our example controller test earlier; however, by default, they are set with the <code class="literal">singleRun</code> property in <code class="literal">karma.conf.js</code> set to false, which is intended for continuous integration. This allows Karma to watch for changes to your code as you make them so that the unit tests are run each time you save a file. In this way, you will get immediate feedback from the test runner and know if any tests are failing, which will prevent you from coding too far down a broken path.</p><p>To run the <code class="literal">angular-seed</code> tests in continuous integration mode, simply run the following NPM <code class="literal">test</code> command from the CLI:</p><pre class="programlisting">
<span class="strong"><strong>$ npm test</strong></span>
</pre><p>This will yield an output similar to the following:</p><pre class="programlisting">
<span class="strong"><strong>&gt; angular-seed@0.0.0 test /angular-seed</strong></span>
<span class="strong"><strong>&gt; karma start karma.conf.js</strong></span>
<span class="strong"><strong>03 09 2016 13:02:57.418:WARN [karma]: No captured browser, open&#13;
    http://localhost:9876/</strong></span>
<span class="strong"><strong>03 09 2016 13:02:57.431:INFO [karma]: Karma v0.13.22 server started at&#13;
    http://localhost:9876/</strong></span>
<span class="strong"><strong>03 09 2016 13:02:57.447:INFO [launcher]: Starting browser Chrome</strong></span>
<span class="strong"><strong>03 09 2016 13:02:58.549:INFO [Chrome 52.0.2743 (Mac OS X 10.11.6)]:&#13;
    Connected on socket /#A2XSbQWChmjkstjNAAAA with id 65182476</strong></span>
<span class="strong"><strong>Chrome 52.0.2743 (Mac OS X 10.11.6):&#13;
    Executed 5 of 5 SUCCESS (0.078 secs / 0.069 secs)</strong></span>
</pre><p>This output shows that <code class="literal">5 of 5</code> unit tests were executed successfully. Notice that the command continues to run as it is in continuous integration mode. You will also have a Chrome browser window open that is awaiting file changes so that it can rerun the tests, the results of which will be immediately printed back to the CLI.</p><p>The project also includes a command to run Karma in <code class="literal">singleRun</code> mode, as we did with our previous Karma examples. To do this, hit <span class="strong"><strong>Ctrl</strong></span> + <span class="strong"><strong>C</strong></span> to close the currently running Karma instance. This will shut down the Chrome browser window as well.</p><p>Next, you will use the following NPM run command to launch Karma just once and shut back down:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run test-single-run</strong></span>
</pre><p>You will see the same output as you did earlier, but the browser window will open and close, the tests will run successfully, and the CLI will bring you back to the command prompt.</p><p>Now that we've done some simple unit testing with the angular-seed project, let's move on to end-to-end testing.</p><div class="section" title="End-to-end testing with AngularJS and angular-seed"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl4sec48"/>End-to-end testing with AngularJS and angular-seed</h4></div></div></div><p>AngularJS emphasizes the importance of end-to-end testing and they have their own testing framework, <span class="strong"><strong>Protractor</strong></span>,to do so. Protractor is an open source Node.js application that is built upon WebdriverJS, or just Webdriver, a component of the Selenium project.</p><p>Selenium has been around for a long time and is extremely well known throughout the web development community. It comprises multiple tools and libraries that allow for web browser automation. WebdriverJS is one of those libraries, and it is designed to test JavaScript applications.</p><p>Protractor is similar to Karma, in that, it is a test runner, but it designed to run end-to-end tests rather than unit tests. The end-to-end tests in the angular-seed project are written with Jasmine and Protractor is used to launch and run them.</p><p>First, we will need to install Webdriver as Protractor is built on top of it. The project comes with the following script to do this:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run update-webdriver</strong></span>
</pre><p>This will yield an output similar to the following, installing the latest version of Webdriver:</p><pre class="programlisting">
<span class="strong"><strong>Updating selenium standalone to version 2.52.0</strong></span>
<span class="strong"><strong>downloading https://selenium-release.storage.googleapis.com/2.52/selenium-&#13;
    server-standalone-2.52.0.jar...</strong></span>
<span class="strong"><strong>Updating chromedriver to version 2.21</strong></span>
<span class="strong"><strong>downloading &#13;
    https://chromedriver.storage.googleapis.com/2.21/chromedriver_mac32.zip...</strong></span>
<span class="strong"><strong>chromedriver_2.21mac32.zip downloaded to /angular-&#13;
    seed/node_modules/protractor/selenium/chromedriver_2.21mac32.zip</strong></span>
<span class="strong"><strong>selenium-server-standalone-2.52.0.jar downloaded to /angular-&#13;
    seed/node_modules/protractor/selenium/selenium-server-standalone-2.52.0.jar</strong></span>
</pre><p>Once Webdriver is installed successfully, run the following NPM server again with Karma running so that Protractor can interact with the web application:</p><pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
</pre><p>Next, as Protractor is set up to test with Chrome by default, we will need to bypass the Selenium server as it uses a Java NPAPI plugin that the newer versions of Chrome do not support. Fortunately, Protractor can test directly against both Chrome and Firefox, which circumvents this problem. To use a direct server connection with Chrome or Firefox, open the <code class="literal">protractor.conf.js</code> file in the E2E-tests directory, add a new configuration property named <code class="literal">directConnect</code> at the bottom, and set it to <code class="literal">true</code>. The Protractor config file should now look like the following block of code:</p><pre class="programlisting">//jshint strict: false &#13;
exports.config = { &#13;
 &#13;
  allScriptsTimeout: 11000, &#13;
 &#13;
  specs: [ &#13;
    '*.js' &#13;
  ], &#13;
 &#13;
  capabilities: { &#13;
    'browserName': 'chrome' &#13;
  }, &#13;
 &#13;
  baseUrl: 'http://localhost:8000/', &#13;
 &#13;
  framework: 'jasmine', &#13;
 &#13;
  jasmineNodeOpts: { &#13;
    defaultTimeoutInterval: 30000 &#13;
  }, &#13;
 &#13;
  directConnect: true &#13;
 &#13;
}; &#13;
</pre><p>Keep in mind that the <code class="literal">directConnect</code> setting is only intended to be used with Chrome and Firefox only. If you decide to run your tests in another browser, you will want to set it to <code class="literal">false</code>, or remove the property from the config, otherwise an error will be thrown. Using Chrome and Firefox to run your tests with <code class="literal">directConnect</code> also gives you a boost in speed when running your tests as the Selenium server is bypassed.</p><p>Now, with the server running, open another CLI session in the angular-seed root directory and run the following command for Protractor:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run protractor</strong></span>
</pre><p>The console output will indicate that ChromeDriver is being used directly and that one instance of WebDriver is running. You should see an output similar to the following command:</p><pre class="programlisting">
<span class="strong"><strong>&gt; angular-seed@0.0.0 protractor /angular-seed</strong></span>
<span class="strong"><strong>&gt; protractor e2e-tests/protractor.conf.js</strong></span>
<span class="strong"><strong>[14:04:58] I/direct - Using ChromeDriver directly...</strong></span>
<span class="strong"><strong>[14:04:58] I/launcher - Running 1 instances of WebDriver</strong></span>
<span class="strong"><strong>Started</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>3 specs, 0 failures</strong></span>
<span class="strong"><strong>Finished in 1.174 seconds</strong></span>
<span class="strong"><strong>[14:05:00] I/launcher - 0 instance(s) of WebDriver still running</strong></span>
<span class="strong"><strong>[14:05:00] I/launcher - chrome #01 passed</strong></span>
</pre><p>Notice that <code class="literal">3 specs</code> is indicated in the output? This indicates that those three E2E tests were run. Let's take a closer look at these tests by opening the <code class="literal">e2e-tests/scenarios.js</code> file in an editor.</p><p>At the beginning of this file, you will see an opening <code class="literal">describe</code> method call used to describe the application you are testing:</p><pre class="programlisting">describe('my app', function() { &#13;
    ... &#13;
}); &#13;
</pre><p>This <code class="literal">describe</code> block is used to contain all E2E tests for the application. Now, let's examine the first test:</p><pre class="programlisting">it('should automatically redirect to /view1 when location hash/fragment is empty', function() { &#13;
    browser.get('index.html'); &#13;
    expect(browser.getLocationAbsUrl()).toMatch("/view1"); &#13;
}); &#13;
</pre><p>This test asserts that the application will redirect the URL in the browser to <code class="literal">/#!/view1</code> when the <code class="literal">#!</code> route is empty. This is because the application is configured to auto-load the <code class="literal">view111</code> partial when it loads, so the URL should reflect the route to that partial when it is loaded. You will notice that this does indeed occur when you load the application at <code class="literal">http://localhost:8000</code> in your browser and it redirects to <code class="literal">http://localhost:8000/#!/view1</code>. This uses WebDriver's direct connection to Chrome to run the application and test the functionality through the <code class="literal">browser</code> API method, combined with an <code class="literal">expect</code> assertion that the URL matches the test path.</p><p>The second test in <code class="literal">scenarios.js</code> is a bit more verbose, as shown in the following block of code:</p><pre class="programlisting">describe('view1', function() { &#13;
 &#13;
    beforeEach(function() { &#13;
        browser.get('index.html#!/view1'); &#13;
    }); &#13;
 &#13;
    it('should render view1 when user navigates to /view1', function() { &#13;
        expect(element.all(by.css('[ng-view]&#13;
        p')).first().getText()).toMatch(/partial for view 1/); &#13;
    }); &#13;
 &#13;
}); &#13;
</pre><p>This test asserts that the text shown in the view for the partial route <code class="literal">/#!/view1</code> is in fact what it is expected to be. If you watch your developer console when you load the app in a browser, you will notice that it automatically makes an AJAX request to retrieve the local file, <code class="literal">view1.html</code>, which contains the partial for this view. The subsequent text that is displayed from this view is what this end-to-end test is looking for. This test uses the <code class="literal">browser</code> API method again, and additionally it uses the <code class="literal">element</code> API method to access DOM selectors, combined with an <code class="literal">expect</code> assertion that the text in the view matches the test string.</p><p>The third and final test in <code class="literal">scenarios.js</code> is much like the second test, but it is used to test the text shown in the view for the partial route rendered at <code class="literal">/#!/view2</code>. To view that text, first click on the <span class="strong"><strong>view2</strong></span> link in the running angular-seed application in your browser. You will see the URL update to view2, the console will show that another AJAX request is made to retrieve the local file view2.html, and the rendered view is updated, displaying the text (<span class="strong"><strong>This is the partial for view 2</strong></span>). Now, let's take a look at the test, which is as follows:</p><pre class="programlisting">describe('view2', function() { &#13;
 &#13;
    beforeEach(function() { &#13;
        browser.get('index.html#!/view2'); &#13;
    }); &#13;
 &#13;
    it('should render view2 when user navigates to /view2', function() { &#13;
        expect(element.all(by.css('[ng-view] &#13;
        p')).first().getText()).toMatch(/partial for view 2/); &#13;
    }); &#13;
 &#13;
}); &#13;
</pre><p>For this test to work, the browser must first be directed to go to the <code class="literal">/#!/view2</code> route so that the respective view will be displayed. This is accomplished by the <code class="literal">beforeEach</code> method that is run before the <code class="literal">it</code> method call. As discussed earlier, Jasmine provides the <code class="literal">beforeEach</code> method for any setup that needs to occur before each time a test is run. In this case, it runs code directing the <code class="literal">browser</code> API method to perform a <code class="literal">get</code> request to the <code class="literal">/#!/view2</code> URL, which will subsequently update the view for the application to display the <code class="literal">view2</code> partial. Only after this is complete will the test be run. This test also uses the <code class="literal">element</code> API method to access the DOM and find the text that it is looking to match against the <code class="literal">expect</code> assertion that the text (<span class="strong"><strong>This is the partial for view 2</strong></span>) is found in the view.</p><p>End-to-end testing should certainly be more thorough for a real-world application, but the angular-seed project is a good place to start with experimenting on both unit testing and end-to-end testing for an AngularJS application. Once you have learned how it all works, gotten familiar with the Protractor and WebDriver APIs, and feel comfortable using Jasmine and Protractor together, you can begin writing custom tests for your own AngularJS applications with confidence.</p></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec70"/>Summary</h1></div></div></div><p>In this chapter, you have learned the differences between unit testing, integration testing, and end-to-end testing and how they can, and should, all be combined together to provide full-fledged testing for a JavaScript SPA. You have learned about the Mocha and Jasmine unit testing frameworks, and how to write unit test with both of them, including how to write unit tests for AngularJS with Jasmine. You have also learned how to launch multiple browsers to test cross-browser compatibility of your unit tests with Karma, and about various other tools that can be added to your testing stack, including Chai and Sinon.js.</p><p>Now that you have all the tools you need to build and test a JavaScript SPA, we will bring you to the final chapter to learn about deployment and scaling.</p></div></body></html>