- en: Introducing TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book aims to provide you with a broad overview of TypeScript's features,
    its limitations, and its ecosystem. You will learn about the TypeScript language,
    development tools, design patterns, and recommended practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you an overview of the history behind TypeScript and
    introduce you to some of its basics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type annotations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and primitive data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow control statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TypeScript architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will focus on TypeScript's internal architecture and its
    original design goals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Design goals
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list describes the main design goals and architectural decisions
    that shaped the way the TypeScript programming language looks today:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Statically identify JavaScript constructs that are likely to be errors**:
    The engineers at Microsoft decided that the best way to identify and prevent potential
    runtime issues was to create a strongly-typed programming language and perform
    static type checking at compile time. The engineers also designed a language services
    layer to provide developers with better tools.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High compatibility with existing JavaScript code**: TypeScript is a superset
    of JavaScript; this means that any valid JavaScript program is also a valid TypeScript
    program (with a few small exceptions).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide a structuring mechanism for larger pieces of code**: TypeScript adds
    class-based object-orientation, interfaces, namespaces, and modules. These features
    will help us to structure our code in a much better way. We will also reduce potential
    integration issues within our development team and our code will become easier
    to maintain and scale by adhering to the best object-oriented principles and recommended
    practices.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Impose no runtime overhead on emitted programs**: It is common to differentiate
    between design time and execution time when thinking about TypeScript. We use
    the term *design time* or *compile time* to refer to the TypeScript code that
    we write while designing an application, while we use the term *execution time*
    or *runtime* to refer to the JavaScript code executed after compiling some TypeScript
    code.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript adds some features to JavaScript, but those features are only available
    at design time. For example, we can declare interfaces in TypeScript, but since
    JavaScript doesn't support interfaces, the TypeScript compiler will not declare
    or try to emulate this feature at runtime (in the output JavaScript code).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft engineers provided the TypeScript compiler with some mechanisms,
    such as **code transformations** (converting TypeScript features into plain JavaScript
    implementations) and **type erasure** (removing static type notation), to generate
    clean JavaScript code. Type erasure removes not only the type annotations, but
    also all the TypeScript-exclusive language features such as interfaces.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the generated code is highly compatible with web browsers as it
    targets the ECMAScript 3 specification by default, but it also supports ECMAScript
    5 and ECMAScript 6\. In general, we can use the TypeScript features when compiling
    to any of the available compilation targets, but sometimes some features will
    require ECMAScript 5 or a higher version as the compilation target.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**Align with current and future ECMAScript proposals**: TypeScript is not just
    compatible with existing JavaScript code; it is also compatible with some future
    versions of JavaScript. At first glance, we may think that some TypeScript features
    make it quite different from JavaScript, but the reality is that all the features
    available in TypeScript (except the type system features) follow the ECMAScript
    proposals, which means that many of the TypeScript files will eventually be available
    as native JavaScript features.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be a cross-platform development tool**: Microsoft released TypeScript under
    the open source Apache license and it can be installed and executed in all major
    operating systems.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript components
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript language has three main internal layers. Each of these layers
    is, in turn, divided into sublayers or components. In the following diagram, we
    can see the three layers (three different shades of gray) and each of their internal
    components (boxes):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a5b02ad-cdc4-4ec9-a3cb-2982bb15ef2f.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the acronym **VS** refers to Microsoft's Visual Studio,
    which is the official family of **integrated development environments** (**IDEs**)
    for all Microsoft products (including TypeScript). We will learn more about this
    and the other IDEs in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these main layers has a different purpose:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Language**: Features the TypeScript language elements.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiler** Performs the parsing, type checking, and transformation of your
    TypeScript code to JavaScript code.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language services**: Generates information that helps editors and other tools
    provide better assistance features, such as IntelliSense or automated refactoring.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDE integration (VS Shim)**: The developers of the IDEs and text editors
    must perform some integration work to take advantage of the TypeScript features.
    TypeScript was designed to facilitate the development of tools that help to increase
    the productivity of JavaScript developers. Because of these efforts, integrating
    TypeScript with an IDE is not a complicated task. A proof of this is that the
    most popular IDEs these days include good TypeScript support.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other books and online resources, you may find references to the term *transpiler*
    instead of *compiler*. A **transpiler** is a type of compiler that takes the source
    code of a programming language as its input and outputs the source code into another
    programming language with a similar level of abstraction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the TypeScript language services and the TypeScript
    compiler in [Chapter 15](9cc3e5f2-72c1-4f3c-9ed8-ba2760eae2d8.xhtml), *Working
    with the TypeScript Compiler and the Language Services*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript language features
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned about the purpose of TypeScript, it's time to get
    our hands dirty and start writing some code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can start learning how to use some of the basic TypeScript building
    blocks, you will need to set up your development environment. The easiest and
    fastest way to start writing some TypeScript code is to use the online editor,
    available on the official TypeScript website at [https://www.typescriptlang.org/play/index.html](https://www.typescriptlang.org/play/index.html):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/683b2ade-87db-499a-97f6-9dc9f1743a7c.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the appearance of the TypeScript playground.
    If you visit the playground, you will be able to use the text editor on the left-hand
    side of the screen to write TypeScript code. The code will then be automatically
    compiled into JavaScript. The output code will be inserted in the text editor
    located on the right-hand side of the screen. If your TypeScript code is invalid,
    the JavaScript code on the right-hand side will not be updated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you prefer to be able to work offline, you can download and
    install the TypeScript compiler. If you work with a Visual Studio version older
    than Visual Studio 2015, you will need to download the official TypeScript extension
    from [https://marketplace.visualstudio.com/](https://marketplace.visualstudio.com/).
    If you are working with a version of Visual Studio released after the 2015 version
    (or Visual Studio Code), you will not need to install the extension, as these
    versions includes TypeScript support by default.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: There are TypeScript plugins available for many popular editors such as Sublime
    ([https://github.com/Microsoft/TypeScript-Sublime-Plugin](https://github.com/Microsoft/TypeScript-Sublime-Plugin))
    or Atom ([https://atom.io/packages/atom-typescript](https://atom.io/packages/atom-typescript)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: You can also use TypeScript from the command-line interface by downloading it
    as an `npm` module. Don't worry if you are not familiar with npm. For now, you
    only need to know that it stands for **node package manager** and is the default
    Node.js package manager. Node.js is an open source, cross-platform JavaScript
    runtime environment for executing JavaScript code server-side. To be able to use
    npm, you will need to install Node.js in your development environment. You will
    be able to find the Node.js installation files on the official website at [https://nodejs.org/](https://nodejs.org/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed Node.js in your development environment, you will be
    able to run the following command in a console or Terminal:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unix-based operating systems may require the use of the `sudo` command when
    installing global (`-g`) npm packages. The `sudo` command will prompt the user
    credentials and install the package using administrative privileges:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo npm install -g typescript`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `test.ts`, and add the following code to it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the file into a directory of your choice and open a command-line interface.
    Navigate to the directory in which you saved the file and execute the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If everything goes well, you will find a file named `test.js` in the same directory
    in which the `test.ts` file is located. Now you know how to compile your TypeScript
    code into JavaScript code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute the output JavaScript code using Node.js:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know how to compile and execute TypeScript source code, we can start
    learning about some of the TypeScript features.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to learn more about editors, compiler options, and other TypeScript
    tools in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)*,* *Automating
    Your Development Workflow*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already learned, TypeScript is a typed superset of JavaScript. TypeScript
    added a static type system and optional static type annotations to JavaScript
    to transform it into a strongly-typed programming language.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript's type analysis occurs entirely at compile time and adds no runtime
    overhead to program execution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Type inference and optional static type annotations
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TypeScript language service is great at automatically detecting the type
    of a variable. However, there are certain cases where it is not able to automatically
    detect a type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: When the type inference system is not able to identify the type of a variable,
    it uses a type known as the *any* type. The any type is a value that represents
    all the existing types, and as a result, it is too flexible and unable to detect
    most errors, which is not a problem because TypeScript allows us to explicitly
    declare the type of a variable using what is known as **optional static type annotations**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The optional static type annotations are used as constraints on program entities
    such as functions, variables, and properties so that compilers and development
    tools can offer better verification and assistance (such as IntelliSense) during
    software development.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Strong typing allows programmers to express their intentions in their code,
    both to themselves and to others in the development team.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'For a variable, a type notation comes preceded by a colon after the name of
    a variable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have used the `let` keyword instead of the `var` keyword. The `let` keyword
    is a newer JavaScript construct that TypeScript makes available. We'll discuss
    the details later, but some common problems in JavaScript can be solved by using
    `let`, so, you should use `let` instead of `var` whenever possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we declare the type of a variable after its name; this style
    of type notation is based on type theory and helps to reinforce the idea of types
    being optional.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: When no type annotations are available, TypeScript will try to guess the type
    of the variable by examining the assigned values. For example, in the second line,
    in the preceding code snippet, we can see that the variable counter has been identified
    as a numeric variable, because its value is a numeric value. There is a process
    known as **type inference** that can automatically detect and assign a type to
    a variable. The any type is used as the type of a variable when the type inference
    system is not able to detect its type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that the companion source code might be slightly different from
    the code presented during the chapters. The companion source code uses namespaces
    to isolate each demo from all the other demos and sometimes appends numbers to
    the name of the variables to prevent naming conflicts. For example, the preceding
    code is included in the companion source code as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will be able to learn more about the TypeScript type system in [Chapter
    2](7211d7ea-dc2f-4ff0-bb19-14400bb911bc.xhtml), *Working with Types*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Variables, basic types, and operators
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic types are boolean, number, string, array, tuple, Object, object,
    null, undefined, {}, void, and enumerations. Let''s learn about each of these
    basic types:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Description** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| Boolean | Whereas the string and number data types can have a virtually unlimited
    number of different values, the boolean data type can only have two. They are
    the literals: `true` and `false`. A boolean value is a truth value; it specifies
    whether the condition is true or not:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '| Number | As in JavaScript, all numbers in TypeScript are floating-point values.
    These floating-point numbers get the type `number`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '| String | We use the `string` data type to represent text in TypeScript. You
    include string literals in your scripts by enclosing them in single or double
    quotation marks. Double quotation marks can be contained in strings surrounded
    by single quotation marks and single quotation marks can be contained in strings
    surrounded by double quotation marks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '| Array | We use the `array` data type to represent a collection of values.
    The `array` type can be written using two different syntax styles. We can use
    the type of the elements in the array followed by brackets `[]` to annotate a
    collection of that element type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second syntax style uses a generic array type named `Array<T>`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '| Tuple | Tuple types can be used to represent an array with a fixed number
    of elements with different types where the type is known. For example, we can
    represent a value as a pair of a string and a number:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '| Enum | We use enumerations to add more meaning to a set of values. Enumerations
    can be numeric or text-based. By default, numeric enumerations assign the value
    0 to the first member in the enumeration and increase it by one for each of the
    members in the enumeration:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '| Any | All types in TypeScript are subtypes of a single top type called the
    **any** **type**. The `any` keyword references this type. The any type eliminates
    most of the TypeScript type checks and represents all the possible types:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `any` type can be useful while migrating existing JavaScript code to TypeScript,
    or when we know some details about a type but we don''t know all its details.
    For example, when we know that a type is an array, but we don''t know the type
    of the elements in such an array:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '| object (lowercase) | The `object` type represents any non-primitive type.
    The following types are considered to be primitive types in JavaScript: boolean,
    number, string, symbol, null, and undefined. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| Object (uppercase) | In JavaScript, all objects are derived from the `Object`
    class. `Object` (uppercase) describes functionality that is common to all JavaScript
    objects. That includes the `toString()` and the `hasOwnProperty()` methods, for
    example. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| Empty object type {} | This describes an object that has no members of its
    own. TypeScript issues a compile-time error when you try to access arbitrary properties
    of such an object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '| Null and undefined | In TypeScript, both undefined and null are types. By
    default, null and undefined are subtypes of all other types. That means you can
    assign null and undefined to something like a number.However, when using the `--strictNullChecks`
    flag, null and undefined are only assignable to void and their respective types.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| Never | The `never` type is used in the following two places:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: As the return type of functions that never return
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the type of variables under type guards that are never true
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '| Void | In some ways the opposite of `any` is  `void`, the absence of having
    any type at all. You will see this as the return type of functions that do not
    return a value:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript and JavaScript, undefined is a property in the global scope that
    is assigned as a value to variables that have been declared but have not yet been
    initialized. The value `null` is a literal (not a property of the global object)
    and it can be assigned to a variable as a representation of no value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Variable scope (var, let, and const)
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we declare a variable in TypeScript, we can use the `var`, `let`, or `const`
    keywords:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Variables declared with `var` are scoped to the nearest function block (or global,
    if outside a function block).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Variables declared with `let` are scoped to the nearest enclosing block (or
    global, if outside any block), which can be smaller than a function block.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The `const` keyword creates a constant that can be global or local to the block
    in which it is declared. This means that constants are block-scoped.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about scopes in [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime.*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript supports the following arithmetic operators. We must assume that
    variable `A` holds `10` and variable `B` holds `20` to understand the following
    examples:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtracts the second operand from the first. | *A - B* will give `-10`
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `+` | Adds two operands. | *A + B* will give `30` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiplies both the operands. | *A * B* will give `200` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `**` | Multiplies the first operand by itself a number of times which is
    indicated by the second operand. | *A ** B* will give *1e+20* |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `%` | This is the modulus operator and remainder after an integer division.
    | *B % A* will give `0` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `/` | Divides the numerator by the denominator. | *B / A* will give `2` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `--` | Decreases an integer value by one. | *A--* will give `9` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `++` | Increases an integer value by one. | *A++* will give `11` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: Comparison operators
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript supports the following comparison operators. To understand the examples,
    you must assume that variable `A` holds `10` as value and variable `B` holds `20`
    as value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `==` | Checks whether the values of two operands are equal or not. This operator
    uses type coercion. If yes, then the condition becomes `true`. | *(A == B)* is
    false. A == "10" is true. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `===` | Checks whether the value and type of two operands are equal or not.
    This operator doesn''t use type coercion. If yes, then the condition becomes `true`.
    | A === B is false. A === "10" is false. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Checks whether the value of two operands are equal or not. If the
    values are not equal, then the condition becomes `true`. This operator uses type
    coercion. | (A != B) is true. A != "10" is false. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `!==` | Checks whether the value of two operands are equal or not. If the
    values are not equal, then the condition becomes `true`. This operator doesn''t
    use type coercion. | A !== B is true. A !== "10" is true. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `>` | Checks whether the value of the left operand is greater than the value
    of the right operand. If yes, then the condition becomes `true`. | (A > B) is
    false. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `<` | Checks whether the value of the left operand is less than the value
    of the right operand. If yes, then the condition becomes `true`. | (A < B) is
    true. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Checks whether the value of the left operand is greater than or equal
    to the value of the right operand. If yes, then the condition becomes `true`.
    | (A >= B) is false. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Checks whether the value of the left operand is less than or equal
    to the value of the right operand. If yes, then the condition becomes `true`.
    | (A <= B) is true. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: Logical operators
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript supports the following logical operators. To understand the examples,
    you must assume that variable `A` holds `10` and variable `B` holds `20`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Known as the logical `AND` operator. If both the operands are nonzero,
    then the condition becomes `true`. | (A && B) is true. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Known as the logical `OR` operator. If any of the two operands
    are nonzero, then the condition becomes `true`. | (A &#124;&#124; B) is true.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `!` | Known as the logical `NOT` operator. It is used to reverse the logical
    state of its operand. If a condition is `true`, then the logical `NOT` operator
    will make it `false`. | !(A && B) is false. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: Bitwise operators
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript supports the following bitwise operators. To understand the examples,
    you must assume that variable `A` holds `2` as value and variable `B` holds `3`
    as value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `&` | Known as the bitwise `AND` operator, it performs a boolean `AND` operation
    on each bit of its integer arguments. | (A & B) is 2 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Known as the bitwise `OR` operator, it performs a boolean `OR`
    operation on each bit of its integer arguments. | (A &#124; B) is 3. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `^` | Known as the bitwise `XOR` operator, it performs a boolean exclusive
    `OR` operation on each bit of its integer arguments. Exclusive `OR` means that
    either operand one is true or operand two is true, but not both. | (A ^ B) is
    1. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `~` | Known as the bitwise `NOT` operator, it is a unary operator and operates
    by reversing all bits in the operand. | (~B) is -4 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Known as the bitwise shift-left operator. It moves all bits in its
    first operand to the left by the number of places specified in the second operand.
    New bits are filled with zeros. Shifting a value left by one position is equivalent
    to multiplying by two, shifting two positions is equivalent to multiplying by
    four, and so on. | (A << 1) is 4 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Known as the bitwise shift-right with sign operator. It moves all
    bits in its first operand to the right by the number of places specified in the
    second operand. | (A >> 1) is 1 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `>>>` | Known as the bitwise shift-right with zero operators. This operator
    is just like the `>>` operator, except that the bits shifted from the left are
    always zero. | (A >>> 1) is 1 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: One of the main reasons to use bitwise operators in languages such as C++, Java,
    or C# is that they're extremely fast. However, bitwise operators are often considered
    not that efficient in TypeScript and JavaScript. The bitwise operators are less
    efficient in JavaScript, because it is necessary to cast from floating-point representation
    (how JavaScript stores all of its numbers) to a 32-bit integer to perform the
    bit manipulation and back.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript supports the following assignment operators:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `=` | Assigns the values from the right-side operands to the left-side operand.
    | C = A + B will assign the value of A + B into C |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `+=` | Adds the right operand to the left operand and assigns the result
    to the left operand. | C += A is equivalent to C = C + A |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `-=` | Substracts the right operand from the left operand and assigns the
    result to the left operand. | C -= A is equivalent to C = C - A |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `*=` | Multiplies the right operand by the left operand and assigns the result
    to the left operand. | C *= A is equivalent to C = C * A |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `/=` | Divides the left operand by the right operand and assigns the result
    to the left operand. | C /= A is equivalent to C = C / A |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `%=` | Calculates the modulus using two operands and assigns the result to
    the left operand. | C %= A is equivalent to C = C % A |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: Spread operator
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The spread operator can be used to initialize arrays and objects from another
    array or object:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code snippet showcases the usage of the spread operator with
    arrays, while the following code snippet showcases its usage with object literals:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The spread operator can also be used to expand to an expression into multiple
    arguments (in function calls), but we will skip that use case for now.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the spread operator in [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml),
    *Working with Functions* and [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml),
    *Object-Oriented Programming with TypeScript*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Flow control statements
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes the decision-making statements, the looping statements,
    and the branching statements supported by the TypeScript programming language.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The single-selection structure (if)
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet declares a variable of type boolean and name `isValid`.
    Then, an `if` statement will check whether the value of `isValid` is equal to
    `true`. If the statement turns out to be `true`, the `Is valid!` message will
    be displayed on the screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The double-selection structure (if...else)
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet declares a variable of type boolean and name `isValid`.
    Then, an `if` statement will check whether the value of `isValid` is equal to
    `true`. If the statement turns out to be `true`, the message `Is valid!` will
    be displayed on the screen. On the other hand, if the statement turns out to be
    `false`, the message `Is NOT valid!` will be displayed on the screen:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The inline ternary operator (?)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The inline ternary operator is just an alternative way of declaring a double-selection
    structure:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code snippet declares a variable of type boolean and name `isValid`.
    Then, it checks whether the variable or expression on the left-hand side of the
    operator `?` is equal to `true`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: If the statement turns out to be `true`, the expression on the left-hand side
    of the character will be executed and the message `Is valid!` will be assigned
    to the message variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the statement turns out to be `false`, the expression
    on the right-hand side of the operator will be executed and the message, `Is NOT
    valid!` will be assigned to the message variable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the value of the message variable is displayed on the screen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The multiple-selection structure (switch)
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `switch` statement evaluates an expression, matches the expression's value
    to a case clause, and executes statements associated with that case. Switch statements
    and enumerations are often used together to improve the readability of the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we declare a function that takes an enumeration named
    `AlertLevel`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about enumerations in [Chapter 2](7211d7ea-dc2f-4ff0-bb19-14400bb911bc.xhtml),
    *Working with Types.*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the function, we will generate an array of strings to store email addresses
    and execute a `switch` structure. Each of the options of the enumeration is a
    case in the `switch` structure:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The value of the `level` variable is tested against all the cases in the `switch`.
    If the variable matches one of the cases, the statement associated with that case
    is executed. Once the `case` statement has been executed, the variable is tested
    against the next case.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Once the execution of the statement associated with a matching case is finalized,
    the next case will be evaluated. If the `break` keyword is present, the program
    will not continue the execution of the following `case` statement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: If no matching case clause is found, the program looks for the optional `default`
    clause, and if found, it transfers control to that clause and executes the associated
    statements.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If no `default` clause is found, the program continues execution at the statement
    following the end of switch. By convention, the `default` clause is the last clause,
    but it does not have to be so.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The expression is tested at the top of the loop (while)
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `while` expression is used to repeat an operation while a certain requirement
    is satisfied. For example, the following code snippet declares a numeric variable
    `i`. If the requirement (the value of `i` is less than `5`) is satisfied, an operation
    takes place (increase the value of `i` by one and display its value in the browser
    console). Once the operation has completed, the accomplishment of the requirement
    will be checked again:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a `while` expression, the operation will take place only if the requirement
    is satisfied.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The expression is tested at the bottom of the loop (do...while)
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `do...while` expression can be used to repeat an instruction until a certain
    requirement is not satisfied. For example, the following code snippet declares
    a numeric variable `i` and repeats an operation (increase the value of `i` by
    `one` and display its value in the browser console) for as long as the requirement
    (the value of `i` is less than `five`) is satisfied:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unlike the `while` loop, the `do...while` expression will execute at least once,
    regardless of the tested expression, as the operation will take place before checking
    whether a certain requirement is satisfied or not.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Iterate on each object's properties (for...in)
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for...in` statement by itself is not a *bad practice*; however, it can
    be misused, for example, to iterate over arrays or array-like objects. The purpose
    of the `for...in` statement is to enumerate over object properties:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The following code snippet will go up in the prototype chain, also enumerating
    the inherited properties. The `for...in` statement iterates the entire prototype
    chain, also enumerating the inherited properties. When you want to enumerate only
    the object's properties that aren't inherited, you can use the `hasOwnProperty`
    method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Iterate values in an iterable (for...of)
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, some built-in types are built-in iterables with a default iteration
    behavior. To be an iterable, an object must implement the `@@iterator` method,
    meaning that the object (or one of the objects in its prototype chain) must have
    a property with a `@@iterator` key, which is available via constant `Symbol.iterator`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for...of` statement creates a loop iterating over iterable objects (including
    array, map, set, string, arguments object, and so on):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will learn more about iterables in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,
    Object-Oriented Programming with TypeScript*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Counter-controlled repetition (for)
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` statement creates a loop that consists of three optional expressions,
    enclosed in parentheses and separated by semicolons, followed by a statement or
    a set of statements executed in the loop:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code snippet contains a `for` statement. It starts by declaring
    the variable `i` and initializing it to `0`. It checks whether `i` is less than
    `9`, performs the two succeeding statements, and increments `i` by one after each
    pass through the loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as in JavaScript, TypeScript functions can be created either as a named
    function or as an anonymous function, which allows us to choose the most appropriate
    approach for an application, whether we are building a list of functions in an
    API or a one-off function to hand over to another function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see in the preceding code snippet, in TypeScript, we can add types
    to each of the parameters and then to the function itself to add a return type.
    TypeScript can infer the return type by looking at the `return` statements, so
    we can also optionally leave this off in many cases.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternative syntax for functions that use the `=>` operator after
    the return type and don''t use the `function` keyword:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have learned about this alternative syntax, we can return to the
    previous example, in which we were assigning an anonymous function to the `greet`
    variable. We can now add the type annotations to the `greet` variable to match
    the anonymous function signature:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Keep in mind that the arrow function (`=>`) syntax changes the way the `this`
    keyword works when working with classes. We will learn more about this in the
    upcoming chapters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know how to add type annotations to force a variable to be a function
    with a specific signature. The usage of this kind of annotation is really common
    when we use a callback (functions used as an argument of another function):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, we are declaring a function named `add` that takes
    two numbers and a `callback` as a function. The type annotations will force the
    callback to return `void` and take a number as its only argument.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on functions in [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml)*,*
    *Working with Functions*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMAScript 6, the next version of JavaScript, adds class-based object-orientation
    to JavaScript and, since TypeScript includes all the features available in ES6,
    developers are allowed to use class-based object orientation today, and compile
    them down to JavaScript that works across all major browsers and platforms, without
    having to wait for the next version of JavaScript.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple TypeScript class definition example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding example, we have declared a new class, `Character`. This class
    has three members: a property called `fullname`, a `constructor`, and a method
    `greet`. When we declare a class in TypeScript, all the methods and properties
    are public by default. We have used the `public` keyword to be more explicit;
    being explicit about the accessibility of the class members is recommended but
    it is not a requirement.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that when we refer to one of the members of the class (from within
    itself), we prepend the `this` operator. The `this` operator denotes that it's
    a member access. In the last lines, we construct an instance of the `Character`
    class using a `new` operator. This calls into the constructor we defined earlier,
    creating a new object with the `Character` shape and running the constructor to
    initialize it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript classes are compiled into JavaScript functions in order to achieve
    compatibility with ECMAScript 3 and ECMAScript 5.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about classes and other object-oriented programming concepts
    in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,* *Object-Oriented
    Programming with TypeScript*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, we can use interfaces to ensure that a class follows a particular
    specification:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, we have defined an interface `LoggerInterface` and
    a class `Logger`, which implements it. TypeScript will also allow you to use interfaces
    to declare the type of an object. This can help us to prevent many potential issues,
    especially when working with object literals:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will learn more about interfaces and other object-oriented programming concepts
    in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,* *Object-Oriented
    Programming with TypeScript*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Namespaces, also known as **internal modules**, are used to encapsulate features
    and objects that share a certain relationship. Namespaces will help you to organize
    your code. To declare a namespace in TypeScript, you will use the `namespace`
    and `export` keywords:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In older versions of TypeScript, the keyword to define an internal module was
    `module` instead of `namespace`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code snippet, we have declared a namespace that contains the
    classes `vector2D` and `vector3D` and the interfaces `VectorInterface`, `Vector2DInterface`,
    and `Vector3DInterface`. Note that the first interface is missing the keyword
    `export`. As a result, the interface `VectorInterface` will not be accessible
    from outside the module's scope.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are a good way to organize your code; however, they are **not the
    recommended way to organize your code** in a TypeScript application. We will not
    get into more details about this topic for now, but we will learn more about internal
    and external modules and we'll discuss when each is appropriate and how to use
    them in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*, Object-Oriented
    Programming with TypeScript.*
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learned how to use the basic TypeScript building blocks individually,
    let''s take a look at a final example in which we will use modules, classes, functions,
    and type annotations for each of these elements:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding example is just a small portion of a basic 3D engine written in
    JavaScript. In 3D engines, there are a lot of mathematical calculations involving
    matrices and vectors. As you can see, we have defined a module `Geometry` that
    will contain some entities; to keep the example simple, we have only added the
    class `Vector2D`. This class stores two coordinates (`x` and `y`) in 2D space
    and performs some operations on the coordinates. One of the most widely used operations
    in vectors is normalization, which is one of the methods in our `Vector2D` class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 3D engines are complex software solutions, and as a developer, you are much
    more likely to use a third-party 3D engine than create your own. For this reason,
    it is important to understand that TypeScript will not only help you develop large-scale
    applications but also interact with complex libraries.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we will use the module declared earlier to create
    a `Vector2D` instance:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The type-checking and IntelliSense features will help us create a `Vector2D`
    instance, normalize its value, and convert it into an array to finally show its
    value on the screen with ease:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc7c2a1d-a52d-41e2-9d8a-fdfcafe3026c.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the purposes of TypeScript. You have
    also learned about some of the design decisions made by the TypeScript engineers
    at Microsoft.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of this chapter, you learned a lot about the basic building blocks
    of a TypeScript application, and we started to write some TypeScript code for
    the first time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We now know the basics of type annotations, variables, primitive data types,
    operators, flow control statements, functions, interfaces, classes, and namespaces.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了类型注解、变量、原始数据类型、运算符、流程控制语句、函数、接口、类和命名空间的基础知识。
- en: In the next chapter, we will learn more about the TypeScript type system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于 TypeScript 类型系统的内容。
