<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor111"/>9</h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>Extracting Logic Out of the Framework</h1>
<p>An important property of maintainable software is its <strong class="bold">testability</strong>. This is the idea that all parts of the application should be straightforward to test. More specifically, the design of the application code should make it easy to write automated unit tests.</p>
<p>In this chapter, we’ll look at one technique for improving testability: moving domain logic out of the framework and into plain JavaScript. Plain JavaScript code is simpler to test because there are no complex framework objects that interact with your code.</p>
<p>The following diagram shows how to think about a SvelteKit code base in this way.</p>
<div><div><img alt="Figure 9.1 – Keeping application code outside of framework components to aid testability" height="928" src="img/Figure_9.1_B19611.jpg" width="1000"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Keeping application code outside of framework components to aid testability</p>
<p>In <a href="B19611_07.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Tidying up Test Suites</em>, we took a step toward moving the storage of birthday data items into a <code>birthdayRepository</code> module. We’ll continue that process by pushing data validation out of the SvelteKit form action and into <code>birthdayRepository</code> That means we can test complex validation rules without having to set up the complex SvelteKit form request objects, and without having to test the form response objects either.</p>
<p>And since the repository has no asynchronous behavior, the moved tests no longer need to be littered with <code>async</code> and <code>await</code> keywords.</p>
<p>The following topics are covered in this chapter:</p>
<ul>
<li>Migrating tests with a test to-do list</li>
<li>Porting tests from the form action</li>
<li>Duplicating form validation behavior in the repository</li>
<li>Extracting common methods</li>
</ul>
<p>By the end of the chapter, you’ll have used a test-driven approach to move domain logic out of the framework.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter09/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter09/Start</a>.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Migrating tests with a test todo list</h1>
<p>The task at hand is <a id="_idIndexMarker295"/>moving the validation logic out of the SvelteKit form action we completed in <a href="B19611_05.xhtml#_idTextAnchor070"><em class="italic">Chapter 5</em></a>, <em class="italic">Validating Form Data</em>, and into the <code>birthdayRepository</code> module. And in this section, we’ll plan that task using a new technique.</p>
<p>You might remember that the <code>birthdayRepository</code> module already exists but has no tests. That’s a situation that we often find ourselves in when we extract modules during refactoring. And it’s often perfectly okay to leave these modules untested. The issue comes when we want to modify the behavior of these modules: where do we add the tests?</p>
<p>There’s no clear answer to that, but in this case, we’ll use the opportunity to duplicate all the tests from the form action in the <code>birthdayRepository</code> module, in addition to adding some new tests too.</p>
<p class="callout-heading">Deleting tests in the original location</p>
<p class="callout">We won’t delete the original tests, but that is something you should consider doing so that you’re not at risk of over-testing. (The only thing worse than over-testing is under-testing!)</p>
<p>There’s a special modifier of the <code>it</code> test function that can be used for planning a test suite: the <code>it.todo</code> modifier. As a form of up-front planning, it’s useful when you already have a concrete idea of the tests you’ll need in a test suite.</p>
<p>The <code>birthdayRepository</code> module has two exported functions that we’re interested in <a id="_idIndexMarker296"/>testing: the <code>addNew</code> and <code>replace</code> functions. We will split the existing form action tests between the two new functions. The tests for validation errors will need to be duplicated for both functions. In this way, each function will be fully specified.</p>
<p>Go ahead and create the <code>src/lib/server/birthdayRepository.test.js</code> file with the following content. This gets all the imports in place and primes the <code>birthdayRepository</code> test suite with a call to <code>clear</code> so that each test starts from a blank slate.</p>
<p>There’s also a definition of <code>storedId</code> – we can use the same technique for verifying data that we used in the form action tests. And we also add an empty test for checking the initial state:</p>
<pre class="source-code">
import { describe, it, expect, beforeEach } from 'vitest';
import {
  createBirthday
} from 'src/factories/birthday.js';
import {
  addNew, clear, getAll, replace
} from './birthdayRepository.js';
describe('birthdayRepository', () =&gt; {
  beforeEach(clear);
  const storedId = () =&gt; getAll()[0].id;
  it.todo('is initially empty');
});</pre>
<p>Now, add a nested <code>describe</code> block for the <code>addNew</code> function. This takes the original test <a id="_idIndexMarker297"/>descriptions from the <code>src/routes/birthdays/page.server.test.js</code> file and morphs them into a more appropriate form:</p>
<pre class="source-code">
describe('addNew', () =&gt; {
  it.todo('adds a new birthday into the list');
  it.todo('saves unique ids onto each new birthday');
  it.todo('returns the added birthday with its id');
  describe('validation errors', () =&gt; {
    describe.todo('when the name is not provided');
    describe.todo(
      'when the date of birth in the right format'
    );
  });
});</pre>
<p>It’s time to look at the tests for the <code>replace</code> function. You’ll see that the validation errors are repeated from the <code>addNew</code> context. That highlights a difference when splitting a single <code>entrypoint</code> (the form action) into two (the <code>addNew</code> and <code>replace</code> functions):</p>
<pre class="source-code">
describe('replace', () =&gt; {
  it.todo('updates an entry that shares the same id');
  it.todo('returns the updated birthday');
  describe('validation errors', () =&gt; {
    describe.todo('when the name is not provided');
    describe.todo(
      'when the date of birth in the right format'
    );
    it.todo(
      'returns the id when an empty date of birth is
       provided'
    );
  });
});</pre>
<p>The plan <a id="_idIndexMarker298"/>is complete. The remaining sections in this chapter will complete the test suite, starting with the <em class="italic">happy path</em> tests, which already pass, and then going back to complete the validation errors.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>Porting tests from the form action</h1>
<p>In this section, we’ll write <a id="_idIndexMarker299"/>out tests for the behavior that already <a id="_idIndexMarker300"/>exists in the <code>birthdayRepository</code> module, together with ensuring that the functions return values for the form action to reuse.</p>
<p>The <code>src/lib/server/birthdayRepository.js</code> file already contains the working code that you last touched on in <a href="B19611_06.xhtml#_idTextAnchor079"><em class="italic">Chapter 6</em></a>, <em class="italic">Editing Form Data</em>. Here’s a reminder:</p>
<pre class="source-code">
import { randomUUID } from 'crypto';
const db = new Map();
export const addNew = (item) =&gt; {
  const id = randomUUID();
  db.set(id, { ...item, id });
};
export const getAll = () =&gt; Array.from(db.values());
export const clear = () =&gt; db.clear();
export const replace = (id, item) =&gt;
  db.set(id, { ...item, id });
export const has = (id) =&gt; db.has(id);</pre>
<p>Most of this <a id="_idIndexMarker301"/>functionality is tested by way of the form action. We need to <a id="_idIndexMarker302"/>add tests and then double-check that they work.</p>
<p class="callout-heading">Always requiring a failing test</p>
<p class="callout">When porting tests, you’ll be writing tests that already pass. You skip the <em class="italic">Red</em> step and pass directly to <em class="italic">Green</em>. However, it’s still important to verify that your tests check the correct thing, and the way to do that is to delete or comment out the application code under test so that you can see the test fail.</p>
<p>Let’s start on that now:</p>
<ol>
<li>In <code>src/lib/server/birthdayRepository.test.js</code>, remove the <code>.todo</code> modifier from the first test, and add the following test content:<pre class="source-code">
it('is initially empty', () =&gt; {
  expect(getAll()).toHaveLength(0);
});</pre></li>
<li>You’ll see that the test already passed. Verify that it tests the right thing by replacing the <code>getAll</code> implementation with a <code>null</code> return value, and then re-run the test to check that it’s red. An easy way to do this is to comment out the rest of the line, like this:<pre class="source-code">
export const getAll = () =&gt;
  <strong class="bold">null; //</strong>Array.from(db.values());</pre></li>
<li>After checking that the test fails, bring the original implementation back and verify that it’s green.</li>
<li>Fill out the body <a id="_idIndexMarker303"/>of the next test, as shown in the following code. This is <a id="_idIndexMarker304"/>now a simpler test than the form action test we’re porting, for a couple of reasons. First, there’s no longer any asynchronous behavior, and second, we use a single factory method of <code>createBirthday</code> and avoid the more complex <code>performFormAction</code> helper method:<pre class="source-code">
describe('addNew', () =&gt; {
  it('adds a new birthday into the list', () =&gt; {
    addNew(createBirthday('Zeus', '2009-02-02'));
    expect(getAll()).toContainEqual(
      expect.objectContaining({
        name: 'Zeus',
        dob: '2009-02-02'
      })
    );
  });
});</pre></li>
<li>Although this will already pass, it’s important to check that it’s red. You can do that by using the same technique of commenting out the relevant line of code, like this:<pre class="source-code">
export const addNew = (item) =&gt; {
  const id = randomUUID();
  <strong class="bold">//</strong>db.set(id, { ...item, id });
};</pre></li>
<li>After verifying <a id="_idIndexMarker305"/>that the test fails, undo the commented code <a id="_idIndexMarker306"/>and get the test back to green.</li>
<li>Next, fill out the third test:<pre class="source-code">
it('saves unique ids onto each new birthday', () =&gt; {
  const birthday = createBirthday(
    'Zeus',
    '2009-02-02'
  );
  addNew(birthday);
  addNew(birthday);
  expect(getAll()[0].id).not.toEqual(
    getAll()[1].id
  );
});</pre></li>
<li>To verify that, you can comment out the <code>id</code> value:<pre class="source-code">
export const addNew = (item) =&gt; {
  const id = <strong class="bold">null; //</strong>randomUUID();
  db.set(id, { ...item, id });
};</pre></li>
<li>Now, we come on to the test for new behavior, checking that the object is returned <a id="_idIndexMarker307"/>together with its new <code>id</code> property. This uses the <code>storedId</code> function <a id="_idIndexMarker308"/>defined at the top of the test suite:<pre class="source-code">
it('returns the added birthday with its id', () =&gt; {
  expect(
    addNew(createBirthday('Zeus', '2009-02-02'))
  ).toEqual({
    id: storedId(),
    name: 'Zeus',
    dob: '2009-02-02'
  });
});</pre></li>
<li>To make that pass, introduce a variable named <code>itemWithId</code> and return it:<pre class="source-code">
export const addNew = (item) =&gt; {
  ...
  <strong class="bold">const itemWithId = { ...item, id };</strong>
  <strong class="bold">db.set(id, itemWithId);</strong>
  <strong class="bold">return itemWithId;</strong>
};</pre></li>
<li>Now, let’s move on to the <code>replace</code> tests. We’ll start with the migration of the <code>beforeEach</code> block and the <code>storedId</code> method:<pre class="source-code">
describe('replace', () =&gt; {
  beforeEach(() =&gt;
    addNew(createBirthday('Hercules', '1991-05-06'))
  );
  const storedId = () =&gt; getAll()[0].id;
  ...
});</pre></li>
<li>Then, we’ll move <a id="_idIndexMarker309"/>on to the first test for the <code>replace</code> function. You <a id="_idIndexMarker310"/>can verify that in the same way you verified the first test for <code>getAll</code>, by giving it a <code>null</code> implementation:<pre class="source-code">
it('updates an entry that shares the same id', () =&gt; {
  replace(
    storedId(),
    createBirthday('Zeus Ex', '2007-02-02')
  );
  expect(getAll()).toHaveLength(1);
  expect(getAll()).toContainEqual({
    id: storedId(),
    name: 'Zeus Ex',
    dob: '2007-02-02'
  });
});</pre></li>
<li>The final test in this section ensures that we returned the updated item:<pre class="source-code">
it('returns the updated birthday', () =&gt; {
  expect(
    replace(
      storedId(),
      createBirthday('Zeus Ex', '2007-02-02')
    )
  ).toEqual({
    id: storedId(),
    name: 'Zeus Ex',
    dob: '2007-02-02'
  });
});</pre></li>
<li>To make that <a id="_idIndexMarker311"/>pass, make exactly the same change that you <a id="_idIndexMarker312"/>made in the <code>addNew</code> function:<pre class="source-code">
export const replace = (id, item) =&gt; {
  ...
  <strong class="bold">const itemWithId = { ...item, id };</strong>
  <strong class="bold">db.set(id, itemWithId);</strong>
  <strong class="bold">return itemWithId;</strong>
};</pre></li>
</ol>
<p>That’s all the tests that prove the existing behavior. In the next section, we’ll need to port across the implementation in addition to the test cases.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>Duplicating form validation behavior in the repository</h1>
<p>In this <a id="_idIndexMarker313"/>section, we’ll continue porting <a id="_idIndexMarker314"/>across tests from the <code>src/routes/birthdays/page.server.test.js</code> file, but now we’re going to duplicate the validation behavior within the form action itself.</p>
<p class="callout-heading">Repetition as a design signal</p>
<p class="callout">The following steps contain a fair amount of repetition. First, the tests are very similar to tests you’ve already written in the form action. Second, the same checks are repeated for both the <code>addNew</code> and <code>replace</code> functions.</p>
<p class="callout">This kind of <em class="italic">forced repetition</em> (where you feel the pain of repeated work) can help you to figure out what (if any) shared logic you’d like to pull out.</p>
<p>Let’s begin:</p>
<ol>
<li>Start by filling in the <code>validation errors</code> nested <code>describe</code> block and the tests within it. I’m electing to copy two tests at once because these tests are very simple, and we already have a good idea of where we’re going to end up with the implementation:<pre class="source-code">
describe('addNew', () =&gt; {
  ...
    describe('validation errors', () =&gt; {
      describe('when the name is not provided', () =&gt; {
        let result;
        beforeEach(() =&gt; {
          result = addNew(
            createBirthday('', '1991-05-06')
          );
        });
        it('does not save the birthday', () =&gt; {
          expect(getAll()).toHaveLength(0);
        });
        it('returns an error', () =&gt; {
          expect(result).toEqual({
            error: 'Please provide a name.'
          });
        });
      });
    });
  });
});</pre></li>
<li>To make <a id="_idIndexMarker315"/>that pass in <code>src/lib/server/birthdayRepository.js</code>, start by defining the <code>empty</code> function <a id="_idIndexMarker316"/>at the bottom of the file:<pre class="source-code">
const empty = (value) =&gt;
  value === undefined ||
  value === null ||
  value.trim() === '';</pre></li>
<li>Then, update the <code>addNew</code> method to include a guard class that uses the <code>empty</code> function. After this change, both tests should pass:<pre class="source-code">
export const addNew = (item) =&gt; {
  <strong class="bold">if (empty(item.name)) {</strong>
    <strong class="bold">return { error: 'Please provide a name.' };</strong>
  <strong class="bold">}</strong>
  ...
};</pre></li>
<li>Now, we’ll <a id="_idIndexMarker317"/>move on to the next <a id="_idIndexMarker318"/>nested <code>describe</code> block, for checking the date of birth format:<pre class="source-code">
describe('when the date of birth is in the wrong format', () =&gt; {
  let result;
  beforeEach(() =&gt; {
    result = addNew(
      createBirthday('Hercules', 'unknown')
    );
  });
  it('does not save the birthday', () =&gt; {
    expect(getAll()).toHaveLength(0);
  });
  it('returns an error', () =&gt; {
    expect(result).toEqual({
      error:
        'Please provide a date of birth in the YYYY-
          MM-DD format.'
    });
  });
});</pre></li>
<li>To make <a id="_idIndexMarker319"/>that pass, start <a id="_idIndexMarker320"/>by duplicating the <code>invalidDob</code> helper from the form action:<pre class="source-code">
const invalidDob = (dob) =&gt; isNaN(Date.parse(dob));</pre></li>
<li>Then, add the guard clause, which should cause both tests to pass:<pre class="source-code">
if (invalidDob(item.dob)) {
  return {
    error:
      'Please provide a date of birth in the YYYY-MM-
        DD format.'
  };
}</pre></li>
<li>Now, let’s repeat the validation checks for the <code>replace</code> function. In the original form action tests, this wasn’t necessary because we implemented the <em class="italic">edit form</em> functionality by building on the top of the original action for creating birthdays, so the validations were already there. But now, both operations are separated. Fill out the new nested <code>describe</code> block:<pre class="source-code">
describe('replace', () =&gt; {
  ...
  describe('validation errors', () =&gt; {
    describe('when the name is not provided', () =&gt; {
      let result;
      beforeEach(() =&gt; {
        result = replace(
          storedId(),
          createBirthday('', '1991-05-06')
        );
      });
      it('does not update the birthday', () =&gt; {
        expect(getAll()[0].name).toEqual(
          'Hercules'
        );
      });
      it('returns an error', () =&gt; {
        expect(result).toEqual({
          error: 'Please provide a name.'
        });
      });
    });
  });
});</pre></li>
<li>To make <a id="_idIndexMarker321"/>that pass, start by <a id="_idIndexMarker322"/>duplicating the same guard clause from <code>addNew</code>. We’ll remove this duplication later:<pre class="source-code">
export const replace = (id, item) =&gt; {
  <strong class="bold">if (empty(item.name)) {</strong>
    <strong class="bold">return { error: 'Please provide a name.' };</strong>
  <strong class="bold">}</strong>
  ...
};</pre></li>
<li>Now, move on to the date of birth:<pre class="source-code">
describe('when the date of birth is in the wrong format', () =&gt; {
  let result;
  beforeEach(() =&gt; {
    result = replace(
      storedId(),
      createBirthday('Hercules', 'unknown')
    );
  });
  it('does not update the birthday', () =&gt; {
    expect(getAll()[0].dob).toEqual(
      '1991-05-06'
    );
  });
  it('returns an error', () =&gt; {
    expect(result).toEqual({
      error:
        'Please provide a date of birth in the YYYY-
          MM-DD format.'
    });
  });
});</pre></li>
<li>Make that <a id="_idIndexMarker323"/>pass by adding in the <a id="_idIndexMarker324"/>second guard clause, by repeating <em class="italic">step 6</em> but, this time, adding code within the <code>replace</code> function:<pre class="source-code">
if (invalidDob(item.dob)) {
  return {
    error:
      'Please provide a date of birth in the YYYY-MM-
        DD format.'
  };
}</pre></li>
<li>Then onto the final test. This one doesn’t need a <code>describe</code> block since it’s only one test:<pre class="source-code">
it('requires an id of a birthday that exists in the store', () =&gt; {
  expect(
    replace(
      '234',
      createBirthday('Hercules', '2009-01-02')
    )
  ).toEqual({
    error: 'An unknown ID was provided.'
  });
});</pre></li>
<li>This time, put the guard clause right at the top. It seems to make sense that this guard should <a id="_idIndexMarker325"/>take precedence over <a id="_idIndexMarker326"/>the name and date of birth checks – notice, for example, how the argument comes first in the argument list:<pre class="source-code">
export const replace = (id, item) =&gt; {
  <strong class="bold">if (!has(id))</strong>
    <strong class="bold">return { error: 'An unknown ID was provided.' };</strong>
  ...
}</pre></li>
</ol>
<p>That completes all the new functionality. All the <code>birthdayRepository</code> behavior is complete. Next, we’ll stop to refactor to remove duplication.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Extracting common methods</h1>
<p>In this section, we’ll <a id="_idIndexMarker327"/>pull out the validation clauses that are duplicated in the <code>addNew</code> and <code>replace</code> functions, moving them into a shared <code>validate</code> function.</p>
<p>Let’s start now with the <code>validate</code> function:</p>
<ol>
<li>Below the definitions of <code>addNew</code> and <code>replace</code>, add the following function named <code>validate</code>. This contains the two guard clauses that appeared in each of the original functions. As a simplification, the <code>item</code> argument has been destructured into <code>name</code> and <code>dob</code> arguments:<pre class="source-code">
const validate = ({ name, dob }) =&gt; {
  if (empty(name)) {
    return { error: 'Please provide a name.' };
  }
  if (invalidDob(dob)) {
    return {
      error:
        'Please provide a date of birth in the YYYY-
          MM-DD format.'
    };
  }
};</pre></li>
<li>Then, <a id="_idIndexMarker328"/>update <code>addNew</code> to replace its guard clauses with a call to <code>validate</code>. The result is stored in <code>validationResult</code>, which can then be returned if it has a value:<pre class="source-code">
export const addNew = (item) =&gt; {
  <strong class="bold">const validationResult = validate(item);</strong>
  <strong class="bold">if (validationResult) {</strong>
    <strong class="bold">return validationResult;</strong>
  <strong class="bold">}</strong>
  const id = randomUUID();
  const itemWithId = { ...item, id };
  db.set(id, itemWithId);
  return itemWithId;
};</pre></li>
<li>Next, do the same for the <code>replace</code> function:<pre class="source-code">
export const replace = (id, item) =&gt; {
  if (!has(id))
    return { error: 'An unknown ID was provided.' };
  <strong class="bold">const validationResult = validate(item);</strong>
  <strong class="bold">if (validationResult) {</strong>
    <strong class="bold">return validationResult;</strong>
  <strong class="bold">}</strong>
  const itemWithId = { ...item, id };
  db.set(id, itemWithId);
  return itemWithId;
};</pre></li>
<li>Now, how <a id="_idIndexMarker329"/>about we pull out the last bit of each function? Add the <code>set</code> function:<pre class="source-code">
const set = (id, item) =&gt; {
  const itemWithId = { ...item, id };
  db.set(id, itemWithId);
  return itemWithId;
};</pre></li>
<li>Then, use that in <code>addNew</code>:<pre class="source-code">
export const addNew = (item) =&gt; {
  const validationResult = validate(item);
  if (validationResult) {
    return validationResult;
  }
  <strong class="bold">return set(randomUUID(), item);</strong>
};</pre></li>
<li>And finally, add <a id="_idIndexMarker330"/>the same call at the end of the <code>replace</code> function:<pre class="source-code">
export const replace = (id, item) =&gt; {
  if (!has(id))
    return { error: 'An unknown ID was provided.' };
  const validationResult = validate(item);
  if (validationResult) {
    return validationResult;
  }
  <strong class="bold">return set(id, item);</strong>
};</pre></li>
</ol>
<p>That completes the <code>birthdayRepository</code> implementation – a straightforward but satisfying refactoring.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Summary</h1>
<p>This chapter has covered techniques for porting existing behavior from one place to another. In particular, it’s shown how worthwhile it can be to move business logic out of framework objects – such as form actions – and into plain JavaScript objects. Doing so makes the tests simpler.</p>
<p>In this case, our tests were no longer asynchronous, and no longer needed to use the complex <code>performFormAction</code> helper.</p>
<p>Another benefit is that <code>birthdayRepository</code>, along with its validation, can be reused in other places. That’s exactly what we’ll do in the next chapter, when we introduce new API endpoints that interact with the repository.</p>
</div>
</div></body></html>