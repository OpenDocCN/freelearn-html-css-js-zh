["```js\n// The React components we need...\nimport React from 'react';\nimport { render } from 'react-dom';\n\n// The stores and views from our \"feature packages\".\nimport { Users, ListUsers } from 'my-users';\nimport { Groups, ListGroups } from 'my-groups';\n\n// The components that are core to the application...\nimport dispatcher from './dispatcher';\nimport AppData from './stores/app';\nimport App from './views/app';\nimport { init } from './actions/init';\n\n// Constructs the Flux stores, passing in the\n// dispatcher as an argument. This is how we're\n// able to get third-party Flux components to\n// talk to our application and vice-versa.\nconst app = new AppData(dispatcher);\nconst users = new Users(dispatcher);\nconst groups = new Groups(dispatcher);\n\n// Re-render the application when the store\n// changes state.\napp.on('change', renderApp);\nusers.on('change', renderApp);\ngroups.on('change', renderApp);\n\n// Renders the \"App\" React component, and it's\n// child components. The dispatcher is passed\n// to the \"ListUsers\" and the \"ListGroups\"\n// components since they come from different\n// packages.\nfunction renderApp() {\n  render(\n    <App {...app.state}>\n      <ListUsers\n        dispatcher={dispatcher}\n        {...users.state}\n      />\n      <ListGroups\n        dispatcher={dispatcher}\n        {...groups.state}\n      />\n    </App>,\n    document.getElementById('app')\n  );\n}\n\n// Dispatches the \"INIT\" action, so that the\n// \"App\" store will populate it's state.\ninit();\n```", "```js\nimport { EventEmitter } from 'events';\nimport { INIT } from '../actions/init';\n\n// The initial state of the \"App\" store has\n// some header text and a collection of\n// navigation links.\nconst initialState = {\n  header: [ 'Home' ],\n  links: [\n    { title: 'Users', action: 'LOAD_USERS' },\n    { title: 'Groups', action: 'LOAD_GROUPS' }\n  ]\n};\n\n// The actual state is empty by default, meaning\n// that nothing gets rendered.\nvar state = {\n  header: [],\n  links:[]\n};\n\nexport default class App extends EventEmitter{\n  constructor(dispatcher) {\n    super();\n\n    this.id = dispatcher.register((action) => {\n      switch(action.type) {\n\n        // When the \"INIT\" action is dispatched,\n        // we assign the initial state to the empty\n        // state, which triggers a re-render.\n        case INIT:\n          state = Object.assign({}, initialState);\n          break;\n\n        // By default, we empty out the store's state.\n        default:\n          state = Object.assign({}, state, {\n            header: [],\n            links: []\n          });\n          break;\n      }\n\n      // We always emit the change event.\n      this.emit('change', state);\n    });\n  }\n\n  get state() {\n    return Object.assign({}, state);\n  }\n}\n```", "```js\nimport React from 'react';\nimport dispatcher from '../dispatcher';\n\n// The \"onClick()\" click handler will dispatch\n// the given action. This argument is bound when\n// the link is rendered. Actions that are dispatched\n// from this function can be handled by other packages\n// that are sharing this same dispatcher.\nfunction onClick(type, e) {\n  e.preventDefault();\n  dispatcher.dispatch({ type });\n}\n\n// Renders the main navigation links, and\n// any child elements. Nothing is rendered\n// if the store state is empty.\nexport default ({ header, links, children }) => (\n  <div>\n    {header.map(title => <h1 key={title}>{title}</h1>)}\n    <ul>{\n      links.map(({ title, action }) =>\n        <li key={action}>\n          <a\n            href=\"#\"\n            onClick={onClick.bind(null, action)}>{title}\n          </a>\n        </li>\n      )\n    }</ul>\n    {children}\n  </div>\n);\n```", "```js\nimport { EventEmitter } from 'events';\nimport { LOAD_USERS } from '../actions/load-users';\nimport { LOAD_USER } from '../actions/load-user';\n\n// The initial state of the store has some header\n// text and a collection of user objects.\nconst initialState = {\n  header: [ 'Users' ],\n  users: [\n    { id: 1, name: 'First User' },\n    { id: 2, name: 'Second User' },\n    { id: 3, name: 'Third User' }\n  ]\n};\n\n// The state of the store that gets rendered by\n// views. Initially this is empty so nothing is\n// rendered by the view.\nvar state = {\n  header: [],\n  users: []\n};\n\nexport default class Users extends EventEmitter{\n  constructor(dispatcher) {\n    super();\n\n    this.id = dispatcher.register((action) => {\n      switch(action.type) {\n\n        // When the \"LOAD_USERS\" action is dispatched,\n        // we populate the store state using the initial\n        // state object. This causes the view to render.\n        case LOAD_USERS:\n          state = Object.assign({}, initialState);\n          break;\n\n        // When the \"LOAD_USER\" action is dispatched,\n        // we update the header text by finding the user\n        // that corresponds to the \"payload\" id, and using\n        // it's \"name\" property.\n        case LOAD_USER:\n          state = Object.assign({}, state, {\n            header: [ state.users.find(\n              x => x.id === action.payload).name ]\n          });\n          break;\n\n        // By default, we want to empty the store state.\n        default:\n          state = Object.assign({}, state, {\n            header: [],\n            users: []\n          });\n          break;\n      }\n\n      // Always emit the change event.\n      this.emit('change', state);\n    });\n  }\n\n  get state() {\n    return Object.assign({}, state);\n  }\n}\n```", "```js\nimport React from 'react';\nimport { LOAD_USER } from '../actions/load-user';\n\n// The \"click\" event handler for items in the users\n// list. The dispatcher is passed in as an argument\n// because this Flux package doesn't have a dispatcher,\n// it relies on the one from the application.\n//\n// The \"id\" of the user that was clicked is also passed\n// in as an argument. Then the \"LOAD_USER\" action\n// is dispatched.\nfunction onClick(dispatcher, id, e) {\n  e.preventDefault();\n\n  dispatcher.dispatch({\n    type: LOAD_USER,\n    payload: id\n  });\n}\n\n// Renders the component using data from the store\n// state that was passed in as props.\nexport default ({ header, users, dispatcher }) => (\n  <div>\n    {header.map(h => <h1 key={h}>{h}</h1>)}\n    <ul>{users.map(({ id, name }) =>\n      <li key={id}>\n        <a\n          href=\"#\"\n          onClick={\n            onClick.bind(null, dispatcher, id)\n          }>{name}\n        </a>\n      </li>\n    )}</ul>\n  </div>\n)\n```"]