<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Managing Views</h1></div></div></div><p>As we learned in <a class="link" href="ch03.html" title="Chapter 3. Marionette View Types and Their Use">Chapter 3</a>, <em>Marionette View Types and Their Use</em>, <code class="literal">Marionette.js</code> views<a id="id91" class="indexterm"/> provide us with a lot of functionality to render data with the benefit of having to write very little code in exchange. In this chapter, we are going to discover what a <code class="literal">Region</code> in Marionette is and what <code class="literal">RegionManager</code> and <code class="literal">BabySitter</code> objects are. All of them are intended to help us manage views in an easier way.</p><p>We will also get to know a handy object while rendering templates in your application: the <code class="literal">Renderer</code> object. After that, we will have a short summary of what we have learned through the first four chapters.</p><p>We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.Region</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.RegionManager</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.BabySitter</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette.Renderer</code></li><li class="listitem" style="list-style-type: disc">Improving the application's performance with <code class="literal">Marionette.TemplateCache</code></li></ul></div><p>All of these are very helpful objects that will help us to manage our Marionette views with ease, keeping in mind performance and reuse.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec19"/>Understanding the Marionette.Region object</h1></div></div></div><p>While building an application, <a id="id92" class="indexterm"/>we need to separate the screen into small, logical pieces such as header, footer, navigation, and content area. These are common parts that are present in most applications. Usually your navigation options can change depending on the user. The header may also be different based on your user profile, and of course, your content area is going to be busy showing different views—views that need to be rendered to perform an action and closed in order to show a new view with perhaps some results or the next logical steps in your application. That's why we should think of the footer or content parts of your application as regions within your application, where we will be swapping different views.</p><p>The following code exemplifies one of <a id="id93" class="indexterm"/>the ways to create a <code class="literal">Marionette.Region</code> object:</p><div><pre class="programlisting">var FooterRegion = new Backbone.Marionette.Region({
  el: "#footer"
});</pre></div><p>To define a region, we just need to specify an element in DOM that will serve as a container of the views on your logical section of the application. In this case, the <code class="literal">#footer</code> is a DIV element, but it can be any HTML element as long as appending a view inside of it generates a valid HTML.</p><p>The idea behind a region is to use it as a container of views in your application one at a time. It will be in charge of calling the <code class="literal">render</code> function of the specified view when we call the method <code class="literal">.show</code> of the region. It will call the close method of the current view and remove it from the DOM when we call the method <code class="literal">.close</code> of the region.</p><p>The following is the code needed to use a region in order to render a view:</p><div><pre class="programlisting">// definition of a view to be shown in the region
var footerView = new FooterView();

//the Region will show the footerview in its DOM element
//in this case it will render the footer view inside the #footer element in the DOM
FooterRegion.show(footerView);
// the footerView is now rendered

//Finally we can call close on the region and the footer view will be removed from the #footer element
FooterRegion.close();</pre></div><p>As we can see in the preceding code snippet, the <code class="literal">show</code> method of the region will take the instance of the view to be rendered as a parameter.</p><p>Rendering the views and then swapping them for new ones seems trivial at the beginning. We can just call <code class="literal">close</code> and <code class="literal">render</code>, right? Then why do we need a region object to do it for us? This is because the region does these things for us and much more, without us having to worry about which view is the current view displayed inside of it. Think of it in this way: you have the content region and you will display a view inside of it. We can replace this view with a new one just by calling the <code class="literal">.show</code> method and the region will take care of the removal of the first view. So we don't have to call its <code class="literal">close</code> method, as this is part of the functionality of the <code class="literal">show</code> method of the region. This means that if there is a view already being displayed in the region, the <code class="literal">close</code> method of the exiting view will be called by calling <code class="literal">show</code> and passing a new view, thereby ensuring there is proper removal of its <code class="literal">.el</code> event bindings.</p><p>Let's use a <a id="id94" class="indexterm"/>wizard as an example. We have four steps and on each step, we show a view where we will fill some data. On each one of these views, we have links that will guide us to the next step or to the previous step in case we want to modify the data. The links will modify the URL, and it will be the router's responsibility to call the proper step.</p><p>For this example, the code that is inside the controller is given as follows:</p><div><pre class="programlisting">// each view step syncs with the server at the time to initialize and close in order to preserve the data
stepOne : function () {
  var stepOneView = new StepOneView();
  content.region.show(stepOneView);
},
stepTwo : function () {
  var stepTwoView = new StepTwoView();
  content.region.show(stepTwoView);
}
stepThree : function () {
  ar stepThreeView = new StepThreeView();
  content.region.show(stepThreeView);
}
finalStep : function () {
  var finalStepView = new FinalStepView();
  content.region.show(finalStepView);
}</pre></div><p>From the preceding code, we can see the benefits of using a region to render views. If the user clicks on the second step and decides to go back, we don't need to check whether the instance of the <code class="literal">stepTwoView</code> method is in memory and close it in order to render the <code class="literal">stepOneView</code> method, as this will be handled by the region.</p><p>There will be occasions where it will be impossible to track which view is present in a region, and in most of those cases, we don't care. We just need to render a new view on this area without having to worry about whether the previous view is being removed in a proper way.</p><p>Another way to declare a region is by attaching it directly to a Marionette application, as follows:</p><div><pre class="programlisting">BookStoreApp = new Backbone.Marionette.Application();
BookStoreApp.addRegions({
  contentRegion: "#mainContent",
});</pre></div><p>In this case, we used the <code class="literal">.addRegions</code> method of the application object that is expecting an object literal with the names of the regions and the DOM element to be used.</p><p>To use these new regions, we just need to call them by the name given in the object literal, which is used for this configuration as follows:</p><div><pre class="programlisting">BookStoreApp.contentRegion.show(stepOneView);</pre></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Marionette View Types and Their Use">Chapter 3</a>, <em>Marionette View Types and Their Use</em>, we defined a layout. The layout view of <a id="id95" class="indexterm"/>Marionette serves as a container of regions or as a container of containers. The layout will render a template with the skeleton of your HTML. Inside this skeleton, we will put the DIV element or elements that will serve as regions, and once this layout is rendered, we can use its region to display views.</p><p>So lets review the code as follows:</p><div><pre class="programlisting">CatalogLayout = Backbone.Marionette.Layout.extend({
  template: "#CatalogLayout",
  regions: {
    categoriesRegion : '#categories',
    productsRegion : '#products',
    orderRegion : '#order',
    bookRegion: '#book'
  }
});</pre></div><p>In the layout declaration, we defined a template and the regions object literal, giving names to the regions and matching those with the DOM elements.</p><p>For this <code class="literal">BookStoreApp</code>, we will create <code class="literal">mainRegion</code>. The responsibility of this region is to render the layout view of the application. The layout view will contain the initial HTML file and the logical regions of the application, regions that will show the proper views. The following code exemplifies the creation of the application object, the layout view, and the rendering of views inside the regions of the layout:</p><div><pre class="programlisting">BookStoreApp = new Backbone.Marionette.Application();
BookStoreApp.addRegions({
  mainRegion: "#mainContent",
});
CatalogLayout = Backbone.Marionette.Layout.extend({
  template: "#CatalogLayout",
  regions: {
    categoriesRegion : '#categories',
    productsRegion : '#products',
    orderRegion : '#order',
    bookRegion: '#book'
  }
});
var catalogLayput  = new CatalogLayout();
BookStoreApp.mainRegion.show(catalogLayput );

catalogLayput.categoriesRegion.show(new CategoriesView());
catalogLayput.productsRegion.show(new ProductsView());</pre></div><p>With the<a id="id96" class="indexterm"/> help of the layout and the regions, we can create a logical segmentation of the screen that will allow us to render views on each region. Using meaningful names for these regions will definitely help, as we just need to pass the right view to the region and stop worrying about the glue code needed for rendering and cleanup.</p><p>A region will raise the following two events while rendering a view that will help us to perform an extra manipulation to the DOM:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">"show"/onShow</code>: This event is called on the view instance when the view has been rendered and displayed</li><li class="listitem" style="list-style-type: disc"><code class="literal">"show"/onShow</code>: This event is called on the region instance when the view has been rendered and displayed</li></ul></div><p>Finally, while closing a view, the following method will be raised that can be used to perform one of the final tasks such as notifying the user with a friendly message:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">"close"/onClose</code>: This method is called when the view has been closed</li></ul></div><p>You can subscribe to these events as usual with the <code class="literal">.on</code> method declaration as follows:</p><div><pre class="programlisting">BookStoreApp.mainRegion.on("show", function(view){
  // extra functionality needed to be added once the view is rendered
});</pre></div><p>The following code exemplifies how to subscribe to the <code class="literal">close</code> method:</p><div><pre class="programlisting">BookStoreApp.mainRegion.on("close", function(view){
  // code to notify that the view as been removed
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec20"/>Using the Marionette.RegionManager object</h1></div></div></div><p>Using regions helps to <a id="id97" class="indexterm"/>manage views in a very elegant way. But that may not be enough for some applications, which can have dozens of regions that need to be added and removed during the lifetime of the application. To accomplish this management, we can take advantage of the <code class="literal">RegionManager</code> object of Marionette, which will serve as a container for regions.</p><p>Having your regions in this container can help us to accomplish almost the same actions, which we could accomplish with a <code class="literal">Backbone.Collection</code> object, with the help of underscore methods such as <code class="literal">each</code>, <code class="literal">map</code>, <code class="literal">invoke</code>, <code class="literal">contains</code>, and <code class="literal">toArray</code>.</p><p>The following syntax can help us to declare <code class="literal">Marionette.RegionManager</code>:</p><div><pre class="programlisting">var regionManager = new Marionette.RegionManager();</pre></div><p>The following syntax demonstrates how to add a region to <code class="literal">regionManager</code>. The <code class="literal">addRegion</code> method takes two parameters. The first one will be the ID or alias of the region, and the second one will be the DOM element to be used.</p><div><pre class="programlisting">regionManager.addRegion("math", "#math");</pre></div><p>If we want to add multiple regions, we need to use the <code class="literal">addRegions</code> method and pass an object literal to this method with names and IDs as parameters.</p><div><pre class="programlisting">regionManager.addRegions({
  art: "#art",
  music: "#music",
  science: "#science"
});</pre></div><p>We can make use of the <code class="literal">removeRegion</code> method to remove the region from <code class="literal">regionManager</code> and also to close the region, which will call <code class="literal">close</code> on the contained view, thereby removing this view from the application.</p><div><pre class="programlisting">regionManager.removeRegion("math");</pre></div><p>To remove all the regions, we can use the <code class="literal">removeRegions</code> method as shown in the following code:</p><div><pre class="programlisting">regionManager.removeRegions();</pre></div><p>We can continue adding more regions to this container. But let's now create a <code class="literal">RegionManager</code> object for a category that will contain regions for subcategories; each region will show a <code class="literal">CollectionView</code> object with books of the same subcategory. So we display a <code class="literal">CollectionView</code> object inside a region with the same name.</p><p>The idea is that the user wants to view books of his favorite category and also wants to add more subcategories to the screen to be rendered. For instance, in the History category, we can have an option to view books from modern history, Rome, universal history, World War II, and many more subcategories.</p><div><pre class="programlisting">var historyManager = new Marionette.RegionManager();
historyManager.addRegions({
  wwIIRegion: "#wwII",
  romeRegion: "#rome",
  modernRegion: "#modern",
  unitedStatesHistoryRegion : "#us"
});</pre></div><p>And then just render the proper view on each region as follows:</p><div><pre class="programlisting">historyManager.modernRegion.show(new BooksView({collection : modern}));
historyManager.wwIIRegion.show(new BooksView({collection :wwIIBooks}));</pre></div><p>If at some point, the<a id="id98" class="indexterm"/> user switches to another category and no longer wants to see the History category, calling <code class="literal">removeRegions</code> will cascade to the view level, thereby removing all the views in a safe way for us.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Using the Backbone.BabySitter object</h1></div></div></div><p>With the value that they<a id="id99" class="indexterm"/> provide, two objects made its way out of the Marionette library and can be used individually by including them in your scripts or using the blended version of Marionette. One is the <code class="literal">Backbone.Wreqr.EventAggregator</code> object and the other is the <code class="literal">Backbone.BabySitter</code> object, which is the one that we are about to discuss.</p><p>This object helps us to keep track of views and to manage them. These views can be contained within another view or another object that needs to keep track of these views.</p><p>The <code class="literal">BabySitter</code> object can be used to contain views instead of regions. The responsibility of <code class="literal">RegionManager</code> is to contain and perform actions on regions within your application. The <code class="literal">BabySitter</code> object has the same responsibility, but in this case, it helps us to manage related views.</p><p>The following code is an example of an instantiation of a BabySitter object:</p><div><pre class="programlisting">container = new Backbone.ChildViewContainer();</pre></div><p>You can start adding and removing views to this container as it is a regular <code class="literal">Backbone.Collection</code> object; you can do this by using the add and remove functions.</p><div><pre class="programlisting">container.add(someView);
container.add(anotherView);
container.remove(someView);</pre></div><p>The container offers a lot of useful methods such as length, which will return the number of views that the container is keeping track of.</p><div><pre class="programlisting">var numberofViews  =container.length</pre></div><p>As we have mentioned earlier, the container exposes several functions of the underscore collection functions, such as <code class="literal">each</code>, <code class="literal">map</code>, <code class="literal">find</code>, <code class="literal">select</code>, <code class="literal">filter</code>, <code class="literal">all</code>, <code class="literal">some</code>, and <code class="literal">toArray</code>.</p><p>To demonstrate that we can call a method of each one of the views inside the container, we just need to write the following code:</p><div><pre class="programlisting">container.each(function(view){
  view.changeColor();
});</pre></div><p>The responsibility of<a id="id100" class="indexterm"/> the preceding function is to iterate all the views in the container and call a function inside this view,in this case, the <code class="literal">changeColor</code> function of each view.</p><p>We have created a JSFiddle that demonstrates the use of the <code class="literal">BabySitter</code> object. You can find it at <a class="ulink" href="http://jsfiddle.net/rayweb_on/fxzAs/">http://jsfiddle.net/rayweb_on/fxzAs/</a>.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>
<a class="ulink" href="http://jsfiddle.net">jsfiddle.net</a> is a <a id="id101" class="indexterm"/>very useful website for sharing small snippets of code, facilitating collaboration between developers.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Taking advantage of the Marionette.Renderer object</h1></div></div></div><p>As we<a id="id102" class="indexterm"/> saw in <a class="link" href="ch03.html" title="Chapter 3. Marionette View Types and Their Use">Chapter 3</a>, <em>Marionette View Types and Their Use</em>, Marionette does the great job of removing the repetitive code needed in order to render views. But behind the scenes, what Marionette does is it delegates this task to the <code class="literal">Renderer</code> object. Its responsibility is to load and compile the template into the <code class="literal">.template</code> function and to pass the data to be used in order to properly render the model of the view. This means that every view object in Marionette uses the <code class="literal">Renderer</code> object. This object can also help to render HTML into DOM by just passing a template with the data to be used for this purpose.</p><p>Let's say that for some reason we need to append HTML into our view, but we don't want to call the render of the view that we are working with. In such a case, we can use the <code class="literal">Marionette.Renderer</code> object.</p><div><pre class="programlisting">callRenderer : function () {
  var template = "#sample-template2";
  var data = {foo: "I was appended with Marionette Renderer"};
  var html = Backbone.Marionette.Renderer.render(template, data);
  this.$el.append(html);
}</pre></div><p>In the <a id="id103" class="indexterm"/>preceding function, we declared a template that is in DOM, then we created an object literal with dummy data, and then we passed these two to the <code class="literal">Renderer</code> object, which returned an HTML, that we finally appended to the <code class="literal">$el</code> of our view.</p><p>To see this example working, you can go to the <a class="ulink" href="http://jsfiddle.net/rayweb_on/BeMfz/">http://jsfiddle.net/rayweb_on/BeMfz/</a> JSFiddle link.</p><p>But perhaps a better use could be to render DOM elements that will serve as containers for the regions.</p><p>If we need to render the subcategories, we need the DIVs <code class="literal">(&lt;div id="rome"&gt;&lt;div&gt;</code>) to be available in order to attach the regions and then call <code class="literal">show</code> to render the views inside these containers (DIV elements).</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Improving the performance of the application with TemplateCache</h1></div></div></div><p>In every application, <a id="id104" class="indexterm"/>performance<a id="id105" class="indexterm"/> matters. That's why having our templates available in the cache will definitely improve the speed of the rendering process in future calls.</p><p>Marionette has an object called <code class="literal">TemplateCache</code> that is used by the <code class="literal">Renderer</code> object. This means that all of our templates are stored in this <code class="literal">TemplateCache</code> object and to start making use of it, we just need to call the <code class="literal">get</code> method. Internally, this method will confirm whether it already has the template and then return it; alternatively, it will load the template from DOM and will return the template so that we can use it, but it will also keep a reference of it. Hence in the subsequent call, we will get the cached version of our template by using the following code:</p><div><pre class="programlisting">var template = Backbone.Marionette.TemplateCache.get("#my-template");</pre></div><p>To remove one or more templates from our cache, we need to call the <code class="literal">clear</code> function as follows:</p><div><pre class="programlisting">Backbone.Marionette.TemplateCache.clear("#my-template")</pre></div><p>If we need to delete more than one template, we can pass a list of templates to be deleted or simply call the <code class="literal">clear()</code> function without parameters to delete all the cached templates as follows:</p><div><pre class="programlisting">Backbone.Marionette.TemplateCache.clear("#my-template", "#this0-template")</pre></div><p>Alternatively, we can use the following code to do this:</p><div><pre class="programlisting">Backbone.Marionette.TemplateCache.clear()</pre></div><p>By default, the<a id="id106" class="indexterm"/> Marionette <code class="literal">TemplateCache</code> works<a id="id107" class="indexterm"/> with underscore templates, but to override this, we need to provide our own definition of the <code class="literal">compileTemplate</code> function.</p><p>To be consistent, we will override this function to return handlebars templates.</p><div><pre class="programlisting">Backbone.Marionette.TemplateCache.prototype.compileTemplate = function(rawTemplate) {
  return Handlebars.compile(rawTemplate);
}</pre></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Handlebars<a id="id108" class="indexterm"/> is a very popular template engine and is commonly used as an alternative to underscore templates. You can find out more about it on its<a id="id109" class="indexterm"/> website, <a class="ulink" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>.</p></div></div><p>As we saw, making use of <code class="literal">TemplateCache</code> is very easy and the benefits that it provides are definitely its biggest selling point.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Summary</h1></div></div></div><p>In this chapter, we learned about different objects that Marionette provides to manage views, such as the <code class="literal">Region</code> and <code class="literal">BabySitter</code> objects. This management is definitely needed, but it takes a lot of glue code to achieve it. So having it out of the way at the time of building an application is a very good reason to start using these objects.</p><p>In the next chapter, we will learn how to modularize our applications into small modules of subapplications in order to keep different functionalities of our website separated from each other, but still working together.</p></div></body></html>