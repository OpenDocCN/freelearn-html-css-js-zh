["```js\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport const LOAD_USERS = 'LOAD_USERS';\n\n// Performs some asynchronous behavior, and once\n// complete, dispatches the action.\nexport function loadUsers() {\n\n  // Creates a new promise, intended to simulate\n  // a call to some API function, which would likely\n  // also return a promise.\n  let api = new Promise((resolve, reject) => {\n\n    // Resolves the promise with some data after half\n    // a second.\n    setTimeout(() => {\n      resolve([\n        { id: 1, name: 'User 1' },\n        { id: 2, name: 'User 2' },\n        { id: 3, name: 'User 3' }\n      ]);\n    }, 500);\n  });\n\n  // When the promise resolves, the callback that's\n  // passed to \"then()\" is called with the resolved\n  // value. This is the payload that's dispatched.\n  api.then((response) => {\n    dispatcher.dispatch({\n      type: LOAD_USERS,\n      payload: response\n    });\n  });\n}\n```", "```js\nimport dispatcher from './dispatcher';\nimport { \n  LOAD_USERS, \n  loadUsers\n} from './actions/load-users';\n\n// Logs the specific action payloads as\n// they're dispatched.\ndispatcher.register((e) => {\n  switch(e.type) {\n    case LOAD_USERS:\n      console.log('users', e.payload.map(x =>x.id));\n      break;\n  }\n});\n\nloadUsers();\n// → users [1, 2, 3]\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport const START = 'START';\n\nexport function start() {\n\n  // Simulate an async API call that starts\n  // something. The promise resolves after\n  // one second.\n  let api = new Promise((resolve, reject) => {\n    setTimeout(resolve, 1000);\n  });\n\n  // Dispatches the action after the promise\n  // has resolved.\n  api.then((response) => {\n    dispatcher.dispatch({ type: START });\n  });\n}\n```", "```js\nimport dispatcher from '../dispatcher';\n\nexport const STARTING = 'STARTING';\n\nexport function starting() {\n  dispatcher.dispatch({ type: STARTING });\n}\n```", "```js\nimport dispatcher from '../dispatcher';\nimport {\n  START,\n  STARTING,\n  STOP,\n  STOPPING\n} from '../actions/constants';\n\nimport { EventEmitter } from 'events';\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = {\n      startDisabled: false,\n      stopDisabled: true\n    };\n\n    dispatcher.register((e) => {\n      switch(e.type) {\n\n        // If starting or stopping, we don't want any\n        // buttons enabled.\n        case STARTING:\n        case STOPPING:\n          this.state.startDisabled = true;\n          this.state.stopDisabled = true;\n          this.emit('change', this.state);\n          break;\n\n        // Disable the stop button after being started.\n        case START:\n          this.state.startDisabled = true;\n          this.state.stopDisabled = false;\n          this.emit('change', this.state);\n          break;\n\n        // Disabled the start button after being stopped.\n        case STOP:\n          this.state.startDisabled = false;\n          this.state.stopDisabled = true;\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport myStore from '../stores/mystore';\nimport {\n  start,\n  starting,\n  stop,\n  stopping\n} from '../actions/functions';\n\nclass MyView {\n  constructor() {\n\n    // The elements our view interacts with...\n    this.start = document.getElementById('start');\n    this.stop = document.getElementById('stop');\n\n    // The start button was clicked. Dispatch the\n    // \"STARTING\" action, and the \"START\" action\n    // once the asynchronous call resolves.\n    this.start.addEventListener('click', (e) => {\n      starting();\n      start();\n    });\n\n    // The stop button was clicked. Dispatch the\n    // \"STOPPING\" action, and the \"STOP\" action\n    // once the asynchronous call resolves.\n    this.stop.addEventListener('click', (e) => {\n      stopping();\n      stop();\n    });\n\n    // When the store state changes, update the UI\n    // by enabling or disabling the buttons,\n    // depending on the store state.\n    myStore.on('change', (state) => {\n      this.start.disabled = state.startDisabled;\n      this.stop.disabled = state.stopDisabled;\n    });\n  }\n}\n\nexport default new MyView();\n```", "```js\n// API helper function - resolves the given\n// \"data\" after the given MS \"delay\".\nfunction api(data, delay=1000) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(data);\n    }, delay);\n  });\n}\n\n// The first API...\nexport function first() {\n  return api([ 'A', 'B', 'C' ], 500);\n}\n\n// The second API...\nexport function second() {\n  return api([ 1, 2, 3 ]);\n}\n\n// The third API...\nexport function third() {\n  return api([ 'D', 'E', 'F' ], 1200);\n}\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The mock API functions we need.\nimport {\n  first,\n  second,\n  third\n} from './api';\n\n// The action identifier...\nexport constMY_ACTION = 'MY_ACTION';\n\nexport function myAction() {\n\n  // Calls all three APIs, which all resolve\n  // after different delay times. The \"Promise.all()\"\n  // method synchronizes them and returns a new promise.\n  Promise.all([\n    first(),\n    second(),\n    third()\n  ]).then((values) => {\n\n    // These are the resolved values...\n    let [ first, second, third ] = values;\n\n    // All three API calls have resolved, meaning we\n    // can now dispatch \"MY_ACTION\" with the three\n    // resolved async values as the payload.\n    dispatcher.dispatch({\n      type: MY_ACTION,\n      payload: {\n        first: first,\n        second: second,\n        third, third\n      }\n    });\n  });\n}\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/myaction';\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = [];\n\n    dispatcher.register((e) => {\n      switch(e.type) {\n        case MY_ACTION:\n\n          // Get the resolved async values from the\n          // action payload.\n          let { first, second, third } = e.payload;\n\n          // Zip the three arrays and set the resulting\n          // array as the store state.\n          this.state = first.map((item, i) =>\n            [ item, second[i], third[i] ]);\n\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport { myAction } from './actions/myaction';\nimport myStore from './stores/mystore';\n\nmyStore.on('change', (state) => {\n  console.log('changed', state);\n});\n\nmyAction();\n// → changed\n// [\n//   [ 'A', 1, 'D' ],\n//   [ 'B', 2, 'E' ],\n//   [ 'C', 3, 'F' ]\n// ]\n```", "```js\nimport { start as _start } from './start';\nimport { starting } from './starting';\nimport { stop as _stop } from './stop';\nimport { stopping } from './stopping';\n\n// The \"start()\" function now automatically\n// calls \"starting()\".\nexport function start() {\n  starting();\n  _start();\n}\n\n// The \"stop()\" function now automatically\n// calls \"stopping()\"\nexport function stop() {\n  stopping();\n  _stop();\n}\n\n// Export \"starting()\" and \"stopping()\" so\n// that they can still be used on their\n// own, or composed into other functions.\nexport { starting, stopping };\n```", "```js\n// The action identifier...\nexport const FIRST = 'FIRST';\n\n// The API function that returns a promise that's\n// resolved after 1.5 seconds.\nfunction api() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ first: 'First Name' });\n    }, 1500);\n  });\n}\n\nexport function first() {\n\n  // Returns a promise so that the caller\n  // knows when the update round is complete,\n  // regardless of the asynchronous behavior\n  // that takes place before the action is dispatched.\n  return new Promise((resolve, reject) => {\n    api().then((response) => {\n\n      // Action is dispatched after the asynchronous\n      // value is resolved.\n      dispatcher.dispatch({\n        type: FIRST,\n        payload: response\n      });\n\n      // Resolve the promise returned by \"first()\",\n      // after the update round.\n      resolve();\n    });\n  });\n}\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport const LAST = 'LAST';\n\n// The API function that returns a promise that's\n// resolved after 1.5 seconds.\nfunction api() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ last: 'Last Name' });\n    }, 1000);\n  });\n}\n\nexport function last() {\n  return new Promise((resolve, reject) => {\n    api().then((response) => {\n      dispatcher.dispatch({\n        type: LAST,\n        payload: response\n      });\n\n      resolve();\n    });\n  });\n}\n```", "```js\nimport dispatcher from './dispatcher';\nimport { FIRST, first } from './actions/first';\nimport { LAST, last } from './actions/last';\n\n// Logs the payload as actions are dispatched...\ndispatcher.register((e) => {\n  switch (e.type) {\n    case FIRST:\n      console.log('first', e.payload.first);\n      break;\n    case LAST:\n      console.log('last', e.payload.last);\n      break;\n  }\n});\n\n// Order of update rounds isn't guaranteed here.\nfirst();\nlast();\n// →\n// last Last Name\n// first First Name\n\n// With promises, update round order is consistent.\nfirst().then(last);\n// →\n// first First Name\n// last Last Name\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport const UPDATE_TASK = 'UPDATE_TASK';\n\n// The action error identifier...\nexport const UPDATE_TASK_ERROR = 'UPDATE_TASK_ERROR';\n\n// Returns a promise that's rejected with an error\n// message after 0.5 seconds.\nfunction api() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject('Failed to update task');\n    }, 500);\n  });\n}\n\nexport function updateTask() {\n  return new Promise((resolve, reject) => {\n\n    // Dispatches the \"UPDATE_TASK\" action as usual\n    // when the promise resolves. Then resolves\n    // the promise returned by \"updateTask()\".\n    api().then((response) => {\n      dispatcher.dispatch({\n        type: UPDATE_TASK\n      });\n\n      resolve();\n\n    // If the API promise rejects, reject the promise\n    // returned by \"updateTask()\" as well.\n    }, (error) => {\n      reject(error);\n    });\n  });\n}\n\n// A basic helper action creator for when the\n// \"updateTask()\" function is rejected.\nexport function updateTaskError(error) {\n  dispatcher.dispatch({\n    type: UPDATE_TASK_ERROR,\n    payload: error\n  });\n}\n```", "```js\nimport dispatcher from './dispatcher';\nimport {\n  UPDATE_TASK,\n  UPDATE_TASK_ERROR,\n  updateTask,\n  updateTaskError\n} from './actions/update-task';\n\n// Logs the payload as actions are dispatched...\ndispatcher.register((e) => {\n  switch (e.type) {\n    case UPDATE_TASK:\n      console.log('task updated');\n      break;\n    case UPDATE_TASK_ERROR:\n      console.error(e.payload);\n      break;\n  }\n});\n\n// We can tell \"updateTask()\" how to respond when\n// the underlying API call fails.\nupdateTask().catch(updateTaskError);\n// → Failed to update task\n```"]