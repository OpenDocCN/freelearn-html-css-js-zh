<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Types</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the preceding chapter, we learned some basic concepts about the TypeScript type system, including the basics about the type inference system and the optional static type annotations.</p>
<p class="mce-root">In this chapter, you will learn about the main features of the TypeScript type system, including the following concepts:</p>
<ul>
<li>The line between TypeScript and JavaScript</li>
<li>The features of the type system</li>
<li>Union types, intersection types, and discriminated unions</li>
<li>Type aliases and local types</li>
<li>The <kbd>typeof</kbd> and <kbd>keyof</kbd> operators</li>
<li>Control flow analysis and type guards</li>
<li>Non-nullable types</li>
<li>Generic types</li>
<li>Mapped types, lookup types, and conditional types</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The TypeScript type system's characteristics</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to learn about the main characteristics of the TypeScript type system, including concepts such as type inference, optional type annotation, and the differences between a nominal type system and a structural type system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The line between TypeScript and JavaScript</h1>
                </header>
            
            <article>
                
<p>One of the most important things that you are going to need to master to become a good TypeScript programmer is to be able to understand where TypeScript ends and JavaScript begins. It is very important to be able to understand what happens with our TypeScript code at three important phases:</p>
<ul>
<li><strong>Design time</strong>: This takes place when we are writing our TypeScript code and designing our application.</li>
<li><strong>Compilation time</strong>: This takes place when we compile our TypeScript into JavaScript code (some compilation errors may take place). Compilation time has subphases, such as parsing the TypeScript code, creating an abstract syntax tree (ATS), and emitting JavaScript code.</li>
<li><strong>Execution time</strong> (also known as runtime): This takes place when we execute the output JavaScript code generated by the TypeScript compiler.</li>
</ul>
<p>The TypeScript types are declared or inferred at design time and used during compilation time, but they are not available at execution time because they are not part of JavaScript.</p>
<p>In this chapter, we are going to learn about many of the TypeScript type system features. If you are familiar with JavaScript, you will notice the differences straight away but, if you are not familiar with JavaScript, I would recommend examining the generated JavaScript output after compiling the code samples included in this chapter. Over time, you will slowly earn the experience required to have a clear vision of the line between TypeScript and JavaScript.</p>
<div class="packt_tip packt_infobox">Please refer to <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml">Chapter 6</a>, <em>Understanding the Runtime</em>, to learn more about the execution time phase (JavaScript).</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type inference</h1>
                </header>
            
            <article>
                
<p>TypeScript tries to find the types of the variables and objects in our application using what is known as <strong>type inference</strong>. When we declare a variable, TypeScript will try to observe the value assigned to the variables in the application to identify its type. Let's examine some examples:</p>
<pre>let myVariable1 = 3;</pre>
<p>The type of the variable <kbd>myVariable1</kbd> is inferred as a number.</p>
<pre>let myVariable2 = "Hello";</pre>
<p>The type of the variable <kbd>myVariable2</kbd> is inferred as a string.</p>
<pre>let myVariable3 = {<br/>  name: "Remo",<br/>  surname: "Jansen",<br/>  age: 29<br/>};</pre>
<p>The type of the variable <kbd>myVariable3</kbd> is inferred as the following type:</p>
<pre>{ name: string; surname: string; age: number; }</pre>
<p>The type any is assigned in the cases in which TypeScript is not able to identify the type of a variable. For example, given the following function:</p>
<pre>function add(a, b) {<br/>  return a + b;<br/>}</pre>
<p>The type of the function <kbd>add</kbd> is inferred as the following type:</p>
<pre>(a: any, b: any) =&gt; any;</pre>
<p>The type <kbd>any</kbd> is problematic because it prevents the TypeScript compiler from identifying many potential errors. Fortunately, TypeScript features optional type annotations that can be used to solve this problem.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Optional static type annotations</h1>
                </header>
            
            <article>
                
<p>TypeScript allows us to use type annotations to overcome the scenarios in which the type inference system is not powerful enough to automatically detect the type of a variable.</p>
<p>Let's consider the <kbd>add</kbd> function one more time:</p>
<pre>function add(a, b) {<br/>  return a + b;<br/>}</pre>
<p>The type of the function <kbd>add</kbd> is inferred as the following type:</p>
<pre>(a: any, b: any) =&gt; any;</pre>
<p>The preceding type is a problem because the usage of the <kbd>any</kbd> type effectively prevents the TypeScript compiler from detecting certain errors. For example, we might expect the <kbd>add</kbd> function to add two numbers:</p>
<pre>let result1 = add(2, 3); // 5</pre>
<p>However, if we pass a string as input, we will encounter an unexpected result:</p>
<pre>let result2 = add("2", 3); // "23"</pre>
<p>The preceding error can happen very easily if, for example, the arguments provided to the <kbd>add</kbd> function have been extracted from an HTML input and we forget to parse them as a number.</p>
<p>We can fix the <kbd>add</kbd> function by adding optional type annotations:</p>
<pre>function add(a: number, b: number): number {<br/>  return a + b;<br/>}</pre>
<p>We can add an optional type annotation by adding a colon (<kbd>:</kbd>) after the declaration of a variable followed by the type:</p>
<pre>let myVariable: string = "Hello";</pre>
<div class="packt_tip packt_infobox">In the case of functions, we can add annotations to the arguments of the function and its returned value.</div>
<p>Now that the type of the arguments of the <kbd>add</kbd> function are <kbd>number</kbd>, instead of <kbd>any</kbd>, the TypeScript compiler will be able to detect potential issues if we provide arguments of the <kbd>worn</kbd> type:</p>
<pre>let result1 = add(2, 3); // OK<br/>let result2 = add("2", 3); // Error</pre>
<div class="packt_tip packt_infobox">In general, we should try to leverage the type inference system and use optional static type annotations only when the type inference system is not powerful enough to automatically detect the type of a variable.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Structural type system</h1>
                </header>
            
            <article>
                
<p>In the type system of a programming language, a type is an object with a name and a structure. Some types have very simple data structures (such as primitives) while others use complex structures (such as classes).</p>
<p>The type system can use two different strategies to validate that a given value matches the desired type:</p>
<ul>
<li><strong>Nominal type system</strong>: In this type system, values are matched against a type by its name</li>
<li><strong>Structural type system</strong>: <span>In this type system, v</span>alues are matched against a type by its structure</li>
</ul>
<p>The TypeScript type system is a structural type system because the values are matched against a type by its structure, as the following code snippet demonstrates:</p>
<pre>interface Person {<br/>  name: string; 
  surname: string; 
} 
 
function getFullName(person: Person) { 
  return `${person.name} ${person.surname}`; 
} 
 
class Employer { 
  constructor( 
    public name: string, 
    public surname: string 
  ) {} 
} 
 
getFullName(new Employer("remo", "jansen")); // OK 
 
const p1 = { name: "remo", surname: "jansen" }; 
getFullName(p1); // OK 
 
const p2 = { name: "remo", familyName: "jansen" }; 
getFullName(p2); // Error</pre>
<p>In the preceding code snippet, we can observe how the first two calls to the <kbd>getFullName</kbd> function are successful because the structure (properties and types) of both the <kbd>Employer</kbd> instance and the object literal match the structure of the <kbd>Person</kbd> interface.</p>
<p>The following code snippet showcases how TypeScript would work if it used a nominal type system:</p>
<pre>interface Person {<br/>  name: string;<br/>  surname: string;<br/>}<br/><br/>function getFullName(person: Person) {<br/>  return `${person.name} ${person.surname}`;<br/>}<br/><br/><br/>class Employer implements Person { // Named!<br/>  constructor(<br/>    public name: string,<br/>    public surname: string<br/>  ) {}<br/>}<br/><br/><br/>getFullName(new Employer("remo", "jansen")); // OK<br/><br/><br/>const p1: Person = { name: "remo", surname: "jansen" }; // Named!<br/>getFullName(p1); // OK<br/><br/><br/>const p2: Person = { name: "remo", familyName: "jansen" }; // Error<br/>getFullName(p2); // OK</pre>
<p>The first call to <kbd>getFullName</kbd> works because the <kbd>Employer</kbd> class implements the <kbd>Person</kbd> interface, and the name of the type of the interface can then be matched against the name of the type of the function argument.</p>
<div class="packt_tip packt_infobox">The TypeScript team is currently investigating the possibility of potentially adding support for a nominal type system as well. You can learn more about the progress at <a href="https://github.com/Microsoft/TypeScript/issues/202">https://github.com/Microsoft/TypeScript/issues/202</a><em>.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Core features of the TypeScript type system</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to learn about some of the core features of the TypeScript type system. This includes concepts such as union types, intersection guards, type guards, and type aliases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Union types</h1>
                </header>
            
            <article>
                
<p>TypeScript allows you to declare union types:</p>
<pre>let path: string[]|string;<br/>path = "/temp/log.xml";<br/>path = ["/temp/log.xml", "/temp/errors.xml"];<br/>path = 1; // Error</pre>
<p>In the preceding example, we have declared a variable named <kbd>path</kbd> that can contain a single path (string) or a collection of paths (array of strings). In the example, we have also set the value of the variable. We assigned a string and an array of strings without errors; however, when we attempted to assign a numeric value, we got a compilation error, because the union type didn't declare a number as one of the valid types of the variable.</p>
<p>Union types are used to declare a variable that can store a value of two or more types. Only the properties available in all the types present in the intersection type are considered valid:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-120 image-border" src="Images/8b061ccf-0238-48be-acee-3f26eb3689d5.png" style="width:20.25em;height:13.67em;" width="640" height="467"/></div>
<p>We can appreciate this behavior in the following example:</p>
<pre>interface Supplier {<br/> 
    orderItems(): void; 
    getAddress(): void; 
} 
 
interface Customer { 
    sellItems(): void; 
    getAddress(): void; 
} 
 
declare let person: Supplier | Customer; 
person.getAddress(); // OK 
person.orderItems(); // Error 
person.sellItems();  // Error</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type aliases</h1>
                </header>
            
            <article>
                
<p>TypeScript allows us to declare type aliases by using the <kbd>type</kbd> keyword:</p>
<pre>type PrimitiveArray = Array&lt;string|number|boolean&gt;; 
type MyNumber = number;  
type Callback = () =&gt; void</pre>
<p>Type aliases are exactly the same as their original types; they are simply alternative names. Type aliases can help us to make our code more readable, but it can also lead to some problems.</p>
<p>If you work as part of a large team, the indiscriminate creation of aliases can lead to maintainability problems. The book <em>Maintainable JavaScript</em>, <em>Nicholas C. Zakas</em> recommends that you <em>"avoid modifying the objects you don't own"</em>. Nicholas was talking about adding, removing, or overriding methods in objects that have not been declared by you (DOM objects, BOM objects, primitive types, and third-party libraries), but we can apply this rule to the use of aliases as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Intersection types</h1>
                </header>
            
            <article>
                
<p>When Anders Hejlsberg added intersection types to TypeScript for the first time, he defined them as follows:</p>
<div class="packt_quote">"Intersection types are the logical complement of union types. A union type A | B represents an entity that has either type A or type B, whereas an intersection type A &amp; B represents an entity that has both type A and type B."</div>
<p>The following example declares three interfaces named <kbd>A</kbd>, <kbd>B</kbd>, and <kbd>C</kbd>. Then it declares an object named <kbd>abc</kbd>, whose type is the intersection type of the interfaces <kbd>A</kbd>, <kbd>B</kbd>, and <kbd>C</kbd>. As a result, the <kbd>abc</kbd> object has properties named <kbd>a</kbd>, <kbd>b</kbd>, and <kbd>c</kbd>, but not <kbd>d</kbd>:</p>
<pre>interface A { a: string } 
interface B { b: string } 
interface C { c: string } 
declare let abc: A &amp; B &amp; C; 
abc.a = "hello"; // OK 
abc.b = "hello"; // OK 
abc.c = "hello"; // OK 
abc.d = "hello"; // Error <br/><br/></pre>
<p>Intersection types can also be applied to subproperties:</p>
<pre>interface X { x: A }<br/>interface Y { x: B }<br/>interface Z { x: C }<br/>declare let xyz: X &amp; Y &amp; Z;<br/>xyz.x.a = "hello"; // OK<br/>xyz.x.b = "hello"; // OK<br/>xyz.x.c = "hello"; // OK<br/>xyz.x.d = "hello"; // Error<br/><br/></pre>
<p>They can also be applied to functions:</p>
<pre>type F1 = (x: string) =&gt; string;<br/>type F2 = (x: number) =&gt; number;<br/>declare let f: F1 &amp; F2;<br/>let s = f("hello"); // OK<br/>let n = f(42); // OK<br/>let t = f(true); // Error</pre>
<p>The properties available in one or all the types present in the intersection type are considered valid:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-121 image-border" src="Images/39abf20c-3de5-49c2-9610-b46b9ac87d79.png" style="width:18.75em;height:12.50em;" width="640" height="467"/></div>
<p>We can appreciate this behavior in the following example:</p>
<pre>interface Supplier {<br/>    orderItems(): void;<br/>    getAddress(): void;<br/>}<br/><br/>interface Customer {<br/>    sellItems(): void;<br/>    getAddress(): void;<br/>}<br/><br/>declare let person: Supplier &amp; Customer;<br/>person.getAddress(); // OK<br/>person.orderItems(); // OK<br/>person.sellItems();  // OK</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Non-nullable types</h1>
                </header>
            
            <article>
                
<p>TypeScript 2.0 introduced what are known as non-nullable types. TypeScript used to consider null and undefined to be valid values of every type.</p>
<p>The following diagram represents the values that can be assigned to the type number when non-nullable types are disabled:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-122 image-border" src="Images/a26d29c5-8b7e-4eba-89dd-163e4605358d.png" style="width:16.08em;height:16.08em;" width="436" height="436"/></div>
<p>As we can see in the preceding diagram, <kbd>undefined</kbd> and <kbd>null</kbd> are allowed as values of the type number, together with the <kbd>NaN</kbd> value and all the possible numbers.</p>
<div class="packt_quote packt_infobox">NaN, standing for not a number, is a numeric data type value representing an undefined or non-representable value, especially in floating-point calculations. Systematic use of NaNs was introduced by the IEEE 754 floating-point standard in 1985, along with the representation of other non-finite quantities such as infinities.</div>
<p>The following code snippet demonstrates how <kbd>undefined</kbd> and <kbd>null</kbd> are allowed as values of the type number when non-nullable types are disabled:</p>
<pre>let name: string;<br/>name = "Remo"; // OK<br/>name = null; // OK<br/>name = undefined; // OK</pre>
<p>The same can be said about all other types:</p>
<pre>let age: number;<br/>age = 28; // OK<br/>age = null; // OK<br/>age = undefined; // OK<br/><br/>let person: { name: string, age: number};<br/>person = { name: "Remo", age: 28 }; // OK<br/>person = { name: null, age: null }; // OK<br/>person = { name: undefined, age: undefined }; // OK<br/>person = null;       // OK<br/>person = undefined;  // OK</pre>
<p>When non-nullable types are enabled, the values <kbd>null</kbd> and <kbd>undefined</kbd> are considered independent types and stop being considered as valid values of the type number:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-123 image-border" src="Images/a785a982-e504-42b5-b136-735465473c16.png" style="width:18.00em;height:16.50em;" width="503" height="460"/></div>
<p>The following code snippet demonstrates how <kbd>undefined</kbd> and <kbd>null</kbd> are not allowed as values of the type number when non-nullable types are enabled:</p>
<pre>let name: string;<br/>name = "Remo"; // OK<br/>name = null; // Error<br/>name = undefined; // Error</pre>
<p>The same can be said about all other types:</p>
<pre>let age: number;<br/>age = 28; // OK<br/>age = null; // Error<br/>age = undefined; // Error<br/><br/>let person: { name: string, age: number};<br/>person = { name: "Remo", age: 28 }; // OK<br/>person = { name: null, age: null }; // Error<br/>person = { name: undefined, age: undefined }; // Error<br/>person = null; // Error<br/>person = undefined; // Error</pre>
<p>We can enable non-nullable types by using the <kbd><strong>--</strong>strictNullChecks</kbd> compilation flag:</p>
<pre>tsc -strictNullChecks file.ts</pre>
<p>When non-nullable types are enabled, we can use union types to create nullable versions of a type:</p>
<pre>type NullableNumber = number | null;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The --strict mode</h1>
                </header>
            
            <article>
                
<p>TypeScript allows us to use the <kbd>--strict</kbd> compilation flag to enable all strict type checking options. Enabling <kbd>--strict</kbd> enables <kbd>--noImplicitAny</kbd>, <kbd>--noImplicitThis</kbd>, <kbd>--alwaysStrict</kbd>, <kbd>--strictPropertyInitialization</kbd>, and <kbd>--strictNullChecks</kbd>:</p>
<ul>
<li>The <kbd>--strictNullChecks</kbd> compilation flag enables non-nullable types.</li>
<li>The <kbd>--noImplicitAny</kbd> flag forces us to explicitly declare the type of a variable when the type inference system is not able to automatically infer the correct type.</li>
<li>The <kbd>--alwaysStrict</kbd> flag forces the TypeScript parse to use the strict mode.</li>
<li>The <kbd>--noImplicitThis</kbd> flag forces us to explicitly declare the type of the this operator in functions when the type inference system is not able to automatically infer the correct type.</li>
<li>The <kbd>--strictPropertyInitialization</kbd> flag forces class properties to be initialized.</li>
</ul>
<div class="packt_tip packt_infobox">We will learn more about the JavaScript use strict and the this operator in <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml">Chapter 6</a>, <em>Understanding the Runtime</em>.</div>
<p>Using the <kbd>--strict</kbd> compilation flag makes the TypeScript compiler much stricter. Enabling this option in existing large TypeScript projects can lead to the discovery of many errors that may require a significant effort to fix. For this reason, it is recommended to enable the <kbd>--strict</kbd> compilation flag in greenfield TypeScript projects and enable the individual flags (<kbd>--noImplicitAny</kbd>, <kbd>--noImplicitThis</kbd>, <kbd>--alwaysStrict</kbd>, and <kbd>--strictNullChecks</kbd>) progressively in existing TypeScript projects.</p>
<p>The <kbd>--noImplicitReturns</kbd> compilation flag is not one of the flags enabled by the <kbd>--strict</kbd> flag. The flag throws an error when not all code paths in function return a value. It is also recommended that you enable this flag in greenfield TypeScript projects or when possible on existing projects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The typeof operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>typeof</kbd> operator can be used at runtime (JavaScript):</p>
<pre>let myNumber = 5;<br/>console.log(typeof myNumber === "number");</pre>
<p>It is important to note that it can also be used at design time (TypeScript) only:</p>
<pre>let myNumber = 5;<br/>type NumberType = typeof myNumber;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type guards</h1>
                </header>
            
            <article>
                
<p>We can examine the type of an expression at runtime by using the <kbd>typeof</kbd> or <kbd>instanceof</kbd> operators. The TypeScript language service looks for these operators and will narrow down the inferred type accordingly when used in an <kbd>if</kbd> block:</p>
<pre>let x: any = { /* ... */ };<br/>if(typeof x === 'string') {<br/>console.log(x.splice(3, 1)); // Error, 'splice' does not exist<br/>  on 'string'<br/>}<br/>// x is still any<br/>x.foo(); // OK</pre>
<p>In the preceding code snippet, we have declared a variable named <kbd>x</kbd> of type <kbd>any</kbd>. Later, we check the type of <kbd>x</kbd> at runtime by using the <kbd>typeof</kbd> operator. If the type of <kbd>x</kbd> results to be a string, we will try to invoke the method <kbd>splice</kbd>, which is supposed to be a member of the <kbd>x</kbd> variable. The TypeScript language service can understand the usage of <kbd>typeof</kbd> in a conditional statement. TypeScript will automatically assume that <kbd>x</kbd> must be a string and let us know that the <kbd>splice</kbd> method does not exist on the type string. This feature is known as <strong>type guards</strong>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom type guards</h1>
                </header>
            
            <article>
                
<p>We can define custom type guards using by declaring a function with a special return type:</p>
<pre>interface Supplier {<br/>    orderItems(): void;<br/>    getAddress(): void;<br/>}<br/><br/>interface Customer {<br/>    sellItems(): void;<br/>    getAddress(): void;<br/>}<br/><br/>function isSupplier(person: Supplier | Customer): person is Supplier {<br/>    return (&lt;Supplier&gt; person).orderItems !== undefined;<br/>}<br/><br/>function handleItems(person: Supplier | Customer) {<br/>    if (isSupplier(person)) {<br/>        person.orderItems(); // OK<br/>    } else {<br/>        person.sellItems(); // OK<br/>    }<br/>}</pre>
<p>The preceding code snippet declares two types (<kbd>Supplier</kbd> and <kbd>Customer</kbd>); it then declares a custom type guard function. The custom type guard returns a Boolean value. The function returns true when the provided value <kbd>person</kbd> has a property named <kbd>orderItems</kbd> and false when the property is missing.</p>
<p>The function is trying to identify the type at runtime by examining the properties of the value. This kind of type matching is known as <strong>pattern matching</strong>.</p>
<div class="packt_infobox">We will learn more about pattern matching in <a href="72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml">Chapter 7</a>, <em>Functional Programming with TypeScript</em>.</div>
<p>Pattern matching is not the only technique that we can use to identify if a value matches a type. We can also use the <kbd>instanceof</kbd> operator:</p>
<pre>class Supplier {<br/>    public orderItems(): void {<br/>        // do something...<br/>    }<br/>    public getAddress(): void {<br/>        // do something...<br/>    }<br/>}<br/><br/><br/>class Customer {<br/>    public sellItems(): void {<br/>        // do something...<br/>    }<br/>    public getAddress(): void {<br/>        // do something...<br/>    }<br/>}<br/><br/><br/>function isSupplier(person: Supplier | Customer): person is Supplier {<br/>    return person instanceof Supplier;<br/>}<br/><br/><br/>function handleItems(person: Supplier | Customer) {<br/>    if (isSupplier(person)) {<br/>        person.orderItems(); // OK<br/>    } else {<br/>        person.sellItems(); // OK<br/>    }<br/>}</pre>
<p>Another technique that we can use to identify if a value matches a type is to use the <kbd>typeof</kbd> operator:</p>
<pre>function doSomething(x: number | string) {<br/>    if (typeof x === 'string') {<br/>        console.log(x.subtr(1)); // Error<br/>        console.log(x.substr(1)); // OK<br/>    }<br/>    x.substr(1); // Error<br/>}</pre>
<p>The preceding code snippet throws a compilation error within the <kbd>if</kbd> block because TypeScript knows that the variable <kbd>x</kbd> must be a string within the block. Another error is thrown outside of the <kbd>if</kbd> block, because TypeScript cannot guarantee that the type of the variable x is string at that point.</p>
<p>Since TypeScript 2.7, we can use the <kbd>in</kbd> operator as a type guard to narrow down a given type, as demonstrated by the following example:</p>
<pre>interface Cat {<br/>    meow(): void;<br/>}<br/><br/><br/>interface Dog {<br/>    woof(): void;<br/>}<br/><br/><br/>function doSomething(obj: Cat | Dog) {<br/>    if ("meow" in obj) {<br/>        obj.meow(); // OK<br/>    } else {<br/>        obj.woof(); // OK<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Control flow analysis</h1>
                </header>
            
            <article>
                
<p>TypeScript includes a feature known as control flow analysis that is used to identify the type of a variable, based on the execution flow of a program. This feature allows TypeScript to have more precise type inference capabilities.</p>
<p>The following example defines a function that takes two arguments, and the type of one of them (named value) is the union type of number and array of number:</p>
<pre>function increment(<br/>  incrementBy: number, value: number | number[]<br/>) {<br/>  if (Array.isArray(value)) {<br/>    // value must be an array of number<br/>    return value.map(value =&gt; value + incrementBy);<br/>  } else {<br/>    // value is a number<br/>    return value + incrementBy;<br/>  }<br/>}<br/><br/><br/>increment(2, 2); // 4<br/>increment(2, [2, 4, 6]); // [4, 6, 8]</pre>
<p>Within the body of the function, we use an <kbd>if</kbd> statement to determine if the value variable is indeed an array of numbers or just a number. The type inference system will change the inferred type of the argument to match the correct type accordingly with the two paths of the <kbd>if...else</kbd> statement.</p>
<p>Control flow analysis improves the type checker's understanding of variable assignments and control flow statements, thereby greatly reducing the need for type guards.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Literal types</h1>
                </header>
            
            <article>
                
<p>Literal types allow us to declare the exact value that a string Boolean or number must have. When we declare a variable using the <kbd>let</kbd> keyword, its value will be inferred as a primitive type:</p>
<pre>let five = 5; // number<br/>let falsy = false; // boolean<br/>let shape = "rectangle"; // string</pre>
<p>However, if we use the <kbd>const</kbd> keyword, the type is inferred as the actual assigned value:</p>
<pre>const five = 5; // 5<br/>const falsy = false; // false<br/>const shape = "rectangle"; // rectangle</pre>
<p>Literal types can be used in combination with union types, type guards, and type aliases with ease:</p>
<pre>type ShapeKind = "square" | "rectangle" | "circle";</pre>
<p>Literal types can be used in combination with type guards and the power of control flow analysis to narrow union types using a technique known as discriminated unions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Discriminated unions</h1>
                </header>
            
            <article>
                
<p>A discriminated union (also known as tagged unions or algebraic data types) is an advanced pattern that combines string literal types, union types, type guards, and types aliases.</p>
<p>Discriminated unions use a type guard to narrow union types based on tests of a discriminant property (a string literal type) and furthermore extend that capability to switch statements.</p>
<p>The following code snippet declares three types that share a string literal property named <kbd>kind</kbd>:</p>
<pre>interface Cube {<br/>    kind: "cube";<br/>    size: number;<br/>}<br/><br/><br/>interface Pyramid {<br/>    kind: "pyramid";<br/>    width: number;<br/>    length: number;<br/>    height: number;<br/>}<br/><br/><br/>interface Sphere {<br/>    kind: "sphere";<br/>    radius: number;<br/>}</pre>
<p>We then declare the union type of the three types declared in the preceding code snippet:</p>
<pre>type Shape = Cube | Pyramid | Sphere;<br/><br/>function volume(shape: Shape) {<br/>    const PI = Math.PI;<br/>    switch (shape.kind) {<br/>        case "cube":<br/>            return shape.size ** 3;<br/>        case "pyramid":<br/>            return (shape.width * shape.height * shape.length) / 3;<br/>        case "sphere":<br/>            return (4 / 3) * PI * (shape.radius ** 3);<br/>    }<br/>}</pre>
<p>In the preceding function, the <kbd>switch</kbd> statement acts as a type guard. The type of shape is narrowed in each case clause, according to the value of the discriminant property, <kbd>kind</kbd>, thereby allowing the other properties of that variant to be accessed without a type assertion.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The never type</h1>
                </header>
            
            <article>
                
<p>As described in the TypeScript documentation, the <kbd>never</kbd> type has the following characteristics:</p>
<ul>
<li>The <kbd>never</kbd> type is a subtype of and assignable to every type.</li>
<li>No type is a subtype of or assignable to <kbd>never</kbd> (except <kbd>never</kbd> itself).</li>
<li>In a function expression or arrow function with no return type annotation, if the function has no <kbd>return</kbd> statements or only <kbd>return</kbd> statements with expressions of type <kbd>never</kbd> and, if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is <kbd>never</kbd>.</li>
<li>In a function with an explicit never return type annotation, all <kbd>return</kbd> statements (if any) must have expressions of a type <kbd>never</kbd> and the end of the function must not be reachable.</li>
</ul>
<p>In JavaScript, when a function doesn't explicitly return a value, it implicitly returns the value <kbd>undefined</kbd>. In TypeScript, the return type of such a function is inferred as void. When a function doesn't complete its execution (it throws an error or never finishes running at all), its return type is inferred as <kbd>never</kbd> by TypeScript:</p>
<pre>function error(message: string): never {<br/>    throw new Error(message);<br/>}<br/><br/><br/>// Type () =&gt; never<br/>const sing = function() {<br/>    while (true) {<br/>        console.log("I will never return!");<br/>    }<br/>};</pre>
<p>We can also encounter the <kbd>never</kbd> type when we reach impossible matches in discriminated unions:</p>
<pre>function area(shape: Shape) {<br/>    const PI = Math.PI;<br/>    switch (shape.kind) {<br/>        case "square": return shape.size * shape.size;<br/>        case "rectangle": return shape.width * shape.height;<br/>        case "circle": return PI * shape.radius * shape.radius;<br/>        default:<br/>            return shape; // never<br/>    }<br/>}</pre>
<p>In the preceding code snippet, the default case will never be executed; therefore, the return type is inferred as the never type.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enumerations</h1>
                </header>
            
            <article>
                
<p>Enumerations allow us to define a set of named constants. Since the TypeScript 2.4 release, these named constant values can be string values. Originally, they could only be numeric values:</p>
<pre>enum CardinalDirection {<br/>    Up,<br/>    Down,<br/>    Left,<br/>    Right<br/>}</pre>
<p>A common workaround to this limitation was the usage of union types of literal types:</p>
<pre>type CardinalDirection =<br/>    "North"<br/>    | "East"<br/>    | "South"<br/>    | "West";<br/><br/><br/>function move(distance: number, direction: CardinalDirection) {<br/>    // ...<br/>}<br/><br/>move(1,"North"); // Okay<br/>move(1,"Nurth"); // Error!</pre>
<p>Since the TypeScript 2.4 release, enumerations with string values are also supported:</p>
<pre>enum CardinalDirection {<br/>    Red = "North",<br/>    Green = "East",<br/>    Blue = "South",<br/>    West = "West"<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Object literals</h1>
                </header>
            
            <article>
                
<p>Objects can be initialized using new <kbd>Object()</kbd>, <kbd>Object.create()</kbd>, or using the object literal notation, also known as initializer notation. An object initializer is a comma-delimited list of zero or more pairs of property names and values of an object, enclosed in curly braces:</p>
<pre>let person = { name: "Remo", age: 28 };</pre>
<p>The type inference system can automatically infer the type of object literals. The inferred type for the variable person declared in the preceding code snippet is <kbd>{ name: string, age: number }</kbd>. Alternatively, we can explicitly declare the type of an object literal:</p>
<pre>interface User {<br/>    name: string;<br/>    age: number;<br/>}<br/><br/>let person: User = { name: "Remo", age: 28 }; // OK</pre>
<p>It is also possible to declare optional properties:</p>
<pre>interface User {<br/>    name: string;<br/>    age?: number;<br/>}<br/><br/><br/>let person1: User = { name: "Remo", age: 28 }; // OK<br/>let person2: User = { name: "Remo" }; // OK</pre>
<div class="packt_infobox">Please refer to <a href="25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml">Chapter 1</a><em>, Introducing TypeScript,</em> to learn more about the difference between the empty object type (<kbd>{}</kbd>), the Object (uppercase) type, and the object (lowercase) type.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Weak types</h1>
                </header>
            
            <article>
                
<p>A weak type is an object literal type in which all properties are optional:</p>
<pre>interface User {<br/>    name?: string;<br/>    age?: number;<br/>}</pre>
<p>TypeScript allows us to add a value with some or all the properties defined in the weak type, but it doesn't allow us to assign properties that are not part of the weak type:</p>
<pre>let user1: User  = { name: "Remo", age: 28 }; // OK<br/>let user2: User = { firstName: "Remo", yearBorn: 28 }; // Error</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The keyof operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>keyof</kbd> operator can be used to generate a union type of the properties of an object as string literal types:</p>
<pre>interface User {<br/>    name: string;<br/>    age: number;<br/>}<br/><br/><br/>type userKeys = keyof User; // "name" | "age"</pre>
<p>The <kbd>keyof</kbd> operator can be used in combination with other operators, such as the <kbd>typeof</kbd> operator, for example:</p>
<pre>let person = { name: "Remo", age: "28" };<br/><br/>interface User {<br/>    name: string;<br/>    age: number;<br/>}<br/><br/>type userKeys = keyof typeof person; // "name" | "age"</pre>
<p>We will find out more about the <kbd>keyof</kbd> operator later in this chapter when we learn about lookup types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Index signature</h1>
                </header>
            
            <article>
                
<p>In JavaScript, we can access the properties of an object using the name of the object followed by a dot and the name of the property:</p>
<pre>let foo: any = {};<br/>foo.hello = 'World';<br/>console.log(foo.hello); // World</pre>
<p>However, it is also possible to access the properties of an object using the name of the object followed by the name of the property as a string wrapped by brackets:</p>
<pre>let foo: any = {};<br/>foo['hello'] = 'World';<br/>console.log(foo['hello']); // World</pre>
<p>This behavior can be declared using what is known as the index signature:</p>
<pre>interface StringArray {<br/>    [index: number]: string;<br/>}<br/><br/>let myArray: StringArray = ["Bob", "Fred"];<br/>let myStr: string = myArray[0];</pre>
<p>As we can see in the preceding code snippet, the index signature allows us to specify the type of the value returned when we access a property using the brackets signature.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Local types</h1>
                </header>
            
            <article>
                
<p>The TypeScript type system allows us to declare types (such as type aliases, classes, and interfaces) within the declaration of functions and methods. In the early releases of TypeScript, this was not allowed:</p>
<pre>interface Person {<br/>    name: string;<br/>    age: number;<br/>}<br/><br/>function makePerson(name: string, age: number): Person {<br/><br/>    // Local type<br/>    class Person implements Person {<br/>        constructor(<br/>            public name: string,<br/>            public age: number<br/>        ) {}<br/>    }<br/><br/>    return new Person(name, age);<br/><br/>}<br/><br/>let user = makePerson("Remo", 28);</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type casting</h1>
                </header>
            
            <article>
                
<p>The TypeScript type system allows us to cast a given type using two different syntaxes:</p>
<pre>var myObject: TypeA;<br/>var otherObject: any;<br/>myObject = &lt;TypeA&gt; otherObject; // Using &lt;&gt;<br/>myObject = otherObject as TypeA; // Using as keyword</pre>
<p>It is important to understand that the TypeScript casting does not affect the runtime type of the variables.</p>
<div class="packt_infobox">Since Typescript 1.6, the default is <kbd>as</kbd>, because <kbd>&lt;&gt;</kbd> is ambiguous in <kbd>.tsx</kbd> files. We will learn more about <kbd>.tsx</kbd> files in <a href="b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml">Chapter 11</a><em>, Frontend Development with React and TypeScript.</em></div>
<p>In general, it is recommended to avoid using type castings and prefer generic types instead.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced features of the TypeScript type system</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to learn some advanced type system features such as generic types, mapped types, and lookup types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic types</h1>
                </header>
            
            <article>
                
<p>Generic types can help us avoid using type casting and increase the reusability of our code by allowing us to declare (<kbd>T</kbd>) when a function, class, or method is consumed, as opposed to when it is declared:</p>
<pre>function deserialize&lt;T&gt;(json: string): T {<br/>    return JSON.parse(json) as T;<br/>}<br/><br/>interface User {<br/>    name: string;<br/>    age: number;<br/>}<br/><br/>let user = deserialize&lt;User&gt;(`{"name":"Remo","age":28}`);<br/><br/>interface Rectangle {<br/>    width: number;<br/>    height: number;<br/>}<br/><br/>let rectangle = deserialize&lt;Rectangle&gt;(`{"width":5,"height":8}`);</pre>
<p>The preceding example declares a function named deserialize. The type returned by the function (T) is unknown at the point in which the function is declared. The function is then invoked on two occasions, and the type T becomes finally known (User and Rectangle).</p>
<div class="packt_infobox">We will learn more about generic types in <a href="841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml">Chapter 4</a><em>, Object-Oriented Programming with TypeScript.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic constraints</h1>
                </header>
            
            <article>
                
<p>Sometimes, we don't need the concrete type required by a function, class, or method, but we know that such type must adhere to a certain set of rules.</p>
<p>For example, the following code snippet declares a generic function named <kbd>isEquals</kbd>. However, this time the type <kbd>T</kbd> has a constraint (<kbd>T</kbd> extends <kbd>Comparable</kbd>):</p>
<pre>interface Comparable&lt;T&gt; {<br/>    equals(value: T): boolean;<br/>}<br/><br/>function isEqual&lt;TVal, T extends Comparable&lt;TVal&gt;&gt;(comparable: T, value: TVal) {<br/>    return comparable.equals(value);<br/>}</pre>
<p>The constraint is used to ensure that all the types provided to <kbd>isEqual</kbd> as its generic type argument implement the <kbd>Comparable</kbd> interface:</p>
<pre>interface RectangleInterface {<br/>    width: number;<br/>    height: number;<br/>}<br/><br/>type ComparableRectangle = RectangleInterface &amp; Comparable&lt;RectangleInterface&gt;;<br/><br/>class Rectangle implements ComparableRectangle {<br/>    public width: number;<br/>    public height: number;<br/>    public constructor(width: number, height: number) {<br/>        this.width = width;<br/>        this.height = height;<br/>    }<br/>    public equals(value: Rectangle) {<br/>        return value.width === this.width &amp;&amp; value.height === this.height;<br/>    }<br/>};<br/><br/>interface CircleInterface {<br/>    radious: number;<br/>}<br/><br/>type ComparableCircle = CircleInterface &amp; Comparable&lt;CircleInterface&gt;;<br/><br/>class Circle implements ComparableCircle {<br/>    public radious: number;<br/>    public constructor(radious: number) {<br/>        this.radious = radious<br/>    }<br/>    public equals(value: CircleInterface): boolean {<br/>        return value.radious === this.radious;<br/>    }<br/>}<br/><br/>const circle = new Circle(5);<br/>const rectangle = new Rectangle(5, 8);<br/><br/>isEqual&lt;RectangleInterface, ComparableRectangle&gt;(rectangle, { width: 5, height: 8 });<br/>isEqual&lt;CircleInterface, ComparableCircle&gt;(circle, { radius: 5 });</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mapped types</h1>
                </header>
            
            <article>
                
<p>Mapped types are an advanced type feature that allows us to map the value of each of the properties of a type to a different type. For example, the following mapped type transforms the value of the properties of a given type to a string literal that matches the property name:</p>
<pre>type Keyify&lt;T&gt; = {<br/>    [P in keyof T]: P;<br/>};</pre>
<p>The following function takes an object and returns a new object in which all the properties have the same names, but their values are the names of the properties:</p>
<pre>function getKeys&lt;T&gt;(obj: T): Keyify&lt;T&gt; {<br/>    const keysArr = Object.keys(obj);<br/>    const stringifyObj = keysArr.reduce((p, c, i, a) =&gt; {<br/>        return {<br/>            ...p,<br/>            [c]: c<br/>        };<br/>    }, {});<br/>    return stringifyObj as Keyify&lt;T&gt;;<br/>}<br/><br/>interface User {<br/>    name: string;<br/>    age: number;<br/>}<br/><br/>let user: User = { name: "Remo", age: 28 };<br/>let keys = getKeys&lt;User&gt;(user);<br/><br/>keys.name; // "name"<br/>keys.age; // "age"<br/><br/>TypeScript declares some commonly used mapped types for us:<br/>// Make all properties in T optional<br/>type Partial&lt;T&gt; = {<br/>    [P in keyof T]?: T[P];<br/>};<br/><br/><br/>// Make all properties in T readonly<br/>type Readonly&lt;T&gt; = {<br/>    readonly [P in keyof T]: T[P];<br/>};<br/><br/><br/>// From T pick a set of properties K<br/>type Pick&lt;T, K extends keyof T&gt; = {<br/>    [P in K]: T[P];<br/>}<br/><br/>// Construct a type with a set of properties K of type T<br/>type Record&lt;K extends string, T&gt; = {<br/>    [P in K]: T;<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lookup types</h1>
                </header>
            
            <article>
                
<p>Lookup types are another advanced type system feature that allow us to combine the <kbd>keyof</kbd> operator with generic and object literals to create advanced type annotations. Let's look at an example:</p>
<pre>function filterByProperty&lt;T, K extends keyof T&gt;(<br/>    property: K, entities: T[], value: T[K]<br/>) {<br/>    return entities.filter(e =&gt; e[property] === value);<br/>}</pre>
<p>The preceding function takes two generic type arguments:</p>
<ul>
<li><kbd>T</kbd> is the type of the items in the array passed as the first argument of the function.</li>
<li><kbd>K</kbd> is the name of the properties of <kbd>T</kbd>. This requirement is enforced by a generic constraint (extends <kbd>keyof T</kbd>).</li>
</ul>
<p>The function also expects two arguments:</p>
<ul>
<li>An array of entities of type <kbd>T</kbd>.</li>
<li>A value of type <kbd>T[K]</kbd>. The type <kbd>T[K]</kbd> represents the type of the value of the property <kbd>K</kbd> in the type <kbd>T</kbd>, and it is known as lookup type.</li>
</ul>
<p>The preceding function can be used to filter the array of entities of type <kbd>T</kbd> by one of the properties of the type <kbd>T</kbd>:</p>
<pre>interface User {<br/>    surname: string;<br/>    age: number;<br/>}<br/><br/>const users = [<br/>    { surname: "Smith", age: 28 },<br/>    { surname: "Johnson", age: 55 },<br/>    { surname: "Williams", age: 14 }<br/>];<br/><br/><br/>filterByProperty&lt;User, "age"&gt;("age", users, 21);<br/>filterByProperty&lt;User, "surname"&gt;("surname", users, "Smith");</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mapped type modifiers</h1>
                </header>
            
            <article>
                
<p>TypeScript 2.8 introduced a few operators that allow us to have a greater level of control over the definition of mapped types:</p>
<ul>
<li>We can use the <kbd>readonly</kbd> modifier to flag a property as immutable.</li>
<li>We can use the <kbd>?</kbd> operator to flag a property as optional.</li>
<li>We can use the <kbd>+</kbd> operator to apply a modifier, such as the <kbd>readonly</kbd> modifier, to a property in a type. We can also use the <kbd>+</kbd> operator with the <kbd>?</kbd> operator.</li>
<li>We can use the <kbd>-</kbd> operator to apply a modifier, such as the <kbd>readonly</kbd> modifier to a property in a type. We can also use the <kbd>+</kbd> operator with the <kbd>?</kbd> operator.</li>
</ul>
<p>We will now examine a few examples. The code snippet declares a mapped type that can be used to transform a type, <kbd>T</kbd>, into a new type that contains all the properties in <kbd>T</kbd> but is marked as both <kbd>readonly</kbd> and <kbd>optional</kbd>:</p>
<pre>type ReadonlyAndPartial1&lt;T&gt; = {<br/>    readonly [P in keyof T]?: T[P]<br/>}</pre>
<p>The following type declaration is identical to the one in the preceding code snippet:</p>
<pre>type ReadonlyAndPartial2&lt;T&gt; = {<br/>    +readonly [P in keyof T]+?: T[P];<br/>}</pre>
<p>The following type can be used to remove the <kbd>readonly</kbd> modifier from all the properties in a given type <kbd>T</kbd>:</p>
<pre>type Mutable&lt;T&gt; = {<br/>    -readonly [P in keyof T]: T[P]<br/>}</pre>
<p>We can apply the <kbd>Mutable</kbd> type to the following interface to generate a new type. The <kbd>abc</kbd> property is no longer immutable, but the <kbd>def</kbd> property is still optional:</p>
<pre>interface Foo {<br/>    readonly abc: number;<br/>    def?: string;<br/>}<br/><br/>type TotallyMutableFoo = Mutable&lt;Foo&gt;</pre>
<p>Finally, the following code snippet declares a mapped type that can be used to remove the optional properties in a given type <kbd>T</kbd>:</p>
<pre>type Required&lt;T&gt; = {<br/>    [P in keyof T]-?: T[P];<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Conditional types</h1>
                </header>
            
            <article>
                
<p>Conditional mapped types are an advanced feature introduced in TypeScript 2.8. Previously in this chapter, we learned that we could use the <kbd>extends</kbd> keyword to declare generic constraints. When we declare a generic constraint, we are using the <kbd>extends</kbd> keyword as a kind of operator that allows us to check if a generic type (<kbd>T</kbd>) is a subtype of a given type. For example, the following code snippet declares two interfaces named <kbd>Animal</kbd> and <kbd>Dog</kbd>:</p>
<pre>interface Animal {<br/>    live(): void;<br/>}<br/>interface Dog extends Animal {<br/>    woof(): void;<br/>}</pre>
<p>We then use the <kbd>extends</kbd> keyword as a conditional operator to generate a new type:</p>
<pre>type Foo1 = Dog extends Animal ? number : string; // number<br/>type Bar1 = RegExp extends Dog ? number : string; // string</pre>
<p>Conditional types can be used to declare some complex types. For example, the <kbd>Flatten</kbd> function is a function that transforms a multi-dimensional array (<kbd>[][]</kbd>) into an array with only one dimension (<kbd>[]</kbd>). The type of the return of <kbd>Flatten</kbd> function is a conditional type, because it returns an array when a multidimensional array is provided and a number when an array with only one dimension is provided:</p>
<pre>type Flatten&lt;T&gt; = T extends any[] ? T[number] : T;<br/><br/>type arr1 = number[];<br/>type flattenArr1 = Flatten&lt;arr1&gt;; // number<br/><br/>type arr2 = number[][];<br/>type flattenArr2 = Flatten&lt;arr2&gt;; // number[]</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The infer keyword</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we have defined the <kbd>Flatten</kbd> type. However, this behavior was hardcoded to return a number when an array of one dimension is provided. This means that the <kbd>flatten</kbd> type only works as expected with arrays of numbers. Fortunately, since the TypeScript 2.8 release, we can use the <kbd>infer</kbd> keyword to overcome this limitation:</p>
<pre>type TypedFlatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T;</pre>
<p>The <kbd>infer</kbd> keyword can be used in other scenarios. For example, we can use it to infer the return type of a function:</p>
<pre>type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;<br/><br/>type func1 = () =&gt; number;<br/>type returnOfFunc1 = ReturnType&lt;func1&gt;; // number</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Built-in conditional types</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we have used the <kbd>ReturnType</kbd> type to extract the return type of a given function. The <kbd>ReturnType</kbd> type is included as a built-in type. TypeScript 2.8 includes many other types:</p>
<pre>// Exclude from T those types that are assignable to U<br/>type Exclude&lt;T, U&gt; = T extends U ? never : T;<br/><br/>// Extract from T those types that are assignable to U<br/>type Extract&lt;T, U&gt; = T extends U ? T : never;<br/><br/>// string[] | number[]<br/>type Foo2 = Extract&lt;boolean | string[] | number[], any[]&gt;;<br/><br/>// boolean<br/>type Bar2 = Exclude&lt;boolean | string[] | number[], any[]&gt;;<br/><br/>// Exclude null and undefined from T<br/>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;<br/><br/>//  Obtain the return type of a function type<br/>type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;<br/><br/></pre>
<pre>// Obtain the return type of a constructor function type<br/>type InstanceType&lt;T extends new (...args: any[]) =&gt; any&gt; = T extends new (...args: any[]) =&gt; infer R ? R : any;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The polymorphic this type</h1>
                </header>
            
            <article>
                
<p>In JavaScript, the value of the <kbd>this</kbd> operator is determined by the way a function or method is invoked. In a method, the <kbd>this</kbd> operator usually points to the class instance.</p>
<p>The polymorphic <kbd>this</kbd> type is an improved version of the original type inference for the <kbd>this</kbd> operator that introduced the following behavior as documented by Anders Hejlsberg:</p>
<ul>
<li>The type of <kbd>this</kbd> in an expression within a nonstatic class or interface member is an instance of some class that derives from the containing class, as opposed to simply an instance of the containing class.</li>
<li>The <kbd>this</kbd> keyword can be used in a type position within a nonstatic class or interface member to reference the type of this.</li>
<li>When a class or interface is referenced as a type, all occurrences of the <kbd>this</kbd> type within the class (including those inherited from base classes) are replaced with the type itself.</li>
</ul>
<p>This feature makes patterns such as fluent interfaces (<a href="https://en.wikipedia.org/wiki/Fluent_interface">https://en.wikipedia.org/wiki/Fluent_interface</a>) much easier to express and implement, as we can see in the following example:</p>
<pre>interface Person {<br/>    name?: string;<br/>    surname?: string;<br/>    age?: number;<br/>}<br/><br/>class PersonBuilder&lt;T extends Person&gt; {<br/>    protected _details: T;<br/>    public constructor() {<br/>        this._details = {} as T;<br/>    }<br/>    public currentValue(): T {<br/>        return this._details;<br/>    }<br/>    public withName(name: string): this {<br/>        this._details.name = name;<br/>        return this;<br/>    }<br/>    public withSurname(surname: string): this {<br/>        this._details.surname = surname;<br/>        return this;<br/>    }<br/>    public withAge(age: number): this {<br/>        this._details.age = age;<br/>        return this;<br/>    }<br/>}</pre>
<div class="packt_infobox"><span>A fluent interface allows us to invoke multiple methods in an object by connecting them with dots, without having to write the object name each time.</span></div>
<p>Since the class methods return the <kbd>this</kbd> type, we can invoke multiple methods without having to write the class name multiple times:</p>
<pre>let value1 = new PersonBuilder()<br/>            .withName("name")<br/>            .withSurname("surname")<br/>            .withAge(28)<br/>            .currentValue();</pre>
<p>Since the class uses the <kbd>this</kbd> type, we can extend it and the new class can then provide a fluent interface that includes the base methods as well:</p>
<pre>interface Employee extends Person {<br/>    email: string;<br/>    department: string;<br/>}<br/><br/>class EmployeeBuilder extends PersonBuilder&lt;Employee&gt; {<br/>    public withEmail(email: string) {<br/>        this._details.email = email;<br/>        return this;<br/>    }<br/>    public withDepartment(department: string) {<br/>        this._details.department = department;<br/>        return this;<br/>    }<br/>}<br/><br/>let value2 = new EmployeeBuilder()<br/>    .withName("name")<br/>    .withSurname("surname")<br/>    .withAge(28)<br/>    .withEmail("name.surname@company.com")<br/>    .withDepartment("engineering")<br/>    .currentValue();</pre>
<div class="packt_infobox">In <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml">Chapter 6</a>, <em>Understanding the Runtime,</em> we will learn much more about the <kbd>this</kbd> operator.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ambient declarations</h1>
                </header>
            
            <article>
                
<p>The ambient declaration allows you to create a variable in your TypeScript code that will not be translated into JavaScript at compilation time. This feature was designed to make the integration with the existing JavaScript code and the <strong>Document Object Model</strong> (<strong>DOM</strong>) and <strong>Browser Object Model</strong> (<strong>BOM</strong>) easier. Let's look at an example:</p>
<pre>customConsole.log("A log entry!");  // error</pre>
<p>If you try to call the member log of an object named <kbd>customConsole</kbd>, TypeScript will let us know that the <kbd>customConsole</kbd> object has not been declared:</p>
<pre>// Cannot find name 'customConsole'</pre>
<p>This is not a surprise. However, sometimes we want to invoke an object that has not been defined, for example, the <kbd>console</kbd> or <kbd>window</kbd> objects:</p>
<pre>console.log("Log Entry!");<br/>const host = window.location.hostname;</pre>
<p>When we access the DOM or BOM objects, we don't get an error because these objects have already been declared in a special TypeScript file known as <strong>declaration files</strong>. You can use the <kbd>declare</kbd> operator to create an ambient declaration.</p>
<p>In the following code snippet, we will declare an interface that is implemented by the <kbd>customConsole</kbd> object. We then use the <kbd>declare</kbd> operator to add the <kbd>customConsole</kbd> object to the scope:</p>
<pre>interface ICustomConsole {<br/>    log(arg: string) : void;<br/>}<br/>declare var customConsole : ICustomConsole;</pre>
<div class="packt_infobox">Interfaces are explained in greater detail in <a href="841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml">Chapter 4</a><em>, Object-Oriented Programming with TypeScript.</em></div>
<p>We can then use the <kbd>customConsole</kbd> object without compilation errors:</p>
<pre>customConsole.log("A log entry!"); // ok</pre>
<p>TypeScript includes, by default, a file named <kbd>lib.d.ts</kbd> that provides interface declarations for the built-in JavaScript library as well as the DOM.</p>
<p>Declaration files use the file extension <kbd>.d.ts</kbd> and are used to increase the TypeScript compatibility with third-party libraries and runtime environments, such as Node.js or a browser.</p>
<div class="packt_infobox">We will learn how to work with declaration files in <a href="90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml">Chapter 5</a><em>, Working with Dependencies.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type declarations – .d.ts</h1>
                </header>
            
            <article>
                
<p>Sometimes, we will need to consume an existing JavaScript file, but we will not be able to migrate it to TypeScript. A common example of this scenario is when we consume a third-party JavaScript library.</p>
<p>If the library is open source, we could contribute to it by migrating it to TypeScript. However, sometimes, using TypeScript might not align with the preferences of the library authors, or the migration may require a significant amount of work. TypeScript solves this problem by allowing us to create special kinds of files known as type declarations or type definitions.</p>
<p>In the previous chapter, we learned that, by default, TypeScript includes a  <kbd>lib.d.ts</kbd> file that provides interface declarations for the built-in JavaScript objects, as well as the DOM and BOM APIs.</p>
<p>The type definition files contain the type declarations of third-party libraries. These files facilitate the integration between the existing JavaScript libraries and TypeScript.</p>
<p>To take advantage of all the TypeScript features while consuming a JavaScript library, we need to install the type definition file of such library. Fortunately, we don't need to create the type definition files by hand, because there is an open source project known as <strong>DefinitelyTyped</strong> that already contains some type definition files for many of the existing JavaScript libraries.</p>
<p>In the early days of TypeScript development, developers had to manually download and install the type definition files from the DefinitelyTyped project website, but those days are long gone and today we can use the node package manager (npm) to install and manage the type definition files required by our TypeScript application.</p>
<div class="packt_infobox">We will learn how to work with declaration files in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a><em>, Automating Your Development Workflow.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about many of the features of the TypeScript type system. At this point, we should now have a good understanding of concepts such type inference, non-nullable types, structural typing, and control flow analysis.</p>
<p>In the next chapter, we will learn more about the usage of functions in TypeScript.</p>


            </article>

            
        </section>
    </div>



  </body></html>