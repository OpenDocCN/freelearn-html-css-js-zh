- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Test-Driving Svelte Stores
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动 Svelte 存储
- en: '`subscribe` mechanism – that helps ensure that all components maintain a consistent
    view of each variable’s current value.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe` 机制 – 该机制有助于确保所有组件保持对每个变量当前值的持续视图。'
- en: 'When it comes to writing tests for components that involve stores, you’ve got
    to write tests for two halves: the first half for the *observation* of the store
    value and the second half for the *setting* of the store value.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编写涉及存储的组件的测试时，你必须为存储的两个部分编写测试：第一部分是存储值的 *观察*，第二部分是存储值的 *设置*。
- en: Because stores are an internal design decision, there’s no need to write a Playwright
    test specifically for the introduction of stores.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储是一个内部设计决策，因此不需要为存储的引入编写特定的 Playwright 测试。
- en: 'This chapter covers the following key topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下关键主题：
- en: Designing a store for birthdays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为生日设计存储
- en: Writing tests for reading store values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为读取存储值编写测试
- en: Writing tests for updating store values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为更新存储值编写测试
- en: By the end of the chapter, you’ll have a good understanding of writing unit
    tests for Svelte store objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解为 Svelte 存储对象编写单元测试。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter15/Complete](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter15/Complete).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的代码可以在网上找到，地址为 [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter15/Complete](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter15/Complete)。
- en: Designing a store for birthdays
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生日设计存储
- en: 'The code for this chapter includes a single store in the `src/stores/birthdays.js`
    file with the following content:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包括 `src/stores/birthdays.js` 文件中的一个存储，其内容如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The idea of the `birthdays` store is to store whatever birthdays have been returned
    from the SvelteKit page load. It’s kept up to date by the page route component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`birthdays` 存储的想法是存储从 SvelteKit 页面加载返回的所有生日。它通过页面路由组件保持更新。'
- en: There’s also a new `NextBirthday` component that reads the store and displays
    a message at the top of the page alerting the user to the next upcoming birthday.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个新的 `NextBirthday` 组件，该组件读取存储并显示页面顶部的消息，提醒用户即将到来的生日。
- en: Stores aren’t necessary for this change
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个变更，存储不是必需的
- en: This feature could have been written simply by passing `birthdays` as a prop
    to `NextBirthday`. It’s certainly worth avoiding stores if you can simply use
    component props. This chapter’s code is intended to be educative only; in reality
    I would not use a store for this use case.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能可以通过将 `birthdays` 作为属性传递给 `NextBirthday` 来简单地编写。如果你可以简单地使用组件属性来避免存储，这当然值得。本章的代码旨在仅用于教育目的；在现实中，我不会为这个用例使用存储。
- en: '![Figure 15.1 – The Birthdays application with the new alert](img/Figure_15.1_B19611.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 带有新警报的生日应用](img/Figure_15.1_B19611.jpg)'
- en: Figure 15.1 – The Birthdays application with the new alert
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 带有新警报的生日应用
- en: The code for the `NextBirthday` component is not trivial, so you may be interested
    in checking it out online. In particular, the unit tests make use of the `vi.useFakeTimers`
    and `vi.setSystemTime` functions to ensure that the test checks aren’t affected
    by the passing of real time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`NextBirthday` 组件的代码并不简单，因此你可能对在线查看它感兴趣。特别是，单元测试使用了 `vi.useFakeTimers` 和 `vi.setSystemTime`
    函数来确保测试检查不受真实时间流逝的影响。'
- en: That’s all the design necessary. Let’s look at the tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的设计就这么多。让我们看看测试。
- en: Writing tests for reading store values
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为读取存储值编写测试
- en: 'There are at least two tests needed when reading the store value: first, for
    the initial value when the component loads, and second, when an update comes in.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 读取存储值时至少需要两个测试：首先，当组件加载时的初始值，其次，当更新到来时。
- en: 'Here’s an example of the first, which you’ll find in `src/routes/birthdays/NextBirthday.test.js`.
    Notice how we import the `birthdays` store with the name, `birthdaysStore`, which
    makes it very clear in the test that the object imported is the store. The *Arrange*
    phase of the test then calls `birthdayStore.set` to prime the store with its initial
    value before the component is mounted:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，你可以在 `src/routes/birthdays/NextBirthday.test.js` 中找到它。注意我们如何使用名称 `birthdaysStore`
    导入 `birthdays` 存储，这使得在测试中非常清楚地表明导入的对象是存储。测试的 *Arrange* 阶段随后调用 `birthdayStore.set`
    来在组件挂载之前用其初始值初始化存储：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may be curious why the year `2056` is mentioned in the expectation. That’s
    because we used `vi.setSystemTime` to set the current date to a fixed date:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能好奇为什么期望中提到了年份`2056`。那是因为我们使用了`vi.setSystemTime`将当前日期设置为固定日期：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The second test has the same initial setting, but now the `render` call moves
    into the *Arrange* phase, and the *Act* phase is now a second call to `birthdayStore.set`.
    Notice also that this call needs to be marked with `await` so that the component
    has the opportunity to re-render:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试有相同的初始设置，但现在`render`调用移动到了*安排*阶段，而*行动*阶段现在是对`birthdayStore.set`的第二次调用。注意，这个调用需要标记为`await`，以便组件有机会重新渲染：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This test will only pass if the component is set to observe the store. You
    can see this in `src/routes/birthdays/NextBirthday.svelte`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当组件设置为观察存储时，这个测试才会通过。你可以在`src/routes/birthdays/NextBirthday.svelte`中看到这一点：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The test would fail if the argument to the function was `birthdays` and not
    `$birthdays`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数的参数是`birthdays`而不是`$birthdays`，测试将失败。
- en: Next, let’s look at the tests for setting the value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看设置值的测试。
- en: Writing tests for updating store values
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写更新存储值的测试
- en: The page route component is responsible for ensuring the birthdays that are
    passed into it are saved in the store.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 页面路由组件负责确保传递给它的生日被保存在存储中。
- en: 'Here’s the first test from the `src/routes/birthdays/page.test.js` file, which
    uses `birthdaysStore.subscribe` to set a `storedBirthdays` value within the test.
    After rendering the component, it expects the `storedBirthdays` value to contain
    the birthdays:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是来自`src/routes/birthdays/page.test.js`文件的第一个测试，它使用`birthdaysStore.subscribe`在测试中设置一个`storedBirthdays`值。在渲染组件后，它期望`storedBirthdays`值包含生日：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A second test is then needed to ensure the store value is updated whenever
    the component prop changes. This test makes use of the `$set` function on the
    returned component to update the props on the component:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 需要第二个测试来确保组件属性更改时存储值会更新。这个测试利用了返回的组件上的`$set`函数来更新组件的属性：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And that’s all there is to it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。
- en: Summary
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This short chapter covered some important concepts for testing Svelte stores:
    first, how to test the two halves of observing and setting Svelte store values,
    and second, how you can rename the store import so that it’s more readable within
    your tests. In our case, that meant renaming `birthdays` as `birthdaysStore`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这短短的一章涵盖了测试Svelte存储的一些重要概念：首先，如何测试观察和设置Svelte存储值的两个部分，其次，你如何重命名存储导入，使其在测试中更具可读性。在我们的例子中，这意味着将`birthdays`重命名为`birthdaysStore`。
- en: You’ve also seen how to call the store’s `set` and `subscribe` methods within
    your tests, and how to use Svelte’s `$set` function on the component instance
    to update props to a previously rendered component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也已经看到了如何在测试中调用存储的`set`和`subscribe`方法，以及如何在组件实例上使用Svelte的`$set`函数来更新先前渲染的组件的属性。
- en: Taken together, these techniques highlight how advanced Svelte features are
    still testable at the unit level if that’s desired. Of course, you might get just
    as much value from writing Playwright tests that can happily ignore the internal
    mechanics of Svelte stores.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些技术突出了如果需要的话，Svelte的高级特性在单元测试级别仍然是可测试的。当然，你可能也会从编写可以愉快地忽略Svelte存储内部机制的Playwright测试中获得同样多的价值。
- en: 'The next chapter covers a more complicated topic: **service workers**.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖一个更复杂的话题：**服务工作者**。
