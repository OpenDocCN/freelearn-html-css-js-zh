<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Playing with Syntax"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Playing with Syntax</h1></div></div></div><p>
<span class="strong"><strong>JavaScript</strong></span> was lacking behind some other programming languages when compared to various syntactic forms such as declaring constant variables, declaring block scoped variables, extracting data from arrays, shorter syntax for declaring functions and so on. <span class="strong"><strong>ES6</strong></span> adds up a lot of new syntax-based features to JavaScript, which helps the developers to write less and do more. ES6 also prevents programmers from using various hacks for achieving various goals, which have negative performance impact and made code harder to read. In this chapter, we will look at the new syntactic features, introduced by ES6.</p><p>In this chapter, we'll cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating the block scoped variables using the <code class="literal">let</code> keyword</li><li class="listitem" style="list-style-type: disc">Creating constant variables using the <code class="literal">const</code> keyword</li><li class="listitem" style="list-style-type: disc">The spread operator and the rest parameter</li><li class="listitem" style="list-style-type: disc">Extracting the data from iterables and objects using the destructuring assignment</li><li class="listitem" style="list-style-type: disc">The arrow functions</li><li class="listitem" style="list-style-type: disc">The new syntaxes for creating the object properties</li></ul></div><div class="section" title="The let keyword"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>The let keyword</h1></div></div></div><p>The ES6 <code class="literal">let</code> keyword is used to declare a block scoped variable, optionally initializing it to a value. The programmers who come from other programming language background, but new to JavaScript, often <a id="id0" class="indexterm"/>end up writing error-prone JavaScript programs, believing that the JavaScript variables are block scoped. Almost every popular programming<a id="id1" class="indexterm"/> language has the same rules when it comes to the variable scopes, but JavaScript acts a bit different due to a lack of the block scoped variables. Due to the fact that JavaScript variables are not block scoped, there are chances of memory leak and also the JavaScript programs are harder to read and debug.</p><div class="section" title="Declaring function scoped variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Declaring function scoped variables</h2></div></div></div><p>The JavaScript variables that are declared using the <code class="literal">var</code> keyword are called as <span class="strong"><strong>function scoped</strong></span> variables. The<a id="id2" class="indexterm"/> function scoped variables are accessible globally to the script, that is, throughout the script, if declared outside a function. Similarly, if the function scoped variables are declared inside a function, then they become accessible throughout the function, but not outside the function.</p><p>Here is an example that shows how to create the function-scoped variables:</p><div class="informalexample"><pre class="programlisting">var a = 12; //accessible globally

function myFunction()
{
  console.log(a);

  var b = 13; //accessible throughout function

  if(true)
  {
    var c = 14; //accessible throughout function
    console.log(b);
  }

  console.log(c);
}

myFunction();</pre></div><p>The output of the code is:</p><div class="informalexample"><pre class="programlisting">12
13
14</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>Here, you can see that the <code class="literal">c</code> variable is accessible outside the <code class="literal">if</code> statement, but this is not the case in other programming languages. So, the programmers coming from other languages would expect the <code class="literal">c</code> variable to be undefined outside the <code class="literal">if</code> statement, but that's not the case. Therefore, ES6 had introduced the <code class="literal">let</code> keyword, which can be used for creating variables that are block scoped.</p></div><div class="section" title="Declaring block scoped variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Declaring block scoped variables</h2></div></div></div><p>Variables that are<a id="id3" class="indexterm"/> declared using the <code class="literal">let</code> keyword are called as block scoped variables. The block scoped variables behave the same way as the function scoped variables when declared outside a function, that is, they are accessible globally. But when the block scoped variables are declared inside a block, then they are accessible inside the block that they are defined in (and also any sub-blocks) but not outside the block.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>A block is used to group zero or more statements. A pair of curly brackets delimits the block, that is <code class="literal">{}</code>.</p></div></div><p>Let's take the previous <a id="id4" class="indexterm"/>example script, replace <code class="literal">var</code> with the <code class="literal">let</code> keyword, and see the output:</p><div class="informalexample"><pre class="programlisting">let a = 12; //accessible globally

function myFunction()
{
  console.log(a);

  let b = 13; //accessible throughout function

  if(true)
  {
    let c = 14; //accessible throughout the "if" statement
    console.log(b);
  }

  console.log(c);
}

myFunction();</pre></div><p>The output of the code is:</p><div class="informalexample"><pre class="programlisting">12
13
Reference Error Exception</pre></div><p>Now, the output is as expected by a programmer who is used to another programming language.</p></div><div class="section" title="Re-declaring variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Re-declaring variables</h2></div></div></div><p>When you declare a variable <a id="id5" class="indexterm"/>using the <code class="literal">var</code> keyword that is already declared using <code class="literal">var</code> keyword (in the same scope) then it's overwritten. Consider this example:</p><div class="informalexample"><pre class="programlisting">var a = 0;
var a = 1;

console.log(a);

function myFunction()
{
  var b = 2;
  var b = 3;

  console.log(b);
}

myFunction();</pre></div><p>The output of the code is:</p><div class="informalexample"><pre class="programlisting">1
3</pre></div><p>The output is as expected. But the variables created using the <code class="literal">let</code> keyword don't behave in the same way.</p><p>When you declare a <a id="id6" class="indexterm"/>variable using the <code class="literal">let</code> keyword that is already declared using the <code class="literal">let</code> keyword in the same scope, then it throws a <code class="literal">TypeError</code> exception. Consider this example:</p><div class="informalexample"><pre class="programlisting">let a = 0;
let a = 1; //TypeError

function myFunction()
{
  let b = 2;
  let b = 3; //TypeError

  if(true)
  {
    let c = 4;
    let c = 5; //TypeError
  }
}

myFunction();</pre></div><p>When you declare a variable with a name that's already accessible in a function (or inner function), or is a sub-block using <code class="literal">var</code> or the <code class="literal">let</code> keyword respectively, then it's a different variable. Here, is an example that shows the behavior:</p><div class="informalexample"><pre class="programlisting">var a = 1;
let b = 2;

function myFunction()
{
  var a = 3; //different variable
  let b = 4; //different variable

  if(true)
  {
    var a = 5; //overwritten
    let b = 6; //different variable

    console.log(a);
    console.log(b);
  }

  console.log(a);
  console.log(b);
}

myFunction();

console.log(a);
console.log(b);</pre></div><p>The output <a id="id7" class="indexterm"/>of the code is:</p><div class="informalexample"><pre class="programlisting">5
6
5
4
1
2</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>
<code class="literal">var</code> versus <code class="literal">let</code>, which one to use?</p><p>When writing the ES6 code, it is recommended to switch to using the <code class="literal">let</code> keyword because it makes scripts more memory friendly, prevents scoping mistakes, prevents accidental bugs, and makes the code easier to read. But if you are already addicted to the <code class="literal">var</code> keyword and comfortable using it, then you can still use this.</p></div></div><p>You may be wondering why not just make the <code class="literal">var</code> keyword to define the block-scoped variables instead of introducing the <code class="literal">let</code> keyword? The reason why the <code class="literal">var</code> keyword wasn't made enough to define block-scoped variables, instead of introducing the <code class="literal">let</code> keyword, was for the sake of backward compatibility.</p></div></div></div>
<div class="section" title="The const keyword"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The const keyword</h1></div></div></div><p>The ES6 <code class="literal">const</code> keyword is used to declare the read-only variables, that is, the variables whose value cannot be<a id="id8" class="indexterm"/> reassigned. Before ES6, the programmers usually used to prefix the variables that were supposed to be constant. For example, take a look <a id="id9" class="indexterm"/>at the following code:</p><div class="informalexample"><pre class="programlisting">var const_pi = 3.141;
var r = 2;
console.log(const_pi * r * r); //Output "12.564"</pre></div><p>The value of <code class="literal">pi</code> should always remain constant. Here, although we have prefixed it, there is still a chance that we might accidentally change its value somewhere in the program, as they're no native protection to the value of <code class="literal">pi</code>. Prefixing is just not enough to keep the track of the constant variables.</p><p>Therefore, the <code class="literal">const</code> keyword was introduced to provide a native protection to the constant variables. So, the previous program should be written in this way in ES6:</p><div class="informalexample"><pre class="programlisting">const pi = 3.141;
var r = 2;

console.log(pi * r * r); //Output "12.564"

pi = 12; //throws read-only exception</pre></div><p>Here, when we tried to change the value of <code class="literal">pi</code>, a read-only exception was thrown.</p><div class="section" title="The scope of constant variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>The scope of constant variables</h2></div></div></div><p>Constant variables<a id="id10" class="indexterm"/> are block-scoped variables, that is, they follow the same scoping rules as the variables that are declared using the <code class="literal">let</code> keyword. Here is an example, which shows the scope of the constant variables:</p><div class="informalexample"><pre class="programlisting">const a = 12; //accessible globally

function myFunction()
{
  console.log(a);

  const b = 13; //accessible throughout function

  if(true)
  {
    const c = 14; //accessible throughout the "if" statement
    console.log(b);
  }

  console.log(c);
}

myFunction();</pre></div><p>The output of the preceding code is:</p><div class="informalexample"><pre class="programlisting">12
13
ReferenceError Exception</pre></div><p>Here, we can <a id="id11" class="indexterm"/>see that the constant variables behave in the same way as the block scoped variables, when it comes to the scoping rules.</p></div><div class="section" title="Referencing the objects using constant variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Referencing the objects using constant variables</h2></div></div></div><p>When we assign an object to a variable, the reference of the object is what the variable holds and not the object itself. So, when <a id="id12" class="indexterm"/>assigning an object to a constant variable, the reference of the object becomes constant to that variable and not to the object itself. Therefore, the object is mutable. </p><p>Consider this example:</p><div class="informalexample"><pre class="programlisting">const a = {
  "name" : "John"
};

console.log(a.name);

a.name = "Eden";

console.log(a.name);

a = {}; //throws read-only exception</pre></div><p>The output of the preceding code is:</p><div class="informalexample"><pre class="programlisting">John
Eden
a is read only: Exception</pre></div><p>In this example, the <code class="literal">a</code> variable stores the address (that is, reference) of the object. So the address of the object is the value of the <code class="literal">a</code> variable, and it cannot be changed. But the object is mutable. So when we tried to assign another object to the <code class="literal">a</code> variable, we got an exception as we were trying to change the value of the <code class="literal">a</code> variable.</p></div></div>
<div class="section" title="Default parameter values"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Default parameter values</h1></div></div></div><p>In JavaScript there is no defined way to assign the default values to the function parameters that are not<a id="id13" class="indexterm"/> passed. So, the programmers usually check for the parameters with the <code class="literal">undefined</code> value (as it is the default value for the missing parameters), and assign the default values to them. Here is an example, which shows how to do this:</p><div class="informalexample"><pre class="programlisting">function myFunction(x, y, z)
{
  x = x === undefined ? 1 : x;
  y = y === undefined ? 2 : y;
  z = z === undefined ? 3 : z;

  console.log(x, y, z); //Output "6 7 3"
}
myFunction(6, 7);</pre></div><p>ES6 provides a new syntax that can be used to do this in an easier way. Here is the code which demonstrates how to do this in ES6:</p><div class="informalexample"><pre class="programlisting">function myFunction(x = 1, y = 2, z = 3)
{
  console.log(x, y, z); // Output "6 7 3"
}

myFunction(6,7);</pre></div><p>Also, passing <code class="literal">undefined</code> is considered as missing an argument. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function myFunction(x = 1, y = 2, z = 3)
{
  console.log(x, y, z); // Output "1 7 9"
}

myFunction(undefined,7,9);</pre></div><p>Defaults can also be expressions. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function myFunction(x = 1, y = 2, z = 3 + 5)
{
  console.log(x, y, z); // Output "6 7 8"
}

myFunction(6,7);</pre></div></div>
<div class="section" title="The spread operator"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>The spread operator</h1></div></div></div><p>
<span class="strong"><strong>A spread operator</strong></span><a id="id14" class="indexterm"/> is represented by the "<code class="literal">…</code>" token. A spread operator splits an iterable object into the individual values.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>An iterable is an object that contains a group of values, and implements ES6 iterable protocol to let us iterate through its values. An array is an example of built in an iterable object.</p></div></div><p>A spread operator can be placed wherever multiple function arguments or multiple elements (for array literals) are expected in code.</p><p>The spread operator is commonly used to spread the values of an iterable object into the arguments of a function. Let's take an example of an array and see how to split it into the arguments of a function.</p><p>Before ES6, for providing the values of an array as function argument, the programmers used the <code class="literal">apply()</code> method<a id="id15" class="indexterm"/> of functions. Here is an example:</p><div class="informalexample"><pre class="programlisting">function myFunction(a, b)
{
  return a + b;
}

var data = [1, 4];
var result = myFunction.apply(null, data);

console.log(result); //Output "5"</pre></div><p>Here, the apply method takes an array, extracts the values, passes them as individual arguments to the function, and then calls it.</p><p>ES6 provides an easy way to do this, using the spread operator. Here is an example:</p><div class="informalexample"><pre class="programlisting">function myFunction(a, b)
{
 return a + b;
}

let data = [1, 4];
let result = myFunction(...data);
console.log(result); //Output "5"</pre></div><p>During runtime, before the JavaScript interpreter calls the <code class="literal">myFunction</code> function, it replaces <code class="literal">…data</code> with the <code class="literal">1,4</code> expression:</p><div class="informalexample"><pre class="programlisting">let result = myFunction(...data);</pre></div><p>The previous code is replaced with:</p><div class="informalexample"><pre class="programlisting">let result = myFunction(1,4);</pre></div><p>After this, the<a id="id16" class="indexterm"/> function is called.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>A spread operator doesn't call the <code class="literal">apply()</code> method. The JavaScript runtime engine spreads the array using the iteration protocols, and has nothing to do with the <code class="literal">apply()</code> method, but the behavior is same.</p></div></div><div class="section" title="Other usages of the spread operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Other usages of the spread operator</h2></div></div></div><p>The spread operator is not just limited to spreading an iterable object into the function arguments, but it can<a id="id17" class="indexterm"/> be used wherever multiple elements (for array literals) are expected in code. So it has many uses. Let's see some other use cases of the spread operator for arrays.</p><div class="section" title="Making array values a part of another array"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Making array values a part of another array</h3></div></div></div><p>It can also be used to<a id="id18" class="indexterm"/> make the array values a part of another array. Here is an example code that demonstrates how to make the values of an existing array a part of another array while creating it.</p><div class="informalexample"><pre class="programlisting">let array1 = [2,3,4];
let array2 = [1, ...array1, 5, 6, 7];

console.log(array2); //Output "1, 2, 3, 4, 5, 6, 7"</pre></div><p>Here the following line:</p><div class="informalexample"><pre class="programlisting">let array2 = [1, ...array1, 5, 6, 7];</pre></div><p>Will be replaced with the following line:</p><div class="informalexample"><pre class="programlisting">let array2 = [1, 2, 3, 4, 5, 6, 7];</pre></div></div><div class="section" title="Pushing the values of an array into another array"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Pushing the values of an array into another array</h3></div></div></div><p>Sometimes, we may <a id="id19" class="indexterm"/>need to push the values of an existing array into the end of another existing array.</p><p>Before ES6, this is how the programmers used to do it:</p><div class="informalexample"><pre class="programlisting">var array1 = [2,3,4];
var array2 = [1];

Array.prototype.push.apply(array2, array1);

console.log(array2); //Output "1, 2, 3, 4"</pre></div><p>But in ES6 we have a much cleaner way to do it, which is as follows:</p><div class="informalexample"><pre class="programlisting">let array1 = [2,3,4];
let array2 = [1];

array2.push(...array1);

console.log(array2); //Output "1, 2, 3, 4"</pre></div><p>Here the push method takes a series of variables, and adds them to the end of the array on which it is called.</p><p>Here the following line:</p><div class="informalexample"><pre class="programlisting">array2.push(...array1);</pre></div><p>Will be replaced<a id="id20" class="indexterm"/> with the following line:</p><div class="informalexample"><pre class="programlisting">array2.push(2, 3, 4);</pre></div></div></div><div class="section" title="Spreading multiple arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Spreading multiple arrays</h2></div></div></div><p>Multiple arrays can<a id="id21" class="indexterm"/> be spread on a single line of expression. For example, take the following code:</p><div class="informalexample"><pre class="programlisting">let array1 = [1];
let array2 = [2];
let array3 = [...array1, ...array2, ...[3, 4]];//multi array spread
let array4 = [5];

function myFunction(a, b, c, d, e)
{
  return a+b+c+d+e;
}

let result = myFunction(...array3, ...array4); //multi array spread

console.log(result); //Output "15"</pre></div></div></div>
<div class="section" title="The rest parameter"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The rest parameter</h1></div></div></div><p>The rest parameter is also<a id="id22" class="indexterm"/> represented by the "<code class="literal">…</code>" token. The last parameter of a function prefixed with "<code class="literal">…</code>" is called as a rest parameter. The rest parameter is an array type, which contains the rest of the parameters of a function when number of arguments exceeds the number of named parameters.</p><p>The rest parameter is used to capture a variable number of the function arguments from within a function.</p><p>Before ES6, the programmers used the <code class="literal">arguments</code> object of a function to retrieve the extra arguments, passed to the function. The <code class="literal">arguments</code> object is not an array, but it provides some interfaces that are similar to an array.</p><p>Here is a code<a id="id23" class="indexterm"/> example that shows how to use the <code class="literal">arguments</code> object to retrieve the extra arguments:</p><div class="informalexample"><pre class="programlisting">function myFunction(a, b)
{
  var args = Array.prototype.slice.call(arguments, myFunction.length);

  console.log(args);
}

myFunction(1, 2, 3, 4, 5); //Output "3, 4, 5"</pre></div><p>In ES6, this can be done in a much easier and cleaner way, using the rest parameter. Here is an example of using the rest parameter:</p><div class="informalexample"><pre class="programlisting">function myFunction(a, b, ...args)
{
  console.log(args); //Output "3, 4, 5"
}

myFunction(1, 2, 3, 4, 5);</pre></div><p>The <code class="literal">arguments</code> object is not an array object. Therefore, to do array operations on the <code class="literal">arguments</code> object, you need to first convert it to an array. As the ES6 rest parameter is an array type, it's easier to work with it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>What is the "…" token called?</p><p>The "…" token is called as the spread operator or rest parameter, depending on where and how it's used.</p></div></div></div>
<div class="section" title="The destructuring assignment"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>The destructuring assignment</h1></div></div></div><p>The destructuring<a id="id24" class="indexterm"/> assignment is an expression that allows you to assign the values or properties of an iterable or object, to the variables, using a syntax that looks similar to the array or object construction literals respectively.</p><p>A destructuring assignment makes it easy to extract data from iterables or objects by providing a shorter syntax. A destructuring assignment is already present in the programming languages, such as <a id="id25" class="indexterm"/>
<span class="strong"><strong>Perl</strong></span> and <span class="strong"><strong>Python</strong></span>, and works the same way everywhere.</p><p>There are two kinds of destructuring assignment expressions—the array and object destructuring<a id="id26" class="indexterm"/> assignment. Let's see each of them in details.</p><div class="section" title="The array destructuring assignment"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>The array destructuring assignment</h2></div></div></div><p>An array destructuring assignment is used to extract the values of an iterable object and assign them to the variables. It's named as the <span class="emphasis"><em>array destructuring assignment</em></span> because the expression<a id="id27" class="indexterm"/> is similar to an array construction literal.</p><p>Before ES6, the<a id="id28" class="indexterm"/> programmers used to do it this way to assign the values of an array to the variables:</p><div class="informalexample"><pre class="programlisting">var myArray = [1, 2, 3];
var a = myArray[0];
var b = myArray[1];
var c = myArray[2];</pre></div><p>Here, we are extracting the values of an array and assigning them to the <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code> variables respectively.</p><p>In ES6, we can do this in just one line statement using the array destructuring assignment:</p><div class="informalexample"><pre class="programlisting">let myArray = [1, 2, 3];
let a, b, c;

[a, b, c] = myArray; //array destructuring assignment syntax</pre></div><p>As you see, the <code class="literal">[a, b, c]</code> is the array destructuring expression.</p><p>On the left-hand side of the array destructuring statement, we need to place the variables to which we want to assign the array values, using syntax similar to an array literal. On right-hand side, we need to place an array (actually any iterable object) whose values we want to extract.</p><p>The previous example code can be made even shorter in this way:</p><div class="informalexample"><pre class="programlisting">let [a, b, c] = [1, 2, 3];</pre></div><p>Here we create the variables on the same statement and instead of providing the array variable, we provide the array with a construction literal.</p><p>If there are fewer variables than items in the array, then only the first items are considered.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>If you place a non-iterable object on the right-hand side of the array destructuring assignment syntax, then a <code class="literal">TypeError</code> exception is thrown.</p></div></div><div class="section" title="Ignoring values"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Ignoring values</h3></div></div></div><p>We can also<a id="id29" class="indexterm"/> ignore some of the values of the iterable. Here is example code, which shows how to do this:</p><div class="informalexample"><pre class="programlisting">let [a, , b] = [1, 2, 3];

console.log(a);
console.log(b);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
3</pre></div></div><div class="section" title="Using the rest operator in the array destructuring assignment"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Using the rest operator in the array destructuring assignment</h3></div></div></div><p>We can prefix the last <a id="id30" class="indexterm"/>variable of the array destructuring expression using the "<code class="literal">…</code>" token. In this case, the variable is always converted into an array object, which holds the rest of the values of the iterable object, if the number of other variables is less than the values in the iterable object.</p><p>Consider this example to understand it:</p><div class="informalexample"><pre class="programlisting">let [a, ...b] = [1, 2, 3, 4, 5, 6];

console.log(a);
console.log(Array.isArray(b));
console.log(b);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
true
2,3,4,5,6</pre></div><p>In the previous example code, you can see that the <code class="literal">b</code> variable is converted into an array, and it holds all the other values of the right-hand side array.</p><p>Here the "<code class="literal">…</code>" token is called as the<a id="id31" class="indexterm"/> <span class="strong"><strong>rest operator</strong></span>.</p><p>We can also ignore the values while using the rest operator. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">let [a, , ,...b] = [1, 2, 3, 4, 5, 6];

console.log(a);
console.log(b);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">1
4,5,6</pre></div><p>Here, we ignored<a id="id32" class="indexterm"/> the <code class="literal">2,</code> <code class="literal">3</code> values.</p></div><div class="section" title="Default values for variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Default values for variables</h3></div></div></div><p>While destructuring, you <a id="id33" class="indexterm"/>can also provide the default values to the variables if an array index is <code class="literal">undefined</code>. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">let [a, b, c = 3] = [1, 2];
console.log(c); //Output "3"</pre></div></div><div class="section" title="Nested array destructuring"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Nested array destructuring</h3></div></div></div><p>We can also extract the values from a multi-dimensional array and assign them to variables. Here is an<a id="id34" class="indexterm"/> example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">let [a, b, [c, d]] = [1, 2, [3, 4]];</pre></div></div><div class="section" title="Using the destructuring assignment as a parameter"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Using the destructuring assignment as a parameter</h3></div></div></div><p>We can also use the<a id="id35" class="indexterm"/> array destructuring expression as the function parameter for extracting the values of an iterable object, passed as argument into the function parameters. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function myFunction([a, b, c = 3])
{
  console.log(a, b, c); //Output "1 2 3"
}

myFunction([1, 2]);</pre></div><p>Earlier in this chapter, we saw that if we pass <code class="literal">undefined</code> as an argument to a function call, then JavaScript checks for the default parameter value. So, we can provide a default array here too, which will be used if the argument is <code class="literal">undefined</code>. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function myFunction([a, b, c = 3] = [1, 2, 3])
{
  console.log(a, b, c);  //Output "1 2 3"
}

myFunction(undefined);</pre></div><p>Here, we passed <code class="literal">undefined</code> as an argument and therefore, the default array, which is <code class="literal">[1, 2, 3]</code>, was used<a id="id36" class="indexterm"/> for extracting the values.</p></div></div><div class="section" title="The object destructuring assignment"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>The object destructuring assignment</h2></div></div></div><p>An object destructuring assignment is used to the extract property values of an object and assign them to the <a id="id37" class="indexterm"/>variables.</p><p>Before ES6, the <a id="id38" class="indexterm"/>programmers used to do it in the following way to assign the values of an object's properties to the variables:</p><div class="informalexample"><pre class="programlisting">var object = {"name" : "John", "age" : 23};
var name = object.name;
var age = object.age;</pre></div><p>In ES6, we can do this in just one line statement, using the object destructuring assignment:</p><div class="informalexample"><pre class="programlisting">let object = {"name" : "John", "age" : 23};
let name, age;

({name, age} = object); //object destructuring assignment syntax</pre></div><p>On the left-hand side of the object destructuring statement, we need to place the variables to which we want to assign the object property values using syntax similar to object literal. On right-hand side, we need to place an object whose property values we want to extract are finally close the statement using the <code class="literal">( )</code> token.</p><p>Here the variable names must be same as the object property names. If you want to assign different variable names, then you can do it this way:</p><div class="informalexample"><pre class="programlisting">let object = {"name" : "John", "age" : 23};
let x, y;

({name: x, age: y} = object);</pre></div><p>The previous code can be made even shorter this way:</p><div class="informalexample"><pre class="programlisting">let {name: x, age: y} = {"name" : "John", "age" : 23};</pre></div><p>Here we are create the variables and object on the same line. We don't need to close the statement using the <code class="literal">( )</code> token, as we are creating the variables on the same statement.</p><div class="section" title="Default values for the variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Default values for the variables</h3></div></div></div><p>You can also provide the default values to the variables, if the object property is <code class="literal">undefined</code> while<a id="id39" class="indexterm"/> destructuring. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">let {a, b, c = 3} = {a: "1", b: "2"};
console.log(c); //Output "3"</pre></div></div><div class="section" title="Destructuring computed property names"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Destructuring computed property names</h3></div></div></div><p>Some property names<a id="id40" class="indexterm"/> are constructed dynamically using expressions. In this case, to extract the property values, we can use the <code class="literal">[ ]</code> token to provide the property name an expression. Here is an example:</p><div class="informalexample"><pre class="programlisting">let {["first"+"Name"]: x} = { firstName: "Eden" };
console.log(x); //Output "Eden"</pre></div></div><div class="section" title="Destructuring nested objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Destructuring nested objects</h3></div></div></div><p>We can also the<a id="id41" class="indexterm"/> extract property values from the nested objects, that is, the objects within the objects. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">var {name, otherInfo: {age}} = {name: "Eden", otherInfo: {age: 23}};
console.log(name, age); //Eden 23</pre></div></div><div class="section" title="Using the object destructuring assignment as a parameter"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Using the object destructuring assignment as a parameter</h3></div></div></div><p>Just like the array<a id="id42" class="indexterm"/> destructuring assignment, we can also use the object destructuring assignment as a function parameter. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">functionmyFunction({name = 'Eden', age = 23, profession = "Designer"} = {})
{
  console.log(name, age, profession); //Output "John 23 Designer"
}

myFunction({name: "John", age: 23});</pre></div><p>Here, we passed an empty object as a default parameter value, which will be used as a default object if <code class="literal">undefined</code> is passed as a function argument.</p></div></div></div>
<div class="section" title="The arrow functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>The arrow functions</h1></div></div></div><p>ES6 provides a new way to create functions using the <code class="literal">=&gt;</code> operator. These functions are called as <span class="strong"><strong>arrow</strong></span> functions. This <a id="id43" class="indexterm"/>new method has a shorter syntax, and the arrow functions are the anonymous functions.</p><p>Here is an example that shows how to create an arrow function:</p><div class="informalexample"><pre class="programlisting">let circleArea = (pi, r) =&gt; {
  let area = pi * r * r;
  return area;
}

let result = circleArea(3.14, 3);

console.log(result); //Output "28.26"</pre></div><p>Here, <code class="literal">circleArea</code> is a variable, referencing to the anonymous arrow function. The previous code is similar to the next code in ES5:</p><div class="informalexample"><pre class="programlisting">Var circleArea = function(pi, r) {
  var area = pi * r * r;
  return area;
}

var result = circleArea(3.14, 3);

console.log(result); //Output "28.26"</pre></div><p>If an arrow function contains just one statement, then you don't have to use the <code class="literal">{}</code> brackets to wrap the code. Here is an example:</p><div class="informalexample"><pre class="programlisting">let circleArea = (pi, r) =&gt; pi * r * r;
let result = circleArea(3.14, 3);

console.log(result); //Output "28.26"</pre></div><p>When <code class="literal">{}</code> brackets are not used then the value of the statement in the body is automatically returned.</p><div class="section" title="The value of &quot;this&quot; in an arrow function"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>The value of "this" in an arrow function</h2></div></div></div><p>In the arrow functions, the <a id="id44" class="indexterm"/>value of <code class="literal">this</code> keyword is same as the value of <code class="literal">this</code> keyword of the enclosing scope (the global or function scope, inside whichever the arrow function is defined), instead of referring to the context object (that is, the object inside of which the function is a property), which is the value of <code class="literal">this</code> in traditional functions.</p><p>Consider this example to understand the difference in the traditional function's and the arrow function's <code class="literal">this</code> value:</p><div class="informalexample"><pre class="programlisting">var object = {
  f1: function(){
    console.log(this);
    var f2 = function(){ console.log(this); }
    f2();
    setTimeout(f2, 1000);
  }
}

object.f1();</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">Object
Window
Window</pre></div><p>Here, <code class="literal">this</code> inside the <code class="literal">f1</code> function refers to <code class="literal">object,</code> as <code class="literal">f1</code> is the property of it. <code class="literal">this</code> inside <code class="literal">f2</code> refers to the <code class="literal">window</code> object, as <code class="literal">f2</code> is a property of the <code class="literal">window</code> object.</p><p>But <code class="literal">this</code> behaves <a id="id45" class="indexterm"/>differently in the arrow functions. Let's replace the traditional functions with the arrow functions in the preceding code and see the value of this:</p><div class="informalexample"><pre class="programlisting">var object = {
  f1: () =&gt; {
    console.log(this);
    var f2 = () =&gt; { console.log(this); }
    f2();
    setTimeout(f2, 1000);
  }
}

object.f1();</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">Window
Window
Window</pre></div><p>Here, <code class="literal">this</code> inside the <code class="literal">f1</code> function copies the <code class="literal">this</code> value of global scope, as <code class="literal">f1</code> lies in global scope. <code class="literal">this</code> inside <code class="literal">f2</code> copies the <code class="literal">this</code> value of <code class="literal">f1,</code> as <code class="literal">f2</code> lies in the <code class="literal">f1</code> scope.</p></div><div class="section" title="Other differences between the arrow and traditional functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Other differences between the arrow and traditional functions</h2></div></div></div><p>The arrow <a id="id46" class="indexterm"/>functions cannot be used as object constructors that is, the <code class="literal">new</code> operator cannot be applied on them.</p><p>Apart from syntax, the <code class="literal">this</code> value, and the <code class="literal">new</code> operator, everything else is the same between the arrow and traditional functions, that is, they both are the instances of <code class="literal">the</code> <code class="literal">Function</code> constructor.</p></div></div>
<div class="section" title="The enhanced object literals"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>The enhanced object literals</h1></div></div></div><p>ES6 has added some<a id="id47" class="indexterm"/> new syntax-based extensions to the <code class="literal">{}</code> object literal for creating properties. Let's see them:</p><div class="section" title="Defining properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Defining properties</h2></div></div></div><p>ES6 provides a<a id="id48" class="indexterm"/> shorter syntax for assigning the object properties to the values of the variables, which have the same name as the properties.</p><p>In ES5, you have been doing this:</p><div class="informalexample"><pre class="programlisting">var x = 1, y = 2;
var object = {
  x: x,
  y: y
};

console.log(object.x); //output "1"</pre></div><p>In ES6, you can do it this way:</p><div class="informalexample"><pre class="programlisting">let x = 1, y = 2;
let object = { x, y };

console.log(object.x); //output "1"</pre></div></div><div class="section" title="Defining methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Defining methods</h2></div></div></div><p>ES6 provides a <a id="id49" class="indexterm"/>new syntax for defining the methods on an object. Here is an example to demonstrate the new syntax:</p><div class="informalexample"><pre class="programlisting">let object = {
  myFunction(){
    console.log("Hello World!!!"); //Output "Hello World!!!"
  }
}

object.myFunction();</pre></div><p>This concise function allows the use of <code class="literal">super</code> in them, whereas the traditional methods of the objects <a id="id50" class="indexterm"/>don't allow the use of <code class="literal">super</code>. We will learn more about it later in this book.</p></div><div class="section" title="The computed property names"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>The computed property names</h2></div></div></div><p>The property names that are evaluated during runtime are called as the <span class="strong"><strong>computed property names</strong></span>. An<a id="id51" class="indexterm"/> expression is usually resolved to find the property name dynamically.</p><p>In ES5, the computed properties are defined in this way:</p><div class="informalexample"><pre class="programlisting">var object = {};

object["first"+"Name"] = "Eden";//"firstName" is the property name

//extract
console.log(object["first"+"Name"]); //Output "Eden"</pre></div><p>Here, after creating the object, we attach the properties to the object. But in ES6, we can add the properties with the computed name while creating the objects. Here is an example:</p><div class="informalexample"><pre class="programlisting">let object = {
  ["first" + "Name"]: "Eden",
};

//extract
console.log(object["first" + "Name"]); //Output "Eden"</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we learned about the variable's scopes, read-only variables, splitting arrays into individual values, passing indefinite parameters to a function, extracting data from objects and arrays, arrow functions, and new syntaxes for creating object properties.</p><p>In the next chapter, we will learn about built-in objects and symbols, and we will discover the properties added by ES6 into strings, arrays, and objects.</p></div></body></html>