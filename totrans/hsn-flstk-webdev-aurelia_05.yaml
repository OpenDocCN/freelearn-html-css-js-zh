- en: Creating Our RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application is composed of different layers; upto now, you have been developing
    the client-side layer of the FIFA World Cup project. However, just presenting
    a user interface to the user is not enough. We need to process some business logic
    in order to provide an appropriate user experience to our users, such as subscribing
    to the next matches, retrieving the roaster for the user's favorite team, managing
    login, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have a full web application, we should implement the following
    server-side missing pieces in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: The RESTful API layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once upon a time, developers used to implement all the layers in a single project,
    and this was because of the adoption of popular open source web platforms such
    as XAMPP, which configures a PHP/MySQL environment in just a few seconds. So,
    developers used to write the client-side web pages in PHP and add HTML code in
    the same file, mixing server-side with client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: With the passing of the years, new techniques were introduced. Now, developers
    separate client side and server side in different projects, and in addition to
    separating the project, these layers are deployed in different domains. All of
    this was possible thanks to the introduction of new client-side and server-side
    frameworks. All this brings a new challenge—communication—so having separate projects
    now requires a way to exchange information with each other. RESTful APIs become
    the right solution to communicate between the client side and backend using the
    HTTP protocol as the mean of data transportation between these layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration depicts the new way to create web apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6302213e-bacf-4734-9e9e-c79966070af4.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will implement the RESTful API layer. For this, we will
    use Node.js and JavaScript to build a robust RESTful API. You will also learn
    the concepts and how to design robust APIs using an open source framework on top
    of Node.js called ExpressJS. We will also explore the new MEAN stack and learn
    about the technologies behind it and why we decided to baptize it as the new MEAN
    stack. Lastly, you will learn how to improve your RESTful APIs using new techniques
    to improve the developer experience in your team.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RESTful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an API with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving our API with ExpressJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding RESTful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go through the components HTTP and **CRUD** (**Create**, **Retrieve,
    Update** and **Delete**), which form the basic building block of RESTful. These
    components together make possible the communication between different applications
    over the internet in a distributed environment via a well-defined API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you are navigating on the internet, you are using the HTTP. Even
    when you are booking a ride on Uber, you are using HTTP. In fact, HTTP is present
    in almost all the applications that you use on a daily basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP is based on the principle of client-server communication. It means that
    every time you want to access an information or resources, you have to send a
    request object and the server will send you all the requested information into
    a response object. The following diagram explains this communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8fb1186-0c9e-44a9-abca-42a8d1275bcc.png)'
  prefs: []
  type: TYPE_IMG
- en: So, in order to really understand how to design a robust HTTP RESTful API we
    need to know how URLs works and learn about the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'URLs are the way how applications give access to their information assets by
    defining well-structured endpoints. For example, if you want to search about Peru,
    you would probably access from a web browser the following URL: [https://www.google.com/search?q=Peru](https://www.google.com/search?q=Peru).
    Let''s divide the previous URL into parts and analyze it in details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/919e96ad-ca50-4934-9841-fbdec902b46e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the diagram, we see that there are basically four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol**: This is the HTTP for non-secure connections or HTTPS for secure
    connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain**: The registered domain that will be translated to the server IP,
    which contains this resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: This allows us to separate our resources into segments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query String**: This is optional but allows us to provide additional data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will always use URLs to access resources hosted on another server.
  prefs: []
  type: TYPE_NORMAL
- en: Verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTTP verbs are the magic behind RESTful APIs. Let''s use an example to
    understand how HTTP verbs works. We want to create an API to manage products;
    our first version might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoint** | **HTTP verb** | **Goal** |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myapp/api/createProduct` | POST | To create a product |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myapp/api/updateProduct/P1` | POST | To update an existing product
    |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myapp/api/listProducts` | GET | To retrieve the complete list of
    products |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myapp/api/viewProductDetails/P1` | GET | To retrieve a single product
    |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myapp/api/deleteProduct/P1` | POST | To delete a product |'
  prefs: []
  type: TYPE_TB
- en: 'From the preceding table, you can note that we need to remember five endpoints,
    and we are using two HTTP verbs: POST and GET. It might be understood that every
    time we want to retrieve information, a GET verb is used, and to perform operations
    that will modify the existing information in our system, a POST verb is used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s make our endpoints easy to remember using HTTP verbs. After applying
    a simple refactor, now our table might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoint** | **HTTP verb** | **Goal** |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myapp/api/products` | GETPOST | To retrieve the full list of products.To
    create a new product. |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myapp/api/products/P1` | GETDELETEPUT | To retrieve a single product.To
    delete an existing product.To modify an existing product. In this case, you must
    send the full document, not just the fields that have changed. |'
  prefs: []
  type: TYPE_TB
- en: Now, we are using the HTTP verbs, and we have reduced from five endpoints to
    just two. HTTP verbs are sent with every request to the server, so servers can
    use them to identify what operation a user wants to perform, sending the correct
    endpoint and verb.
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The headers contain additional information about every request that we send
    to the server. The headers that you will use more frequently during development
    are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content**-**Type**: To tell the server which type of response you are waiting
    for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accept**: To tell the server which type of content the client can process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: To send a piece of information to validate the identity
    of the information consumer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there are more headers. Refer to [https://developer.mozilla.org/es/docs/Web/HTTP/Headers](https://developer.mozilla.org/es/docs/Web/HTTP/Headers) to
    learn more about the HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: Body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The body is present in the request and response objects. Every time you want
    to create a new entry in your database, you have to pass the information in the
    body section of your HTTP Request. The data in the body section is known as **payload**.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might have noted when we talked about HTTP verbs, every verb is related
    to a CRUD operation. Basically, these four operation refers to the basic functions
    that all the database engines perform.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, mapping each HTTP verb with its respective CRUD operation, we will have
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Verb** | **CRUD Operation** | **GOAL** |'
  prefs: []
  type: TYPE_TB
- en: '| POST | Create | Create or Insert a new element in our app |'
  prefs: []
  type: TYPE_TB
- en: '| GET | Retrieve | Retrieve or Read elements from our app |'
  prefs: []
  type: TYPE_TB
- en: '| PUT | Update | Update or Modify any existing element into our app |'
  prefs: []
  type: TYPE_TB
- en: '| DELETE | Delete | Delete or Remove any existing element into our app |'
  prefs: []
  type: TYPE_TB
- en: Designing APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are clear about what HTTP is and the building blocks behind it,
    we need to design a friendly and robust API. Another advantage of this is that
    we will improve the developer experience in our organization by having a well-defined
    API.
  prefs: []
  type: TYPE_NORMAL
- en: API documentation is another key practice that you have to apply in every API
    development you will do. With documentation, the development team and API consumers
    are aware of the full functionality of the API, because they are defined in an
    easy-to-read format. For example, the financial team and the logistics team in
    an organization can share their API documentation between them and start working
    on a possible integration solution immediately because they now know the full
    details of the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to design robust APIs by understanding the API first movement
    and other design concepts.
  prefs: []
  type: TYPE_NORMAL
- en: API first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**API first** is one of the most important concepts you should keep in mind
    while developing a new product or a service, you have to think of it as if it
    were the user interface for programmers. In fact, APIs are the way how you can
    expose the functionalities of your products in a distributed big system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, techniques and approaches such as cloud applications and microservices
    are becoming adopted everywhere, and they suggest a new way to develop software.
    With microservices, you have to split your application into different independent
    services; each service contains a specific set of related features of your application,
    such as taking some Amazon APIs as an example, we can have something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42b387e7-abdf-4f3c-833d-9e0527cd5b4d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are different services that need to exchange information
    and functionalities. All of those have to define a consistent and self-explained
    API that the other services have to use in order to either perform an operation
    in another service that it is not able to do or a client-side application will
    invoke the APIs directly to access some information.
  prefs: []
  type: TYPE_NORMAL
- en: The main understanding behind API first is that before you implement any code
    or UI design in your system, you should design your API in such a way that even
    if you don't have any user interface, developers should be able to navigate and
    access the information and functionality into your application data.
  prefs: []
  type: TYPE_NORMAL
- en: API design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To design a robust, self-explained, friendly, and easy-to-use API, we will follow
    the set of best practices that have been used and implemented over the years by
    the internet gurus. Thankfully, some great developers and architects had defined
    a set of rules that we will cover in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Nouns as paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have you ever seen some API endpoints that contain a full sentence to access
    a resource? Some examples might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to keep in mind is that you should never use verbs in your
    endpoints. Instead, use nouns in plural to refer to a resource into your API Endpoint.
    For example, the preceding example can be refactored to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The Rest way** - **Not recommended** | **The RESTful way** - **Recommended**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myshop.com/createNewProduct``http://myshop.com/deleteProduct``http://myshop.com/updateProduct`
    | `http://myshop.com/products` |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myshop.com/getProductDetail/P01` | `http://myshop.com/products/P01`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `http://myshop.com/getProductComments/P01` | `http://myshop.com/products/P01/comments`
    |'
  prefs: []
  type: TYPE_TB
- en: 'A good practice is not to extend the path depth higher than three paths. For
    example, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Do that instead of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to extend your API to perform additional operations such as getting
    the first 10 messages published today, use query strings instead of paths. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: HTTP verbs for CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have designed clean endpoints for your API, it is time to take
    advantage of what we learned about HTTP verbs. You might be asking yourself how
    do you differentiate when you want to create, update, or delete a product if you
    are using the same endpoint, `/products`? This is the case where we use HTTP verbs.
    For example, for the `/products` endpoint, we will have something like the following
    verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoint** | **HTTP Verb** | **Goal** |'
  prefs: []
  type: TYPE_TB
- en: '| `/products` | POST | To create a new product |'
  prefs: []
  type: TYPE_TB
- en: '| `/products` | PUT | To update an existing product |'
  prefs: []
  type: TYPE_TB
- en: '| `/products` | DELETE | To delete an existing product |'
  prefs: []
  type: TYPE_TB
- en: So from the preceding table, you can note that the key differentiator is the
    HTTP Verb. In short, an endpoint is composed by one path and an HTTP Verb.
  prefs: []
  type: TYPE_NORMAL
- en: API documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are working on a real project, the number of endpoints you will need
    to design will be higher. You will need a way to remember all your endpoints and
    the reason they were designed. Similarly, we are confident that documenting software
    is extremely important for us to remember what a piece of code is supposed to
    do; API documentation allows us to tell the API consumers how they can use our
    API by documenting the endpoints and other additional metadata, such as the ones
    listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected body structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an awesome open source tool that helps you document and share the documentation
    with your APIs called **Swagger**. We encourage you to visit the official site
    and play with it at [https://swagger.io](https://swagger.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible documentation might be just a simple table that contains the data
    used in the request and responses. For example, the documentation to create a
    new product might be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Path** | **Products** |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP method | POST |'
  prefs: []
  type: TYPE_TB
- en: '| Expected Results | HTTP 200 OK status code |'
  prefs: []
  type: TYPE_TB
- en: '| Expected Input Headers | Content-type: `application/json` |'
  prefs: []
  type: TYPE_TB
- en: '| Expected Input Body | {`id`: `Integer`, `name`: `String`, `price`: `Decimal`}
    |'
  prefs: []
  type: TYPE_TB
- en: '| Goal | Use this endpoint to create a new product |'
  prefs: []
  type: TYPE_TB
- en: '| Authorization | Required Authorization Token |'
  prefs: []
  type: TYPE_TB
- en: Having the knowledge of how to design self-explained APIs and how to use HTTP
    to create endpoints, let's move forward to implement a RESTful API with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to start having fun and code our RESTful API. Until now you have seen
    the theory behind APIs and that knowledge is very important to understand the
    following sections. So, you might be wondering, why Node.js? The short answer
    is because it is cool! Haha, just kidding. Node.js has evolved since its creation
    in 2009 by *Ryan Dahl*. Node.js is used for leading companies over the world,
    such as LinkedIn, Facebook, Amazon, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is not limited to API Development. In fact, you might create any kind
    of project from command-line tools to **Internet of Things** (**IoT**) applications.
    So, let's start learning about the advantages of Node.js and coding our API.
  prefs: []
  type: TYPE_NORMAL
- en: Node advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has a lot of advantages; we will explore the more important ones in
    the following subtopics.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most programming languages, I/O operations are performed synchronously.
    Synchronous execution will block the program flow until the blocking operation
    finishes its execution. For example, the following Python code is executed synchronously
    and blocks the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The total execution time will be approximately 30 seconds. That is because
    of the I/O Blocking operation. If we represent the synchronous execution as a
    timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75eedb21-1266-4f3b-9f80-69072f285285.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now if we execute the same operation in an asynchronous way using JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: From the previous code, you can note that we use a callback to process the content
    of the file. Callbacks are functions that are invoked after some events occur.
    For example, `(file_content)=> {}` will be called once the content of `my_file.txt`
    is ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two `open()` statements will be executed at the same time. Executing the
    statements in parallel will help us reduce the execution time. For example, let''s
    see the timeline execution for this asynchronous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33587146-6ad1-4b24-aec8-aeb06e94b7f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now the execution will be just 20 seconds, and, with this, we have improved
    our application performance. This is one of the key advantages that Node.js brings
    up to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Single-thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every time a new user request arrives at the backend server it will create
    a new thread for the request, this is the classic behavior for backend servers
    that don''t use Node.js. Once the server sends the response to the user, it releases
    the thread. Handling just a few threads is not an issue but, imagine what would
    happen if you need to handle millions of users at the same time? Let''s graph
    this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46d145e2-1374-4ba8-b5f2-af04627ef2d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Node.js does not have this issue because of its single-thread strategy. Instead
    of starting a new thread for each request, it will use the same main thread to
    handle all the requests and will be supported by the event-loop. The following
    diagram depicts this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9301b979-ae59-454d-aaf8-a35bbeaaf4aa.png)'
  prefs: []
  type: TYPE_IMG
- en: This scenario is better for CPU utilization; multiple threads allow NodeJS to
    take advantage of multi-core CPUs. However, we need more than a simple chapter
    to talk about them. We strongly encourage you to visit the official Node.js site
    at [https://nodejs.org/en/](https://nodejs.org/en/).
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to code a simple HTTP Server and start the fun part!
  prefs: []
  type: TYPE_NORMAL
- en: Simple HTTP Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is time to start coding and see how we can implement a simple HTTP Server
    using Node.js. So, open your Terminal and in the working directory of your choice,
    go ahead and create a new folder called `my-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you move into the `my-server` folder, we will need to initialize an NPM
    module, so run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to create the `server.js`file by executing the `touch server.js`
    command in your Terminal. This file will contain the code for our server. We will
    start importing the HTTP module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We import any module using the `require` built-in function, and we define the
    `http` variable to house the module reference. Let''s implement a simple handler
    by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a handler is just a function that declares two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request`: Used to read the information sent by the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response`: Used to send information to the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our handler is using the `response` parameter to send our friendly message
    to the client. Now it''s time to create a server instance using the `http` reference
    we declared earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating an empty server that does not perform any operation. To make
    our server useful, we pass the `request` handler we declared earlier, `myRequestHandler`.
    With this, our server is able to send our `Hello` message every time some client
    sends an HTTP request to our server. To finish our server implementation, we need
    to listen to the client request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! Now that we have a simple HTTP, execute the `node server.js` command
    to run the server. Let''s test things out. Head over to [http://localhost:5000](http://localhost:5000)
    and you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24f16fb3-ea3a-41a1-adbb-69356cf27bd9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you know how to create a simple HTTP server using the native HTTP module
    that comes along with Node.js. However, in order to create a powerful RESTful
    backend, we need to use a more sophisticated framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will enhance our simple server using Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our API with Express.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js is an open source web framework created on top of Node.js. We can
    implement our REST API using the Node.js HTTP module, but we will have to write
    a lot of code to handle a simple user request. Express.js is very flexible and
    provides a set of features that will allow us to create robust APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Coding our server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to create our FIFA backend folder and start working on the API development.
    Open your Terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the initialization is done, let''s install Express.js. Execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `server.js` file in the root folder and write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We start importing the `express` module and instantiation of an express application
    into the `app` variable. Next, we use the application instance to configure a
    simple request handler using the `app.use` function. Into this function, we pass
    another function as a parameter that has two parameters for the request and response:
    `req` and `res`. To send a simple message, we use the `res` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the server application instance is configured, we bring it to life by
    calling its `listen` function and passing the HTTP port where it will listen to
    new HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We strongly recommend you to use **nodemon** in development. The nodemon will
    restart your node application every time it detects a change in your source code
    automatically. To install nodemon, just execute the `npm install -g nodemon` command.
    To run your server, use the `nodemon server.js` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it by opening `http://localhost:3000` in your browser or using
    an HTTP client command-line tool. Consider the given example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good! Let''s define a route path to make a self-explanatory API.
    Apply the following change to the `server.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, head over to `http://localhost:3000/hello` and you should see the same `Hello!`
    message. You can navigate to `http://localhost:3000` to see what you get after
    the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Routes are the magic behind our RESTful API. If you remember when we talked
    about HTTP verbs, RESTful is composed by combining CRUD operations with the HTTP
    verbs. Express.js makes easy the definition of these RESTful way. For example,
    open the `server.js`file and apply the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we changed `use` for `get`. As you are so smart, you know that `get`
    refers to the GET HTTP verb, so let''s define our RESTful routes for our Teams
    API. In the `server.js`*, *apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we apply these changes, it''s time to test them. Run the following commands
    in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Cool! our RESTful API is responding correctly. Note that we use the `-X [HTTP
    Verb]` to tell curl which HTTP verb we want to use for the given request. Now
    that we are ready with the main skeleton of our API, we need to structure our
    project in a consistent way because we will create a group of files and should
    always organize our source code. Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Coding our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we are! We will implement the code of our project. Our application is
    composed of three domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Teams**: To manage the information of all the teams that participate in the
    World Cup competition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matches**: To manage the information of all the Matches during the competition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: To manage the information of the users and permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The teams and matches follow the same implementation with a few variants. For
    that reason, in this section, we will write the code to implement the `Team` domain
    and then expose it via our API, and you will be able to implement the code for
    the `Match` domains yourself. Of course, the complete source code is available
    in the [https://github.com/Packt-Aurelia-Fullstack-Book/worldcup-app](https://github.com/Packt-Aurelia-Fullstack-Book/worldcup-app) GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: So, having said that. Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Our project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating the Project structure for our source code. Create
    the following directories and files in your working directory, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26946484-c911-44b4-93e6-93f432fb096c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `src` folder contains three subfolders: `models`, `routes`, and `config`.
    In this chapter, we will just use the `routes` folder and the `teams-api.js` file.
    The other two will be explored in the next chapter when we talk about Databases
    and MongoDB.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the routes folder is to host all the API Routes declaration. We
    have declared our routes in the `server.js` file; it might be a good idea if we
    are working on a small project, but it is not a good idea for a big project, which
    will have a lot of routes declarations. For that reason, a good strategy is to
    separate the routes per API functionality; for example, teams-API, matches-API,
    and auth-API. With this, we will have more easy-to-read and easy-to-maintain code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Teams API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start coding, we have to design our API first. The following table
    contains the documentation for the API we will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Route** | **HTTP Verb** | **Goal** | **Responses** |'
  prefs: []
  type: TYPE_TB
- en: '| `/teams` | GET | List all the teams | Http 200 - OK |'
  prefs: []
  type: TYPE_TB
- en: '| `/teams` | POST | Create a new team with body{`name`: String} | Http 201
    - Created |'
  prefs: []
  type: TYPE_TB
- en: '| `/teams/:id` | GET | Get a single team | Http 200 -OKHttp 404 - Not Found
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/teams/:id` | PUT | Update an existing team | Http 200 -OKHttp 404 - Not
    Found |'
  prefs: []
  type: TYPE_TB
- en: '| `/teams/:id` | DELETE | Delete an existing team | Http 200 -OKHttp 404 -
    Not Found |'
  prefs: []
  type: TYPE_TB
- en: Keeping this in mind, let's begin with the fun part!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the JSON Parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by configuring our server to be able to parse JSON. This means
    that Express.js will automatically parse the data that flows in and out of the
    HTTP Request. The following diagram explains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf677a86-a721-409c-ae8c-0519f0504280.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, all the requests will be intercepted by the **JSON Parser**. The
    **JSON Parser** is better known as a **middleware**. A middleware is just a simple
    function that is processed before another function. For example, the **GET /teams**
    function is supposed to be the only function that should be called in every request,
    but as we have configured the **JSON Parser**, the **GET /teams** will be invoked
    once the **JSON Parser** function is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure this in our code, first we need to install it. Run the `npm install
    --save body-parser` in your terminal and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `body-parser` module. Then, we configure the application
    to use our `bodyParser.json()` using its `app.use` function. All the middleware
    are configured by calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to test whether the JSON Parser is working, we define the `teams` variable
    containing two teams with their respective names. To send the `teams`, we use `res.json`
    instead of `res.send`. Let''s check the results by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that our API is able to receive and send JSON, let's move our routes to
    its own file.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We previously created the `teams-api.js` file in the `routes`folder. Open that
    file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the `express` module. From this module, we are declaring the
    `api` variable, which is an instance of `express.Router`. A `teams` variable has
    been created in order to host some fake data for the teams. We will use this router
    to configure our CRUD/HTTP handlers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using the `api` route variable, we define the `'/teams'` path as root for the
    HTTP handlers. In the `get` handler, we are just sending the list of teams as
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to export the `api` route to be used in the `server.js`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are ready, open the `server.js`file to apply the following changes
    that will configure the server to use this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the Teams API module from the relative path into our project
    and use the `app.use` function to configure our routes. Let''s test things out;
    run the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Now we have our code clean and everything is working as we expect. It's
    time to write some code to implement the POST, PUT, and DELETE handlers. We will
    use the fake `teams` variable to add data in memory until we learn how to use
    a real database in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a team, we need to implement the POST handler. The data to the new
    team will be sent into the `body` parameter into the HTTP Request. Apply the following
    changes to the `teams-api.js`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we read the data from the `req.body` property. Then, we insert the new
    element into the `teams` array. Lastly, we send the `teams` array with the new
    team added and specify the HTTP status 201, which means Resource Created.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full list of HTTP statuses at [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).
  prefs: []
  type: TYPE_NORMAL
- en: 'To test things out, we will call our API using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Our command is a little weird this time. As we are using JSON, we have to explicitly
    tell the HTTP Request that we are sending JSON data, so we use the `-H` header
    option. To send the information, we use the `-d` data option. That's all! It looks
    difficult but it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use the GET method to list all the teams and see the new team added
    to our list.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already have the list handler, but the listing is not enough. Apart from
    retrieving the full list, we will need to retrieve a single team. To do this,
    we will need to add a new GET route and learn how to use params. Apply the following
    changes into the `teams-api.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare a new route, which now contains a dynamic param—`/teams/:api`.
    We said dynamic because, of course, it can take any value that will be available
    as an attribute of the `req.params` object. Note that the name you use for your
    param will be created as a property, for example, `req.params.id` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a simple `for` loop that iterates across the full list of teams
    and looks for the team that has the same `id` we passed in the route param. If
    a team is found, we send the team by calling the `res.json(team)` statement. As
    we want to quit the handler immediately after we send the response, we use `return` to
    exit the handler. If a team is not found, we send an error message and mark the
    response with the HTTP `status` 404, which means Resource not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to test our implementation, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that by default, curl always sends a -X GET request if no HTTP
    verb has been explicitly defined.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our last two implementations for PUT and DELETE.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a Team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The update process is a combination of two processes—the search for a team
    and the update process itself. In the previous implementation, we wrote the code
    to look up an existing team. So, let''s reuse the same code by defining a function
    that can be used for retrieve, update, and delete. Open the `teams-api.js`file
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the `lookupTeam` function, which expects for the `id` as a param
    and will return a valid team index if it is found. Otherwise, it will return -1\.
    Now we need to refactor our handle to retrieve a Team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done that, let''s implement our update handler. Apply the following
    changes in the same `teams-api`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So we define a `.put` route and look up for a team by passing the `id` param.
    If a valid index is returned, we save the team instance in the `team` variable
    and apply the change to its `name` property by reading the data from the `request.body`
    object and finally, we send the updated team. If there is not a valid index for
    the ID passed, we return a `Not Found` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to test things out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a Team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delete` process is similar to the `update`. First, we need to retrieve
    a valid index from the `teams` array and then remove it from there. Open the `teams-api.js`file
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So we define a `.delete` route and look up for a team by passing the `id` param.
    If a valid index is returned, we save the team instance in the `team` variable.
    Next, we delete the element from the array using the `splice(index, 1)` expression.
    Lastly, we return the deleted `team` just for the information purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We are done! We have implemented a RESTful API that exposes HTTP handlers for
    our Teams feature. We need to apply security to our routes and other advanced
    features. We will learn all about that in subsequent chapters. Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the API's world and understood how APIs are implemented
    using the HTTP Protocol and CRUD operations. This great combination enables the
    exchange of information easier than before.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to create an API using Node.js and saw how easy it is to
    build a RESTful API using one of the most popular open source web frameworks—Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will integrate our API with MongoDB in order to save
    information in a real database instead of sending fake data. It's getting better.
  prefs: []
  type: TYPE_NORMAL
