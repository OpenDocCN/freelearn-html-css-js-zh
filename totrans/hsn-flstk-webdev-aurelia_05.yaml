- en: Creating Our RESTful API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的RESTful API
- en: A web application is composed of different layers; upto now, you have been developing
    the client-side layer of the FIFA World Cup project. However, just presenting
    a user interface to the user is not enough. We need to process some business logic
    in order to provide an appropriate user experience to our users, such as subscribing
    to the next matches, retrieving the roaster for the user's favorite team, managing
    login, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络应用程序由不同的层组成；到目前为止，你一直在开发FIFA世界杯项目的客户端层。然而，仅仅向用户展示用户界面是不够的。我们需要处理一些业务逻辑，以便为用户提供适当的用户体验，例如订阅下一场比赛、检索用户喜爱球队的阵容、管理登录等。
- en: 'In order to have a full web application, we should implement the following
    server-side missing pieces in our project:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有一个完整的网络应用程序，我们应该在我们的项目中实现以下服务器端缺失的部分：
- en: The RESTful API layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API层
- en: Database layer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库层
- en: Once upon a time, developers used to implement all the layers in a single project,
    and this was because of the adoption of popular open source web platforms such
    as XAMPP, which configures a PHP/MySQL environment in just a few seconds. So,
    developers used to write the client-side web pages in PHP and add HTML code in
    the same file, mixing server-side with client-side code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从前，开发者通常在一个项目中实现所有层，这主要是因为采用了像XAMPP这样的流行开源Web平台，它只需几秒钟就能配置PHP/MySQL环境。因此，开发者通常使用PHP编写客户端网页，并在同一文件中添加HTML代码，将服务器端代码与客户端代码混合。
- en: With the passing of the years, new techniques were introduced. Now, developers
    separate client side and server side in different projects, and in addition to
    separating the project, these layers are deployed in different domains. All of
    this was possible thanks to the introduction of new client-side and server-side
    frameworks. All this brings a new challenge—communication—so having separate projects
    now requires a way to exchange information with each other. RESTful APIs become
    the right solution to communicate between the client side and backend using the
    HTTP protocol as the mean of data transportation between these layers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，引入了新技术。现在，开发者将客户端和服务器端分离到不同的项目中，并且除了分离项目之外，这些层还部署在不同的域中。所有这一切都得益于新客户端和服务器端框架的引入。所有这些都带来了新的挑战——通信，因此现在需要一种方式来交换信息。RESTful
    API成为在客户端和后端之间使用HTTP协议作为这些层之间数据传输手段进行通信的正确解决方案。
- en: 'The following illustration depicts the new way to create web apps:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了创建Web应用的新方法：
- en: '![](img/6302213e-bacf-4734-9e9e-c79966070af4.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6302213e-bacf-4734-9e9e-c79966070af4.png)'
- en: In this chapter, we will implement the RESTful API layer. For this, we will
    use Node.js and JavaScript to build a robust RESTful API. You will also learn
    the concepts and how to design robust APIs using an open source framework on top
    of Node.js called ExpressJS. We will also explore the new MEAN stack and learn
    about the technologies behind it and why we decided to baptize it as the new MEAN
    stack. Lastly, you will learn how to improve your RESTful APIs using new techniques
    to improve the developer experience in your team.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现RESTful API层。为此，我们将使用Node.js和JavaScript构建一个健壮的RESTful API。你还将学习概念以及如何使用Node.js之上的开源框架ExpressJS设计健壮的API。我们还将探索新的MEAN栈，了解其背后的技术以及为什么我们决定将其命名为新的MEAN栈。最后，你将学习如何使用新技术改进你的RESTful
    API，以改善团队的开发体验。
- en: 'So, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将涵盖以下主题：
- en: Understanding RESTful
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解RESTful
- en: Designing APIs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计API
- en: Creating an API with Node.js
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js创建API
- en: Improving our API with ExpressJS
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ExpressJS改进我们的API
- en: Coding our project
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码我们的项目
- en: Understanding RESTful
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解RESTful
- en: In this section, we will go through the components HTTP and **CRUD** (**Create**, **Retrieve,
    Update** and **Delete**), which form the basic building block of RESTful. These
    components together make possible the communication between different applications
    over the internet in a distributed environment via a well-defined API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍HTTP和**CRUD**（**创建**、**检索**、**更新**和**删除**）组件，这些组件构成了RESTful的基本构建块。这些组件共同使得在分布式环境中通过定义良好的API在不同应用程序之间进行通信成为可能。
- en: Understanding HTTP
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTTP
- en: Every time you are navigating on the internet, you are using the HTTP. Even
    when you are booking a ride on Uber, you are using HTTP. In fact, HTTP is present
    in almost all the applications that you use on a daily basis.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您在网上导航时，您都在使用HTTP。即使您在Uber上预订行程，您也在使用HTTP。事实上，HTTP几乎存在于您每天使用的所有应用程序中。
- en: 'HTTP is based on the principle of client-server communication. It means that
    every time you want to access an information or resources, you have to send a
    request object and the server will send you all the requested information into
    a response object. The following diagram explains this communication:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基于客户端-服务器通信的原则。这意味着每次您想要访问信息或资源时，您都必须发送一个请求对象，服务器将发送所有请求的信息到一个响应对象中。以下图表解释了这种通信：
- en: '![](img/c8fb1186-0c9e-44a9-abca-42a8d1275bcc.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8fb1186-0c9e-44a9-abca-42a8d1275bcc.png)'
- en: So, in order to really understand how to design a robust HTTP RESTful API we
    need to know how URLs works and learn about the HTTP protocol.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了真正理解如何设计一个健壮的HTTP RESTful API，我们需要了解URL的工作原理以及学习HTTP协议。
- en: URLs
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL
- en: 'URLs are the way how applications give access to their information assets by
    defining well-structured endpoints. For example, if you want to search about Peru,
    you would probably access from a web browser the following URL: [https://www.google.com/search?q=Peru](https://www.google.com/search?q=Peru).
    Let''s divide the previous URL into parts and analyze it in details:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: URL是应用程序通过定义良好结构的端点来提供对其信息资产访问的方式。例如，如果您想搜索秘鲁，您可能会通过网页浏览器访问以下URL：[https://www.google.com/search?q=Peru](https://www.google.com/search?q=Peru)。让我们将之前的URL分成几个部分，并详细分析它：
- en: '![](img/919e96ad-ca50-4934-9841-fbdec902b46e.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/919e96ad-ca50-4934-9841-fbdec902b46e.png)'
- en: 'From the diagram, we see that there are basically four parts:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中，我们看到基本上有四个部分：
- en: '**Protocol**: This is the HTTP for non-secure connections or HTTPS for secure
    connections'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议**：这是非安全连接的HTTP或安全连接的HTTPS'
- en: '**Domain**: The registered domain that will be translated to the server IP,
    which contains this resource'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名**：将转换为服务器IP的已注册域名，其中包含此资源'
- en: '**Path**: This allows us to separate our resources into segments'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：这使我们能够将资源分成几个部分'
- en: '**Query String**: This is optional but allows us to provide additional data'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询字符串**：这是可选的，但允许我们提供额外的数据'
- en: We will always use URLs to access resources hosted on another server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将始终使用URL来访问托管在其他服务器上的资源。
- en: Verbs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动词
- en: 'The HTTP verbs are the magic behind RESTful APIs. Let''s use an example to
    understand how HTTP verbs works. We want to create an API to manage products;
    our first version might look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP动词是RESTful API背后的魔法。让我们用一个例子来理解HTTP动词是如何工作的。我们想要创建一个用于管理产品的API；我们的第一个版本可能看起来像这样：
- en: '| **Endpoint** | **HTTP verb** | **Goal** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **端点** | **HTTP动词** | **目标** |'
- en: '| `http://myapp/api/createProduct` | POST | To create a product |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `http://myapp/api/createProduct` | POST | 创建产品 |'
- en: '| `http://myapp/api/updateProduct/P1` | POST | To update an existing product
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `http://myapp/api/updateProduct/P1` | POST | 更新现有产品 |'
- en: '| `http://myapp/api/listProducts` | GET | To retrieve the complete list of
    products |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `http://myapp/api/listProducts` | GET | 获取产品完整列表 |'
- en: '| `http://myapp/api/viewProductDetails/P1` | GET | To retrieve a single product
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `http://myapp/api/viewProductDetails/P1` | GET | 获取单个产品 |'
- en: '| `http://myapp/api/deleteProduct/P1` | POST | To delete a product |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `http://myapp/api/deleteProduct/P1` | POST | 删除一个产品 |'
- en: 'From the preceding table, you can note that we need to remember five endpoints,
    and we are using two HTTP verbs: POST and GET. It might be understood that every
    time we want to retrieve information, a GET verb is used, and to perform operations
    that will modify the existing information in our system, a POST verb is used.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表中，您可以注意到我们需要记住五个端点，我们使用了两个HTTP动词：POST和GET。可以理解的是，每次我们想要检索信息时，都会使用GET动词，而要执行将修改我们系统中现有信息的操作时，会使用POST动词。
- en: 'So, let''s make our endpoints easy to remember using HTTP verbs. After applying
    a simple refactor, now our table might look as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用HTTP动词使我们的端点易于记忆。经过简单的重构后，我们的表格可能看起来如下所示：
- en: '| **Endpoint** | **HTTP verb** | **Goal** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **端点** | **HTTP动词** | **目标** |'
- en: '| `http://myapp/api/products` | GETPOST | To retrieve the full list of products.To
    create a new product. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `http://myapp/api/products` | GET/POST | 获取产品完整列表。创建新产品。 |'
- en: '| `http://myapp/api/products/P1` | GETDELETEPUT | To retrieve a single product.To
    delete an existing product.To modify an existing product. In this case, you must
    send the full document, not just the fields that have changed. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `http://myapp/api/products/P1` | GETDELETEPUT | 检索单个产品。删除现有产品。修改现有产品。在这种情况下，你必须发送完整的文档，而不仅仅是已更改的字段。
    |'
- en: Now, we are using the HTTP verbs, and we have reduced from five endpoints to
    just two. HTTP verbs are sent with every request to the server, so servers can
    use them to identify what operation a user wants to perform, sending the correct
    endpoint and verb.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在使用 HTTP 动词，并且我们已经将端点数量从五个减少到两个。HTTP 动词与每个请求一起发送到服务器，因此服务器可以使用它们来识别用户想要执行的操作，发送正确的端点和动词。
- en: Headers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部信息
- en: 'The headers contain additional information about every request that we send
    to the server. The headers that you will use more frequently during development
    are these:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 头部信息包含了我们发送给服务器每个请求的附加信息。在开发过程中，你将更频繁地使用以下头部信息：
- en: '**Content**-**Type**: To tell the server which type of response you are waiting
    for'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容类型** - **Type**：告诉服务器你期望哪种类型的响应'
- en: '**Accept**: To tell the server which type of content the client can process'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受** - **Accept**：告诉服务器客户端可以处理哪种类型的内容'
- en: '**Authorization**: To send a piece of information to validate the identity
    of the information consumer'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权** - **Authorization**：发送一段信息以验证信息消费者的身份'
- en: Of course, there are more headers. Refer to [https://developer.mozilla.org/es/docs/Web/HTTP/Headers](https://developer.mozilla.org/es/docs/Web/HTTP/Headers) to
    learn more about the HTTP headers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多的头部信息。请参阅 [https://developer.mozilla.org/es/docs/Web/HTTP/Headers](https://developer.mozilla.org/es/docs/Web/HTTP/Headers)
    了解更多关于 HTTP 头部信息的内容。
- en: Body
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主体
- en: The body is present in the request and response objects. Every time you want
    to create a new entry in your database, you have to pass the information in the
    body section of your HTTP Request. The data in the body section is known as **payload**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 主体存在于请求和响应对象中。每次你想在你的数据库中创建新条目时，你都必须在 HTTP 请求的主体部分传递信息。主体部分中的数据被称为 **有效载荷**。
- en: CRUD over HTTP
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD 通过 HTTP
- en: As you might have noted when we talked about HTTP verbs, every verb is related
    to a CRUD operation. Basically, these four operation refers to the basic functions
    that all the database engines perform.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 HTTP 动词时，你可能已经注意到，每个动词都与一个 CRUD 操作相关联。基本上，这四个操作指的是所有数据库引擎执行的基本功能。
- en: 'So, mapping each HTTP verb with its respective CRUD operation, we will have
    the following table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将每个 HTTP 动词与其相应的 CRUD 操作相对应，我们将得到以下表格：
- en: '| **HTTP Verb** | **CRUD Operation** | **GOAL** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP Verb** | **CRUD Operation** | **GOAL** |'
- en: '| POST | Create | Create or Insert a new element in our app |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| POST | 创建 | 在我们的应用程序中创建或插入一个新元素 |'
- en: '| GET | Retrieve | Retrieve or Read elements from our app |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| GET | 检索 | 从我们的应用程序中检索或读取元素 |'
- en: '| PUT | Update | Update or Modify any existing element into our app |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| PUT | 更新 | 更新或修改我们应用程序中的任何现有元素 |'
- en: '| DELETE | Delete | Delete or Remove any existing element into our app |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | 删除 | 从我们的应用程序中删除或移除任何现有元素 |'
- en: Designing APIs
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 API
- en: Now that we are clear about what HTTP is and the building blocks behind it,
    we need to design a friendly and robust API. Another advantage of this is that
    we will improve the developer experience in our organization by having a well-defined
    API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚 HTTP 是什么以及其背后的构建块，我们需要设计一个友好且健壮的 API。这个做法的另一个优点是，我们将通过拥有一个定义良好的 API
    来提高我们组织中的开发者体验。
- en: API documentation is another key practice that you have to apply in every API
    development you will do. With documentation, the development team and API consumers
    are aware of the full functionality of the API, because they are defined in an
    easy-to-read format. For example, the financial team and the logistics team in
    an organization can share their API documentation between them and start working
    on a possible integration solution immediately because they now know the full
    details of the APIs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: API 文档是你在将要进行的每个 API 开发中必须应用的关键实践之一。有了文档，开发团队和 API 消费者都会了解 API 的全部功能，因为它们是以易于阅读的格式定义的。例如，一个组织中的财务团队和物流团队可以共享他们的
    API 文档，并立即开始工作，因为他们现在知道了 API 的全部细节。
- en: Let's learn how to design robust APIs by understanding the API first movement
    and other design concepts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过了解 API 的第一步骤和其他设计概念来学习如何设计健壮的 API。
- en: API first
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 首选
- en: '**API first** is one of the most important concepts you should keep in mind
    while developing a new product or a service, you have to think of it as if it
    were the user interface for programmers. In fact, APIs are the way how you can
    expose the functionalities of your products in a distributed big system.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**API 首先**是在开发新产品或服务时你应该牢记的最重要概念之一，你必须把它看作是程序员的用户界面。实际上，API 是你如何在分布式大系统中暴露产品功能的方式。'
- en: 'Nowadays, techniques and approaches such as cloud applications and microservices
    are becoming adopted everywhere, and they suggest a new way to develop software.
    With microservices, you have to split your application into different independent
    services; each service contains a specific set of related features of your application,
    such as taking some Amazon APIs as an example, we can have something like the
    following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像云应用和微服务这样的技术和方法正在被广泛应用，并提出了软件开发的新方式。使用微服务，你必须将你的应用程序拆分为不同的独立服务；每个服务包含你应用程序中一组特定的相关功能，例如以一些亚马逊
    API 为例，我们可以有如下所示的内容：
- en: '![](img/42b387e7-abdf-4f3c-833d-9e0527cd5b4d.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42b387e7-abdf-4f3c-833d-9e0527cd5b4d.png)'
- en: As you can see, there are different services that need to exchange information
    and functionalities. All of those have to define a consistent and self-explained
    API that the other services have to use in order to either perform an operation
    in another service that it is not able to do or a client-side application will
    invoke the APIs directly to access some information.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，存在不同的服务需要交换信息和功能。所有这些都必须定义一个一致且自解释的 API，其他服务必须使用这个 API 来执行它们无法完成的操作，或者客户端应用程序可以直接调用
    API 来访问某些信息。
- en: The main understanding behind API first is that before you implement any code
    or UI design in your system, you should design your API in such a way that even
    if you don't have any user interface, developers should be able to navigate and
    access the information and functionality into your application data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: API 首先的主要理解是，在你为系统实现任何代码或 UI 设计之前，你应该以这样的方式设计你的 API，即使你没有用户界面，开发者也应该能够导航并访问你的应用程序数据中的信息和功能。
- en: API design
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 设计
- en: To design a robust, self-explained, friendly, and easy-to-use API, we will follow
    the set of best practices that have been used and implemented over the years by
    the internet gurus. Thankfully, some great developers and architects had defined
    a set of rules that we will cover in this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计一个健壮、自解释、友好且易于使用的 API，我们将遵循多年来互联网大牛们所使用和实施的最佳实践。幸运的是，一些优秀的开发者和架构师已经定义了一套规则，我们将在本节中介绍。
- en: Nouns as paths
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径作为名词
- en: 'Have you ever seen some API endpoints that contain a full sentence to access
    a resource? Some examples might be the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否见过一些包含完整句子来访问资源的 API 端点？以下是一些示例：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing to keep in mind is that you should never use verbs in your
    endpoints. Instead, use nouns in plural to refer to a resource into your API Endpoint.
    For example, the preceding example can be refactored to this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要记住的是，你永远不应该在你的端点中使用动词。相反，使用复数名词来指代你的 API 端点中的资源。例如，前面的例子可以被重构为以下内容：
- en: '| **The Rest way** - **Not recommended** | **The RESTful way** - **Recommended**
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **REST 方法** - **不推荐** | **RESTful 方法** - **推荐** |'
- en: '| `http://myshop.com/createNewProduct``http://myshop.com/deleteProduct``http://myshop.com/updateProduct`
    | `http://myshop.com/products` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `http://myshop.com/createNewProduct` `http://myshop.com/deleteProduct` `http://myshop.com/updateProduct`
    | `http://myshop.com/products` |'
- en: '| `http://myshop.com/getProductDetail/P01` | `http://myshop.com/products/P01`
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `http://myshop.com/getProductDetail/P01` | `http://myshop.com/products/P01`
    |'
- en: '| `http://myshop.com/getProductComments/P01` | `http://myshop.com/products/P01/comments`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `http://myshop.com/getProductComments/P01` | `http://myshop.com/products/P01/comments`
    |'
- en: 'A good practice is not to extend the path depth higher than three paths. For
    example, use this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是不将路径深度扩展超过三个路径。例如，使用以下方法：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Do that instead of the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to extend your API to perform additional operations such as getting
    the first 10 messages published today, use query strings instead of paths. Consider
    this example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要扩展你的 API 以执行额外的操作，例如获取今天发布的第一个 10 条消息，请使用查询字符串而不是路径。考虑以下示例：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: HTTP verbs for CRUD
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD 的 HTTP 动词
- en: 'Now that you have designed clean endpoints for your API, it is time to take
    advantage of what we learned about HTTP verbs. You might be asking yourself how
    do you differentiate when you want to create, update, or delete a product if you
    are using the same endpoint, `/products`? This is the case where we use HTTP verbs.
    For example, for the `/products` endpoint, we will have something like the following
    verbs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为你的 API 设计了干净的端点，是时候利用我们关于 HTTP 动词所学的知识了。你可能想知道，如果你使用相同的端点 `/products`，你如何区分创建、更新或删除产品？这就是我们使用
    HTTP 动词的情况。例如，对于 `/products` 端点，我们将有以下动词：
- en: '| **Endpoint** | **HTTP Verb** | **Goal** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **端点** | **HTTP 动词** | **目标** |'
- en: '| `/products` | POST | To create a new product |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `/products` | POST | 创建一个新的产品 |'
- en: '| `/products` | PUT | To update an existing product |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `/products` | PUT | 更新现有产品 |'
- en: '| `/products` | DELETE | To delete an existing product |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `/products` | DELETE | 删除现有产品 |'
- en: So from the preceding table, you can note that the key differentiator is the
    HTTP Verb. In short, an endpoint is composed by one path and an HTTP Verb.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表中，你可以注意到关键的区别在于 HTTP 动词。简而言之，一个端点由一个路径和一个 HTTP 动词组成。
- en: API documentation
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 文档
- en: 'When you are working on a real project, the number of endpoints you will need
    to design will be higher. You will need a way to remember all your endpoints and
    the reason they were designed. Similarly, we are confident that documenting software
    is extremely important for us to remember what a piece of code is supposed to
    do; API documentation allows us to tell the API consumers how they can use our
    API by documenting the endpoints and other additional metadata, such as the ones
    listed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在实际项目中工作时，你需要设计的端点数量将会更多。你需要一种方法来记住所有你的端点以及它们被设计的原因。同样，我们确信记录软件对于我们记住代码应该做什么非常重要；API
    文档允许我们通过记录端点和其他附加元数据（如以下列出的）来告诉 API 消费者如何使用我们的 API。
- en: Endpoint path
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点路径
- en: HTTP verbs
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 动词
- en: The expected headers
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期头信息
- en: The expected body structure
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期体结构
- en: The expected results
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期结果
- en: There is an awesome open source tool that helps you document and share the documentation
    with your APIs called **Swagger**. We encourage you to visit the official site
    and play with it at [https://swagger.io](https://swagger.io).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很棒的开源工具可以帮助你记录和分享你的 API 文档，它被称为 **Swagger**。我们鼓励你访问官方网站并尝试使用它：[https://swagger.io](https://swagger.io)。
- en: 'A possible documentation might be just a simple table that contains the data
    used in the request and responses. For example, the documentation to create a
    new product might be this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的文档可能只是一个简单的表格，包含请求和响应中使用的数据。例如，创建新产品的文档可能如下所示：
- en: '| **Path** | **Products** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **路径** | **产品** |'
- en: '| HTTP method | POST |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 方法 | POST |'
- en: '| Expected Results | HTTP 200 OK status code |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 预期结果 | HTTP 200 OK 状态码 |'
- en: '| Expected Input Headers | Content-type: `application/json` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 预期输入头信息 | Content-type: `application/json` |'
- en: '| Expected Input Body | {`id`: `Integer`, `name`: `String`, `price`: `Decimal`}
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 预期输入体 | {`id`: `Integer`, `name`: `String`, `price`: `Decimal`} |'
- en: '| Goal | Use this endpoint to create a new product |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 目标 | 使用此端点创建一个新产品 |'
- en: '| Authorization | Required Authorization Token |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 授权 | 需要授权令牌 |'
- en: Having the knowledge of how to design self-explained APIs and how to use HTTP
    to create endpoints, let's move forward to implement a RESTful API with Node.js.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了如何设计自解释的 API 以及如何使用 HTTP 创建端点之后，让我们继续使用 Node.js 实现一个 RESTful API。
- en: Creating an API with Node.js
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 创建 API
- en: It's time to start having fun and code our RESTful API. Until now you have seen
    the theory behind APIs and that knowledge is very important to understand the
    following sections. So, you might be wondering, why Node.js? The short answer
    is because it is cool! Haha, just kidding. Node.js has evolved since its creation
    in 2009 by *Ryan Dahl*. Node.js is used for leading companies over the world,
    such as LinkedIn, Facebook, Amazon, and more.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始享受编码我们的 RESTful API 了。到目前为止，你已经看到了 API 背后的理论，这些知识对于理解以下部分非常重要。所以，你可能想知道为什么选择
    Node.js？简短的答案是它很酷！哈哈，开个玩笑。Node.js 自 2009 年由 *Ryan Dahl* 创建以来已经发展演变了。Node.js 被世界各地的领先公司使用，如
    LinkedIn、Facebook、Amazon 等。
- en: Node.js is not limited to API Development. In fact, you might create any kind
    of project from command-line tools to **Internet of Things** (**IoT**) applications.
    So, let's start learning about the advantages of Node.js and coding our API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 不限于 API 开发。实际上，你可以从命令行工具到 **物联网**（**IoT**）应用创建任何类型的项目。因此，让我们开始学习 Node.js
    的优势以及如何编写我们的 API。
- en: Node advantages
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js优势
- en: Node.js has a lot of advantages; we will explore the more important ones in
    the following subtopics.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有很多优势；我们将在以下子主题中探索其中更重要的一些。
- en: Asynchronous
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步
- en: 'In most programming languages, I/O operations are performed synchronously.
    Synchronous execution will block the program flow until the blocking operation
    finishes its execution. For example, the following Python code is executed synchronously
    and blocks the execution:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，I/O操作是同步执行的。同步执行将阻塞程序流程，直到阻塞操作完成其执行。例如，以下Python代码是同步执行的，并阻塞了执行：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The total execution time will be approximately 30 seconds. That is because
    of the I/O Blocking operation. If we represent the synchronous execution as a
    timeline:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总执行时间大约为30秒。这是因为I/O阻塞操作。如果我们用时间线表示同步执行：
- en: '![](img/75eedb21-1266-4f3b-9f80-69072f285285.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75eedb21-1266-4f3b-9f80-69072f285285.png)'
- en: 'Now if we execute the same operation in an asynchronous way using JavaScript:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们使用JavaScript以异步方式执行相同的操作：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the previous code, you can note that we use a callback to process the content
    of the file. Callbacks are functions that are invoked after some events occur.
    For example, `(file_content)=> {}` will be called once the content of `my_file.txt`
    is ready to use.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，你可以注意到我们使用回调来处理文件的内容。回调是在某些事件发生后被调用的函数。例如，`(file_content)=> {}`将在`my_file.txt`的内容准备好使用时被调用。
- en: 'The two `open()` statements will be executed at the same time. Executing the
    statements in parallel will help us reduce the execution time. For example, let''s
    see the timeline execution for this asynchronous code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`open()`语句将同时执行。并行执行这些语句将帮助我们减少执行时间。例如，让我们看看这个异步代码的时间线执行：
- en: '![](img/33587146-6ad1-4b24-aec8-aeb06e94b7f1.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33587146-6ad1-4b24-aec8-aeb06e94b7f1.png)'
- en: Now the execution will be just 20 seconds, and, with this, we have improved
    our application performance. This is one of the key advantages that Node.js brings
    up to the game.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行时间将仅为20秒，并且，通过这种方式，我们已经提高了应用程序的性能。这是Node.js带来的关键优势之一。
- en: Single-thread
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单线程
- en: 'Every time a new user request arrives at the backend server it will create
    a new thread for the request, this is the classic behavior for backend servers
    that don''t use Node.js. Once the server sends the response to the user, it releases
    the thread. Handling just a few threads is not an issue but, imagine what would
    happen if you need to handle millions of users at the same time? Let''s graph
    this issue:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个新的用户请求到达后端服务器时，它将为该请求创建一个新的线程，这是不使用Node.js的后端服务器的经典行为。一旦服务器向用户发送响应，它就会释放线程。处理几个线程没问题，但想象一下，如果你需要同时处理数百万用户会发生什么？让我们用图表来展示这个问题：
- en: '![](img/46d145e2-1374-4ba8-b5f2-af04627ef2d8.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46d145e2-1374-4ba8-b5f2-af04627ef2d8.png)'
- en: 'Node.js does not have this issue because of its single-thread strategy. Instead
    of starting a new thread for each request, it will use the same main thread to
    handle all the requests and will be supported by the event-loop. The following
    diagram depicts this scenario:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js由于其单线程策略而没有这个问题。它不会为每个请求启动一个新的线程，而是将使用相同的主线程来处理所有请求，并由事件循环支持。以下图表描述了这种情况：
- en: '![](img/9301b979-ae59-454d-aaf8-a35bbeaaf4aa.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9301b979-ae59-454d-aaf8-a35bbeaaf4aa.png)'
- en: This scenario is better for CPU utilization; multiple threads allow NodeJS to
    take advantage of multi-core CPUs. However, we need more than a simple chapter
    to talk about them. We strongly encourage you to visit the official Node.js site
    at [https://nodejs.org/en/](https://nodejs.org/en/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景更适合CPU利用率；多个线程允许Node.js利用多核CPU。然而，我们需要超过一个简单的章节来讨论它们。我们强烈建议您访问官方Node.js网站[https://nodejs.org/en/](https://nodejs.org/en/)。
- en: Now it's time to code a simple HTTP Server and start the fun part!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写一个简单的HTTP服务器并开始有趣的环节了！
- en: Simple HTTP Server
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单HTTP服务器
- en: 'It is time to start coding and see how we can implement a simple HTTP Server
    using Node.js. So, open your Terminal and in the working directory of your choice,
    go ahead and create a new folder called `my-server`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始编码，看看我们如何使用Node.js实现一个简单的HTTP服务器了。所以，打开你的终端，并在你选择的目录中，创建一个名为`my-server`的新文件夹：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you move into the `my-server` folder, we will need to initialize an NPM
    module, so run the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入`my-server`文件夹，我们需要初始化一个NPM模块，所以运行以下命令：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now it''s time to create the `server.js`file by executing the `touch server.js`
    command in your Terminal. This file will contain the code for our server. We will
    start importing the HTTP module:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过在终端中执行 `touch server.js` 命令来创建 `server.js` 文件了。这个文件将包含我们服务器的代码。我们将开始导入
    HTTP 模块：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We import any module using the `require` built-in function, and we define the
    `http` variable to house the module reference. Let''s implement a simple handler
    by writing the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置的 `require` 函数导入任何模块，并定义 `http` 变量来存放模块引用。让我们通过编写以下代码来实现一个简单的处理器：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, a handler is just a function that declares two parameters:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理器只是一个声明了两个参数的函数：
- en: '`request`: Used to read the information sent by the client'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`：用于读取客户端发送的信息'
- en: '`response`: Used to send information to the client'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response`：用于向客户端发送信息'
- en: 'Our handler is using the `response` parameter to send our friendly message
    to the client. Now it''s time to create a server instance using the `http` reference
    we declared earlier:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理器正在使用 `response` 参数将友好的消息发送给客户端。现在是我们使用之前声明的 `http` 引用创建服务器实例的时候了：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are creating an empty server that does not perform any operation. To make
    our server useful, we pass the `request` handler we declared earlier, `myRequestHandler`.
    With this, our server is able to send our `Hello` message every time some client
    sends an HTTP request to our server. To finish our server implementation, we need
    to listen to the client request:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个不执行任何操作的空服务器。为了使我们的服务器变得有用，我们传递之前声明的 `request` 处理器 `myRequestHandler`。有了这个，每当某个客户端向我们的服务器发送
    HTTP 请求时，我们的服务器就能够发送我们的 `Hello` 消息。为了完成我们的服务器实现，我们需要监听客户端请求：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That''s all! Now that we have a simple HTTP, execute the `node server.js` command
    to run the server. Let''s test things out. Head over to [http://localhost:5000](http://localhost:5000)
    and you should see something like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！现在我们有一个简单的 HTTP 服务器，执行 `node server.js` 命令来运行服务器。让我们测试一下。转到 [http://localhost:5000](http://localhost:5000)，您应该看到以下内容：
- en: '![](img/24f16fb3-ea3a-41a1-adbb-69356cf27bd9.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24f16fb3-ea3a-41a1-adbb-69356cf27bd9.png)'
- en: Now you know how to create a simple HTTP server using the native HTTP module
    that comes along with Node.js. However, in order to create a powerful RESTful
    backend, we need to use a more sophisticated framework.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何使用 Node.js 内置的 HTTP 模块创建一个简单的 HTTP 服务器。然而，为了创建一个强大的 RESTful 后端，我们需要使用一个更复杂的框架。
- en: In the next section, we will enhance our simple server using Express.js.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 Express.js 来增强我们的简单服务器。
- en: Improving our API with Express.js
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express.js 优化我们的 API
- en: Express.js is an open source web framework created on top of Node.js. We can
    implement our REST API using the Node.js HTTP module, but we will have to write
    a lot of code to handle a simple user request. Express.js is very flexible and
    provides a set of features that will allow us to create robust APIs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 是一个基于 Node.js 的开源 Web 框架。我们可以使用 Node.js 的 HTTP 模块来实现我们的 REST API，但我们需要编写大量的代码来处理简单的用户请求。Express.js
    非常灵活，并提供了一套功能，使我们能够创建健壮的 API。
- en: Coding our server
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的服务器
- en: 'It''s time to create our FIFA backend folder and start working on the API development.
    Open your Terminal and run the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们的 FIFA 后端文件夹并开始 API 开发了。打开您的终端并运行以下命令：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the initialization is done, let''s install Express.js. Execute the following
    command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，让我们安装 Express.js。执行以下命令：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, create the `server.js` file in the root folder and write the following
    code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在根目录中创建 `server.js` 文件，并编写以下代码：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We start importing the `express` module and instantiation of an express application
    into the `app` variable. Next, we use the application instance to configure a
    simple request handler using the `app.use` function. Into this function, we pass
    another function as a parameter that has two parameters for the request and response:
    `req` and `res`. To send a simple message, we use the `res` parameter.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始导入 `express` 模块并将一个 express 应用实例化到 `app` 变量中。接下来，我们使用应用实例通过 `app.use` 函数配置一个简单的请求处理器。在这个函数中，我们传递另一个作为参数的函数，该函数有两个参数：请求和响应：`req`
    和 `res`。为了发送一个简单的消息，我们使用 `res` 参数。
- en: 'Once the server application instance is configured, we bring it to life by
    calling its `listen` function and passing the HTTP port where it will listen to
    new HTTP requests:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用实例配置完成后，我们通过调用其 `listen` 函数并传递它将监听新 HTTP 请求的 HTTP 端口来激活它：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We strongly recommend you to use **nodemon** in development. The nodemon will
    restart your node application every time it detects a change in your source code
    automatically. To install nodemon, just execute the `npm install -g nodemon` command.
    To run your server, use the `nodemon server.js` command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议你在开发中使用**nodemon**。nodemon会在检测到源代码中的更改时自动重启你的Node应用程序。要安装nodemon，只需执行`npm
    install -g nodemon`命令。要运行你的服务器，使用`nodemon server.js`命令。
- en: 'Let''s test it by opening `http://localhost:3000` in your browser or using
    an HTTP client command-line tool. Consider the given example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在浏览器中打开`http://localhost:3000`或使用HTTP客户端命令行工具来测试它。考虑以下示例：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So far so good! Let''s define a route path to make a self-explanatory API.
    Apply the following change to the `server.js` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利！让我们定义一个路由路径来创建一个自解释的API。将以下更改应用到`server.js`文件中：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, head over to `http://localhost:3000/hello` and you should see the same `Hello!`
    message. You can navigate to `http://localhost:3000` to see what you get after
    the change:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往`http://localhost:3000/hello`，你应该会看到相同的`Hello!`消息。你可以导航到`http://localhost:3000`来查看更改后的结果：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using routes
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由
- en: 'Routes are the magic behind our RESTful API. If you remember when we talked
    about HTTP verbs, RESTful is composed by combining CRUD operations with the HTTP
    verbs. Express.js makes easy the definition of these RESTful way. For example,
    open the `server.js`file and apply the following change:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是我们RESTful API背后的魔法。如果你记得我们之前讨论HTTP动词时的情况，RESTful是通过将CRUD操作与HTTP动词结合而成的。Express.js使得定义这些RESTful方式变得简单。例如，打开`server.js`文件并应用以下更改：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, we changed `use` for `get`. As you are so smart, you know that `get`
    refers to the GET HTTP verb, so let''s define our RESTful routes for our Teams
    API. In the `server.js`*, *apply the following changes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将`use`更改为`get`。既然你这么聪明，你知道`get`指的是GET HTTP动词，所以让我们定义我们的队伍API的RESTful路由。在`server.js`中应用以下更改：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we apply these changes, it''s time to test them. Run the following commands
    in your Terminal:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了这些更改，就是测试它们的时候了。在你的终端中运行以下命令：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Cool! our RESTful API is responding correctly. Note that we use the `-X [HTTP
    Verb]` to tell curl which HTTP verb we want to use for the given request. Now
    that we are ready with the main skeleton of our API, we need to structure our
    project in a consistent way because we will create a group of files and should
    always organize our source code. Keep reading!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的RESTful API响应正确。注意，我们使用`-X [HTTP Verb]`来告诉curl我们想要为给定请求使用哪个HTTP动词。现在我们已经准备好了我们API的主要骨架，我们需要以一致的方式组织我们的项目，因为我们将会创建一组文件，并且应该始终组织我们的源代码。继续阅读！
- en: Coding our project
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码我们的项目
- en: 'Here we are! We will implement the code of our project. Our application is
    composed of three domains:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里我们就位了！我们将实现我们项目的代码。我们的应用程序由三个领域组成：
- en: '**Teams**: To manage the information of all the teams that participate in the
    World Cup competition'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队伍**：用于管理参加世界杯比赛的队伍信息'
- en: '**Matches**: To manage the information of all the Matches during the competition'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比赛**：用于管理比赛期间所有比赛的信息'
- en: '**Security**: To manage the information of the users and permissions'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：用于管理用户信息和权限'
- en: The teams and matches follow the same implementation with a few variants. For
    that reason, in this section, we will write the code to implement the `Team` domain
    and then expose it via our API, and you will be able to implement the code for
    the `Match` domains yourself. Of course, the complete source code is available
    in the [https://github.com/Packt-Aurelia-Fullstack-Book/worldcup-app](https://github.com/Packt-Aurelia-Fullstack-Book/worldcup-app) GitHub
    repository.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 队伍和比赛遵循相同的实现方式，只有一些小的变化。因此，在本节中，我们将编写实现`Team`领域的代码，并通过我们的API公开它，然后你可以自己实现`Match`领域的代码。当然，完整的源代码可以在[https://github.com/Packt-Aurelia-Fullstack-Book/worldcup-app](https://github.com/Packt-Aurelia-Fullstack-Book/worldcup-app)的GitHub仓库中找到。
- en: So, having said that. Let's start!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，既然已经说到了这里。让我们开始吧！
- en: Our project structure
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的项目结构
- en: 'Let''s start by creating the Project structure for our source code. Create
    the following directories and files in your working directory, as shown in the
    following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们源代码的项目结构开始。在你的工作目录中创建以下目录和文件，如下面的截图所示：
- en: '![](img/26946484-c911-44b4-93e6-93f432fb096c.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26946484-c911-44b4-93e6-93f432fb096c.png)'
- en: 'The `src` folder contains three subfolders: `models`, `routes`, and `config`.
    In this chapter, we will just use the `routes` folder and the `teams-api.js` file.
    The other two will be explored in the next chapter when we talk about Databases
    and MongoDB.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 文件夹包含三个子文件夹：`models`、`routes` 和 `config`。在本章中，我们将仅使用 `routes` 文件夹和 `teams-api.js`
    文件。其他两个将在下一章讨论数据库和MongoDB时进行探讨。'
- en: The goal of the routes folder is to host all the API Routes declaration. We
    have declared our routes in the `server.js` file; it might be a good idea if we
    are working on a small project, but it is not a good idea for a big project, which
    will have a lot of routes declarations. For that reason, a good strategy is to
    separate the routes per API functionality; for example, teams-API, matches-API,
    and auth-API. With this, we will have more easy-to-read and easy-to-maintain code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 路由文件夹的目标是托管所有API路由声明。我们已在 `server.js` 文件中声明了我们的路由；如果我们正在处理一个小项目，这可能是个好主意，但对于将有很多路由声明的大项目来说，这并不是一个好主意。因此，一个很好的策略是按API功能分离路由；例如，teams-API、matches-API和auth-API。这样，我们将拥有更易于阅读和易于维护的代码。
- en: Implementing the Teams API
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Teams API
- en: 'Before we start coding, we have to design our API first. The following table
    contains the documentation for the API we will implement:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我们必须首先设计我们的API。以下表格包含了我们将要实现的API的文档：
- en: '| **Route** | **HTTP Verb** | **Goal** | **Responses** |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **路由** | **HTTP方法** | **目标** | **响应** |'
- en: '| `/teams` | GET | List all the teams | Http 200 - OK |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `/teams` | GET | 列出所有团队 | Http 200 - OK |'
- en: '| `/teams` | POST | Create a new team with body{`name`: String} | Http 201
    - Created |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `/teams` | POST | 创建新的团队，请求体为{`name`: String} | Http 201 - Created |'
- en: '| `/teams/:id` | GET | Get a single team | Http 200 -OKHttp 404 - Not Found
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `/teams/:id` | GET | 获取单个团队 | Http 200 - OKHttp 404 - Not Found |'
- en: '| `/teams/:id` | PUT | Update an existing team | Http 200 -OKHttp 404 - Not
    Found |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `/teams/:id` | PUT | 更新现有团队 | Http 200 - OKHttp 404 - Not Found |'
- en: '| `/teams/:id` | DELETE | Delete an existing team | Http 200 -OKHttp 404 -
    Not Found |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `/teams/:id` | DELETE | 删除现有团队 | Http 200 - OKHttp 404 - Not Found |'
- en: Keeping this in mind, let's begin with the fun part!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点，让我们开始有趣的环节！
- en: Configuring the JSON Parser
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置JSON解析器
- en: 'We will start by configuring our server to be able to parse JSON. This means
    that Express.js will automatically parse the data that flows in and out of the
    HTTP Request. The following diagram explains this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先配置我们的服务器以能够解析JSON。这意味着Express.js将自动解析HTTP请求进出的数据。以下图表解释了这一点：
- en: '![](img/bf677a86-a721-409c-ae8c-0519f0504280.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf677a86-a721-409c-ae8c-0519f0504280.png)'
- en: As you can see, all the requests will be intercepted by the **JSON Parser**. The
    **JSON Parser** is better known as a **middleware**. A middleware is just a simple
    function that is processed before another function. For example, the **GET /teams**
    function is supposed to be the only function that should be called in every request,
    but as we have configured the **JSON Parser**, the **GET /teams** will be invoked
    once the **JSON Parser** function is completed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有请求都将被 **JSON解析器** 截获。**JSON解析器** 更为人所知的是 **中间件**。中间件只是一个简单的函数，它在另一个函数之前被处理。例如，**GET
    /teams** 函数应该是在每个请求中应该调用的唯一函数，但由于我们已配置了**JSON解析器**，**GET /teams** 将在**JSON解析器**函数完成后被调用。
- en: 'To configure this in our code, first we need to install it. Run the `npm install
    --save body-parser` in your terminal and apply the following changes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的代码中配置此功能，首先我们需要安装它。在终端中运行 `npm install --save body-parser`，并应用以下更改：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we import the `body-parser` module. Then, we configure the application
    to use our `bodyParser.json()` using its `app.use` function. All the middleware
    are configured by calling this function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 `body-parser` 模块。然后，我们使用 `app.use` 函数配置应用程序使用我们的 `bodyParser.json()`。所有中间件都是通过调用此函数进行配置的。
- en: 'Lastly, to test whether the JSON Parser is working, we define the `teams` variable
    containing two teams with their respective names. To send the `teams`, we use `res.json`
    instead of `res.send`. Let''s check the results by executing the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试JSON解析器是否工作正常，我们定义了一个包含两个团队及其相应名称的 `teams` 变量。要发送 `teams`，我们使用 `res.json`
    而不是 `res.send`。让我们通过执行以下命令来检查结果：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that our API is able to receive and send JSON, let's move our routes to
    its own file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们API能够接收和发送JSON，让我们将路由移动到自己的文件中。
- en: Refactoring routes
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构路由
- en: 'We previously created the `teams-api.js` file in the `routes`folder. Open that
    file and apply the following changes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 `routes` 文件夹中创建了 `teams-api.js` 文件。打开该文件并应用以下更改：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First, we import the `express` module. From this module, we are declaring the
    `api` variable, which is an instance of `express.Router`. A `teams` variable has
    been created in order to host some fake data for the teams. We will use this router
    to configure our CRUD/HTTP handlers, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`express`模块。从这个模块中，我们声明了`api`变量，它是一个`express.Router`的实例。为了存储一些关于团队的假数据，我们创建了一个`teams`变量。我们将使用这个路由来配置我们的CRUD/HTTP处理器，如下所示：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using the `api` route variable, we define the `'/teams'` path as root for the
    HTTP handlers. In the `get` handler, we are just sending the list of teams as
    the response.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`api`路由变量，我们定义`'/teams'`路径作为HTTP处理器的根路径。在`get`处理器中，我们只是发送团队的列表作为响应。
- en: 'Lastly, we need to export the `api` route to be used in the `server.js`file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将`api`路由导出以便在`server.js`文件中使用：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we are ready, open the `server.js`file to apply the following changes
    that will configure the server to use this route:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了，打开`server.js`文件以应用以下更改，这将配置服务器使用此路由：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, we import the Teams API module from the relative path into our project
    and use the `app.use` function to configure our routes. Let''s test things out;
    run the following command in your Terminal:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从相对路径导入Teams API模块到我们的项目中，并使用`app.use`函数来配置我们的路由。让我们测试一下；在您的终端中运行以下命令：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Cool! Now we have our code clean and everything is working as we expect. It's
    time to write some code to implement the POST, PUT, and DELETE handlers. We will
    use the fake `teams` variable to add data in memory until we learn how to use
    a real database in the next chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们的代码整洁，一切按预期工作。是时候编写一些代码来实现POST、PUT和DELETE处理器了。我们将使用假的`teams`变量在内存中添加数据，直到我们学习如何在下一章中使用真正的数据库。
- en: Creating a team
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建团队
- en: 'To create a team, we need to implement the POST handler. The data to the new
    team will be sent into the `body` parameter into the HTTP Request. Apply the following
    changes to the `teams-api.js`file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个团队，我们需要实现POST处理器。新团队的数据将通过HTTP请求的`body`参数发送。将以下更改应用到`teams-api.js`文件中：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we read the data from the `req.body` property. Then, we insert the new
    element into the `teams` array. Lastly, we send the `teams` array with the new
    team added and specify the HTTP status 201, which means Resource Created.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`req.body`属性读取数据。然后，我们将新元素插入到`teams`数组中。最后，我们发送包含新团队的`teams`数组，并指定HTTP状态码201，表示资源已创建。
- en: You can find the full list of HTTP statuses at [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)找到完整的HTTP状态码列表。
- en: 'To test things out, we will call our API using the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们将使用以下命令调用我们的API：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our command is a little weird this time. As we are using JSON, we have to explicitly
    tell the HTTP Request that we are sending JSON data, so we use the `-H` header
    option. To send the information, we use the `-d` data option. That's all! It looks
    difficult but it is not.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的命令这次有点奇怪。因为我们使用JSON，我们必须明确告诉HTTP请求我们正在发送JSON数据，所以我们使用`-H`头选项。为了发送信息，我们使用`-d`数据选项。就这样！看起来很难，但实际上并不难。
- en: Now you can use the GET method to list all the teams and see the new team added
    to our list.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用GET方法列出所有团队并查看添加到我们列表中的新团队。
- en: Retrieving the list
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索列表
- en: 'We already have the list handler, but the listing is not enough. Apart from
    retrieving the full list, we will need to retrieve a single team. To do this,
    we will need to add a new GET route and learn how to use params. Apply the following
    changes into the `teams-api.js`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了列表处理器，但列表还不够。除了检索完整列表外，我们还需要检索单个团队。为此，我们需要添加一个新的GET路由并学习如何使用参数。将以下更改应用到`teams-api.js`中：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we declare a new route, which now contains a dynamic param—`/teams/:api`.
    We said dynamic because, of course, it can take any value that will be available
    as an attribute of the `req.params` object. Note that the name you use for your
    param will be created as a property, for example, `req.params.id` in this case.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明了一个新的路由，它现在包含一个动态参数—`/teams/:api`。我们称之为动态参数，因为当然它可以取任何值，这些值将作为`req.params`对象的属性可用。请注意，你为参数使用的名称将被创建为一个属性，例如，在这个例子中是`req.params.id`。
- en: Next, we create a simple `for` loop that iterates across the full list of teams
    and looks for the team that has the same `id` we passed in the route param. If
    a team is found, we send the team by calling the `res.json(team)` statement. As
    we want to quit the handler immediately after we send the response, we use `return` to
    exit the handler. If a team is not found, we send an error message and mark the
    response with the HTTP `status` 404, which means Resource not found.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个简单的 `for` 循环，遍历完整的团队列表，寻找与路由参数中传递的相同 `id` 的团队。如果找到团队，我们通过调用 `res.json(team)`
    语句发送团队。由于我们希望在发送响应后立即退出处理程序，我们使用 `return` 来退出处理程序。如果没有找到团队，我们发送一个错误消息，并将响应标记为
    HTTP `status` 404，这意味着资源未找到。
- en: 'Lastly, to test our implementation, execute the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试我们的实现，执行以下命令：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Keep in mind that by default, curl always sends a -X GET request if no HTTP
    verb has been explicitly defined.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认情况下，curl 总是发送一个 -X GET 请求，如果没有明确定义 HTTP 动词。
- en: Let's continue with our last two implementations for PUT and DELETE.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的最后两个实现，PUT 和 DELETE。
- en: Updating a Team
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新一个团队
- en: 'The update process is a combination of two processes—the search for a team
    and the update process itself. In the previous implementation, we wrote the code
    to look up an existing team. So, let''s reuse the same code by defining a function
    that can be used for retrieve, update, and delete. Open the `teams-api.js`file
    and apply the following changes:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 更新过程是两个过程的组合——搜索团队和更新过程本身。在前一个实现中，我们编写了查找现有团队的代码。所以，让我们通过定义一个可以用于检索、更新和删除的函数来重用相同的代码。打开
    `teams-api.js` 文件并应用以下更改：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We created the `lookupTeam` function, which expects for the `id` as a param
    and will return a valid team index if it is found. Otherwise, it will return -1\.
    Now we need to refactor our handle to retrieve a Team:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `lookupTeam` 函数，它期望 `id` 作为参数，如果找到，将返回一个有效的团队索引。否则，它将返回 -1。现在我们需要重构我们的处理程序以检索团队：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Having done that, let''s implement our update handler. Apply the following
    changes in the same `teams-api`file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，让我们实现我们的更新处理程序。在相同的 `teams-api` 文件中应用以下更改：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So we define a `.put` route and look up for a team by passing the `id` param.
    If a valid index is returned, we save the team instance in the `team` variable
    and apply the change to its `name` property by reading the data from the `request.body`
    object and finally, we send the updated team. If there is not a valid index for
    the ID passed, we return a `Not Found` message.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个 `.put` 路由，并通过传递 `id` 参数来查找一个团队。如果返回一个有效的索引，我们将团队实例保存在 `team` 变量中，并通过从
    `request.body` 对象中读取数据来应用更改到其 `name` 属性，最后发送更新后的团队。如果传递的 ID 没有有效的索引，我们返回一个 `Not
    Found` 消息。
- en: 'Execute the following command to test things out:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来测试：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Deleting a Team
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除一个团队
- en: 'The `delete` process is similar to the `update`. First, we need to retrieve
    a valid index from the `teams` array and then remove it from there. Open the `teams-api.js`file
    and apply the following changes:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 过程与 `update` 类似。首先，我们需要从 `teams` 数组中检索一个有效的索引，然后将其从中删除。打开 `teams-api.js`
    文件并应用以下更改：'
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So we define a `.delete` route and look up for a team by passing the `id` param.
    If a valid index is returned, we save the team instance in the `team` variable.
    Next, we delete the element from the array using the `splice(index, 1)` expression.
    Lastly, we return the deleted `team` just for the information purposes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个 `.delete` 路由，并通过传递 `id` 参数来查找一个团队。如果返回一个有效的索引，我们将团队实例保存在 `team` 变量中。接下来，我们使用
    `splice(index, 1)` 表达式从数组中删除元素。最后，我们仅为了信息目的返回被删除的 `team`。
- en: We are done! We have implemented a RESTful API that exposes HTTP handlers for
    our Teams feature. We need to apply security to our routes and other advanced
    features. We will learn all about that in subsequent chapters. Keep reading!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！我们已经实现了一个暴露 HTTP 处理程序的 RESTful API，用于我们的团队功能。我们需要对我们的路由和其他高级功能应用安全性。我们将在后续章节中学习所有这些内容。继续阅读！
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the API's world and understood how APIs are implemented
    using the HTTP Protocol and CRUD operations. This great combination enables the
    exchange of information easier than before.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了 API 的世界，并了解了如何使用 HTTP 协议和 CRUD 操作来实现 API。这种伟大的组合使得信息交换比以前更容易。
- en: We also learned how to create an API using Node.js and saw how easy it is to
    build a RESTful API using one of the most popular open source web frameworks—Express.js.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用 Node.js 创建 API，并看到了如何使用最流行的开源 Web 框架之一 Express.js 构建一个 RESTful API
    是多么容易。
- en: In the next chapter, we will integrate our API with MongoDB in order to save
    information in a real database instead of sending fake data. It's getting better.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的API与MongoDB集成，以便将信息保存到真实的数据库中，而不是发送虚假数据。情况正在变得更好。
