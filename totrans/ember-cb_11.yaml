- en: Chapter 11. Real-Time Web Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。实时网络应用程序
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Using dependency injection
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖注入
- en: Working with application initializers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与应用程序初始化器一起工作
- en: Building a chat application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建聊天应用程序
- en: Creating and working with add-ons
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用插件
- en: Learning the Ember run loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Ember 运行循环
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As you level up with Ember, you'll learn how to work with real-time applications.
    In these types of applications, you'll be dealing with updates from a server.
    You'll need to be able to handle these events and notify the user as needed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你使用 Ember 的技能提升，你将学习如何处理实时应用程序。在这些类型的应用程序中，你将处理来自服务器的更新。你需要能够处理这些事件并在需要时通知用户。
- en: In Ember, we can use things such as dependency injection and services with WebSockets
    to handle real-time events from a server. We'll be looking at these concepts,
    including add-ons, in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ember 中，我们可以使用诸如依赖注入和 WebSocket 服务之类的功能来处理来自服务器的实时事件。在本章中，我们将探讨这些概念，包括插件。
- en: Using dependency injection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入
- en: The dependency injection pattern is used to declare and instantiate classes
    of objects and handle dependencies between them. In Ember, we can take objects
    or services and inject them into routes, controllers, or components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式用于声明和实例化对象的类以及处理它们之间的依赖关系。在 Ember 中，我们可以将对象或服务注入到路由、控制器或组件中。
- en: In this recipe, we'll take a logger object and inject it into our controllers
    using dependency injection.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用依赖注入将记录器对象注入到我们的控制器中。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In a new application, install the `moment` library and create a new `initializer`:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用程序中安装 `moment` 库并创建一个新的 `initializer`：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will install the Bower **Moment.js** library. We'll use this for our custom
    logger.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装 Bower **Moment.js** 库。我们将使用它来创建自定义记录器。
- en: 'Import the Moment library to the Ember project:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Moment 库导入 Ember 项目：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `app.import` statement adds the `moment` library to the application.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app.import` 语句将 `moment` 库添加到应用程序中。'
- en: 'In the `application.js` file in the `initializers` folder, add a new logger:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initializers` 文件夹中的 `application.js` 文件中添加一个新的记录器：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a new logger called `myLogger`. It uses the built-in `Ember.Logger`
    and adds a timestamp to it using the `moment` library that was installed earlier.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个名为 `myLogger` 的新记录器。它使用之前安装的内置 `Ember.Logger` 并添加了一个时间戳。
- en: 'Let''s take a look at this in more detail:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更详细地看看：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `application.register` method registers a new factory. The first argument
    is the registration key. The registration key is always two parts separated by
    a colon `:`. The first part is the type of factory and the second part is the
    name of the factory. The type of factory can be a template, `component`, `controller`,
    or `service`, or you can create your own. In this example, I called it `myLogger`.
    The second argument is the object you want to register, `MyLogger`:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`application.register` 方法注册了一个新的工厂。第一个参数是注册键。注册键总是由冒号 `:` 分隔的两个部分组成。第一部分是工厂的类型，第二部分是工厂的名称。工厂的类型可以是模板、`component`、`controller`
    或 `service`，或者你可以创建自己的。在这个例子中，我将其命名为 `myLogger`。第二个参数是你想要注册的对象，`MyLogger`：'
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This application inject makes the new `myLogger:zzz` factory available in all
    controllers. The value of `myLogger` comes from the `myLogger:zzz` factory.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个应用程序注入使新的 `myLogger:zzz` 工厂在所有控制器中可用。`myLogger` 的值来自 `myLogger:zzz` 工厂。
- en: 'Create a new application controller and add a new action that logs using the
    new `myLogger` debugger:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序控制器并添加一个新的使用新的 `myLogger` 调试器的记录动作：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When a new `press` action occurs, it logs to the console, `Hello World`.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当发生新的 `press` 动作时，它会在控制台记录 `Hello World`。
- en: 'Add `action` to the application template:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `action` 添加到应用程序模板：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the button is clicked, the `press` action is triggered.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当按钮被点击时，`press` 动作被触发。
- en: Run `ember server` and you'll see the following screen:![How to do it...](img/00087.jpeg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server`，你将看到以下屏幕：![如何做到这一点...](img/00087.jpeg)
- en: 'Press **Button** and you''ll see something as follows in the console:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按下**按钮**，你将在控制台看到以下内容：
- en: '![How to do it...](img/00088.jpeg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/00088.jpeg)'
- en: Each time you click the button, it logs a debug statement to the console.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次点击按钮时，它都会在控制台记录一个调试语句。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Dependency injection occurs when we take objects and inject them into other
    objects during instantiation. Ember can do this with the `application.inject`
    method. To accomplish this in Ember, we must create factories. Factories are simply
    objects that return other objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入发生在我们实例化时将对象注入到其他对象中的过程。Ember可以通过`application.inject`方法来实现这一点。要在Ember中完成此操作，我们必须创建工厂。工厂只是返回其他对象的简单对象。
- en: Ember registers these factories in `Ember.Application`. `Ember.Application`
    acts as a registry of sorts that holds different factories. After being registered,
    they can be injected into other parts of the Ember application such as components
    or controllers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ember将这些工厂注册到`Ember.Application`中。`Ember.Application`充当一种注册表，其中包含不同的工厂。注册后，它们可以被注入到Ember应用的其它部分，如组件或控制器。
- en: Working with application initializers
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用初始化器
- en: Application initializers can be used to configure your application as it boots.
    It's the primary place to set up dependency injections in your application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用初始化器可以在应用启动时配置您的应用。这是设置应用中依赖注入的主要位置。
- en: In this example, we'll examine when an application initializer is run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将检查应用初始化器何时运行。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new application, create `initializer`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新应用中，创建`initializer`：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will create a new application `initializer`. This will be run as soon as
    the application boots.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个新的应用`initializer`。它将在应用启动时立即运行。
- en: 'Add an alert box to the initializer:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中添加一个警告框：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will load an `alert` box as soon as the application loads.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在应用加载时立即加载一个`alert`框。
- en: Run `ember server` and you should see an alert box displayed before the application
    is loaded:![How to do it...](img/00089.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ember server`，您应该在应用加载前看到一个警告框：![如何操作...](img/00089.jpeg)
- en: Nothing else has loaded in the application before this alert box is shown.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在显示此警告框之前，应用中还没有加载任何其他内容。
- en: 'If needed, we can also `register` or `inject` services in the initializer.
    It may look as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，我们也可以在初始化器中`register`或`inject`服务。它可能看起来如下：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This takes the service named start and injects it into all the components. You
    can see more examples of this in [Chapter 9](part0075_split_000.html#27GQ61-d21a6ad8148a415181fa52c0043435bb
    "Chapter 9. Real-Life Tasks with Ember.js"), *Real-Life Tasks with Ember.js*.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会将名为start的服务注入到所有组件中。您可以在[第9章](part0075_split_000.html#27GQ61-d21a6ad8148a415181fa52c0043435bb
    "第9章。使用Ember.js的实战任务") *使用Ember.js的实战任务* 中看到更多此类示例。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Application instance initializers**'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**应用实例初始化器**'
- en: Application instance initializers run when the instance is loaded. It was added
    with Ember's FastBoot to make it easier to run many requests concurrently. During
    bootup, application initializers are run first, then instance initializers. If
    needed, you can look up factories you've already registered in the application
    initializer in the instance initializer.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用实例初始化器在实例加载时运行。它是随着Ember的FastBoot添加的，以便更容易地并发运行多个请求。在启动过程中，首先运行应用初始化器，然后是实例初始化器。如果需要，您可以在实例初始化器中查找已在应用初始化器中注册的工厂。
- en: For the most part, you'll only be using instance initializers for certain A/B
    testing configurations, configuring initial states, and when working with the
    Ember FastBoot server. To generate an instance initializer, run `ember g instance-initializer
    <name>`.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数情况下，您只会使用实例初始化器进行某些A/B测试配置、配置初始状态以及与Ember FastBoot服务器一起工作时。要生成实例初始化器，请运行`ember
    g instance-initializer <name>`。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Application initializers are run as soon as the application boots. This is the
    primary place to configure dependency injections into your application. Try to
    keep initializers as lightweight as possible. More complexity added to an initializer
    might cause delay in the application loading. Things like asynchronous loading
    conditions will work better in a service or route hook instead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用初始化器在应用启动时立即运行。这是配置依赖注入到您应用中的主要位置。尽量保持初始化器尽可能轻量。向初始化器中添加更多复杂性可能会造成应用加载延迟。像异步加载条件这样的东西在服务或路由钩子中运行会更好。
- en: Building a chat application
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天应用
- en: In this recipe, we'll combine what you learned with initializers and dependency
    injection to create a chat room. The chat room will use WebSockets to communicate
    with the host.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将结合您从初始化器和依赖注入中学到的知识来创建一个聊天室。聊天室将使用WebSockets与主机通信。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new application, generate these files:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新应用中，生成以下文件：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These will generate the files needed for the project. The `chat-room` component
    will have all the logic for the chat room that we'll create.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些将生成项目所需的文件。`chat-room`组件将包含我们创建的聊天室的逻辑。
- en: 'Import the **SockJS** library to the application:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**SockJS**库导入到应用程序中：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will import the library so that we can use the global variable, `sockjs`,
    anywhere in our application.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导入库，以便我们可以在应用程序的任何地方使用全局变量`sockjs`。
- en: 'Create a new service for `SockJS`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SockJS`创建一个新的服务：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s take a look at this in more detail:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This line is needed so that **JSHint** won''t complain about the SockJS global
    variable. JSHint is the built-in library for Ember CLI that detects errors in
    your program:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行是必需的，这样**JSHint**就不会对SockJS全局变量提出抱怨。JSHint是Ember CLI的内置库，用于检测程序中的错误：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This adds the `Ember.Evented` mixin to the service. This mixin allows Ember
    objects to subscribe and emit events. This is perfect for what we need to do in
    this example:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将`Ember.Evented`混入添加到服务中。这个混入允许Ember对象订阅和发射事件。这对于我们在本例中需要做的事情来说非常合适：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `init` method is where the SockJS socket will be set up and the event listener
    will be created. This method will fire after the service is initialized. The `this._super`
    method guarantees that the `init` method is set up properly:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`init`方法是在SockJS套接字设置和事件监听器创建的地方。这个方法将在服务初始化后触发。`this._super`方法确保`init`方法被正确设置：'
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding line creates a new socket server at the localhost port `7000`:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一行在本地主机的端口`7000`创建了一个新的套接字服务器：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This creates an event listener that is fired when a message is received. The
    `run.bind` method is a part of the Ember `run` loop that we'll describe later
    in this chapter. This ensures that all the requests are taken care of properly
    in the `run` loop.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个在收到消息时触发的事件监听器。`run.bind`方法是Ember `run`循环的一部分，我们将在本章后面描述它。这确保了所有请求都在`run`循环中得到妥善处理。
- en: 'The `this.trigger` is a part of the `Event.Evented` class. The `trigger` method
    creates a new event called `messageReceived`. We can subscribe to this event so
    that other methods in Ember can be triggered when a message is received. Finally,
    we `log` the information in `event.data` to the console and `set` the `socket`
    property:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`this.trigger`是`Event.Evented`类的一部分。`trigger`方法创建一个名为`messageReceived`的新事件。我们可以订阅这个事件，以便在收到消息时触发Ember中的其他方法。最后，我们将`event.data`中的信息`log`到控制台，并设置`socket`属性：'
- en: '[PRE18]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method accepts `message` and sends it the `socket` server we defined earlier.
    The `socket` property is accessed here.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个方法接受`message`并将其发送到我们之前定义的`socket`服务器。在这里访问`socket`属性。
- en: 'Inject the new service into all the components in the application:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新服务注入到应用程序的所有组件中：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The initializer takes the service called `sockjs` and injects it into all the
    components. This will be run whenever the program first boots. We use this so
    that we don't have to specifically inject the `sockjs` service into each component.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化器接受名为`sockjs`的服务并将其注入到所有组件中。这将在程序首次启动时运行。我们使用这个方法，这样我们就不必将`sockjs`服务特别注入到每个组件中。
- en: 'Create a new component for the chat room:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为聊天室创建一个新的组件：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s break this down into smaller parts:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们将这个操作分解成更小的部分：
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This `init` method fires on initialization and sets up the component. We can
    then subscribe to the event that we created earlier in the service using on. The
    first parameter is the name of the event. The second is the binding. The last
    is the name of the callback function. Therefore, in this example, whenever a message
    is received in the service, the `messageReceived` callback in this component will
    be fired:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`init`方法在初始化时触发，并设置组件。然后我们可以使用`on`订阅在服务中之前创建的事件。第一个参数是事件的名称。第二个是绑定。最后一个是指回调函数的名称。因此，在本例中，每当服务中收到消息时，这个组件中的`messageReceived`回调将被触发：
- en: '[PRE22]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is the `messageReceived` callback. It uses a little bit of jQuery to find
    the `chat-content` ID and concatenate the existing message to it using ES6 string
    interpolation. In addition, the `message` property is set:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是`messageReceived`回调。它使用一点jQuery来查找`chat-content` ID，并使用ES6字符串插值将现有消息连接到它。此外，设置`message`属性：
- en: '[PRE23]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This action sends `info` and `username` to the socket. This way, any other clients
    connected will be notified.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个操作将`info`和`username`发送到套接字。这样，任何连接的其他客户端都会收到通知。
- en: 'Create the `chat-room.hbs` template file for the component:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为组件创建`chat-room.hbs`模板文件：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code displays the messages from the server. The `input` helpers capture
    the username and message. Each value is passed to the `enter` action when the
    `Send` button is clicked.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码显示来自服务器的消息。`input` 辅助器捕获用户名和消息。当点击“发送”按钮时，每个值都会传递给 `enter` 动作。
- en: 'Add the component to the `application.hbs` file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件添加到 `application.hbs` 文件中：
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This adds the component to the application.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将组件添加到应用程序中。
- en: Start the node server. Then start the Ember application. You'll see the following
    screen:![How to do it...](img/00090.jpeg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动节点服务器。然后启动 Ember 应用程序。你会看到以下屏幕：![如何操作...](img/00090.jpeg)
- en: As each client connects they'll be able to send messages to the server. Each
    client will receive these messages and display them in the chat box.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着每个客户端的连接，他们可以向服务器发送消息。每个客户端将接收到这些消息并在聊天框中显示它们。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A chat room consists of multiple clients talking to a server. The server's job
    is to notify all the other clients connected when a messages is received. This
    is done in this example using SockJS with WebSockets. The SockJS library has message
    events that we can set up in Ember. When a message is received, it is then sent
    to a component that updates its template with the message.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天室由多个客户端与服务器进行通信组成。服务器的任务是当收到消息时通知所有其他已连接的客户端。在这个例子中，使用 SockJS 和 WebSocket
    来实现。SockJS 库有消息事件，我们可以在 Ember 中设置这些事件。当收到消息时，它会被发送到一个组件，该组件会更新其模板以显示消息。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To use the preceding example, you'll need to set up a WebSocket server. Here
    are the steps to create a simple Node.js SockJS server. To learn more about SockJS,
    check out their GitHub page at [https://github.com/sockjs/sockjs-node](https://github.com/sockjs/sockjs-node).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面的示例，你需要设置一个 WebSocket 服务器。以下是创建简单的 Node.js SockJS 服务器步骤。要了解更多关于 SockJS
    的信息，请查看他们的 GitHub 页面 [https://github.com/sockjs/sockjs-node](https://github.com/sockjs/sockjs-node)。
- en: 'In a new directory, run the `npm init` command:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新目录中，运行 `npm init` 命令：
- en: '[PRE26]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will generate the `package.json` file and install the SockJS server in
    it.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成 `package.json` 文件并在其中安装 SockJS 服务器。
- en: 'Create a new `app.js` file for the WebSocket server:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 WebSocket 服务器创建一个新的 `app.js` 文件：
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This server uses the SockJS library to create a new socket server. When a new
    client connects, it''s added to an array. When it receives data, it broadcasts
    this data to all the other servers connected using this function:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个服务器使用 SockJS 库创建一个新的 socket 服务器。当一个新的客户端连接时，它会被添加到一个数组中。当它接收到数据时，它会使用这个函数将数据广播到所有通过此连接的其他服务器：
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function sends a `broadcast` `message` to every other client connected
    with the `message` it just received. When Ember receives this information, it's
    written to the chat box.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数向所有连接的其他客户端发送一个包含刚刚接收到的 `message` 的 `broadcast` `message`。当 Ember 收到这个信息时，它会被写入聊天框。
- en: Creating and working with add-ons
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用插件
- en: Ember has a common way of sharing code using something called Ember Addons (also
    known as add-ons). Ember Addons make it easy to distribute reusable libraries
    with other applications. Anyone can create add-ons. You can publish them to NPM
    or to your own private Git repository.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 使用一种称为 Ember Addons（也称为插件）的方式来共享代码。Ember 插件使得与其他应用程序一起分发可重用库变得容易。任何人都可以创建插件。你可以将它们发布到
    NPM 或你自己的私有 Git 仓库。
- en: Keep in mind that you can also use Bower to install frontend dependencies. This
    is done through the Bower package manager. Take a look at [Chapter 1](part0015_split_000.html#E9OE1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 1. Ember CLI Basics"), *Ember CLI Basics* for more information on how
    to do this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你还可以使用 Bower 来安装前端依赖项。这是通过 Bower 软件包管理器完成的。查看 [第 1 章](part0015_split_000.html#E9OE1-d21a6ad8148a415181fa52c0043435bb
    "第 1 章。Ember CLI 基础")，*Ember CLI 基础*，了解更多关于如何操作的信息。
- en: In this recipe, we'll take our chat program from the last section and make it
    an add-on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从上一节中的聊天程序创建一个插件。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new add-on called `sockjs-chat`. Generate these files:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sockjs-chat` 的新插件。生成以下文件：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ember addon` command generates the folder structure for the add-on. We'll
    discuss the folder structure in more detail later. The `blueprint` command creates
    a new blueprint called `sockjs-chat`. Blueprints are used to generate snippets
    of code. This is needed so that the SockJS library can be installed. If we're
    doing anything with templates, we'll need to add `ember-cli-htmlbars`.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ember addon` 命令为插件生成文件夹结构。我们将在稍后更详细地讨论文件夹结构。`blueprint` 命令创建一个新的蓝图，称为 `sockjs-chat`。蓝图用于生成代码片段。这是安装
    SockJS 库所需的。如果我们做任何与模板相关的事情，我们需要添加 `ember-cli-htmlbars`。'
- en: 'Create the `sockjs-chat` blueprint so that it installs the SockJS library:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `sockjs-chat` 蓝图，以便安装 SockJS 库：
- en: '[PRE30]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `afterInstall` hook is used to add Bower packages. By default, the blueprint
    file will be run during the add-on installation. This guarantees that the `sockjs-client`
    library is installed via the Bower package manager.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`afterInstall` 钩子用于添加 Bower 包。默认情况下，蓝图文件将在插件安装期间运行。这保证了 `sockjs-client` 库通过
    Bower 包管理器安装。'
- en: 'Update the root `index.js` file so that the SockJS library is imported:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新根 `index.js` 文件，以便导入 SockJS 库：
- en: '[PRE31]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The JavaScript SockJS library is installed in the blueprint. However, we still
    need to import it to Ember. This can be done in the root folder's `index.js` file.
    This file is the entry point to the application. The `included` hook is used to
    import the Bower components to the application. Imports are added to the application
    in the order that they appear.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JavaScript SockJS 库在蓝图中被安装。然而，我们仍然需要将其导入 Ember。这可以在根文件夹的 `index.js` 文件中完成。此文件是应用程序的入口点。`included`
    钩子用于将 Bower 组件导入应用程序。导入按它们出现的顺序添加到应用程序中。
- en: 'Set the `package.json` file with the correct information for the project:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的项目信息设置 `package.json` 文件：
- en: '[PRE32]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's important to have your `package.json` file updated with at least your `name`,
    `description`, `repository`, `author`, and `keywords`. This is extremely important
    if you plan on open sourcing your add-on and publishing it to NPM. Without this
    information, your add-on will be hard to find.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你的 `package.json` 文件至少更新了 `name`、`description`、`repository`、`author` 和 `keywords`。如果你计划开源你的插件并将其发布到
    NPM，这非常重要。没有这些信息，你的插件将很难找到。
- en: 'In the generated service file, add a new `setup` and `send` method:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成的服务文件中，添加一个新的 `setup` 和 `send` 方法：
- en: '[PRE33]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This may look familiar. This is almost the same service that we created in
    the last recipe. However, this time, we have a new `setupSockjs` method that takes
    `url` as a parameter. The `url` parameter is used to set the new socket listener:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这看起来可能很熟悉。这几乎是我们上一次配方中创建的相同服务。然而，这次我们有一个新的 `setupSockjs` 方法，它接受 `url` 作为参数。`url`
    参数用于设置新的套接字监听器：
- en: '[PRE34]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This `event` is triggered when a new `message` is received. After a new `message`
    arrives, a new trigger called `messageReceived` will be called:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当接收到新的 `message` 时，会触发此 `event`。在新的 `message` 到达后，将调用一个新的触发器 `messageReceived`：
- en: '[PRE35]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As long as `socket` isn't `null`, `message` will be sent to the WebSocket server.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只要 `socket` 不是 `null`，`message` 就会被发送到 WebSocket 服务器。
- en: 'Set up the `sockjs-chat.js` component:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `sockjs-chat.js` 组件：
- en: '[PRE36]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The purpose of the component is to make it easy for someone to add a chat feature
    to their application without having to understand the internals of the service
    that we created earlier. To use this component, the template must be in block
    or non-block form with these properties:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件的目的是让某人能够轻松地将聊天功能添加到他们的应用程序中，而无需了解我们之前创建的服务内部结构。要使用此组件，模板必须是块或非块形式，并具有以下属性：
- en: '[PRE37]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `url` property is the location of the WebSocket. The `receiveAction` method
    is the parent component's `action` name. This will be triggered whenever a message
    is received. The `sendAction` method is the parent component's name for `action`
    that will be sending out messages.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`url` 属性是 WebSocket 的位置。`receiveAction` 方法是父组件的 `action` 名称。每当接收到消息时，它都会被触发。`sendAction`
    方法是父组件用于发送消息的 `action` 名称。'
- en: 'Let''s take a look at the component in more detail:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个组件：
- en: '[PRE38]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `layout` property is the same as `layout: layout`. This is a part of ES6\.
    The `init` hook is run when the component is initialized. Whenever you `extend`
    a built-in method, it''s always a good idea to run `this._super`. This makes sure
    that the component is set up correctly. The `…arguments` array is a part of the
    new ES6 syntax. It''s known as `Rest` parameters and represents an indefinite
    number of arguments in an array. We''ll be using this several times in this component.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout` 属性与 `layout: layout` 相同。这是 ES6 的一部分。`init` 钩子在组件初始化时运行。每次你 `extend`
    内置方法时，总是运行 `this._super` 的好主意。这确保了组件被正确设置。`…arguments` 数组是新的 ES6 语法的一部分。它被称为 `Rest`
    参数，表示数组中的不定数量的参数。我们将在本组件中多次使用它。'
- en: After `super` is run, we pass the `url` property to the `setupSockjs` method
    in our service. The `this.attrs.url` retrieves the `url` property that was passed
    to the component.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `super` 运行后，我们将 `url` 属性传递给我们的服务中的 `setupSockjs` 方法。`this.attrs.url` 获取传递给组件的
    `url` 属性。
- en: 'As we are using the `Ember.Event` mixin, we can subscribe to the service and
    watch for the `messageReceived` trigger. When `messageReceived` is triggered,
    we set the internal message, `this.message` property, to the message that was
    received. We then pass the message to a new method called `_actionHandler`:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们使用 `Ember.Event` 混合，我们可以订阅服务并监视 `messageReceived` 触发器。当 `messageReceived`
    触发时，我们将内部消息 `this.message` 属性设置为接收到的消息。然后我们将消息传递给一个新的方法 `_actionHandler`：
- en: '[PRE39]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The purpose of `actionHandler` is to take an `action` passed by the `receiveAction`
    or `sendAction` property and invoke it. However, we need to make sure that we
    can handle actions passed via closure actions, as described in [Chapter 6](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 6. Ember Components"), *Ember Components*, or just a named action. If
    it''s a closure action such as `(action ''receiveMessage'')`, then we simply call
    it using `this.attrs[actionname](…args)`. If not, then we use `sendAction`, which
    will send the action to the parent component:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`actionHandler` 的目的是接收由 `receiveAction` 或 `sendAction` 属性传递的 `action` 并调用它。然而，我们需要确保我们可以处理通过闭包动作传递的动作，如
    [第 6 章](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb "第 6 章。Ember
    组件") 所述，*Ember 组件*，或者只是一个命名的动作。如果是一个闭包动作，例如 `(action ''receiveMessage'')`，那么我们只需使用
    `this.attrs[actionname](…args)` 来调用它。如果不是，那么我们使用 `sendAction`，这将动作发送到父组件：'
- en: '[PRE40]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `enter` action calls the action handler and passes the `info` and `username`
    over. As we are using `Rest` parameters in `_actionHandler`, `(…arguments)`, we
    can pass to it as many arguments as we need.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`enter` 动作调用动作处理程序并传递 `info` 和 `username`。由于我们在 `_actionHandler` 中使用 `Rest`
    参数 `(…arguments)`，我们可以传递所需数量的参数。'
- en: 'Update the component template for `sockjs-chat.hbs`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `sockjs-chat.hbs` 组件模板：
- en: '[PRE41]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This gives the user a couple of choices when using this add-on. They can use
    the component in block form, which will look similar to the service we created
    in the last chapter, or they can design their own. The `hasBlock` helper returns
    `true` if the user adds the component in block form. If the component was not
    added in block form, then it displays the normal chat window.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这在使用此插件时给用户提供了几个选择。他们可以使用块形式使用组件，这将类似于我们在上一章中创建的服务，或者他们可以设计自己的。如果用户以块形式添加组件，`hasBlock`
    辅助函数将返回 `true`。如果组件不是以块形式添加的，那么它将显示正常的聊天窗口。
- en: One important aspect in this template is `{{yield this}}`. When in block form,
    this will give the block access to the component itself. We'll have full access
    to the components, properties, and methods in the templates block. We'll take
    a look at this when we test the add-on.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此模板中，一个重要的方面是 `{{yield this}}`。当处于块形式时，这将使块能够访问组件本身。在测试插件时，我们将查看这一点。
- en: Testing the sockjs-chat add-on
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 sockjs-chat 插件
- en: The `/tests` folder in the add-on is where all the test cases reside. This is
    very similar to any other Ember application. However, add-ons also include a dummy
    folder in the test folder. This folder is generally where add-on makers create
    their test applications. The program in this folder will have access to the add-on,
    although you'll need to install any Bower dependencies manually.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 插件中的 `/tests` 文件夹是所有测试用例所在的地方。这与其他任何 Ember 应用程序非常相似。然而，插件还包括测试文件夹中的 dummy 文件夹。这个文件夹通常是插件制作者创建测试应用程序的地方。这个文件夹中的程序将能够访问插件，尽管你可能需要手动安装任何
    Bower 依赖项。
- en: 'Run this command to install `sockjs-client` for testing purposes in the `add-on`
    folder:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令在 `add-on` 文件夹中安装 `sockjs-client` 以进行测试：
- en: '[PRE42]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will install `sockjs-client` in the `bower.json` `devDependencies` section.
    The `bower.json` file is used only for the application in the `/tests/dummy/`
    folder.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在 `bower.json` 的 `devDependencies` 部分安装 `sockjs-client`。`bower.json` 文件仅用于
    `/tests/dummy/` 文件夹中的应用程序。
- en: 'Update the `ember-cli-build.js` file with `SockJS bower_component`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `SockJS bower_component` 更新 `ember-cli-build.js` 文件：
- en: '[PRE43]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will add the `sockjs-client` library to our `/tests/dummy` app.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把 `sockjs-client` 库添加到我们的 `/tests/dummy` 应用程序中。
- en: 'In the `/tests/dummy` folder, add the component from the add-on in a non-block
    form:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/tests/dummy` 文件夹中，以非块形式添加插件中的组件：
- en: '[PRE44]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will add our new component add-on to the application. The `url` property
    will be passed to the service so that it can connect to the WebSocket server at
    port `7000`. The `receiveAction` and `sendAction` properties point to closure
    actions. This will trigger when we receive a message or want to send a message.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将添加我们的新组件附加组件到应用程序中。`url` 属性将被传递到服务中，以便它可以连接到端口 `7000` 的 WebSocket 服务器。`receiveAction`
    和 `sendAction` 属性指向闭包操作。这将在我们收到消息或想要发送消息时触发。
- en: 'Define the send and receive actions in the application controller:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序控制器中定义发送和接收操作：
- en: '[PRE45]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: These `actions` handle the sending and receiving of messages. The `receive`
    method uses a little bit of jQuery to append the latest message to the chat window.
    The `send` method uses the service from the add-on to send a message.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些 `actions` 处理消息的发送和接收。`receive` 方法使用一点 jQuery 将最新消息附加到聊天窗口。`send` 方法使用附加组件中的服务来发送消息。
- en: 'Run `ember server` command and test out the add-on:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server` 命令并测试附加组件：
- en: '[PRE46]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can run the server command directly in the `add-on` folder. This will serve
    up the files in the `/tests/dummy/` folder. Make sure to also begin the WebSockets
    server as well. Check out the last recipe on how to create a WebSocket server
    in Node.js.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以直接在 `add-on` 文件夹中运行服务器命令。这将提供 `/tests/dummy/` 文件夹中的文件。请确保同时启动 WebSockets
    服务器。查看如何在 Node.js 中创建 WebSocket 服务器的最后一个配方。
- en: Open a web browser and type in a message:![Testing the sockjs-chat add-on](img/00091.jpeg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并输入一条消息：![测试 sockjs-chat 附加组件](img/00091.jpeg)
- en: This chat box is generated from the template in the add-on. The message typed
    here will be sent using the action created in the controller.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个聊天框是从附加组件中的模板生成的。在这里输入的消息将通过控制器中创建的操作发送。
- en: 'Use the component in block form and create your own chat box:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用块形式的组件并创建自己的聊天框：
- en: '[PRE47]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This template uses the add-on component in block form. This time, we create
    a smaller chat room instead of using the default one created by the add-on:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个模板使用块形式的附加组件。这次，我们创建了一个更小的聊天室，而不是使用附加组件默认创建的聊天室：
- en: '[PRE48]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When a component begins with hash `#`, it''s considered to be in block form.
    To get access to the component itself, we add `|sockjs|` at the end. Now `sockjs`
    has access to all the properties in the component:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当一个组件以 hash `#` 开头时，它被认为是块形式。要访问组件本身，我们在末尾添加 `|sockjs|`。现在 `sockjs` 可以访问组件中的所有属性：
- en: '[PRE49]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As we have access to the component in the block, we can set `target` of this
    `action` to `sockjs`. We can also display the message anywhere we need to:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们可以在块中访问组件，我们可以将此 `action` 的 `target` 设置为 `sockjs`。我们还可以在任何需要的地方显示消息：
- en: '[PRE50]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will display the `message` property in the component.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在组件中显示 `message` 属性。
- en: Run `ember server` again in the `add-on` folder and open a web browser. Type
    in a message:![Testing the sockjs-chat add-on](img/00092.jpeg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `add-on` 文件夹中再次运行 `ember server` 并打开一个网页浏览器。输入一条消息：![测试 sockjs-chat 附加组件](img/00092.jpeg)
- en: As you can see, this new chat window looks a little different. However, it behaves
    in the same way and uses the same add-on as before.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这个新的聊天窗口看起来略有不同。然而，它的行为与之前相同，并且使用的是相同的附加组件。
- en: 'Create a new application and link it to the add-on to test:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序并将其链接到附加组件以进行测试：
- en: '[PRE51]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first thing that we do is navigate to the `sockjs-chat` folder that has
    our new add-on in it. We then run the `npm link` command. This generates a symbolic
    link from the local NPM cache to the add-on project. To access the add-on, we
    must then run `npm link sockjs-chat` in our new application. This creates a link
    to the add-on.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先做的事情是导航到包含我们的新附加组件的 `sockjs-chat` 文件夹。然后我们运行 `npm link` 命令。这将在本地 NPM 缓存和附加组件项目之间生成符号链接。要访问附加组件，我们必须然后在我们的新应用程序中运行
    `npm link sockjs-chat`。这创建了一个指向附加组件的链接。
- en: 'Add the add-on to the `package.json` file in the chat test application:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将附加组件添加到聊天测试应用程序的 `package.json` 文件中：
- en: '[PRE52]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is one of the last steps when linking an add-on to test. Ember must have
    this code in `devDependencies` for it to see the add-on.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是将附加组件链接到测试时的最后一步之一。Ember 必须在 `devDependencies` 中有这段代码，才能看到附加组件。
- en: 'Run install and add the blueprint:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装并添加蓝图：
- en: '[PRE53]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: After updating the `package.json` file, we must install the new package using
    `npm install`. Finally, running `ember g sockjs-chat` runs the default blueprint
    that will install `sockjs-client` in the application. The blueprint is automatically
    run when a new Ember add-on is installed. However, we must run it manually if
    we use the `npm link` technique.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在更新 `package.json` 文件后，我们必须使用 `npm install` 安装新包。最后，运行 `ember g sockjs-chat`
    将运行默认蓝图，该蓝图将在应用程序中安装 `sockjs-client`。蓝图在安装新的 Ember 插件时自动运行。但是，如果我们使用 `npm link`
    技术，我们必须手动运行它。
- en: We can now use the add-on in the application. Take note that we'll need to implement
    the same controller as we did in the dummy application to make this add-on work.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以在应用程序中使用此插件。请注意，我们需要实现与在模拟应用程序中相同的控制器，以便使此插件正常工作。
- en: Publishing the sockjs-chat add-on
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布 sockjs-chat 插件
- en: There are two ways to publish the new add-on. We can use either NPM or Git.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以发布新的插件。我们可以使用 NPM 或 Git。
- en: 'Publish your add-on to a private Git repository:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的插件发布到私有 Git 仓库：
- en: '[PRE54]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: To publish privately, you need to set up a private Git repository. Then push
    the add-on to this repository. In this case, replace `yourserver:username` with
    the `server` and `username` of your private Git repository.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要私有发布，您需要设置一个私有 Git 仓库。然后将插件推送到此仓库。在此情况下，将 `yourserver:username` 替换为您的私有 Git
    仓库的 `server` 和 `username`。
- en: 'Install the add-on from the Git repository in a new application:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新应用程序中从 Git 仓库安装插件：
- en: '[PRE55]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will install the add-on in the application. Make sure that the name of
    the repository matches the name of the add-on, or you'll get a message that the
    add-on cannot be found.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在应用程序中安装插件。请确保存储库的名称与插件的名称匹配，否则您将收到一条消息，表明找不到插件。
- en: 'Publish your add-on to NPM:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的插件发布到 NPM：
- en: '[PRE56]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will add you as a new user to the [http://npm.org](http://npm.org) site.
    You can then publish the `npm` as long as the `package.json` file is set up correctly.
    Later, you can use the `npm` version to bump the add-on version if needed.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使您成为 [http://npm.org](http://npm.org) 网站的新用户。只要 `package.json` 文件设置正确，您就可以发布
    `npm`。稍后，如果需要，您可以使用 `npm` 版本来提升插件版本。
- en: 'Install your add-on in a new application:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新应用程序中安装您的插件：
- en: '[PRE57]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will install the `sockjs-chat` application from `npm` in the `my-app2`
    application.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在 `my-app2` 应用程序中从 `npm` 安装 `sockjs-chat` 应用程序。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ember uses an add-on system to share code between applications. Each add-on
    has its own package that can be added to any application. Unlike the Bower package
    manager, these libraries can be more complicated and can encapsulate Ember code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 使用插件系统在应用程序之间共享代码。每个插件都有自己的包，可以添加到任何应用程序中。与 Bower 包管理器不同，这些库可能更复杂，并且可以封装
    Ember 代码。
- en: Ember add-ons can be accessed via NPM or private Git server. This can be used
    to share information between applications.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 插件可以通过 NPM 或私有 Git 服务器访问。这可以用于在应用程序之间共享信息。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Using Ember Addons can really speed up the development process. There are thousands
    of add-ons available. Check out the following two websites:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ember 插件可以真正加快开发过程。有数千个插件可供选择。查看以下两个网站：
- en: '[http://www.emberaddons.com/](http://www.emberaddons.com/)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.emberaddons.com/](http://www.emberaddons.com/)'
- en: '[http://emberobserver.com/](http://emberobserver.com/)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://emberobserver.com/](http://emberobserver.com/)'
- en: Both websites list add-ons and rank them. Use them for your applications. You
    won't regret it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个网站都列出了插件并对它们进行排名。请将它们用于您的应用程序。您不会后悔的。
- en: Learning the Ember run loop
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Ember `run` 循环
- en: The Ember `run` loop is an extremely important part of Ember's internals. The
    `run` loop is used to batch, order, and work in a way that's most efficient for
    the Ember application. In this recipe, we'll create a simple timer and take a
    look at how the `run` loop works.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 的 `run` 循环是 Ember 内部极其重要的部分。`run` 循环用于批量、排序并以最有效的方式在 Ember 应用程序中工作。在本食谱中，我们将创建一个简单的计时器，并查看
    `run` 循环是如何工作的。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we move on to our recipe, we'll need to understand some basics of the
    Ember `run` loop.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到我们的食谱之前，我们需要了解 Ember `run` 循环的一些基础知识。
- en: Understanding Ember run queues
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Ember `run` 队列
- en: 'The Ember `run` loop consists of six queues as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 的 `run` 循环由以下六个队列组成：
- en: '`sync`: This queue consists of binding synchronization jobs.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`: 此队列包含绑定同步任务。'
- en: '`actions`: This queue contains general work and promises.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actions`: 此队列包含一般工作和承诺。'
- en: '`routerTransitions`: This queue contains transition jobs in the router.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routerTransitions`: 此队列包含路由器中的转换任务。'
- en: '`render`: This queue contains jobs meant to render, usually to update the DOM.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`：这个队列包含旨在渲染的任务，通常用于更新DOM。'
- en: '`afterRender`: This queue is run after all previously scheduled render tasks
    are completed. This queue is typically used for third-party applications.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterRender`：这个队列在所有之前安排的渲染任务完成后运行。这个队列通常用于第三方应用程序。'
- en: '`destroy`: This last queue tears down objects.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy`：这个最后的队列负责拆解对象。'
- en: These queues don't run all the time. They only run in response to certain user
    and timer events. This way, responsibility is handed back to the user; otherwise,
    the browser would hang.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些队列不是一直运行的。它们只在响应某些用户和定时器事件时运行。这样，责任就交回到了用户手中；否则，浏览器会挂起。
- en: When should you change the Ember run loop?
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该在何时更改Ember的`run`循环？
- en: 'You should make changes to the Ember `run` loop only in certain situations:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在特定情况下更改Ember的`run`循环：
- en: Asynchronous callbacks
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步回调
- en: Dealing with timers
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理定时器
- en: Ajax callbacks
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ajax回调
- en: Certain types of tests
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些类型的测试
- en: WebSockets
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSockets
- en: '`PostMessage` and `messageChannel` event handlers'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostMessage`和`messageChannel`事件处理器'
- en: Most of the time, Ember's `run` loop will handle everything and you won't need
    to touch it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，Ember的`run`循环会处理一切，你不需要去触碰它。
- en: Working with the Ember.run namespace
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Ember的`run`命名空间一起工作
- en: 'The Ember run namespace gives us several methods to use when working with the
    `run` loop. The most popular methods are as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Ember的`run`命名空间为我们提供了在处理`run`循环时可以使用的方法。最流行的方法如下：
- en: '`Ember.run.bind`: This is great for use in third-party libraries, and adds
    the execution of the function to Ember''s `run` loop'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ember.run.bind`：这对于在第三方库中使用非常棒，并且将函数的执行添加到Ember的`run`循环中'
- en: '`Ember.run.later`: This runs the passed target/method after a specified period
    of time'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ember.run.later`：这个方法在指定的时间后运行传递的目标/方法'
- en: '`Ember.run.schedule`: This runs the passed target/method and optional arguments
    to the named queue at the end of the loop'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ember.run.schedule`：这个方法在循环结束时运行传递的目标/方法以及可选参数到命名队列'
- en: There are more methods available, but these are the ones you'll use the most
    when you need to manipulate the `run` loop.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多方法可用，但当你需要操作`run`循环时，这些是你最常用的方法。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In a new application, generate a new `time-checker` component:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用程序中，生成一个新的`time-checker`组件：
- en: '[PRE58]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will generate a new component called `time-checker`. In addition, we'll
    be using the Moment library to keep track of our timer.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成一个名为`time-checker`的新组件。此外，我们还将使用Moment库来跟踪我们的计时器。
- en: 'Import the Moment library to the application:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Moment库导入到应用程序中：
- en: '[PRE59]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This adds the Moment library to the application.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把Moment库添加到应用程序中。
- en: 'Update the new `time-checker.js` component file. Add two properties to it—one
    to show the time when the component started and another to show the current time:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新新的`time-checker.js`组件文件。向其中添加两个属性——一个用于显示组件开始的时间，另一个用于显示当前时间：
- en: '[PRE60]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The purpose of this component is to display the time when the component loaded
    and the current time. It also shows the difference between these two times. Let''s
    take a look at this in more detail:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个组件的目的是显示组件加载的时间和当前时间。它还显示了这两个时间之间的差异。让我们更详细地看看：
- en: '[PRE61]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `init` function runs as soon as the component is instantiated. It sets
    the current time and calls the `startWatchingTime` method. This method uses `Ember.run.later`
    to wait a second before continuing. Each second, it calls itself, and then calculates
    the new date and time again. It''s better to use this method than `setTimeout`,
    as it may cause issues in the Ember `run` loop:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`init`函数在组件实例化后立即运行。它设置当前时间并调用`startWatchingTime`方法。这个方法使用`Ember.run.later`等待一秒后再继续。每秒，它会调用自己，然后再次计算新的日期和时间。与`setTimeout`相比，使用这个方法更好，因为它可能会在Ember的`run`循环中引起问题：'
- en: '[PRE62]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `diff` computed property updates whenever `currentTime` changes. It returns
    the difference in seconds between the two times.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`diff`计算属性在`currentTime`变化时更新。它返回两个时间之间的秒数差异。'
- en: 'Update the template for the `time-checker.hbs` component file:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`time-checker.hbs`组件文件的模板：
- en: '[PRE63]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This will display the start, current, and difference times.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示开始时间、当前时间和时间差。
- en: 'Update the application template and add the component:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序模板并添加组件：
- en: '[PRE64]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will add the `time-checker` component to the application.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把`time-checker`组件添加到应用程序中。
- en: Run the application and you'll see two times. The second time will update every
    second:![How to do it...](img/00093.jpeg)
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，你会看到两个时间。第二个时间将每秒更新一次：![如何实现...](img/00093.jpeg)
- en: The Ember `run` loop makes this possible.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember 的 `run` 循环使得这成为可能。
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Ember `run` loop helps schedule work in an Ember application. It runs whenever
    there is user action or certain timing events. It consists of six different queues.
    Each queue is responsible for different functions in the application.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 的 `run` 循环帮助在 Ember 应用程序中安排工作。它会在有用户操作或特定的时间事件发生时运行。它由六个不同的队列组成。每个队列负责应用中的不同功能。
- en: In most situations, you don't need to worry about the `run` loop. However, in
    some situations such as dealing with asynchronous callbacks or timing events,
    you'll need to use them. Keep this in mind as you continue to program in the future.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要担心 `run` 循环。然而，在某些情况下，例如处理异步回调或时间事件时，你需要使用它们。在未来的编程过程中请记住这一点。
