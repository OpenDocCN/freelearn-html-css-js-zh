- en: Chapter 11. Real-Time Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with application initializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a chat application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and working with add-ons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Ember run loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you level up with Ember, you'll learn how to work with real-time applications.
    In these types of applications, you'll be dealing with updates from a server.
    You'll need to be able to handle these events and notify the user as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In Ember, we can use things such as dependency injection and services with WebSockets
    to handle real-time events from a server. We'll be looking at these concepts,
    including add-ons, in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dependency injection pattern is used to declare and instantiate classes
    of objects and handle dependencies between them. In Ember, we can take objects
    or services and inject them into routes, controllers, or components.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take a logger object and inject it into our controllers
    using dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, install the `moment` library and create a new `initializer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install the Bower **Moment.js** library. We'll use this for our custom
    logger.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the Moment library to the Ember project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `app.import` statement adds the `moment` library to the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `application.js` file in the `initializers` folder, add a new logger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a new logger called `myLogger`. It uses the built-in `Ember.Logger`
    and adds a timestamp to it using the `moment` library that was installed earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s take a look at this in more detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `application.register` method registers a new factory. The first argument
    is the registration key. The registration key is always two parts separated by
    a colon `:`. The first part is the type of factory and the second part is the
    name of the factory. The type of factory can be a template, `component`, `controller`,
    or `service`, or you can create your own. In this example, I called it `myLogger`.
    The second argument is the object you want to register, `MyLogger`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This application inject makes the new `myLogger:zzz` factory available in all
    controllers. The value of `myLogger` comes from the `myLogger:zzz` factory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new application controller and add a new action that logs using the
    new `myLogger` debugger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a new `press` action occurs, it logs to the console, `Hello World`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add `action` to the application template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the button is clicked, the `press` action is triggered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `ember server` and you'll see the following screen:![How to do it...](img/00087.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press **Button** and you''ll see something as follows in the console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00088.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Each time you click the button, it logs a debug statement to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dependency injection occurs when we take objects and inject them into other
    objects during instantiation. Ember can do this with the `application.inject`
    method. To accomplish this in Ember, we must create factories. Factories are simply
    objects that return other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Ember registers these factories in `Ember.Application`. `Ember.Application`
    acts as a registry of sorts that holds different factories. After being registered,
    they can be injected into other parts of the Ember application such as components
    or controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with application initializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application initializers can be used to configure your application as it boots.
    It's the primary place to set up dependency injections in your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll examine when an application initializer is run.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, create `initializer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a new application `initializer`. This will be run as soon as
    the application boots.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add an alert box to the initializer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will load an `alert` box as soon as the application loads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `ember server` and you should see an alert box displayed before the application
    is loaded:![How to do it...](img/00089.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nothing else has loaded in the application before this alert box is shown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If needed, we can also `register` or `inject` services in the initializer.
    It may look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This takes the service named start and injects it into all the components. You
    can see more examples of this in [Chapter 9](part0075_split_000.html#27GQ61-d21a6ad8148a415181fa52c0043435bb
    "Chapter 9. Real-Life Tasks with Ember.js"), *Real-Life Tasks with Ember.js*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Application instance initializers**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Application instance initializers run when the instance is loaded. It was added
    with Ember's FastBoot to make it easier to run many requests concurrently. During
    bootup, application initializers are run first, then instance initializers. If
    needed, you can look up factories you've already registered in the application
    initializer in the instance initializer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the most part, you'll only be using instance initializers for certain A/B
    testing configurations, configuring initial states, and when working with the
    Ember FastBoot server. To generate an instance initializer, run `ember g instance-initializer
    <name>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application initializers are run as soon as the application boots. This is the
    primary place to configure dependency injections into your application. Try to
    keep initializers as lightweight as possible. More complexity added to an initializer
    might cause delay in the application loading. Things like asynchronous loading
    conditions will work better in a service or route hook instead.
  prefs: []
  type: TYPE_NORMAL
- en: Building a chat application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll combine what you learned with initializers and dependency
    injection to create a chat room. The chat room will use WebSockets to communicate
    with the host.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, generate these files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These will generate the files needed for the project. The `chat-room` component
    will have all the logic for the chat room that we'll create.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the **SockJS** library to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will import the library so that we can use the global variable, `sockjs`,
    anywhere in our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new service for `SockJS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at this in more detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line is needed so that **JSHint** won''t complain about the SockJS global
    variable. JSHint is the built-in library for Ember CLI that detects errors in
    your program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This adds the `Ember.Evented` mixin to the service. This mixin allows Ember
    objects to subscribe and emit events. This is perfect for what we need to do in
    this example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `init` method is where the SockJS socket will be set up and the event listener
    will be created. This method will fire after the service is initialized. The `this._super`
    method guarantees that the `init` method is set up properly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding line creates a new socket server at the localhost port `7000`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates an event listener that is fired when a message is received. The
    `run.bind` method is a part of the Ember `run` loop that we'll describe later
    in this chapter. This ensures that all the requests are taken care of properly
    in the `run` loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `this.trigger` is a part of the `Event.Evented` class. The `trigger` method
    creates a new event called `messageReceived`. We can subscribe to this event so
    that other methods in Ember can be triggered when a message is received. Finally,
    we `log` the information in `event.data` to the console and `set` the `socket`
    property:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method accepts `message` and sends it the `socket` server we defined earlier.
    The `socket` property is accessed here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inject the new service into all the components in the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The initializer takes the service called `sockjs` and injects it into all the
    components. This will be run whenever the program first boots. We use this so
    that we don't have to specifically inject the `sockjs` service into each component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new component for the chat room:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break this down into smaller parts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `init` method fires on initialization and sets up the component. We can
    then subscribe to the event that we created earlier in the service using on. The
    first parameter is the name of the event. The second is the binding. The last
    is the name of the callback function. Therefore, in this example, whenever a message
    is received in the service, the `messageReceived` callback in this component will
    be fired:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the `messageReceived` callback. It uses a little bit of jQuery to find
    the `chat-content` ID and concatenate the existing message to it using ES6 string
    interpolation. In addition, the `message` property is set:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This action sends `info` and `username` to the socket. This way, any other clients
    connected will be notified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `chat-room.hbs` template file for the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code displays the messages from the server. The `input` helpers capture
    the username and message. Each value is passed to the `enter` action when the
    `Send` button is clicked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the component to the `application.hbs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds the component to the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the node server. Then start the Ember application. You'll see the following
    screen:![How to do it...](img/00090.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As each client connects they'll be able to send messages to the server. Each
    client will receive these messages and display them in the chat box.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A chat room consists of multiple clients talking to a server. The server's job
    is to notify all the other clients connected when a messages is received. This
    is done in this example using SockJS with WebSockets. The SockJS library has message
    events that we can set up in Ember. When a message is received, it is then sent
    to a component that updates its template with the message.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the preceding example, you'll need to set up a WebSocket server. Here
    are the steps to create a simple Node.js SockJS server. To learn more about SockJS,
    check out their GitHub page at [https://github.com/sockjs/sockjs-node](https://github.com/sockjs/sockjs-node).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new directory, run the `npm init` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate the `package.json` file and install the SockJS server in
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `app.js` file for the WebSocket server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This server uses the SockJS library to create a new socket server. When a new
    client connects, it''s added to an array. When it receives data, it broadcasts
    this data to all the other servers connected using this function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function sends a `broadcast` `message` to every other client connected
    with the `message` it just received. When Ember receives this information, it's
    written to the chat box.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating and working with add-ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember has a common way of sharing code using something called Ember Addons (also
    known as add-ons). Ember Addons make it easy to distribute reusable libraries
    with other applications. Anyone can create add-ons. You can publish them to NPM
    or to your own private Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you can also use Bower to install frontend dependencies. This
    is done through the Bower package manager. Take a look at [Chapter 1](part0015_split_000.html#E9OE1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 1. Ember CLI Basics"), *Ember CLI Basics* for more information on how
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take our chat program from the last section and make it
    an add-on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new add-on called `sockjs-chat`. Generate these files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ember addon` command generates the folder structure for the add-on. We'll
    discuss the folder structure in more detail later. The `blueprint` command creates
    a new blueprint called `sockjs-chat`. Blueprints are used to generate snippets
    of code. This is needed so that the SockJS library can be installed. If we're
    doing anything with templates, we'll need to add `ember-cli-htmlbars`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `sockjs-chat` blueprint so that it installs the SockJS library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `afterInstall` hook is used to add Bower packages. By default, the blueprint
    file will be run during the add-on installation. This guarantees that the `sockjs-client`
    library is installed via the Bower package manager.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the root `index.js` file so that the SockJS library is imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The JavaScript SockJS library is installed in the blueprint. However, we still
    need to import it to Ember. This can be done in the root folder's `index.js` file.
    This file is the entry point to the application. The `included` hook is used to
    import the Bower components to the application. Imports are added to the application
    in the order that they appear.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the `package.json` file with the correct information for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's important to have your `package.json` file updated with at least your `name`,
    `description`, `repository`, `author`, and `keywords`. This is extremely important
    if you plan on open sourcing your add-on and publishing it to NPM. Without this
    information, your add-on will be hard to find.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the generated service file, add a new `setup` and `send` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This may look familiar. This is almost the same service that we created in
    the last recipe. However, this time, we have a new `setupSockjs` method that takes
    `url` as a parameter. The `url` parameter is used to set the new socket listener:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `event` is triggered when a new `message` is received. After a new `message`
    arrives, a new trigger called `messageReceived` will be called:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As long as `socket` isn't `null`, `message` will be sent to the WebSocket server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up the `sockjs-chat.js` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The purpose of the component is to make it easy for someone to add a chat feature
    to their application without having to understand the internals of the service
    that we created earlier. To use this component, the template must be in block
    or non-block form with these properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `url` property is the location of the WebSocket. The `receiveAction` method
    is the parent component's `action` name. This will be triggered whenever a message
    is received. The `sendAction` method is the parent component's name for `action`
    that will be sending out messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s take a look at the component in more detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `layout` property is the same as `layout: layout`. This is a part of ES6\.
    The `init` hook is run when the component is initialized. Whenever you `extend`
    a built-in method, it''s always a good idea to run `this._super`. This makes sure
    that the component is set up correctly. The `…arguments` array is a part of the
    new ES6 syntax. It''s known as `Rest` parameters and represents an indefinite
    number of arguments in an array. We''ll be using this several times in this component.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After `super` is run, we pass the `url` property to the `setupSockjs` method
    in our service. The `this.attrs.url` retrieves the `url` property that was passed
    to the component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we are using the `Ember.Event` mixin, we can subscribe to the service and
    watch for the `messageReceived` trigger. When `messageReceived` is triggered,
    we set the internal message, `this.message` property, to the message that was
    received. We then pass the message to a new method called `_actionHandler`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The purpose of `actionHandler` is to take an `action` passed by the `receiveAction`
    or `sendAction` property and invoke it. However, we need to make sure that we
    can handle actions passed via closure actions, as described in [Chapter 6](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 6. Ember Components"), *Ember Components*, or just a named action. If
    it''s a closure action such as `(action ''receiveMessage'')`, then we simply call
    it using `this.attrs[actionname](…args)`. If not, then we use `sendAction`, which
    will send the action to the parent component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `enter` action calls the action handler and passes the `info` and `username`
    over. As we are using `Rest` parameters in `_actionHandler`, `(…arguments)`, we
    can pass to it as many arguments as we need.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the component template for `sockjs-chat.hbs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gives the user a couple of choices when using this add-on. They can use
    the component in block form, which will look similar to the service we created
    in the last chapter, or they can design their own. The `hasBlock` helper returns
    `true` if the user adds the component in block form. If the component was not
    added in block form, then it displays the normal chat window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One important aspect in this template is `{{yield this}}`. When in block form,
    this will give the block access to the component itself. We'll have full access
    to the components, properties, and methods in the templates block. We'll take
    a look at this when we test the add-on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing the sockjs-chat add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `/tests` folder in the add-on is where all the test cases reside. This is
    very similar to any other Ember application. However, add-ons also include a dummy
    folder in the test folder. This folder is generally where add-on makers create
    their test applications. The program in this folder will have access to the add-on,
    although you'll need to install any Bower dependencies manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command to install `sockjs-client` for testing purposes in the `add-on`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install `sockjs-client` in the `bower.json` `devDependencies` section.
    The `bower.json` file is used only for the application in the `/tests/dummy/`
    folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `ember-cli-build.js` file with `SockJS bower_component`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add the `sockjs-client` library to our `/tests/dummy` app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `/tests/dummy` folder, add the component from the add-on in a non-block
    form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add our new component add-on to the application. The `url` property
    will be passed to the service so that it can connect to the WebSocket server at
    port `7000`. The `receiveAction` and `sendAction` properties point to closure
    actions. This will trigger when we receive a message or want to send a message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the send and receive actions in the application controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These `actions` handle the sending and receiving of messages. The `receive`
    method uses a little bit of jQuery to append the latest message to the chat window.
    The `send` method uses the service from the add-on to send a message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run `ember server` command and test out the add-on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can run the server command directly in the `add-on` folder. This will serve
    up the files in the `/tests/dummy/` folder. Make sure to also begin the WebSockets
    server as well. Check out the last recipe on how to create a WebSocket server
    in Node.js.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open a web browser and type in a message:![Testing the sockjs-chat add-on](img/00091.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chat box is generated from the template in the add-on. The message typed
    here will be sent using the action created in the controller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the component in block form and create your own chat box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This template uses the add-on component in block form. This time, we create
    a smaller chat room instead of using the default one created by the add-on:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a component begins with hash `#`, it''s considered to be in block form.
    To get access to the component itself, we add `|sockjs|` at the end. Now `sockjs`
    has access to all the properties in the component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we have access to the component in the block, we can set `target` of this
    `action` to `sockjs`. We can also display the message anywhere we need to:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will display the `message` property in the component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `ember server` again in the `add-on` folder and open a web browser. Type
    in a message:![Testing the sockjs-chat add-on](img/00092.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, this new chat window looks a little different. However, it behaves
    in the same way and uses the same add-on as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new application and link it to the add-on to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing that we do is navigate to the `sockjs-chat` folder that has
    our new add-on in it. We then run the `npm link` command. This generates a symbolic
    link from the local NPM cache to the add-on project. To access the add-on, we
    must then run `npm link sockjs-chat` in our new application. This creates a link
    to the add-on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the add-on to the `package.json` file in the chat test application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is one of the last steps when linking an add-on to test. Ember must have
    this code in `devDependencies` for it to see the add-on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run install and add the blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After updating the `package.json` file, we must install the new package using
    `npm install`. Finally, running `ember g sockjs-chat` runs the default blueprint
    that will install `sockjs-client` in the application. The blueprint is automatically
    run when a new Ember add-on is installed. However, we must run it manually if
    we use the `npm link` technique.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can now use the add-on in the application. Take note that we'll need to implement
    the same controller as we did in the dummy application to make this add-on work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Publishing the sockjs-chat add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two ways to publish the new add-on. We can use either NPM or Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'Publish your add-on to a private Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To publish privately, you need to set up a private Git repository. Then push
    the add-on to this repository. In this case, replace `yourserver:username` with
    the `server` and `username` of your private Git repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install the add-on from the Git repository in a new application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install the add-on in the application. Make sure that the name of
    the repository matches the name of the add-on, or you'll get a message that the
    add-on cannot be found.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Publish your add-on to NPM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add you as a new user to the [http://npm.org](http://npm.org) site.
    You can then publish the `npm` as long as the `package.json` file is set up correctly.
    Later, you can use the `npm` version to bump the add-on version if needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install your add-on in a new application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install the `sockjs-chat` application from `npm` in the `my-app2`
    application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember uses an add-on system to share code between applications. Each add-on
    has its own package that can be added to any application. Unlike the Bower package
    manager, these libraries can be more complicated and can encapsulate Ember code.
  prefs: []
  type: TYPE_NORMAL
- en: Ember add-ons can be accessed via NPM or private Git server. This can be used
    to share information between applications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Ember Addons can really speed up the development process. There are thousands
    of add-ons available. Check out the following two websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.emberaddons.com/](http://www.emberaddons.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://emberobserver.com/](http://emberobserver.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both websites list add-ons and rank them. Use them for your applications. You
    won't regret it.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Ember run loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ember `run` loop is an extremely important part of Ember's internals. The
    `run` loop is used to batch, order, and work in a way that's most efficient for
    the Ember application. In this recipe, we'll create a simple timer and take a
    look at how the `run` loop works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on to our recipe, we'll need to understand some basics of the
    Ember `run` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Ember run queues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Ember `run` loop consists of six queues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sync`: This queue consists of binding synchronization jobs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actions`: This queue contains general work and promises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`routerTransitions`: This queue contains transition jobs in the router.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render`: This queue contains jobs meant to render, usually to update the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterRender`: This queue is run after all previously scheduled render tasks
    are completed. This queue is typically used for third-party applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroy`: This last queue tears down objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These queues don't run all the time. They only run in response to certain user
    and timer events. This way, responsibility is handed back to the user; otherwise,
    the browser would hang.
  prefs: []
  type: TYPE_NORMAL
- en: When should you change the Ember run loop?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should make changes to the Ember `run` loop only in certain situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ajax callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain types of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostMessage` and `messageChannel` event handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, Ember's `run` loop will handle everything and you won't need
    to touch it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Ember.run namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Ember run namespace gives us several methods to use when working with the
    `run` loop. The most popular methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ember.run.bind`: This is great for use in third-party libraries, and adds
    the execution of the function to Ember''s `run` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ember.run.later`: This runs the passed target/method after a specified period
    of time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ember.run.schedule`: This runs the passed target/method and optional arguments
    to the named queue at the end of the loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more methods available, but these are the ones you'll use the most
    when you need to manipulate the `run` loop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, generate a new `time-checker` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate a new component called `time-checker`. In addition, we'll
    be using the Moment library to keep track of our timer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the Moment library to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds the Moment library to the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the new `time-checker.js` component file. Add two properties to it—one
    to show the time when the component started and another to show the current time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The purpose of this component is to display the time when the component loaded
    and the current time. It also shows the difference between these two times. Let''s
    take a look at this in more detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `init` function runs as soon as the component is instantiated. It sets
    the current time and calls the `startWatchingTime` method. This method uses `Ember.run.later`
    to wait a second before continuing. Each second, it calls itself, and then calculates
    the new date and time again. It''s better to use this method than `setTimeout`,
    as it may cause issues in the Ember `run` loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `diff` computed property updates whenever `currentTime` changes. It returns
    the difference in seconds between the two times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the template for the `time-checker.hbs` component file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will display the start, current, and difference times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the application template and add the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add the `time-checker` component to the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the application and you'll see two times. The second time will update every
    second:![How to do it...](img/00093.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ember `run` loop makes this possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Ember `run` loop helps schedule work in an Ember application. It runs whenever
    there is user action or certain timing events. It consists of six different queues.
    Each queue is responsible for different functions in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In most situations, you don't need to worry about the `run` loop. However, in
    some situations such as dealing with asynchronous callbacks or timing events,
    you'll need to use them. Keep this in mind as you continue to program in the future.
  prefs: []
  type: TYPE_NORMAL
