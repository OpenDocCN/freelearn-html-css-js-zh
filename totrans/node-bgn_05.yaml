- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Node.js Core Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 核心库
- en: In this chapter, we delve into the core libraries of Node.js and explore the
    techniques for modularizing your code. JavaScript has come a long way from being
    limited to browsers, and Node.js has offered us new ways to structure our code.
    We’ll begin by understanding the historical limitations of organizing code in
    the browser and how they led to the development of various module systems. We’ll
    primarily focus on two module systems, **CommonJS** (**CJS**) and **ECMAScript
    Modules** (**ESM**), and discuss their usage, importation, and exportation. Achieving
    interoperability between these two systems is crucial, and we’ll explore strategies
    to make it work seamlessly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究 Node.js 的核心库，并探讨模块化代码的技术。JavaScript 已经从仅限于浏览器的限制中走出来，Node.js 为我们提供了新的代码结构方式。我们将从理解在浏览器中组织代码的历史局限性以及它们如何导致各种模块系统的开发开始。我们将主要关注两个模块系统，**CommonJS**（**CJS**）和**ECMAScript
    模块**（**ESM**），并讨论它们的用法、导入和导出。实现这两个系统之间的互操作性至关重要，我们将探讨使它们无缝工作的策略。
- en: Understanding how core libraries in Node.js are structured is key. We’ll take
    a closer look at core libraries including `fs` and `http`, which deal with file
    operations, and explore the use of callbacks, synchronous functions, and promises
    for asynchronous I/O operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Node.js 核心库的结构是关键。我们将更深入地研究包括 `fs` 和 `http` 在内的核心库，这些库处理文件操作，并探讨使用回调、同步函数和承诺进行异步
    I/O 操作的使用。
- en: Also, more advanced topics related to extending Node.js functionality with C++
    addons and executing external commands using the `child_process` library will
    be discussed. We’ll also review various command-line options (including to enable
    experimental features and control memory allocation) and environmental variables
    that allow you to customize the Node.js behavior. We’ll provide examples of how
    to use these options to enable experimental features, control memory allocation,
    and fine-tune your Node.js applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还将讨论更多与使用 C++ 插件扩展 Node.js 功能和通过 `child_process` 库执行外部命令相关的先进主题。我们还将回顾各种命令行选项（包括启用实验性功能和控制内存分配）以及允许您自定义
    Node.js 行为的环境变量。我们将提供如何使用这些选项来启用实验性功能、控制内存分配以及微调您的 Node.js 应用程序的示例。
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是本章我们将探讨的主要主题：
- en: How to create and consume modules using the ESM and CJS approaches
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 ESM 和 CJS 方法创建和消费模块
- en: How to interoperate between ESM and CJS modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 ESM 和 CJS 模块之间进行互操作
- en: How the Node.js core libraries interfaces are structured
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 核心库接口的结构
- en: What the most relevant Node.js core libraries are when starting with Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始使用 Node.js 时，最相关的 Node.js 核心库是什么
- en: How to extend the Node.js functionality by using command-line options and the
    `NODE_OPTIONS` environment variable
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如何通过使用命令行选项和 `NODE_OPTIONS` 环境变量来扩展 Node.js 功能
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
    找到。
- en: Check out the code in action video for this chapter on [https://youtu.be/WQzdXAFxdsc](https://youtu.be/WQzdXAFxdsc)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本章的代码执行视频，请访问 [https://youtu.be/WQzdXAFxdsc](https://youtu.be/WQzdXAFxdsc)
- en: Modularizing your code (ESM versus CJS)
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化您的代码（ESM 与 CJS）
- en: 'For many years JavaScript was limited to the browser, and the only way to organize
    our code was using script files that were loaded in the correct order in a HTML
    page. This was done by including specific references in the HTML files, such as
    the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多年来，JavaScript 仅限于浏览器中，我们组织代码的唯一方式是使用在 HTML 页面中按正确顺序加载的脚本文件。这是通过在 HTML 文件中包含特定引用来实现的，例如以下内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach was not scalable, and it was very easy to pollute the global scope.
    To solve this problem, historically we used the IIFE pattern and the module pattern.
    As the adoption of JavaScript started to grow and the amount of JavaScript required
    for a modern website was dramatically rising, the community began to create libraries
    and frameworks to solve these aforementioned problems. The outcome included results
    such as RequireJS ([https://requirejs.org/](https://requirejs.org/)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不可扩展，很容易污染全局作用域。为了解决这个问题，历史上我们使用了 IIFE 模式和模块模式。随着 JavaScript 的采用率开始增长，现代网站所需的
    JavaScript 量急剧增加，社区开始创建库和框架来解决上述问题。结果包括 RequireJS ([https://requirejs.org/](https://requirejs.org/))。
- en: 'For many years, we had four different ways to organize our code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们有四种不同的方式来组织我们的代码：
- en: '**CommonJS (CJS)**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CommonJS (CJS)**'
- en: '**ECMAScript** **Modules (ESM)**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ECMAScript** **Modules (ESM)**'
- en: '**Asynchronous Module** **Definition (AMD)**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步模块** **定义 (AMD)**'
- en: '**Universal Module** **Definition (UMD)**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用模块** **定义 (UMD)**'
- en: In this book, we will focus on the first two approaches, CJS and ESM. Currently
    CJS is the default module system in Node.js, but since the release of Node.js
    12, ESM is now available. In this section, we will explore how to create and consume
    modules using both approaches.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将重点关注前两种方法，CJS 和 ESM。目前 CJS 是 Node.js 的默认模块系统，但自从 Node.js 12 发布以来，ESM
    现在也已可用。在本节中，我们将探讨如何使用这两种方法创建和消费模块。
- en: Important note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Today, in the browser environment is very common to consolidate our code using
    a module bundler such as webpack or Rollup. However, in Node.js we keep using
    CJS or ESM directly. In this section, we will explore how to create and consume
    modules using both approaches.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器环境中，使用模块打包器（如 webpack 或 Rollup）来整合我们的代码是非常常见的。然而，在 Node.js 中，我们仍然直接使用
    CJS 或 ESM。在本节中，我们将探讨如何使用这两种方法创建和消费模块。
- en: CommonJS (CJS)
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommonJS (CJS)
- en: CommonJS is the module system that Node.js uses by default. This module system
    is synchronous, and is based on the `require` and `module.exports` functions.
    It is important to note that this module system is not part of the ECMAScript
    specification, but it is the most used module system in the Node.js ecosystem,
    especially if you are looking for documentation or tutorials.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 是 Node.js 默认使用的模块系统。这个模块系统是同步的，基于 `require` 和 `module.exports` 函数。需要注意的是，这个模块系统不是
    ECMAScript 规范的一部分，但在 Node.js 生态系统中是最常用的模块系统，特别是如果你在寻找文档或教程的话。
- en: 'There are two aspects here of CJS use that we need to understand: the importation
    and the exportation. Let’s start with the importation.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要了解 CJS 使用的两个方面：导入和导出。让我们从导入开始。
- en: Importation
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入
- en: 'So, we have two files in our project, `utils.js` and `index.js`. In this example,
    we are importing the `sayHello` function from the `utils.js` file in the `index.js`
    file, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的项目中，有两个文件，`utils.js` 和 `index.js`。在这个例子中，我们在 `index.js` 文件中从 `utils.js`
    文件导入 `sayHello` 函数，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `require` function is a global function that is available in Node.js and
    is used to import modules. The `require` function receives a string as a parameter,
    and this string is the path to the module that we want to import. In this case,
    we are using a relative path, but we can also use absolute paths or even the name
    of a module that is installed in the `node_modules` folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 函数是 Node.js 中可用的全局函数，用于导入模块。`require` 函数接收一个字符串作为参数，这个字符串是我们想要导入的模块的路径。在这个例子中，我们使用的是相对路径，但也可以使用绝对路径，甚至可以使用安装在
    `node_modules` 文件夹中的模块名称。'
- en: Exportation
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出
- en: 'In this example, we are exporting the `sayHello` function in the `utils.js`
    file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 `utils.js` 文件中导出 `sayHello` 函数：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`module.exports` is a global object that is available in Node.js, and it is
    used to export modules. In this case, we are exporting the `sayHello` function,
    but we can export any type of value.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports` 是 Node.js 中可用的全局对象，用于导出模块。在这个例子中，我们导出 `sayHello` 函数，但我们可以导出任何类型的值。'
- en: 'If you execute the `index.js` file, you will see the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行 `index.js` 文件，你会看到以下输出：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But if we execute the `utils.js` file, we will see nothing. Even if the file
    is executed, the `sayHello` function itself is not executed, just defined:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们执行 `utils.js` 文件，我们将看不到任何东西。即使文件被执行，`sayHello` 函数本身也不会执行，只是定义了：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Export object structures
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出对象结构
- en: 'The most popular structure to use while exporting modules is the object structure,
    as it is very flexible and allows us to export multiple values. If we want to
    export multiple values, we can use the `exports` object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出模块时，最常用的结构是对象结构，因为它非常灵活，允许我们导出多个值。如果我们想导出多个值，我们可以使用`exports`对象：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But we can also export an object directly using `module.exports = {}`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以直接使用`module.exports = {}`导出一个对象：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I recommend the preceding option as it is more readable when working with larger
    files. In order to import the exported values, we can use the destructuring syntax:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐前面的选项，因为它在处理大型文件时更易读。为了导入导出的值，我们可以使用解构语法：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JSON support
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON支持
- en: 'Yep, you can add JSON files directly to your project in Node.js and you don’t
    need to use any external library or parse the content:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以在Node.js项目中直接添加JSON文件，而无需使用任何外部库或解析内容：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can require the file directly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接引入该文件：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The way that modules work in Node.js is very similar to the IIFE pattern. When
    we import a module, the code is executed and the module is cached. If we import
    the same module again, the code is not executed again, and the module is retrieved
    from the cache. Basically, the module is executed only once (singleton pattern).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中模块的工作方式与IIFE模式非常相似。当我们导入一个模块时，代码会被执行并且模块会被缓存。如果我们再次导入相同的模块，代码将不会再次执行，并且模块将从缓存中检索。基本上，模块只执行一次（单例模式）。
- en: So, for example, if we make changes to the imported JSON file, the changes will
    not be reflected in the imported module once it has already been imported, because
    it is read once and the content is cached in the program memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们修改了导入的JSON文件，一旦导入模块后，这些更改将不会反映在导入的模块中，因为它是只读的，并且内容被缓存在了程序内存中。
- en: ECMAScript Modules (ESM)
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECMAScript模块（ESM）
- en: Node.js 12 introduced the support for `import` and `export` keywords.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 12引入了对`import`和`export`关键字的支持。
- en: 'In order to use modules with Node.js 20.11.0 you will need to create a `package.json`
    file and add the following configuration:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Node.js 20.11.0中的模块，你需要创建一个`package.json`文件并添加以下配置：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In [*Chapter 6*](B21678_06.xhtml#_idTextAnchor171), we will explore how to create
    a `package.json` file and how to configure it in depth.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B21678_06.xhtml#_idTextAnchor171)中，我们将探讨如何创建`package.json`文件以及如何对其进行深度配置。
- en: Basic usage
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'In this example, we are exporting the `sayHello` function in the `utils.js`
    file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们正在导出`utils.js`文件中的`sayHello`函数：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `export` keyword is used to export modules. In this case, we are exporting
    the `sayHello` function, but we can export any type of value. Note that we are
    using the `default` keyword, this is because we are exporting a single value.
    If we want to export multiple values, we can use the `export` keyword without
    the `default` keyword.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`关键字用于导出模块。在这种情况下，我们正在导出`sayHello`函数，但我们可以导出任何类型的值。注意，我们使用了`default`关键字，这是因为我们正在导出一个单一值。如果我们想导出多个值，我们可以使用不带`default`关键字的`export`关键字。'
- en: 'In this example, we are importing the `sayHello` function from the `utils.js`
    file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们正在从`utils.js`文件中导入`sayHello`函数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Export object structures
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出对象结构
- en: 'The most popular structure to use while exporting modules is the object structure,
    as it is very flexible and allows us to export multiple values. If we want to
    export multiple values, we can use the `export` keyword:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出模块时，最常用的结构是对象结构，因为它非常灵活，允许我们导出多个值。如果我们想导出多个值，我们可以使用`export`关键字：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we are importing the `sayHello` and `sayGoodbye` functions
    from the `utils.js` file in several ways:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们以几种方式从`utils.js`文件中导入`sayHello`和`sayGoodbye`函数：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Support for JSON files
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持JSON文件
- en: 'While using ESM, it is not possible to import JSON files directly as we did
    for CJS. If we try to import a JSON file, we will get the following error:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ESM时，我们无法直接导入JSON文件，就像我们为CJS所做的那样。如果我们尝试导入一个JSON文件，我们将得到以下错误：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the future, it will be possible to import JSON files directly, there is
    a proposal ([https://github.com/tc39/proposal-import-attributes](https://github.com/tc39/proposal-import-attributes))
    that will allow us to use import attributes, such as `import json from "./foo.json"
    with { type: "json" };`. But for now, we need to use a workaround to import JSON
    files. We can fix this error by understanding how interoperability works between
    ESM and CJS.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '在未来，将可以直接导入 JSON 文件，有一个提案([https://github.com/tc39/proposal-import-attributes](https://github.com/tc39/proposal-import-attributes))将允许我们使用导入属性，例如
    `import json from "./foo.json" with { type: "json" };`。但到目前为止，我们需要使用一种变通方法来导入
    JSON 文件。我们可以通过理解 ESM 和 CJS 之间的互操作性来修复这个错误。'
- en: Understanding how interoperability works
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模块互操作性是如何工作的
- en: While ESM is the future, there are many libraries and frameworks that still
    use CJS. The good news is that Node.js supports both module systems, and it is
    possible to use both in the same project without any problem, but there are some
    considerations that we need to take into account in order to make it work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ESM 是未来，但仍有许多库和框架仍在使用 CJS。好消息是 Node.js 支持这两种模块系统，并且可以在同一个项目中无问题地使用它们，但我们需要注意一些事项以确保其正常工作。
- en: Important note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Interoperability has been a very controversial topic in the Node.js community,
    and there are many discussions about it. If you want to know more about it, I
    recommend you to read this article by Gil Tayar: [https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71](https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 互操作性一直是 Node.js 社区中的一个非常具有争议的话题，并且对此有很多讨论。如果你想了解更多，我推荐你阅读 Gil Tayar 的这篇文章：[https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71](https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71)。
- en: JSON files in ESM
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ESM 中的 JSON 文件
- en: 'In the previous section, we saw that it is not possible to import JSON files
    directly in ESM today. But we can use the `module` library built into Node.js
    to import JSON files. The `module` library is a global object that is available
    in all the modules and contains the `createRequire` method that allows us to create
    a `require` function that can be used to import CJS modules:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了在 ESM 中今天无法直接导入 JSON 文件。但我们可以使用 Node.js 内置的 `module` 库来导入 JSON
    文件。`module` 库是一个全局对象，在所有模块中都是可用的，它包含 `createRequire` 方法，允许我们创建一个 `require` 函数，该函数可以用来导入
    CJS 模块：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: File extensions (.cjs and .mjs)
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件扩展名 (.cjs 和 .mjs)
- en: In order to use both module systems in the same project, we need to use different
    file extensions in our files. The `.mjs` extension is used for ESM modules, and
    the `.cjs` extension is used for CJS modules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在同一个项目中使用这两种模块系统，我们需要在我们的文件中使用不同的文件扩展名。`.mjs` 扩展名用于 ESM 模块，而 `.cjs` 扩展名用于
    CJS 模块。
- en: Important note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using `.js` extension for your files, Node.js will try to use the
    CJS module system by default, like if you were using `.``cjs` extension.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `.js` 扩展名来为你的文件命名，Node.js 将默认尝试使用 CJS 模块系统，就像你使用 `.cjs` 扩展名一样。
- en: 'Here is the file structure of a project that uses both module systems:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这两种模块系统的项目的文件结构：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `utils.cjs` file is a CJS module:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`utils.cjs` 文件是一个 CJS 模块：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `utils.mjs` file is an ESM module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`utils.mjs` 文件是一个 ESM 模块：'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `index.mjs` file is an ESM module. We can combine both module systems in
    the same file as long as we use different file extensions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.mjs` 文件是一个 ESM 模块。只要我们使用不同的文件扩展名，我们就可以在同一个文件中结合使用这两种模块系统：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `index.cjs` file is a CJS module. In this case, ESM modules can not be
    imported directly because `require` was designed as a synchronous function, and
    ESM modules are asynchronous. But we can use the `import` function to import ESM
    modules asynchronously:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.cjs` 文件是一个 CJS 模块。在这种情况下，由于 `require` 被设计为同步函数，而 ESM 模块是异步的，因此不能直接导入
    ESM 模块。但我们可以使用 `import` 函数异步导入 ESM 模块：'
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Important info
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: This way of importing modules is part of the standard, and it is called dynamic
    import ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导入模块的方式是标准的一部分，被称为动态导入([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports))。
- en: In this book, we use ESM modules by default, but we will use CJS modules when
    we need to use interoperability with other libraries and frameworks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们默认使用ESM模块，但当我们需要与其他库和框架进行互操作性时，我们将使用CJS模块。
- en: Now that we have a clearer idea of how to create modules in the different formats,
    let’s explore in the next section how the Node.js core APIs use a similar approach
    to expose tons of functionalities that we will use very often in our projects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何以不同格式创建模块有了更清晰的认识，让我们在下一节中探讨Node.js核心API如何使用类似的方法来公开我们在项目中非常常用的众多功能。
- en: Structuring core libraries
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心库的结构
- en: Over the years, Node.js has grown a lot, and the core libraries too. There are
    many libraries available for us to use, and it is important to know how they are
    structured to be able to use them properly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，Node.js已经发展壮大，核心库也是如此。有许多库可供我们使用，了解它们的结构对于能够正确使用它们非常重要。
- en: Most of the core libraries are quite simple and are structured in a similar
    way so you know what to expect in practical terms. Once you know how to use one
    of them, you will be able to use the rest of them without any problem.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数核心库都非常简单，并且以类似的方式构建，因此你知道在实际应用中可以期待什么。一旦你学会了如何使用其中一个，你将能够毫无问题地使用其余的库。
- en: Furthermore, you will be able to create your own libraries and publish them
    in npm, and other developers will be able to use them easily, but we will talk
    about this in the next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将能够创建自己的库并在npm上发布它们，其他开发者将能够轻松地使用它们，但我们在下一章中会讨论这一点。
- en: The library structure
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库结构
- en: Let’s look at the `fs` library as an example. The `fs` library is used to work
    with the file system, and it is one of the most used libraries in Node.js.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`fs`库为例。`fs`库用于与文件系统交互，它是Node.js中最常用的库之一。
- en: 'Any library that performs I/O operations is asynchronous. Historically, Node.js
    has offered two ways to handle I/O operations: callbacks or synchronous functions.
    While callbacks are still supported, Node.js currently offers the same functionality
    providing a promise interface.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何执行I/O操作的库都是异步的。从历史上看，Node.js提供了两种处理I/O操作的方法：回调或同步函数。虽然回调仍然被支持，但Node.js目前提供了相同的功能，提供了一个promise接口。
- en: 'In this example, we will use the `readFile` function to read a file asynchronously.
    This function receives the path of the file to read, and a callback function that
    will be called when the file is read. The callback function receives two arguments:
    an error object and the content of the file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`readFile`函数异步读取文件。这个函数接收要读取的文件的路径，以及当文件被读取时将被调用的回调函数。回调函数接收两个参数：一个错误对象和文件的内容：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you run the previous example, it will throw an error, as the file does
    not exist. However, we manage the error using the error first pattern in the callback.
    You can see the `OMG, there... error message`. Now, if you create the `hello.txt`
    file with the content `Hello world` and you run again the script, you will see
    the content printed as expected.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的示例时，它将抛出一个错误，因为文件不存在。然而，我们使用回调中的错误优先模式来处理错误。你可以看到“OMG，那里... 错误信息”。现在，如果你创建一个包含内容“Hello
    world”的`hello.txt`文件，并再次运行脚本，你将看到预期的内容被打印出来。
- en: 'In the next example, we will use the `readFileSync` function to read a file
    synchronously. This function receives the path of the file to read, and it returns
    the content of the file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将使用`readFileSync`函数来同步读取文件。这个函数接收要读取的文件的路径，并返回文件的内容：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And finally, in this example, we will use the `readFile` function to read a
    file asynchronously. This function receives the path of the file to read and returns
    a promise that will be resolved when the file is read. The promise will be resolved
    with the content of the file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个示例中，我们将使用`readFile`函数异步读取文件。这个函数接收要读取的文件的路径，并返回一个当文件被读取时将被解决的promise。这个promise将被文件的内容解决：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Core libraries without prefix
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无前缀的核心库
- en: Historically, Node.js has provided the core libraries without the `node:*` prefix,
    such as `const { readFile } from 'fs'`. This is mainly for backward compatibility.
    But it is recommended to use the new syntax with the prefix `node:*`. You will
    find many examples on the internet that use the old syntax. More information can
    be found at [https://nodejs.org/api/modules.html](https://nodejs.org/api/modules.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: CJS support
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the core libraries are available as CJS modules, so you can use them in
    your projects without any problem. You can use the `require` function to import
    them:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '| CJS | ESM |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| `const { readFile } =` `require(''node:fs'')` | `import { readFile }` `from
    ''node:fs''` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| `const { readFileSync } =` `require(''node:fs'')` | `import { readFileSync
    }` `from ''node:fs''` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `const { readFile } =` `require(''node:fs/promises'')` | `import { readFile
    }` `from ''node:fs/promises''` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `const { readFile } =` `require(''node:fs'')` | `import { readFile }` `from
    ''node:fs''` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `const { readFileSync } =` `require(''node:fs'')` | `import { readFileSync
    }` `from ''node:fs''` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: Additional interfaces
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other core libraries that you will use frequently, such as `http` or `https`,
    are structured similarly and provide an interface to work with events. We will
    cover this topic in depth in [*Chapter 7*](B21678_07.xhtml#_idTextAnchor206).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Stability index
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stability index is a number that indicates the stability of the core libraries.
    The stability index is a number between 0 and 3, where 0 means deprecated, 1 means
    experimental, 2 means stable, and 3 means legacy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: You can find the stability index of each core library in the official documentation,
    along with more details about the stability index at [https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#stability-index](https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#stability-index).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If you are just starting with Node.js, you should use the core libraries with
    stability index 2 or 3\. The core libraries with a stability index of 0 or 1 are
    not recommended for production environments.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples from Node.js 20:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Permission Model ([https://nodejs.org/docs/latest-v20.x/api/permissions.html#permission-model](https://nodejs.org/docs/latest-v20.x/api/permissions.html#permission-model)):
    This is an API that allows us to restrict access to system resources such as network
    or files. Currently, it is in active development (stability=1), so you can experiment
    with it, but it is not yet mature enough to use for building production systems
    as the API might change or have unexpected behavior.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'http ([https://nodejs.org/docs/latest-v20.x/api/http.html#http](https://nodejs.org/docs/latest-v20.x/api/http.html#http)):
    This is the API used since the beginning of Node.js to build web server applications
    and make HTTP requests to external resources. Currently, it is stable (stability=2),
    but some methods are legacy (stability=3). This library is perfect for use in
    production systems.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http ([https://nodejs.org/docs/latest-v20.x/api/http.html#http](https://nodejs.org/docs/latest-v20.x/api/http.html#http))：这是自
    Node.js 诞生以来用于构建网络服务器应用程序和对外部资源发起 HTTP 请求的 API。目前它是稳定的（稳定性=2），但某些方法是遗留的（稳定性=3）。这个库非常适合在生产系统中使用。
- en: Other core libraries
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他核心库
- en: The `fs` library is just an example; in this book, we will cover the most important
    core libraries, but you can find the documentation of all the core libraries in
    the Node.js documentation at [https://nodejs.org/docs/latest-v20.x/api/index.html](https://nodejs.org/docs/latest-v20.x/api/index.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs` 库只是一个例子；在这本书中，我们将介绍最重要的核心库，但你可以在 Node.js 文档中找到所有核心库的文档，网址为 [https://nodejs.org/docs/latest-v20.x/api/index.html](https://nodejs.org/docs/latest-v20.x/api/index.html)。'
- en: 'In my humble opinion, the most important core libraries when you are starting
    with Node.js are the following, in alphabetical order:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我谦逊的观点中，当你刚开始使用 Node.js 时，最重要的核心库如下，按字母顺序排列：
- en: '`Buffer` handles binary data efficiently in memory, commonly used for tasks
    such as file operations and network communication.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Buffer` 在内存中高效地处理二进制数据，常用于文件操作和网络通信等任务。'
- en: '`Crypto` provides cryptographic functionality, such as encryption, decryption,
    hashing, and digital signatures.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Crypto` 提供了加密、解密、哈希和数字签名等加密功能。'
- en: '`Events` allows us to create, emit, and listen for events inside our applications.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Events` 允许我们在应用程序内部创建、触发和监听事件。'
- en: '`File System` provides a solid interface to deal with the file system (files,
    folders, creation, deletions, etc.).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File System` 提供了一个稳定的接口来处理文件系统（文件、文件夹、创建、删除等）。'
- en: '`HTTP` allows us to create HTTP servers and perform HTTP requests.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP` 允许我们创建 HTTP 服务器并执行 HTTP 请求。'
- en: '`OS` offers various utilities to retrieve information about the system’s architecture,
    platform, CPU, memory, network interfaces, and much more.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OS` 提供了各种实用工具来检索有关系统架构、平台、CPU、内存、网络接口等信息。'
- en: '`Path` provides utilities for working with file paths and directory paths.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path` 提供了处理文件路径和目录路径的实用工具。'
- en: '`Process` provides information and control over aspects of the current Node.js
    process, including environmental variables, lifecycle events, and more.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Process` 提供了关于当前 Node.js 进程方面的信息和控制，包括环境变量、生命周期事件等。'
- en: '`Stream` provides readable and writable streams, as well as transform streams
    for modifying data as it passes through. This module is essential for building
    scalable and memory-efficient applications that work with large volumes of data
    in Node.js.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream` 提供了可读和可写流，以及用于在数据通过时修改数据的转换流。这个模块对于在 Node.js 中构建可扩展和内存高效的、处理大量数据的应用程序至关重要。'
- en: '`Timers` includes functions such as `setTimeout()`, `setInterval()`, and `setImmediate()`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timers` 包含了诸如 `setTimeout()`、`setInterval()` 和 `setImmediate()` 等函数。'
- en: There are other core libraries that are very important to extend the functionality
    of Node.js, but they are not so important when you are just starting out with
    Node.js.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些核心库对于扩展 Node.js 的功能非常重要，但当你刚开始使用 Node.js 时，它们并不那么重要。
- en: For example, the `child_process` library is essential to execute external commands
    such as `ls` and `cat` from Node.js, complex applications such as `ffmpeg` and
    `imagemagick`, and even directly execute Python scripts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`child_process` 库对于从 Node.js 执行外部命令（如 `ls` 和 `cat`）、复杂的应用程序（如 `ffmpeg` 和
    `imagemagick`）以及直接执行 Python 脚本至关重要。
- en: The `C++ Addons` ([https://nodejs.org/dist/latest-v20.x/docs/api/addons.html](https://nodejs.org/dist/latest-v20.x/docs/api/addons.html))
    are very important to extend the functionality of Node.js with C++ code. This
    is very useful when you need to use a C++ library in your Node.js application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`C++ Addons` ([https://nodejs.org/dist/latest-v20.x/docs/api/addons.html](https://nodejs.org/dist/latest-v20.x/docs/api/addons.html))
    对于使用 C++ 代码扩展 Node.js 的功能非常重要。当你需要在 Node.js 应用程序中使用 C++ 库时，这非常有用。'
- en: Command-line options
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行选项
- en: Node.js provides a lot of command-line options and environmental variables that
    you can use to customize the behavior of Node.js. You can find the complete list
    of command-line options in the Node.js documentation at [https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options](https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 提供了许多命令行选项和环境变量，您可以使用它们来定制 Node.js 的行为。您可以在 Node.js 文档中找到完整的命令行选项列表，文档地址为
    [https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options](https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options)。
- en: For example, you can use the `--experimental-json-modules` command-line option
    to enable the JSON modules in ESM, such as `node --``experimental-json-modules
    index.js`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用 `--experimental-json-modules` 命令行选项来启用 ESM 中的 JSON 模块，例如 `node --``experimental-json-modules
    index.js`。
- en: 'The code of the `index.js` file is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js` 文件的代码如下：'
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This does work, and the terminal output will remark that the JSON modules are
    experimental:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实有效，终端输出将指出 JSON 模块是实验性的：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Aside from enabling experimental features, you can use the `--max-old-space-size`
    command-line option to increase the RAM usage limit of Node.js. This is very useful
    when you are working with large files, have a lot of data in memory, or are debugging
    a complicated memory leak.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了启用实验性功能外，您还可以使用 `--max-old-space-size` 命令行选项来增加 Node.js 的 RAM 使用限制。当您处理大文件、内存中有大量数据或调试复杂的内存泄漏时，这非常有用。
- en: 'For example, you can use the `--max-old-space-size=4096` command-line option
    to increase the RAM limit to 4GB: `node --``max-old-space-size=4096 index.js`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用 `--max-old-space-size=4096` 命令行选项将 RAM 限制增加到 4GB：`node --``max-old-space-size=4096
    index.js`。
- en: Important note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can’t use all the RAM in your computer, because the operating system and
    other applications also need some RAM to work properly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法使用计算机中的所有 RAM，因为操作系统和其他应用程序也需要一些 RAM 来正常工作。
- en: Environmental variables
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: You can use environmental variables to customize the behavior of Node.js. You
    can find the complete list of environmental variables in the Node.js documentation
    at [https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables](https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用环境变量来定制 Node.js 的行为。您可以在 Node.js 文档中找到完整的环境变量列表，文档地址为 [https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables](https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables)。
- en: 'Sometimes it is more convenient to use environmental variables instead of command-line
    options directly, such as when using UNIX-based systems:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候使用环境变量而不是直接使用命令行选项会更方便，例如在使用基于 UNIX 的系统时：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code lets you use the `NODE_OPTIONS` environmental variable to
    set the command-line options that you want to use. This is very useful when you
    are using a tool such as `nodemon` or `pm2` to run your Node.js application. We
    will use a lot of environmental variables from [*Chapter 12*](B21678_12.xhtml#_idTextAnchor320).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许您使用 `NODE_OPTIONS` 环境变量来设置您想要使用的命令行选项。当您使用 `nodemon` 或 `pm2` 等工具运行 Node.js
    应用程序时，这非常有用。我们将使用来自 [*第 12 章*](B21678_12.xhtml#_idTextAnchor320) 的许多环境变量。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered how modules work in Node.js, the differences
    between CJS and ESM, and how to interoperate between them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Node.js 中模块的工作方式、CJS 和 ESM 之间的区别以及它们之间的互操作性。
- en: Additionally, we have covered the core libraries of Node.js, how to use them,
    their structure, and the stability index. We listed the most important core libraries
    when starting out with Node.js and other libraries that become essential in more
    advanced projects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了 Node.js 的核心库、如何使用它们、它们的结构和稳定性指数。我们列出了在开始使用 Node.js 时最重要的核心库，以及在其他更高级项目中变得至关重要的库。
- en: Finally, we learned how to use the command-line options and environmental variables
    to modify the Node.js behavior.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用命令行选项和环境变量来修改 Node.js 的行为。
- en: In the next chapter, we will learn how to use the **node.js package manager**
    (**npm**) in depth. We will publish our first package and we will see how we can
    integrate the huge module ecosystem available for us in our Node.js projects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入学习如何使用 **node.js 包管理器**（**npm**）。我们将发布我们的第一个包，并了解我们如何将可用的庞大模块生态系统集成到我们的
    Node.js 项目中。
- en: Further reading
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Node.js documentation: [https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index](https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 文档：[https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index](https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index)
- en: )
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Keeping the Node.js core small: [https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152](https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持 Node.js 内核小巧：[https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152](https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152)
- en: 'Moz://a Hacks | ES6 In Depth: Modules: [https://hacks.mozilla.org/2015/08/es6-in-depth-modules](https://hacks.mozilla.org/2015/08/es6-in-depth-modules)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moz://a Hacks | 深入了解 ES6：模块：[https://hacks.mozilla.org/2015/08/es6-in-depth-modules](https://hacks.mozilla.org/2015/08/es6-in-depth-modules)
- en: 'Promises API in Node.js Core: Part “Do”, the Update! - Joe Sepi, IBM: [https://www.youtube.com/watch?v=f7YSsYQmNSI](https://www.youtube.com/watch?v=f7YSsYQmNSI)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 核心中的 Promises API：第“Do”，更新！ - Joe Sepi，IBM：[https://www.youtube.com/watch?v=f7YSsYQmNSI](https://www.youtube.com/watch?v=f7YSsYQmNSI)
