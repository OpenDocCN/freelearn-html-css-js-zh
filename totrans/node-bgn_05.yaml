- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js Core Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delve into the core libraries of Node.js and explore the
    techniques for modularizing your code. JavaScript has come a long way from being
    limited to browsers, and Node.js has offered us new ways to structure our code.
    We’ll begin by understanding the historical limitations of organizing code in
    the browser and how they led to the development of various module systems. We’ll
    primarily focus on two module systems, **CommonJS** (**CJS**) and **ECMAScript
    Modules** (**ESM**), and discuss their usage, importation, and exportation. Achieving
    interoperability between these two systems is crucial, and we’ll explore strategies
    to make it work seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how core libraries in Node.js are structured is key. We’ll take
    a closer look at core libraries including `fs` and `http`, which deal with file
    operations, and explore the use of callbacks, synchronous functions, and promises
    for asynchronous I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Also, more advanced topics related to extending Node.js functionality with C++
    addons and executing external commands using the `child_process` library will
    be discussed. We’ll also review various command-line options (including to enable
    experimental features and control memory allocation) and environmental variables
    that allow you to customize the Node.js behavior. We’ll provide examples of how
    to use these options to enable experimental features, control memory allocation,
    and fine-tune your Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create and consume modules using the ESM and CJS approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interoperate between ESM and CJS modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Node.js core libraries interfaces are structured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the most relevant Node.js core libraries are when starting with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend the Node.js functionality by using command-line options and the
    `NODE_OPTIONS` environment variable
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/WQzdXAFxdsc](https://youtu.be/WQzdXAFxdsc)
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing your code (ESM versus CJS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For many years JavaScript was limited to the browser, and the only way to organize
    our code was using script files that were loaded in the correct order in a HTML
    page. This was done by including specific references in the HTML files, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This approach was not scalable, and it was very easy to pollute the global scope.
    To solve this problem, historically we used the IIFE pattern and the module pattern.
    As the adoption of JavaScript started to grow and the amount of JavaScript required
    for a modern website was dramatically rising, the community began to create libraries
    and frameworks to solve these aforementioned problems. The outcome included results
    such as RequireJS ([https://requirejs.org/](https://requirejs.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For many years, we had four different ways to organize our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CommonJS (CJS)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECMAScript** **Modules (ESM)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous Module** **Definition (AMD)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Module** **Definition (UMD)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will focus on the first two approaches, CJS and ESM. Currently
    CJS is the default module system in Node.js, but since the release of Node.js
    12, ESM is now available. In this section, we will explore how to create and consume
    modules using both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Today, in the browser environment is very common to consolidate our code using
    a module bundler such as webpack or Rollup. However, in Node.js we keep using
    CJS or ESM directly. In this section, we will explore how to create and consume
    modules using both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS (CJS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CommonJS is the module system that Node.js uses by default. This module system
    is synchronous, and is based on the `require` and `module.exports` functions.
    It is important to note that this module system is not part of the ECMAScript
    specification, but it is the most used module system in the Node.js ecosystem,
    especially if you are looking for documentation or tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two aspects here of CJS use that we need to understand: the importation
    and the exportation. Let’s start with the importation.'
  prefs: []
  type: TYPE_NORMAL
- en: Importation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, we have two files in our project, `utils.js` and `index.js`. In this example,
    we are importing the `sayHello` function from the `utils.js` file in the `index.js`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `require` function is a global function that is available in Node.js and
    is used to import modules. The `require` function receives a string as a parameter,
    and this string is the path to the module that we want to import. In this case,
    we are using a relative path, but we can also use absolute paths or even the name
    of a module that is installed in the `node_modules` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Exportation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we are exporting the `sayHello` function in the `utils.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`module.exports` is a global object that is available in Node.js, and it is
    used to export modules. In this case, we are exporting the `sayHello` function,
    but we can export any type of value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute the `index.js` file, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we execute the `utils.js` file, we will see nothing. Even if the file
    is executed, the `sayHello` function itself is not executed, just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Export object structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most popular structure to use while exporting modules is the object structure,
    as it is very flexible and allows us to export multiple values. If we want to
    export multiple values, we can use the `exports` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also export an object directly using `module.exports = {}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I recommend the preceding option as it is more readable when working with larger
    files. In order to import the exported values, we can use the destructuring syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: JSON support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yep, you can add JSON files directly to your project in Node.js and you don’t
    need to use any external library or parse the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can require the file directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The way that modules work in Node.js is very similar to the IIFE pattern. When
    we import a module, the code is executed and the module is cached. If we import
    the same module again, the code is not executed again, and the module is retrieved
    from the cache. Basically, the module is executed only once (singleton pattern).
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, if we make changes to the imported JSON file, the changes will
    not be reflected in the imported module once it has already been imported, because
    it is read once and the content is cached in the program memory.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript Modules (ESM)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js 12 introduced the support for `import` and `export` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use modules with Node.js 20.11.0 you will need to create a `package.json`
    file and add the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B21678_06.xhtml#_idTextAnchor171), we will explore how to create
    a `package.json` file and how to configure it in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we are exporting the `sayHello` function in the `utils.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `export` keyword is used to export modules. In this case, we are exporting
    the `sayHello` function, but we can export any type of value. Note that we are
    using the `default` keyword, this is because we are exporting a single value.
    If we want to export multiple values, we can use the `export` keyword without
    the `default` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are importing the `sayHello` function from the `utils.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Export object structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most popular structure to use while exporting modules is the object structure,
    as it is very flexible and allows us to export multiple values. If we want to
    export multiple values, we can use the `export` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are importing the `sayHello` and `sayGoodbye` functions
    from the `utils.js` file in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Support for JSON files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While using ESM, it is not possible to import JSON files directly as we did
    for CJS. If we try to import a JSON file, we will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the future, it will be possible to import JSON files directly, there is
    a proposal ([https://github.com/tc39/proposal-import-attributes](https://github.com/tc39/proposal-import-attributes))
    that will allow us to use import attributes, such as `import json from "./foo.json"
    with { type: "json" };`. But for now, we need to use a workaround to import JSON
    files. We can fix this error by understanding how interoperability works between
    ESM and CJS.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how interoperability works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While ESM is the future, there are many libraries and frameworks that still
    use CJS. The good news is that Node.js supports both module systems, and it is
    possible to use both in the same project without any problem, but there are some
    considerations that we need to take into account in order to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Interoperability has been a very controversial topic in the Node.js community,
    and there are many discussions about it. If you want to know more about it, I
    recommend you to read this article by Gil Tayar: [https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71](https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71).'
  prefs: []
  type: TYPE_NORMAL
- en: JSON files in ESM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we saw that it is not possible to import JSON files
    directly in ESM today. But we can use the `module` library built into Node.js
    to import JSON files. The `module` library is a global object that is available
    in all the modules and contains the `createRequire` method that allows us to create
    a `require` function that can be used to import CJS modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: File extensions (.cjs and .mjs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to use both module systems in the same project, we need to use different
    file extensions in our files. The `.mjs` extension is used for ESM modules, and
    the `.cjs` extension is used for CJS modules.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `.js` extension for your files, Node.js will try to use the
    CJS module system by default, like if you were using `.``cjs` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the file structure of a project that uses both module systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `utils.cjs` file is a CJS module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `utils.mjs` file is an ESM module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index.mjs` file is an ESM module. We can combine both module systems in
    the same file as long as we use different file extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index.cjs` file is a CJS module. In this case, ESM modules can not be
    imported directly because `require` was designed as a synchronous function, and
    ESM modules are asynchronous. But we can use the `import` function to import ESM
    modules asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Important info
  prefs: []
  type: TYPE_NORMAL
- en: This way of importing modules is part of the standard, and it is called dynamic
    import ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)).
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we use ESM modules by default, but we will use CJS modules when
    we need to use interoperability with other libraries and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clearer idea of how to create modules in the different formats,
    let’s explore in the next section how the Node.js core APIs use a similar approach
    to expose tons of functionalities that we will use very often in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring core libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, Node.js has grown a lot, and the core libraries too. There are
    many libraries available for us to use, and it is important to know how they are
    structured to be able to use them properly.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the core libraries are quite simple and are structured in a similar
    way so you know what to expect in practical terms. Once you know how to use one
    of them, you will be able to use the rest of them without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you will be able to create your own libraries and publish them
    in npm, and other developers will be able to use them easily, but we will talk
    about this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The library structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at the `fs` library as an example. The `fs` library is used to work
    with the file system, and it is one of the most used libraries in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any library that performs I/O operations is asynchronous. Historically, Node.js
    has offered two ways to handle I/O operations: callbacks or synchronous functions.
    While callbacks are still supported, Node.js currently offers the same functionality
    providing a promise interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will use the `readFile` function to read a file asynchronously.
    This function receives the path of the file to read, and a callback function that
    will be called when the file is read. The callback function receives two arguments:
    an error object and the content of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When you run the previous example, it will throw an error, as the file does
    not exist. However, we manage the error using the error first pattern in the callback.
    You can see the `OMG, there... error message`. Now, if you create the `hello.txt`
    file with the content `Hello world` and you run again the script, you will see
    the content printed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will use the `readFileSync` function to read a file
    synchronously. This function receives the path of the file to read, and it returns
    the content of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, in this example, we will use the `readFile` function to read a
    file asynchronously. This function receives the path of the file to read and returns
    a promise that will be resolved when the file is read. The promise will be resolved
    with the content of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Core libraries without prefix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Historically, Node.js has provided the core libraries without the `node:*` prefix,
    such as `const { readFile } from 'fs'`. This is mainly for backward compatibility.
    But it is recommended to use the new syntax with the prefix `node:*`. You will
    find many examples on the internet that use the old syntax. More information can
    be found at [https://nodejs.org/api/modules.html](https://nodejs.org/api/modules.html).
  prefs: []
  type: TYPE_NORMAL
- en: CJS support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the core libraries are available as CJS modules, so you can use them in
    your projects without any problem. You can use the `require` function to import
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| CJS | ESM |'
  prefs: []
  type: TYPE_TB
- en: '| `const { readFile } =` `require(''node:fs'')` | `import { readFile }` `from
    ''node:fs''` |'
  prefs: []
  type: TYPE_TB
- en: '| `const { readFileSync } =` `require(''node:fs'')` | `import { readFileSync
    }` `from ''node:fs''` |'
  prefs: []
  type: TYPE_TB
- en: '| `const { readFile } =` `require(''node:fs/promises'')` | `import { readFile
    }` `from ''node:fs/promises''` |'
  prefs: []
  type: TYPE_TB
- en: '| `const { readFile } =` `require(''node:fs'')` | `import { readFile }` `from
    ''node:fs''` |'
  prefs: []
  type: TYPE_TB
- en: '| `const { readFileSync } =` `require(''node:fs'')` | `import { readFileSync
    }` `from ''node:fs''` |'
  prefs: []
  type: TYPE_TB
- en: Additional interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other core libraries that you will use frequently, such as `http` or `https`,
    are structured similarly and provide an interface to work with events. We will
    cover this topic in depth in [*Chapter 7*](B21678_07.xhtml#_idTextAnchor206).
  prefs: []
  type: TYPE_NORMAL
- en: Stability index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stability index is a number that indicates the stability of the core libraries.
    The stability index is a number between 0 and 3, where 0 means deprecated, 1 means
    experimental, 2 means stable, and 3 means legacy.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the stability index of each core library in the official documentation,
    along with more details about the stability index at [https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#stability-index](https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#stability-index).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are just starting with Node.js, you should use the core libraries with
    stability index 2 or 3\. The core libraries with a stability index of 0 or 1 are
    not recommended for production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples from Node.js 20:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Permission Model ([https://nodejs.org/docs/latest-v20.x/api/permissions.html#permission-model](https://nodejs.org/docs/latest-v20.x/api/permissions.html#permission-model)):
    This is an API that allows us to restrict access to system resources such as network
    or files. Currently, it is in active development (stability=1), so you can experiment
    with it, but it is not yet mature enough to use for building production systems
    as the API might change or have unexpected behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'http ([https://nodejs.org/docs/latest-v20.x/api/http.html#http](https://nodejs.org/docs/latest-v20.x/api/http.html#http)):
    This is the API used since the beginning of Node.js to build web server applications
    and make HTTP requests to external resources. Currently, it is stable (stability=2),
    but some methods are legacy (stability=3). This library is perfect for use in
    production systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other core libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fs` library is just an example; in this book, we will cover the most important
    core libraries, but you can find the documentation of all the core libraries in
    the Node.js documentation at [https://nodejs.org/docs/latest-v20.x/api/index.html](https://nodejs.org/docs/latest-v20.x/api/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In my humble opinion, the most important core libraries when you are starting
    with Node.js are the following, in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Buffer` handles binary data efficiently in memory, commonly used for tasks
    such as file operations and network communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Crypto` provides cryptographic functionality, such as encryption, decryption,
    hashing, and digital signatures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Events` allows us to create, emit, and listen for events inside our applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File System` provides a solid interface to deal with the file system (files,
    folders, creation, deletions, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP` allows us to create HTTP servers and perform HTTP requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OS` offers various utilities to retrieve information about the system’s architecture,
    platform, CPU, memory, network interfaces, and much more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path` provides utilities for working with file paths and directory paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Process` provides information and control over aspects of the current Node.js
    process, including environmental variables, lifecycle events, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream` provides readable and writable streams, as well as transform streams
    for modifying data as it passes through. This module is essential for building
    scalable and memory-efficient applications that work with large volumes of data
    in Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timers` includes functions such as `setTimeout()`, `setInterval()`, and `setImmediate()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other core libraries that are very important to extend the functionality
    of Node.js, but they are not so important when you are just starting out with
    Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `child_process` library is essential to execute external commands
    such as `ls` and `cat` from Node.js, complex applications such as `ffmpeg` and
    `imagemagick`, and even directly execute Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The `C++ Addons` ([https://nodejs.org/dist/latest-v20.x/docs/api/addons.html](https://nodejs.org/dist/latest-v20.x/docs/api/addons.html))
    are very important to extend the functionality of Node.js with C++ code. This
    is very useful when you need to use a C++ library in your Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js provides a lot of command-line options and environmental variables that
    you can use to customize the behavior of Node.js. You can find the complete list
    of command-line options in the Node.js documentation at [https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options](https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options).
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can use the `--experimental-json-modules` command-line option
    to enable the JSON modules in ESM, such as `node --``experimental-json-modules
    index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the `index.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This does work, and the terminal output will remark that the JSON modules are
    experimental:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Aside from enabling experimental features, you can use the `--max-old-space-size`
    command-line option to increase the RAM usage limit of Node.js. This is very useful
    when you are working with large files, have a lot of data in memory, or are debugging
    a complicated memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use the `--max-old-space-size=4096` command-line option
    to increase the RAM limit to 4GB: `node --``max-old-space-size=4096 index.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can’t use all the RAM in your computer, because the operating system and
    other applications also need some RAM to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Environmental variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use environmental variables to customize the behavior of Node.js. You
    can find the complete list of environmental variables in the Node.js documentation
    at [https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables](https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is more convenient to use environmental variables instead of command-line
    options directly, such as when using UNIX-based systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code lets you use the `NODE_OPTIONS` environmental variable to
    set the command-line options that you want to use. This is very useful when you
    are using a tool such as `nodemon` or `pm2` to run your Node.js application. We
    will use a lot of environmental variables from [*Chapter 12*](B21678_12.xhtml#_idTextAnchor320).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered how modules work in Node.js, the differences
    between CJS and ESM, and how to interoperate between them.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we have covered the core libraries of Node.js, how to use them,
    their structure, and the stability index. We listed the most important core libraries
    when starting out with Node.js and other libraries that become essential in more
    advanced projects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to use the command-line options and environmental variables
    to modify the Node.js behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use the **node.js package manager**
    (**npm**) in depth. We will publish our first package and we will see how we can
    integrate the huge module ecosystem available for us in our Node.js projects.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js documentation: [https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index](https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the Node.js core small: [https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152](https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moz://a Hacks | ES6 In Depth: Modules: [https://hacks.mozilla.org/2015/08/es6-in-depth-modules](https://hacks.mozilla.org/2015/08/es6-in-depth-modules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Promises API in Node.js Core: Part “Do”, the Update! - Joe Sepi, IBM: [https://www.youtube.com/watch?v=f7YSsYQmNSI](https://www.youtube.com/watch?v=f7YSsYQmNSI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
