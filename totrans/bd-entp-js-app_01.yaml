- en: The Importance of Good Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that separates a good company from a great company is their processes.
    In a great company, everyone understands what is expected of them, what they can
    expect from others, the vision of the company, and the philosophy of the workplace.
    With that foundation, the staff has the freedom to be creative and innovate, working
    within the processes and boundaries set by the company.
  prefs: []
  type: TYPE_NORMAL
- en: When there are no processes, there is chaos. Developers wouldn't know what to
    expect— are the requirements and specifications documented? Where can I find them?
    They also wouldn't understand what's expected of them—do I need to write tests
    or is this a **Proof of Concept** (**PoC**)? What edge cases should I test for?
    Without processes, managers and developers will waste time chasing requirements
    and clarifications, giving them less time to be creative and innovative, and thus
    excel at their jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, a chaotic environment leads to a product that's lower in quality.
    On the technical side, there'll be more **technical debt**—bugs and inefficiencies
    that need to be fixed later. The product team will suffer too, as fewer features
    would be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these companies, the best way to improve is simply to start implementing
    robust processes on the technical level by implementing **Test-Driven Development**
    (**TDD**), and on the management level by adopting **Agile** principles and/or
    implementing the **Scrum** framework. In this chapter, we will focus on the technical
    aspect—implementing TDD. Specifically, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is technical debt?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the causes and consequences of technical debt?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing technical debt by implementing TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most popular questions on the Software Engineering Stack Exchange
    ([https://softwareengineering.stackexchange.com/](https://softwareengineering.stackexchange.com/)) website
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"*I''m doing 90% maintenance and 10% development, is this normal?"'
  prefs: []
  type: TYPE_NORMAL
- en: Whilst this should never be regarded as normal, for many developers, it is their
    reality. So, why do so many projects end up in an unmaintainable state? After
    all, every project starts off with a blank slate.
  prefs: []
  type: TYPE_NORMAL
- en: Some may say that it's because most programmers are inherently lazy, but most
    also take pride in their work, and value quality over speed. Others may say it's
    because the developers are incompetent, but even companies that employ very talented
    technical teams fall victim to this.
  prefs: []
  type: TYPE_NORMAL
- en: My theory is that during the lengthy development process, it's too easy to make
    little concessions along the way, where code quality is sacrificed to save other
    resources, usually time. For instance, you may stop writing tests to meet a deadline,
    or forgo refactoring because your manager assures you that the project is just
    a PoC or **Minimum Viable Product** (**MVP**). Little by little, these small concessions
    build up. Oftentimes, the deadlines become ever more unreasonable, and the MVP
    becomes the company's flagship product. That's how we end up with so many unmaintainable
    projects in this world.
  prefs: []
  type: TYPE_NORMAL
- en: '"Most software today is very much like an Egyptian pyramid with millions of
    bricks piled on top of each other, with no structural integrity, but just done
    by brute force and thousands of slaves."'
  prefs: []
  type: TYPE_NORMAL
- en: – Alan Kay, creator of Smalltalk
  prefs: []
  type: TYPE_NORMAL
- en: These compromises, although small at the time, have a knock-on effect on the code
    that is written afterward. This cumulative effect is described using the metaphor
    of *technical debt*, which plays on the analogy of financial debt, where you incur
    compound interest on your existing debts.
  prefs: []
  type: TYPE_NORMAL
- en: What is technical debt?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technical debt is a metaphor created by Ward Cunningham, an American computer
    programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A little debt speeds development so long as it is paid back promptly with
    a rewrite... The danger occurs when the debt is not repaid. Every minute spent
    on not-quite-right code counts as interest on that debt."'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to start your own business, but do not have enough
    personal savings, you may opt to take out a loan with a bank. In this case, you
    incur a small debt now in order to acquire a potentially larger reward later, when
    your business generates a profit.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, you may decide to incur some technical debt in order to capture the **First-Mover
    Advantage** (**FMA**) to ship a feature before your competitors go to market.
    The debt comes in the form of poorly-written code; for instance, you may write
    everything into a single file (colloquially called a kitchen sink) with no modularization
    or tests.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the debt is incurred with the expectation that it will be repaid,
    *with interest*, at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: For development, repayment comes in the form of **refactoring**. This is where
    time is re-invested to revise the poorly-written code back to an acceptable standard.
    As this requires time and manpower, by incurring the technical debt, you are,
    in essence, trading a moderate increase in development speed now for a significant
    decrease later.
  prefs: []
  type: TYPE_NORMAL
- en: The problem arises when the debt is not repaid sufficiently quickly. At some
    point, the amount of maintenance done on the project is so great that no more
    features can be added, and the business may opt for a complete rewrite instead.
  prefs: []
  type: TYPE_NORMAL
- en: Causes of technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss how to tackle technical debt, let''s first examine some of
    its most common causes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lack of talent**: Inexperienced developers may not follow best practices
    and write unclean code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of time**: Setting unreasonable deadlines, or adding new features without
    allotting additional time, means developers do not have enough time to follow
    proper processes of writing tests, conducting code reviews, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of morale**: We should not overlook the human aspect of development.
    If requirements change all the time, or developers are required to work overtime,
    then they''re not likely to produce good work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these causes can easily be mitigated. The problem of inexperienced developers
    can be tackled through mentoring, code reviews, and general training. The problem
    of morale can be tempered by providing better working environments. The issue
    of lack of time can be remedied by reducing the scope of the project to something
    more achievable; this may mean pushing non-essential features to a subsequent
    phase. Besides this, the business can employ more staff and/or outsource the development
    of well-defined modules to external contractors.
  prefs: []
  type: TYPE_NORMAL
- en: The real problem lies in the reluctance to tackle technical debt, since the
    biggest cause of technical debt is the *existing technical debt*. Any new code
    that depends on the bad code will very soon become part of the technical debt
    and incur further debt down the line.
  prefs: []
  type: TYPE_NORMAL
- en: The debt spiral
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you talk with product managers or business owners, most of them understand
    the concept of technical debt; however, most managers or business owners I've
    encountered also tend to overestimate the short-term returns and underestimate
    the long-term consequences. They believe that technical debt works like personal
    loans issued by banks, with an interest rate of around 3% **Annual Percentage
    Rate** (**APR**); in reality, it works more like payday loans that charge you
    1500% APR.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the debt metaphor isn't completely accurate. This is because, unlike
    a formalized loan, when you incur technical debt, you don't actually know the
    interest rate or repayment period beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The debt may require one week of refactoring time that you can delay indefinitely,
    or it may cost you a few months' time just a few days down the line. It is very
    hard to predict and quantify the effect of technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, there's no guarantee that by incurring the debt, the current set
    of features are actually going to be finished earlier. Often, the consequences
    of technical debt are close to immediate; therefore, by rushing, it may actually
    slow you down within the same development cycle. It is very hard to predict and
    quantify the short-term benefits of incurring technical debt. In that sense, incurring
    technical debt resembles more of a gamble than a loan.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences of technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s examine the consequences of technical debt. Some are obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: Development speed will slow down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More manpower (and thus money) and time will need to be spent to implement the
    same set of features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More bugs, which consequently means poorer user experience, and more personnel
    required for customer service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the human cost of technical debt is often overlooked; so
    let's spend some time discussing it here.
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt leads to low morale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most developers want to work on **greenfield** projects where they can develop
    new features, rather than to inherit legacy **brownfield** projects riddled with
    bugs and technical debt. This will likely reduce the morale of the developers.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, those working on brownfield projects may even show animosity
    toward their colleagues who work on greenfield projects. This is because newer
    frameworks, libraries, and paradigms will eventually replace older ones, making
    them obsolete. Those working on legacy projects know that the skills they develop
    will be worthless in a few years' time, making them less competitive on the job
    market. In comparison, their colleagues are gaining valuable experience on more
    modern frameworks that will increase their market value. I can't imagine a developer
    being happy knowing their skills are becoming less and less relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, having technical debt would likely ignite disagreement between
    developers and their managers about the best time to repay the debt. Typically,
    developers demand immediate repayment, while the (inexperienced) managers would
    try to push it further down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, having technical debt in the project tends to lower the morale of its
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences of low morale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In turn, low morale leads to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower productivity**: Unmotivated developers are more likely to work slower,
    take longer breaks, and be less engaged in the business.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower code quality**: Development is a creative process—there is more than
    one way to implement a feature. Developers with low morale are unlikely to conjure
    up the willingness to figure out the best approach—they''ll simply select for
    the approach that requires the least effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High Turnover**: Unhappy developers are going to be looking for better jobs,
    leading to a high turnover of staff for the company. This means the time invested
    to train the developer and integrate him/her into the team is wasted. Furthermore,
    it may cause other members of staff to lose confidence in the company, creating
    a snowball effect of people leaving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some managers may argue that the business is not responsible for the happiness
    of its developers—they pay them to produce work and value, not to be happy. Whilst this
    is true, an experienced project manager should remember that a development team
    is not a machine—it consists of people, each with their individual ambitions and
    emotions. Thus, the manager would be wise to consider the human costs of technical
    debt when making a business decision.
  prefs: []
  type: TYPE_NORMAL
- en: Repaying technical debt through refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite its negative repercussions, incurring technical debt is often inevitable.
    In those cases, you must ensure that the decision is an informed and conscious
    one, and remember to repay the debt as soon as possible. So how do we actually
    pay back the debt? We do this through *refactoring—*or making our code *cleaner* *without **changing
    the existing behavior*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whilst there are no formal definitions on what **clean** means, here are some
    signs of clean code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Well-structured**: Code should consist of modules, separated by domains'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Well-documented**: For example, include unit tests, inline comments, automatically
    generated documentation, and `README` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Succinct**: Be concise, but not to the point of obfuscation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Well-formatted and readable**: Other developers must be able to review and
    work on the same code base, so it should be easy to understand and not deviate
    too far from well-established conventions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you gain more experience, you'll be able to detect code that deviates from
    these signs. In programming, we call these deviations **code smells**. Code smells
    are weaknesses within the code that violate well-established design principles,
    paradigms, and patterns. While they are not bugs themselves, they may slow down
    development and make the code base more prone to errors later.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, refactoring is simply a process that moves the current code base
    from having a lot of code smells to one that is cleaner. As we have mentioned
    before, there is more than one way to achieve the same results, and developers
    need to be creative and figure out the best solutions to problems that arise.
  prefs: []
  type: TYPE_NORMAL
- en: The important point here is that developers should be given time to refactor;
    in other words, refactoring should be the core part of a development process,
    and be included in the time estimates that the developers provide.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prevention is better than cure. Instead of incurring technical debt, how about
    avoiding it in the first place? Here, we outline some easy tactics that you can
    adopt to prevent technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Informing the decision makers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most decision makers, especially those without a technical background, greatly
    underestimate the effects of technical debt. Furthermore, in their view, developers
    do not understand the business costs of repaying technical debt in terms of manpower,
    salaries, and time.
  prefs: []
  type: TYPE_NORMAL
- en: That's why it is important for a professional developer to understand the situation
    from the decision maker's perspective and the constraints that they must work
    within. One of the most relevant models is the **triple constraint** model.
  prefs: []
  type: TYPE_NORMAL
- en: The triple constraint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classic project management triangle (also known as triple constraint or
    the *iron triangle*) coined the popular saying Time, Quality, Cost. Pick two.
    The triangle is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5a6e054-9385-4486-ae31-aaf41da945f3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The triple constraint is a model used in project management to visualize the
    constraints on any projects, and to consider how optimizing the project for one
    area would cause another area to suffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time and Quality**: You can design and build a high-quality platform in a
    short time, but you''ll need to hire a lot of experienced developers, which will
    be expensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time and Cost**: You can build a platform quickly with a few inexperienced
    developers, but the quality will be low.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality and Cost**: You can tell a few inexperienced developers to design
    and plan a platform properly. It''ll be of good quality, but it''s going to take
    a long time because they''ll need time to learn the principles and apply them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most businesses are limited largely by their time and cost: by time, because
    for each day the product is not launched, the greater the chance their competitor
    delivers a similar product and captures the **first-mover advantage** (**FMA**);
    by cost, because the company still has to pay their staff salaries while the product
    is not generating any revenue.'
  prefs: []
  type: TYPE_NORMAL
- en: To exacerbate the problem, many managers and business owners are focused more
    on tangible, immediate results, rather than long-term rewards. For these reasons,
    when given the choice, most decision-makers pick time and cost over quality.
  prefs: []
  type: TYPE_NORMAL
- en: The fallacy of the triple constraint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fallacy here is that by neglecting quality and incurring debt, they'll eventually
    be increasing both the time and cost requirements many times over.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is the duty of the developer to inform the product manager and
    business owner of the unpredictable effects of incurring technical debt to give
    them all of the advice they need to make an informed decision. You may want to
    turn the tables and approach it from a positive perspective—cleaning up technical
    debt would allow future development of new features to be completed more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Do this to prevent the worst-case scenario where the effort required to fix
    the code is greater than rewriting everything from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Refuse to develop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the code base is so bad that it's close to FUBAR (a variation on the military
    slang that stands for 'Fucked Up Beyond Any Repair'), then a more drastic approach
    may be to refuse further development until refactoring is done. This may seem
    extreme, given that the people you're disobeying are paying your salary. While
    this is an easy way to forgo responsibility, it's not what a professional developer
    should do.
  prefs: []
  type: TYPE_NORMAL
- en: 'To paraphrase an analogy from *The Clean Code* by Robert C. Martin: Let''s
    suppose you are a doctor and a patient asks you to perform open heart surgery
    on him/her in order to relieve a sore throat, what would you do? Of course, you''d
    refuse! Patients do not know what are best for them, that''s why they must rely
    on your professional opinion.'
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, most business owners do not know what is best for them technically,
    which is why they hired you to make the best possible technical decisions for
    their business. They pay you not simply to code; they pay you because they want
    you to bring value to the business. As a professional, you should think about
    whether your actions are beneficial or detrimental to the business, in both the
    short and long term.
  prefs: []
  type: TYPE_NORMAL
- en: Business owners also need to trust the advice of their developers. If they do
    not respect their professional opinion, they shouldn't hire them in the first
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be a hero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, it's not always the business owner's fault for making unreasonable
    demands; the developer who commits to those demands is equally at fault.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, it is the business owner's, or your manager's, role to get as much
    out of you as possible. But more importantly, it is your duty to inform them of
    what is and isn't possible; so, when asked to complete features under a deadline
    that you cannot meet without sacrificing on quality, *do not accept the deadline*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may think the business would appreciate you for going the extra mile and
    making the impossible possible, but there are four problems with this line of
    thinking:'
  prefs: []
  type: TYPE_NORMAL
- en: You may not actually complete the feature in time, while the business has planned
    a strategy that depends on that deadline being met.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've demonstrated to the manager that you're willing to accept these deadlines,
    so they may set even tighter deadlines next time, even if they don't need to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rushing through code will likely incur technical debt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your fellow developers may resent you, since they may have to work overtime
    in order to keep up with your pace; otherwise, their manager may view them as
    slow. It also means they'll have to develop on top of your rushed code, making
    everyday work less enjoyable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's a time to stick your head out to save a business, but by doing it too
    often, you are actually hurting the team. The danger is that neither you nor the
    business owner will realize this; in fact, you may even naïvely celebrate the
    rapid progress being made.
  prefs: []
  type: TYPE_NORMAL
- en: The solution here is to manage your business owner's expectations. If you believe
    there's a 50% chance of meeting an optimistic deadline, then ask for the scope
    to be reduced further until you can be more confident in your estimate. Speaking
    from experience, business owners would rather hear *it's not possible* a month
    in advance than a promise of *everything will be done* that was not delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Defining processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This brings me back to the topic of defining and documenting processes. Good
    code starts with good planning, design, and management, and is maintained by good
    processes. Many of the problems outlined previously can be mitigated if there
    are clear guidelines outlining the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Situations where incurring technical debt is appropriate, for example, to meet
    a legal requirement such as GDPR compliance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasions when developers can expect to receive time to repay these debts, for
    example, before the next feature is started, or two weeks at the end of each quarter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distribution of work on greenfield/brownfield projects within the team,
    for example, with a rotation system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Definition of Done** – a list of criteria which must be met before a feature
    is considered "done", for example, code passes all tests and is peer-reviewed,
    and documentation is updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software development paradigms such as *Agile* and **Waterfall**, as well as
    their implementations such as *Scrum* and **Kanban**, provide different ways to
    define and enforce these processes. For example, in Scrum, development happens
    in short iterations (typically one and four weeks) called **sprints**. At the
    beginning of each sprint, a meeting is held to review pending tasks and select
    features to be tackled in this sprint. At the end of each sprint, a **retrospective**
    meeting is held to review the progress of the sprint and identify lessons that
    can be learned and applied to subsequent sprints.
  prefs: []
  type: TYPE_NORMAL
- en: Although these paradigms and methodologies are popular in software development,
    they are not coupled to any technical processes at all. Instead, they deal with the
    entire development process, including gathering requirements and specifications,
    communicating with the client, design, development, and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, of more relevance to developers are development techniques, which specify *how* a
    developer should develop a feature. The most prominent technique is TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test-Driven Development is a development practice created by Kent Beck, it requires
    the developer to write tests for a feature before that feature is implemented.
    This provides some immediate benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to validate that your code works as intended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It avoids errors in your test suite, if you write your test first, then run
    it, and it does *not* fail, that's a prompt for you to check your test again.
    It might just be that you have inadvertently implemented this feature by chance,
    but it could also be an error in your test code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since existing features would be covered by existing tests, it allows a test
    runner to notify you when a previously functional piece of code is broken by the
    new code (in other words, to detecting **regressions**). This is especially important
    for developers when they inherit old code bases they are not familiar with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's examine the principles of TDD, outline its process, and see how we
    can incorporate it into our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: There are different flavors of TDD, such as **Acceptance Test-Driven Development** (**ATDD**),
    where the test cases mirror the acceptance criteria set by the business. Another
    flavor is **Behavior-Driven Development** (**BDD**), where the test cases are
    expressed in natural language (that is, the test cases are human readable).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the TDD process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TDD consists of a rapid repetition of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the smallest functional unit of your feature that has not yet been
    implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify a test case and write a test for it. You may want to have test cases
    that cover the **happy path**, which is the default scenario that produces no
    errors or exceptions, as well as **unhappy paths**, including dealing with **edge
    cases**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test and see it fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the minimum amount of code to make it pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if we want to build a math utility library, then our first iteration
    of the TDD cycle may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using the [`assert`](https://nodejs.org/api/assert.html) module
    from Node, as well as the `describe` and `it` syntax provided by the Mocha testing
    framework. We will clarify their syntax in detail in [Chapter 5](275da6be-376e-45cf-87a5-8032b4526f41.xhtml), *Writing
    End-to-End Tests*. In the meantime, you may simply treat the following test code
    as pseudocode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pick a feature**: For this example, let''s pick the `sum` function, which
    simply adds numbers together.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Define a test case**: When running the `sum` function with `15` and `19` as
    the arguments, it should return `34`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Run the test**: It fails because we haven''t written the `sum` function yet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write the code****:** Write the `sum` function that will allow us to pass
    the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Refactor**: No refactoring needed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This completes one cycle of the TDD process. In the next cycle, we will work
    on the same function, but define additional test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pick a feature**: we''ll continue developing the same `sum` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Define a test case**: this time, we will test it by supplying three arguments, `56`,
    `32` and `17`, we expect to receive the result `105`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Run the test**: it fails because our current `sum` function only takes into
    account the first two parameters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code: update the `sum` function to take into account the first three
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Refactor**: improve the function by making it work for any number of function
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that calling with just two arguments would still work, and so the original
    behavior is not altered.
  prefs: []
  type: TYPE_NORMAL
- en: Once a sufficient number of test cases have been completed, we can then move
    on to the next function, such as `multiply`.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By following TDD, the number of bugs should reduce drastically; however, no
    process can guarantee error-free code. There will always be edge cases that were
    overlooked. Previously, we outlined the TDD process for implementing a new feature;
    now, let's look at how can we can apply the same process to fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, when a bug is encountered, it is treated the same way as a new feature—you'd
    first write a (failing) test to reproduce the bug, and then update the code until
    the test passes. Having the bug documented as a test case ensures the bug stays
    fixed in the future, preventing regression.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you first learn to code, no one ever starts with writing tests. This means
    that for many developers, having tests in the code is an afterthought—a luxury
    if time permits. But what they don't realize is that *everyone tests their code*,
    consciously or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: After you've written a function, how do you know it works? You may open the
    browser console and run the function with some dummy test parameters, and if the
    output matches your expectations, then you may assume it's working. But what you're
    doing here is actually **manually testing** a function that has already been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of manual testing is that it requires no upfront costs—you just
    run the function and see if it works. However, the downside is that it cannot
    be automated, eating up more time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding manual tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead, you should formally define these manual tests as code, in the form
    of **unit**, **integration** and **end-to-end** (**E2E**) tests, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Formally defining tests has a higher initial cost, but the benefit is that the
    tests can now be automated. As we will cover in [Chapter 5](275da6be-376e-45cf-87a5-8032b4526f41.xhtml), *Writing
    End-to-End Tests*, once a test is defined as code, we can use **npm scripts**
    to run it automatically every time the code changes, making the cost to run the
    tests in the future virtually zero.
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that you'll need to test your code anyways; it's just a choice
    of whether you invest time to automate it now, saving time in the future, or save
    the time now but waste more time repeating each test manually in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mike Cohn developed the concept of the **Testing Pyramid**, which shows that
    an application should have a lot of unit tests (as they are fast and cheap to
    run), fewer integration tests, and even fewer UI tests, which take the most amount
    of time and are the most expensive to define and run. Needless to say, manual
    testing should only be done after unit, integration, and UI tests have been thoroughly
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7598434-8760-4847-8bfb-eb52ee182114.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tests as specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whilst avoiding manual testing is a benefit of TDD, it certainly is not the
    only one. A developer can still write their unit, integration and E2E tests after
    implementation of the feature. So what are the benefits of writing tests before
    implementation?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that it forces you to think about your requirements and break
    them down into atomic units. You can then write each test case around a specific
    requirement. The end result is that the test cases form the specification for
    your feature. Writing tests first helps you structure your code around the requirements,
    rather than retrofitting requirements around your code.
  prefs: []
  type: TYPE_NORMAL
- en: This also helps you to abide by the **You Aren't Gonna Need It** (**YAGNI**)
    principle, which prevents you from implementing features that aren't actually
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: '"Always implement things when you *actually* need them, never when you just
    *foresee* that you need them."'
  prefs: []
  type: TYPE_NORMAL
- en: – Ron Jeffries, co-founder of Extreme Programming (XP)
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, writing the tests (and thus the specifications) forces you to think
    about the interface that consumers of your function would have to use to interact
    with your function—should everything be defined as properties inside a generic
    `options` object, or should it be a plain list of arguments?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tests as documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developers want to use a tool or library, they learn by reading the documentation
    or guides that contain code samples they can try, or by following tutorials to
    build a basic application.
  prefs: []
  type: TYPE_NORMAL
- en: Test cases can essentially act as code samples and form part of the documentation.
    In fact, tests are the most comprehensive set of code samples there are, covering
    every use case that the application cares about.
  prefs: []
  type: TYPE_NORMAL
- en: Although tests provide the best form of documentation, tests alone are not enough.
    Test cases do not provide context for the code, such as how it fits into the overall
    business goals, or convey the rationale behind its implementation. Therefore,
    tests should be supplemented by inline comments and automatically-generated, as
    well as manually-written, documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Short development cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because TDD focuses on a single functional block at a time, its development
    cycles are usually very short (minutes to hours). This means small, incremental
    changes can be made and released rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: When TDD is implemented within the framework of a software development methodology
    such as Scrum, small development cycles allow the methodology practitioner to
    capture fine-grained metrics on the progress of the team.
  prefs: []
  type: TYPE_NORMAL
- en: Difficulties with TDD adoption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While TDD is the gold standard amongst development techniques, there are many
    obstacles preventing its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inexperienced team**: TDD only works when the whole development team adopts
    it. Many junior developers, especially self-taught developers, never learned to
    write tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The good news is that TDD is not hard; given a day or so, a developer can realistically
    learn about the different types of tests, including how to spy on functions and
    mock data. It's wise to invest time training a developer so that he/she can write
    more reliable code for the entire duration of his/her employment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Slower initial development speed**: TDD requires the product owner to create
    a specification document and for the developers to write the tests before any
    functional code is written. This means the end product will likely take more time
    to complete. This goes back to a recurring theme in this chapter: pay the price
    now, or pay the interest later. If you''ve been reading everything so far, it''ll
    be obvious the first option is the better one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legacy code**: Many legacy code bases do not have tests, or the tests are
    incomplete; worse still, there may be insufficient documentation to understand
    what each function is designed to do. We can write tests to verify functionality
    that we know, but we cannot be certain that it''ll cover all cases. This is a
    tricky one because TDD means you write your tests first; if you already have all
    the code, then it can''t be TDD. If the code base is large, you may continue to
    fix bugs (documenting them as unit tests as you do so) while starting on a rewrite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slow tests**: TDD is only practical when the tests can be run quickly (within
    a few seconds). If the test suite takes a few minutes to run, then developers
    would not receive quick enough feedback for those tests to be useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest way to mitigate this issue is by breaking the code into smaller
    modules and running tests on them individually. However, some tests, such as large
    integration and UI tests, are inevitably slow. In these cases, you can run them
    only when the code is committed and pushed, probably by integrating them into
    a Continuous Integration (CI) system, which is something we will cover in [Chapter
    8](38b85b06-d091-4751-a2ac-32ca0f98f26b.xhtml), *Writing Unit/Integration* *Tests*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When not to use TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although I encourage you to incorporate TDD into your workflow, I should add
    a disclaimer that it is *not a silver bullet*. TDD does not magically make your
    code performant or modular; it's just one technique that forces you to design
    your system better, making it more testable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, TDD induces a high initial cost, so there are a few cases where
    this investment is not advisable:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, when the project is a **Proof-of-Concept** (**PoC**). This is where
    the business and developers are only concerned with whether the idea is possible,
    not about its implementation. Once the concept is proven to be possible, the business
    may then agree to approve additional resources for the proper development of this
    feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, when the product owner has not defined clear requirements (or does
    not want to), or the requirements change every day. This is more common than you
    think, since many early startups are constantly pivoting to find the right market
    fit. Needless to say, this is a bad situation for the developer, but if you do
    find yourself in this situation, then writing tests would be a waste of time,
    as they may become obsolete as soon as the requirements change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at technical debt, its causes, consequences, and
    ways to prevent it. Then, we introduced TDD as a process to avoid technical debt;
    we outlined its benefits, and how to implement it in your workflow. In [Chapter
    5](275da6be-376e-45cf-87a5-8032b4526f41.xhtml), *Writing End-to-End Tests* and
    [Chapter 6](6a407d81-cb0e-4ada-9849-693cba3fabd5.xhtml), *Storing Data in Elasticsearch*,
    we will cover in more depth the different types of tests (unit, integration, and
    E2E / acceptance tests).
  prefs: []
  type: TYPE_NORMAL
- en: Good code, whatever its definition, takes less time to write than bad code in
    the long run. It would be wise to realize this fact and have the discipline to
    build a strong foundation from the get-go. You can build a house on weak foundations,
    and it may stand for a hundred years, but build a skyscraper on a weak foundation,
    it'll come tumbling down quicker than you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: '"Always code as if the guy who ends up maintaining your code will be a violent
    psychopath who knows where you live."'
  prefs: []
  type: TYPE_NORMAL
- en: – John F. Woods
  prefs: []
  type: TYPE_NORMAL
