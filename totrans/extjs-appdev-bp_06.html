<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Practical &#x2013; Monitoring Dashboard"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Practical – Monitoring Dashboard</h1></div></div></div><p>Now that we've started applying the things we've learned to a real-world application, we're going to gradually ramp up the complexity of the projects we build. By designing and creating a code base that imitates something an actual customer might pay money for, we're not coding abstract examples that exist in isolation. We're building something that showcases some of the design decisions you will likely face as a software architect.</p><p>In this chapter, we'll build a <a id="id225" class="indexterm"/>monitoring dashboard that can be used to view metrics from an application server. Developers and system administrators will use applications like this to visualize the performance of their servers and monitor load at any given time.</p><p>Such an application could be used for internal monitoring, or it could be deployed as a <span class="strong"><strong>Software as a Service</strong></span> (<span class="strong"><strong>SaaS</strong></span>) that<a id="id226" class="indexterm"/> could be resold to other users. Either way, it will serve as a great demonstration of the power of view models; we'll be expanding what we already know and will be using it in a more advanced way to shape the data we receive from the server. In this chapter, we'll cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing the user interface</li><li class="listitem" style="list-style-type: disc">Designing our data layer from the <code class="literal">Ext.data.Model</code> through to the view models needed to support our UI</li><li class="listitem" style="list-style-type: disc">Using multiple view controllers</li><li class="listitem" style="list-style-type: disc">Building components that are reused across views</li><li class="listitem" style="list-style-type: disc">Adding routing to allow users to bookmark each screen of the application</li><li class="listitem" style="list-style-type: disc">Using view model filters to focus our view of the underlying data</li></ul></div><p>By the end of the chapter, we'll have fleshed out the concepts we've already begun to cover and introduced some new features (such as routing). These are important when designing the user experience for an application.</p><p>We're going to approach this as if we're designing an internal program, one that monitors another application in our theoretical software development shop. Although this means we're not bound by external <a id="id227" class="indexterm"/>customer requirements, it's still important that we follow all of the design guidelines we've already learned. This maybe an internal application, but it's still got to be robust, meet the expectations of stakeholders, and be maintained in the future.</p><div class="section" title="Application design"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Application design</h1></div></div></div><p>This <a id="id228" class="indexterm"/>application will have several screens to view the various properties of the app being monitored. We'll have a dashboard screen that shows<a id="id229" class="indexterm"/> an overview of the important metrics being monitored. Then, for each of these metrics, we'll have individual screens that allow the user to drill down and filter the data. As each of these screens will be variations on a common theme, we'll only build-out a couple to demonstrate the concepts, but the framework we'll build with this application means it would be trivial to add more. The <span class="strong"><strong>Dashboard</strong></span> tab<a id="id230" class="indexterm"/> can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/5308OT_06_01.jpg" alt="Application design"/></div><p>The <span class="strong"><strong>Web</strong></span> tab<a id="id231" class="indexterm"/> is as follows:</p><div class="mediaobject"><img src="graphics/5308OT_06_02.jpg" alt="Application design"/></div><p>As users, what<a id="id232" class="indexterm"/> do we want to see in this monitoring application? We want information at a glance, but with the ability to easily get detailed information. Our primary concerns are the response times of web requests and queries to the database, so we want both these metrics available to us. Let's think about the user interface that supplies this information and what it might look like:</p><div class="mediaobject"><img src="graphics/5308OT_06_03.jpg" alt="Application design"/></div><p>On the <a id="id233" class="indexterm"/>
<span class="strong"><strong>Dashboard</strong></span> tab, we're using charts to convey trend information—about both the short-term and the longer term—and this provides our at a glance view of the data. The top two charts update in real time to show the average response time, whereas the bottom charts show historical trends for comparison. How about getting details on this data?</p><p>Also, we've added<a id="id234" class="indexterm"/> tabs on the left-hand side of the screen that allow you to switch between log types. In this application, we've just got <span class="strong"><strong>SQL</strong></span> and <span class="strong"><strong>Web</strong></span> in addition to the initial <span class="strong"><strong>Dashboard</strong></span> view, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5308OT_06_04.jpg" alt="Application design"/></div><p>In the main part of<a id="id235" class="indexterm"/> the screen, we've got a set of controls to filter the data. The chart and grid underneath will update depending on the results of the filter. This gives the user the ability to view data within a particular date range. It also gives the user the ability to pick the category of detail to drill down.</p><p>What<a id="id236" class="indexterm"/> sort of categories? It could be extended in future, but here's our current list for the <span class="strong"><strong>Web</strong></span> tab:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Location</li><li class="listitem" style="list-style-type: disc">Browser</li><li class="listitem" style="list-style-type: disc">Type of device</li></ul></div><p>We're displaying <a id="id237" class="indexterm"/>information on the web requests in our date range to provide more insight on who is visiting our application. Are we getting lots of visitors from Japan? Are they experiencing unacceptably high response times? Maybe we need to add a server somewhere in Asia to meet their requirements. Are we seeing a lot of tablet users? Do we need to improve our responsive design to better cope with a tablet screen size?</p><p>On the SQL front, we've got:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Query type (select, insert, update, and so on)</li><li class="listitem" style="list-style-type: disc">Slowest queries</li><li class="listitem" style="list-style-type: disc">Query sources</li></ul></div><p>The first is<a id="id238" class="indexterm"/> just general information; you could see whether your application was read-heavy or write-heavy here, which would inform how your technology stack changes over time. The other two go hand in hand, showing the slowest queries and which pages in the application issue most queries.</p><p>These metrics are useful to increase transparency in an application. In some cases, they won't be enough to diagnose subtle issues, but they will be invaluable in showing the trends of how your application and users are behaving.</p></div></div>
<div class="section" title="Requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Requirements</h1></div></div></div><p>We've<a id="id239" class="indexterm"/> established the ideal UI for our application, but how <a id="id240" class="indexterm"/>does this translate into technical requirements?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We want line charts to show trends</li><li class="listitem" style="list-style-type: disc">We want these charts to be able to update when they receive new data</li><li class="listitem" style="list-style-type: disc">We want to be able to choose a date range and update charts and grids accordingly</li><li class="listitem" style="list-style-type: disc">We want to be able to choose a data category and have grids update accordingly</li></ul></div><p>Let's look at each of these in the context of Ext JS:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ext JS charts have area, line, scatter series, and so on, so we can plot the data in a way that allows you to visualize a trend.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">load</code> method of <code class="literal">Ext.data.Store</code> can accept an <code class="literal">addRecords</code> parameter, which when set to <code class="literal">true</code> will cause newly loaded records to be appended to the store rather than overwriting the existing data. This will allow us to provide update data to a chart.</li><li class="listitem" style="list-style-type: disc">Ext JS<a id="id241" class="indexterm"/> provides a date field component that can be linked to a view model to filter data based on a date range.</li><li class="listitem" style="list-style-type: disc">Grids<a id="id242" class="indexterm"/> have a reconfigure method that allows you to change the columns of the grid on the fly if necessary.</li></ul></div><p>Looks good!</p><div class="section" title="Message received and understood"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Message received and understood</h2></div></div></div><p>We've set out our own criteria for this project, but we're still being explicit at spelling out what we need before we start coding, and we're making sure that our technical framework will support what we need. Why not just get on with the job and put fingers to keyboards?</p><p>Although this isn't a job that has an explicit paying customer, it's still something that needs accountability. It's not enough as a professional developer to say that it'll be "done when it's done" because this attitude won't wash with the people who pay your salary. We must plan our projects in as much detail as to give us confidence in the delivery of our work—both from a time and quality perspective—as possible.</p><p>No matter who we are building software for, we must always strive to create something robust, something that meets or exceeds expectations.</p></div></div>
<div class="section" title="Data structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Data structure</h1></div></div></div><p>We <a id="id243" class="indexterm"/>will <a id="id244" class="indexterm"/>make an assumption in this chapter, that is, we have a friendly backend developer on our team who's able to provide us data in the format we need. Let's flesh out our requirements for the data that will power our application.</p><p>Another assumption is that we're looking for trends and statistics here, so we're going to be basically aggregating logs into something more suitable for user consumption.</p><div class="section" title="Live charts"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Live charts</h2></div></div></div><p>We planned <a id="id245" class="indexterm"/>to have two "live" charts on the dashboard (one to show SQL queries as they come in, and one to show web requests). In order for this to work, we need a URL we can poll every second or so. This will provide us with data on the last second of activity. Something like this:</p><div class="informalexample"><pre class="programlisting">GET /logStream
Accepts: n/a
Returns: [
    {
        "type":"web",
        "subType":"request",
        "time":"2014-11-04T12:10:14.465Z",
        "ms":10,
        "count":5
    },
    {
        "type":"sql",
        "subType":"query",
        "time":"2014-11-04T12:10:14.466Z",
        "ms":17,
           "count":34
    }
]</pre></div><p>A <code class="literal">GET</code> request to <code class="literal">/logs/all/live</code> gives us an array of objects, one for each log type. As mentioned, we're restricting ourselves to SQL and the Web only. The <code class="literal">ms</code> property is the average response time of the operations that occurred in the past second. The <code class="literal">count</code> property is the number of operations that took place. We designed the API with a little bit of flexibility in mind, so it could be extended, for example, replace <code class="literal">"all"</code> in the URL with <code class="literal">"sql"</code> to filter on one log type.</p></div><div class="section" title="Historical logs"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Historical logs</h2></div></div></div><p>On the <a id="id246" class="indexterm"/>dashboard and the subpages of our application, we also need to show graphs of historical data. On the dashboard, it'll be from the past 30 days, but on the subpages, it could be an arbitrary time frame. Here's our API:</p><div class="informalexample"><pre class="programlisting">GET /logEntry
Accepts: filter=[{"property":"propertyName","operator":"=","value":"value"}, …]
Returns: [{
    "type":"sql",
    "subType":"query",
    "time":"2014-11-04T12:10:14.466Z",
    "ms":17,
    "count":34
}, ...]</pre></div><p>We're going<a id="id247" class="indexterm"/> to rely on a feature of <code class="literal">Ext.data.Store: remoteFilter</code>. When this is set to <code class="literal">true</code>, Ext JS will defer filtering to the server and pass through the filter criteria as a JSON array. We can set an arbitrary number of filters, so in order to get SQL data within a date range, we'd be passing something like this:</p><div class="informalexample"><pre class="programlisting">[
    { property: 'type', operator: '=', value: 'sql' },
    { property: 'time', operator: '&lt;=', value: '2014-01-01' },
    { property: 'time', operator: '&gt;=', value: '2014-02-01' }
]</pre></div><p>Our kind server-side developer will combine these filters into something that returns the correct response.</p></div><div class="section" title="Log statistics"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Log statistics</h2></div></div></div><p>As well as<a id="id248" class="indexterm"/> general aggregated information about Web and SQL operations, we also want to display a grid of further detail on our tab pages. Again, these will be filterable based on the date range as well as the category of information we want to view:</p><div class="informalexample"><pre class="programlisting">GET /statistic
Accepts:
filter=[
    { property: 'type', operator: '=', value: 'web' },
    { property: 'category', operator: '=', value: 'location' },
    { property: 'time', operator: '&lt;=', value: '2014-01-01' },
    { property: 'time', operator: '&gt;=', value: '2014-02-01' }
]
Returns: [{"category":"location","label":"Other","percentage":19.9}, ...]</pre></div><p>We're using the <code class="literal">remoteFilter</code> feature again, meaning that Ext JS just passes the JSON filter straight through to the server as well as the <code class="literal">type</code> and <code class="literal">time</code> parameter from before. This time, we will add a <code class="literal">category</code> parameter to specify what subset of information—such as location for web logs or query source for SQL—we'd like to retrieve.</p><p>In response, we <a id="id249" class="indexterm"/>get an array of all of the items within the chosen category and the percentages allocated to each one over the specified time frame.</p></div><div class="section" title="Model behavior"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Model behavior</h2></div></div></div><p>We've <a id="id250" class="indexterm"/>got our API. How does this translate into the JavaScript data models we'll need? Well, we only need two—look at the API responses we just documented—the <code class="literal">/logs</code> returns one type and <code class="literal">/statistics</code> returns another type. They'll look something like this:</p><div class="informalexample"><pre class="programlisting">Instrumatics.model.LogEntry: extends Instrumatics.model.BaseModel
- type
- subType
- time
- ms
- count</pre></div><p>What's this <code class="literal">BaseModel</code> all about? In order to share schema configuration between models, we can use a base model from which all other models inherit. It looks like this:</p><div class="informalexample"><pre class="programlisting">Instrumatics.model.BaseModel: extends Ext.data.Model
- schema</pre></div><p>Now, the model for statistics is as follows:</p><div class="informalexample"><pre class="programlisting">Instrumatics.model.Statistic: extends Instrumatics.model.BaseModel
- category
- label
- percentage</pre></div><p>The <code class="literal">percentage</code> field represents the proportion of operations that are represented by this statistic. For example, if <code class="literal">category</code> is <code class="literal">location</code> and <code class="literal">label</code> is <code class="literal">Japan</code>, then the percentage could be something like <code class="literal">5 percent</code> (5 percent of our requests come from Japan). This is flexible enough to be used for all the data categories we'd like to view.</p><p>Finally, we need one for the live log stream:</p><div class="informalexample"><pre class="programlisting">Instrumatics.model.LogStream: extends Instrumatics.model.LogEntry</pre></div><p>The log stream has the same fields as the <code class="literal">LogEntry</code> model, but we have it as a separate class, so its class name can affect the schema configuration. We'll go into more detail later.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>We're lucky with this theoretical API; in this, we are allowed to shape our requirements. In the real world, it might not be that simple, but having a friendly backend developer will always make our lives as frontend developers much easier.</p></div></div><p>Our API <a id="id251" class="indexterm"/>has strongly informed our data layer. While it's great to keep things simple—as we've been able to here—it's important not to mistake simplicity for naivety or inflexibility. In this case, our UI components will happily work with our data layer, which in turn works with our API without having to shoehorn any one piece into working with the others.</p></div></div>
<div class="section" title="The view from the top"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>The view from the top</h1></div></div></div><p>We have the<a id="id252" class="indexterm"/> fuel for our application; the data will bring life to the coding engine we're about to build. We now need to establish <a id="id253" class="indexterm"/>controllers that will constitute this engine and views that will give us a user interface to control and visualize it. Consider the following screenshot:</p><div class="mediaobject"><img src="graphics/5308OT_06_05.jpg" alt="The view from the top"/></div><p>For the outer <a id="id254" class="indexterm"/>area marked as <span class="strong"><strong>1</strong></span>, we have a main view <a id="id255" class="indexterm"/>that provides a container for other views. This will have a corresponding view controller that will manage any cross-application concerns from the main's subcomponents.</p><p>For the inner section marked as <span class="strong"><strong>2</strong></span>, we have the dashboard view, a container for four charts. Its view controller will manage the live updates of the top two charts.</p><p>Each subpage will add an additional view (see <span class="strong"><strong>3</strong></span>), for example, a <span class="strong"><strong>Web</strong></span> view and an associated view controller. It will present and control the historical log chart, the statistics grid, and user input<a id="id256" class="indexterm"/> to the filtering date fields and button, as<a id="id257" class="indexterm"/> shown here:</p><div class="mediaobject"><img src="graphics/5308OT_06_06.jpg" alt="The view from the top"/></div><p>Here's how all our classes interact:</p><div class="mediaobject"><img src="graphics/5308OT_06_07.jpg" alt="The view from the top"/></div><p>We've got the <a id="id258" class="indexterm"/>general picture of our application classes. Let's drill down and look at the details of each class in turn:</p><div class="informalexample"><pre class="programlisting">Instrumatics.view.main.Main: extends Ext.tab.Panel
- items[]
    - dashboard: extends Ext.panel.Panel
    - web: extends Instrumatics.view.web.Web
    - sql: extends Instrumatics.view.sql.Sql
</pre></div><p>The main <a id="id259" class="indexterm"/>view is a tab panel that contains all subpages:</p><div class="informalexample"><pre class="programlisting">Instrumatics.view.main.MainController: extends
Ext.app.ViewController
- onTabChange
- onNavigate</pre></div><p>As we mentioned, the main controller deals with things that concern the whole application. It's responsible for swapping between the dashboard and subpages <code class="literal">onTabChange</code> and decides what action to take if the URL changes <code class="literal">onNavigate</code>. Four instances of <code class="literal">Ext.chart.CartesianChart</code> to display the various line charts that we need on the dashboard, as shown here:</p><div class="informalexample"><pre class="programlisting">Instrumatics.view.dashboard.Dashboard: extends Ext.panel.Panel
- items[]
- live-sql-requests: extends Ext.chart.CartesianChart
- live-web-requests: extends Ext.chart.CartesianChart
- historical-sql-requests: extends Ext.chart.CartesianChart
- historical-web-requests: extends Ext.chart.CartesianChart</pre></div><p>We need some code to set up our live-updating charts, so we do this in <code class="literal">initializeChartRefresh</code>:</p><div class="informalexample"><pre class="programlisting">Instrumatics.view.dashboard.DashboardController: extends
Ext.app.ViewController
- initializeChartRefresh</pre></div><p>The <code class="literal">Ext.app.ViewModel</code> is as follows:</p><div class="informalexample"><pre class="programlisting">Instrumatics.view.dashboard.DashboardModel: extends Ext.app.ViewModel
- store.webLogs
- store.sqlLogs
- store.historicalWebLogs
- store.historicalSqlLogs</pre></div><p>The <a id="id260" class="indexterm"/>view <a id="id261" class="indexterm"/>model for the dashboard sets out four separate sources of data, one for each of the charts:</p><div class="informalexample"><pre class="programlisting">Instrumatics.view.web.Web: extends Ext.panel.Panel
- filters: extends Ext.Container
- historical-web-requests: extends Ext.chart.CartesianChart
- statistics-grid: extends Ext.grid.Panel</pre></div><p>The associated view controller is as follows:</p><div class="informalexample"><pre class="programlisting">Instrumatics.view.web.WebController: extends Ext.app.ViewController</pre></div><p>Ah! This is a pretty sparse view controller for a view, which is actually doing quite a lot. Let's look at the view model and things might become a bit clearer:</p><div class="informalexample"><pre class="programlisting">Instrumatics.view.web.WebModel: extends Ext.app.ViewModel
- stores
    - logData
    - logStatistics
    - categories
- data
    - currentCategory
    - currentStartDate
    - currentEndDate</pre></div><p>The plan is to pull the historical log data and the statistics about this log data from a couple of stores. We'll have another that holds the categories that the user can use to filter the grid view.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>It's arguable that the categories could be held in the part of the user interface that filters the data in a completely separate store. However, it also makes sense to hold the data for a view in one place—the view model—and not over complicate things by adding another unnecessary store class.</p></div></div><p>The <a id="id262" class="indexterm"/>key part <a id="id263" class="indexterm"/>of this view model comes when we think about the current state of the application. For this subpage, it'll be stored in the <code class="literal">currentCategory</code>, <code class="literal">currentStartDate</code>, and <code class="literal">currentEndDate</code> variables.</p><p>As we're keeping all of the state in the view model, we can bind to the UI controls that set this state and in turn bind these values to a <code class="literal">store</code> filter. This means that changing the value using the UI will automatically change the filter value without requiring any glue code in the controller.</p><p>This implementation requires a strong understanding of the power of view models and a thoughtful eye for the design of the application. We'll go into detail on this later when we write the code for this section.</p><p>The last part of the application is the SQL subpage. This is essentially the same as the web subpage, but displaying a different set of information, so we won't go into detail about its design.</p></div>
<div class="section" title="Flexibility and pragmatism"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Flexibility and pragmatism</h1></div></div></div><p>Something<a id="id264" class="indexterm"/> that we're yet to discuss in detail is how a design can change over time. We're setting out our thoughts on what we think our application should look like, but until we write it, we won't know all of the ins-and-outs of the exact implementation.</p><p>It's important <a id="id265" class="indexterm"/>to undertake a constant re-evaluation of the work that's taking place to ensure that the quality of what's being written remains high. We've documented our design earlier, but in one key place, we've also had the realization that subpages will be very similar to each other.</p><p>Depending on how these similarities are fleshed out in code, there could be scope for refactoring and reusing in a way that isn't immediately clear when drawing up the design document. However, if the implementation does turn out to be sufficiently similar with only minor variations between each subpage, then we need to look at extracting this code into a reusable class.</p><p>Code <a id="id266" class="indexterm"/>duplication—and even worse, copying and pasting code—is a very good way of ending up with a messy code base. In the event you need to change something, tweak behavior, add a feature, or fix a bug, you'll have to do the same thing in several places, increasing the overhead of the change and increasing the chance that more mistakes will creep into your code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Copy and pasting is a blight on your code base. By blindly duplicating code, your developers are not applying any critical analysis. They are increasing the size of your code base unnecessarily and could well be introducing bugs.</p></div></div><p>Later <a id="id267" class="indexterm"/>in this chapter, we'll begin building out the code for this application. We'll also keep a close eye out for anything that looks like it might be duplicating what went before. In these cases, we'll take some time out to see whether there's functionality we can encapsulate and reuse.</p><p>Ext JS provides multiple methods to structure code—such as inheritance and mixins—and taking advantage of these methods will result in an application that is much easier to maintain and extend.</p></div>
<div class="section" title="Does this hurt?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Does this hurt?</h1></div></div></div><p>We've got our design in place, from top to bottom, so now it's time to cast a critical eye over it. Are there any unknown aspects of the design or are there any potential pain points? The live-updating chart is a little bit of a black box right now. While we know that charts support animation (via the <code class="literal">animate</code>
<span class="strong"><strong> configuration </strong></span>option), we want to be certain that the axis on the chart can update as the new data comes in. It's worth doing a very simple test<a id="id268" class="indexterm"/> to make certain this'll work. To do this, we're going to go a little bit retro.</p><p>Rather than using Sencha Cmd and the whole Bootstrap process, we're going to link directly to the files we need and use <code class="literal">Ext.onReady</code> to run our code. Here's the empty template:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE HTML&gt;
&lt;html manifest=""&gt;
&lt;head&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Chart Test&lt;/title&gt;
 &lt;script type="text/javascript" src="ext/build/ext-all-debug.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="ext/packages/sencha-charts/build/sencha-charts-debug.js"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" type="text/css" href="ext/packages/ext-theme-neptune/build/resources/ext-theme-neptune-all-debug.css"&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div id="chart"&gt;&lt;/div&gt;

   &lt;script type="text/javascript"&gt;
   Ext.onReady(function() {
         // Code goes here.
   });
   &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>We've <a id="id269" class="indexterm"/>created an HTML page that links to the JS files for Ext JS and Sencha Charts as well as the CSS for one of the Ext JS Themes. In the body of the HTML, we will create a div with an ID of "chart" to render into and then an <code class="literal">Ext.onReady</code> block where we'll place the bulk of our code. First, let's set up a store in here:</p><div class="informalexample"><pre class="programlisting">var store = Ext.create('Ext.data.Store', {
   fields: [
          { name: 'value' },
          { name: 'time', type: 'date' }
   ]
});</pre></div><p>Variables for the current time "from" and "to" times for the chart axis is shown here:</p><div class="informalexample"><pre class="programlisting">var now = new Date();
      fromDate = Ext.Date.subtract(now, Ext.Date.MINUTE, 1),
      toDate = Ext.Date.add(now, Ext.Date.MINUTE, 5);</pre></div><p>And then the chart itself:</p><div class="informalexample"><pre class="programlisting">var chart = Ext.create('Ext.chart.Chart', {
    renderTo: 'chart',
    width: 500, height: 300,
    animate: true, store: store,
    axes: [
        { type: 'numeric', position: 'left', fields: 'value' }, 
        {
            type: 'time', fields: 'time', dateFormat: 'H:i:s',
            fromDate: fromDate.setSeconds(0),
            toDate: toDate.setSeconds(0)
        }
    ],
    series: [{ type: 'line', xField: 'time', yField: 'value' }]
});</pre></div><p>Now, let's add some data to the store:</p><div class="informalexample"><pre class="programlisting">setInterval(function() {
    store.add({
        time: (new Date()).toISOString(),
        value: Ext.Number.randomInt(1, 30)
    });
}, 1000);</pre></div><p>Every <a id="id270" class="indexterm"/>second, we add a new record to the store with the current time and a random value. After running this code, we get a line chart that updates every second, fantastic! However, while this is pretty close to what we need, there is a problem. As the line approaches the right-hand side of the chart, it just disappears off the canvas. We need to somehow update the bottom axis of the chart when we update its data.</p><p>The chart has a <code class="literal">redraw</code> event that we can use for just this purpose. What we'll try to do is move the <code class="literal">from</code> date and the <code class="literal">to</code> date located at the bottom axis forward by <code class="literal">15</code> seconds. As the <code class="literal">redraw</code> event will be triggered every second, thanks to our store updating via the <code class="literal">setInterval</code> call, every fifteenth time the <code class="literal">redraw</code> event is fired, we update the axes. This is how it looks in code:</p><div class="informalexample"><pre class="programlisting">var redrawCounter = 0;

chart.on('redraw', function() {
    redrawCounter++;

    if(redrawCounter &gt; 15) {
        redrawCounter = 0;

        var timeAxis = this.getAxes()[1],
            oldFrom = new Date(timeAxis.getFromDate()),
            oldTo = new Date(timeAxis.getToDate()),
            newFrom = Ext.Date.add(oldFrom, Ext.Date.SECOND, 15),
            newTo = Ext.Date.add(oldTo, Ext.Date.SECOND, 15);

        timeAxis.setFromDate(newFrom);
        timeAxis.setToDate(newTo);
    }
});</pre></div><p>We use a <a id="id271" class="indexterm"/>variable called <code class="literal">redrawCounter</code> to keep track of how many times the redraw event has fired since our last axis adjustment. The rest of the code should be fairly straightforward. Grab the bottom and set its dates 15 seconds ahead.</p><p>This was all fairly painless, although there were some unexpected hurdles in having to hook into the <code class="literal">redraw</code> event. Now that we've assured ourselves that this particular issue can be solved, we can move on to building the rest of the application.</p></div>
<div class="section" title="Onwards and upwards"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Onwards and upwards</h1></div></div></div><p>As with<a id="id272" class="indexterm"/> all of our example applications, we'll use Sencha Cmd and build an application template as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha generate app -ext Instrumatics ./instrumatics</strong></span>
</pre></div><p>Remove all of the cruft and example files that the generator creates and use the <code class="literal">watch</code> command to fire up a web server. We can then proceed to create the first real code for our application: the data layer.</p></div>
<div class="section" title="Data first"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Data first</h1></div></div></div><p>All<a id="id273" class="indexterm"/> our models will inherit from a base model, which will be used to <a id="id274" class="indexterm"/>specify the following command:</p><div class="informalexample"><pre class="programlisting">// app/model/BaseModel.js
Ext.define('Instrumatics.model.BaseModel', {
    extend: 'Ext.data.Model',

    schema: {
        namespace: 'Instrumatics.model',
        urlPrefix: 'http://localhost:3000',
        proxy: {
            type: 'ajax',
            url: '{prefix}/{entityName:uncapitalize}'
        }
    },
});</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>We've assumed that we have an API server running at localhost on port <code class="literal">3000</code> and supplied this information as the URL prefix.</p></div></div><p>We used <a id="id275" class="indexterm"/>the <code class="literal">schema</code> configuration in the last chapter, but now that we're about to use it with multiple models, it really comes into its own. In each of the models that inherit from <code class="literal">BaseModel</code>, the model's name will be inserting into the proxy URL in place of the <code class="literal">entityName</code> token. This avoids duplicating the URL configuration across multiple models. We can now create our <code class="literal">LogEntry</code> model as per our design:</p><div class="informalexample"><pre class="programlisting">// app/model/LogEntry.js
Ext.define('Instrumatics.model.LogEntry', {
    extend: 'Instrumatics.model.BaseModel',

    fields: [
        { name: 'value' },
        { name: 'subType' },
        { name: 'type' },
        { name: 'time', type: 'date' }
    ]    
});</pre></div><p>Via the schema, this will result in the following URL:</p><div class="informalexample"><pre class="programlisting">http://localhost:3000/logEntry</pre></div><p>Other than this, we're just implementing the fields, we specified in the design, on to the <code class="literal">LogStream</code> class:</p><div class="informalexample"><pre class="programlisting">// app/model/LogStream.js
Ext.define('Instrumatics.model.LogStream', {
    extend: 'Instrumatics.model.LogEntry',
});</pre></div><p>This was simple. The <code class="literal">LogStream</code> class inherits all of the fields from the <code class="literal">LogEntry</code> class, but thanks to the use of the schema configuration in the <code class="literal">BaseClass</code>, <code class="literal">LogStream</code> will have a URL like this:</p><div class="informalexample"><pre class="programlisting">http://localhost:3000/logStream</pre></div><p>Finally, here's the <code class="literal">Statistics</code> model:</p><div class="informalexample"><pre class="programlisting">// app/model/Statistic.js
Ext.define('Instrumatics.model.Statistic', {
    extend: 'Instrumatics.model.BaseModel',
    fields: [
        { name: 'category' },
        { name: 'label' },
        { name: 'percentage', type: 'number' }
    ]
});</pre></div><p>Just the<a id="id276" class="indexterm"/> three fields from the design here and it gives us a model that produces this URL:</p><div class="informalexample"><pre class="programlisting">http://localhost:3000/statistic</pre></div><p>Nothing in our data layer is particularly taxing, as we thought through the implementation during our design phase. By having an awareness of the features Ext JS provides before sitting down to write code, we were able to reduce code duplication by having the proxy configuration in a base class.</p><p>We should always look for places, either via refactoring or through the initial design, where we can reduce duplicated code. In this example, we could have had the same functionality by setting the proxy configuration on each of <code class="literal">LogEntry</code>, <code class="literal">LogStream</code>, and <code class="literal">Statistic</code>, but in the event where we want to change some part of the config, such as the hostname of the API, we'd have to change it in multiple locations. By centralizing in the way that we have, we will have less code to maintain and it's easier to work with.</p><p>One thing to note in the model classes earlier is the way we define the fields. There are two options in Ext JS, one option is to pass a field definition as an object literal as we have in our code, and the second option is to pass a string containing the field name. To use the <code class="literal">Statistic</code> class as an example, the field config will look like this:</p><div class="informalexample"><pre class="programlisting">'category',
'label',
{ name: 'percentage', type: 'number' }</pre></div><p>Why choose one over the other? The answer is for consistency. This is a perfect example of something that could go in the programming style guide for your team, so rather than having one class declared using one method and a second class using another method, we have a unified approach. No alarms and no surprises for a new developer who opens up your model files and finds the field definitions well organized.</p><p>There is a third approach for field definitions; not bothering with them. Ext JS allows you to leave out the field definitions and will create them on the fly based on the data the model is consuming.</p><p>We're all <a id="id277" class="indexterm"/>for reducing the amount of code to maintain, but sometimes, it's better to be explicit. If we needed to use one of the other configuration options in a field, such as convert, then we'd have to manually define that field anyway, and so on, and then be left with some fields explicit in the model and some created on the fly.</p><p>This is a matter of preference, but for our purposes, we'll always define the full field definitions. It's consistent and self-documenting; we're always aware of the fields it's consuming when looking at a model file.</p></div>
<div class="section" title="Storing the data"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Storing the data</h1></div></div></div><p>The <a id="id278" class="indexterm"/>stores in this project are as simple as it can be:</p><div class="informalexample"><pre class="programlisting">// app/store/LogEntries.js
Ext.define('Instrumatics.store.LogEntries', {
    extend: 'Ext.data.Store',
    alias: 'store.logentries',
    model: 'Instrumatics.model.LogEntry',
    autoLoad: true,
    remoteFilter: true
});

// app/store/LogStream.js
Ext.define('Instrumatics.store.LogStream', {
    extend: 'Ext.data.Store',
    alias: 'store.logstream',
    model: 'Instrumatics.model.LogStream',
    autoLoad: true,
    remoteFilter: true
});

// app/model/Statistics.js
Ext.define('Instrumatics.store.Statistics', {
    extend: 'Ext.data.Store',
    alias: 'store.statistics',
    model: 'Instrumatics.model.Statistic'
});</pre></div><p>These <a id="id279" class="indexterm"/>classes are fairly boilerplate (define the model, define the alias, and that's it). There's an argument to be heard that these stores could actually be defined on individual view models, reducing the number of files in our code base. However, in this application, we'll reuse the stores in multiple view models, so it makes sense to keep their configuration in a centralized location.</p><p>Let's move on to the UI layer of our application.</p></div>
<div class="section" title="With a view to a controller"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>With a view to a controller</h1></div></div></div><p>In this application, we have a "main" view, which acts as the application's viewport, and an associated controller, which<a id="id280" class="indexterm"/> deals with user interactions with this viewport and handles routing. Let's look at the UI portion first: <code class="literal">view</code>:</p><div class="informalexample"><pre class="programlisting">// app/view/main/Main.js
Ext.define('Instrumatics.view.main.Main', {
    extend: 'Ext.tab.Panel',

    requires: [
        'Instrumatics.view.dashboard.Dashboard',
        'Instrumatics.view.web.Web',
        'Instrumatics.view.web.Sql',
    ],

    xtype: 'app-main',
    controller: 'main-main',

    header: {
        title: {
            text: 'Instrumatics', padding: 20
        }
    },

    tabPosition: 'left',
    tabRotation: 0,

    items: [
        { xtype: 'dashboard', title: 'Dashboard', reference: 'dash' },
        { xtype: 'web-logs', title: 'Web', reference: 'web' },
        { xtype: 'sql-logs', title: 'SQL', reference: 'sql' }
    ]
});</pre></div><p>There are a <a id="id281" class="indexterm"/>few interesting bits in this code. We use the <code class="literal">header</code> config option to give us fine control over the panel's header, allowing us to add some formatting to the title.</p><p>We then change the default configuration of the panel's tabs to put them on the left-hand side of the screen (as opposed to the top of the screen). As tabs on the left-hand side default to displaying from top to bottom, we adjust <code class="literal">tabRotation</code> too, making them read from left to right. The tab selected by default is automatically the first component in the items array, so we can avoid setting any configuration to stipulate this.</p><p>Then, we set out the items that will be included in this tab panel, just the dashboard, the web logs subpage, and the SQL logs subpage, as dictated in our design. The only interesting part of this configuration is the addition of <code class="literal">reference</code> for each component and its utility will become clear when we look at the view controller.</p></div>
<div class="section" title="The main view controller"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>The main view controller</h1></div></div></div><p>There<a id="id282" class="indexterm"/> isn't a lot of code in this view controller, but the<a id="id283" class="indexterm"/> functionality it enables is very important. Let's take a look:</p><div class="informalexample"><pre class="programlisting">// app/view/main/MainController.js
Ext.define('Instrumatics.view.main.MainController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.main-main',
    
    routes: {
        ':controller': 'onNavigate'
    },

    listen: {
        component: {
            'tabpanel': {
                tabchange: 'onTabChange'
            }
        }
    },

    onTabChange: function(tab, newCmp, oldCmp) {
        this.redirectTo(newCmp.getReference());
    },

    onNavigate: function(controller) {
        var view = this.getView();

        view.setActiveTab(view.lookupReference(controller));
    }
});</pre></div><p>Not<a id="id284" class="indexterm"/> much code, to be sure, but a lot going on. This is the part of the application that deals with routing, so let's take a bit of time out to discuss what routing actually is.</p><div class="section" title="Rootin-Tootin"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>Rootin-Tootin</h2></div></div></div><p>There's a pretty comprehensive description of routing<a id="id285" class="indexterm"/> in the Ext JS Guides, but let's cover it in brief here anyway. Routing allows you to keep the application's state in the page URL via the URL's hash (the hash is everything after the <code class="literal">#</code> symbol in a URL). For example:</p><div class="informalexample"><pre class="programlisting">http://localhost/#banana</pre></div><p>This shows us we're on a page about bananas. Likewise, look at the following example:</p><div class="informalexample"><pre class="programlisting">http://localhost/#cars/56</pre></div><p>This shows that we're on a page about car number <code class="literal">56</code>. The beauty of using the hash is that it can be manipulated with JavaScript without reloading the page. Also, any change made to the hash symbol will be remembered by the browser's history. This means that we can navigate around our application and use the back button to retrace our steps. It also means that if we can bookmark a specific page in the application when it reloads the app, it will navigate to the state specified in the hash symbol.</p></div><div class="section" title="Back to business"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>Back to business</h2></div></div></div><p>How do <a id="id286" class="indexterm"/>we implement routes in the <code class="literal">Instrumatics</code> app? The first step is to actually define a route as follows:</p><div class="informalexample"><pre class="programlisting">routes: { ':viewReference: 'onNavigate' }</pre></div><p>The first part is the hash we're trying to match. Nothing's been specified apart from <code class="literal">:viewReference</code>, so in this case, everything in the hash symbol gets captured and passed on to a method called <code class="literal">onNavigate</code>. The name of the <code class="literal">:viewReference</code> token is arbitrary, in this it doesn't affect anything else, but in more complex routes, it's useful to name it in a descriptive way.</p><p>What are we trying to achieve here? When the hash symbol changes, we want to detect it and redirect the user to the correct page. The route definition does the detection part, so now let's look at how we move the user to the right page:</p><div class="informalexample"><pre class="programlisting">onNavigate: function(viewReference) {
    var view = this.getView();
    view.setActiveTab(view.lookupReference(viewReference));
}</pre></div><p>The route definition means that all matching routes will be consumed by <code class="literal">onNavigate</code>. In this method, we can assume that the token passed in is a valid reference to a component on the view controller's view, so we just lookup the component using this reference and set it as the active tab on the "main" view.</p><p>We're missing something though, that is, how does the hash get set in the first place?</p></div><div class="section" title="Route to nowhere"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>Route to nowhere</h2></div></div></div><p>In the listen <a id="id287" class="indexterm"/>configuration for the view controller, we handle the "main" tab panel's <code class="literal">tabchange</code> event with the <code class="literal">onTabChange</code> method. This grabs the reference config from the tab the user is changing to and passes it to the view controller's <code class="literal">redirectTo</code> method:</p><div class="informalexample"><pre class="programlisting">onTabChange: function(tab, newCmp, oldCmp) {
    this.redirectTo(newCmp.getReference());
}</pre></div><p>The <code class="literal">redirectTo</code> method<a id="id288" class="indexterm"/> simply changes the hash in the URL, in this case, to the reference of the new component. It's a simple approach that gives us a powerful way to improve the user experience.</p></div></div>
<div class="section" title="The dashboard"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>The dashboard</h1></div></div></div><p>We<a id="id289" class="indexterm"/> have the application infrastructure in place, so it's time to build out the components that are going to rest on this infrastructure. First up is the dashboard, something that requires us to carefully consider how to implement the rest of our application.</p><p>The dashboard consists of two live charts and two historical charts. The live charts are very similar to each other, as are the historical charts (just some minor formatting and binding configuration between them). However, in order to build a chart, you also have to build the axes and the series being drawn on it, which results in a fairly long-winded configuration object. Here's what the historical log chart from the dashboard will look like:</p><div class="informalexample"><pre class="programlisting">{ 
    xtype: 'cartesian',
    title: 'Last 30 Days',
    margin: 10, flex: 1
    bind: '{historicalWebLogs}'
    axes: [{
        type: 'numeric',
        position: 'left',
        fields: ['value'],
        title: {
            text: 'Avg. Response \nTime (ms)',
            fontSize: 15
        },
        grid: true,
        minimum: 0,
        maximum: 20
    }, {
        type: 'time',
        fields: 'time',
        dateFormat: 'd M'
    }],
    series: {
        type: 'line',
        xField: 'time',
        yField: 'value',
        style: { 'stroke': 'red' }
    }
}</pre></div><p>Excellent! We have configured a chart with a line series that has a numeric left axis and a time-base bottom axis. This is exactly what we need for the dashboard, so where's the problem?</p><p>Duplication<a id="id290" class="indexterm"/> is the problem. The majority of this configuration object would be duplicated, one copy for the web logs and one copy for the SQL logs. We've mentioned before in this chapter that we'd like to battle duplication where possible, so in this case, we will create a new class that we can reuse in places where we need a chart to plot historical requests from the logs.</p><p>Here's the class:</p><div class="informalexample"><pre class="programlisting">// app/ux/chart/HistoricalRequestChart.js
Ext.define('Instrumatics.ux.chart.HistoricalRequestChart', {
    extend: 'Ext.chart.CartesianChart',
    xtype: 'historical-request-chart',
    frame: true,
    axes: [{
        type: 'numeric',
        position: 'left',
        fields: ['value'],
        title: {
            text: 'Avg. Response \nTime (ms)',
            fontSize: 15
        },
        grid: true,
        minimum: 0,
        maximum: 20
    }, {
        type: 'time',
        position: 'bottom',
        fields: ['time'],
        dateFormat: 'd M'
        style: {
            axisLine: false
        }
    }],

    series: {
        type: 'line',
        xField: 'time',
        yField: 'value',
        style: { 'stroke': 'red' }
    }
});</pre></div><p>It combines<a id="id291" class="indexterm"/> the basic definition of the chart, such as the axes and series, with things we know we'll reuse across the application, such as the title on the left axis.</p><p>Note that we're putting this class in a different location from anything we've seen so far in our example applications, but one that we discussed in <a class="link" href="ch03.html" title="Chapter 3. Application Structure">Chapter 3</a>, <span class="emphasis"><em>Application Structure</em></span>. The <code class="literal">ux</code> namespace and corresponding directory is a fairly standard location for reusable classes in the Ext JS community, so we will follow this convention here.</p><p>We will create another reusable class, this time for the live request chart:</p><div class="informalexample"><pre class="programlisting">// app/ux/chart/LiveRequestChart.js
Ext.define('Instrumatics.ux.chart.LiveRequestChart', {
    extend: 'Ext.chart.CartesianChart',
    xtype: 'live-request-chart',
    redrawCounter: 0,
    frame: true,
    axes: [{
        type: 'numeric',
        position: 'left',
        fields: ['value'],
        title: {
            text: 'Avg. Response \nTime (ms)',
            fontSize: 15
        },
        grid: true,
        minimum: 0,
        maximum: 20
    }, {
        type: 'time',
        position: 'bottom',
        step: [Ext.Date.SECOND, 1],
        fields: ['time'],
        dateFormat: 'H:i:s',
        fromDate: new Date(new Date().setMinutes( new Date().getMinutes() - 1)).setSeconds(0),
        toDate: new Date(new Date().setMinutes( new Date().getMinutes() + 5)).setSeconds(0)
    }],
    series: {
        type: 'line',
        xField: 'time',
        yField: 'value',
        style: {
            'stroke-width': 2
        }
    },


    constructor: function() {
        this.callParent(arguments);

        this.on('redraw', this.onRedraw, this);
    },


    onRedraw: function() {
        this.redrawCounter++;

        if(this.redrawCounter &gt; 15) {
            this.redrawCounter = 0;

            var timeAxis = this.getAxes()[1],
                oldFrom = new Date(timeAxis.getFromDate()),
                oldTo = new Date(timeAxis.getToDate()),
                newFrom = Ext.Date.add(oldFrom, Ext.Date.SECOND, 15),
                newTo = Ext.Date.add(oldTo, Ext.Date.SECOND, 15);

            timeAxis.setFromDate(newFrom);
            timeAxis.setToDate(newTo);
        }
    }
});</pre></div><p>You'll <a id="id292" class="indexterm"/>notice that this code has a lot in common with the code from our code investigation earlier in the chapter. It's just that we've wrapped it up into a reusable class.</p><p>With these new classes ready to go, creating the dashboard is just a matter of piecing together what we've already written, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// app/view/dashboard/Dashboard.js
Ext.define("Instrumatics.view.dashboard.Dashboard", {
    extend: "Ext.panel.Panel",
    xtype: 'app-dashboard',
    title: 'hello',
    requires: [
        'Instrumatics.ux.chart.LiveRequestChart',
        'Instrumatics.ux.chart.HistoricalRequestChart'
    ],
    viewModel: {
        type: 'dashboard-dashboard'
    },
    controller: 'dashboard-dashboard',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    items: [
        {
            xtype: 'container',
            flex: 1,
            layout: {
                type: 'hbox',
                align: 'stretch'
            },
            items: [
                {
                    xtype: 'live-request-chart',
                    title: 'Live Web Requests', bind: '{webLogs}',
                    series: { style: { 'stroke': 'red' } },
                    margin: '10 5 0 10', flex: 1
                },
                {
                    xtype: 'live-request-chart',
                    title: 'Live SQL Requests', bind: '{sqlLogs}',
                    series: { style: { 'stroke': 'green' } },
                    margin: '10 10 0 5', flex: 1
                }
            ]
        },
        {
            xtype: 'container',
            flex: 1,
            layout: {
                type: 'hbox',
                align: 'stretch'
            },
            items: [
                {
                    xtype: 'historical-request-chart',
                    title: 'Last 30 Days', bind: '{historicalWebLogs}',
                    series: { style: { 'stroke': 'red' } },
                    margin: '10 5 10 10', flex: 1
                },
                {
                    xtype: 'historical-request-chart',
                    title: 'Last 30 Days', bind: '{historicalSqlLogs}',
                    series: { style: { 'stroke': 'green' } },
                    margin: '10 10 10 5', flex: 1
                }
            ]
        }

    ]
});</pre></div><p>Rather<a id="id293" class="indexterm"/> than duplication of the configuration that forms the charts, we'll just put together the containers—which use the <code class="literal">vbox</code> and <code class="literal">hbox</code> layouts—and set up titles, formatting, and bindings.</p><p>This is great. Rather than duplicating code and having lots of unnecessary configuration in the dashboard view itself, we've moved this code to a more logical location, promoting reuse and making for a tidier code base.</p><div class="section" title="Constant evaluation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Constant evaluation</h2></div></div></div><p>At this <a id="id294" class="indexterm"/>point, let's look at what we've built in comparison with our design. It matches our implementation so far, but there wasn't any mention of these reusable classes. There are two ways of looking at this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We didn't go far enough in our design and missed an opportunity to spell out exactly what we needed to build</li><li class="listitem" style="list-style-type: disc">We saw an opportunity to refactor our code after we found ourselves duplicating something we'd already written</li></ul></div><p>There's <a id="id295" class="indexterm"/>something to be said for both these viewpoints; however, in <a class="link" href="ch05.html" title="Chapter 5. Practical – a CMS Application">Chapter 5</a>, <span class="emphasis"><em>Practical – a CMS Application</em></span>, we discussed YAGNI—you aren't going to need it—which dictates that there's little point in planning for reuse if the component in question is never going to be reused.</p><p>In this case, the implementation process revealed that we'd have some duplication, so we refactored. While taking careful consideration at the design stage is important, re-evaluating our decisions and code should be an ongoing process, so it's critical to realize that even if there's a feeling that something should have been noticed in the design phase, nothing is set in stone. We can always change things as long as we understand why they need to change and use it as a learning experience.</p></div></div>
<div class="section" title="The dashboard view model"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>The dashboard view model</h1></div></div></div><p>Each of the<a id="id296" class="indexterm"/> four charts in the dashboard<a id="id297" class="indexterm"/> has its own data source and these are specified in the bind configuration for each. The definitions for these sources are in the dashboard view model:</p><div class="informalexample"><pre class="programlisting">// app/view/dashboard/DashboardModel.js
Ext.define('Instrumatics.view.dashboard.DashboardModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.dashboard-dashboard',
    
    stores: {
        webLogs: {
            type: 'logstream',
            filters: [{
                property: 'type',
                value: 'web'
            }]
        },

        sqlLogs: {
            type: 'logstream',
            filters: [{
                property: 'type',
                value: 'sql'
            }]
        },

        historicalWebLogs: {
            type: 'logentries',
            filters: [{
                property: 'type', 
                value: 'web'
            }]
        },

        historicalSqlLogs: {
            type: 'logentries',
            filters: [{
                property: 'type',
                value: 'sql'
            }]
        }
    }
});</pre></div><p>We're setting up<a id="id298" class="indexterm"/> the data sources for the dashboard. If you look back at the associated store definitions, you'll see matching aliases and<a id="id299" class="indexterm"/> also the <code class="literal">remoteFilter</code> option set to <code class="literal">true</code>. This enables us to set the filter on the store definition in the view model and have these passed through to the server as JSON.</p><p>This makes for a very simple method to set up stores to retrieve filtered data from the server side (just pass over an array of filters and let the backend take care of it).</p><p>We've put together nearly all the pieces of the dashboard with one exception: the view controller. Let's look at this now.</p></div>
<div class="section" title="The dashboard view controller"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>The dashboard view controller</h1></div></div></div><p>There<a id="id300" class="indexterm"/> isn't any interactivity on the dashboard, so<a id="id301" class="indexterm"/> there's not much for the view controller to do. We'll use it to control the live refresh aspect of the charts:</p><div class="informalexample"><pre class="programlisting">// app/view/dashboard/DashboardController.js
Ext.define('Instrumatics.view.dashboard.DashboardController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.dashboard-dashboard',
    
    init: function() {
        var data = this.getViewModel().getData(),
            me = this;

        setInterval(function() {
            data.webLogs.load({ addRecords: true });
            data.sqlLogs.load({ addRecords: true });
        }, 1000);
    }
});</pre></div><p>It's as simple <a id="id302" class="indexterm"/>as this; every second, grab the store powering the live chart and call its load method with the <code class="literal">addRecords</code> option set to <code class="literal">true</code>. This will cause new records to be appended to the store rather than overwriting old records.</p><p>While<a id="id303" class="indexterm"/> there's not much code here, there are a couple of discussion points. We could have avoided using a view controller at all for the dashboard and baked this refresh behavior directly in the <code class="literal">LiveRequestChart</code> class, maybe setting the refresh rate via a configuration option.</p><p>By doing it in the controller, we get the chance to centralize the place in which the refresh rate is set. This isn't a massive win though. There's definitely a case to be made for moving this into the UI class. It's another situation where there's no right or wrong way of doing things; multiple options are available and it's better to pick one and move on than be paralyzed with the choices on offer.</p><p>We've got the first page of our application, so let's now move on to the subpages, starting with the web logs.</p></div>
<div class="section" title="Web logs subpage"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Web logs subpage</h1></div></div></div><p>We've <a id="id304" class="indexterm"/>already built part of this screen already. We can reuse <code class="literal">Instrumatics.ux.chart.HistoricalRequestChart</code> we created earlier to display the <a id="id305" class="indexterm"/>trend for a specified date range. As this data's coming from the store, we can simply filter the store and don't have to do anything on the component itself. With this in mind, the <span class="strong"><strong>Web</strong></span> view <a id="id306" class="indexterm"/>looks <a id="id307" class="indexterm"/>like this:</p><div class="informalexample"><pre class="programlisting">// app/view/web/Web.js
Ext.define('Instrumatics.view.web.Web',{
    extend: 'Ext.panel.Panel',
    xtype: 'web-logs',

    viewModel: {
        type: 'web-web'
    },

    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    items: [
        {
            header: {
                title: 'Web Requests',
                items: [
                    { xtype: 'datefield', fieldLabel: 'From', labelAlign: 'right', bind: '{currentStartDate}' },
                    { xtype: 'datefield', fieldLabel: 'To', labelAlign: 'right', bind: '{currentEndDate}', labelWidth: 30 },
                    { xtype: 'button', text: 'Refresh', margin: '0 0 0 10' }
                ]
            },
            margin: 10, xtype: 'historical-request-chart', bind: '{logData}', flex: 1
        },
        {
            xtype: 'grid',
            margin: 10,
            hideHeaders: true,
            viewConfig: {
              trackOver: false
            },
            disableSelection: true,
            header: {
                title: 'Breakdown',
                items: [
                    {
                        xtype: 'combo',
                        labelAlign: 'right', labelWidth: 60,
                        fieldLabel: 'Category',
                        bind: {
                            store: '{categories}',
                            value: '{currentCategory}'
                        },
                        queryMode: 'local',
                        editable: false,
                        forceSelection: true,
                        displayField: 'text',
                        valueField: 'value'
                    }
                ]
            },
            bind: '{logStatistics}',
            flex: 1,
            width: '100%',
            columns: [
                { name: 'Label', dataIndex: 'label', flex: 1 },
                { name: 'Percentage', dataIndex: 'percentage', flex: 1 }
            ]
        }
    ]
});</pre></div><p>It's a fair amount <a id="id308" class="indexterm"/>of code, but nothing other than component configuration is happening here. Let's break it down step-by-step.</p><p>Firstly, there's the<a id="id309" class="indexterm"/> configuration of the panel itself where we set up a <code class="literal">vbox</code> layout.</p><p>Then we add our first item, an instance of the <code class="literal">HistoricalRequestChart</code> we built earlier, and add <code class="literal">To</code> and <code class="literal">From</code> date fields to its header. The values of these are bound to values (<code class="literal">currentStartDate</code> and <code class="literal">currentEndDate</code>) in the view model, and the chart itself is bound to <code class="literal">logData</code> in the view model.</p><p>Finally, we have the configuration of the statistics grid. Its store is bound to <code class="literal">logStatistics</code> and in its header, we add a combo box that has its value bound to <code class="literal">currentCategory</code> in the view model and its store—to provide the combo box options—bound to categories. The combo box allows the user to choose which statistics category they'd like to view.</p><p>Onwards<a id="id310" class="indexterm"/> and <a id="id311" class="indexterm"/>upwards to the view model!</p></div>
<div class="section" title="A view on the Web"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>A view on the Web</h1></div></div></div><p>Our <a id="id312" class="indexterm"/>Web view model follows our design and fleshes it <a id="id313" class="indexterm"/>out with some implementation details:</p><div class="informalexample"><pre class="programlisting">// app/view/web/WebModel.js
Ext.define('Instrumatics.view.web.WebModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.web-web',
    stores: {
        logData: {
            type: 'logentries',
            filters: [
                { property: 'startDate', value: '{currentStartDate}' },
                { property: 'endDate', value: '{currentEndDate}' }
            ]
        },

        logStatistics: {
            type: 'statistics',
            filters: [
                { property: 'category', value: '{currentCategory}' },
                { property: 'startDate', value: '{currentStartDate}' },
                { property: 'endDate', value: '{currentEndDate}' }
            ]
        },


        categories: {
            fields: ['text', 'value'],
            data: [{
                text: 'Browser', value: 'browser'
            },{
                text: 'Location', value: 'location'
            },{
                text: 'Device Type', value: 'device'
            }]
        }
    },


    data: {
        currentCategory: '',
        currentStartDate: null,
        currentEndDate: null
    }
});</pre></div><p>Note the<a id="id314" class="indexterm"/> bindings on the filters. This enables <a id="id315" class="indexterm"/>us to link the filters with a value on the view model, which in turn links through to values on the form controls in the view. This means that as soon as the user updates a form control, it'll update the filter on the store automatically, reloading the store, and redrawing the chart and grid.</p><p>We've also got a <code class="literal">categories</code> store, which is simply a way of holding data for the categories combo, nothing more.</p></div>
<div class="section" title="Controlling the Web"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Controlling the Web</h1></div></div></div><p>Well here's <a id="id316" class="indexterm"/>a thing, this view has no corresponding view controller! In previous versions of Ext JS, we'd be listening for change events on the date fields and combo box, then grabbing the changed value and reloading the store with it.</p><p>In the brave new world of view models though, we don't need to do this. When a date field updates, it automatically updates the corresponding view model value, which in turn updates the store's filter.</p><p>We're already setting up the stores and the form components, so by adding an extra sprinkle of magic in the form of bind configurations, Ext JS will power all of this for us. This means less custom code for us to write, which can only be a good thing!</p></div>
<div class="section" title="More and more subpages"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec65"/>More and more subpages</h1></div></div></div><p>We know<a id="id317" class="indexterm"/> that the other subpage in our application, the SQL log page, is going to be very similar to the web log page. This should be raising an eyebrow with regard to code duplication. We could pull out the grid and the chart header from the <span class="strong"><strong>Web</strong></span> view into separate classes and turn them into reusable components, but is this the right thing to do? These components won't be reused! They have their place in only one location in the application to power the subpages. Unlike <code class="literal">HistoricalRequestChart</code>, which is used in both the dashboard and the subpages, these are only needed for one job.</p><p>Let's consider another approach: <span class="emphasis"><em>subclassing</em></span>. We could create a new component that contains the chart, form fields, and grid from the<a id="id318" class="indexterm"/> <span class="strong"><strong>Web</strong></span> view, and add some configuration options that give us the customization we need. This might look like the following command:</p><div class="informalexample"><pre class="programlisting">// app/view/SubPage.js
Ext.define('Instrumatics.view.SubPage',{
    extend: 'Ext.Container',

    requires: [
        'Instrumatics.ux.chart.HistoricalRequestChart'
    ],

    xtype: 'subpage',

    config: {

        layout: {
            type: 'vbox',
            align: 'stretch'
        },

        chartCfg: {
            header: {
                items: [
                    { xtype: 'datefield', fieldLabel: 'From', labelAlign: 'right', bind: '{currentStartDate}' },
                    { xtype: 'datefield', fieldLabel: 'To', labelAlign: 'right', bind: '{currentEndDate}', labelWidth: 30 },
                    { xtype: 'button', text: 'Refresh', margin: '0 0 0 10' }
                ]
            },
            margin: 10, xtype: 'historical-request-chart', bind: '{logData}', flex: 1
        },

        gridCfg: {
            xtype: 'grid',
            margin: 10,
            hideHeaders: true,
            viewConfig: {
              trackOver: false
            },
            disableSelection: true,
            header: {
                title: 'Breakdown',
                items: [
                    {
                        xtype: 'combo',
                        labelAlign: 'right', labelWidth: 60,
                        fieldLabel: 'Category',
                        bind: {
                            store: '{categories}',
                            value: '{currentCategory}'
                        },
                        queryMode: 'local',
                        editable: false,
                        forceSelection: true,
                        displayField: 'text',
                        valueField: 'value'
                    }
                ]
            },
            bind: '{logStatistics}',
            flex: 1,
            width: '100%',
            columns: [
                { name: 'Label', dataIndex: 'label', flex: 1 },
                { name: 'Percentage', dataIndex: 'percentage', flex: 1 }
            ]
        }
    },

    initComponent: function(arguments) {
        this.callParent(arguments);
        this.add(this.getChartCfg());
        this.add(this.getGridCfg());
    }
});</pre></div><p>We've pulled<a id="id319" class="indexterm"/> the entire configuration from the <span class="strong"><strong>Web</strong></span> view <a id="id320" class="indexterm"/>into this base class called <code class="literal">SubPage</code> and separated out the key components, namely, the chart and the grid. We're also harnessing the power of the Ext JS class system by wrapping these in the config section, which not only generates get and set methods for <code class="literal">gridCfg</code> and <code class="literal">chartCfg</code>, but also provides us with a shortcut to override parts of these config objects. Let's demonstrate by showing the <span class="strong"><strong>SQL</strong></span> view, which is powered by our new <code class="literal">SubPage</code> class:</p><div class="informalexample"><pre class="programlisting">// app/view/sql/Sql.js
Ext.define("Instrumatics.view.sql.Sql",{
    extend: "Instrumatics.view.SubPage",
    xtype: 'sql-logs',
    viewModel: {
        type: "sql-sql"
    },
    chartCfg: {
        title: 'SQL Requests'
    }
});</pre></div><p>Yep, that's it! We've managed to get the same functionality that the <span class="strong"><strong>Web</strong></span> view had, but reusing lots of the code. Note that <code class="literal">chartCfg</code> is exposed for us to configure, which means that all we have to do is set <code class="literal">viewModel</code> and the chart's title configuration and we're all set.</p><p>Turns out we can do the same for the view model too:</p><div class="informalexample"><pre class="programlisting">    // app/view/SubPageModel.js
Ext.define('Instrumatics.view.SubPageModel', {
    extend: 'Ext.app.ViewModel',
    stores: {
        logData: {
            type: 'logentries',
            autoLoad: true,
            remoteFilter: true,
            filters: [
                { property: 'startDate', value: '{currentStartDate}' },
                { property: 'endDate', value: '{currentEndDate}' }
            ]
        },

        logStatistics: {
            type: 'statistics',
            autoLoad: true,
            remoteFilter: true,
            filters: [
                { property: 'category', value: '{currentCategory}' },
                { property: 'startDate', value: '{currentStartDate}' },
                { property: 'endDate', value: '{currentEndDate}' }
            ]
        }
    },


    data: {
        currentStartDate: null,
        currentEndDate: null
    }
});</pre></div><p>And the <a id="id321" class="indexterm"/>following<a id="id322" class="indexterm"/> SQL view model:</p><div class="informalexample"><pre class="programlisting">Ext.define('Instrumatics.view.sql.SqlModel', {
    extend: 'Instrumatics.view.SubPageModel',
    alias: 'viewmodel.sql-sql',

    stores: {
        categories: {
            fields: ['text', 'value'],
            data: [{
                text: 'Query Source', value: 'source'
            },{
                text: 'Query Type', value: 'type'
            }]
        }
    },

    data: {
        currentCategory: 'source'
    }
});</pre></div><p>The <span class="strong"><strong>Web</strong></span> and <span class="strong"><strong>SQL</strong></span> views now share code in a logical way without polluting our UX namespace with<a id="id323" class="indexterm"/> classes that don't belong there. In future, we<a id="id324" class="indexterm"/> could easily add on more views like this, but for now, we've got a fantastic way to avoid code duplication and keep our application well structured.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec66"/>Summary</h1></div></div></div><p>In this chapter, we've built a second practical application and talked a lot about how a design can change as an application develops. While we produce an initial application architecture with the best of intentions and the knowledge we have hand as the application develops, it's important to be flexible in order to produce a successful final product. We also introduced routing, more on data binding, and showed how code can be reused in a variety of ways.</p><p>In the next chapter, we'll build an application that will be familiar to most readers: an e-mail client. It'll be a responsive app tailored for both desktop and tablet, and we'll once again take the ideas we've already discussed and develop them even further.</p></div></body></html>