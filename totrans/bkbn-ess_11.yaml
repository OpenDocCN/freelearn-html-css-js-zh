- en: Chapter 11. (Not) Re-Inventing the Wheel – Utilizing Third-Party Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。（不）重新发明轮子 – 利用第三方库
- en: 'In this chapter, we''ll take an introductory look at a mix of general-purpose
    and Backbone-specific third-party libraries, all of which can benefit you as a
    Backbone developer. In particular, we''ll look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍通用和 Backbone 特定的第三方库的混合，所有这些库都可以为 Backbone 开发者带来好处。特别是，我们将查看以下内容：
- en: Dependency management tools Require.js and Bower
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖管理工具 Require.js 和 Bower
- en: Table-generation tools Backbone Paginator and BackGrid
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表生成工具 Backbone Paginator 和 BackGrid
- en: HTML templating tool Handlebars
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 模板工具 Handlebars
- en: Task automation tool Grunt
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务自动化工具 Grunt
- en: Alternate language CoffeeScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代语言 CoffeeScript
- en: General-purpose Backbone utility library BackSupport
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用 Backbone 工具库 BackSupport
- en: The Backbone ecosystem
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone 生态系统
- en: In the five years that Backbone has existed, its popularity has resulted in
    the development of hundreds of related third-party libraries. In addition, numerous
    other general-purpose libraries have been released, which can also be of great
    value to a Backbone developer. While we don't have room to explore these libraries
    in depth, this chapter will provide you with a preview of each library so that
    you can identify the ones that would be most beneficial to you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Backbone 存在的五年间，其流行度导致了数百个相关第三方库的开发。此外，还发布了众多其他通用库，这些库对 Backbone 开发者来说也可能非常有价值。虽然我们没有足够的空间深入探讨这些库，但本章将为你提供每个库的预览，以便你可以识别出对你最有益的库。
- en: As we cover the libraries in this chapter, keep in mind that for each library
    that we preview, there exist several (and sometimes several dozen) competing libraries
    that we didn't feature. While we could try to list every available library in
    each category, such a list would quickly become out of date, so instead we've
    chosen to focus only on the most popular offerings. If any of the libraries in
    this chapter strike you as useful, we strongly recommend searching the Internet
    to see what other similar libraries are available, as you may well find one that
    better suits you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，当我们介绍各个库时，请记住，对于每个我们预览的库，都存在几个（有时甚至几十个）我们没有介绍的竞争性库。虽然我们可以尝试列出每个类别中每个可用的库，但这样的列表会很快过时，因此我们选择只关注最受欢迎的库。如果本章中的任何库看起来对你有用，我们强烈建议你在互联网上搜索，看看还有哪些类似的库可供选择，因为你可能会找到一个更适合你的库。
- en: Dependency management with RequireJS
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RequireJS 进行依赖管理
- en: With modern IDEs, it is possible for a developer to open a file by typing just
    a few characters of that file's name. This feature, along with a general desire
    to keep code organized, has motivated developers to separate their code into multiple
    files. In Backbone, this typically means creating one file for every `Collection`,
    `Model`, `View`, and `Router`, and even in a small project, this can add up to
    a lot of files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 IDE 中，开发者只需输入文件名的一两个字符就可以打开文件。这个功能，加上保持代码组织的一般愿望，促使开发者将代码分离成多个文件。在 Backbone
    中，这通常意味着为每个 `Collection`、`Model`、`View` 和 `Router` 创建一个文件，即使在小型项目中，这也可能积累很多文件。
- en: 'All these files create two problems. First, each file needs to be downloaded
    separately, and as we learned in [Chapter 8](part0076.xhtml#aid-28FAO1 "Chapter 8. Scaling
    Up – Ensuring Performance in Complex Applications"), *Scaling Up: Ensuring Performance
    in Complex Applications*, browsers can only download between 2 and 8 files at
    once. Second, the order in which files are loaded can become increasingly hard
    to manage, because of the dependencies among the different files (`View A` needs
    `Collection B`, which needs `Model C`, which needs …). **RequireJS** ([http://requirejs.org/](http://requirejs.org/))
    solves both of these problems.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件都带来了两个问题。首先，每个文件都需要单独下载，正如我们在第8章[《扩展：确保复杂应用程序的性能》](part0076.xhtml#aid-28FAO1
    "第8章。扩展：确保复杂应用程序的性能")中学到的，浏览器一次只能下载2到8个文件。其次，由于不同文件之间的依赖关系（例如，“视图A”需要“集合B”，“集合B”需要“模型C”，依此类推），文件加载的顺序可能会变得越来越难以管理。**RequireJS**
    ([http://requirejs.org/](http://requirejs.org/))解决了这两个问题。
- en: RequireJS does this by organizing your code into `modules`. Each module can
    optionally depend on one or more other modules, and RequireJS will take care of
    stitching the modules together in a way that preserves all of their dependencies.
    RequireJS also provides a related tool, called RequireJS Optimizer, which allows
    you to combine multiple modules into a single file. The optimizer can also "minify"
    your code, as well as "uglify" it, making it harder for others to understand (to
    prevent competitors from reading your source files).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS通过将你的代码组织成`模块`来实现这一点。每个模块可以可选地依赖于一个或多个其他模块，而RequireJS将负责以保留所有依赖关系的方式将这些模块拼接在一起。RequireJS还提供了一个相关的工具，称为RequireJS优化器，它允许你将多个模块合并成一个文件。优化器还可以“压缩”你的代码，以及“混淆”它，使其他人更难理解（以防止竞争对手阅读你的源代码文件）。
- en: 'Here''s an example RequireJS module for a BookList `View` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例RequireJS模块，用于BookList `视图`类：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'RequireJS''s style of managing dependencies is known as the **AMD** style.
    There is also a competing style, known as **Common JS**, which is used by other
    dependency management libraries such as Browserify or Hem. Common JS modules look
    significantly different; here''s our previous example rewritten using Browserify''s
    Common JS syntax:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS管理依赖项的风格被称为**AMD**风格。还有一种竞争风格，称为**Common JS**，它被其他依赖项管理库（如Browserify或Hem）使用。Common
    JS模块看起来显著不同；以下是我们之前示例使用Browserify的Common JS语法的重写：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The downside to this approach is that the actual ordering of the modules isn''t
    handled for you, as it is in RequireJS. Instead, the order of the modules must
    be spelt out separately using `require` statements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，模块的实际顺序并没有为你处理，就像在RequireJS中那样。相反，必须使用`require`语句单独指定模块的顺序：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: External dependency management with Bower
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bower进行外部依赖项管理
- en: 'In addition to using RequireJS or a similar library for managing your code''s
    dependencies, many programmers also use a second tool called **Bower** ([http://bower.io/](http://bower.io/))
    to manage their external library dependencies. Much like Python''s `pip` or Node.js''s
    NPM, Bower offers a simple command line interface for easily installing external
    libraries. It''s worth noting that NPM itself can also be used for managing libraries
    on the client-side, but this tool is designed primarily for server-side developers,
    whereas Bower is designed primarily for use on the client-side. To install a library,
    such as jQuery, one would simply run the following command at the command line:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用RequireJS或类似库来管理代码的依赖项之外，许多程序员还使用另一个名为**Bower** ([http://bower.io/](http://bower.io/))的工具来管理他们的外部库依赖项。和Bower与Python的`pip`或Node.js的NPM类似，Bower提供了一个简单的命令行界面，可以轻松安装外部库。值得注意的是，NPM本身也可以用于管理客户端上的库，但这个工具主要设计用于服务器端开发者，而Bower主要设计用于客户端。要安装一个库，例如jQuery，你只需在命令行中运行以下命令：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Multiple Bower dependencies can be stored in a `bower.json` file, allowing
    you to install all of your application''s dependencies with a single command.
    Here''s an example of what such a file might look like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多个Bower依赖项可以存储在一个`bower.json`文件中，允许你使用单个命令安装应用程序的所有依赖项。以下是一个此类文件可能的样子：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the preceding file defines the dependencies for your project.
    It includes Backbone and jQuery but not Underscore; as a dependency of Backbone,
    Underscore will be downloaded automatically (jQuery isn't technically a dependency
    of Backbone, as the library will work without it, so we have to require it separately).
    It also lets us include Mocha as `devDependency`, which means that it will be
    downloaded in a development environment but not in a production one. Using a requirements
    file like this allows you to keep your external libraries out of your source control
    system and to easily update them when new versions come out. It also allows you
    to easily manage different builds of these libraries (for instance, the debugging
    version versus the minified version).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，前面的文件定义了项目的依赖关系。它包括Backbone和jQuery但不包括Underscore；作为Backbone的依赖项，Underscore将被自动下载（jQuery在技术上不是Backbone的依赖项，因为库在没有它的情况下也能工作，所以我们必须单独要求它）。它还允许我们将Mocha作为`devDependency`包含进来，这意味着它将在开发环境中下载，但不在生产环境中。使用这样的需求文件可以让你将外部库从源代码控制系统中分离出来，并在新版本发布时轻松更新它们。它还允许你轻松管理这些库的不同构建版本（例如，调试版本与压缩版本）。
- en: Paginating with Backbone Paginator
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Backbone Paginator进行分页
- en: 'One very common task many Backbone developers are faced with is rendering paginated
    data. For example, you might have a search page that can return hundreds of results,
    but you only want to show the first twenty results. To do this, you essentially
    need two `Collection` classes: one for all of the results and the other for the
    results being displayed. However, switching between the two can be tricky, and
    you may not actually want to fetch hundreds of results at once. Instead, you might
    just want to fetch the first twenty, but still be able to know how many total
    results are available so that you can display that information to your users.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Backbone 开发者面临的一个非常常见的任务是对分页数据进行渲染。例如，你可能有一个可以返回数百个结果的搜索页面，但你只想显示前二十个结果。为此，你本质上需要两个
    `Collection` 类：一个用于所有结果，另一个用于正在显示的结果。然而，在这两个之间切换可能会很棘手，你可能实际上并不想一次性获取数百个结果。相反，你可能只想获取前二十个，但仍然能够知道总共有多少个结果，以便你可以将此信息显示给用户。
- en: Backbone Paginator ([https://github.com/backbone-paginator/backbone.paginator](https://github.com/backbone-paginator/backbone.paginator))
    is a specialized `Collection` class created expressly for this purpose. Backbone
    Paginator was originally two separate libraries, but these libraries have since
    merged making Backbone Paginator the primary tool for handling paginated data
    in Backbone.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone Paginator ([https://github.com/backbone-paginator/backbone.paginator](https://github.com/backbone-paginator/backbone.paginator))
    是一个专门为这个目的创建的 `Collection` 类。Backbone Paginator 最初是两个独立的库，但这两个库已经合并，使 Backbone
    Paginator 成为处理 Backbone 中分页数据的主要工具。
- en: 'Backbone Paginator can be used in one of the following three modes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone Paginator 可以在以下三种模式之一中使用：
- en: '`client`: For when you want to fetch with your entire `Collection` at once'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client`：当你想一次性获取整个 `Collection` 时使用。'
- en: '`server`: For when you want to leave most of the `Collection` on the server
    and only fetch the relevant parts'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server`：当你想将大部分 `Collection` 留在服务器上，只获取相关部分时使用。'
- en: '`infinite`: For creating a `Collection` class to power a Facebook-like infinite
    scroll view.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`infinite`：用于创建一个 `Collection` 类来支持类似 Facebook 的无限滚动视图。'
- en: 'To use Backbone Paginator, you simply extend its `PageableCollection` class
    to create your own pageable `Collection` class, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Backbone Paginator，你只需扩展其 `PageableCollection` 类来创建你自己的可分页 `Collection`
    类，如下所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see a `PageableCollection` class is very similar to a normal `Collection`
    class: It has the `model` and `url` properties, can be extended, and so on. However,
    it also has two special properties.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一个 `PageableCollection` 类与一个普通的 `Collection` 类非常相似：它有 `model` 和 `url`
    属性，可以扩展，等等。然而，它也有两个特殊的属性。
- en: The first of these properties is `queryParams`, which tells `PageableCollection`
    how to interpret the pagination information in your server's response, in much
    the same way that a `parse` method normally tells Backbone how to interpret your
    server's response. The second property is `state`, which `PageableCollection`
    uses to keep track of which page of results the user is currently on, how many
    results there are in a page, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性是 `queryParams`，它告诉 `PageableCollection` 如何解释服务器响应中的分页信息，这与 `parse` 方法通常告诉
    Backbone 如何解释服务器响应的方式非常相似。第二个属性是 `state`，`PageableCollection` 使用它来跟踪用户当前所在的页面、每页有多少个结果等等。
- en: 'The full Backbone Paginator library has several other options for both `queryParams`
    and `state`, as well as a set of pagination methods such as `getPage` (for moving
    to a specific page of results) or `setSorting` (for changing how the results are
    sorted). If you want to implement a paginated view yourself, you can find full
    documentation of Backbone Paginator on its GitHub page. However, as it turns out,
    you may not want to create your own `View` of paginated data at all, because there''s
    already a very powerful existing one that you can leverage instead: BackGrid.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Backbone Paginator 库为 `queryParams` 和 `state` 提供了几个其他选项，以及一系列分页方法，如 `getPage`（用于跳转到特定结果页）或
    `setSorting`（用于更改结果的排序方式）。如果你想自己实现分页视图，你可以在 Backbone Paginator 的 GitHub 页面上找到完整的文档。然而，实际上，你可能根本不需要创建自己的分页数据
    `View`，因为已经有一个非常强大的现有 `View` 可以利用：BackGrid。
- en: Rendering tables with Backgrid.js
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Backgrid.js 渲染表格
- en: There are several different table `View` libraries available specifically for
    rendering tables in Backbone, and there are also many popular non-Backbone specific
    libraries (such as `jqGrid` or `DataTables`) that you can easily adapt for use
    in Backbone. However, BackGrid ([http://backgridjs.com/](http://backgridjs.com/))
    stands out from the rest because it combines a powerful feature set, simple design,
    and support for Backbone Paginator *out of the box*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个不同的专门用于在 Backbone 中渲染表格的 `View` 库，还有许多流行的非 Backbone 特定库（如 `jqGrid` 或 `DataTables`），你可以轻松地将它们用于
    Backbone。然而，BackGrid ([http://backgridjs.com/](http://backgridjs.com/)) 从其他库中脱颖而出，因为它结合了强大的功能集、简单的设计以及对
    Backbone Paginator 的原生支持。
- en: 'Here''s an example of a table generated using BackGrid:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用 BackGrid 生成的表格示例：
- en: '![Rendering tables with Backgrid.js](img/image00170.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Backgrid.js 渲染表格](img/image00170.jpeg)'
- en: 'To use BackGrid, you simply extend it, just as you would with any other `View`
    and then, instantiate it with one extra `columns` option:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 BackGrid，你只需像扩展任何其他 `View` 一样扩展它，然后使用一个额外的 `columns` 选项来实例化它：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see the extra `columns` option that you provide tells BackGrid which
    attribute of `Model` to use for the column's data (`name`), what this column's
    header text should be (`label`), and how BackGrid should format cells in this
    column (`cell`). Once you provide BackGrid with these columns and a `Collection`
    class, BackGrid will generate a `<table>` element as its `el` by using each `Model`
    in the provided `Collection` to generate a `<tr>` element.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你提供的额外 `columns` 选项告诉 BackGrid 使用 `Model` 的哪个属性来为列的数据（`name`）使用，该列的标题文本应该是什么（`label`），以及
    BackGrid 应如何格式化该列的单元格（`cell`）。一旦你向 BackGrid 提供了这些列和一个 `Collection` 类，BackGrid
    将使用提供的 `Collection` 中的每个 `Model` 来生成一个 `<tr>` 元素，从而生成一个 `<table>` 元素作为其 `el`。
- en: 'If you only want a table that displays information that''s all you need to
    do, but BackGrid can also be optionally used to edit information. To use this
    feature, you just need to pass one other `editable: true` option in each column
    that you want to make editable. When BackGrid renders its table, users will be
    able to click on any cells in the editable columns to switch the selected cell
    into the *edit* mode (for instance, replacing plain text with an HTML `<input>`
    tag), and any changes that the user makes will be automatically updated in the
    appropriate `Model`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你只想显示信息的表格，那么你只需要做这些，但 BackGrid 也可以选择性地用于编辑信息。要使用此功能，你只需在每个你想使其可编辑的列中传递一个额外的
    `editable: true` 选项。当 BackGrid 渲染其表格时，用户将能够点击可编辑列中的任何单元格以将选定的单元格切换到 *编辑* 模式（例如，将纯文本替换为
    HTML `<input>` 标签），并且用户所做的任何更改都将自动更新到相应的 `Model`。'
- en: BackGrid has many other features as well, such as the ability to define your
    own custom cell types by extending Backgrid.Cell. You can find the full list of
    these features on Backgrid's website, which has excellent tutorial-style documentation
    and API reference documentation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: BackGrid 还具有许多其他功能，例如通过扩展 Backgrid.Cell 定义自己的自定义单元格类型的能力。你可以在 Backgrid 的网站上找到这些功能的完整列表，该网站拥有优秀的教程式文档和
    API 参考文档。
- en: Templating with Handlebars
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Handlebars 模板
- en: As we discussed in [Chapter 5](part0050.xhtml#aid-1FLS42 "Chapter 5. Adding
    and Modifying Elements with Views"), *Adding and Modifying Elements with Views*,
    using templates to render your View's HTML offers many benefits. While you can
    simply use Underscore's `template` function, if you want a more powerful templating
    language there are many different libraries to choose from. For this chapter,
    we are going to use Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/))
    as our templating engine. Other libraries you may want to consider include Mustache
    ([https://github.com/janl/mustache.js](https://github.com/janl/mustache.js)),
    Embedded JS ([http://embeddedjs.com/](http://embeddedjs.com/)), or Hogan.js ([http://twitter.github.io/hogan.js/](http://twitter.github.io/hogan.js/)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 5 章](part0050.xhtml#aid-1FLS42 "第 5 章。使用视图添加和修改元素")中讨论的，“使用视图添加和修改元素”，使用模板来渲染视图的
    HTML 提供了许多好处。虽然你可以简单地使用 Underscore 的 `template` 函数，但如果你需要一个更强大的模板语言，有许多不同的库可供选择。对于本章，我们将使用
    Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/)) 作为我们的模板引擎。你可能还想考虑的其他库包括
    Mustache ([https://github.com/janl/mustache.js](https://github.com/janl/mustache.js))、Embedded
    JS ([http://embeddedjs.com/](http://embeddedjs.com/)) 或 Hogan.js ([http://twitter.github.io/hogan.js/](http://twitter.github.io/hogan.js/))。
- en: 'Handlebars, which was created from another templating library (Mustache), offers
    a significant amount of in-template logic in the form of "helper". For instance,
    here''s a Handlebars template that uses an "each" helper and an "if" helper to
    render a list of last names prefaced with either "Mr." or "Ms.," depending on
    the person''s gender:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars是从另一个模板库（Mustache）创建的，它提供了大量的模板逻辑，形式为“辅助函数”。例如，以下是一个Handlebars模板，它使用“each”辅助函数和“if”辅助函数来渲染一个以“先生”或“女士”开头的人名列表，具体取决于个人的性别：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Handlebars also allows you to define your own custom helpers, which makes it
    very extensible. These helpers are so flexible that you could create an entire
    sub-language within your templates if you so desire.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars还允许你定义自己的自定义辅助函数，这使得它非常易于扩展。这些辅助函数非常灵活，如果你愿意，你可以在模板中创建一个完整的子语言。
- en: 'Once you have a template written, you can either include it directly in your
    JavaScript code (wrapped in quotation marks to make it a valid string), or you
    can store it in a separate file and use RequireJS or a similar tool to bring it
    in. Thereafter, it''s a simple matter of compiling the template and writing a
    `View render` method that uses this template, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了一个模板，你既可以将其直接包含在你的JavaScript代码中（用引号括起来以使其成为一个有效的字符串），也可以将其存储在单独的文件中，并使用RequireJS或类似工具将其引入。然后，编译模板并编写一个使用此模板的`View
    render`方法就变得简单了，如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Automating tasks with Grunt
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Grunt自动化任务
- en: In many software projects, there are a number of tasks that are typically automated.
    For instance, just as a traditional C++ or Java project would need to compile
    the source code into byte code, a JavaScript project might need to use RequireJS
    or CoffeeScript to compile its source. The project might also need to concatenate
    files, run linting programs to validate the source, or assemble other web components
    such as sprite image files or SCSS/Less-generated CSS files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多软件项目中，有一些任务通常是自动化的。例如，就像传统的C++或Java项目需要将源代码编译成字节码一样，JavaScript项目可能需要使用RequireJS或CoffeeScript来编译其源代码。项目可能还需要连接文件、运行linting程序以验证源代码，或者组装其他Web组件，如精灵图像文件或由SCSS/Less生成的CSS文件。
- en: 'Most of these tasks aren''t language-specific: you don''t need to actually
    use JavaScript code in order to start RequireJS Optimizer; you just need a command
    line. Because of this, it''s possible to use a tool designed for another language
    (such as Ant or Maven for Java, or Fabric for Python) to automate these tasks,
    and if your server-side team is using such a language, it might be helpful to
    have everyone using the same tool.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些任务都不是语言特定的：你实际上不需要使用JavaScript代码来启动RequireJS优化器；你只需要一个命令行。正因为如此，可以使用为另一种语言（如Java的Ant或Maven，或Python的Fabric）设计的工具来自动化这些任务，如果你的服务器端团队使用这种语言，那么让每个人都使用相同的工具可能会有所帮助。
- en: 'However, if you don''t have a server-side team (or if that team uses `Node.js`),
    you may wish to have a JavaScript-specific build tool, and this is where Grunt
    comes in. Here''s an example Grunt configuration file that can be used to run
    RequireJS Optimizer:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你没有服务器端团队（或者如果该团队使用`Node.js`），你可能希望有一个特定的JavaScript构建工具，这就是Grunt的用武之地。以下是一个可以用来运行RequireJS优化器的示例Grunt配置文件：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While a full explanation of the preceding code is outside the scope of this
    book, it is sufficient to say that by using this configuration file, you can run
    a single command at the command line to invoke RequireJS Optimizer. More importantly,
    you can make RequireJS Optimizer just one step of your entire deployment process
    and then, invoke that entire process by using a single command. You can also use
    Grunt to set up different processes for different environments, such as one process
    for setting up a development environment and a different one for setting up a
    production server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对上述代码的完整解释超出了本书的范围，但可以说，通过使用此配置文件，你可以在命令行中运行单个命令来调用RequireJS优化器。更重要的是，你可以将RequireJS优化器作为整个部署过程的一步，然后通过单个命令调用整个过程。你还可以使用Grunt为不同的环境设置不同的流程，例如为设置开发环境设置一个流程，为设置生产服务器设置另一个流程。
- en: New syntax with CoffeeScript
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CoffeeScript的新语法
- en: You would think that as the creator of Backbone (and **Underscore** and **Docco**),
    Jeremy Ashkenas would have enough on his hands … but you'd be wrong. Somewhere
    in between creating these three libraries, Jeremy also found the time to create
    an entirely new programming language called **CoffeeScript** ([http://coffeescript.org/](http://coffeescript.org/)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为作为Backbone（以及**Underscore**和**Docco**）的创建者，Jeremy Ashkenas手头的工作已经足够多了……但你会错的。在这三个库之间创建的过程中，Jeremy还找到了时间创建一种全新的编程语言，称为**CoffeeScript**([http://coffeescript.org/](http://coffeescript.org/))。
- en: 'CoffeeScript is interesting to many web developers because of the following
    two key features:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript对许多Web开发者来说很有趣，因为它具有以下两个关键特性：
- en: CoffeeScript compiles to JavaScript, which means that you can use it for development
    but then compile it into a language that your user's browsers can actually understand.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CoffeeScript编译成JavaScript，这意味着你可以用它进行开发，然后将它编译成用户浏览器真正能理解的语言。
- en: CoffeeScript offers a syntax and feature set that have more in common with languages
    such as Python or Ruby than with "vanilla" JavaScript.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CoffeeScript提供的语法和功能集与Python或Ruby等语言比与“纯”JavaScript有更多共同之处。
- en: 'This is best explained by example. Here''s how you would create a `View` class
    for an `h1` element in CoffeeScript:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好通过例子来解释。以下是如何在CoffeeScript中创建一个`View`类，用于`h1`元素：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are some of the key differences that we just demonstrated:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们刚刚展示的一些关键差异：
- en: CoffeScript has its own syntax for declaring classes
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoffeeScript有自己声明类的语法。
- en: CoffeeScript uses indentation rather than curly braces ("`{}`") to mark where
    a function starts/stops
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoffeeScript使用缩进来标记函数的开始/结束位置，而不是使用花括号("`{}`")。
- en: CoffeeScript declares functions using `->` instead of `function() {} this` can
    be referenced as `@` the parentheses in function calls are optional
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoffeeScript使用`->`来声明函数，而不是`function() {}`，`this`可以引用为`@`，函数调用中的括号是可选的。
- en: Together these (and many other) features make CoffeeScript a significant improvement
    over JavaScript. However, there is a catch to using it. Because it compiles to
    JavaScript, debugging can be tricky, as the browser will use the JavaScript line
    numbers instead of the CoffeeScript line numbers when reporting errors. Also,
    when using the browser's debugger, you will walk through the JavaScript code,
    not the CoffeeScript code. While a new technology called "source maps" can help
    reduce these issues, it doesn't eliminate them entirely.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些（以及许多其他）特性使CoffeeScript在JavaScript之上有了显著的改进。然而，使用它也有一个缺点。因为它编译成JavaScript，所以调试可能很棘手，因为当浏览器报告错误时，它将使用JavaScript行号而不是CoffeeScript行号。此外，当使用浏览器的调试器时，你将遍历JavaScript代码，而不是CoffeeScript代码。虽然一种名为“源映射”的新技术可以帮助减少这些问题，但它并不能完全消除它们。
- en: If you are willing to put up with the abovementioned inconveniences, CoffeeScript
    can provide you with a syntax and a feature set that JavaScript itself won't have
    for many years, if ever. Further, because it was created by Jeremy Ashkenas, you
    can be rest assured that Backbone will always be compatible with CoffeeScript.
    In fact, Jeremy added at least one feature to Backbone, the hidden `__super__`
    property, specifically to support CoffeeScript.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意忍受上述不便，CoffeeScript可以为你提供一套语法和功能集，而JavaScript本身在许多年内甚至可能永远都不会有。此外，由于它是由Jeremy
    Ashkenas创建的，你可以放心，Backbone将始终与CoffeeScript兼容。事实上，Jeremy为Backbone添加了至少一个功能，即隐藏的`__super__`属性，专门用于支持CoffeeScript。
- en: Making life easier with BackSupport
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BackSupport让生活更轻松
- en: 'When I first started working with Backbone a few years ago, I was inspired
    to write BackSupport ([https://github.com/machineghost/BackSupport](https://github.com/machineghost/BackSupport))
    to help eliminate a lot of boilerplate code that I found myself writing over and
    over again. For instance, consider this basic `View` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前我开始使用Backbone时，我受到启发编写了BackSupport ([https://github.com/machineghost/BackSupport](https://github.com/machineghost/BackSupport))，以帮助消除我发现自己在反复编写的许多样板代码。例如，考虑这个基本的`View`类：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, what if there were a way to reduce all that common code to just the parts
    that are specific to our class? This is where BackSupport comes in. Let''s look
    at that same `View` class recreated using BackSupport:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们能将所有这些通用代码缩减到只针对我们类的部分，那会怎样？这正是BackSupport发挥作用的地方。让我们看看使用BackSupport重新创建的相同`View`类：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, BackSupport simplified so much of our logic that we didn't even
    need an `initialize` method in our second version!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，BackSupport简化了我们的许多逻辑，以至于我们甚至在第二版中都不需要`initialize`方法！
- en: 'Here are all of the BackSupport features demonstrated:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了所有BackSupport的功能：
- en: '`extend2`: This alternate form of Backbone''s `extend` is smart enough to combine,
    rather than replace, properties such as `className`, `events`, or `defaults`.
    This allows you to more easily create subclasses that use these properties, without
    losing their values from the parent class.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extend2`：Backbone 的 `extend` 的这种替代形式足够智能，可以合并而不是替换诸如 `className`、`events`
    或 `defaults` 这样的属性。这允许您更轻松地创建使用这些属性的子类，而不会丢失父类中的值。'
- en: '`boundMethods`: BackSupport will automatically call `_.bindAll` on every method
    included in this property, so we don''t have to do it manually in an `initialize`
    method.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boundMethods`：BackSupport 将自动对包含在这个属性中的每个方法调用 `_.bindAll`，因此我们不需要在 `initialize`
    方法中手动执行。'
- en: '`propertyOptions`: BackSupport will automatically transform any option included
    in this property into a new property of instances of this class, saving us from
    the tedium of doing `this.foo = options.foo` in our `initialize`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyOptions`：BackSupport 将自动将包含在这个属性中的任何选项转换为这个类实例的新属性，从而让我们免于在 `initialize`
    中进行 `this.foo = options.foo` 的繁琐操作。'
- en: '`requiredOptions`: BackSupport will throw an error if a class is instantiated
    without providing these options, giving us a simple way to ensure that they are
    provided without adding extra `initialize` logic.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requiredOptions`：如果类实例化时没有提供这些选项，BackSupport 将抛出错误，这为我们提供了一个简单的方法来确保它们被提供，而无需添加额外的
    `initialize` 逻辑。'
- en: '`render`: BackSupport provides a set of methods to make using templates easier.
    These methods are completely agnostic as to which templating system you use, and
    to choose a particular templating system, you need to only override the relevant
    BackSupport methods.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`：BackSupport 提供了一套方法，使使用模板变得更加容易。这些方法对您使用的模板系统完全无关，要选择特定的模板系统，您只需要覆盖相关的
    BackSupport 方法。'
- en: While this simple example provides a taste of what BackSupport offers, it also
    has many other great convenience features, which you can learn about on its GitHub
    page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个简单的例子展示了 BackSupport 提供的功能，但它还拥有许多其他出色的便利功能，您可以在其 GitHub 页面上了解更多信息。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the great variety of tools available to the
    Backbone community. In particular, we looked at RequireJS and Bower for dependency
    management, Backbone Paginator and BackGrid for rendering paginated tables, and
    Handlebars for templating. We also looked at using Grunt for build management,
    CoffeeScript for an alternative syntax, and this author's own tool, BackSupport,
    for general-purpose solutions to many of the minor inconveniences of Backbone.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 Backbone 社区提供的各种工具。特别是，我们探讨了 RequireJS 和 Bower 用于依赖管理，Backbone Paginator
    和 BackGrid 用于渲染分页表格，以及 Handlebars 用于模板。我们还探讨了使用 Grunt 进行构建管理，CoffeeScript 用于替代语法，以及作者自己的工具
    BackSupport，用于解决 Backbone 中许多小不便的通用解决方案。
- en: In the next chapter, we'll wrap things up by reviewing a summary of everything
    we've covered in this book. We'll also take a brief look at how the lessons learned
    can be applied to a real-world use case. Finally, we'll finish up with a look
    into the sources for learning even more about Backbone.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过回顾本书中涵盖的所有内容来总结全文。我们还将简要探讨如何将所学知识应用于实际案例。最后，我们将探讨更多关于 Backbone 的学习资源。
