- en: Chapter 11. (Not) Re-Inventing the Wheel – Utilizing Third-Party Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take an introductory look at a mix of general-purpose
    and Backbone-specific third-party libraries, all of which can benefit you as a
    Backbone developer. In particular, we''ll look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management tools Require.js and Bower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table-generation tools Backbone Paginator and BackGrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML templating tool Handlebars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task automation tool Grunt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternate language CoffeeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General-purpose Backbone utility library BackSupport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Backbone ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the five years that Backbone has existed, its popularity has resulted in
    the development of hundreds of related third-party libraries. In addition, numerous
    other general-purpose libraries have been released, which can also be of great
    value to a Backbone developer. While we don't have room to explore these libraries
    in depth, this chapter will provide you with a preview of each library so that
    you can identify the ones that would be most beneficial to you.
  prefs: []
  type: TYPE_NORMAL
- en: As we cover the libraries in this chapter, keep in mind that for each library
    that we preview, there exist several (and sometimes several dozen) competing libraries
    that we didn't feature. While we could try to list every available library in
    each category, such a list would quickly become out of date, so instead we've
    chosen to focus only on the most popular offerings. If any of the libraries in
    this chapter strike you as useful, we strongly recommend searching the Internet
    to see what other similar libraries are available, as you may well find one that
    better suits you.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management with RequireJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With modern IDEs, it is possible for a developer to open a file by typing just
    a few characters of that file's name. This feature, along with a general desire
    to keep code organized, has motivated developers to separate their code into multiple
    files. In Backbone, this typically means creating one file for every `Collection`,
    `Model`, `View`, and `Router`, and even in a small project, this can add up to
    a lot of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these files create two problems. First, each file needs to be downloaded
    separately, and as we learned in [Chapter 8](part0076.xhtml#aid-28FAO1 "Chapter 8. Scaling
    Up – Ensuring Performance in Complex Applications"), *Scaling Up: Ensuring Performance
    in Complex Applications*, browsers can only download between 2 and 8 files at
    once. Second, the order in which files are loaded can become increasingly hard
    to manage, because of the dependencies among the different files (`View A` needs
    `Collection B`, which needs `Model C`, which needs …). **RequireJS** ([http://requirejs.org/](http://requirejs.org/))
    solves both of these problems.'
  prefs: []
  type: TYPE_NORMAL
- en: RequireJS does this by organizing your code into `modules`. Each module can
    optionally depend on one or more other modules, and RequireJS will take care of
    stitching the modules together in a way that preserves all of their dependencies.
    RequireJS also provides a related tool, called RequireJS Optimizer, which allows
    you to combine multiple modules into a single file. The optimizer can also "minify"
    your code, as well as "uglify" it, making it harder for others to understand (to
    prevent competitors from reading your source files).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example RequireJS module for a BookList `View` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'RequireJS''s style of managing dependencies is known as the **AMD** style.
    There is also a competing style, known as **Common JS**, which is used by other
    dependency management libraries such as Browserify or Hem. Common JS modules look
    significantly different; here''s our previous example rewritten using Browserify''s
    Common JS syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside to this approach is that the actual ordering of the modules isn''t
    handled for you, as it is in RequireJS. Instead, the order of the modules must
    be spelt out separately using `require` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: External dependency management with Bower
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to using RequireJS or a similar library for managing your code''s
    dependencies, many programmers also use a second tool called **Bower** ([http://bower.io/](http://bower.io/))
    to manage their external library dependencies. Much like Python''s `pip` or Node.js''s
    NPM, Bower offers a simple command line interface for easily installing external
    libraries. It''s worth noting that NPM itself can also be used for managing libraries
    on the client-side, but this tool is designed primarily for server-side developers,
    whereas Bower is designed primarily for use on the client-side. To install a library,
    such as jQuery, one would simply run the following command at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple Bower dependencies can be stored in a `bower.json` file, allowing
    you to install all of your application''s dependencies with a single command.
    Here''s an example of what such a file might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding file defines the dependencies for your project.
    It includes Backbone and jQuery but not Underscore; as a dependency of Backbone,
    Underscore will be downloaded automatically (jQuery isn't technically a dependency
    of Backbone, as the library will work without it, so we have to require it separately).
    It also lets us include Mocha as `devDependency`, which means that it will be
    downloaded in a development environment but not in a production one. Using a requirements
    file like this allows you to keep your external libraries out of your source control
    system and to easily update them when new versions come out. It also allows you
    to easily manage different builds of these libraries (for instance, the debugging
    version versus the minified version).
  prefs: []
  type: TYPE_NORMAL
- en: Paginating with Backbone Paginator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One very common task many Backbone developers are faced with is rendering paginated
    data. For example, you might have a search page that can return hundreds of results,
    but you only want to show the first twenty results. To do this, you essentially
    need two `Collection` classes: one for all of the results and the other for the
    results being displayed. However, switching between the two can be tricky, and
    you may not actually want to fetch hundreds of results at once. Instead, you might
    just want to fetch the first twenty, but still be able to know how many total
    results are available so that you can display that information to your users.'
  prefs: []
  type: TYPE_NORMAL
- en: Backbone Paginator ([https://github.com/backbone-paginator/backbone.paginator](https://github.com/backbone-paginator/backbone.paginator))
    is a specialized `Collection` class created expressly for this purpose. Backbone
    Paginator was originally two separate libraries, but these libraries have since
    merged making Backbone Paginator the primary tool for handling paginated data
    in Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backbone Paginator can be used in one of the following three modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`client`: For when you want to fetch with your entire `Collection` at once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server`: For when you want to leave most of the `Collection` on the server
    and only fetch the relevant parts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`infinite`: For creating a `Collection` class to power a Facebook-like infinite
    scroll view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use Backbone Paginator, you simply extend its `PageableCollection` class
    to create your own pageable `Collection` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see a `PageableCollection` class is very similar to a normal `Collection`
    class: It has the `model` and `url` properties, can be extended, and so on. However,
    it also has two special properties.'
  prefs: []
  type: TYPE_NORMAL
- en: The first of these properties is `queryParams`, which tells `PageableCollection`
    how to interpret the pagination information in your server's response, in much
    the same way that a `parse` method normally tells Backbone how to interpret your
    server's response. The second property is `state`, which `PageableCollection`
    uses to keep track of which page of results the user is currently on, how many
    results there are in a page, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full Backbone Paginator library has several other options for both `queryParams`
    and `state`, as well as a set of pagination methods such as `getPage` (for moving
    to a specific page of results) or `setSorting` (for changing how the results are
    sorted). If you want to implement a paginated view yourself, you can find full
    documentation of Backbone Paginator on its GitHub page. However, as it turns out,
    you may not want to create your own `View` of paginated data at all, because there''s
    already a very powerful existing one that you can leverage instead: BackGrid.'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering tables with Backgrid.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several different table `View` libraries available specifically for
    rendering tables in Backbone, and there are also many popular non-Backbone specific
    libraries (such as `jqGrid` or `DataTables`) that you can easily adapt for use
    in Backbone. However, BackGrid ([http://backgridjs.com/](http://backgridjs.com/))
    stands out from the rest because it combines a powerful feature set, simple design,
    and support for Backbone Paginator *out of the box*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a table generated using BackGrid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering tables with Backgrid.js](img/image00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To use BackGrid, you simply extend it, just as you would with any other `View`
    and then, instantiate it with one extra `columns` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the extra `columns` option that you provide tells BackGrid which
    attribute of `Model` to use for the column's data (`name`), what this column's
    header text should be (`label`), and how BackGrid should format cells in this
    column (`cell`). Once you provide BackGrid with these columns and a `Collection`
    class, BackGrid will generate a `<table>` element as its `el` by using each `Model`
    in the provided `Collection` to generate a `<tr>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only want a table that displays information that''s all you need to
    do, but BackGrid can also be optionally used to edit information. To use this
    feature, you just need to pass one other `editable: true` option in each column
    that you want to make editable. When BackGrid renders its table, users will be
    able to click on any cells in the editable columns to switch the selected cell
    into the *edit* mode (for instance, replacing plain text with an HTML `<input>`
    tag), and any changes that the user makes will be automatically updated in the
    appropriate `Model`.'
  prefs: []
  type: TYPE_NORMAL
- en: BackGrid has many other features as well, such as the ability to define your
    own custom cell types by extending Backgrid.Cell. You can find the full list of
    these features on Backgrid's website, which has excellent tutorial-style documentation
    and API reference documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Templating with Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 5](part0050.xhtml#aid-1FLS42 "Chapter 5. Adding
    and Modifying Elements with Views"), *Adding and Modifying Elements with Views*,
    using templates to render your View's HTML offers many benefits. While you can
    simply use Underscore's `template` function, if you want a more powerful templating
    language there are many different libraries to choose from. For this chapter,
    we are going to use Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/))
    as our templating engine. Other libraries you may want to consider include Mustache
    ([https://github.com/janl/mustache.js](https://github.com/janl/mustache.js)),
    Embedded JS ([http://embeddedjs.com/](http://embeddedjs.com/)), or Hogan.js ([http://twitter.github.io/hogan.js/](http://twitter.github.io/hogan.js/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Handlebars, which was created from another templating library (Mustache), offers
    a significant amount of in-template logic in the form of "helper". For instance,
    here''s a Handlebars template that uses an "each" helper and an "if" helper to
    render a list of last names prefaced with either "Mr." or "Ms.," depending on
    the person''s gender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Handlebars also allows you to define your own custom helpers, which makes it
    very extensible. These helpers are so flexible that you could create an entire
    sub-language within your templates if you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a template written, you can either include it directly in your
    JavaScript code (wrapped in quotation marks to make it a valid string), or you
    can store it in a separate file and use RequireJS or a similar tool to bring it
    in. Thereafter, it''s a simple matter of compiling the template and writing a
    `View render` method that uses this template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Automating tasks with Grunt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many software projects, there are a number of tasks that are typically automated.
    For instance, just as a traditional C++ or Java project would need to compile
    the source code into byte code, a JavaScript project might need to use RequireJS
    or CoffeeScript to compile its source. The project might also need to concatenate
    files, run linting programs to validate the source, or assemble other web components
    such as sprite image files or SCSS/Less-generated CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of these tasks aren''t language-specific: you don''t need to actually
    use JavaScript code in order to start RequireJS Optimizer; you just need a command
    line. Because of this, it''s possible to use a tool designed for another language
    (such as Ant or Maven for Java, or Fabric for Python) to automate these tasks,
    and if your server-side team is using such a language, it might be helpful to
    have everyone using the same tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you don''t have a server-side team (or if that team uses `Node.js`),
    you may wish to have a JavaScript-specific build tool, and this is where Grunt
    comes in. Here''s an example Grunt configuration file that can be used to run
    RequireJS Optimizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While a full explanation of the preceding code is outside the scope of this
    book, it is sufficient to say that by using this configuration file, you can run
    a single command at the command line to invoke RequireJS Optimizer. More importantly,
    you can make RequireJS Optimizer just one step of your entire deployment process
    and then, invoke that entire process by using a single command. You can also use
    Grunt to set up different processes for different environments, such as one process
    for setting up a development environment and a different one for setting up a
    production server.
  prefs: []
  type: TYPE_NORMAL
- en: New syntax with CoffeeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would think that as the creator of Backbone (and **Underscore** and **Docco**),
    Jeremy Ashkenas would have enough on his hands … but you'd be wrong. Somewhere
    in between creating these three libraries, Jeremy also found the time to create
    an entirely new programming language called **CoffeeScript** ([http://coffeescript.org/](http://coffeescript.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'CoffeeScript is interesting to many web developers because of the following
    two key features:'
  prefs: []
  type: TYPE_NORMAL
- en: CoffeeScript compiles to JavaScript, which means that you can use it for development
    but then compile it into a language that your user's browsers can actually understand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CoffeeScript offers a syntax and feature set that have more in common with languages
    such as Python or Ruby than with "vanilla" JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is best explained by example. Here''s how you would create a `View` class
    for an `h1` element in CoffeeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some of the key differences that we just demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: CoffeScript has its own syntax for declaring classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoffeeScript uses indentation rather than curly braces ("`{}`") to mark where
    a function starts/stops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoffeeScript declares functions using `->` instead of `function() {} this` can
    be referenced as `@` the parentheses in function calls are optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together these (and many other) features make CoffeeScript a significant improvement
    over JavaScript. However, there is a catch to using it. Because it compiles to
    JavaScript, debugging can be tricky, as the browser will use the JavaScript line
    numbers instead of the CoffeeScript line numbers when reporting errors. Also,
    when using the browser's debugger, you will walk through the JavaScript code,
    not the CoffeeScript code. While a new technology called "source maps" can help
    reduce these issues, it doesn't eliminate them entirely.
  prefs: []
  type: TYPE_NORMAL
- en: If you are willing to put up with the abovementioned inconveniences, CoffeeScript
    can provide you with a syntax and a feature set that JavaScript itself won't have
    for many years, if ever. Further, because it was created by Jeremy Ashkenas, you
    can be rest assured that Backbone will always be compatible with CoffeeScript.
    In fact, Jeremy added at least one feature to Backbone, the hidden `__super__`
    property, specifically to support CoffeeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Making life easier with BackSupport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When I first started working with Backbone a few years ago, I was inspired
    to write BackSupport ([https://github.com/machineghost/BackSupport](https://github.com/machineghost/BackSupport))
    to help eliminate a lot of boilerplate code that I found myself writing over and
    over again. For instance, consider this basic `View` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what if there were a way to reduce all that common code to just the parts
    that are specific to our class? This is where BackSupport comes in. Let''s look
    at that same `View` class recreated using BackSupport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, BackSupport simplified so much of our logic that we didn't even
    need an `initialize` method in our second version!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are all of the BackSupport features demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`extend2`: This alternate form of Backbone''s `extend` is smart enough to combine,
    rather than replace, properties such as `className`, `events`, or `defaults`.
    This allows you to more easily create subclasses that use these properties, without
    losing their values from the parent class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boundMethods`: BackSupport will automatically call `_.bindAll` on every method
    included in this property, so we don''t have to do it manually in an `initialize`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`propertyOptions`: BackSupport will automatically transform any option included
    in this property into a new property of instances of this class, saving us from
    the tedium of doing `this.foo = options.foo` in our `initialize`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requiredOptions`: BackSupport will throw an error if a class is instantiated
    without providing these options, giving us a simple way to ensure that they are
    provided without adding extra `initialize` logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render`: BackSupport provides a set of methods to make using templates easier.
    These methods are completely agnostic as to which templating system you use, and
    to choose a particular templating system, you need to only override the relevant
    BackSupport methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this simple example provides a taste of what BackSupport offers, it also
    has many other great convenience features, which you can learn about on its GitHub
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the great variety of tools available to the
    Backbone community. In particular, we looked at RequireJS and Bower for dependency
    management, Backbone Paginator and BackGrid for rendering paginated tables, and
    Handlebars for templating. We also looked at using Grunt for build management,
    CoffeeScript for an alternative syntax, and this author's own tool, BackSupport,
    for general-purpose solutions to many of the minor inconveniences of Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll wrap things up by reviewing a summary of everything
    we've covered in this book. We'll also take a brief look at how the lessons learned
    can be applied to a real-world use case. Finally, we'll finish up with a look
    into the sources for learning even more about Backbone.
  prefs: []
  type: TYPE_NORMAL
