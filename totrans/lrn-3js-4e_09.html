<html><head></head><body>
		<div><h1 id="_idParaDest-149" class="chapter-number"><a id="_idTextAnchor148"/>9</h1>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Animation and Moving the Camera</h1>
			<p>In the previous chapters, we saw some simple animations, but nothing too complex. In <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, we introduced the basic rendering loop, and in the chapters following that, we used that to rotate some simple objects and show a couple of other basic animation concepts. </p>
			<p>In this chapter, we’re going to look in more detail at how animation is supported by Three.js. We will look at the following four subjects:</p>
			<ul>
				<li>Basic animations</li>
				<li>Working with the camera</li>
				<li>Morphing and skeleton animation</li>
				<li>Creating animations using external modes</li>
			</ul>
			<p>We will start by covering the basic concepts behind animations.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Basic animations</h1>
			<p>Before we <a id="_idIndexMarker771"/>look at the examples, let’s do a quick recap of what was shown in <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, on the render loop. To support animations, we need to tell Three.js to render the scene every so often. For this, we use the standard HTML5 <code>requestAnimationFrame</code> functionality, as follows:</p>
			<pre class="source-code">
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();</pre>
			<p>With this code, we only need to call the <code>render()</code> function once we’ve initialized the scene. In the <code>render()</code> function itself, we use <code>requestAnimationFrame</code> to schedule the next rendering. This way, the browser will make sure the <code>render()</code> function is called at the correct interval (usually around 60 times or 120 times a second). Before <code>requestAnimationFrame</code> was added to browsers, <code>setInterval(function, interval)</code> or <code>setTimeout(function, interval)</code> was used. These would call the specified function once every set interval. </p>
			<p>The problem with this approach is that it doesn’t take into account what else is going on. Even if your animation isn’t shown or is in a hidden tab, it is still called and is still using resources. Another issue is that these functions update the screen whenever they are called, and not when it is the best time for the browser, which results in higher CPU usage. With <code>requestAnimationFrame</code>, we don’t tell the browser when it needs to update the screen; we ask the browser to run the supplied function when it’s most opportune. Usually, this <a id="_idIndexMarker772"/>results in a frame rate of about 60 or 120 FPS (depending on your hardware). With <code>requestAnimationFrame</code>, your animations will run more smoothly and will be more CPU- and GPU-friendly, and you don’t have to worry about timing issues.</p>
			<p>In the next section, we’ll start with creating a simple animation.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>Simple animations</h2>
			<p>With this approach, we can very <a id="_idIndexMarker773"/>easily animate objects by changing their <code>rotation</code>, <code>scale</code>, <code>position</code>, <code>material</code>, vertices, faces, and anything else you can imagine. In the next render loop, Three.js will render the changed properties. A very simple example, based on the one we already saw in <a href="B18726_07.xhtml#_idTextAnchor122"><em class="italic">Chapter 7</em></a>, <em class="italic">Points and Sprites</em>, is available in <code>01-basic-animations.html</code>. The following screenshot shows this example:</p>
			<div><div><img src="img/Figure_9.1_B18726.jpg" alt="Figure 9.1 – Animation after changing its properties"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Animation after changing its properties</p>
			<p>The render loop for this<a id="_idIndexMarker774"/> is very simple. First, we initialize the various properties on the <code>userData</code> object, which is a place for custom data stored in the <code>THREE.Mesh</code> itself, and then update these properties on the mesh, using the data we defined on the <code>userData</code> object. In the animation loop, just change the rotation, position, and the scale based on<a id="_idIndexMarker775"/> these properties, and Three.js handles the rest. Here’s how we do this:</p>
			<pre class="source-code">
const geometry = new THREE.TorusKnotGeometry(2, 0.5, 150, 50, 3, 4)
const material = new THREE.PointsMaterial({
  size: 0.1,
  vertexColors: false,
  color: 0xffffff,
  map: texture,
  depthWrite: false,
  opacity: 0.1,
  transparent: true,
  blending: THREE.AdditiveBlending
})
const points = new THREE.Points(geometry, material)
points.userData.rotationSpeed = 0
points.userData.scalingSpeed = 0
points.userData.bouncingSpeed = 0
points.userData.currentStep = 0
points.userData.scalingStep = 0
// in the render loop
function render() {
  const rotationSpeed = points.userData.rotationSpeed
  const scalingSpeed = points.userData.scalingSpeed
  const bouncingSpeed = points.userData.bouncingSpeed
  const currentStep = points.userData.currentStep
  const scalingStep = points.userData.scalingStep
  points.rotation.x += rotationSpeed
  points.rotation.y += rotationSpeed
  points.rotation.z += rotationSpeed
  points.userData.currentStep = currentStep + bouncingSpeed
  points.position.x = Math.cos(points.userData.currentStep)
  points.position.y = Math.abs(Math.sin
   (points.userData.currentStep)) * 2
  points.userData.scalingStep = scalingStep + scalingSpeed
  var scaleX = Math.abs(Math.sin(scalingStep * 3 + 0.5 * 
    Math.PI))
  var scaleY = Math.abs(Math.cos(scalingStep * 2))
  var scaleZ = Math.abs(Math.sin(scalingStep * 4 + 0.5 * 
    Math.PI))
  points.scale.set(scaleX, scaleY, scaleZ)
}</pre>
			<p>There’s nothing spectacular here, but it nicely shows the concept behind the basic animations we will discuss in this book. We just change the <code>scale</code>, <code>rotation</code>, and <code>position</code> properties and <a id="_idIndexMarker776"/>Three.js does the rest. </p>
			<p>In the next section, we’ll take a quick sidestep. Besides animations, an important aspect that you’ll quickly run into when working with Three.js in more complex scenes is the ability to select objects on the screen using the mouse.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Selecting and moving objects</h2>
			<p>Even though not directly related to animations, since we’ll be looking at cameras and animations in this chapter, knowing how to select and move objects is a nice addition to the subjects explained in this chapter. Here, we will show you how to do the following:</p>
			<ul>
				<li>Select an object from a scene using the mouse</li>
				<li>Drag an object around the scene with the mouse</li>
			</ul>
			<p>We’ll start by looking at the steps you need to take to select an object.</p>
			<h3>Selecting objects</h3>
			<p>First, open<a id="_idIndexMarker777"/> the <code>selecting-objects.html</code> example, where you’ll see the following:</p>
			<div><div><img src="img/Figure_9.2_B18726.jpg" alt="Figure 9.2 – Randomly placed cubes that can be selected with the mouse"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Randomly placed cubes that can be selected with the mouse</p>
			<p>When you move the<a id="_idIndexMarker778"/> mouse around the scene, you’ll see that whenever your mouse hits an object, that object is highlighted. You can easily create this by using a <code>THREE.Raycaster</code>. A raycaster<a id="_idIndexMarker779"/> will look at your current camera and cast a ray from the camera to your mouse’s position. Based on that, it can calculate which object is hit based on the position of the mouse. To accomplish this, we need to take the following steps:</p>
			<ul>
				<li>Create an object that keeps track of where the mouse is pointing at</li>
				<li>Whenever we move the mouse, update that object</li>
				<li>In the render loop, use this updated information to see which Three.js object we’re pointing at</li>
			</ul>
			<p>This is shown in the<a id="_idIndexMarker780"/> following code fragment:</p>
			<pre class="source-code">
// initially set the position to -1, -1
let pointer = {
  x: -1,
  y: -1
}
// when the mouse moves update the point
document.addEventListener('mousemove', (event) =&gt; {
  pointer.x = (event.clientX / window.innerWidth) * 2 - 1
  pointer.y = -(event.clientY / window.innerHeight) * 2 + 1
})
// an array containing all the cubes in the scene
const cubes = ...
// use in the render loop to determine the object to highlight
const raycaster = new THREE.Raycaster()
function render() {
  raycaster.setFromCamera(pointer, camera)
  const cubes = scene.getObjectByName('group').children
  const intersects = raycaster.intersectObjects(cubes)
  // do something with the intersected objects
}</pre>
			<p>Here, we are using <code>THREE.Raycaster</code> to determine which objects intersect the position of the mouse, from the point of the camera. The result (<code>intersects</code>, in the preceding example) contains all the cubes that intersected our mouse because the ray is cast from the camera’s position through to the end of the camera’s range. The first one in this array is the one that we’re hovering over, and the other values in this array (if any) point to objects behind the first mesh. <code>THREE.Raycaster</code> also provides other information about exactly where you hit the object:</p>
			<div><div><img src="img/Figure_9.3_B18726.jpg" alt="Figure 9.3 – Additional information from the raycaster"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Additional information from the raycaster</p>
			<p>Here, we clicked<a id="_idIndexMarker781"/> on the <code>face</code> object. <code>faceIndex</code> points to the face of the mesh that was selected. The <code>distance</code> value is measured from the camera to the clicked object, and <code>point</code> is the exact position on the mesh where it was clicked. Finally, we have the <code>uv</code> value, which determines, when using textures, where the point that was clicked appears on the 2D texture (ranging from 0 to 1; more information on <code>uv</code> can be found in <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working </em><em class="italic">With Textures</em>).</p>
			<h3>Dragging objects</h3>
			<p>Besides selecting an <a id="_idIndexMarker782"/>object, a common requirement is being able to drag and move objects around. Three.js also provides default support for this. If you open the <code>dragging-objects.html</code> example in your browser, you’ll see a similar scene to the one shown in <em class="italic">Figure 9</em><em class="italic">.2</em>. This time, when you click on an object, you can drag it around the scene:</p>
			<div><div><img src="img/Figure_9.4_B18726.jpg" alt="Figure 9.4 – Dragging an object around the scene using the mouse"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Dragging an object around the scene using the mouse</p>
			<p>To support<a id="_idIndexMarker783"/> dragging objects, Three.js uses something called <code>DragControls</code>. This handles everything and provides convenient callbacks whenever the dragging starts and stops. The code to accomplish this is shown here:</p>
			<pre class="source-code">
const orbit = new OrbitControls(camera, renderer.domElement)
orbit.update()
const controls = new DragControls(cubes, camera, renderer.domElement)
controls.addEventListener('dragstart', function (event) {
  orbit.enabled = false
  event.object.material.emissive.set(0x33333)
})
controls.addEventListener('dragend', function (event) {
  orbit.enabled = true
  event.object.material.emissive.set(0x000000)
})</pre>
			<p>It is as simple as that. Here, we added <code>DragControls</code> and passed in the elements that can be dragged (in our case, all of the randomly placed cubes). Then, we added two event listeners. The first one, <code>dragstart</code>, is called when we start dragging a cube, whereas <code>dragend</code> is called when we stop dragging an object. In this example, when we start dragging, we disable <code>OrbitControls</code> (which allows us to use the mouse to look around the scene) and change the color of the selected object. Once we stop dragging, we change the color of the object back and enable <code>OrbitControls</code> again.</p>
			<p>There is also a <a id="_idIndexMarker784"/>somewhat more advanced version of <code>DragControls</code> available called <code>TransformControls</code>. We won’t go into the details of this control, but it allows you to use a simple UI to transform the properties of a mesh. You can find an example of this control when you open <code>transform-controls-html</code> in your browser:</p>
			<div><div><img src="img/Figure_9.5_B18726.jpg" alt="Figure 9.5 – Transform controls allow you to change the properties of a mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Transform controls allow you to change the properties of a mesh</p>
			<p>If you click on the<a id="_idIndexMarker785"/> various parts of this control, you can easily change the shape of the cube:</p>
			<div><div><img src="img/Figure_9.6_B18726.jpg" alt="Figure 9.6 – Shape modified using transform controls"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Shape modified using transform controls</p>
			<p>For the final <a id="_idIndexMarker786"/>example in this chapter, we’ll show you how you can use an alternative way of modifying the properties of an object (as we saw in the first example of this chapter) by using a tweening library.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Animating with Tween.js</h2>
			<p>Tween.js is <a id="_idIndexMarker787"/>a small JavaScript library that you can download from <a href="https://github.com/sole/tween.js/">https://github.com/sole/tween.js/</a> and that you can use to easily define the transition of a property between two values. All the intermediate points between the start and end values are calculated for you. This process is <a id="_idIndexMarker788"/>called <code>x</code> position of a mesh from 10 to 3 in 10 seconds, as follows:</p>
			<pre class="source-code">
const tween = new TWEEN.Tween({x: 10}).to({x: 3}, 10000)
.easing(TWEEN.Easing.Elastic.InOut)
.onUpdate( function () {
  // update the mesh
})</pre>
			<p>Alternatively, you can create a separate object and pass that into the mesh you want to work with:</p>
			<pre class="source-code">
  const tweenData = {
    x: 10
  }
  new TWEEN.Tween(tweenData)
    .to({ x: 3 }, 10000)
    .yoyo(true)
    .repeat(Infinity)
    .easing(TWEEN.Easing.Bounce.InOut)
    .start()
  mesh.userData.tweenData = tweenData    </pre>
			<p>In this example, we’ve created <code>TWEEN.Tween</code>. This tween will make sure that the <code>x</code> property is changed from 10 to 3 over 10,000 milliseconds. Tween.js also allows you to define how this property is changed over time. This can be done using linear, quadratic, or any of the other possibilities (see <a href="http://sole.github.io/tween.js/examples/03_graphs.html">http://sole.github.io/tween.js/examples/03_graphs.html</a> for a complete overview). The value is changed over time by a process<a id="_idIndexMarker790"/> called <code>easing()</code> function. This library also provides additional ways to control how this easing is done. For instance, we can set how often the easing should be repeated (<code>repeat(10)</code>) and whether we want a yoyo effect (this means we go from 10 to 3 and back to 10 in this example).</p>
			<p>Using this library <a id="_idIndexMarker791"/>together with Three.js is very simple. If you open the <code>tween-animations.html</code> example, you will see the Tween.js library in action. The following screenshot shows a still image of the example:</p>
			<div><div><img src="img/Figure_9.7_B18726.jpg" alt="Figure 9.7 – Tweening a point system halfway through the action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Tweening a point system halfway through the action</p>
			<p>We’ll use the Tween.js library to move this to a single point using a specific <code>easing()</code>, which at a certain point looks as follows:</p>
			<div><div><img src="img/Figure_9.8_B18726.jpg" alt="Figure 9.8 – Tweening a point when everything is merged into a single point"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Tweening a point when everything is merged into a single point</p>
			<p>In this example, we’ve<a id="_idIndexMarker792"/> taken a point cloud from <a href="B18726_07.xhtml#_idTextAnchor122"><em class="italic">Chapter 7</em></a>, and created an animation where all the points slowly move down to the center. The position of these particles is set by using a tween created with the Tween.js library, as follows:</p>
			<pre class="source-code">
const geometry = new THREE.TorusKnotGeometry(2, 0.5, 150, 50, 3, 4)
geometry.setAttribute('originalPos', geometry.attributes['position'].clone())
const material = new THREE.PointsMaterial(..)
const points = new THREE.Points(geometry, material)
const tweenData = {
  pos: 1
}
new TWEEN.Tween(tweenData)
  .to({ pos: 3 }, 10000)
  .yoyo(true)
  .repeat(Infinity)
  .easing(TWEEN.Easing.Bounce.InOut)
  .start()
points.userData.tweenData = tweenData    
// in the render loop
const originalPosArray = points.geometry.attributes.originalPos.array
const positionArray = points.geometry.attributes.position.array
TWEEN.update()
 for (let i = 0; i &lt; points.geometry.attributes.position.count; i++) {
  positionArray[i * 3] = originalPosArray[i * 3] * points.userData.tweenData.pos
  positionArray[i * 3 + 1] = originalPosArray[i * 3 + 1] * points.userData.tweenData.pos
  positionArray[i * 3 + 2] = originalPosArray[i * 3 + 2] * points.userData.tweenData.pos
}
points.geometry.attributes.position.needsUpdate = true</pre>
			<p>With this piece<a id="_idIndexMarker793"/> of code, we created a tween that transitions a value from <code>1</code> to <code>0</code> and back again. To use the value from the tween, we have two different options: we can use the <code>onUpdate</code> function provided by this library to call a function with the updated values, whenever the tween is updated (which is done by calling <code>TWEEN.update()</code>), or we can directly access the updated values. In this example, we used the latter approach. </p>
			<p>Before we look at the changes we need to make in the <code>render</code> function, we must perform one additional step after we load the model. We want to tween between the original values to zero and back again. For this, we need to store the original positions of the vertices somewhere. We can do this by copying the starting positions array:</p>
			<pre class="source-code">
geometry.setAttribute('originalPos', geometry.attributes['position'].clone())</pre>
			<p>Now, whenever we want to access the original position, we can look at the <code>originalPos</code> attribute on the geometry. Now, we can just use the value from the tween to calculate the new positions of each of the vertices. We can do this like so in the render loop:</p>
			<pre class="source-code">
const originalPosArray = points.geometry.attributes.originalPos.array
const positionArray = points.geometry.attributes.position.array
for (let i = 0; i &lt; points.geometry.attributes.position.count; i++) {
  positionArray[i * 3] = originalPosArray[i * 3] * points.userData.tweenData.pos
  positionArray[i * 3 + 1] = originalPosArray[i * 3 + 1] * points.userData.tweenData.pos
  positionArray[i * 3 + 2] = originalPosArray[i * 3 + 2] * points.userData.tweenData.pos
}
points.geometry.attributes.position.needsUpdate = true</pre>
			<p>With these steps<a id="_idIndexMarker794"/> in place, the tween library will take care of positioning the various points on the screen. As you can see, using this library is much easier than having to manage the transitions yourself. Besides animating and changing objects, we can also animate a scene by moving the camera around. In the previous chapters, we did this a couple of times by manually updating the position of the camera. Three.js also provides several additional ways of updating the camera.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>Working with the camera</h1>
			<p>Three.js has several <a id="_idIndexMarker795"/>camera controls you can use to control the camera throughout a scene. These controls are located in the Three.js distribution and can be found in the <code>examples/js/controls</code> directory. In this section, we’ll look at the following controls in more detail:</p>
			<ul>
				<li><code>ArcballControls</code>: An<a id="_idIndexMarker796"/> extensive control that provides a transparent <a id="_idIndexMarker797"/>overlay that you can use to easily move the camera around.</li>
				<li><code>FirstPersonControls</code>: These<a id="_idIndexMarker798"/> are controls that<a id="_idIndexMarker799"/> behave like those in first-person shooters. You can move around with the keyboard and look around with the mouse.</li>
				<li><code>FlyControls</code>: These<a id="_idIndexMarker800"/> are flight simulator-like controls. You can move<a id="_idIndexMarker801"/> and steer with the keyboard and the mouse.</li>
				<li><code>OrbitControls</code>: This <a id="_idIndexMarker802"/>simulates a satellite in orbit around a specific scene. This <a id="_idIndexMarker803"/>allows you to move around with the mouse and keyboard.</li>
				<li><code>PointerLockControls</code>: These are <a id="_idIndexMarker804"/>similar to the first-person controls but they also lock the mouse pointer to the screen, making it a great<a id="_idIndexMarker805"/> choice for simple games.</li>
				<li><code>TrackBallControls</code>: These are <a id="_idIndexMarker806"/>the most-used controls, allowing you to use the mouse (or the trackball) to easily move, pan, and zoom <a id="_idIndexMarker807"/>around the scene.</li>
			</ul>
			<p>Besides using these camera controls, you can also move the camera yourself by setting its position and changing where it is pointed using the <code>lookAt()</code> function.</p>
			<p>The first control we’ll look at is <code>ArcballControls</code>.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>ArcballControls</h2>
			<p>The<a id="_idIndexMarker808"/> easiest way to<a id="_idIndexMarker809"/> explain how <code>ArcballControls</code> works is by looking at an example. If you open up the <code>arcball-controls.html</code> example, you’ll see a simple scene, like this:</p>
			<div><div><img src="img/Figure_9.9_B18726.jpg" alt="Figure 9.9 – Using ArcballControls to explore a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Using ArcballControls to explore a scene</p>
			<p>If you look <a id="_idIndexMarker810"/>closely at this screenshot, you will see two translucent lines <a id="_idIndexMarker811"/>crossing the scene. These are lines provided by <code>ArcballControls</code>, which you can use to rotate and pan around the scene. These lines are<a id="_idIndexMarker812"/> called <strong class="bold">gizmos</strong>. The left mouse button is used to rotate the scene, the right mouse button can be used to pan around, and you can zoom in with the scroll wheel.</p>
			<p>Besides this standard functionally, this control also allows you to focus on specific parts of the mesh that is shown. If you double-click on the scene, the camera will focus on that part of the scene. To use this control, all we need to do is instantiate it and pass in the <code>camera</code> property, the <code>domElement</code> property used by the renderer, and the <code>scene</code> property we’re looking at:</p>
			<pre class="source-code">
import { ArcballControls } from 'three/examples/jsm/controls/ArcballControls'
const controls = new ArcballControls(camera, renderer.domElement, scene)
controls.update()</pre>
			<p>This control is a <a id="_idIndexMarker813"/>very versatile one, which can be configured through a set of properties. Most of these properties can be explored in this example by using the menu on the right of this example. For this specific control, we’ll dive a bit deeper into the properties and methods provided by this object since it is a versatile control and a good choice when you want to provide a good way for your users to explore your scenes. Let’s provide an overview of the properties and the methods provided by this control. First, let’s<a id="_idIndexMarker814"/> look at the properties:</p>
			<ul>
				<li><code>adjustNearFar</code>: If this is set to <code>true</code>, this control will change the camera’s <code>near</code> and <code>far</code> properties when zooming in</li>
				<li><code>camera</code>: The camera that’s used when creating this control</li>
				<li><code>cursorZoom</code>: If set to <code>true</code>, when zooming in, the zoom will be focused on the position of the cursor</li>
				<li><code>dampingFactor</code>: If <code>enableAnimations</code> is set to <code>true</code>, this value will determine how quickly an animation stops after an action</li>
				<li><code>domElement</code>: This element is used to list mouse events</li>
				<li><code>enabled</code>: Determines whether this control is enabled or not</li>
				<li><code>enableRotate</code>, <code>enableZoom</code>, <code>enablePan</code>, <code>enableGrid</code>, <code>enableAnimations</code>: These properties enable and disable functionality provided by this control</li>
				<li><code>focusAnimationTime</code>: When we double-click and focus on part of the scene, this property determines the duration of the focusing animation</li>
				<li><code>maxDistance</code>/<code>minDistance</code>: How far we can zoom out and in for <code>PerspectiveCamera</code></li>
				<li><code>maxZoom</code>/<code>minZoom</code>: How far we can zoom out and in for <code>OrthographicCamera</code></li>
				<li><code>scaleFactor</code>: How fast we zoom in and out</li>
				<li><code>scene</code>: The scene passed in the constructor</li>
				<li><code>radiusFactor</code>: The size of the “gizmo” relative to the screen’s width and height</li>
				<li><code>wMax</code>: How <a id="_idIndexMarker815"/>fast <a id="_idIndexMarker816"/>we’re allowed to rotate the scene</li>
			</ul>
			<p>This control also provides several methods to <a id="_idIndexMarker817"/>interact or configure it further:</p>
			<ul>
				<li><code>activateGizmos(bool)</code>: If <code>true</code>, it highlights the gizmos</li>
				<li><code>copyState()</code>, <code>pasteState()</code>: Allows you to copy and paste the state of the controls to the clipboard in JSON</li>
				<li><code>saveState()</code>, <code>reset()</code>: Internally saves the current state and uses <code>reset()</code> to apply the saved state</li>
				<li><code>dispose()</code>: Removes all parts of this control from the scene, and cleans up any listeners and animations</li>
				<li><code>setGizomsVisible(bool)</code>: Specifies whether to show or hide the gizmos</li>
				<li><code>setTbRadius(radiusFactor)</code>: Updates the <code>radiusFactor</code> property and redraws the gizmos</li>
				<li><code>setMouseAction(operation, mouse, key)</code>: Determines which mouse key provides which action</li>
				<li><code>unsetMouseAction(mouse, key)</code>: Clears an assigned mouse action</li>
				<li><code>update()</code>: Whenever the camera properties change, call this to apply these new settings to this control</li>
				<li><code>getRayCaster()</code>: Provides access to <code>rayCaster</code>, which is <a id="_idIndexMarker818"/>used internally by these <a id="_idIndexMarker819"/>controls</li>
			</ul>
			<p><code>ArcballControls</code> is a really useful and relatively new addition to Three.js that provides advanced control of the scene using the mouse. If you’re looking for a simpler approach, you can use <code>TrackBallControls</code>.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>TrackBallControls</h2>
			<p>Using <code>TrackBallControls</code> follows the <a id="_idIndexMarker820"/>same approach as we<a id="_idIndexMarker821"/> saw for <code>ArcballControls</code>:</p>
			<pre class="source-code">
import { TrackBallControls } from 'three/examples/jsm/
  controls/TrackBallControls'
const controls = new TrackBallControls(camera, renderer.
  domElement)</pre>
			<p>This time, we just need to pass in the <code>camera</code> and <code>domeElement</code> properties from the renderer. For the trackball controls to work, we also need to add a <code>THREE.Clock</code> and update the render loop, like so:</p>
			<pre class="source-code">
const clock = new THREE.Clock()
function animate() {
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
  controls.update(clock.getDelta())
}</pre>
			<p>In the preceding code snippet, we can see a new Three.js object, <code>THREE.Clock</code>. The <code>THREE.Clock</code> object can be used to calculate the elapsed time that a specific invocation or rendering loop takes to complete. You can do this by calling the <code>clock.getDelta()</code> function. This function will return the elapsed time between this call and the previous call to <code>getDelta()</code>. To update the position of the camera, we can call the <code>TrackBallControls.update()</code> function. In this function, we need to provide the time that has passed since the last time this update function was called. For this, we can use the <code>getDelta()</code> function from the <code>THREE.Clock</code> object. You might be wondering why we don’t just pass in the frame rate (1/60 seconds) to the update function. The reason is that with <code>requestAnimationFrame</code>, we can expect 60 FPS, but this isn’t<a id="_idIndexMarker822"/> guaranteed. Depending <a id="_idIndexMarker823"/>on all kinds of external factors, the frame rate might change. To make sure the camera turns and rotates smoothly, we need to pass in the exact elapsed time.</p>
			<p>A working example of this can be found in <code>trackball-controls-camera.html</code>. The following screenshot shows a still image of this example:</p>
			<div><div><img src="img/Figure_9.10_B18726.jpg" alt="Figure 9.10 – Using TrackBallControls to control a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Using TrackBallControls to control a scene</p>
			<p>You can control the <a id="_idIndexMarker824"/>camera in the following manner:</p>
			<ul>
				<li><strong class="bold">Left mouse button and move</strong>: Rotate and roll the camera around the scene</li>
				<li><strong class="bold">Scroll wheel</strong>: Zoom in and zoom out</li>
				<li><strong class="bold">Middle mouse button and move</strong>: Zoom in and zoom out</li>
				<li><strong class="bold">Right mouse button and move</strong>: Pan<a id="_idIndexMarker825"/> around the scene</li>
			</ul>
			<p>There are a<a id="_idIndexMarker826"/> couple of properties that you can use to fine-tune how the camera acts. For instance, you can set how fast the camera rotates with the <code>rotateSpeed</code> property and <a id="_idIndexMarker827"/>disable zooming by setting the <code>noZoom</code> property to <code>true</code>. In this chapter, we won’t go into detail on what each property does as they are pretty much self-explanatory. For a complete overview of what is possible, look at the source of the <code>TrackBallControls.js</code> file, where these properties are listed.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>FlyControls</h2>
			<p>The next control <a id="_idIndexMarker828"/>we’ll look at is <code>FlyControls</code>. With <code>FlyControls</code>, you<a id="_idIndexMarker829"/> can fly around a scene using controls also found in flight simulators. An example can be found in <code>fly-controls-camera.html</code>. The following screenshot shows a still image of this example:</p>
			<div><div><img src="img/Figure_9.11_B18726.jpg" alt="Figure 9.11 – Using FlyControls to fly around a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Using FlyControls to fly around a scene</p>
			<p>Enabling <code>FlyControls</code> works in the<a id="_idIndexMarker830"/> same<a id="_idIndexMarker831"/> manner as the other controls:</p>
			<pre class="source-code">
import { FlyControls } from 'three/examples/jsm/controls/FlyControls'
const controls = new FlyControls(camera, renderer.domElement)
const clock = new THREE.Clock()
function animate() {
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
  controls.update(clock.getDelta())
}</pre>
			<p><code>FlyControls</code> takes <a id="_idIndexMarker832"/>the camera and the renderer’s <code>domElement</code> as arguments and<a id="_idIndexMarker833"/> requires that you call the <code>update()</code> function with the elapsed time in the render loop. You can control the camera with <code>THREE.FlyControls</code> in the following manner:</p>
			<ul>
				<li><strong class="bold">Left and middle mouse buttons</strong>: Start moving forward</li>
				<li><strong class="bold">Right mouse button</strong>: Move backward</li>
				<li><strong class="bold">Mouse movement</strong>: Look around</li>
				<li><em class="italic">W</em>: Start moving forward</li>
				<li><em class="italic">S</em>: Move backward</li>
				<li><em class="italic">A</em>: Move left</li>
				<li><em class="italic">D</em>: Move right</li>
				<li><em class="italic">R</em>: Move up</li>
				<li><em class="italic">F</em>: Move down</li>
				<li><strong class="bold">Left, right, up, and down arrows</strong>: Look left, right, up, and down, respectively</li>
				<li><em class="italic">G</em>: Roll left</li>
				<li><em class="italic">E</em>: Roll right</li>
			</ul>
			<p>The <a id="_idIndexMarker834"/>next <a id="_idIndexMarker835"/>control we’ll look at is <code>THREE.FirstPersonControls</code>.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>FirstPersonControls</h2>
			<p>As the name<a id="_idIndexMarker836"/> implies, <code>FirstPersonControls</code> allows you to control the camera just<a id="_idIndexMarker837"/> like in a first-person shooter. The mouse is used to look around, and the keyboard is used to walk around. You can find an example in <code>07-first-person-camera.html</code>. The following screenshot shows a still image of this example:</p>
			<div><div><img src="img/Figure_9.12_B18726.jpg" alt="Figure 9.12 – Exploring a scene using the first-person controls"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Exploring a scene using the first-person controls</p>
			<p>Creating these controls follows the same principles as the ones followed for the other controls we’ve seen so far:</p>
			<pre class="source-code">
Import { FirstPersonControls } from 'three/examples/jsm/
  controls/FirstPersonControls'
const controls = new FirstPersonControls(camera, renderer.domElement)
const clock = new THREE.Clock()
function animate() {
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
  controls.update(clock.getDelta())
}</pre>
			<p>The<a id="_idIndexMarker838"/> functionality<a id="_idIndexMarker839"/> provided by this control is pretty straightforward:</p>
			<ul>
				<li><strong class="bold">Mouse movement</strong>: Look around</li>
				<li><strong class="bold">Left, right, up, and down arrows</strong>: Move left, right, forward, and backward, respectively</li>
				<li><em class="italic">W</em>: Move forward</li>
				<li><em class="italic">A</em>: Move left</li>
				<li><em class="italic">S</em>: Move backward</li>
				<li><em class="italic">D</em>: Move right</li>
				<li><em class="italic">R</em>: Move up</li>
				<li><em class="italic">F</em>: Move down</li>
				<li><em class="italic">Q</em>: Stop all movement</li>
			</ul>
			<p>For the final<a id="_idIndexMarker840"/> control, we’ll <a id="_idIndexMarker841"/>move on from this first-person perspective to the perspective from space.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>OrbitControls</h2>
			<p>The <code>OrbitControls</code> control<a id="_idIndexMarker842"/> is a great way to rotate and pan around an object in the <a id="_idIndexMarker843"/>center of the scene. This is also the control we used in the other chapters to provide you with a simple way to explore the models in the examples provided.</p>
			<p>With <code>orbit-controls-orbit-camera.html</code>, we’ve included an example that shows how this control works. The following screenshot shows a still image of this example:</p>
			<div><div><img src="img/Figure_9.13_B18726.jpg" alt="Figure 9.13 – OrbitControls properties"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – OrbitControls properties</p>
			<p>Using <code>OrbitControls</code> is just as<a id="_idIndexMarker844"/> simple as using the other controls. Include the correct <a id="_idIndexMarker845"/>JavaScript file, set up the control with the camera, and use <code>THREE.Clock</code> again to update the control:</p>
			<pre class="source-code">
import { OrbitControls } from 'three/examples/jsm/
  controls/OrbitControls'
const controls = new OrbitControls(camera, renderer.
  domElement)
const clock = new THREE.Clock()
function animate() {
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
  controls.update(clock.getDelta())
}</pre>
			<p>The controls for <code>OrbitControls</code> are focused on using the mouse, as shown in the following list:</p>
			<ul>
				<li><strong class="bold">Left mouse click and move</strong>: Rotate the camera around the center of the scene</li>
				<li><strong class="bold">Scroll wheel or middle mouse click and move</strong>: Zoom in and zoom out</li>
				<li><strong class="bold">Right mouse click and move</strong>: Pan around the scene</li>
			</ul>
			<p>That’s it for <a id="_idIndexMarker846"/>the camera<a id="_idIndexMarker847"/> and moving it around. In this section, we saw a lot of controls that allow you to easily interact with and move through a scene by changing the camera properties. In the next section, we’ll look at more advanced methods of animation: morphing and skinning.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Morphing and skeleton animation</h1>
			<p>When you create animations in external programs (for instance, Blender), you usually have two main options to define animations:</p>
			<ul>
				<li><strong class="bold">Morph targets</strong>: With <a id="_idIndexMarker848"/>morph targets, you define a deformed version – that is, a key position – of the mesh. For this deformed target, all vertex positions are stored. All you need to do to animate the shape is move all the vertices from one position to another key position and repeat that process. The following screenshot shows various morph targets used to show facial expressions (this screenshot has been provided by the Blender foundation):</li>
			</ul>
			<div><div><img src="img/Figure_9.14_B18726.jpg" alt="Figure 9.14 – Setting up animations using morph targets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Setting up animations using morph targets</p>
			<ul>
				<li><strong class="bold">Skeleton animation</strong>: An <a id="_idIndexMarker849"/>alternative is using skeleton animation. With skeletal animation, you define the skeleton – that is, the bones – of the mesh and attach vertices to the specific bones. Now, when you move a bone, any connected bone is also moved appropriately, and the attached vertices are moved and deformed based on the position, movement, and scaling of the bone. The following screenshot, once again provided by the Blender foundation, shows an example of how bones can be used to move and deform an object:</li>
			</ul>
			<div><div><img src="img/Figure_9.15_B18726.jpg" alt="Figure 9.15 – Setting up animations using bones"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Setting up animations using bones</p>
			<p>Three.js supports both modes, but there can be an issue getting a good export when you want to work with skeleton/bones-based animations. For the best results, you should export or convert your model into glTF format, which is becoming the default for exchanging models, animations, and scenes, and has great support from Three.js.</p>
			<p>In this section, we’ll look at both options and also look at a couple of external formats supported by Three.js in which animations can be defined.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Animation with morph targets</h2>
			<p>Morph targets <a id="_idIndexMarker850"/>are the most straightforward way of defining an animation. You<a id="_idIndexMarker851"/> define all the vertices for each important position (also called keyframes) and tell Three.js to move the vertices from one position to the other.</p>
			<p>We’ll show you how to work with morph targets using two examples. In the first example, we’ll let Three.js handle the transition between the various keyframes (or morph targets, as we’ll call them from now on), and in the second one, we’ll do this manually. Keep in mind that we are only scratching the surface of what is possible with animations in Three.js. As you’ll see in this section, Three.js has excellent support for controlling animations, supports syncing of animations, and provides ways to smoothly transition from one animation to another, warranting a book just on this subject. So, in the next couple of sections, we’ll provide you with the basics of animations in Three.js, which should provide you with enough information to get started and explore the more complex subjects.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>Animation with a mixer and morph targets</h2>
			<p>Before we dive into the examples, first, we’ll look at the three core classes that you can use to animate with Three.js. Later in this chapter, we’ll show you all the functions and properties provided by these objects:</p>
			<ul>
				<li><code>THREE.AnimationClip</code>: When you<a id="_idIndexMarker852"/> load a model that contains animations, you can look in the <code>response</code> object for a field usually called <code>animations</code>. This field will contain a list of <code>THREE.AnimationClip</code> objects. Note that depending on the loader, an animation might be defined on a <code>Mesh</code>, a <code>Scene</code>, or be provided completely separately. A <code>THREE.AnimationClip</code> most often holds the data for a certain animation the model you loaded can perform. For instance, if you loaded a model of a bird, one <code>THREE.AnimationClip</code> would contain the information needed to flap the wings, and another one might be opening and closing its beak.</li>
				<li><code>THREE.AnimationMixer</code>: <code>THREE.AnimationMixer</code> is<a id="_idIndexMarker853"/> used to control several <code>THREE.AnimationClip</code> objects. It makes sure the timing of the animation is correct and makes it possible to sync animations together, or cleanly move from one animation to another.</li>
				<li><code>THREE.AnimationAction</code>: <code>THREE.AnimationMixer</code> itself doesn’t expose a large number of <a id="_idIndexMarker854"/>functions to control the animation, though. This is done through <code>THREE.AnimationAction</code> objects, which are returned when you add a <code>THREE.AnimationClip</code> to a <code>THREE.AnimationMixer</code> (though you can get them at a later time by using functions provided by <code>THREE.AnimationMixer</code>).</li>
			</ul>
			<p>There is also an <code>AnimationObjectGroup</code>, which you can use to provide the animation state not just to a single <code>Mesh</code> but to a group of objects.</p>
			<p>In the following<a id="_idIndexMarker855"/> example, you can control a <code>THREE.AnimationMixer</code> and <a id="_idIndexMarker856"/>a <code>THREE.AnimationAction</code>, which were created using a <code>THREE.AnimationClip</code> from the model. The <code>THREE.AnimationClip</code> objects used in this example morph a model into a cube and then into a cylinder.</p>
			<p>For this first morphing example, the easiest way to understand how a morph targets-based animation works is by opening up the <code>morph-targets.html</code> example. The following screenshot shows a still image of this example:</p>
			<div><div><img src="img/Figure_9.16_B18726.jpg" alt="Figure 9.16 – Animation using morph targets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Animation using morph targets</p>
			<p>In this <a id="_idIndexMarker857"/>example, we’ve got a simple model (a monkey’s head), which <a id="_idIndexMarker858"/>can be transformed into either a cube or a cylinder using morph targets. You can easily test this yourself by moving the <code>cubeTarget</code> or <code>coneTarget</code> sliders, and you’ll see the head being morphed into a different shape. For instance, with <code>cubeTarget</code> at <code>0.5</code>, you will see that we’re halfway through morphing the monkey’s initial head into a cube. Once it is at <code>1</code>, the initial geometry is morphed completely:</p>
			<div><div><img src="img/Figure_9.17_B18726.jpg" alt="Figure 9.17 – Same model, but now with cubeTarget set to 1"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Same model, but now with cubeTarget set to 1</p>
			<p>And that’s<a id="_idIndexMarker859"/> the basics of how morph animations work. You’ve got <a id="_idIndexMarker860"/>several <code>morphTargets</code> (influences) you can control, and based on their value (from 0 to 1), the vertices move into the desired position. An animation that uses morph targets uses this approach. It just defines at which time certain vertex positions should occur. When running the animation, Three.js will make sure the right values are passed to the <code>morphTargets</code> property of the <code>Mesh</code> instance.</p>
			<p>To run the predefined animation, you can open the <code>AnimationMixer</code> menu for this example, and click <strong class="bold">Play</strong>. You’ll see that the head will first transform into a cube and then into a cylinder, before moving back into the shape of a head.</p>
			<p>Setting up the<a id="_idIndexMarker861"/> required components to accomplish this in Three.js <a id="_idIndexMarker862"/>can be done using the following pieces of code. First, we have to load the model. In this example, we exported this example from Blender into glTF, so our <code>animations</code> are at the top level. We simply add these to a variable that we can access in the other parts of the code. We could also set this as a property on the mesh or add it to the <code>userdata</code> property of <code>Mesh</code>:</p>
			<pre class="source-code">
let animations = []
const loadModel = () =&gt; {
  const loader = new GLTFLoader()
  return loader.loadAsync('/assets/models/blender-morph-targets/morph-targets.gltf').then((container) =&gt; {
    animations = container.animations
    return container.scene
  })
}</pre>
			<p>Now that we’ve got an animation from the loaded model, we can set up the specific Three.js components so that we can play them:</p>
			<pre class="source-code">
const mixer = new THREE.AnimationMixer(mesh)
const action = mixer.clipAction(animations[0])
action.play()</pre>
			<p>There is one final step we need to take so that the correct shape of the mesh is shown whenever we render something, and that is adding a single line to the render loop:</p>
			<pre class="source-code">
// in render loop
mixer.update(clock.getDelta())</pre>
			<p>Here, we used <code>THREE.Clock</code> again to determine the time that’s passed between now and the previous render loop, and called <code>mixer.update()</code>. This information is used by the mixer to determine<a id="_idIndexMarker863"/> how far it should morph the vertices to<a id="_idIndexMarker864"/> the next morph target (keyframe).</p>
			<p><code>THREE.AnimationMixer</code> and <code>THREE.AnimationClip</code> provide several other functions that you can use to control the animation or create new <code>THREE.AnimationClip</code> objects. You can experiment with them by using the menu on the right in the examples for this<a id="_idIndexMarker865"/> section. We will start with <code>THREE.AnimationClip</code>:</p>
			<ul>
				<li><code>duration</code>: The duration of this track (in seconds).</li>
				<li><code>name</code>: The name of this clip.</li>
				<li><code>tracks</code>: The internal property used to keep track of how certain properties of the model are animated.</li>
				<li><code>uuid</code>: The unique ID of this clip. This is assigned automatically.</li>
				<li><code>clone()</code>: Makes a copy of this clip.</li>
				<li><code>optimize()</code>: This optimizes <code>THREE.AnimationClip</code>.</li>
				<li><code>resetDuration()</code>: This determines the correct duration of this clip.</li>
				<li><code>toJson()</code>: Converts this clip into a JSON object.</li>
				<li><code>trim()</code>: This trims all the internal tracks to the duration set on this clip.</li>
				<li><code>validate()</code>: Does some minimal validation to see if this is a valid clip.</li>
				<li><code>CreateClipsFromMorphTargetSequences( name, morphTargetSequences,fps, noLoop)</code>: This creates a list of <code>THREE.AnimationClip</code> instances based on a set of morph target sequences.</li>
				<li><code>CreateFromMorpTargetSequences( name, morphTargetSequence,fps,noLoop)</code>: This creates a single <code>THREE.AnimationClip</code> from a sequence of morph targets.</li>
				<li><code>findByName(objectOrClipArray, name)</code>: Searches for a <code>THREE.AnimationClip</code> by name. </li>
				<li><code>parse</code> and <code>toJson</code>: Allow you to restore and save a <code>Three.AnimationClip</code> as JSON, respectively.</li>
				<li><code>parseAnimation(animation, bones)</code>: Converts an <code>THREE.AnimationClip</code> into <a id="_idIndexMarker866"/>JSON.</li>
			</ul>
			<p>Once you’ve got a <code>THREE.AnimationClip</code>, you can pass it into the <code>THREE.AnimationMixer</code> object, which provides the <a id="_idIndexMarker867"/>following functionality:</p>
			<ul>
				<li><code>AnimationMixer(rootObject)</code>: The constructor for this object. This constructor takes a <code>THREE.Object3D</code> as an argument (for example, a <code>THREE.Mesh</code> of a <code>THREE.Group</code>).</li>
				<li><code>time</code>: The global time for this mixer. This starts at 0, at the time when this mixer is created.</li>
				<li><code>timeScale</code>: This can be used to speed up or slow down all the animations managed by this mixer. If the value of this property is set to 0, all the animations are effectively paused.</li>
				<li><code>clipAction(animationClip, optionalRoot)</code>: This creates a <code>THREE.AnimationAction</code> that can be used to control the passed-in <code>THREE.AnimationClip</code>. If the animation clip is for a different object than what was provided in the constructor of <code>AnimationMixer</code>, you can pass that in as well. </li>
				<li><code>existingAction(animationClip, optionalRoot)</code>: This returns the <code>THREE.AnimationAction</code> property, which can be used to control the passed-in <code>THREE.AnimationClip</code>. Once again, if <code>THREE.AnimationClip</code> is for a <a id="_idIndexMarker868"/>different <code>rootObject</code>, you can also pass that in.</li>
			</ul>
			<p>When you get <code>THREE.AnimationClip</code> back, you <a id="_idIndexMarker869"/>can use it to control the animation:</p>
			<ul>
				<li><code>clampWhenFinished</code>: When set to <code>true</code>, this will cause the animation to be paused when it reaches its last frame. The default is <code>false</code>.</li>
				<li><code>enabled</code>: When set to <code>false</code>, this will disable the current action so that it does not affect the model. When the action is re-enabled, the animation will continue where it left off.</li>
				<li><code>loop</code>: This is the looping mode of this action (which can be set using the <code>setLoop</code> function). This can be set to the following: <ul><li><code>THREE.LoopOnce</code>: Plays the clip only one time</li><li><code>THREE.LoopRepeat</code>: Repeats the clip based on the number of repetitions that have been set</li><li><code>THREE.LoopPingPong</code>: Plays the clip based on the number of repetitions, but alternates between playing the clip forward and backward</li></ul></li>
				<li><code>paused</code>: Setting this property to <code>true</code> will pause the execution of this clip.</li>
				<li><code>repetitions</code>: The number of times the animation will be repeated. This is used by the <code>loop</code> property. The default is <code>Infinity</code>.</li>
				<li><code>time</code>: The time this action has been running. This is wrapped from 0 to the duration of the clip.</li>
				<li><code>timeScale</code>: This can be used to speed up or slow down this animation. If the value of this property is set to <code>0</code>, this animation is effectively paused.</li>
				<li><code>weight</code>: This specifies the effect this animation has on the model from a scale of <code>0</code> to <code>1</code>. When set to <code>0</code>, you won’t see any transformation of the model from this animation, and when set to <code>1</code>, you will see the full effect of this animation.</li>
				<li><code>zeroSlopeAtEnd</code>: When set to true (which is the default), this will make sure there is a smooth transition between separate clips.</li>
				<li><code>zeroSlopeAtStart</code>: When set to true (which is the default), this will make sure there is a smooth transition between separate clips.</li>
				<li><code>crossFadeFrom(fadeOutAction, durationInSeconds, warpBoolean)</code>: This causes this action to fade in, while <code>fadeOutAction</code> is faded out. The total fade takes <code>durationInSeconds</code>. This allows for smooth transitions between animations. When <code>warpBoolean</code> is set to <code>true</code>, it will apply additional smoothing of timescales.</li>
				<li><code>crossFadeTo(fadeInAction, durationInSeconds, warpBoolean)</code>: Same as <code>crossFadeFrom</code>, but this time, it fades in the provided action, and fades out this action.</li>
				<li><code>fadeIn(durationInSeconds)</code>: Increases the <code>weight</code> property slowly from <code>0</code> to <code>1</code> within the passed time interval.</li>
				<li><code>fadeOut(durationInSeconds)</code>: Decreases the <code>weight</code> property slowly from <code>0</code> to <code>1</code> within the passed time interval.</li>
				<li><code>getEffectiveTimeScale()</code>: Returns the effective timescale based on the currently running warp.</li>
				<li><code>getEffectiveWeight()</code>: Returns the effective weight based on the currently running fade.</li>
				<li><code>getClip()</code>: Returns the <code>THREE.AnimationClip</code> property this action is managing.</li>
				<li><code>getMixer()</code>: Returns the mixer that is playing this action.</li>
				<li><code>getRoot()</code>: Gets the root<a id="_idIndexMarker870"/> object that is controlled by this action.</li>
				<li><code>halt(durationInSeconds)</code>: Gradually decreases <code>timeScale</code> to <code>0</code> within <code>durationInSeconds</code>.</li>
				<li><code>isRunning()</code>: Checks whether the animation is currently running.</li>
				<li><code>isScheduled()</code>: Checks whether this action is currently active in the mixer.</li>
				<li><code>play()</code>: Starts running this action (starting the animation).</li>
				<li><code>reset()</code>: Resets this action. This will result in setting <code>paused</code> to <code>false</code>, <code>enabled</code> to <code>true</code>, and <code>time</code> to <code>0</code>.</li>
				<li><code>setDuration(durationInSeconds)</code>: Sets the duration of a single loop. This will change <code>timeScale</code> so that the complete animation can play within <code>durationInSeconds</code>.</li>
				<li><code>setEffectiveTimeScale(timeScale)</code>: Sets <code>timeScale</code> to the provided value.</li>
				<li><code>setEffectiveWeight()</code>: Sets <code>weight</code> to the provided value.</li>
				<li><code>setLoop(loopMode, repetitions)</code>: Sets <code>loopMode</code> and the number of <code>repetitions</code>. See the <code>loop</code> property for the options and their effect.</li>
				<li><code>startAt(startTimeInSeconds)</code>: Delays starting the animation for <code>startTimeInSeconds</code>.</li>
				<li><code>stop()</code>: Stops this action, and <code>reset</code> is applied.</li>
				<li><code>stopFading()</code>: Stops any scheduled fading.</li>
				<li><code>stopWarping()</code>: Stops any schedule warping.</li>
				<li><code>syncWith(otherAction)</code>: Syncs this action with the passed-in action. This will set this action’s <code>time</code> and <code>timeScale</code> value to the passed-in action.</li>
				<li><code>warp(startTimeScale, endTimeScale, durationInSeconds)</code>: Changes the <code>timeScale</code> property from <code>startTimeScale</code> to <code>endTimeScale</code> within the <a id="_idIndexMarker871"/>specified <code>durationInSeconds</code>.</li>
			</ul>
			<p>Besides all the functions and properties that you can use to control the animation, <code>THREE.AnimationMixer</code> also provides two events you can listen to by calling <code>addEventListener</code> on the mixer. The <code>"loop"</code> event is sent when a single loop is finished, and the <code>"finished"</code> event is sent when the complete action has finished.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>Animation using bones and skinning</h2>
			<p>As we <a id="_idIndexMarker872"/>saw in the <em class="italic">Animation with a mixer and morph targets</em> section, morph <a id="_idIndexMarker873"/>animations are very straightforward. Three.js knows all the target vertex positions and only needs to transition each vertex from one position to the next. For bones and skinning, it becomes a bit more complex. When you use bones for animation, you move the bone, and Three.js has to determine how to translate the attached skin (a set of vertices) accordingly. For this example, we will use a model that was exported from Blender into Three.js format (<code>lpp-rigging.gltf</code> in the <code>models/blender-skeleton</code> folder). This is a model of a person, complete with a set of bones. By moving the bones around, we can animate the complete model. First, let’s look at how we loaded the model:</p>
			<pre class="source-code">
let animations = []
const loadModel = () =&gt; {
  const loader = new GLTFLoader()
  return loader.loadAsync('/assets/models/blender-
    skeleton/lpp-rigging.gltf').then((container) =&gt; {
    container.scene.translateY(-2)
    applyShadowsAndDepthWrite(container.scene)
    animations = container.animations
    return container.scene
  })
}</pre>
			<p>We’ve exported the model in glTF format since the support for glTF in Three.js is good. Loading a model for bone animation isn’t that different than any of the other models. We just specify the model file and load it like any other glTF file. For glTF, the animations are in a separate property of the object that is loaded, so we simply assign it to the <code>animations</code> variable for easy access.</p>
			<p>In this <a id="_idIndexMarker874"/>example, we’ve added a console log, which shows <a id="_idIndexMarker875"/>what <code>THREE.Mesh</code> looks like once we’ve loaded it:</p>
			<div><div><img src="img/Figure_9.18_B18726.jpg" alt="Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects</p>
			<p>Here, you can see that the mesh consists of a tree of bones and meshes. This also means that if you move a bone, the relevant meshes will be moved alongside it.</p>
			<p>The following<a id="_idIndexMarker876"/> screenshot shows a still image of this <a id="_idIndexMarker877"/>example:</p>
			<div><div><img src="img/Figure_9.19_B18726.jpg" alt="Figure 9.19 – Manually changing the rotation of the arm and leg bones"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Manually changing the rotation of the arm and leg bones</p>
			<p>This scene also<a id="_idIndexMarker878"/> contains an animation, which you can trigger by<a id="_idIndexMarker879"/> checking the <strong class="bold">animationIsPlaying</strong> checkbox. This will override the manually set bones’ positions and rotations, and has the skeleton kind of jumping up and down:</p>
			<div><div><img src="img/Figure_9.20_B18726.jpg" alt="Figure 9.20 – Playing a skeleton animation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – Playing a skeleton animation</p>
			<p>To set up this animation, we must follow the same steps we saw earlier:</p>
			<pre class="source-code">
const mixer = new THREE.AnimationMixer(mesh)
const action = mixer.clipAction(animations[0])
action.play()</pre>
			<p>As you can <a id="_idIndexMarker880"/>see, working with bones is just as easy as working <a id="_idIndexMarker881"/>with fixed morph targets. In this example, we’ve only adjusted the rotation of the bones; you can also move the position or change the scale. In the next section, we will look at loading animations from external models.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Creating animations using external models</h1>
			<p>In <a href="B18726_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating and Loading Advanced Meshes and Geometries</em>, we looked at several 3D formats that are supported by Three.js. A couple of those formats also support animations. In this chapter, we’ll look at the following examples:</p>
			<ul>
				<li><strong class="bold">COLLADA model</strong>: The COLLADA<a id="_idIndexMarker882"/> format has support for animations. For this example, we’ll load an animation from a COLLADA file and render it with Three.js.</li>
				<li><strong class="bold">MD2 model</strong>: The MD2 model<a id="_idIndexMarker883"/> is a simple format used in the older Quake engines. Even though the format is a bit dated, it is still a very good format for storing character animations.</li>
				<li><strong class="bold">glTF models</strong>: <strong class="bold">GL transmission format</strong> (<strong class="bold">glTF</strong>) is a format specifically designed for storing 3D <a id="_idIndexMarker884"/>scenes and models. It focuses on minimizing the size of the assets and tries to be as efficient as possible in unpacking the models.</li>
				<li><strong class="bold">FBX model</strong>: FBX is <a id="_idIndexMarker885"/>a format produced by the Mixamo<a id="_idIndexMarker886"/> tooling available at <a href="https://www.mixamo.com">https://www.mixamo.com</a>. With Mixamo, you can easily rig and animate models, without needing lots of modeling experience.</li>
				<li><strong class="bold">BVH model</strong>: The <strong class="bold">Biovision</strong> (<strong class="bold">BVH</strong>) format<a id="_idIndexMarker887"/> is a slightly different one compared to the other loaders. With this loader, you don’t load a geometry with a skeleton or a set of animations. With this format, which is used by Autodesk MotionBuilder, you just load a skeleton, which you can visualize or even attach to your geometry.</li>
			</ul>
			<p>We’ll start with a glTF model since this format is becoming the standard for exchanging models between different tools and libraries.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Using gltfLoader</h2>
			<p>A format that is getting more <a id="_idIndexMarker888"/>and more attention lately is the glTF format. This format, for which you can find a very extensive explanation at <a href="https://github.com/KhronosGroup/glTF">https://github.com/KhronosGroup/glTF</a>, focuses on optimizing size and resource usage. Using <code>glTFLoader</code> is similar to using the other loaders:</p>
			<pre class="source-code">
import { GLTFLoader } from 'three/examples
  /jsm/loaders/GLTFLoader'
...
return loader.loadAsync('/assets/models/truffle_man/scene.gltf').
  then((container) =&gt; {
  container.scene.scale.setScalar(4)
  container.scene.translateY(-2)
  scene.add(container.scene)
  
  const mixer = new THREE.AnimationMixer( container.scene ); 
  const animationClip = container.animations[0];
  const clipAction = mixer.clipAction( animationClip ).
play(); 
})</pre>
			<p>This loader also loads a complete scene, so you can either add everything to the group or select child elements. For this <a id="_idIndexMarker889"/>example, you can view the results by opening <code>load-gltf.js</code>:</p>
			<div><div><img src="img/Figure_9.21_B18726.jpg" alt="Figure 9.21 – Animation loaded using glTF"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Animation loaded using glTF</p>
			<p>For the next example, we’ll <a id="_idIndexMarker890"/>use the FBX model.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Visualizing motions captured models using fbxLoader</h2>
			<p>The <a id="_idIndexMarker891"/>Autodesk FBX format has been around for a while and is very easy to use. There is a great resource online where you can find many animations that you can download in this format: <a href="https://www.mixamo.com/">https://www.mixamo.com/</a>. This site provides 2,500 animations that you can use and customize:</p>
			<div><div><img src="img/Figure_9.22_B18726.jpg" alt="Figure 9.22 – Loading animations from mixamo"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – Loading animations from mixamo</p>
			<p>After <a id="_idIndexMarker892"/>downloading an animation, using it from Three.js is easy:</p>
			<pre class="source-code">
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader'
...
loader.loadAsync('/assets/models/salsa/salsa.fbx').then((mesh) =&gt; {
  mesh.translateX(-0.8)
  mesh.translateY(-1.9)
  mesh.scale.set(0.03, 0.03, 0.03)
  scene.add(mesh)
  const mixer = new THREE.AnimationMixer(mesh)
  const clips = mesh.animations
  const clip = THREE.AnimationClip.findByName(clips, 
    'mixamo.com')   
})</pre>
			<p>The resulting animation, as you can see in <code>load-fbx.html</code>, looks great:</p>
			<div><div><img src="img/Figure_9.23_B18726.jpg" alt="Figure 9.23 – Animation loaded using fbx"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Animation loaded using fbx</p>
			<p>FBX and glTF are<a id="_idIndexMarker893"/> modern formats that are used a lot and are a good way to exchange models and animations. There are a couple of older formats around as well. An interesting one is a format used by the old FPS Quake: MD2.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Loading an animation from a Quake model</h2>
			<p>The <a id="_idIndexMarker894"/>MD2 format was created to model characters<a id="_idIndexMarker895"/> from Quake, a great game from 1996. Even though the newer engines use a different format, you can still find a lot of interesting models in the MD2 format. Using an MD2 file is a bit different than using the others we’ve seen so far. When you load an MD2 model, you get a geometry, so you have to make sure that you create a material as well and assign a skin:</p>
			<pre class="source-code">
let animations = []
const loader = new MD2Loader()
loader.loadAsync('/assets/models/ogre/ogro.md2').then
  ((object) =&gt; {
  const mat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    metalness: 0,
    map: new THREE.TextureLoader().load
      ('/assets/models/ogre/skins/skin.jpg')
  })
  animations = object.animations
  const mesh = new THREE.Mesh(object, mat)
  // add to scene, and you can animate it as we've seen 
    already
})</pre>
			<p>Once you have this <code>Mesh</code>, setting up the animation works in the same way. The result of this animation can be seen here (<code>load-md2.html</code>):</p>
			<div><div><img src="img/Figure_9.24_B18726.jpg" alt="Figure 9.24 – Loaded Quake monster"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Loaded Quake monster</p>
			<p>Next up is COLLADA.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Loading an animation from a COLLADA model</h2>
			<p>While the normal COLLADA <a id="_idIndexMarker896"/>models aren’t compressed (and they can get quite large), there is also a <code>KMZLoader</code> available in Three.js. This is a <a id="_idIndexMarker897"/>compressed COLLADA model, so if you run<a id="_idIndexMarker898"/> into <code>KMZLoader</code> instead of <code>ColladaLoader</code>:</p>
			<div><div><img src="img/Figure_9.25_B18726.jpg" alt="Figure 9.25 – Loaded COLLADA model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – Loaded COLLADA model</p>
			<p>For the final loader, we’ll look at <code>BVHLoader</code>.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/>Visualizing a skeleton with BVHLoader</h2>
			<p><code>BVHLoader</code> is a <a id="_idIndexMarker899"/>slightly different loader than the ones we’ve seen<a id="_idIndexMarker900"/> so far. This loader doesn’t return meshes or geometries with animations; instead, it returns a skeleton and an animation. An example of this is shown in <code>load-bvh.html</code>:</p>
			<div><div><img src="img/Figure_9.26_B18726.jpg" alt="Figure 9.26 – Loaded BVH skeleton"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Loaded BVH skeleton</p>
			<p>To visualize this, we<a id="_idIndexMarker901"/> can use a <code>THREE.SkeletonHelper</code>, as<a id="_idIndexMarker902"/> seen here. With a <code>THREE.SkeletonHelper</code>, we can visualize the skeleton of a mesh. BVH models just contain skeleton information, which we can visualize like this:</p>
			<pre class="source-code">
const loader = new BVHLoader()
let animation = undefined
loader.loadAsync('/assets/models//amelia-dance/DanceNightClub7_t1.bvh').then((result) =&gt; {
  const skeletonHelper = new THREE.SkeletonHelper
    (result.skeleton.bones[0])
  skeletonHelper.skeleton = result.skeleton
  const boneContainer = new THREE.Group()
  boneContainer.add(result.skeleton.bones[0])
  animation = result.clip
  const group = new THREE.Group()
  group.add(skeletonHelper)
  group.add(boneContainer)
  group.scale.setScalar(0.2)
  group.translateY(-1.6)
  group.translateX(-3)
  // Now we can animate the group just like we did for the 
    other examples
})</pre>
			<p>In older versions of Three.js, there <a id="_idIndexMarker903"/>was support for other kinds of animation file<a id="_idIndexMarker904"/> formats. Most of those are obsolete and have subsequently been removed from the Three.js distribution. If you do stumble upon a different format in which you want to show the animations, you can look at the older Three.js releases and possibly reuse the loaders from there.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we looked at different ways you can animate your scene. We started with some basic animation tricks, moved on to camera movement and control, and ended by looking at animating models using morph targets and skeleton/bones animations.</p>
			<p>When you have the render loop in place, adding simple animations is very easy. Just change a property of the mesh; in the next rendering step, Three.js will render the updated mesh. For more complex animations, you would usually model them in external programs and load them through one of the loaders provided by Three.js.</p>
			<p>In the previous chapters, we looked at the various materials we can use to skin our objects. For instance, we saw how we can change the color, shininess, and opacity of these materials. What we haven’t discussed in detail yet, however, is how we can use external images (also called textures) together with these materials. With textures, we can easily create objects that look as if they are made out of wood, metal, stone, and much more. In <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, we’ll explore all the different aspects of textures and how they are used in Three.js.</p>
		</div>
	</body></html>