<html><head></head><body>
		<div id="_idContainer200">
			<h1 id="_idParaDest-149" class="chapter-number"><a id="_idTextAnchor148"/>9</h1>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Animation and Moving the Camera</h1>
			<p>In the previous chapters, we saw some simple animations, but nothing too complex. In <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, we introduced the basic rendering loop, and in the chapters following that, we used that to rotate some simple objects and show a couple of other basic animation concepts. </p>
			<p>In this chapter, we’re going to look in more detail at how animation is supported by Three.js. We will look at the following <span class="No-Break">four subjects:</span></p>
			<ul>
				<li><span class="No-Break">Basic animations</span></li>
				<li>Working with <span class="No-Break">the camera</span></li>
				<li>Morphing and <span class="No-Break">skeleton animation</span></li>
				<li>Creating animations using <span class="No-Break">external modes</span></li>
			</ul>
			<p>We will start by covering the basic concepts <span class="No-Break">behind animations.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Basic animations</h1>
			<p>Before we <a id="_idIndexMarker771"/>look at the examples, let’s do a quick recap of what was shown in <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, on the render loop. To support animations, we need to tell Three.js to render the scene every so often. For this, we use the standard HTML5 <strong class="source-inline">requestAnimationFrame</strong> functionality, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();</pre>
			<p>With this code, we only need to call the <strong class="source-inline">render()</strong> function once we’ve initialized the scene. In the <strong class="source-inline">render()</strong> function itself, we use <strong class="source-inline">requestAnimationFrame</strong> to schedule the next rendering. This way, the browser will make sure the <strong class="source-inline">render()</strong> function is called at the correct interval (usually around 60 times or 120 times a second). Before <strong class="source-inline">requestAnimationFrame</strong> was added to browsers, <strong class="source-inline">setInterval(function, interval)</strong> or <strong class="source-inline">setTimeout(function, interval)</strong> was used. These would call the specified function once every set interval. </p>
			<p>The problem with this approach is that it doesn’t take into account what else is going on. Even if your animation isn’t shown or is in a hidden tab, it is still called and is still using resources. Another issue is that these functions update the screen whenever they are called, and not when it is the best time for the browser, which results in higher CPU usage. With <strong class="source-inline">requestAnimationFrame</strong>, we don’t tell the browser when it needs to update the screen; we ask the browser to run the supplied function when it’s most opportune. Usually, this <a id="_idIndexMarker772"/>results in a frame rate of about 60 or 120 FPS (depending on your hardware). With <strong class="source-inline">requestAnimationFrame</strong>, your animations will run more smoothly and will be more CPU- and GPU-friendly, and you don’t have to worry about <span class="No-Break">timing issues.</span></p>
			<p>In the next section, we’ll start with creating a <span class="No-Break">simple animation.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>Simple animations</h2>
			<p>With this approach, we can very <a id="_idIndexMarker773"/>easily animate objects by changing their <strong class="source-inline">rotation</strong>, <strong class="source-inline">scale</strong>, <strong class="source-inline">position</strong>, <strong class="source-inline">material</strong>, vertices, faces, and anything else you can imagine. In the next render loop, Three.js will render the changed properties. A very simple example, based on the one we already saw in <a href="B18726_07.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Points and Sprites</em>, is available in <strong class="source-inline">01-basic-animations.html</strong>. The following screenshot shows <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/Figure_9.1_B18726.jpg" alt="Figure 9.1 – Animation after changing its properties"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Animation after changing its properties</p>
			<p>The render loop for this<a id="_idIndexMarker774"/> is very simple. First, we initialize the various properties on the <strong class="source-inline">userData</strong> object, which is a place for custom data stored in the <strong class="source-inline">THREE.Mesh</strong> itself, and then update these properties on the mesh, using the data we defined on the <strong class="source-inline">userData</strong> object. In the animation loop, just change the rotation, position, and the scale based on<a id="_idIndexMarker775"/> these properties, and Three.js handles the rest. Here’s how we <span class="No-Break">do this:</span></p>
			<pre class="source-code">
const geometry = new THREE.TorusKnotGeometry(2, 0.5, 150, 50, 3, 4)
const material = new THREE.PointsMaterial({
  size: 0.1,
  vertexColors: false,
  color: 0xffffff,
  map: texture,
  depthWrite: false,
  opacity: 0.1,
  transparent: true,
  blending: THREE.AdditiveBlending
})
const points = new THREE.Points(geometry, material)
points.userData.rotationSpeed = 0
points.userData.scalingSpeed = 0
points.userData.bouncingSpeed = 0
points.userData.currentStep = 0
points.userData.scalingStep = 0
// in the render loop
function render() {
  const rotationSpeed = points.userData.rotationSpeed
  const scalingSpeed = points.userData.scalingSpeed
  const bouncingSpeed = points.userData.bouncingSpeed
  const currentStep = points.userData.currentStep
  const scalingStep = points.userData.scalingStep
  points.rotation.x += rotationSpeed
  points.rotation.y += rotationSpeed
  points.rotation.z += rotationSpeed
  points.userData.currentStep = currentStep + bouncingSpeed
  points.position.x = Math.cos(points.userData.currentStep)
  points.position.y = Math.abs(Math.sin
   (points.userData.currentStep)) * 2
  points.userData.scalingStep = scalingStep + scalingSpeed
  var scaleX = Math.abs(Math.sin(scalingStep * 3 + 0.5 * 
    Math.PI))
  var scaleY = Math.abs(Math.cos(scalingStep * 2))
  var scaleZ = Math.abs(Math.sin(scalingStep * 4 + 0.5 * 
    Math.PI))
  points.scale.set(scaleX, scaleY, scaleZ)
}</pre>
			<p>There’s nothing spectacular here, but it nicely shows the concept behind the basic animations we will discuss in this book. We just change the <strong class="source-inline">scale</strong>, <strong class="source-inline">rotation</strong>, and <strong class="source-inline">position</strong> properties and <a id="_idIndexMarker776"/>Three.js does the rest. </p>
			<p>In the next section, we’ll take a quick sidestep. Besides animations, an important aspect that you’ll quickly run into when working with Three.js in more complex scenes is the ability to select objects on the screen using <span class="No-Break">the mouse.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Selecting and moving objects</h2>
			<p>Even though not directly related to animations, since we’ll be looking at cameras and animations in this chapter, knowing how to select and move objects is a nice addition to the subjects explained in this chapter. Here, we will show you how to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Select an object from a scene using <span class="No-Break">the mouse</span></li>
				<li>Drag an object around the scene with <span class="No-Break">the mouse</span></li>
			</ul>
			<p>We’ll start by looking at the steps you need to take to select <span class="No-Break">an object.</span></p>
			<h3>Selecting objects</h3>
			<p>First, open<a id="_idIndexMarker777"/> the <strong class="source-inline">selecting-objects.html</strong> example, where you’ll see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/Figure_9.2_B18726.jpg" alt="Figure 9.2 – Randomly placed cubes that can be selected with the mouse"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Randomly placed cubes that can be selected with the mouse</p>
			<p>When you move the<a id="_idIndexMarker778"/> mouse around the scene, you’ll see that whenever your mouse hits an object, that object is highlighted. You can easily create this by using a <strong class="source-inline">THREE.Raycaster</strong>. A raycaster<a id="_idIndexMarker779"/> will look at your current camera and cast a ray from the camera to your mouse’s position. Based on that, it can calculate which object is hit based on the position of the mouse. To accomplish this, we need to take the <span class="No-Break">following steps:</span></p>
			<ul>
				<li>Create an object that keeps track of where the mouse is <span class="No-Break">pointing at</span></li>
				<li>Whenever we move the mouse, update <span class="No-Break">that object</span></li>
				<li>In the render loop, use this updated information to see which Three.js object we’re <span class="No-Break">pointing at</span></li>
			</ul>
			<p>This is shown in the<a id="_idIndexMarker780"/> following <span class="No-Break">code fragment:</span></p>
			<pre class="source-code">
// initially set the position to -1, -1
let pointer = {
  x: -1,
  y: -1
}
// when the mouse moves update the point
document.addEventListener('mousemove', (event) =&gt; {
  pointer.x = (event.clientX / window.innerWidth) * 2 - 1
  pointer.y = -(event.clientY / window.innerHeight) * 2 + 1
})
// an array containing all the cubes in the scene
const cubes = ...
// use in the render loop to determine the object to highlight
const raycaster = new THREE.Raycaster()
function render() {
  raycaster.setFromCamera(pointer, camera)
  const cubes = scene.getObjectByName('group').children
  const intersects = raycaster.intersectObjects(cubes)
  // do something with the intersected objects
}</pre>
			<p>Here, we are using <strong class="source-inline">THREE.Raycaster</strong> to determine which objects intersect the position of the mouse, from the point of the camera. The result (<strong class="source-inline">intersects</strong>, in the preceding example) contains all the cubes that intersected our mouse because the ray is cast from the camera’s position through to the end of the camera’s range. The first one in this array is the one that we’re hovering over, and the other values in this array (if any) point to objects behind the first mesh. <strong class="source-inline">THREE.Raycaster</strong> also provides other information about exactly where you hit <span class="No-Break">the object:</span></p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/Figure_9.3_B18726.jpg" alt="Figure 9.3 – Additional information from the raycaster"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Additional information from the raycaster</p>
			<p>Here, we clicked<a id="_idIndexMarker781"/> on the <strong class="source-inline">face</strong> object. <strong class="source-inline">faceIndex</strong> points to the face of the mesh that was selected. The <strong class="source-inline">distance</strong> value is measured from the camera to the clicked object, and <strong class="source-inline">point</strong> is the exact position on the mesh where it was clicked. Finally, we have the <strong class="source-inline">uv</strong> value, which determines, when using textures, where the point that was clicked appears on the 2D texture (ranging from 0 to 1; more information on <strong class="source-inline">uv</strong> can be found in <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working </em><span class="No-Break"><em class="italic">With Textures</em></span><span class="No-Break">).</span></p>
			<h3>Dragging objects</h3>
			<p>Besides selecting an <a id="_idIndexMarker782"/>object, a common requirement is being able to drag and move objects around. Three.js also provides default support for this. If you open the <strong class="source-inline">dragging-objects.html</strong> example in your browser, you’ll see a similar scene to the one shown in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.2</em>. This time, when you click on an object, you can drag it around <span class="No-Break">the scene:</span></p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/Figure_9.4_B18726.jpg" alt="Figure 9.4 – Dragging an object around the scene using the mouse"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Dragging an object around the scene using the mouse</p>
			<p>To support<a id="_idIndexMarker783"/> dragging objects, Three.js uses something called <strong class="source-inline">DragControls</strong>. This handles everything and provides convenient callbacks whenever the dragging starts and stops. The code to accomplish this is <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
const orbit = new OrbitControls(camera, renderer.domElement)
orbit.update()
const controls = new DragControls(cubes, camera, renderer.domElement)
controls.addEventListener('dragstart', function (event) {
  orbit.enabled = false
  event.object.material.emissive.set(0x33333)
})
controls.addEventListener('dragend', function (event) {
  orbit.enabled = true
  event.object.material.emissive.set(0x000000)
})</pre>
			<p>It is as simple as that. Here, we added <strong class="source-inline">DragControls</strong> and passed in the elements that can be dragged (in our case, all of the randomly placed cubes). Then, we added two event listeners. The first one, <strong class="source-inline">dragstart</strong>, is called when we start dragging a cube, whereas <strong class="source-inline">dragend</strong> is called when we stop dragging an object. In this example, when we start dragging, we disable <strong class="source-inline">OrbitControls</strong> (which allows us to use the mouse to look around the scene) and change the color of the selected object. Once we stop dragging, we change the color of the object back and enable <span class="No-Break"><strong class="source-inline">OrbitControls</strong></span><span class="No-Break"> again.</span></p>
			<p>There is also a <a id="_idIndexMarker784"/>somewhat more advanced version of <strong class="source-inline">DragControls</strong> available called <strong class="source-inline">TransformControls</strong>. We won’t go into the details of this control, but it allows you to use a simple UI to transform the properties of a mesh. You can find an example of this control when you open <strong class="source-inline">transform-controls-html</strong> in <span class="No-Break">your browser:</span></p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/Figure_9.5_B18726.jpg" alt="Figure 9.5 – Transform controls allow you to change the properties of a mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Transform controls allow you to change the properties of a mesh</p>
			<p>If you click on the<a id="_idIndexMarker785"/> various parts of this control, you can easily change the shape of <span class="No-Break">the cube:</span></p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/Figure_9.6_B18726.jpg" alt="Figure 9.6 – Shape modified using transform controls"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Shape modified using transform controls</p>
			<p>For the final <a id="_idIndexMarker786"/>example in this chapter, we’ll show you how you can use an alternative way of modifying the properties of an object (as we saw in the first example of this chapter) by using a <span class="No-Break">tweening library.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Animating with Tween.js</h2>
			<p>Tween.js is <a id="_idIndexMarker787"/>a small JavaScript library that you can download from <a href="https://github.com/sole/tween.js/">https://github.com/sole/tween.js/</a> and that you can use to easily define the transition of a property between two values. All the intermediate points between the start and end values are calculated for you. This process is <a id="_idIndexMarker788"/>called <strong class="bold">tweening</strong>. For instance, you can <a id="_idIndexMarker789"/>use this library to change the <strong class="source-inline">x</strong> position of a mesh from 10 to 3 in 10 seconds, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const tween = new TWEEN.Tween({x: 10}).to({x: 3}, 10000)
.easing(TWEEN.Easing.Elastic.InOut)
.onUpdate( function () {
  // update the mesh
})</pre>
			<p>Alternatively, you can create a separate object and pass that into the mesh you want to <span class="No-Break">work with:</span></p>
			<pre class="source-code">
  const tweenData = {
    x: 10
  }
  new TWEEN.Tween(tweenData)
    .to({ x: 3 }, 10000)
    .yoyo(true)
    .repeat(Infinity)
    .easing(TWEEN.Easing.Bounce.InOut)
    .start()
  mesh.userData.tweenData = tweenData    </pre>
			<p>In this example, we’ve created <strong class="source-inline">TWEEN.Tween</strong>. This tween will make sure that the <strong class="source-inline">x</strong> property is changed from 10 to 3 over 10,000 milliseconds. Tween.js also allows you to define how this property is changed over time. This can be done using linear, quadratic, or any of the other possibilities (see <a href="http://sole.github.io/tween.js/examples/03_graphs.html">http://sole.github.io/tween.js/examples/03_graphs.html</a> for a complete overview). The value is changed over time by a process<a id="_idIndexMarker790"/> called <strong class="bold">easing</strong>. With Tween.js, you configure this using the <strong class="source-inline">easing()</strong> function. This library also provides additional ways to control how this easing is done. For instance, we can set how often the easing should be repeated (<strong class="source-inline">repeat(10)</strong>) and whether we want a yoyo effect (this means we go from 10 to 3 and back to 10 in <span class="No-Break">this example).</span></p>
			<p>Using this library <a id="_idIndexMarker791"/>together with Three.js is very simple. If you open the <strong class="source-inline">tween-animations.html</strong> example, you will see the Tween.js library in action. The following screenshot shows a still image of <span class="No-Break">the example:</span></p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/Figure_9.7_B18726.jpg" alt="Figure 9.7 – Tweening a point system halfway through the action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Tweening a point system halfway through the action</p>
			<p>We’ll use the Tween.js library to move this to a single point using a specific <strong class="source-inline">easing()</strong>, which at a certain point looks <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/Figure_9.8_B18726.jpg" alt="Figure 9.8 – Tweening a point when everything is merged into a single point"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Tweening a point when everything is merged into a single point</p>
			<p>In this example, we’ve<a id="_idIndexMarker792"/> taken a point cloud from <a href="B18726_07.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, and created an animation where all the points slowly move down to the center. The position of these particles is set by using a tween created with the Tween.js library, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const geometry = new THREE.TorusKnotGeometry(2, 0.5, 150, 50, 3, 4)
geometry.setAttribute('originalPos', geometry.attributes['position'].clone())
const material = new THREE.PointsMaterial(..)
const points = new THREE.Points(geometry, material)
const tweenData = {
  pos: 1
}
new TWEEN.Tween(tweenData)
  .to({ pos: 3 }, 10000)
  .yoyo(true)
  .repeat(Infinity)
  .easing(TWEEN.Easing.Bounce.InOut)
  .start()
points.userData.tweenData = tweenData    
// in the render loop
const originalPosArray = points.geometry.attributes.originalPos.array
const positionArray = points.geometry.attributes.position.array
TWEEN.update()
 for (let i = 0; i &lt; points.geometry.attributes.position.count; i++) {
  positionArray[i * 3] = originalPosArray[i * 3] * points.userData.tweenData.pos
  positionArray[i * 3 + 1] = originalPosArray[i * 3 + 1] * points.userData.tweenData.pos
  positionArray[i * 3 + 2] = originalPosArray[i * 3 + 2] * points.userData.tweenData.pos
}
points.geometry.attributes.position.needsUpdate = true</pre>
			<p>With this piece<a id="_idIndexMarker793"/> of code, we created a tween that transitions a value from <strong class="source-inline">1</strong> to <strong class="source-inline">0</strong> and back again. To use the value from the tween, we have two different options: we can use the <strong class="source-inline">onUpdate</strong> function provided by this library to call a function with the updated values, whenever the tween is updated (which is done by calling <strong class="source-inline">TWEEN.update()</strong>), or we can directly access the updated values. In this example, we used the latter approach. </p>
			<p>Before we look at the changes we need to make in the <strong class="source-inline">render</strong> function, we must perform one additional step after we load the model. We want to tween between the original values to zero and back again. For this, we need to store the original positions of the vertices somewhere. We can do this by copying the starting <span class="No-Break">positions array:</span></p>
			<pre class="source-code">
geometry.setAttribute('originalPos', geometry.attributes['position'].clone())</pre>
			<p>Now, whenever we want to access the original position, we can look at the <strong class="source-inline">originalPos</strong> attribute on the geometry. Now, we can just use the value from the tween to calculate the new positions of each of the vertices. We can do this like so in the <span class="No-Break">render loop:</span></p>
			<pre class="source-code">
const originalPosArray = points.geometry.attributes.originalPos.array
const positionArray = points.geometry.attributes.position.array
for (let i = 0; i &lt; points.geometry.attributes.position.count; i++) {
  positionArray[i * 3] = originalPosArray[i * 3] * points.userData.tweenData.pos
  positionArray[i * 3 + 1] = originalPosArray[i * 3 + 1] * points.userData.tweenData.pos
  positionArray[i * 3 + 2] = originalPosArray[i * 3 + 2] * points.userData.tweenData.pos
}
points.geometry.attributes.position.needsUpdate = true</pre>
			<p>With these steps<a id="_idIndexMarker794"/> in place, the tween library will take care of positioning the various points on the screen. As you can see, using this library is much easier than having to manage the transitions yourself. Besides animating and changing objects, we can also animate a scene by moving the camera around. In the previous chapters, we did this a couple of times by manually updating the position of the camera. Three.js also provides several additional ways of updating <span class="No-Break">the camera.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>Working with the camera</h1>
			<p>Three.js has several <a id="_idIndexMarker795"/>camera controls you can use to control the camera throughout a scene. These controls are located in the Three.js distribution and can be found in the <strong class="source-inline">examples/js/controls</strong> directory. In this section, we’ll look at the following controls in <span class="No-Break">more detail:</span></p>
			<ul>
				<li><strong class="source-inline">ArcballControls</strong>: An<a id="_idIndexMarker796"/> extensive control that provides a transparent <a id="_idIndexMarker797"/>overlay that you can use to easily move the <span class="No-Break">camera around.</span></li>
				<li><strong class="source-inline">FirstPersonControls</strong>: These<a id="_idIndexMarker798"/> are controls that<a id="_idIndexMarker799"/> behave like those in first-person shooters. You can move around with the keyboard and look around with <span class="No-Break">the mouse.</span></li>
				<li><strong class="source-inline">FlyControls</strong>: These<a id="_idIndexMarker800"/> are flight simulator-like controls. You can move<a id="_idIndexMarker801"/> and steer with the keyboard and <span class="No-Break">the mouse.</span></li>
				<li><strong class="source-inline">OrbitControls</strong>: This <a id="_idIndexMarker802"/>simulates a satellite in orbit around a specific scene. This <a id="_idIndexMarker803"/>allows you to move around with the mouse <span class="No-Break">and keyboard.</span></li>
				<li><strong class="source-inline">PointerLockControls</strong>: These are <a id="_idIndexMarker804"/>similar to the first-person controls but they also lock the mouse pointer to the screen, making it a great<a id="_idIndexMarker805"/> choice for <span class="No-Break">simple games.</span></li>
				<li><strong class="source-inline">TrackBallControls</strong>: These are <a id="_idIndexMarker806"/>the most-used controls, allowing you to use the mouse (or the trackball) to easily move, pan, and zoom <a id="_idIndexMarker807"/>around <span class="No-Break">the scene.</span></li>
			</ul>
			<p>Besides using these camera controls, you can also move the camera yourself by setting its position and changing where it is pointed using the <span class="No-Break"><strong class="source-inline">lookAt()</strong></span><span class="No-Break"> function.</span></p>
			<p>The first control we’ll look at <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">ArcballControls</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>ArcballControls</h2>
			<p>The<a id="_idIndexMarker808"/> easiest way to<a id="_idIndexMarker809"/> explain how <strong class="source-inline">ArcballControls</strong> works is by looking at an example. If you open up the <strong class="source-inline">arcball-controls.html</strong> example, you’ll see a simple scene, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/Figure_9.9_B18726.jpg" alt="Figure 9.9 – Using ArcballControls to explore a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Using ArcballControls to explore a scene</p>
			<p>If you look <a id="_idIndexMarker810"/>closely at this screenshot, you will see two translucent lines <a id="_idIndexMarker811"/>crossing the scene. These are lines provided by <strong class="source-inline">ArcballControls</strong>, which you can use to rotate and pan around the scene. These lines are<a id="_idIndexMarker812"/> called <strong class="bold">gizmos</strong>. The left mouse button is used to rotate the scene, the right mouse button can be used to pan around, and you can zoom in with the <span class="No-Break">scroll wheel.</span></p>
			<p>Besides this standard functionally, this control also allows you to focus on specific parts of the mesh that is shown. If you double-click on the scene, the camera will focus on that part of the scene. To use this control, all we need to do is instantiate it and pass in the <strong class="source-inline">camera</strong> property, the <strong class="source-inline">domElement</strong> property used by the renderer, and the <strong class="source-inline">scene</strong> property we’re <span class="No-Break">looking at:</span></p>
			<pre class="source-code">
import { ArcballControls } from 'three/examples/jsm/controls/ArcballControls'
const controls = new ArcballControls(camera, renderer.domElement, scene)
controls.update()</pre>
			<p>This control is a <a id="_idIndexMarker813"/>very versatile one, which can be configured through a set of properties. Most of these properties can be explored in this example by using the menu on the right of this example. For this specific control, we’ll dive a bit deeper into the properties and methods provided by this object since it is a versatile control and a good choice when you want to provide a good way for your users to explore your scenes. Let’s provide an overview of the properties and the methods provided by this control. First, let’s<a id="_idIndexMarker814"/> look at <span class="No-Break">the properties:</span></p>
			<ul>
				<li><strong class="source-inline">adjustNearFar</strong>: If this is set to <strong class="source-inline">true</strong>, this control will change the camera’s <strong class="source-inline">near</strong> and <strong class="source-inline">far</strong> properties when <span class="No-Break">zooming in</span></li>
				<li><strong class="source-inline">camera</strong>: The camera that’s used when creating <span class="No-Break">this control</span></li>
				<li><strong class="source-inline">cursorZoom</strong>: If set to <strong class="source-inline">true</strong>, when zooming in, the zoom will be focused on the position of <span class="No-Break">the cursor</span></li>
				<li><strong class="source-inline">dampingFactor</strong>: If <strong class="source-inline">enableAnimations</strong> is set to <strong class="source-inline">true</strong>, this value will determine how quickly an animation stops after <span class="No-Break">an action</span></li>
				<li><strong class="source-inline">domElement</strong>: This element is used to list <span class="No-Break">mouse events</span></li>
				<li><strong class="source-inline">enabled</strong>: Determines whether this control is enabled <span class="No-Break">or not</span></li>
				<li><strong class="source-inline">enableRotate</strong>, <strong class="source-inline">enableZoom</strong>, <strong class="source-inline">enablePan</strong>, <strong class="source-inline">enableGrid</strong>, <strong class="source-inline">enableAnimations</strong>: These properties enable and disable functionality provided by <span class="No-Break">this control</span></li>
				<li><strong class="source-inline">focusAnimationTime</strong>: When we double-click and focus on part of the scene, this property determines the duration of the <span class="No-Break">focusing animation</span></li>
				<li><strong class="source-inline">maxDistance</strong>/<strong class="source-inline">minDistance</strong>: How far we can zoom out and in <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">PerspectiveCamera</strong></span></li>
				<li><strong class="source-inline">maxZoom</strong>/<strong class="source-inline">minZoom</strong>: How far we can zoom out and in <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">OrthographicCamera</strong></span></li>
				<li><strong class="source-inline">scaleFactor</strong>: How fast we zoom in <span class="No-Break">and out</span></li>
				<li><strong class="source-inline">scene</strong>: The scene passed in <span class="No-Break">the constructor</span></li>
				<li><strong class="source-inline">radiusFactor</strong>: The size of the “gizmo” relative to the screen’s width <span class="No-Break">and height</span></li>
				<li><strong class="source-inline">wMax</strong>: How <a id="_idIndexMarker815"/>fast <a id="_idIndexMarker816"/>we’re allowed to rotate <span class="No-Break">the scene</span></li>
			</ul>
			<p>This control also provides several methods to <a id="_idIndexMarker817"/>interact or configure <span class="No-Break">it further:</span></p>
			<ul>
				<li><strong class="source-inline">activateGizmos(bool)</strong>: If <strong class="source-inline">true</strong>, it highlights <span class="No-Break">the gizmos</span></li>
				<li><strong class="source-inline">copyState()</strong>, <strong class="source-inline">pasteState()</strong>: Allows you to copy and paste the state of the controls to the clipboard <span class="No-Break">in JSON</span></li>
				<li><strong class="source-inline">saveState()</strong>, <strong class="source-inline">reset()</strong>: Internally saves the current state and uses <strong class="source-inline">reset()</strong> to apply the <span class="No-Break">saved state</span></li>
				<li><strong class="source-inline">dispose()</strong>: Removes all parts of this control from the scene, and cleans up any listeners <span class="No-Break">and animations</span></li>
				<li><strong class="source-inline">setGizomsVisible(bool)</strong>: Specifies whether to show or hide <span class="No-Break">the gizmos</span></li>
				<li><strong class="source-inline">setTbRadius(radiusFactor)</strong>: Updates the <strong class="source-inline">radiusFactor</strong> property and redraws <span class="No-Break">the gizmos</span></li>
				<li><strong class="source-inline">setMouseAction(operation, mouse, key)</strong>: Determines which mouse key provides <span class="No-Break">which action</span></li>
				<li><strong class="source-inline">unsetMouseAction(mouse, key)</strong>: Clears an assigned <span class="No-Break">mouse action</span></li>
				<li><strong class="source-inline">update()</strong>: Whenever the camera properties change, call this to apply these new settings to <span class="No-Break">this control</span></li>
				<li><strong class="source-inline">getRayCaster()</strong>: Provides access to <strong class="source-inline">rayCaster</strong>, which is <a id="_idIndexMarker818"/>used internally by <span class="No-Break">these </span><span class="No-Break"><a id="_idIndexMarker819"/></span><span class="No-Break">controls</span></li>
			</ul>
			<p><strong class="source-inline">ArcballControls</strong> is a really useful and relatively new addition to Three.js that provides advanced control of the scene using the mouse. If you’re looking for a simpler approach, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">TrackBallControls</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>TrackBallControls</h2>
			<p>Using <strong class="source-inline">TrackBallControls</strong> follows the <a id="_idIndexMarker820"/>same approach as we<a id="_idIndexMarker821"/> saw <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">ArcballControls</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import { TrackBallControls } from 'three/examples/jsm/
  controls/TrackBallControls'
const controls = new TrackBallControls(camera, renderer.
  domElement)</pre>
			<p>This time, we just need to pass in the <strong class="source-inline">camera</strong> and <strong class="source-inline">domeElement</strong> properties from the renderer. For the trackball controls to work, we also need to add a <strong class="source-inline">THREE.Clock</strong> and update the render loop, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
const clock = new THREE.Clock()
function animate() {
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
  controls.update(clock.getDelta())
}</pre>
			<p>In the preceding code snippet, we can see a new Three.js object, <strong class="source-inline">THREE.Clock</strong>. The <strong class="source-inline">THREE.Clock</strong> object can be used to calculate the elapsed time that a specific invocation or rendering loop takes to complete. You can do this by calling the <strong class="source-inline">clock.getDelta()</strong> function. This function will return the elapsed time between this call and the previous call to <strong class="source-inline">getDelta()</strong>. To update the position of the camera, we can call the <strong class="source-inline">TrackBallControls.update()</strong> function. In this function, we need to provide the time that has passed since the last time this update function was called. For this, we can use the <strong class="source-inline">getDelta()</strong> function from the <strong class="source-inline">THREE.Clock</strong> object. You might be wondering why we don’t just pass in the frame rate (1/60 seconds) to the update function. The reason is that with <strong class="source-inline">requestAnimationFrame</strong>, we can expect 60 FPS, but this isn’t<a id="_idIndexMarker822"/> guaranteed. Depending <a id="_idIndexMarker823"/>on all kinds of external factors, the frame rate might change. To make sure the camera turns and rotates smoothly, we need to pass in the exact <span class="No-Break">elapsed time.</span></p>
			<p>A working example of this can be found in <strong class="source-inline">trackball-controls-camera.html</strong>. The following screenshot shows a still image of <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/Figure_9.10_B18726.jpg" alt="Figure 9.10 – Using TrackBallControls to control a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Using TrackBallControls to control a scene</p>
			<p>You can control the <a id="_idIndexMarker824"/>camera in the <span class="No-Break">following manner:</span></p>
			<ul>
				<li><strong class="bold">Left mouse button and move</strong>: Rotate and roll the camera around <span class="No-Break">the scene</span></li>
				<li><strong class="bold">Scroll wheel</strong>: Zoom in and <span class="No-Break">zoom out</span></li>
				<li><strong class="bold">Middle mouse button and move</strong>: Zoom in and <span class="No-Break">zoom out</span></li>
				<li><strong class="bold">Right mouse button and move</strong>: Pan<a id="_idIndexMarker825"/> around <span class="No-Break">the scene</span></li>
			</ul>
			<p>There are a<a id="_idIndexMarker826"/> couple of properties that you can use to fine-tune how the camera acts. For instance, you can set how fast the camera rotates with the <strong class="source-inline">rotateSpeed</strong> property and <a id="_idIndexMarker827"/>disable zooming by setting the <strong class="source-inline">noZoom</strong> property to <strong class="source-inline">true</strong>. In this chapter, we won’t go into detail on what each property does as they are pretty much self-explanatory. For a complete overview of what is possible, look at the source of the <strong class="source-inline">TrackBallControls.js</strong> file, where these properties <span class="No-Break">are listed.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>FlyControls</h2>
			<p>The next control <a id="_idIndexMarker828"/>we’ll look at is <strong class="source-inline">FlyControls</strong>. With <strong class="source-inline">FlyControls</strong>, you<a id="_idIndexMarker829"/> can fly around a scene using controls also found in flight simulators. An example can be found in <strong class="source-inline">fly-controls-camera.html</strong>. The following screenshot shows a still image of <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/Figure_9.11_B18726.jpg" alt="Figure 9.11 – Using FlyControls to fly around a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Using FlyControls to fly around a scene</p>
			<p>Enabling <strong class="source-inline">FlyControls</strong> works in the<a id="_idIndexMarker830"/> same<a id="_idIndexMarker831"/> manner as the <span class="No-Break">other controls:</span></p>
			<pre class="source-code">
import { FlyControls } from 'three/examples/jsm/controls/FlyControls'
const controls = new FlyControls(camera, renderer.domElement)
const clock = new THREE.Clock()
function animate() {
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
  controls.update(clock.getDelta())
}</pre>
			<p><strong class="source-inline">FlyControls</strong> takes <a id="_idIndexMarker832"/>the camera and the renderer’s <strong class="source-inline">domElement</strong> as arguments and<a id="_idIndexMarker833"/> requires that you call the <strong class="source-inline">update()</strong> function with the elapsed time in the render loop. You can control the camera with <strong class="source-inline">THREE.FlyControls</strong> in the <span class="No-Break">following manner:</span></p>
			<ul>
				<li><strong class="bold">Left and middle mouse buttons</strong>: Start <span class="No-Break">moving forward</span></li>
				<li><strong class="bold">Right mouse button</strong>: <span class="No-Break">Move backward</span></li>
				<li><strong class="bold">Mouse movement</strong>: <span class="No-Break">Look around</span></li>
				<li><em class="italic">W</em>: Start <span class="No-Break">moving forward</span></li>
				<li><em class="italic">S</em>: <span class="No-Break">Move backward</span></li>
				<li><em class="italic">A</em>: <span class="No-Break">Move left</span></li>
				<li><em class="italic">D</em>: <span class="No-Break">Move right</span></li>
				<li><em class="italic">R</em>: <span class="No-Break">Move up</span></li>
				<li><em class="italic">F</em>: <span class="No-Break">Move down</span></li>
				<li><strong class="bold">Left, right, up, and down arrows</strong>: Look left, right, up, and <span class="No-Break">down, respectively</span></li>
				<li><em class="italic">G</em>: <span class="No-Break">Roll left</span></li>
				<li><em class="italic">E</em>: <span class="No-Break">Roll right</span></li>
			</ul>
			<p>The <a id="_idIndexMarker834"/>next <a id="_idIndexMarker835"/>control we’ll look at <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">THREE.FirstPersonControls</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>FirstPersonControls</h2>
			<p>As the name<a id="_idIndexMarker836"/> implies, <strong class="source-inline">FirstPersonControls</strong> allows you to control the camera just<a id="_idIndexMarker837"/> like in a first-person shooter. The mouse is used to look around, and the keyboard is used to walk around. You can find an example in <strong class="source-inline">07-first-person-camera.html</strong>. The following screenshot shows a still image of <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/Figure_9.12_B18726.jpg" alt="Figure 9.12 – Exploring a scene using the first-person controls"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Exploring a scene using the first-person controls</p>
			<p>Creating these controls follows the same principles as the ones followed for the other controls we’ve seen <span class="No-Break">so far:</span></p>
			<pre class="source-code">
Import { FirstPersonControls } from 'three/examples/jsm/
  controls/FirstPersonControls'
const controls = new FirstPersonControls(camera, renderer.domElement)
const clock = new THREE.Clock()
function animate() {
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
  controls.update(clock.getDelta())
}</pre>
			<p>The<a id="_idIndexMarker838"/> functionality<a id="_idIndexMarker839"/> provided by this control is <span class="No-Break">pretty straightforward:</span></p>
			<ul>
				<li><strong class="bold">Mouse movement</strong>: <span class="No-Break">Look around</span></li>
				<li><strong class="bold">Left, right, up, and down arrows</strong>: Move left, right, forward, and <span class="No-Break">backward, respectively</span></li>
				<li><em class="italic">W</em>: <span class="No-Break">Move forward</span></li>
				<li><em class="italic">A</em>: <span class="No-Break">Move left</span></li>
				<li><em class="italic">S</em>: <span class="No-Break">Move backward</span></li>
				<li><em class="italic">D</em>: <span class="No-Break">Move right</span></li>
				<li><em class="italic">R</em>: <span class="No-Break">Move up</span></li>
				<li><em class="italic">F</em>: <span class="No-Break">Move down</span></li>
				<li><em class="italic">Q</em>: Stop <span class="No-Break">all movement</span></li>
			</ul>
			<p>For the final<a id="_idIndexMarker840"/> control, we’ll <a id="_idIndexMarker841"/>move on from this first-person perspective to the perspective <span class="No-Break">from space.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>OrbitControls</h2>
			<p>The <strong class="source-inline">OrbitControls</strong> control<a id="_idIndexMarker842"/> is a great way to rotate and pan around an object in the <a id="_idIndexMarker843"/>center of the scene. This is also the control we used in the other chapters to provide you with a simple way to explore the models in the <span class="No-Break">examples provided.</span></p>
			<p>With <strong class="source-inline">orbit-controls-orbit-camera.html</strong>, we’ve included an example that shows how this control works. The following screenshot shows a still image of <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/Figure_9.13_B18726.jpg" alt="Figure 9.13 – OrbitControls properties"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – OrbitControls properties</p>
			<p>Using <strong class="source-inline">OrbitControls</strong> is just as<a id="_idIndexMarker844"/> simple as using the other controls. Include the correct <a id="_idIndexMarker845"/>JavaScript file, set up the control with the camera, and use <strong class="source-inline">THREE.Clock</strong> again to update <span class="No-Break">the control:</span></p>
			<pre class="source-code">
import { OrbitControls } from 'three/examples/jsm/
  controls/OrbitControls'
const controls = new OrbitControls(camera, renderer.
  domElement)
const clock = new THREE.Clock()
function animate() {
  requestAnimationFrame(animate)
  renderer.render(scene, camera)
  controls.update(clock.getDelta())
}</pre>
			<p>The controls for <strong class="source-inline">OrbitControls</strong> are focused on using the mouse, as shown in the <span class="No-Break">following list:</span></p>
			<ul>
				<li><strong class="bold">Left mouse click and move</strong>: Rotate the camera around the center of <span class="No-Break">the scene</span></li>
				<li><strong class="bold">Scroll wheel or middle mouse click and move</strong>: Zoom in and <span class="No-Break">zoom out</span></li>
				<li><strong class="bold">Right mouse click and move</strong>: Pan around <span class="No-Break">the scene</span></li>
			</ul>
			<p>That’s it for <a id="_idIndexMarker846"/>the camera<a id="_idIndexMarker847"/> and moving it around. In this section, we saw a lot of controls that allow you to easily interact with and move through a scene by changing the camera properties. In the next section, we’ll look at more advanced methods of animation: morphing <span class="No-Break">and skinning.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Morphing and skeleton animation</h1>
			<p>When you create animations in external programs (for instance, Blender), you usually have two main options to <span class="No-Break">define animations:</span></p>
			<ul>
				<li><strong class="bold">Morph targets</strong>: With <a id="_idIndexMarker848"/>morph targets, you define a deformed version – that is, a key position – of the mesh. For this deformed target, all vertex positions are stored. All you need to do to animate the shape is move all the vertices from one position to another key position and repeat that process. The following screenshot shows various morph targets used to show facial expressions (this screenshot has been provided by the <span class="No-Break">Blender foundation):</span></li>
			</ul>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/Figure_9.14_B18726.jpg" alt="Figure 9.14 – Setting up animations using morph targets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Setting up animations using morph targets</p>
			<ul>
				<li><strong class="bold">Skeleton animation</strong>: An <a id="_idIndexMarker849"/>alternative is using skeleton animation. With skeletal animation, you define the skeleton – that is, the bones – of the mesh and attach vertices to the specific bones. Now, when you move a bone, any connected bone is also moved appropriately, and the attached vertices are moved and deformed based on the position, movement, and scaling of the bone. The following screenshot, once again provided by the Blender foundation, shows an example of how bones can be used to move and deform <span class="No-Break">an object:</span></li>
			</ul>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/Figure_9.15_B18726.jpg" alt="Figure 9.15 – Setting up animations using bones"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Setting up animations using bones</p>
			<p>Three.js supports both modes, but there can be an issue getting a good export when you want to work with skeleton/bones-based animations. For the best results, you should export or convert your model into glTF format, which is becoming the default for exchanging models, animations, and scenes, and has great support <span class="No-Break">from Three.js.</span></p>
			<p>In this section, we’ll look at both options and also look at a couple of external formats supported by Three.js in which animations can <span class="No-Break">be defined.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Animation with morph targets</h2>
			<p>Morph targets <a id="_idIndexMarker850"/>are the most straightforward way of defining an animation. You<a id="_idIndexMarker851"/> define all the vertices for each important position (also called keyframes) and tell Three.js to move the vertices from one position to <span class="No-Break">the other.</span></p>
			<p>We’ll show you how to work with morph targets using two examples. In the first example, we’ll let Three.js handle the transition between the various keyframes (or morph targets, as we’ll call them from now on), and in the second one, we’ll do this manually. Keep in mind that we are only scratching the surface of what is possible with animations in Three.js. As you’ll see in this section, Three.js has excellent support for controlling animations, supports syncing of animations, and provides ways to smoothly transition from one animation to another, warranting a book just on this subject. So, in the next couple of sections, we’ll provide you with the basics of animations in Three.js, which should provide you with enough information to get started and explore the more <span class="No-Break">complex subjects.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>Animation with a mixer and morph targets</h2>
			<p>Before we dive into the examples, first, we’ll look at the three core classes that you can use to animate with Three.js. Later in this chapter, we’ll show you all the functions and properties provided by <span class="No-Break">these objects:</span></p>
			<ul>
				<li><strong class="source-inline">THREE.AnimationClip</strong>: When you<a id="_idIndexMarker852"/> load a model that contains animations, you can look in the <strong class="source-inline">response</strong> object for a field usually called <strong class="source-inline">animations</strong>. This field will contain a list of <strong class="source-inline">THREE.AnimationClip</strong> objects. Note that depending on the loader, an animation might be defined on a <strong class="source-inline">Mesh</strong>, a <strong class="source-inline">Scene</strong>, or be provided completely separately. A <strong class="source-inline">THREE.AnimationClip</strong> most often holds the data for a certain animation the model you loaded can perform. For instance, if you loaded a model of a bird, one <strong class="source-inline">THREE.AnimationClip</strong> would contain the information needed to flap the wings, and another one might be opening and closing <span class="No-Break">its beak.</span></li>
				<li><strong class="source-inline">THREE.AnimationMixer</strong>: <strong class="source-inline">THREE.AnimationMixer</strong> is<a id="_idIndexMarker853"/> used to control several <strong class="source-inline">THREE.AnimationClip</strong> objects. It makes sure the timing of the animation is correct and makes it possible to sync animations together, or cleanly move from one animation <span class="No-Break">to another.</span></li>
				<li><strong class="source-inline">THREE.AnimationAction</strong>: <strong class="source-inline">THREE.AnimationMixer</strong> itself doesn’t expose a large number of <a id="_idIndexMarker854"/>functions to control the animation, though. This is done through <strong class="source-inline">THREE.AnimationAction</strong> objects, which are returned when you add a <strong class="source-inline">THREE.AnimationClip</strong> to a <strong class="source-inline">THREE.AnimationMixer</strong> (though you can get them at a later time by using functions provided <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">THREE.AnimationMixer</strong></span><span class="No-Break">).</span></li>
			</ul>
			<p>There is also an <strong class="source-inline">AnimationObjectGroup</strong>, which you can use to provide the animation state not just to a single <strong class="source-inline">Mesh</strong> but to a group <span class="No-Break">of objects.</span></p>
			<p>In the following<a id="_idIndexMarker855"/> example, you can control a <strong class="source-inline">THREE.AnimationMixer</strong> and <a id="_idIndexMarker856"/>a <strong class="source-inline">THREE.AnimationAction</strong>, which were created using a <strong class="source-inline">THREE.AnimationClip</strong> from the model. The <strong class="source-inline">THREE.AnimationClip</strong> objects used in this example morph a model into a cube and then into <span class="No-Break">a cylinder.</span></p>
			<p>For this first morphing example, the easiest way to understand how a morph targets-based animation works is by opening up the <strong class="source-inline">morph-targets.html</strong> example. The following screenshot shows a still image of <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/Figure_9.16_B18726.jpg" alt="Figure 9.16 – Animation using morph targets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Animation using morph targets</p>
			<p>In this <a id="_idIndexMarker857"/>example, we’ve got a simple model (a monkey’s head), which <a id="_idIndexMarker858"/>can be transformed into either a cube or a cylinder using morph targets. You can easily test this yourself by moving the <strong class="source-inline">cubeTarget</strong> or <strong class="source-inline">coneTarget</strong> sliders, and you’ll see the head being morphed into a different shape. For instance, with <strong class="source-inline">cubeTarget</strong> at <strong class="source-inline">0.5</strong>, you will see that we’re halfway through morphing the monkey’s initial head into a cube. Once it is at <strong class="source-inline">1</strong>, the initial geometry is <span class="No-Break">morphed completely:</span></p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/Figure_9.17_B18726.jpg" alt="Figure 9.17 – Same model, but now with cubeTarget set to 1"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Same model, but now with cubeTarget set to 1</p>
			<p>And that’s<a id="_idIndexMarker859"/> the basics of how morph animations work. You’ve got <a id="_idIndexMarker860"/>several <strong class="source-inline">morphTargets</strong> (influences) you can control, and based on their value (from 0 to 1), the vertices move into the desired position. An animation that uses morph targets uses this approach. It just defines at which time certain vertex positions should occur. When running the animation, Three.js will make sure the right values are passed to the <strong class="source-inline">morphTargets</strong> property of the <span class="No-Break"><strong class="source-inline">Mesh</strong></span><span class="No-Break"> instance.</span></p>
			<p>To run the predefined animation, you can open the <strong class="source-inline">AnimationMixer</strong> menu for this example, and click <strong class="bold">Play</strong>. You’ll see that the head will first transform into a cube and then into a cylinder, before moving back into the shape of <span class="No-Break">a head.</span></p>
			<p>Setting up the<a id="_idIndexMarker861"/> required components to accomplish this in Three.js <a id="_idIndexMarker862"/>can be done using the following pieces of code. First, we have to load the model. In this example, we exported this example from Blender into glTF, so our <strong class="source-inline">animations</strong> are at the top level. We simply add these to a variable that we can access in the other parts of the code. We could also set this as a property on the mesh or add it to the <strong class="source-inline">userdata</strong> property <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Mesh</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
let animations = []
const loadModel = () =&gt; {
  const loader = new GLTFLoader()
  return loader.loadAsync('/assets/models/blender-morph-targets/morph-targets.gltf').then((container) =&gt; {
    animations = container.animations
    return container.scene
  })
}</pre>
			<p>Now that we’ve got an animation from the loaded model, we can set up the specific Three.js components so that we can <span class="No-Break">play them:</span></p>
			<pre class="source-code">
const mixer = new THREE.AnimationMixer(mesh)
const action = mixer.clipAction(animations[0])
action.play()</pre>
			<p>There is one final step we need to take so that the correct shape of the mesh is shown whenever we render something, and that is adding a single line to the <span class="No-Break">render loop:</span></p>
			<pre class="source-code">
// in render loop
mixer.update(clock.getDelta())</pre>
			<p>Here, we used <strong class="source-inline">THREE.Clock</strong> again to determine the time that’s passed between now and the previous render loop, and called <strong class="source-inline">mixer.update()</strong>. This information is used by the mixer to determine<a id="_idIndexMarker863"/> how far it should morph the vertices to<a id="_idIndexMarker864"/> the next morph <span class="No-Break">target (keyframe).</span></p>
			<p><strong class="source-inline">THREE.AnimationMixer</strong> and <strong class="source-inline">THREE.AnimationClip</strong> provide several other functions that you can use to control the animation or create new <strong class="source-inline">THREE.AnimationClip</strong> objects. You can experiment with them by using the menu on the right in the examples for this<a id="_idIndexMarker865"/> section. We will start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">THREE.AnimationClip</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">duration</strong>: The duration of this track (<span class="No-Break">in seconds).</span></li>
				<li><strong class="source-inline">name</strong>: The name of <span class="No-Break">this clip.</span></li>
				<li><strong class="source-inline">tracks</strong>: The internal property used to keep track of how certain properties of the model <span class="No-Break">are animated.</span></li>
				<li><strong class="source-inline">uuid</strong>: The unique ID of this clip. This is <span class="No-Break">assigned automatically.</span></li>
				<li><strong class="source-inline">clone()</strong>: Makes a copy of <span class="No-Break">this clip.</span></li>
				<li><strong class="source-inline">optimize()</strong>: This <span class="No-Break">optimizes </span><span class="No-Break"><strong class="source-inline">THREE.AnimationClip</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">resetDuration()</strong>: This determines the correct duration of <span class="No-Break">this clip.</span></li>
				<li><strong class="source-inline">toJson()</strong>: Converts this clip into a <span class="No-Break">JSON object.</span></li>
				<li><strong class="source-inline">trim()</strong>: This trims all the internal tracks to the duration set on <span class="No-Break">this clip.</span></li>
				<li><strong class="source-inline">validate()</strong>: Does some minimal validation to see if this is a <span class="No-Break">valid clip.</span></li>
				<li><strong class="source-inline">CreateClipsFromMorphTargetSequences( name, morphTargetSequences,fps, noLoop)</strong>: This creates a list of <strong class="source-inline">THREE.AnimationClip</strong> instances based on a set of morph <span class="No-Break">target sequences.</span></li>
				<li><strong class="source-inline">CreateFromMorpTargetSequences( name, morphTargetSequence,fps,noLoop)</strong>: This creates a single <strong class="source-inline">THREE.AnimationClip</strong> from a sequence of <span class="No-Break">morph targets.</span></li>
				<li><strong class="source-inline">findByName(objectOrClipArray, name)</strong>: Searches for a <strong class="source-inline">THREE.AnimationClip</strong> by name. </li>
				<li><strong class="source-inline">parse</strong> and <strong class="source-inline">toJson</strong>: Allow you to restore and save a <strong class="source-inline">Three.AnimationClip</strong> as <span class="No-Break">JSON, respectively.</span></li>
				<li><strong class="source-inline">parseAnimation(animation, bones)</strong>: Converts an <strong class="source-inline">THREE.AnimationClip</strong> <span class="No-Break">into </span><span class="No-Break"><a id="_idIndexMarker866"/></span><span class="No-Break">JSON.</span></li>
			</ul>
			<p>Once you’ve got a <strong class="source-inline">THREE.AnimationClip</strong>, you can pass it into the <strong class="source-inline">THREE.AnimationMixer</strong> object, which provides the <a id="_idIndexMarker867"/><span class="No-Break">following functionality:</span></p>
			<ul>
				<li><strong class="source-inline">AnimationMixer(rootObject)</strong>: The constructor for this object. This constructor takes a <strong class="source-inline">THREE.Object3D</strong> as an argument (for example, a <strong class="source-inline">THREE.Mesh</strong> of <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">THREE.Group</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">time</strong>: The global time for this mixer. This starts at 0, at the time when this mixer <span class="No-Break">is created.</span></li>
				<li><strong class="source-inline">timeScale</strong>: This can be used to speed up or slow down all the animations managed by this mixer. If the value of this property is set to 0, all the animations are <span class="No-Break">effectively paused.</span></li>
				<li><strong class="source-inline">clipAction(animationClip, optionalRoot)</strong>: This creates a <strong class="source-inline">THREE.AnimationAction</strong> that can be used to control the passed-in <strong class="source-inline">THREE.AnimationClip</strong>. If the animation clip is for a different object than what was provided in the constructor of <strong class="source-inline">AnimationMixer</strong>, you can pass that in as well. </li>
				<li><strong class="source-inline">existingAction(animationClip, optionalRoot)</strong>: This returns the <strong class="source-inline">THREE.AnimationAction</strong> property, which can be used to control the passed-in <strong class="source-inline">THREE.AnimationClip</strong>. Once again, if <strong class="source-inline">THREE.AnimationClip</strong> is for a <a id="_idIndexMarker868"/>different <strong class="source-inline">rootObject</strong>, you can also pass <span class="No-Break">that in.</span></li>
			</ul>
			<p>When you get <strong class="source-inline">THREE.AnimationClip</strong> back, you <a id="_idIndexMarker869"/>can use it to control <span class="No-Break">the animation:</span></p>
			<ul>
				<li><strong class="source-inline">clampWhenFinished</strong>: When set to <strong class="source-inline">true</strong>, this will cause the animation to be paused when it reaches its last frame. The default <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">enabled</strong>: When set to <strong class="source-inline">false</strong>, this will disable the current action so that it does not affect the model. When the action is re-enabled, the animation will continue where it <span class="No-Break">left off.</span></li>
				<li><strong class="source-inline">loop</strong>: This is the looping mode of this action (which can be set using the <strong class="source-inline">setLoop</strong> function). This can be set to the following: <ul><li><strong class="source-inline">THREE.LoopOnce</strong>: Plays the clip only <span class="No-Break">one time</span></li><li><strong class="source-inline">THREE.LoopRepeat</strong>: Repeats the clip based on the number of repetitions that have <span class="No-Break">been set</span></li><li><strong class="source-inline">THREE.LoopPingPong</strong>: Plays the clip based on the number of repetitions, but alternates between playing the clip forward <span class="No-Break">and backward</span></li></ul></li>
				<li><strong class="source-inline">paused</strong>: Setting this property to <strong class="source-inline">true</strong> will pause the execution of <span class="No-Break">this clip.</span></li>
				<li><strong class="source-inline">repetitions</strong>: The number of times the animation will be repeated. This is used by the <strong class="source-inline">loop</strong> property. The default <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Infinity</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">time</strong>: The time this action has been running. This is wrapped from 0 to the duration of <span class="No-Break">the clip.</span></li>
				<li><strong class="source-inline">timeScale</strong>: This can be used to speed up or slow down this animation. If the value of this property is set to <strong class="source-inline">0</strong>, this animation is <span class="No-Break">effectively paused.</span></li>
				<li><strong class="source-inline">weight</strong>: This specifies the effect this animation has on the model from a scale of <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>. When set to <strong class="source-inline">0</strong>, you won’t see any transformation of the model from this animation, and when set to <strong class="source-inline">1</strong>, you will see the full effect of <span class="No-Break">this animation.</span></li>
				<li><strong class="source-inline">zeroSlopeAtEnd</strong>: When set to true (which is the default), this will make sure there is a smooth transition between <span class="No-Break">separate clips.</span></li>
				<li><strong class="source-inline">zeroSlopeAtStart</strong>: When set to true (which is the default), this will make sure there is a smooth transition between <span class="No-Break">separate clips.</span></li>
				<li><strong class="source-inline">crossFadeFrom(fadeOutAction, durationInSeconds, warpBoolean)</strong>: This causes this action to fade in, while <strong class="source-inline">fadeOutAction</strong> is faded out. The total fade takes <strong class="source-inline">durationInSeconds</strong>. This allows for smooth transitions between animations. When <strong class="source-inline">warpBoolean</strong> is set to <strong class="source-inline">true</strong>, it will apply additional smoothing <span class="No-Break">of timescales.</span></li>
				<li><strong class="source-inline">crossFadeTo(fadeInAction, durationInSeconds, warpBoolean)</strong>: Same as <strong class="source-inline">crossFadeFrom</strong>, but this time, it fades in the provided action, and fades out <span class="No-Break">this action.</span></li>
				<li><strong class="source-inline">fadeIn(durationInSeconds)</strong>: Increases the <strong class="source-inline">weight</strong> property slowly from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> within the passed <span class="No-Break">time interval.</span></li>
				<li><strong class="source-inline">fadeOut(durationInSeconds)</strong>: Decreases the <strong class="source-inline">weight</strong> property slowly from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> within the passed <span class="No-Break">time interval.</span></li>
				<li><strong class="source-inline">getEffectiveTimeScale()</strong>: Returns the effective timescale based on the currently <span class="No-Break">running warp.</span></li>
				<li><strong class="source-inline">getEffectiveWeight()</strong>: Returns the effective weight based on the currently <span class="No-Break">running fade.</span></li>
				<li><strong class="source-inline">getClip()</strong>: Returns the <strong class="source-inline">THREE.AnimationClip</strong> property this action <span class="No-Break">is managing.</span></li>
				<li><strong class="source-inline">getMixer()</strong>: Returns the mixer that is playing <span class="No-Break">this action.</span></li>
				<li><strong class="source-inline">getRoot()</strong>: Gets the root<a id="_idIndexMarker870"/> object that is controlled by <span class="No-Break">this action.</span></li>
				<li><strong class="source-inline">halt(durationInSeconds)</strong>: Gradually decreases <strong class="source-inline">timeScale</strong> to <strong class="source-inline">0</strong> <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">durationInSeconds</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">isRunning()</strong>: Checks whether the animation is <span class="No-Break">currently running.</span></li>
				<li><strong class="source-inline">isScheduled()</strong>: Checks whether this action is currently active in <span class="No-Break">the mixer.</span></li>
				<li><strong class="source-inline">play()</strong>: Starts running this action (starting <span class="No-Break">the animation).</span></li>
				<li><strong class="source-inline">reset()</strong>: Resets this action. This will result in setting <strong class="source-inline">paused</strong> to <strong class="source-inline">false</strong>, <strong class="source-inline">enabled</strong> to <strong class="source-inline">true</strong>, and <strong class="source-inline">time</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">setDuration(durationInSeconds)</strong>: Sets the duration of a single loop. This will change <strong class="source-inline">timeScale</strong> so that the complete animation can play <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">durationInSeconds</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">setEffectiveTimeScale(timeScale)</strong>: Sets <strong class="source-inline">timeScale</strong> to the <span class="No-Break">provided value.</span></li>
				<li><strong class="source-inline">setEffectiveWeight()</strong>: Sets <strong class="source-inline">weight</strong> to the <span class="No-Break">provided value.</span></li>
				<li><strong class="source-inline">setLoop(loopMode, repetitions)</strong>: Sets <strong class="source-inline">loopMode</strong> and the number of <strong class="source-inline">repetitions</strong>. See the <strong class="source-inline">loop</strong> property for the options and <span class="No-Break">their effect.</span></li>
				<li><strong class="source-inline">startAt(startTimeInSeconds)</strong>: Delays starting the animation <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">startTimeInSeconds</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">stop()</strong>: Stops this action, and <strong class="source-inline">reset</strong> <span class="No-Break">is applied.</span></li>
				<li><strong class="source-inline">stopFading()</strong>: Stops any <span class="No-Break">scheduled fading.</span></li>
				<li><strong class="source-inline">stopWarping()</strong>: Stops any <span class="No-Break">schedule warping.</span></li>
				<li><strong class="source-inline">syncWith(otherAction)</strong>: Syncs this action with the passed-in action. This will set this action’s <strong class="source-inline">time</strong> and <strong class="source-inline">timeScale</strong> value to the <span class="No-Break">passed-in action.</span></li>
				<li><strong class="source-inline">warp(startTimeScale, endTimeScale, durationInSeconds)</strong>: Changes the <strong class="source-inline">timeScale</strong> property from <strong class="source-inline">startTimeScale</strong> to <strong class="source-inline">endTimeScale</strong> within the <a id="_idIndexMarker871"/><span class="No-Break">specified </span><span class="No-Break"><strong class="source-inline">durationInSeconds</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Besides all the functions and properties that you can use to control the animation, <strong class="source-inline">THREE.AnimationMixer</strong> also provides two events you can listen to by calling <strong class="source-inline">addEventListener</strong> on the mixer. The <strong class="source-inline">"loop"</strong> event is sent when a single loop is finished, and the <strong class="source-inline">"finished"</strong> event is sent when the complete action <span class="No-Break">has finished.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>Animation using bones and skinning</h2>
			<p>As we <a id="_idIndexMarker872"/>saw in the <em class="italic">Animation with a mixer and morph targets</em> section, morph <a id="_idIndexMarker873"/>animations are very straightforward. Three.js knows all the target vertex positions and only needs to transition each vertex from one position to the next. For bones and skinning, it becomes a bit more complex. When you use bones for animation, you move the bone, and Three.js has to determine how to translate the attached skin (a set of vertices) accordingly. For this example, we will use a model that was exported from Blender into Three.js format (<strong class="source-inline">lpp-rigging.gltf</strong> in the <strong class="source-inline">models/blender-skeleton</strong> folder). This is a model of a person, complete with a set of bones. By moving the bones around, we can animate the complete model. First, let’s look at how we loaded <span class="No-Break">the model:</span></p>
			<pre class="source-code">
let animations = []
const loadModel = () =&gt; {
  const loader = new GLTFLoader()
  return loader.loadAsync('/assets/models/blender-
    skeleton/lpp-rigging.gltf').then((container) =&gt; {
    container.scene.translateY(-2)
    applyShadowsAndDepthWrite(container.scene)
    animations = container.animations
    return container.scene
  })
}</pre>
			<p>We’ve exported the model in glTF format since the support for glTF in Three.js is good. Loading a model for bone animation isn’t that different than any of the other models. We just specify the model file and load it like any other glTF file. For glTF, the animations are in a separate property of the object that is loaded, so we simply assign it to the <strong class="source-inline">animations</strong> variable for <span class="No-Break">easy access.</span></p>
			<p>In this <a id="_idIndexMarker874"/>example, we’ve added a console log, which shows <a id="_idIndexMarker875"/>what <strong class="source-inline">THREE.Mesh</strong> looks like once we’ve <span class="No-Break">loaded it:</span></p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/Figure_9.18_B18726.jpg" alt="Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects</p>
			<p>Here, you can see that the mesh consists of a tree of bones and meshes. This also means that if you move a bone, the relevant meshes will be moved <span class="No-Break">alongside it.</span></p>
			<p>The following<a id="_idIndexMarker876"/> screenshot shows a still image of <span class="No-Break">this </span><span class="No-Break"><a id="_idIndexMarker877"/></span><span class="No-Break">example:</span></p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/Figure_9.19_B18726.jpg" alt="Figure 9.19 – Manually changing the rotation of the arm and leg bones"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Manually changing the rotation of the arm and leg bones</p>
			<p>This scene also<a id="_idIndexMarker878"/> contains an animation, which you can trigger by<a id="_idIndexMarker879"/> checking the <strong class="bold">animationIsPlaying</strong> checkbox. This will override the manually set bones’ positions and rotations, and has the skeleton kind of jumping up <span class="No-Break">and down:</span></p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/Figure_9.20_B18726.jpg" alt="Figure 9.20 – Playing a skeleton animation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – Playing a skeleton animation</p>
			<p>To set up this animation, we must follow the same steps we <span class="No-Break">saw earlier:</span></p>
			<pre class="source-code">
const mixer = new THREE.AnimationMixer(mesh)
const action = mixer.clipAction(animations[0])
action.play()</pre>
			<p>As you can <a id="_idIndexMarker880"/>see, working with bones is just as easy as working <a id="_idIndexMarker881"/>with fixed morph targets. In this example, we’ve only adjusted the rotation of the bones; you can also move the position or change the scale. In the next section, we will look at loading animations from <span class="No-Break">external models.</span></p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Creating animations using external models</h1>
			<p>In <a href="B18726_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Creating and Loading Advanced Meshes and Geometries</em>, we looked at several 3D formats that are supported by Three.js. A couple of those formats also support animations. In this chapter, we’ll look at the <span class="No-Break">following examples:</span></p>
			<ul>
				<li><strong class="bold">COLLADA model</strong>: The COLLADA<a id="_idIndexMarker882"/> format has support for animations. For this example, we’ll load an animation from a COLLADA file and render it <span class="No-Break">with Three.js.</span></li>
				<li><strong class="bold">MD2 model</strong>: The MD2 model<a id="_idIndexMarker883"/> is a simple format used in the older Quake engines. Even though the format is a bit dated, it is still a very good format for storing <span class="No-Break">character animations.</span></li>
				<li><strong class="bold">glTF models</strong>: <strong class="bold">GL transmission format</strong> (<strong class="bold">glTF</strong>) is a format specifically designed for storing 3D <a id="_idIndexMarker884"/>scenes and models. It focuses on minimizing the size of the assets and tries to be as efficient as possible in unpacking <span class="No-Break">the models.</span></li>
				<li><strong class="bold">FBX model</strong>: FBX is <a id="_idIndexMarker885"/>a format produced by the Mixamo<a id="_idIndexMarker886"/> tooling available at <a href="https://www.mixamo.com">https://www.mixamo.com</a>. With Mixamo, you can easily rig and animate models, without needing lots of <span class="No-Break">modeling experience.</span></li>
				<li><strong class="bold">BVH model</strong>: The <strong class="bold">Biovision</strong> (<strong class="bold">BVH</strong>) format<a id="_idIndexMarker887"/> is a slightly different one compared to the other loaders. With this loader, you don’t load a geometry with a skeleton or a set of animations. With this format, which is used by Autodesk MotionBuilder, you just load a skeleton, which you can visualize or even attach to <span class="No-Break">your geometry.</span></li>
			</ul>
			<p>We’ll start with a glTF model since this format is becoming the standard for exchanging models between different tools <span class="No-Break">and libraries.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Using gltfLoader</h2>
			<p>A format that is getting more <a id="_idIndexMarker888"/>and more attention lately is the glTF format. This format, for which you can find a very extensive explanation at <a href="https://github.com/KhronosGroup/glTF">https://github.com/KhronosGroup/glTF</a>, focuses on optimizing size and resource usage. Using <strong class="source-inline">glTFLoader</strong> is similar to using the <span class="No-Break">other loaders:</span></p>
			<pre class="source-code">
import { GLTFLoader } from 'three/examples
  /jsm/loaders/GLTFLoader'
...
return loader.loadAsync('/assets/models/truffle_man/scene.gltf').
  then((container) =&gt; {
  container.scene.scale.setScalar(4)
  container.scene.translateY(-2)
  scene.add(container.scene)
  
  const mixer = new THREE.AnimationMixer( container.scene ); 
  const animationClip = container.animations[0];
  const clipAction = mixer.clipAction( animationClip ).
play(); 
})</pre>
			<p>This loader also loads a complete scene, so you can either add everything to the group or select child elements. For this <a id="_idIndexMarker889"/>example, you can view the results by <span class="No-Break">opening </span><span class="No-Break"><strong class="source-inline">load-gltf.js</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/Figure_9.21_B18726.jpg" alt="Figure 9.21 – Animation loaded using glTF"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Animation loaded using glTF</p>
			<p>For the next example, we’ll <a id="_idIndexMarker890"/>use the <span class="No-Break">FBX model.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Visualizing motions captured models using fbxLoader</h2>
			<p>The <a id="_idIndexMarker891"/>Autodesk FBX format has been around for a while and is very easy to use. There is a great resource online where you can find many animations that you can download in this format: <a href="https://www.mixamo.com/">https://www.mixamo.com/</a>. This site provides 2,500 animations that you can use <span class="No-Break">and customize:</span></p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/Figure_9.22_B18726.jpg" alt="Figure 9.22 – Loading animations from mixamo"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – Loading animations from mixamo</p>
			<p>After <a id="_idIndexMarker892"/>downloading an animation, using it from Three.js <span class="No-Break">is easy:</span></p>
			<pre class="source-code">
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader'
...
loader.loadAsync('/assets/models/salsa/salsa.fbx').then((mesh) =&gt; {
  mesh.translateX(-0.8)
  mesh.translateY(-1.9)
  mesh.scale.set(0.03, 0.03, 0.03)
  scene.add(mesh)
  const mixer = new THREE.AnimationMixer(mesh)
  const clips = mesh.animations
  const clip = THREE.AnimationClip.findByName(clips, 
    'mixamo.com')   
})</pre>
			<p>The resulting animation, as you can see in <strong class="source-inline">load-fbx.html</strong>, <span class="No-Break">looks great:</span></p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/Figure_9.23_B18726.jpg" alt="Figure 9.23 – Animation loaded using fbx"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Animation loaded using fbx</p>
			<p>FBX and glTF are<a id="_idIndexMarker893"/> modern formats that are used a lot and are a good way to exchange models and animations. There are a couple of older formats around as well. An interesting one is a format used by the old FPS <span class="No-Break">Quake: MD2.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Loading an animation from a Quake model</h2>
			<p>The <a id="_idIndexMarker894"/>MD2 format was created to model characters<a id="_idIndexMarker895"/> from Quake, a great game from 1996. Even though the newer engines use a different format, you can still find a lot of interesting models in the MD2 format. Using an MD2 file is a bit different than using the others we’ve seen so far. When you load an MD2 model, you get a geometry, so you have to make sure that you create a material as well and assign <span class="No-Break">a skin:</span></p>
			<pre class="source-code">
let animations = []
const loader = new MD2Loader()
loader.loadAsync('/assets/models/ogre/ogro.md2').then
  ((object) =&gt; {
  const mat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    metalness: 0,
    map: new THREE.TextureLoader().load
      ('/assets/models/ogre/skins/skin.jpg')
  })
  animations = object.animations
  const mesh = new THREE.Mesh(object, mat)
  // add to scene, and you can animate it as we've seen 
    already
})</pre>
			<p>Once you have this <strong class="source-inline">Mesh</strong>, setting up the animation works in the same way. The result of this animation can be seen <span class="No-Break">here (</span><span class="No-Break"><strong class="source-inline">load-md2.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/Figure_9.24_B18726.jpg" alt="Figure 9.24 – Loaded Quake monster"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Loaded Quake monster</p>
			<p>Next up <span class="No-Break">is COLLADA.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Loading an animation from a COLLADA model</h2>
			<p>While the normal COLLADA <a id="_idIndexMarker896"/>models aren’t compressed (and they can get quite large), there is also a <strong class="source-inline">KMZLoader</strong> available in Three.js. This is a <a id="_idIndexMarker897"/>compressed COLLADA model, so if you run<a id="_idIndexMarker898"/> into <strong class="bold">Keyhole Markup Language Zipped</strong> (<strong class="bold">KMZ</strong>) models, you can load the model using <strong class="source-inline">KMZLoader</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ColladaLoader</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/Figure_9.25_B18726.jpg" alt="Figure 9.25 – Loaded COLLADA model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – Loaded COLLADA model</p>
			<p>For the final loader, we’ll look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">BVHLoader</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor169"/>Visualizing a skeleton with BVHLoader</h2>
			<p><strong class="source-inline">BVHLoader</strong> is a <a id="_idIndexMarker899"/>slightly different loader than the ones we’ve seen<a id="_idIndexMarker900"/> so far. This loader doesn’t return meshes or geometries with animations; instead, it returns a skeleton and an animation. An example of this is shown <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">load-bvh.html</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/Figure_9.26_B18726.jpg" alt="Figure 9.26 – Loaded BVH skeleton"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Loaded BVH skeleton</p>
			<p>To visualize this, we<a id="_idIndexMarker901"/> can use a <strong class="source-inline">THREE.SkeletonHelper</strong>, as<a id="_idIndexMarker902"/> seen here. With a <strong class="source-inline">THREE.SkeletonHelper</strong>, we can visualize the skeleton of a mesh. BVH models just contain skeleton information, which we can visualize <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const loader = new BVHLoader()
let animation = undefined
loader.loadAsync('/assets/models//amelia-dance/DanceNightClub7_t1.bvh').then((result) =&gt; {
  const skeletonHelper = new THREE.SkeletonHelper
    (result.skeleton.bones[0])
  skeletonHelper.skeleton = result.skeleton
  const boneContainer = new THREE.Group()
  boneContainer.add(result.skeleton.bones[0])
  animation = result.clip
  const group = new THREE.Group()
  group.add(skeletonHelper)
  group.add(boneContainer)
  group.scale.setScalar(0.2)
  group.translateY(-1.6)
  group.translateX(-3)
  // Now we can animate the group just like we did for the 
    other examples
})</pre>
			<p>In older versions of Three.js, there <a id="_idIndexMarker903"/>was support for other kinds of animation file<a id="_idIndexMarker904"/> formats. Most of those are obsolete and have subsequently been removed from the Three.js distribution. If you do stumble upon a different format in which you want to show the animations, you can look at the older Three.js releases and possibly reuse the loaders <span class="No-Break">from there.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we looked at different ways you can animate your scene. We started with some basic animation tricks, moved on to camera movement and control, and ended by looking at animating models using morph targets and <span class="No-Break">skeleton/bones animations.</span></p>
			<p>When you have the render loop in place, adding simple animations is very easy. Just change a property of the mesh; in the next rendering step, Three.js will render the updated mesh. For more complex animations, you would usually model them in external programs and load them through one of the loaders provided <span class="No-Break">by Three.js.</span></p>
			<p>In the previous chapters, we looked at the various materials we can use to skin our objects. For instance, we saw how we can change the color, shininess, and opacity of these materials. What we haven’t discussed in detail yet, however, is how we can use external images (also called textures) together with these materials. With textures, we can easily create objects that look as if they are made out of wood, metal, stone, and much more. In <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, we’ll explore all the different aspects of textures and how they are used <span class="No-Break">in Three.js.</span></p>
		</div>
	</body></html>