<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Walking You Through Classes</h1></div></div></div><p>ES6 introduced classes that provide a much simpler and clearer syntax to creating constructors and dealing with inheritance. JavaScript never had the concept of classes, although it's an object-oriented programming language. Programmers from the other programming language background often found it difficult to understand JavaScript's object-oriented model and inheritance due to lack of classes. In this chapter, we will learn about the object-oriented JavaScript using the ES6 classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The JavaScript data types</li><li class="listitem" style="list-style-type: disc">Creating objects the classical way</li><li class="listitem" style="list-style-type: disc">The constructors of the primitive types</li><li class="listitem" style="list-style-type: disc">What are classes in ES6</li><li class="listitem" style="list-style-type: disc">Creating objects using classes</li><li class="listitem" style="list-style-type: disc">The inheritance in classes</li><li class="listitem" style="list-style-type: disc">The features of classes</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Understanding the Object-oriented JavaScript</h1></div></div></div><p>Before we <a id="id403" class="indexterm"/>proceed with the ES6 classes, let's refresh our knowledge on the JavaScript data types, constructors, and inheritance. While learning classes, we will be comparing the syntax of the constructors and prototype-based inheritance with the syntax of the classes. Therefore, it is important to have a good grip on these topics.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec97"/>The JavaScript data types</h2></div></div></div><p>The <a id="id404" class="indexterm"/>JavaScript<a id="id405" class="indexterm"/> variables hold (or store) data (or value). The type of data variables that they hold is called as the <a id="id406" class="indexterm"/>
<strong>data type</strong>. In JavaScript, there are seven<a id="id407" class="indexterm"/> different data types: <strong>number</strong>, <a id="id408" class="indexterm"/>
<strong>string</strong>, <a id="id409" class="indexterm"/>
<strong>Boolean</strong>, <a id="id410" class="indexterm"/>
<strong>null</strong>, <a id="id411" class="indexterm"/>
<strong>undefined</strong>, <a id="id412" class="indexterm"/>
<strong>symbol</strong>, and <a id="id413" class="indexterm"/>
<strong>object</strong>.</p><p>When it comes to holding objects, variables hold the object reference (that is, the memory address) instead of the object itself.</p><p>All the other data types other than object are called as<a id="id414" class="indexterm"/> <strong>primitive data types</strong>.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>The arrays and functions are actually the JavaScript objects.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Creating objects</h2></div></div></div><p>There are two ways of <a id="id415" class="indexterm"/>creating an object in <a id="id416" class="indexterm"/>JavaScript, that is, using the object literal, or using a constructor. The object literal is used when we want to create fixed objects, whereas constructor is used when we want to create the objects dynamically on runtime.</p><p>Let's consider a case where we may need to use the constructors instead of the object literal. Here is a code example:</p><div><pre class="programlisting">var student = {
  name: "Eden",
  printName: function(){
    console.log(this.name);
  }
}

student.printName(); //Output "Eden"</pre></div><p>Here, we created a <code class="literal">student</code> object using the object literal, that is, the <code class="literal">{}</code> notation. This works well when you just want to create a single <code class="literal">student</code> object.</p><p>But the problem arises when you want to create multiple <code class="literal">student</code> objects. Obviously, you don't want to write the previous code multiple times to create multiple <code class="literal">student</code> objects. This is where constructors come into use.</p><p>A function acts like a constructor when invoked using the <code class="literal">new</code> keyword. A constructor creates and returns an object. The <code class="literal">this</code> keyword, inside a function, when invoked as a constructor, points to the new object instance, and once the constructor execution is finished, the new object is automatically returned. Consider this example:</p><div><pre class="programlisting">function Student(name)
{
  this.name = name;
}

Student.prototype.printName = function(){
  console.log(this.name);
}

var student1 = new Student("Eden");
var student2 = new Student("John");

student1.printName(); //Output "Eden"
student2.printName(); //Output "John"</pre></div><p>Here, to create <a id="id417" class="indexterm"/>multiple student objects, we invoked the constructor<a id="id418" class="indexterm"/> multiple times instead of creating multiple student objects using the object literals.</p><p>To add methods to the instances of the constructor, we didn't use the <code class="literal">this</code> keyword, instead we used the <code class="literal">prototype</code> property of constructor. We will learn more on why we did it this way, and what the <code class="literal">prototype</code> property is, in the next section.</p><p>Actually, every object must belong to a constructor. Every object has an inherited property named <code class="literal">constructor</code>, pointing to the object's constructor. When we create objects using the object literal, the <code class="literal">constructor</code> property points to the global <code class="literal">Object</code> constructor. Consider this example to understand this behavior:</p><div><pre class="programlisting">var student = {}

console.log(student.constructor == Object); //Output "true"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Understanding inheritance</h2></div></div></div><p>Each JavaScript object <a id="id419" class="indexterm"/>has an internal <code class="literal">[[prototype]]</code> property pointing to another object called as its prototype. This prototype object has a prototype of its own, and so on until an object is reached with <code class="literal">null</code> as its prototype. <code class="literal">null</code> has no prototype, and it acts as a final link in the prototype chain.</p><p>When trying to access a property of an object, and if the property is not found in the object, then the property is searched in the object's prototype. If still not found, then it's searched in the prototype of the prototype object. It keeps on going until <code class="literal">null</code> is encountered in the prototype chain. This is how inheritance works in JavaScript.</p><p>As a JavaScript object can have only one prototype, JavaScript supports only a single inheritance.</p><p>While creating objects using the object literal, we can use the special <code class="literal">__proto__</code> property or the <code class="literal">Object.setPrototypeOf()</code> method to assign a prototype of an object. JavaScript also provides an <code class="literal">Object.create()</code> method, with which we can create a new object with a specified prototype as the <code class="literal">__proto__</code> lacked browser support, and the <code class="literal">Object.setPrototypeOf()</code> method seemed a little odd. Here is code example that demonstrates different ways to set the prototype of an object while creating, using the object literal:</p><div><pre class="programlisting">var object1 = {
  name: "Eden",
  __proto__: {age: 24}
}

var object2 = {name: "Eden"}
Object.setPrototypeOf(object2, {age: 24});

var object3 = Object.create({age: 24}, {name: {value: "Eden"}});

console.log(object1.name + " " + object1.age);
console.log(object2.name + " " + object2.age);
console.log(object3.name + " " + object3.age);</pre></div><p>The <a id="id420" class="indexterm"/>output is as follows:</p><div><pre class="programlisting">Eden 24
Eden 24
Eden 24</pre></div><p>Here, the <code class="literal">{age:24}</code> object is referred as <a id="id421" class="indexterm"/>
<strong>base object</strong>, <a id="id422" class="indexterm"/>
<strong>superobject</strong>, or <strong>parent object</strong><a id="id423" class="indexterm"/> as its being inherited. And the <code class="literal">{name:"Eden"}</code> object is referred as the <a id="id424" class="indexterm"/>
<strong>derived object</strong>, <a id="id425" class="indexterm"/>
<strong>subobject</strong>, or the <strong>child object</strong><a id="id426" class="indexterm"/>, as it inherits another object.</p><p>If you don't assign a prototype to an object while creating it using the object literal, then the prototype points to the <code class="literal">Object.prototype</code> property. The prototype of <code class="literal">Object.prototype</code> is <code class="literal">null</code> therefore, leading to the end of the prototype chain. Here is an example to demonstrate this:</p><div><pre class="programlisting">var obj = {
  name: "Eden"
}

console.log(obj.__proto__ == Object.prototype); //Output "true"</pre></div><p>While creating objects using a constructor, the prototype of the new objects always points to a property named <code class="literal">prototype</code> of the function object. By default, the <code class="literal">prototype</code> property is an object with one property named as <code class="literal">constructor</code>. The <code class="literal">constructor</code> property points to the function itself. Consider this example to understand this model:</p><div><pre class="programlisting">function Student()
{
  this.name = "Eden";
}

var obj = new Student();

console.log(obj.__proto__.constructor == Student); //Output "true"
console.log(obj.__proto__ == Student.prototype); //Output "true"</pre></div><p>To add new <a id="id427" class="indexterm"/>methods to the instances of a constructor, we should add them to the <code class="literal">prototype</code> property of the constructor, as we did earlier. We shouldn't add methods using the <code class="literal">this</code> keyword in a constructor body, because every instance of the constructor will have a copy of the methods, and this isn't very memory efficient. By attaching methods to the <code class="literal">prototype</code> property of a constructor, there is only one copy of each function that all the instances share. To understand this, consider this example:</p><div><pre class="programlisting">function Student(name)
{
    this.name = name;
}

Student.prototype.printName = function(){
    console.log(this.name);
}

var s1 = new Student("Eden");
var s2 = new Student("John");

function School(name)
{
  this.name = name;
  this.printName = function(){
    console.log(this.name);
  }
}

var s3 = new School("ABC");
var s4 = new School("XYZ");

console.log(s1.printName == s2.printName);
console.log(s3.printName == s4.printName);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">true
false</pre></div><p>Here, <code class="literal">s1</code> and <code class="literal">s2</code> share the same <code class="literal">printName</code> function that reduces the use of memory, whereas <code class="literal">s3</code> and <code class="literal">s4</code> contain two different functions with the name as <code class="literal">printName</code> that makes the program use more memory. This is unnecessary, as both the functions do the same thing. Therefore, we add methods for the instances to the <code class="literal">prototype</code> property of the constructor.</p><p>Implementing the<a id="id428" class="indexterm"/> inheritance hierarchy in the constructors is not as straightforward as we did for object literals. Because the child constructor needs to invoke the parent constructor for the parent constructor's initialization logic to take place and we need to add the methods of the <code class="literal">prototype</code> property of the parent constructor to the <code class="literal">prototype</code> property of the child constructor, so that we can use them with the objects of child constructor. There is no predefined way to do all this. The developers and JavaScript libraries have their own ways of doing this. I will show you the most common way of doing it.</p><p>Here is an example to demonstrate how to implement the inheritance while creating the objects using the constructors:</p><div><pre class="programlisting">function School(schoolName)
{
  this.schoolName = schoolName;
}
School.prototype.printSchoolName = function(){
  console.log(this.schoolName);
}

function Student(studentName, schoolName)
{
  this.studentName = studentName;

  School.call(this, schoolName);
}
Student.prototype = new School();
Student.prototype.printStudentName = function(){
  console.log(this.studentName);
}

var s = new Student("Eden", "ABC School");
s.printStudentName();
s.printSchoolName();</pre></div><p>The output is as follows:</p><div><pre class="programlisting">Eden
ABC School</pre></div><p>Here, we invoked the parent constructor using the <code class="literal">call</code> method of the function object. To inherit the methods, we created an instance of the parent constructor, and assigned it to the child constructor's <code class="literal">prototype</code> property.</p><p>This is not a foolproof way of implementing inheritance in the constructors, as there are lots of potential problems. For example—in case the parent constructor does something else other than just initializing properties, such as DOM manipulation, then while assigning a new instance of the parent constructor, to the <code class="literal">prototype</code> property, of the child constructor, can cause problems.</p><p>Therefore, the ES6 classes provide a better and easier way to inherit the existing constructors and classes. We will see more on this later in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec100"/>The constructors of primitive data types</h2></div></div></div><p>The primitive data, types <a id="id429" class="indexterm"/>such as boolean, string, and number, have<a id="id430" class="indexterm"/> their constructor counterparts. These counterpart constructors behave like wrappers for these primitive types. For example, the <code class="literal">String</code> constructor is used to create a string object that contains an internal <code class="literal">[[PrimitiveValue]]</code> property that holds the actual primitive value.</p><p>At runtime, wherever necessary, the primitive values are wrapped with their constructor counterparts, and also the counterpart objects are treated as primitive values, so that the code works as expected. Consider this example code to understand how it works:</p><div><pre class="programlisting">var s1 = "String";
var s2 = new String("String");

console.log(typeof s1);
console.log(typeof s2);

console.log(s1 == s2);
console.log(s1.length);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">string
object
true
6</pre></div><p>Here, <code class="literal">s1</code> is a primitive type, and <code class="literal">s2</code> is an object although applying the <code class="literal">==</code> operator on them gives us a <code class="literal">true</code> result. <code class="literal">s1</code> is a primitive type but still we are able to access the length property however primitive types shouldn't have any properties.</p><p>All this is happening because the previous code was converted into this on runtime:</p><div><pre class="programlisting">var s1 = "String";
var s2 = new String("String");

console.log(typeof s1);
console.log(typeof s2);

console.log(s1 == s2.valueOf());
console.log((new String(s1)).length);</pre></div><p>Here, we can see<a id="id431" class="indexterm"/> how the primitive value was wrapped with its <a id="id432" class="indexterm"/>constructor counterpart, and how the object counterpart was treated as primitive value when necessary. Therefore, the code works as expected.</p><p>The primitive types introduced from ES6 onwards won't allow their counterpart functions to be invoked as constructors, that is, we can't explicitly wrap them using their object counterparts. We saw this behavior while learning symbols.</p><p>The <code class="literal">null</code> and <code class="literal">undefined</code> primitive types don't have any counterpart constructors.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Using classes</h1></div></div></div><p>We saw that <a id="id433" class="indexterm"/>JavaScript's object-oriented model is based on the constructors and prototype-based inheritance. Well, the ES6 classes are just new a syntax for the existing model. Classes do not introduce a new object-oriented model to JavaScript.</p><p>The ES6 classes aim to provide a much simpler and clearer syntax for dealing with the constructors and inheritance.</p><p>In fact, classes are functions. Classes are just a new syntax for creating functions that are used as constructors. Creating functions using the classes that aren't used as constructors doesn't make any sense, and offer no benefits. Rather, it makes your code difficult to read, as it becomes confusing. Therefore, use classes only if you want to use it for constructing objects. Let's have a look at classes in detail.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec101"/>Defining a class</h2></div></div></div><p>Just as there are<a id="id434" class="indexterm"/> two ways of defining functions, function declaration and function expression, there are two ways to define a class: using the class declaration and the class expression.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec40"/>The class declaration</h3></div></div></div><p>For defining a class using the<a id="id435" class="indexterm"/> class declaration, you need to use the <code class="literal">class</code> keyword, and a name for the class.</p><p>Here is a code example to demonstrate how to define a class using the class declaration:</p><div><pre class="programlisting">class Student
{
  constructor(name)
  {
    this.name = name;
  }
}

var s1 = new Student("Eden");
console.log(s1.name); //Output "Eden"</pre></div><p>Here, we created a class named <code class="literal">Student</code>. Then, we defined a <code class="literal">constructor</code> method in it. Finally, we created a new instance of the class—an object, and logged the <code class="literal">name</code> property of the object.</p><p>The body of a class is in the curly brackets, that is, <code class="literal">{}</code>. This is where we need to define methods. Methods are defined without the <code class="literal">function</code> keyword, and a comma is not used in between the methods.</p><p>Classes are treated as functions, and internally the class name is treated as the function name, and the body of the <code class="literal">constructor</code> method is treated as the body of the function.</p><p>There can only be one <code class="literal">constructor</code> method in a class. Defining more than one constructor will throw the <code class="literal">SyntaxError</code> exception.</p><p>All the code inside a class body is executed in the <code class="literal">strict</code> mode, by default.</p><p>The previous code is the same as this code when written using function:</p><div><pre class="programlisting">function Student(name)
{
  this.name = name;
}

var s1 = new Student("Eden");
console.log(s1.name); //Output "Eden"</pre></div><p>To prove that a class is a <a id="id436" class="indexterm"/>function, consider this code:</p><div><pre class="programlisting">class Student
{
  constructor(name)
  {
    this.name = name;
  }
}


function School(name)
{
  this.name = name;
}

console.log(typeof Student);
console.log(typeof School == typeof Student);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">function
true</pre></div><p>Here, we can see that a<a id="id437" class="indexterm"/> class is a function. It's just a new syntax for creating a function.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec41"/>The class expression</h3></div></div></div><p>A class expression<a id="id438" class="indexterm"/> has a similar syntax to a class declaration. However, with class expressions, you are able to omit the class name. Class body and behavior remains the same in both the ways.</p><p>Here is a code example to demonstrate how to define a class using a class expression:</p><div><pre class="programlisting">var Student = class {
  constructor(name)
  {
    this.name = name;
  }
}

var s1 = new Student("Eden");
console.log(s1.name); //Output "Eden"</pre></div><p>Here, we stored a reference of the class in a variable, and used it to construct the objects.</p><p>The previous code is the same as this code when written using function:</p><div><pre class="programlisting">var Student = function(name) {
  this.name = name;
}

var s1 = new Student("Eden");
console.log(s1.name); //Output "Eden"</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec102"/>The prototype methods</h2></div></div></div><p>All the methods in the<a id="id439" class="indexterm"/> body of the class are added to the <code class="literal">prototype</code> property of the class. The <code class="literal">prototype</code> property is the prototype of the objects created using class.</p><p>Here is an example that shows how to add methods to the <code class="literal">prototype</code> property of a class:</p><div><pre class="programlisting">class Person
{
  constructor(name, age)
  {
    this.name = name;
    this.age = age;
  }

  printProfile()
  {
    console.log("Name is: " + this.name + " and Age is: " + this.age);
  }
}

var p = new Person("Eden", 12)
p.printProfile();

console.log("printProfile" in p.__proto__);
console.log("printProfile" in Person.prototype);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">Name is: Eden and Age is: 12
true
true</pre></div><p>Here, we can see that the <code class="literal">printProfile</code> method was added to the <code class="literal">prototype</code> property of the class.</p><p>The previous code is the same as this code when written using function:</p><div><pre class="programlisting">function Person(name, age)
{
  this.name = name;
  this.age = age;
}

Person.prototype.printProfile = function()
{
  console.log("Name is: " + this.name + " and Age is: " + this.age);
}

var p = new Person("Eden", 12)
p.printProfile();

console.log("printProfile" in p.__proto__);
console.log("printProfile" in Person.prototype);</pre></div><p>The <a id="id440" class="indexterm"/>output is as follows:</p><div><pre class="programlisting">Name is: Eden and Age is: 12
true
true</pre></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec42"/>The get and set methods</h3></div></div></div><p>In ES5, to add <a id="id441" class="indexterm"/>accessor <a id="id442" class="indexterm"/>properties to the objects, we <a id="id443" class="indexterm"/>had to <a id="id444" class="indexterm"/>use the <code class="literal">Object.defineProperty()</code> method. ES6 introduced the <code class="literal">get</code> and <code class="literal">set</code> prefixes for methods. These methods can be added to the object literals and classes for defining the <code class="literal">get</code> and <code class="literal">set</code> attributes of the accessor properties.</p><p>When <code class="literal">get</code> and <code class="literal">set</code> methods are used in a class body, they are added to the <code class="literal">prototype</code> property of the class.</p><p>Here is an example to demonstrate how to define the <code class="literal">get</code> and <code class="literal">set</code> methods in a class:</p><div><pre class="programlisting">class Person
{
  constructor(name)
  {
    this._name_ = name;
  }

  get name(){
    return this._name_;
  }

  set name(name){
    this._name_ = name;
  }
}

var p = new Person("Eden");
console.log(p.name);
p.name = "John";
console.log(p.name);

console.log("name" in p.__proto__);
console.log("name" in Person.prototype);
console.log(Object.getOwnPropertyDescriptor(p.__proto__, "name").set);
console.log(Object.getOwnPropertyDescriptor(Person.prototype, "name").get);
console.log(Object.getOwnPropertyDescriptor(p, "_name_").value);</pre></div><p>The<a id="id445" class="indexterm"/> output <a id="id446" class="indexterm"/>is as follows:</p><div><pre class="programlisting">Eden
John
true
true
function name(name) { this._name_ = name; }
function name() { return this._name_; }
John</pre></div><p>Here, we <a id="id447" class="indexterm"/>created an <a id="id448" class="indexterm"/>accessor property to encapsulate the <code class="literal">_name_</code> property. We also logged some other information to prove that <code class="literal">name</code> is an accessor property, which is added to the <code class="literal">prototype</code> property of the class.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec43"/>The generator method</h3></div></div></div><p>To treat a concise method <a id="id449" class="indexterm"/>of an object literal as the generator method, or to treat <a id="id450" class="indexterm"/>a method of a class as the generator method, we can simply prefix it with the <code class="literal">*</code> character.</p><p>The generator method of a class is added to the <code class="literal">prototype</code> property of the class.</p><p>Here is an example to demonstrate how to define a generator method in class:</p><div><pre class="programlisting">class myClass
{
  * generator_function()
  {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    yield 5;
  }

}

var obj = new myClass();

let generator = obj.generator_function();

console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().done);

console.log("generator_function" in myClass.prototype);</pre></div><p>The output<a id="id451" class="indexterm"/> is as<a id="id452" class="indexterm"/> follows:</p><div><pre class="programlisting">1
2
3
4
5
true
true</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec103"/>The static methods</h2></div></div></div><p>The methods that are <a id="id453" class="indexterm"/>added to the body of the class with the <code class="literal">static</code> prefix <a id="id454" class="indexterm"/>are called as static methods. Static methods are the own methods of the class, that is, they are not added to the <code class="literal">prototype</code> property of the class, rather they are added to the class itself. For example, the <code class="literal">String.fromCharCode()</code> method is a static method of the <code class="literal">String</code> constructor, that is, <code class="literal">fromCharCode</code> is the own property of the <code class="literal">String</code> function itself.</p><p>Static methods are often used to create utility functions for an application.</p><p>Here is an example to demonstrate how to define and use a static method in class:</p><div><pre class="programlisting">class Student
{
  constructor(name)
  {
    this.name = name;
  }

  static findName(student)
  {
    return student.name;
  }
}

var s = new Student("Eden");
var name = Student.findName(s);

console.log(name); //Output "Eden"</pre></div><p>Here, <code class="literal">findName</code> is a static method of the <code class="literal">Student</code> class.</p><p>The previous code<a id="id455" class="indexterm"/> is the same <a id="id456" class="indexterm"/>as this code when written using function:</p><div><pre class="programlisting">function Student(name)
{
    this.name = name;
}

Student.findName = function(student){
  return student.name;
}

var s = new Student("Eden");
var name = Student.findName(s);

console.log(name); //Output "Eden"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Implementing inheritance in classes</h2></div></div></div><p>Earlier in this chapter, we saw<a id="id457" class="indexterm"/> how difficult it was to implement inheritance <a id="id458" class="indexterm"/>hierarchy in functions. Therefore, ES6 aims to make it easy by introducing the <code class="literal">extends</code> clause, and the <code class="literal">super</code> keyword for classes.</p><p>By using the <code class="literal">extends</code> clause, a class can inherit static and non-static properties of another constructor (which may or may not be defined using a class).</p><p>The <code class="literal">super</code> keyword is used in two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It's used in a class <code class="literal">constructor</code> method to call the parent constructor</li><li class="listitem" style="list-style-type: disc">When used inside methods of a class, it references the static and non-static methods of the parent constructor</li></ul></div><p>Here is an example to demonstrate how to implement the inheritance hierarchy in the constructors using the <code class="literal">extends</code> clause, and the <code class="literal">super</code> keyword:</p><div><pre class="programlisting">function A(a)
{
  this.a = a;
}

A.prototype.printA = function(){
  console.log(this.a);
}

class B extends A
{
  constructor(a, b)
  {
    super(a);
    this.b = b;
  }

  printB()
  {
    console.log(this.b);
  }

  static sayHello()
  {
    console.log("Hello");
  }
}

class C extends B
{
  constructor(a, b, c)
  {
    super(a, b);
    this.c = c;
  }

  printC()
  {
    console.log(this.c);
  }

  printAll()
  {
    this.printC();
    super.printB();
    super.printA();
  }
}

var obj = new C(1, 2, 3);
obj.printAll();

C.sayHello();</pre></div><p>The output is as follows:</p><div><pre class="programlisting">3
2
1
Hello</pre></div><p>Here, <code class="literal">A</code> is a function constructor; <code class="literal">B</code> is a class that inherits <code class="literal">A</code>; <code class="literal">C</code> is a class that inherits <code class="literal">B;</code> and as <code class="literal">B</code> inherits <code class="literal">A,</code> therefore <code class="literal">C</code> also inherits <code class="literal">A</code>.</p><p>As a class can inherit a function constructor, we can also inherit the prebuilt function constructors, such as <code class="literal">String</code> and <code class="literal">Array</code>, and also the custom function constructors using the classes instead of other <em>hacky</em> ways that we used to use.</p><p>The previous<a id="id459" class="indexterm"/> example also shows how and where to use the<a id="id460" class="indexterm"/> <code class="literal">super</code> keyword. Remember that inside the <code class="literal">constructor</code> method, you need to use <code class="literal">super</code> before using the <code class="literal">this</code> keyword. Otherwise, an exception is thrown.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>If a child class doesn't have a <code class="literal">constructor</code> method, then the default behavior will invoke the <code class="literal">constructor</code> method of the parent class.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec105"/>The computed method names</h2></div></div></div><p>You can also decide the <a id="id461" class="indexterm"/>name of the static and non-static methods of a class and concise methods of a object literal on runtime, that is, you can define the name of methods via expressions. Here is an example to demonstrate this:</p><div><pre class="programlisting">class myClass
{
  static ["my" + "Method"](){
    console.log("Hello");
  }
}

myClass["my" + "Method"](); //Output "Hello"</pre></div><p>The computed property names also allow you to use symbols as keys for the methods. Here is an example to demonstrate this:</p><div><pre class="programlisting">var s = Symbol("Sample");

class myClass
{
  static [s]()
  {
    console.log("Hello");
  }
}

myClass[s](); //Output "Hello"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec106"/>The attributes of properties</h2></div></div></div><p>When using class, the <a id="id462" class="indexterm"/>attributes of the static and non-static properties of constructor are <a id="id463" class="indexterm"/>different than when declared using function:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The static methods are writable and configurable, but not enumerable</li><li class="listitem" style="list-style-type: disc">The <code class="literal">prototype</code> property and the <code class="literal">prototype.constructor</code> property of class is not writable, numerable, or configurable</li><li class="listitem" style="list-style-type: disc">The properties of the <code class="literal">prototype</code> property are writable and configurable, but not enumerable</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec107"/>Classes are not hoisted!</h2></div></div></div><p>You can call a function before its defined, that is, function calls can be made above the function definition. But in case of class, you cannot use a class before its defined. Trying to do so in classes will throw the <code class="literal">ReferenceError</code> exception.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">myFunc();
function myFunc(){}

var obj = new myClass(); //throws ReferenceError exception
class myClass{}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec108"/>Overriding the result of the constructor method</h2></div></div></div><p>The <code class="literal">constructor</code> method, by <a id="id464" class="indexterm"/>default, returns the new instance if there is no <code class="literal">return</code> statement in it. If there is a <code class="literal">return</code> statement, then whatever is the value in the <code class="literal">return</code> statement is returned.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">class myClass
{
  constructor()
  {
    return Object.create(null);
  }
}

console.log(new myClass() instanceof myClass); //Output "false"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec109"/>The "Symbol.species" static accessor property</h2></div></div></div><p>The <code class="literal">@@species</code> static accessor property is <a id="id465" class="indexterm"/>optionally added to a child constructor, in order to signal the methods of the parent constructor, about what the constructor should use if the parent constructor's methods are returning new instances. If the <code class="literal">@@species</code> static accessor property is not defined on a child constructor, then the methods of the parent constructor can use the default constructor.</p><p>Consider this example to understand the use of <code class="literal">@@species</code>—the <code class="literal">map()</code> method of the array objects returns a new <code class="literal">Array</code> instance. If we call the <code class="literal">map()</code> method of an object that inherits an array object, then the <code class="literal">map()</code> method returns a new instance of the child constructor instead of the <code class="literal">Array</code> constructor, which is not what we always want. Therefore, ES6 introduced the <code class="literal">@@species</code> property, which provides a way to signal such kind of functions, to use a different constructor instead of the default constructor.</p><p>Here is a code example to demonstrate how to use the <code class="literal">@@species</code> static accessor property:</p><div><pre class="programlisting">class myCustomArray1 extends Array
{
   static get [Symbol.species]()
   {
     return Array;
   }
}

class myCustomArray2 extends Array{}

var arr1 = new myCustomArray1(0, 1, 2, 3, 4);
var arr2 = new myCustomArray2(0, 1, 2, 3, 4);

console.log(arr1 instanceof myCustomArray1);
console.log(arr2 instanceof myCustomArray2);

arr1 = arr1.map(function(value){ return value + 1; })
arr2 = arr2.map(function(value){ return value + 1; })

console.log(arr1 instanceof myCustomArray1);
console.log(arr2 instanceof myCustomArray2);

console.log(arr1 instanceof Array);
console.log(arr2 instanceof Array);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">true
true
false
true
true
false</pre></div><p>It is recommended <a id="id466" class="indexterm"/>that if you are creating a JavaScript library, then the methods of the constructors in your library should always look for the <code class="literal">@@species</code> property while returning new instances. Here is an example to demonstrate this:</p><div><pre class="programlisting">//Assume myArray1 is part of library
class myArray1
{

  //default @@species. Child class will inherit this property
  static get [Symbol.species]()
  {
    //default constructor
    return this;
  }

  mapping()
  {
    return new this.constructor[Symbol.species]();
  }
}

class myArray2 extends myArray1
{
  static get [Symbol.species]()
  {
    return myArray1;
  }
}

var arr = new myArray2();

console.log(arr instanceof myArray2); //Output "true"

arr = arr.mapping();

console.log(arr instanceof myArray1); //Output "true"</pre></div><p>In case you don't want to define a default <code class="literal">@@species</code> property in parent constructors, then you can use the <code class="literal">if…else</code> conditional to check whether the <code class="literal">@@species</code> property is defined or not. But the previous pattern is preferred. The built-in <code class="literal">map()</code> method also uses the previous pattern.</p><p>All the built-in methods<a id="id467" class="indexterm"/> of the JavaScript constructors in ES6 look for a <code class="literal">@@species</code> property if they return a new instance. For example, the methods of <code class="literal">Array</code>, <code class="literal">Map</code>, <code class="literal">ArrayBuffer</code>, <code class="literal">Promise</code>, and other such constructors look for the <code class="literal">@@species</code> property if they return new instances.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec110"/>The "new.target" implicit parameter</h2></div></div></div><p>ES6 adds a parameter named <code class="literal">new.target</code> to all the <a id="id468" class="indexterm"/>functions. The dot in between is a part of the parameter name.</p><p>The default value of <code class="literal">new.target</code> is <code class="literal">undefined</code>. But when a function is invoked as a constructor, the value of the <code class="literal">new.target</code> parameter depends on the following conditions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If a constructor is invoked using a <code class="literal">new</code> operator, then <code class="literal">new.target</code> points to this constructor</li><li class="listitem" style="list-style-type: disc">If a constructor is invoked via <code class="literal">super</code> keyword, then the value of <code class="literal">new.target</code> in it is the same as the value of <code class="literal">new.target</code> of the constructor that is called <code class="literal">super</code>.</li></ul></div><p>Inside an arrow function, the value of <code class="literal">new.target</code> is the same as the value of <code class="literal">new.target</code> of the surrounding non-arrow function.</p><p>Here is an example code to demonstrate this:</p><div><pre class="programlisting">function myConstructor()
{
  console.log(new.target.name);
}

class myClass extends myConstructor
{
  constructor()
  {
    super();
  }
}

var obj1 = new myClass();
var obj2 = new myConstructor();</pre></div><p>The output is as follows:</p><div><pre class="programlisting">myClass
myConstructor</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Using "super" in the object literals</h1></div></div></div><p>The <code class="literal">super</code> keyword can also be <a id="id469" class="indexterm"/>used in the concise methods of the object <a id="id470" class="indexterm"/>literals. The <code class="literal">super</code> keyword in concise methods of the object literals, has the same value as the <code class="literal">[[prototype]]</code> property of the object defined by the object literal.</p><p>In the object literals, <code class="literal">super</code> is used to access the over-ridden properties by the child object.</p><p>Here is an example to demonstrate how to use <code class="literal">super</code> in object literals:</p><div><pre class="programlisting">var obj1 = {
  print(){
    console.log("Hello");
  }
}

var obj2 = {
  print(){
    super.print();
  }
}

Object.setPrototypeOf(obj2, obj1);
obj2.print(); //Output "Hello"</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we first learned the basics of the object-oriented programming using ES5. Then, we jumped into ES6 classes, and learned how it makes easy for us to read and write the object-oriented JavaScript code. We also learned miscellaneous features, such as the <code class="literal">new.target</code> and accessor methods.</p><p>In the next chapter, we will learn how to create and use the ES6 modules.</p></div></body></html>