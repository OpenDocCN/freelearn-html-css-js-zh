- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: In this chapter, we will cover several topics that will assist you in the long-term
    maintenance of your D3 code base. The goal is to create a foundation to build
    reusable assets that can be easily unit tested while leveraging popular tools
    and techniques already established in the JavaScript community.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍几个有助于长期维护您的 D3 代码库的话题。目标是建立一个基础，以构建可重用资产，这些资产可以轻松地进行单元测试，同时利用已经在 JavaScript
    社区中确立的流行工具和技术。
- en: 'Unit testing is important in any software development project, especially in
    a D3 code base. Typically, these projects involve a lot of code that applies analytics
    or manipulates data structures. For these types of problems, unit testing can
    help in the following ways:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在任何软件开发项目中都很重要，尤其是在 D3 代码库中。通常，这些项目涉及大量应用分析或操作数据结构的代码。对于这类问题，单元测试可以帮助以下方面：
- en: '**Reduce bugs**: An automated test suite will allow the developer to break
    down and test individual components. These tests will be run constantly throughout
    the development cycle, validating that future features do not break the older
    working code.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少错误**：自动化的测试套件将允许开发者分解并测试单个组件。这些测试将在整个开发周期中不断运行，验证新功能不会破坏旧的工作代码。'
- en: '**Document accurately**: Often, tests are written in a human-readable way;
    this precisely describes the problem they are testing against. An example of the
    code provides much better documentation than a long paragraph.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准确记录**：通常，测试是以人类可读的方式编写的；它们精确地描述了它们正在测试的问题。提供的代码示例比长段落提供了更好的文档。'
- en: '**Allow refactoring**: The developer can change code semantics and design with
    confidence, knowing that the inputs and outputs are still tracked and validated.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许重构**：开发者可以自信地更改代码语义和设计，因为他们知道输入和输出仍然被跟踪和验证。'
- en: '**Make development faster**: Most developers spend time validating their work
    as they write. We''ve seen developers tirelessly refresh browsers, check console
    logs, and inspect DOM elements as they go. Instead of performing these manual
    actions over and over again, simply wrap them up in a framework that does the
    work for you.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加快开发速度**：大多数开发者花费时间验证他们的工作。我们见过开发者不懈地刷新浏览器、检查控制台日志和检查 DOM 元素。与其反复执行这些手动操作，不如简单地用框架将它们封装起来，由框架为您完成工作。'
- en: 'This chapter will explore a Bootstrap project that we like to use when starting
    a new visualization development. The concepts covered in the project include:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨我们在开始新的可视化开发时喜欢使用的 Bootstrap 项目。项目中涵盖的概念包括：
- en: Project structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构
- en: Code organization and reusable assets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码组织和可重用资产
- en: Unit testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: A resilient code base
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性代码库
- en: Code organization and reusable assets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织和可重用资产
- en: The foundation of our way of writing reusable and testable D3 code is from Mike
    Bostock's blog article, *Towards Reusable Charts*, at [http://bost.ocks.org/mike/chart/](http://bost.ocks.org/mike/chart/).
    At its core, it sets out to implement charts as closures with `getter` and `setter`
    methods. This makes the code more readable and simple for testing. It is actually
    a great idea to read this article before continuing, as we can take some of our
    career experiences and extend these concepts a little further. The project structure
    is organized to achieve several goals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写可重用和可测试 D3 代码的基础来自迈克·博斯托克的博客文章 *Towards Reusable Charts*，在 [http://bost.ocks.org/mike/chart/](http://bost.ocks.org/mike/chart/)。其核心是尝试将图表实现为具有
    `getter` 和 `setter` 方法的闭包。这使得代码更易于阅读和测试。实际上，在继续之前阅读这篇文章是个好主意，因为我们可以借鉴一些我们的职业经验并将这些概念进一步扩展。项目结构旨在实现几个目标。
- en: Project structure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'The Bootstrap project contains the following files and directories:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 项目包含以下文件和目录：
- en: '![](img/d05ec2e4-9081-4607-b672-5a1358f582a9.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d05ec2e4-9081-4607-b672-5a1358f582a9.png)'
- en: 'The project works out of the box with example code already in place. To see
    this in action, we will launch the example. From the example Bootstrap code provided,
    first, install all the dependencies (note that you only have to execute this command
    once):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 项目自带示例代码即可运行。为了看到这一效果，我们将启动示例。从提供的示例 Bootstrap 代码开始，首先安装所有依赖项（请注意，您只需执行此命令一次）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to see the visualization, execute  the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了查看可视化效果，执行以下操作：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, open the browser to `http://localhost:8080`. You should see three bars
    changing based on random data in a series of tests. Note that if you have the
    previous examples already open, you will have to kill that process in order to
    run this one, as both of them use the same port.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开浏览器到`http://localhost:8080`。你应该会看到一系列测试中基于随机数据的三个条形图在变化。请注意，如果你已经打开了之前的示例，你必须终止该进程才能运行这个，因为它们都使用了相同的端口。
- en: 'To see the unit tests working, just execute the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看单元测试的工作情况，只需执行以下操作：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see a summary of five unit tests running in the terminal, and a
    continuous running process monitoring your project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端中看到五个单元测试的摘要，以及一个持续运行的过程来监控你的项目：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will explain how to write unit tests for the project later in this chapter.
    For a quick peek at what tests are running, look at `spec/viz_spec.js`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面解释如何为项目编写单元测试。要快速查看正在运行的测试，请查看`spec/viz_spec.js`。
- en: If you change any of the methods in this file, you will notice that the test
    runner will detect that a change has been made in the code and re-execute the
    tests! This provides a fantastic feedback loop to the developer as you continue
    to enhance your work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改此文件中的任何方法，你会注意到测试运行器会检测到代码中的更改并重新执行测试！这为开发者提供了一个极好的反馈循环，随着你继续完善你的工作。
- en: Exploring the code directory
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索代码目录
- en: 'In this section, we will cover each file in detail and explain its importance
    in the overall package:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细介绍每个文件并解释它在整体包中的重要性：
- en: '`index.html`: This file is the starting point of the visualization and will
    launch automatically when you point your browser to `http://localhost:8080`. You
    will notice that the file contains many of the points already covered in the book
    in terms of loading up the proper assets. As we walk through the `index.html`
    file, we will identify the other directories and files used in the project.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`: 此文件是可视化的起点，当你将浏览器指向`http://localhost:8080`时将自动启动。你会注意到该文件包含了许多在书中已经讨论过的点，例如加载适当的资源。随着我们遍历`index.html`文件，我们将识别项目中使用的其他目录和文件。'
- en: '`main.css`: The `main.css` file is used to apply specific CSS styling to'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.css`: `main.css`文件用于应用特定的CSS样式：'
- en: 'your visualization:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的可视化：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`vendor`: This directory contains all the external libraries that we need to
    use in the visualization and is loaded at the bottom of the `index.html` file:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor`: 此目录包含我们在可视化中需要使用的所有外部库，并在`index.html`文件的底部加载：'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We like to keep these to a minimum so that we have as few dependencies on the
    outside world as possible. In this case, we are only using the core D3 library
    and TopoJSON to help us with the GeoJSON encoding.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们喜欢将这些保持到最小，以便尽可能少地对外部世界有依赖。在这种情况下，我们只使用核心D3库和TopoJSON来帮助我们进行GeoJSON编码。
- en: '`scripts`: This is another directory; there are some new additions to the files
    we are loading in order to create the visualization:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`: 这又是一个目录；我们在加载的文件中添加了一些新内容，以创建可视化：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `base.js` script contains some common D3 patterns that are reused in many
    examples (such as containing the visualization in a chart area `<g>` with a predefined
    margin object, common methods to calculate height and width based on this margin
    object, and a handy utility to find the existing container and binding data).
    The `base.js` script is also an excellent location to keep the reusable code.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base.js`脚本包含了一些在许多示例中重复使用的常见D3模式（例如，在具有预定义边距对象的`<g>`图表区域中包含可视化，基于此边距对象计算高度和宽度的常用方法，以及一个方便的实用工具来查找现有容器并绑定数据）。`base.js`脚本也是一个很好的位置来存放可重用代码。'
- en: The `viz.js` script is an example that leverages many of the concepts in *Towards
    Reusable Charts* with some inheritance gained from `base.js`. The `viz.js` script
    is the workhorse of the project and where most of the visualization code will
    reside.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viz.js`脚本是一个示例，它利用了*《迈向可重用图表》*中的许多概念，并从`base.js`中获得了一些继承。`viz.js`脚本是项目的核心，大部分可视化代码都将驻留于此。'
- en: '`factories`: This too is a directory. In order to show our work in the browser,
    we need a script to generate some data, select the element in the DOM, and initiate
    the visualization call. These scripts are organized in the `factories` directory.
    An example of this can be viewed in the `viz_factory.js` file:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`factories`: 这也是一个目录。为了在我们的浏览器中展示我们的工作，我们需要一个脚本来生成一些数据，选择DOM中的元素，并启动可视化调用。这些脚本组织在`factories`目录中。这个示例可以在`viz_factory.js`文件中查看：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`spec`: The tests you write to validate the methods in the visualization code
    go here. A detailed example will be provided later in this chapter.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`：你编写的测试以验证可视化代码中的方法，这里。将在本章后面提供详细示例。'
- en: Other administrative files
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他管理文件
- en: 'Two additional files that assist with the operation of the Bootstrap project
    are as follows; these files rarely require any modification:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个辅助文件用于Bootstrap项目的操作，这些文件很少需要任何修改：
- en: '`karma.conf.js`: This is used to set up the unit test runs'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`karma.conf.js`：用于设置单元测试运行'
- en: '`package.json`: This describes which npm packages to install'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`：描述了要安装哪些npm包'
- en: Writing testable code
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可测试的代码
- en: There are dozens of factors to consider when creating visualizations. Every
    design will have its own set of unique requirements and configuration capabilities
    to consider. If you build on the reusable pattern outlined by Mike Bostock, you
    will have a great framework to start with.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建可视化时需要考虑的因素有数十个。每个设计都将有其自己的一套独特的要求和配置能力。如果你基于Mike Bostock概述的可重复使用模式构建，你将有一个很好的框架开始。
- en: When working with data visualizations, we will have some form of data manipulation
    or logic that must be applied to incoming data. There are two notable best practices
    we can leverage to test and validate these operations. They are explained in the
    following sections.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数据可视化时，我们将有一些形式的数据操作或逻辑必须应用于传入的数据。我们可以利用以下两个值得注意的最佳实践来测试和验证这些操作。它们将在以下部分中解释。
- en: Keeping methods/functions small
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持方法/函数小
- en: Small functions mean low cyclomatic complexity. This means there are fewer logic
    branches in each function and, therefore, fewer things to test. If we test each
    simple function thoroughly and independently, then there will be fewer chances
    of things going wrong when we compose them together into larger complex computations.
    A good guideline is to try and keep methods at around 10 lines of code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 小函数意味着低循环复杂度。这意味着每个函数中的逻辑分支更少，因此要测试的东西也更少。如果我们彻底且独立地测试每个简单函数，那么当我们将它们组合成更大的复杂计算时，出错的机会就会更少。一个好的指导原则是尽量保持方法在约10行代码左右。
- en: Preventing side effects
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止副作用
- en: 'This basically means that each small function should not save some state outside
    itself. Try to limit the use of global variables as much as possible and think
    of each function as  the following process:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着每个小函数不应在自身之外保存任何状态。尽可能限制全局变量的使用，并将每个函数视为以下过程：
- en: Data arrives.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据到达。
- en: Perform some operations on the data.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对数据进行一些操作。
- en: Return results.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回结果。
- en: This way we can easily test each function independently, without worrying about
    the effect it has on the global state of the program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以轻松地独立测试每个函数，而不必担心它对程序全局状态的影响。
- en: An example with viz.js
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: viz.js的示例
- en: 'To see this in practice, let''s take a look at the `scripts/viz.js` program
    as a template for creating testable code for the data manipulation functions in
    the visualization. For this example, we will create a set of simple bars that
    are based on the profit of an arbitrary dataset. We are given the sales and cost
    in the data; however, we need to determine the profit for the visualization by
    subtracting the sales from the cost. In this contrived example, we need a few
    small helper functions, which are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实践中学到这一点，让我们以`scripts/viz.js`程序为例，作为创建可视化中数据操作函数可测试代码的模板。在这个例子中，我们将创建一组基于任意数据集利润的简单条形图。我们得到了数据中的销售额和成本；然而，我们需要通过从成本中减去销售额来确定用于可视化的利润。在这个虚构的例子中，我们需要几个小的辅助函数，如下所示：
- en: A function to take the original dataset and return a new dataset with the profit
    calculated
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，用于从原始数据集生成一个新的数据集，其中包含计算出的利润
- en: A function to retrieve an array of unique categories to apply to an ordinal
    scale
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，用于检索一个唯一类别数组，以应用于序数尺度
- en: A function to determine the maximum profit value in order to build the upper
    bound of our input domain
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，用于确定最大利润值，以便构建我们输入域的上限
- en: If we create these functions with the best practices outlined earlier and expose
    them externally, we can test them in isolation and independently.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面概述的最佳实践来创建这些函数并公开它们，我们就可以在隔离和独立的情况下测试它们。
- en: 'Let''s take a tour of the script to see how it all works together:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览一下脚本，看看它是如何协同工作的：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we will define the namespace for the chart. In this example, our chart
    can be instantiated with `d3.charts.viz`. If the `d3` object with the charts property
    does not exist, or if it is not of the `type` object, create it, using classical
    functional inheritance to leverage common patterns from a `base` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将为图表定义命名空间。在这个例子中，我们的图表可以通过`d3.charts.viz`来实例化。如果带有图表属性的`d3`对象不存在，或者它不是一个`type`对象，则创建它，使用经典的功能继承来利用来自`base`函数的通用模式：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A handy function (see `base.js`) to quickly assign `getters/setters` to the
    closure following the pattern in *Towards Reusable Charts* is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的函数（见`base.js`），可以快速将`getters/setters`分配给遵循*Towards Reusable Charts*中模式的闭包，如下所示：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use the `svg` variable at this level of scope to maintain state when quickly
    appending selectors. The `void 0` is a safer way to initialize the variable as
    undefined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个作用域级别使用`svg`变量来维护在快速添加选择器时的状态。`void 0`是一个初始化变量为undefined的安全方式：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the D3 instance functions that will be used throughout the visualization:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在整个可视化过程中将使用的D3实例函数：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following function represents the main interface to the outside world.
    There is also a set of setup functions commonly seen in D3 visualizations. The
    SVG container is set up in a way that can easily look for existing SVG containers
    in the selector and rebind the data. This makes it much easier to redraw when
    making subsequent calls with new data:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数代表了与外部世界的主要接口。还有一套在D3可视化中常见的前置函数。SVG容器被设置为可以轻松地在选择器中查找现有的SVG容器并重新绑定数据的方式。这使得在后续调用新数据时重新绘制变得更加容易：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that the `chart` function relies on several helper functions (shown
    in the following lines of code) to work with the data. It is also written in such
    a way that we can take advantage of the enter/update/exit pattern:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`chart`函数依赖于几个辅助函数（如下面的代码行所示）来处理数据。它也被编写成可以利用enter/update/exit模式的方式：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function is used to create a new data structure that has profit assigned.
    Note that it takes one data array in as a parameter and returns a newly constructed
    array with the profit attribute added. This function is now exposed externally
    with `viz().profit(data)` and can be easily tested. It does not change any of
    the outside global variables. It is just data in and new data out:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于创建一个新的数据结构，其中分配了利润。请注意，它接受一个数据数组作为参数，并返回一个新构造的数组，其中添加了利润属性。现在，此函数通过`viz().profit(data)`公开外部，可以轻松地进行测试。它不会更改任何外部全局变量。它只是输入数据和新数据：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the exact same pattern as `my.profit(data)`. We will take the data structure
    in as input and return a new data structure, that is, an array of all the categories.
    In the preceding lines of code, you saw that this is leveraged to create the input
    domain.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`my.profit(data)`的模式完全相同。我们将接受数据结构作为输入，并返回一个新的数据结构，即所有类别的数组。在前面的代码行中，你看到了它是如何被用来创建输入域的。
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once again, a simple function to take data in, compute the max, and return that
    maximum value. It is very easy to test and verify with `d3.charts.viz().profitMax(data)`?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个简单的函数，用于接收数据，计算最大值，并返回该最大值。使用`d3.charts.viz().profitMax(data)`非常容易进行测试和验证？
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unit testing
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Now that we have a code base written in a testable way, let's automate those
    tests so that we do not have to perform them manually and can continue to code
    and refactor with ease.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经用可测试的方式编写了代码库，让我们自动化这些测试，这样我们就不必手动执行它们，可以轻松地继续编码和重构。
- en: If you look at the `spec/viz_spec.js` file, you will note some common patterns
    when unit testing. The following code is written with a JavaScript unit-testing
    framework called Jasmine and leverages Karma to execute the tests. You can learn
    more about the Jasmine syntax, assertions, and other features at [http://jasmine.github.io/1.3/introduction.html](http://jasmine.github.io/1.3/introduction.html).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`spec/viz_spec.js`文件，你将注意到单元测试时的一些常见模式。以下代码是用一个名为Jasmine的JavaScript单元测试框架编写的，并利用Karma来执行测试。你可以在[http://jasmine.github.io/1.3/introduction.html](http://jasmine.github.io/1.3/introduction.html)了解更多关于Jasmine语法、断言和其他功能的信息。
- en: The Bootstrap project has everything you need to start testing quickly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap项目包含了你快速开始测试所需的一切。
- en: 'The first step is to start our Karma test runner with this line of code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用以下代码行启动我们的Karma测试运行器：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This runner will watch every edit of the `viz.js` file or the `viz_spec.js`
    file. If any changes are detected, it will automatically rerun every test suite
    and provide the output on the console. If all the tests pass, then the output
    will be all green. If something fails, you will receive a red warning message:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运行器将监视`viz.js`文件或`viz_spec.js`文件的每个编辑。如果检测到任何更改，它将自动重新运行每个测试套件，并在控制台上提供输出。如果所有测试都通过，则输出将全部为绿色。如果有任何失败，你将收到一个红色的警告消息：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create some test data to test your D3 data manipulation functions. The preceding
    `describe` syntax defines the test harness you are about to execute:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一些测试数据来测试你的D3数据操作函数。前面的`describe`语法定义了你即将执行的测试框架：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before every test run, create a new instance of the D3 visualization with some
    default setters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试运行之前，创建一个具有一些默认设置器的D3可视化实例：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is our first test case! In this test, we asserted that we are getting
    a new array from our test data, but with an additional profit attribute. Remember
    that we created the function to have no side effects and to be a small unit of
    work. We will reap the fruits of our labor with this easy-to-test method. Just
    as we did earlier, we will test the list of categories now:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个测试用例！在这个测试中，我们断言从测试数据中得到了一个新的数组，但增加了额外的利润属性。请记住，我们创建这个函数是为了没有副作用，并且是一个小的单元工作。我们将通过这种易于测试的方法收获我们的劳动成果。就像我们之前做的那样，我们现在将测试类别列表：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Calculate the maximum profit, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式计算最大利润：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following are additional example tests to validate that the `height`/`width`,
    bearing in mind the margins, is working properly from our `base.js` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些额外的示例测试，以验证`height`/`width`（考虑到边距）是否在`base.js`函数中正常工作：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As an experiment, try adding new test cases or editing the existing one. Watch
    the test runner report different results.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实验，尝试添加新的测试用例或编辑现有的测试用例。观察测试运行器报告不同的结果。
- en: Creating resilient visualization code
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建健壮的可视化代码
- en: 'We want to make sure that our visualization can react to changing data, with
    minimal effort from the program that calls our code. One way to test different
    permutations of data and ensure that the visualization reacts accordingly is to
    randomly create example data, call the visualization code a number of times, and
    witness the result. These operations are handled in the `factories` directory.
    Let''s take a look at the `viz_factory.js` file as an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想确保我们的可视化可以最小化调用程序的努力来响应数据的变化。测试不同数据排列并确保可视化相应反应的一种方法是通过随机创建示例数据，多次调用可视化代码，并观察结果。这些操作在`factories`目录中处理。让我们以`viz_factory.js`文件为例：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a variable to store our function with `getters` and `setters` as closures.
    In this example, we will use an anonymous function as a wrapper to execute the
    code. This prevents conflicts with other JavaScript code and ensures that our
    visualization will work properly in a protected context:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个变量以存储具有`getters`和`setters`闭包的函数。在这个例子中，我们将使用一个匿名函数作为包装器来执行代码。这可以防止与其他JavaScript代码冲突，并确保我们的可视化在受保护的环境中能够正常工作：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A simple helper function that generates a random number between 1 and 10 is
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的辅助函数，用于生成介于1到10之间的随机数，如下所示：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Generate a fake dataset based on random numbers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基于随机数生成一个假数据集：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Draw the visualization for the first time using these lines of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些代码行首次绘制可视化：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Set a timer for 10 seconds and bind new data to the visualization on iteration.
    The expected behavior is that the visualization will redraw itself on each call.
    Notice how simple it is to pass new data to the visualization. It is a simple
    selector with a new dataset. We have constructed the reusable visualization code
    in such a way that it knows how to react appropriately.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个10秒的定时器，并在迭代中将新数据绑定到可视化上。预期的行为是可视化将在每次调用时重新绘制自己。注意将新数据传递给可视化是多么简单。它只是一个带有新数据集的简单选择器。我们已经以这种方式构建了可重用的可视化代码，使其知道如何适当地做出反应。
- en: 'To see the results in action, simply launch `http-server`, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实际效果，只需启动`http-server`，如下所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, visit `http://localhost:8080`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问`http://localhost:8080`。
- en: Adding a new test case
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个新的测试用例
- en: 'What happens if we change the number of datasets in the array? To test this,
    let''s add a new helper function (called `set()`) to randomly generate a new set
    of data with a random number of elements between 1 and 10:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变数组中的数据集数量会发生什么？为了测试这一点，让我们添加一个新的辅助函数（称为`set()`），它可以随机生成一个包含1到10之间随机元素数量的新数据集：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Modify the `data` function slightly. We will print to the console to validate
    that it is working properly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微修改一下`data`函数。我们将打印到控制台以验证它是否正常工作：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, if we look at `http://localhost:8080` again, we can see that the visualization
    is working properly even with a random amount of data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次查看`http://localhost:8080`，我们可以看到，即使是有随机数量的数据，可视化也能正常工作。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described the techniques to help test your D3 code base
    and to keep it healthy over the lifespan of your project. We also went step by
    step through a Bootstrap project to help you get started with these examples,
    and we took a look at a methodology for structuring your work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了帮助测试您的D3代码库并保持项目生命周期内健康的技巧。我们还逐步通过一个Bootstrap项目来帮助您开始使用这些示例，并查看了一种构建您工作的方法。
- en: Our recommendations are based on many years of experience and many projects
    delivered using D3\. We strongly recommend that you follow good software patterns
    and focus on tests; this will allow you to perfect your craft. Quality is in your
    hands now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议基于多年的经验和许多使用D3完成的项目。我们强烈建议您遵循良好的软件模式并专注于测试；这将使您能够完善您的技艺。现在，质量掌握在您的手中。
