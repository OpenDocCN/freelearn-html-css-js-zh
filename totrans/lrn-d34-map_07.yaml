- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover several topics that will assist you in the long-term
    maintenance of your D3 code base. The goal is to create a foundation to build
    reusable assets that can be easily unit tested while leveraging popular tools
    and techniques already established in the JavaScript community.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is important in any software development project, especially in
    a D3 code base. Typically, these projects involve a lot of code that applies analytics
    or manipulates data structures. For these types of problems, unit testing can
    help in the following ways:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduce bugs**: An automated test suite will allow the developer to break
    down and test individual components. These tests will be run constantly throughout
    the development cycle, validating that future features do not break the older
    working code.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document accurately**: Often, tests are written in a human-readable way;
    this precisely describes the problem they are testing against. An example of the
    code provides much better documentation than a long paragraph.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow refactoring**: The developer can change code semantics and design with
    confidence, knowing that the inputs and outputs are still tracked and validated.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make development faster**: Most developers spend time validating their work
    as they write. We''ve seen developers tirelessly refresh browsers, check console
    logs, and inspect DOM elements as they go. Instead of performing these manual
    actions over and over again, simply wrap them up in a framework that does the
    work for you.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will explore a Bootstrap project that we like to use when starting
    a new visualization development. The concepts covered in the project include:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code organization and reusable assets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A resilient code base
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code organization and reusable assets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The foundation of our way of writing reusable and testable D3 code is from Mike
    Bostock's blog article, *Towards Reusable Charts*, at [http://bost.ocks.org/mike/chart/](http://bost.ocks.org/mike/chart/).
    At its core, it sets out to implement charts as closures with `getter` and `setter`
    methods. This makes the code more readable and simple for testing. It is actually
    a great idea to read this article before continuing, as we can take some of our
    career experiences and extend these concepts a little further. The project structure
    is organized to achieve several goals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Bootstrap project contains the following files and directories:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d05ec2e4-9081-4607-b672-5a1358f582a9.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'The project works out of the box with example code already in place. To see
    this in action, we will launch the example. From the example Bootstrap code provided,
    first, install all the dependencies (note that you only have to execute this command
    once):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to see the visualization, execute  the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, open the browser to `http://localhost:8080`. You should see three bars
    changing based on random data in a series of tests. Note that if you have the
    previous examples already open, you will have to kill that process in order to
    run this one, as both of them use the same port.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the unit tests working, just execute the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see a summary of five unit tests running in the terminal, and a
    continuous running process monitoring your project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will explain how to write unit tests for the project later in this chapter.
    For a quick peek at what tests are running, look at `spec/viz_spec.js`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: If you change any of the methods in this file, you will notice that the test
    runner will detect that a change has been made in the code and re-execute the
    tests! This provides a fantastic feedback loop to the developer as you continue
    to enhance your work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the code directory
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover each file in detail and explain its importance
    in the overall package:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`: This file is the starting point of the visualization and will
    launch automatically when you point your browser to `http://localhost:8080`. You
    will notice that the file contains many of the points already covered in the book
    in terms of loading up the proper assets. As we walk through the `index.html`
    file, we will identify the other directories and files used in the project.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.css`: The `main.css` file is used to apply specific CSS styling to'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'your visualization:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`vendor`: This directory contains all the external libraries that we need to
    use in the visualization and is loaded at the bottom of the `index.html` file:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We like to keep these to a minimum so that we have as few dependencies on the
    outside world as possible. In this case, we are only using the core D3 library
    and TopoJSON to help us with the GeoJSON encoding.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts`: This is another directory; there are some new additions to the files
    we are loading in order to create the visualization:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `base.js` script contains some common D3 patterns that are reused in many
    examples (such as containing the visualization in a chart area `<g>` with a predefined
    margin object, common methods to calculate height and width based on this margin
    object, and a handy utility to find the existing container and binding data).
    The `base.js` script is also an excellent location to keep the reusable code.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `viz.js` script is an example that leverages many of the concepts in *Towards
    Reusable Charts* with some inheritance gained from `base.js`. The `viz.js` script
    is the workhorse of the project and where most of the visualization code will
    reside.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factories`: This too is a directory. In order to show our work in the browser,
    we need a script to generate some data, select the element in the DOM, and initiate
    the visualization call. These scripts are organized in the `factories` directory.
    An example of this can be viewed in the `viz_factory.js` file:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`spec`: The tests you write to validate the methods in the visualization code
    go here. A detailed example will be provided later in this chapter.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other administrative files
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two additional files that assist with the operation of the Bootstrap project
    are as follows; these files rarely require any modification:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`karma.conf.js`: This is used to set up the unit test runs'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`: This describes which npm packages to install'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing testable code
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are dozens of factors to consider when creating visualizations. Every
    design will have its own set of unique requirements and configuration capabilities
    to consider. If you build on the reusable pattern outlined by Mike Bostock, you
    will have a great framework to start with.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: When working with data visualizations, we will have some form of data manipulation
    or logic that must be applied to incoming data. There are two notable best practices
    we can leverage to test and validate these operations. They are explained in the
    following sections.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Keeping methods/functions small
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Small functions mean low cyclomatic complexity. This means there are fewer logic
    branches in each function and, therefore, fewer things to test. If we test each
    simple function thoroughly and independently, then there will be fewer chances
    of things going wrong when we compose them together into larger complex computations.
    A good guideline is to try and keep methods at around 10 lines of code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Preventing side effects
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This basically means that each small function should not save some state outside
    itself. Try to limit the use of global variables as much as possible and think
    of each function as  the following process:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Data arrives.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform some operations on the data.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return results.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way we can easily test each function independently, without worrying about
    the effect it has on the global state of the program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: An example with viz.js
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see this in practice, let''s take a look at the `scripts/viz.js` program
    as a template for creating testable code for the data manipulation functions in
    the visualization. For this example, we will create a set of simple bars that
    are based on the profit of an arbitrary dataset. We are given the sales and cost
    in the data; however, we need to determine the profit for the visualization by
    subtracting the sales from the cost. In this contrived example, we need a few
    small helper functions, which are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: A function to take the original dataset and return a new dataset with the profit
    calculated
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to retrieve an array of unique categories to apply to an ordinal
    scale
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to determine the maximum profit value in order to build the upper
    bound of our input domain
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we create these functions with the best practices outlined earlier and expose
    them externally, we can test them in isolation and independently.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a tour of the script to see how it all works together:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we will define the namespace for the chart. In this example, our chart
    can be instantiated with `d3.charts.viz`. If the `d3` object with the charts property
    does not exist, or if it is not of the `type` object, create it, using classical
    functional inheritance to leverage common patterns from a `base` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A handy function (see `base.js`) to quickly assign `getters/setters` to the
    closure following the pattern in *Towards Reusable Charts* is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use the `svg` variable at this level of scope to maintain state when quickly
    appending selectors. The `void 0` is a safer way to initialize the variable as
    undefined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the D3 instance functions that will be used throughout the visualization:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following function represents the main interface to the outside world.
    There is also a set of setup functions commonly seen in D3 visualizations. The
    SVG container is set up in a way that can easily look for existing SVG containers
    in the selector and rebind the data. This makes it much easier to redraw when
    making subsequent calls with new data:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that the `chart` function relies on several helper functions (shown
    in the following lines of code) to work with the data. It is also written in such
    a way that we can take advantage of the enter/update/exit pattern:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function is used to create a new data structure that has profit assigned.
    Note that it takes one data array in as a parameter and returns a newly constructed
    array with the profit attribute added. This function is now exposed externally
    with `viz().profit(data)` and can be easily tested. It does not change any of
    the outside global variables. It is just data in and new data out:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the exact same pattern as `my.profit(data)`. We will take the data structure
    in as input and return a new data structure, that is, an array of all the categories.
    In the preceding lines of code, you saw that this is leveraged to create the input
    domain.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once again, a simple function to take data in, compute the max, and return that
    maximum value. It is very easy to test and verify with `d3.charts.viz().profitMax(data)`?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unit testing
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a code base written in a testable way, let's automate those
    tests so that we do not have to perform them manually and can continue to code
    and refactor with ease.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the `spec/viz_spec.js` file, you will note some common patterns
    when unit testing. The following code is written with a JavaScript unit-testing
    framework called Jasmine and leverages Karma to execute the tests. You can learn
    more about the Jasmine syntax, assertions, and other features at [http://jasmine.github.io/1.3/introduction.html](http://jasmine.github.io/1.3/introduction.html).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The Bootstrap project has everything you need to start testing quickly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to start our Karma test runner with this line of code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This runner will watch every edit of the `viz.js` file or the `viz_spec.js`
    file. If any changes are detected, it will automatically rerun every test suite
    and provide the output on the console. If all the tests pass, then the output
    will be all green. If something fails, you will receive a red warning message:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create some test data to test your D3 data manipulation functions. The preceding
    `describe` syntax defines the test harness you are about to execute:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before every test run, create a new instance of the D3 visualization with some
    default setters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is our first test case! In this test, we asserted that we are getting
    a new array from our test data, but with an additional profit attribute. Remember
    that we created the function to have no side effects and to be a small unit of
    work. We will reap the fruits of our labor with this easy-to-test method. Just
    as we did earlier, we will test the list of categories now:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Calculate the maximum profit, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following are additional example tests to validate that the `height`/`width`,
    bearing in mind the margins, is working properly from our `base.js` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As an experiment, try adding new test cases or editing the existing one. Watch
    the test runner report different results.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Creating resilient visualization code
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to make sure that our visualization can react to changing data, with
    minimal effort from the program that calls our code. One way to test different
    permutations of data and ensure that the visualization reacts accordingly is to
    randomly create example data, call the visualization code a number of times, and
    witness the result. These operations are handled in the `factories` directory.
    Let''s take a look at the `viz_factory.js` file as an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a variable to store our function with `getters` and `setters` as closures.
    In this example, we will use an anonymous function as a wrapper to execute the
    code. This prevents conflicts with other JavaScript code and ensures that our
    visualization will work properly in a protected context:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A simple helper function that generates a random number between 1 and 10 is
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Generate a fake dataset based on random numbers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Draw the visualization for the first time using these lines of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Set a timer for 10 seconds and bind new data to the visualization on iteration.
    The expected behavior is that the visualization will redraw itself on each call.
    Notice how simple it is to pass new data to the visualization. It is a simple
    selector with a new dataset. We have constructed the reusable visualization code
    in such a way that it knows how to react appropriately.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the results in action, simply launch `http-server`, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, visit `http://localhost:8080`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new test case
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What happens if we change the number of datasets in the array? To test this,
    let''s add a new helper function (called `set()`) to randomly generate a new set
    of data with a random number of elements between 1 and 10:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Modify the `data` function slightly. We will print to the console to validate
    that it is working properly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微修改一下`data`函数。我们将打印到控制台以验证它是否正常工作：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, if we look at `http://localhost:8080` again, we can see that the visualization
    is working properly even with a random amount of data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次查看`http://localhost:8080`，我们可以看到，即使是有随机数量的数据，可视化也能正常工作。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described the techniques to help test your D3 code base
    and to keep it healthy over the lifespan of your project. We also went step by
    step through a Bootstrap project to help you get started with these examples,
    and we took a look at a methodology for structuring your work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了帮助测试您的D3代码库并保持项目生命周期内健康的技巧。我们还逐步通过一个Bootstrap项目来帮助您开始使用这些示例，并查看了一种构建您工作的方法。
- en: Our recommendations are based on many years of experience and many projects
    delivered using D3\. We strongly recommend that you follow good software patterns
    and focus on tests; this will allow you to perfect your craft. Quality is in your
    hands now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议基于多年的经验和许多使用D3完成的项目。我们强烈建议您遵循良好的软件模式并专注于测试；这将使您能够完善您的技艺。现在，质量掌握在您的手中。
