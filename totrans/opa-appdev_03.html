<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Developing Web Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Developing Web Applications</h1></div></div></div><p>Opa is designed for <a id="id111" class="indexterm"/>rapid and secure web development. In this chapter, we <a id="id112" class="indexterm"/>will talk about the fundamental knowledge about developing a web application in Opa.</p><div class="section" title="Starting a web server"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Starting a web server</h1></div></div></div><p>The first thing <a id="id113" class="indexterm"/>we need for a web application<a id="id114" class="indexterm"/> is a web server. In this section we will see how to start a web server using Opa.</p><div class="section" title="A simple example"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>A simple example</h2></div></div></div><p>As a <a id="id115" class="indexterm"/>web application, resources such as web pages, images, and audios need to be served to users; therefore, we need an HTTP server. Let's think for a moment about how we would do that in PHP. The typical setup would be an Apache HTTP server with mod_php5 installed.</p><p>With Opa, things are a bit different. We not only implement our application, but also the whole HTTP server. In fact, our web application and its web server are basically the same. Our code will be translated into Node.js script after compilation, and will be run with Node.js. The benefit of integrating the server with a web application is increased security. Let's just start with a simple example:</p><div class="informalexample"><pre class="programlisting">Server.start(Server.http, {text: "hello Opa"})</pre></div><p>Save this code into a file, <code class="literal">301.opa</code> for example, then compile and run it. The two concluding dashes are<a id="id116" class="indexterm"/> needed to launch the web application after it has completed the compilation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ opa 301.opa –-</strong></span>
</pre></div><p>The output will be:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Http serving on http://localhost:8080</strong></span>
</pre></div><p>Type this address in your browser and you will see something like this:</p><div class="mediaobject"><img src="graphics/3749OS_03_01.jpg" alt="A simple example"/></div></div><div class="section" title="The server module"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>The server module</h2></div></div></div><p>We have started a<a id="id117" class="indexterm"/> web server and run our first Opa web application <a id="id118" class="indexterm"/>with the function <code class="literal">Server.start</code>. Let's now take a detailed <a id="id119" class="indexterm"/>look at this function:</p><div class="informalexample"><pre class="programlisting">void start(Server.conf arg1, Server.handler handler)</pre></div><p>The function starts a web server with two parameters, the first is configuration information and the second is request handler. The <code class="literal">Server.conf</code>
<a id="id120" class="indexterm"/> type is the configuration for <a id="id121" class="indexterm"/>the server. It is a record type with the following fields:</p><div class="informalexample"><pre class="programlisting">type Server.conf = {
  int port,                    //port server runs on
  ip netmask,                  //netmask
  Server.encryption encryption,//secure config if using https
  String name                  //server name
}</pre></div><p>In most cases, we<a id="id122" class="indexterm"/> do not want to define all the elements in this type. We can extend from the static value <code class="literal">Server.http</code>. <code class="literal">Server.http</code> is a predefined default configuration with port equal to 8080 <a id="id123" class="indexterm"/>and the server protocol is http, and the default configuration for https is <code class="literal">Server.https</code><a id="id124" class="indexterm"/>. In the following two lines, we are reusing the <code class="literal">Server.http</code> configuration, replacing port 8080 by port 8088 by using the instruction <code class="literal">with port: 8088</code>.</p><div class="informalexample"><pre class="programlisting">conf = {Server.http with port: 8088}
Server.start(conf,{text: "Hello Opa!"})</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>You can also run your application with the –p option to change the port, which will override this.</p></div></div><p>Our web server will need to answer differently to different requests, depending on which URL was being requested. Therefore, we will need <code class="literal">Server.handler</code>
<a id="id125" class="indexterm"/> to handle these requests. The <code class="literal">Server.handler</code> type is much more complicated than the <code class="literal">Server.conf</code> type. It defines how our web server will handle the incoming requests. It's a variant with eight cases:</p><div class="informalexample"><pre class="programlisting">type Server.handler = 
  {string text} or
  {string title, (-&gt; xhtml) page} or
  {stringmap(resource) resources} or
  {(Uri.relative -&gt; resource) dispatch} or
  {Server.filter filter, (Uri.relative -&gt; resource) dispatch} or
  {Server.registrable_resource register} or
  {Parser.general_parser(resource) custom} or
  list(Server.handler)</pre></div><p>In the example at the beginning of this chapter, we used the simplest case—<code class="literal">{string text}</code>. It accepts<a id="id126" class="indexterm"/> all the requests and just shows some text on the page. Let's see how the second case, <code class="literal">{string title, (-&gt; xhtml) page}</code>, works:</p><div class="informalexample"><pre class="programlisting">Server.start(Server.http, {
  title: "Opa world"
  page : function(){ &lt;h1&gt;Hello Opa!&lt;/h1&gt; }
})</pre></div><p>The second case also handles all the requests, but it servers a single page. The field page is a function with the type <code class="literal">void -&gt; xhtml</code>, which indicates that the function accepts no parameter and produces a value of the type <code class="literal">xhtml</code>. We will talk about XHTML later; the result looks like this:</p><div class="mediaobject"><img src="graphics/3749OS_03_02.jpg" alt="The server module"/></div><p>We can notice from this screenshot that, compared to the first example, what has changed is that the web page we sent to the browser includes HTML markup that the web browser renders as a heading type.</p></div></div></div>
<div class="section" title="Dispatching requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Dispatching requests</h1></div></div></div><p>We have<a id="id127" class="indexterm"/> gone through the first two cases of <code class="literal">Server.handler</code>. They are both simple and accept all requests. But in real web applications, <a id="id128" class="indexterm"/>requests and responses are much more complicated, and the web server should respond differently according to different requests. This section we will cover the remaining cases of <code class="literal">Server.handler</code> and will show how to handle different types of requests.</p><div class="section" title="The resource handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>The resource handler</h2></div></div></div><p>A <a id="id129" class="indexterm"/>resource handler<a id="id130" class="indexterm"/> is often used to serve static resources such as images and sounds. The case <code class="literal">{stringmap(resource) resources}</code> performs on a non-decoded URI (Uniform Resource Identifier)<a id="id131" class="indexterm"/>, and returns a resource that the URI matches with the resource's stringmap. To make it clear, let's suppose there are three images in the directory <code class="literal">res: opa1.png, opa2.png, and opa3.png</code>.</p><p>If we create the resources stringmap manually, it should look like this:</p><div class="informalexample"><pre class="programlisting">"res/opa1.png" -&gt; a resource of opa1.png
"res/opa2.png" -&gt; a resource of opa2.png
"res/opa3.png" -&gt; a resource of opa3.png</pre></div><p>The relative URI is the key and the resource of the <code class="literal">.png</code> file is the value, that is, <code class="literal">"res/opa1.png"</code> is the key and <code class="literal">opa1.png</code>, as a resource, is the value. If the user tries to access the URL <code class="literal">http://localhost:8080/res/opa1.png</code>, the non-decoded relative URI will be <code class="literal">res/opa1.png</code>. The server will try to find the corresponding resource <code class="literal">opa1.png</code> and <a id="id132" class="indexterm"/>serve it back to the user.</p><p>So, how can we add these external files? In Opa, we can use the following two directives. These directives will be replaced by a proper value at compile time:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@static_content("foo.png")</code> is replaced by a function that returns the content of <code class="literal">compile-time foo.png</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@static_resource("foo.png")</code> is replaced by a value of the resource type <code class="literal">represents foo.png</code>, with the last modification time, MIME type, among others.</li></ul></div><p>The difference between these two directives is that <code class="literal">@static_content</code>
<a id="id133" class="indexterm"/> is replaced by a function, while <code class="literal">@static_resource</code>
<a id="id134" class="indexterm"/> is replaced by a resource. Both directives have a counterpart that, instead of processing and returning one file, processes a directory and returns it as a stringmap:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@static_content_directory("foo/")</code> is replaced by a stringmap from file name <code class="literal">f</code> in the directory <code class="literal">foo/ to @static_content("f")</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">@static_resource_directory("foo/")</code> is replaced by a stringmap from file name <code class="literal">f</code> in the directory foo/ to <code class="literal">@static_resource("f")</code></li></ul></div><p>Now, it is very clear that if we want to serve resources in the directory <code class="literal">res</code>, all we need to do is write the code as follows:</p><div class="informalexample"><pre class="programlisting">Server.start(Server.http,{
  resources: @static_resource_directory("res")
})</pre></div><p>We can get the resource at <code class="literal">http://localhost:8080/res/opa1.png</code>.</p></div><div class="section" title="The dispatch handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>The dispatch handler</h2></div></div></div><p>The <a id="id135" class="indexterm"/>resource handler is very useful for static resources. But<a id="id136" class="indexterm"/> frequently, the server needs to respond to different requests. The case <code class="literal">{(Uri.relative  -&gt; resource) dispatch}</code> is just for that. In this case, the request URL is decoded into an <code class="literal">Uri.relative</code> record, which is defined as:</p><div class="informalexample"><pre class="programlisting">type Uri.relative ={
  list(string) path,
  list((string, string)) query,
  option(string) fragment,
  bool is_directory,
  bool is_from_root
}</pre></div><p>Let's suppose the user request URL is <code class="literal">http://localhost:8080/admin/find?name=Li&amp;age=28</code>, the record will be:</p><div class="informalexample"><pre class="programlisting">{ path: [admin,find],            //a list of path
  query: [(name,Li),(age,28)],   //a list of tuple2
  ...}                        //we do not care about the fields here.</pre></div><p>Having this record, we should return a corresponding resource. Most of the time, pattern matching is used to dispatch requests. Here is an example:</p><div class="informalexample"><pre class="programlisting">function dispatch(uri){
  match(uri){
  case {path:[],...} ：Resource.page("Login",&lt;h1&gt;Login&lt;/h1&gt;);
  case {path:["admin"|_],...}:Resource.page("Admin", &lt;h1&gt;Admin&lt;/h1&gt;);
  case {path:["user",x|_],...}:Resource.page("User", &lt;h1&gt;User:{x}&lt;/h1&gt;);
  }
}
Server.start(Server.http,{~dispatch})</pre></div><p>Remember what we discussed about pattern matching in the last chapter? It is not hard to figure out <a id="id137" class="indexterm"/>what happens here. Note that pattern matching is not the only way to dispatch requests. You can do almost anything you want to return a resource for a given URI. Besides, we can also add a filter with the case <code class="literal">{Server.filter filter, (Uri.relative-&gt;resource) dispatch}</code>:</p><div class="informalexample"><pre class="programlisting">Server.start(Server.http,{
  filter: Server.Filter.path(["opa","packt"]),
  dispatch: function(_){
    Resource.page("opa packt",&lt;h1&gt; Hello Opa!&lt;/h1&gt;)
  }
})</pre></div><p>This code will only allow user to access <code class="literal">http://localhost:8080/opa/packt</code>.</p></div><div class="section" title="The register handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>The register handler</h2></div></div></div><p>The <a id="id138" class="indexterm"/>case <code class="literal">{Server.registrable_resource register}</code> is <a id="id139" class="indexterm"/>an empty request handler, which means it will not handle any request. But it is useful for registering external resources such as <code class="literal">js</code> and <code class="literal">css</code>, so that we can use them in our application.</p><div class="informalexample"><pre class="programlisting">Server.start(Server.http,{
  register: [ 
    {doctype: {html5}}, 
    {js: ["/res/js/js1.js","/res/js/js2.js"]},
    {css: ["/res/css/style1.css","/res/css/style2.css"]}
  ]
});</pre></div><p>In this <a id="id140" class="indexterm"/>example, we registered the <code class="literal">doctype</code> as <code class="literal">html5</code>, and some<a id="id141" class="indexterm"/> external JavaScript and CSS. The JavaScript and CSS registered here is application-wide. It means we can use codes from JavaScript and styles from CSS in any page that we create in this application.</p></div><div class="section" title="The customize handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>The customize handler</h2></div></div></div><p>The <a id="id142" class="indexterm"/>case <code class="literal">{Parser.general_parser(resource) custom}</code> is the most configurable request handler. The<a id="id143" class="indexterm"/> custom parser takes the non-decoded URI from incoming requests as input and computes the corresponding resource. Consider the following example:</p><div class="informalexample"><pre class="programlisting">custom = parser{
  case ("/admin".*) : Resource.page("Admin",&lt;h1&gt;Admin&lt;/h1&gt;);
  case ("/user".*) : Resource.page("User",&lt;h1&gt;User&lt;/h1&gt;);
  case (.*) : Resource.page("default",&lt;h1&gt;default&lt;/h1&gt;);
}
Server.start(Server.http, {~custom});</pre></div><p>This example will match all requests beginning with <code class="literal">"/admin"</code> to the admin page created by the code <code class="literal">Resource.page("Admin",&lt;h1&gt;Admin&lt;/h1&gt;)</code>, all requests beginning with <code class="literal">"/user"</code> to the user page, and all the other requests to a default page. You can refer parser in Opa to get more information about how to deal with more complex cases.</p></div><div class="section" title="The handlers group"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>The handlers group</h2></div></div></div><p>The case<a id="id144" class="indexterm"/> list <code class="literal">(Server.handler)</code> aggregates several request handlers <a id="id145" class="indexterm"/>as a group in response to an incoming request. All handlers are tested in the order that they are listed until one succeeds and returns a resource. For example:</p><div class="informalexample"><pre class="programlisting">Server.start(Server.http,[
{resources: @static_resource_directory("resources")},
  {~dispatch},  //we omitted the definition here
  {~custom},    //we omitted the definition here
  {title:"404", page:function(){ &lt;h1&gt;Page Not Found!&lt;h1&gt; }}
]);</pre></div><p>As a single handler may not be sufficient to deal with all the requests, handlers group is a common solution for most web applications developed by Opa.</p></div></div>
<div class="section" title="Preparing pages"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Preparing pages</h1></div></div></div><p>We have<a id="id146" class="indexterm"/> discussed how to launch the server and <a id="id147" class="indexterm"/>dispatch users' requests. Now it is time for the frontend issue, namely, the web page. <a id="id148" class="indexterm"/>Web pages are what users see and interact with. There are numerous technologies that can be used for building excellent web pages, such as PHP<a id="id149" class="indexterm"/>, Perl<a id="id150" class="indexterm"/>, and Python<a id="id151" class="indexterm"/>. But the basic way is using HTML and CSS.</p><div class="section" title="XHTML"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>XHTML</h2></div></div></div><p>In Opa, both <a id="id152" class="indexterm"/>HTML and CSS are first class citizens, and are understood and checked by the compiler without you having to wrap them as strings. Having XHTML as a native type implies near-perfect XSS (cross-site scripting) protection. It also means we can easily compose elements, that is, we can write <code class="literal">&lt;div&gt;{foo()}&lt;/div&gt;</code>. HTML values have a predefined <code class="literal">xhtml</code> type, and there is a built-in syntax for <a id="id153" class="indexterm"/>constructing XHTML values. Here is an overview of the syntax for XHTML:</p><div class="informalexample"><pre class="programlisting">// XHTML is a data-type with built-in syntax
xhtml span = &lt;span class="test"&gt;Hello Opa!&lt;/span&gt;
//named closing tag is optional,
// so are the quotes around literal attributes
another_span = &lt;span class=test&gt;Hello XHTML&lt;/&gt;</pre></div><p>Inserts for both tags and attributes work in XHTML too:</p><div class="informalexample"><pre class="programlisting">function f(class, content){
  &lt;span class="{class}"&gt; {content} &lt;/span&gt;
}</pre></div></div><div class="section" title="Creating a page"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Creating a page</h2></div></div></div><p>Usually, we <a id="id154" class="indexterm"/>need to serve our web page as a value of the resource type. The function <code class="literal">Resource.page</code>
<a id="id155" class="indexterm"/>, or its shortcut <code class="literal">Resource.html</code>, will help us convert XHTML to a resource. <code class="literal">Resource.page</code> is defined as:</p><div class="informalexample"><pre class="programlisting">resource page(string title, xhtml body)</pre></div><p>The first argument is the title of the web page and the second argument is the content written in XHTML. It will return a value of the resource type that we can return to the user. Here is a simple example:</p><div class="informalexample"><pre class="programlisting">function dispatch(_){
  Resource.page("Opa Packt", &lt;h1&gt;Hello Opa!&lt;/h1&gt;)
}
Server.start(Server.http,{~dispathc})</pre></div><p>This code fragment serves all the requests to the web page. <code class="literal">Resource.page</code> is sufficient for developers<a id="id156" class="indexterm"/> in most cases. But if you need more controls, you can refer to <code class="literal">Resource.styled_page</code> and <code class="literal">Resource.full_page</code>.</p></div><div class="section" title="Adding styles"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Adding styles</h2></div></div></div><p>There are<a id="id157" class="indexterm"/> many ways to add styles. First, just like XHTML, CSS is a predefined datatype in Opa and we can define CSS in Opa code directly:</p><div class="informalexample"><pre class="programlisting">red_style = css { color: red }
span = &lt;span style={red_style} /&gt;
// one can use inserts inside css, i.e. height: {height}px;
function div(width, height, content) {
  &lt;div style={ css { height: {height}px; width: {width}px }}&gt;
   {content}
  &lt;/div&gt;
}</pre></div><p>Another way is using the register handler that we have talked about before:</p><div class="informalexample"><pre class="programlisting">Server.start(Server.http,
  [ {register: {css: ["resources/css/style.css"]}} , ...]
)</pre></div><p>The stylesheets registered by the register handler are available application-wide, which means that you can use them in any page. If you want to add some page specific stylesheets, the choice will be <code class="literal">Resource.styled_page</code>. Here is an example:</p><div class="informalexample"><pre class="programlisting">// save this as file: resources/hello.css
.hello1 { font-size: 20pt }
.hello2 { font-size: 12pt }
//save the following code as a file, compile and run it.
function dispatch(_){
  Resource.styled_page("Opa Packt", ["resources/hello.css"],
    &lt;div class="hello1"&gt;Hello Opa!&lt;/div&gt;
    &lt;div class="hello2"&gt;Hello Opa!&lt;/div&gt;
  )
}
Server.start(Server.http,[
  {resources: @static_resource_directory("resources")},
  {~dispatch}
])</pre></div><p>Compile<a id="id158" class="indexterm"/> and run this code; the result looks like this:</p><div class="mediaobject"><img src="graphics/3749OS_03_03.jpg" alt="Adding styles"/></div></div><div class="section" title="Handling events"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Handling events</h2></div></div></div><p>An <a id="id159" class="indexterm"/>event handler is <a id="id160" class="indexterm"/>a function whose call is triggered by some activity in the user interface. Typical event handlers react to user's clicking (the event is called <code class="literal">click</code>), pressing enter (event <code class="literal">newline</code>), moving the mouse (event <code class="literal">mousemove</code>), or loading the page (event <code class="literal">ready</code>).</p><p>In Opa, an <a id="id161" class="indexterm"/>event handler always has the type <code class="literal">Dom.event -&gt; void</code>. Here is an example:</p><div class="informalexample"><pre class="programlisting">function f1(_){ #test1 = "test1"}
function f2(_){ Dom.set_text(#test2,"clicked"}
function f3(_){ Dom.clear_value(#test3) }
function page(){
  &lt;div id=#test1 onready={f1}&gt;&lt;/div&gt;
  &lt;button id=#test2 onclick={f2}&gt;click&lt;/button&gt;
  &lt;input id=#test3 onnewline={f3}&gt;&lt;/input&gt;
  &lt;div id=#test4 onclick={function(_){ jlog("clicked") }}&gt;&lt;/div&gt;
}
Server.start(Server.http, {title:"Opa Packt", ~page})</pre></div><p>This code<a id="id162" class="indexterm"/> gives an example of how to write event handlers in Opa.</p></div></div>
<div class="section" title="Manipulating DOMs"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Manipulating DOMs</h1></div></div></div><p>The Document Object Model (DOM) is a <a id="id163" class="indexterm"/>platform and<a id="id164" class="indexterm"/> language<a id="id165" class="indexterm"/> neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of documents.</p><p>At times, we may want to change the content of a page dynamically. To accomplish this, we will often need to interact with the DOM. Opa provides the module <code class="literal">Dom</code> for the purpose of manipulating the contents of the page currently being displayed by the<a id="id166" class="indexterm"/> browser. You can use it to add and remove elements to and from the page, to get the contents of a form, or to apply styles or special effects.</p><div class="section" title="DOM selection"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>DOM selection</h2></div></div></div><p>The first step that is necessary, in order to use DOMs, is to select the one that you<a id="id167" class="indexterm"/> want to work with. Opa provides many ways of selecting elements. You can find all the available selection functions in the module <code class="literal">Dom</code>. The most commonly used ones are:</p><div class="informalexample"><pre class="programlisting">Dom.select_id("id")          //select element with a given id
Dom.select_document()        //select the complete document
Dom.select_class("class")    //select elements belongs to a class
Dom.select_children(parent)  //select all children
//and much more, search online Opa API for entry Dom</pre></div><p>As <code class="literal">Dom.select_id</code> is used everywhere and very frequently, Opa provides a shortcut for it. You can simply write <code class="literal">#id</code>. For example:</p><div class="informalexample"><pre class="programlisting">#text   //the same as: dom = Dom.select_id("text")
#{test} //insert can be used in this in combination with the //shortcut notation.
Dom.select_children(#text)</pre></div></div><div class="section" title="Reading values"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Reading values</h2></div></div></div><p>Often we<a id="id168" class="indexterm"/> need to read values or get content from some element of a page. For example, getting user's input or getting the width of an element. Opa provides many <code class="literal">get</code> functions to get information of a given <code class="literal">Dom</code> item. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;input id=#test type="text" value="test1"&gt;test2&lt;/input&gt;
x1 = Dom.get_value(#test)            // x1 = test1, x1 is a string
y1 = Dom.get_text(#test)             // y1 = test2, y1 is a string
x2 = Dom.get_attribute(#test,"type") // x2 = {some: text}
y2 = Dom.get_property(#test,"type")  // y2 = {some: text}
x3 = Dom.get_with(#test)             //x3 is the width of #test
y3 = Dom.get_height(#test)           //y3 is the height of #test</pre></div><p>This example illustrates some commonly used functions on <code class="literal">Dom</code>, we can find more on online Opa<a id="id169" class="indexterm"/> API for the entry Dom. Please do not confuse <code class="literal">Dom.get_value</code>
<a id="id170" class="indexterm"/> with <code class="literal">Dom.get_text</code><a id="id171" class="indexterm"/>. The first one will return the content entered by the user (for example, from an input, a menu, and so on), while the second one will return the content inserted in <code class="literal">Dom</code>. We can figure that out from the second and third line of the example we just saw.</p></div><div class="section" title="Updating content"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Updating content</h2></div></div></div><p>Opa offers<a id="id172" class="indexterm"/> three syntactical shortcuts that simplify some of the most common transformations:</p><div class="informalexample"><pre class="programlisting">#identifier = content  //replace the content
#identifier =+ content //prepend the content
#identifier += content //append the content</pre></div><p>In addition, there are many other functions you can use to add, remove, and update the content of the page:</p><div class="informalexample"><pre class="programlisting">Dom.add_class(#test,"style")    //add a class "style" to #test
Dom.clear_value(#test)	          //clear the value of #test
Dom.put_after(#test,#item)      //move #item after #test
Dom.put_before(#test,#item)     //move #item before #test
Dom.put_replace(#test,#item)    //replace #test with #item
Dom.remove(#test)               //remove dom #test
Dom.remove_class(#test,"style") //remove class "style" in #test
Dom.remove_content(#test)       //remove #test's content
//and for more, search online Opa API for entry Dom</pre></div></div><div class="section" title="Binding an event handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Binding an event handler</h2></div></div></div><p>It is quite common <a id="id173" class="indexterm"/>to bind an event handler dynamically at runtime, especially when you are creating controls programmatically. In Opa, we can do this with <code class="literal">Dom.bind</code>
<a id="id174" class="indexterm"/>,which is defined as:</p><div class="informalexample"><pre class="programlisting">Dom.event_handler bind(dom dom, Dom.event.kind event, 
  ( Dom.event -&gt; void ) handler)</pre></div><p>The function returns a value of the type <code class="literal">Dom.event_handler</code>, which you can use to unbind the event handler. Here is an example:</p><div class="informalexample"><pre class="programlisting">&lt;input id=#test type="button" value="bind"&gt;&lt;/input&gt;
//bind #test's click event with a function
handler = Dom.bind(#test,{click},function(_){ void })
Dom.unbind(#test, handler) //unbind the event handler</pre></div></div><div class="section" title="Animations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Animations</h2></div></div></div><p>Opa provides<a id="id175" class="indexterm"/> several techniques for adding animations to a web page. These include simple, standard animations that are frequently used such as fade-in, fade-out, and hide. To apply an animation to a <code class="literal">Dom</code> item, you should use the function <code class="literal">Dom.transaction</code>
<a id="id176" class="indexterm"/>, which is defined as:</p><div class="informalexample"><pre class="programlisting">Dom.transaction transition(dom item, Dom.animation effect)</pre></div><p>The first parameter is a <code class="literal">Dom</code> item and the second parameter is the effect you want to apply to this <code class="literal">Dom</code> item. You <a id="id177" class="indexterm"/>can find a full list of effects supported by Opa in the module <code class="literal">Dom.Effect</code><a id="id178" class="indexterm"/>. Here is an example of animation:</p><div class="informalexample"><pre class="programlisting">function hide(_){
  _ = Dom.transition(#test,Dom.Effect.hide()); void
}
function page(){
  &lt;div id=#test style="width:100px;height:100px;"&gt;&lt;/div&gt;
  &lt;button id=#btnanim onclick={hide}&gt;Hide&lt;/button&gt;
}
Server.start(Server.http,{title:"Opa Packt", ~page})</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we first introduced how to start a web server with the function <code class="literal">Server.start</code>, which is the starting point of our web application. Then we discussed in detail the different cases of <code class="literal">Server.handler</code>, and how to use them to dispatch user requests. After that, we talked about preparing web pages. Finally, we learned how to change the content of the page dynamically by interacting with DOM.</p></div></body></html>