- en: 11\. Higher-Order Functions and Callbacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 高阶函数和回调
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces higher-order functions and callbacks in TypeScript.
    You will first understand what higher-order functions are, why they are useful,
    and how to type them correctly in TypeScript. Then, the chapter will teach you
    about what callbacks are, why they are used, and in what situations. You will
    also learn about why callbacks are so widely used, especially in Node.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 TypeScript 中的高阶函数和回调。你将首先了解什么是高阶函数，它们为什么有用，以及如何在 TypeScript 中正确地给它们类型化。然后，本章将教你什么是回调，为什么它们被使用，以及在什么情况下使用。你还将了解到为什么回调被广泛使用，尤其是在
    Node.js 中。
- en: Additionally, the chapter will provide you with a basic introduction to the
    event loop. Not only will you learn about "callback hell," but also how you can
    avoid it. By the end of this chapter, you will be able to create a well-typed
    higher-order `pipe` function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还将为你提供一个关于事件循环的基本介绍。你不仅将了解“回调地狱”，还将学习如何避免它。到本章结束时，你将能够创建一个类型化的高阶 `pipe`
    函数。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: You have already covered the use of functions in TypeScript in *Chapter 3*,
    *Functions*. This chapter will introduce you to higher-order functions in TypeScript.
    Hitherto, with all the functions that you have used in this book, you either passed
    parameters or arguments into them. However, JavaScript and, by extension, TypeScript,
    has many ways of composing and writing code. In this chapter, we'll explore one
    such pattern – higher-order functions/callbacks (hereinafter called HOCs) are
    functions that either take in another function as an argument or return a function
    (or both).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 *第 3 章* *函数* 中了解了 TypeScript 中函数的使用。本章将介绍 TypeScript 中的高阶函数。到目前为止，你在这本书中使用的所有函数，要么向它们传递参数或参数，要么通过扩展，TypeScript
    有许多编写代码的组合方式。在本章中，我们将探讨其中一种模式——高阶函数/回调（以下简称 HOCs）是那些要么接受另一个函数作为参数，要么返回一个函数（或两者都是）的函数。
- en: Additionally, this chapter also explores the concept of callbacks. Callbacks
    are required in Node.js, as well as in other JavaScript runtimes, since the language
    is single-threaded and runs in an event loop, and so, in order to not hold up
    the main thread, we let other code run, and when needed it will call our code
    back. This chapter will also touch upon "callback hell" and equip you with the
    skills needed to avoid it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还探讨了回调的概念。在 Node.js 以及其他 JavaScript 运行时中，回调是必需的，因为语言是单线程的，并在事件循环中运行，因此，为了不阻塞主线程，我们让其他代码运行，并在需要时调用我们的代码。本章还将涉及“回调地狱”，并为你提供避免它的技能。
- en: Introduction to HOCs – Examples
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HOCs 简介——示例
- en: 'HOCs are frequently used in JavaScript, and especially in Node.js, where even
    the simplest backend server application contains it. Here is an example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: HOCs 在 JavaScript 中经常被使用，尤其是在 Node.js 中，即使是最简单的后端服务器应用程序也包含它。以下是一个示例：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice that the `createServer` function takes in a request listener *function*,
    which will be used to handle any incoming requests. This function will take in
    two arguments, `req` and `res` – the request object and the response object, respectively:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `createServer` 函数接受一个请求监听 *函数*，该函数将用于处理任何传入的请求。这个函数将接受两个参数，`req` 和 `res`
    分别代表请求对象和响应对象：
- en: '![Figure 11.1: Part of the http module in Node.js describing the callback'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1：Node.js 中 http 模块描述回调的部分](img/B14508_11_01.jpg)'
- en: structure of RequestListener
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: RequestListener 的结构
- en: '](img/B14508_11_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_11_01.jpg](img/B14508_11_01.jpg)'
- en: 'Figure 11.1: Part of the http module in Node.js describing the callback structure
    of RequestListener'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：Node.js 中 http 模块描述 RequestListener 回调结构的部分
- en: In addition, the `listen` method also takes in an optional function that will
    run when the server is ready to listen for requests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`listen` 方法还接受一个可选的函数，当服务器准备好监听请求时，该函数将被执行。
- en: Both `createServer` and `listen` are HOCs because they take in functions as
    arguments. These argument functions are usually called *callbacks*, since this
    is how our code can get "called back" (notified) when something happens, and,
    if needed, handle it appropriately. In the preceding example, the HTTP server
    needs to know how to handle incoming requests, so it calls our given `requestListener`
    function, which provides the logic for that. Later, the `listen` function wants
    to let us know when it's ready to accept requests, and it calls our given callback
    when it is.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer` 和 `listen` 都是高阶组件（HOC），因为它们接受函数作为参数。这些参数函数通常被称为 *回调函数*，因为我们的代码可以通过这种方式在发生某些事情时被“回调”（通知），并且如果需要，可以适当地处理它。在前面的示例中，HTTP
    服务器需要知道如何处理传入的请求，因此它调用我们提供的 `requestListener` 函数，该函数提供了相应的逻辑。稍后，`listen` 函数想要让我们知道它何时准备好接受请求，并且它会调用我们提供的回调函数。'
- en: 'Another example is the `setTimeout` function, which takes in another *function*
    as an argument to call later – after the timeout has passed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是 `setTimeout` 函数，它接受另一个 *函数* 作为参数，稍后（超时后）调用：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another example of an HOC that does not take a callback function is the `memoize`
    function. This takes in a function to `memoize` as an argument and returns a function
    with the same signature:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不接收回调函数的高阶组件（HOC）示例是 `memoize` 函数。它接受一个要 `memoize` 的函数作为参数，并返回一个具有相同签名的函数：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `memoize` function takes in a function and returns a function with the same
    type signature; however, the returned function caches the results of the original
    function. This is usually useful for expensive functions that take a long time
    to run and return the same output for the same arguments. *Chapter 9*, *Generics
    and Conditional Types*, *Exercise 9.01*, implements such a `memoize` function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`memoize` 函数接受一个函数，并返回一个具有相同类型签名的函数；然而，返回的函数会缓存原始函数的结果。这对于运行时间较长且对相同参数返回相同输出的昂贵函数通常很有用。*第9章*，*泛型和条件类型*，*练习9.01*
    实现了这样的 `memoize` 函数。'
- en: In the following sections, we'll explore both kinds of HOCs in more detail and
    see how we can avoid some of the pitfalls they introduce.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地探讨这两种高阶组件（HOC），并看看我们如何避免它们引入的一些陷阱。
- en: Higher-Order Functions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'Higher-order functions are regular functions that follow at least one of these
    two principles:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是遵循以下两个原则之一的常规函数：
- en: They take one or more functions as arguments.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们接受一个或多个函数作为参数。
- en: They return a function as a result.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们返回一个函数作为结果。
- en: 'For example, let''s say we want to write a `greet` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要编写一个 `greet` 函数：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的输出：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a fine function, but it''s very limited – what if each person has a
    favorite greeting? Consider the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的函数，但它非常有限——如果每个人都有一句喜欢的问候语怎么办？考虑以下示例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We could put that inside the `greet` function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它放在 `greet` 函数内部：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的输出：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But that means that the `greet` function is no longer reusable by itself since,
    if we were to take it, we''d also need to bring along the `favoriteGreetings`
    mapping with it. Instead, we could pass it in as a parameter:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但这意味着 `greet` 函数本身就不再可重用了，因为如果我们使用它，我们还需要带上 `favoriteGreetings` 映射。相反，我们可以将其作为参数传递：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的输出：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This works, but it's very cumbersome to pass in the `favoriteGreetings` object
    in every call.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但每次调用时传递 `favoriteGreetings` 对象非常繁琐。
- en: 'We can improve on this by making the `greet` function accept a function that
    will serve as a more generic solution to the favorite-greeting issue – it will
    accept the name and return the greeting to use:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使 `greet` 函数接受一个函数来改进这一点，该函数将作为解决喜欢的问候语问题的更通用解决方案——它将接受名字并返回要使用的问候语：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的输出：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This may feel the same as our previous solution, which took the mapper object
    as an argument, but passing in a function is much more powerful. We can do a lot
    more with a function than with a static object. For example, we could base the
    greeting on the time of day:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉和我们的上一个解决方案一样，该解决方案接受映射器对象作为参数，但传递函数要强大得多。我们可以用函数做很多事情，而不仅仅是静态对象。例如，我们可以根据一天中的时间来设置问候语：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An example output would be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例输出可能如下所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We could even go further and make the function return a random greeting, get
    it from a remote server, and a lot more, something which we couldn't do without
    passing in a function to the `greet` function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更进一步，使函数返回一个随机问候语，从远程服务器获取，等等，这是没有在`greet`函数中传递函数无法做到的。
- en: By making `greet` accept a function, we opened up endless possibilities, while
    keeping `greet` reusable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使`greet`接受一个函数，我们打开了无限的可能性，同时保持了`greet`的可重用性。
- en: 'This is great, but passing in the `getGreeting` function in each call still
    feels cumbersome. We can change this by changing the `greet` function to both
    accept a function, and return a function. Let''s take a look at how that appears:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但每次调用时传递`getGreeting`函数仍然感觉有些繁琐。我们可以通过将`greet`函数改为同时接受一个函数并返回一个函数来改变这一点。让我们看看这是如何实现的：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You''ll notice that the logic stays the same as in the previous solution, but
    we split up the function to first take in the `getGreeting` function, and then
    return another function that takes in the `name` argument. This allows us to call
    `greet` like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到逻辑与上一个解决方案相同，但我们拆分了函数，首先接受`getGreeting`函数，然后返回另一个接受`name`参数的函数。这允许我们像这样调用`greet`：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Splitting greet in this way allows us even more flexibility – since we now
    only need the `getGreeting` function once we can inline it, if it doesn''t make
    sense to use it elsewhere:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式拆分`greet`使我们具有更大的灵活性——因为我们现在只需要`getGreeting`函数一次，就可以将其内联，如果它在其他地方使用不合理的话：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We could also use it to greet an array of people (names), using the `forEach`
    method of `Array`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用它来使用`Array`的`forEach`方法问候一个人员（名字）数组：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Higher-order functions, especially ones that accept other functions, are very
    widespread and useful, especially for manipulating datasets. We've even used them
    in previous chapters. For instance, the `map`, `filter`, `reduce`, and `forEach`
    methods of `Array` accept functions as arguments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数，尤其是接受其他函数的函数，非常普遍且有用，尤其是在操作数据集时。我们甚至在之前的章节中使用过它们。例如，`Array`的`map`、`filter`、`reduce`和`forEach`方法接受函数作为参数。
- en: 'Exercise 11.01: Orchestrating Data Filtering and Manipulation Using Higher-Order
    Functions'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.01：使用高阶函数编排数据过滤和操作
- en: In this exercise, we get a list of students and want to get the average score
    of the students who graduated in 2010\. This exercise will make use of higher-order
    functions to complete this task.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，我们获取一个学生列表，并希望获取2010年毕业的学生的平均分数。此练习将使用高阶函数来完成此任务。
- en: 'The list of students is given in the following form:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 学生列表如下所示：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can refer to the following starter file to get the code for student interface:
    [https://packt.link/6Jmeu](https://packt.link/6Jmeu).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下起始文件以获取学生界面代码：[https://packt.link/6Jmeu](https://packt.link/6Jmeu)。
- en: 'Perform the following steps to implement this exercise:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实施此练习的步骤如下：
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/fm3O4](https://packt.link/fm3O4).
    Make sure to begin with the code for the student interface, as mentioned previously.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在以下位置找到：[https://packt.link/fm3O4](https://packt.link/fm3O4)。请确保从之前提到的学生界面代码开始。
- en: 'Create a function, `getAverageScore`, that will accept a `Student[]` argument,
    and return a `number`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数`getAverageScore`，它将接受一个`Student[]`参数，并返回一个`number`：
- en: '[PRE20]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we want to get *only those students who graduated in 2010*. We can use
    the array's `filter` method for that – a higher-order function that accepts a
    predicate, a function that accepts an item from the array and returns `true` or
    `false`, depending on whether the item should be included in the result. `filter`
    returns a new array comprising some of the original array items, depending on
    the predicate. The length of the new array is smaller or equal to the length of
    the original array.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们希望只获取**2010年毕业的学生**。为此，我们可以使用数组的`filter`方法——这是一个接受谓词的高阶函数，它接受一个从数组中获取项的函数，并返回`true`或`false`，这取决于该项是否应包含在结果中。`filter`返回一个新数组，该数组包含根据谓词的一些原始数组项。新数组的长度小于或等于原始数组的长度。
- en: 'Update your function with the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新你的函数：
- en: '[PRE21]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we only care about the score of each student. We can use the array's `map`
    method for that – a higher-order function that accepts a mapping function, a function
    that accepts an item from the array and returns a new, transformed value (of a
    type of your choosing) for each item. `map` returns a new array comprising the
    transformed items.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们只关心每个学生的分数。我们可以使用数组的`map`方法来做到这一点——这是一个接受映射函数的更高阶函数，该函数接受数组中的一个项，并为每个项返回一个新的、转换后的值（你选择的类型）。`map`返回一个包含转换后项的新数组。
- en: 'Use the `map` method as shown:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式使用`map`方法：
- en: '[PRE22]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Lastly, we want to get the average from the array of scores. We can use the
    array's `reduce` method for that – a higher-order function that accepts a reducer
    function and an initial value.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们想要从分数数组中获取平均值。我们可以使用数组的`reduce`方法来做到这一点——这是一个接受减法函数和初始值的更高阶函数。
- en: 'Update the function with the `reduce` method as shown:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式使用`reduce`方法更新函数：
- en: '[PRE23]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The reducer function accepts the accumulator and the current value and returns
    an accumulator. `reduce` iterates over the items in the array, calling the reducer
    function in each iteration with the current item and the previously returned accumulator
    (or the initial value, for the first run). Finally, it returns the resulting accumulator,
    after iterating through the entire array. In this case, we want to average out
    the numbers in the array, so our reducer function will sum all the items, which
    we'll then divide by the number of female students. We can then call the function
    with any dataset and get the average score.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 减法函数接受累加器和当前值，并返回一个累加器。`reduce`遍历数组中的项，在每次迭代中调用减法函数，使用当前项和之前返回的累加器（或第一次运行的初始值）。最后，它返回遍历整个数组后的结果累加器。在这种情况下，我们想要计算数组中数字的平均值，因此我们的减法函数将求和所有项，然后除以女性学生的数量。然后我们可以用任何数据集调用该函数，得到平均分数。
- en: 'Run the file using `npx` `ts-node`. You should see the following output on
    your console:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npx` `ts-node`运行文件。你应该在你的控制台看到以下输出：
- en: '[PRE24]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In this exercise, we could also extract each function given to `filter`, `map`,
    and `reduce` into a named, non-inlined function, if it made sense to use it outside
    of this context; for example, if we wanted to test the filtering logic outside
    of `getAverageScoreOf2010Students`.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，我们还可以将传递给`filter`、`map`和`reduce`的每个函数提取出来，作为一个有名称的非内联函数，如果它在当前上下文之外使用是有意义的；例如，如果我们想在`getAverageScoreOf2010Students`之外测试过滤逻辑。
- en: Callbacks
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数
- en: 'Callbacks are functions that we pass into other functions, which, in turn,
    will be invoked when they are needed. For example, in the client, if you want
    to listen to clicks on a specific DOM element, you attach an event handler via
    `addEventListener`. The function you pass in is then called when clicks on that
    element occur:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数是我们传递给其他函数的函数，它们在需要时会被调用。例如，在客户端，如果你想监听特定DOM元素上的点击事件，你可以通过`addEventListener`附加一个事件处理器。当你点击该元素时，传递进去的函数就会被调用：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, `handleButtonClick` is a *callback function* given to `addEventListener`.
    It will be called whenever someone clicks the `.my-button` element.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`handleButtonClick`是传递给`addEventListener`的*回调函数*。每当有人点击`.my-button`元素时，它就会被调用。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also inline the `handleButtonClick` function, but you won't be able
    to call `removeEventListener` later, which is required in certain cases, to avoid
    memory leaks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以内联`handleButtonClick`函数，但之后你将无法调用`removeEventListener`，这在某些情况下是必需的，以避免内存泄漏。
- en: 'On the server, callbacks are widely used. Even the most basic request handler
    in Node.js'' `http` module requires a callback function to be passed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，回调函数被广泛使用。即使是Node.js的`http`模块中最基本的请求处理器也需要传递一个回调函数：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, `requestHandler` is a callback function given to `createServer`.
    It will be called whenever a request reaches the server, and this is where we
    define what we want to do with it, and how we want to respond.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`requestHandler`是传递给`createServer`的回调函数。每当有请求到达服务器时，它就会被调用，这就是我们定义我们想要做什么，以及我们想要如何响应的地方。
- en: The Event Loop
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: Since JavaScript is single-threaded, callbacks are required to keep the main
    thread free – the basic idea is that you give the engine a function to call when
    something happens, where you can handle it, and then return the control to whatever
    other code needs to run.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript是单线程的，因此需要回调函数来保持主线程空闲——基本思想是，你给引擎一个函数来调用，当发生某些事情时，你可以处理它，然后返回控制权给需要运行的任何其他代码。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In more recent versions of browsers and Node.js, you can create threads via
    *Web Workers* on the browser or via *Worker Threads* in Node.js. However, these
    are usually saved for CPU-intensive tasks, and they are not as easy to use as
    callbacks or other alternatives are (for example, Promises – explored in more
    detail in *Chapter 13*, *Async Await in TypeScript*).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在更近期的浏览器和Node.js版本中，你可以在浏览器中使用 *Web Workers* 或者在Node.js中使用 *Worker Threads*
    来创建线程。然而，这些通常用于CPU密集型任务，并且它们不像回调或其他替代方案（例如，Promises – 在第13章中更详细地探讨了，*TypeScript中的Async
    Await*）那样容易使用。
- en: 'To illustrate this, let''s look at a version of some JavaScript code where
    there are no callbacks, and we want to create a simple server that greets the
    users by their name:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看看一段没有回调的JavaScript代码版本，我们想要创建一个简单的服务器，通过用户的名字来问候用户：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`fetchGreeting` is faking a network operation, which is done synchronously
    to illustrate the issue:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchGreeting` 模拟了一个网络操作，它是同步执行的，以说明问题：'
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In a more real-world example, `fetchGreening` could be replaced by a call to
    get the user's data from the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更贴近现实世界的例子中，`fetchGreening` 可以被替换为从数据库中获取用户数据的调用。
- en: 'If we run the server and try to request a few greetings simultaneously, you''ll
    notice that they each wait for the previous request to complete before starting
    requesting the data for the current one. We can simulate a few concurrent requests
    by calling fetch multiple times, without waiting for the previous request to finish
    first:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行服务器并尝试同时请求几个问候语，你会注意到它们每个都要等待前一个请求完成后再开始请求当前的数据。我们可以通过多次调用 fetch 来模拟几个并发请求，而不必先等待前一个请求完成：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output you''ll see on the server''s console is this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你在服务器控制台看到的输出是：
- en: '![Figure 11.2: Output of running the sync server while making multiple requests simultaneously](img/B14508_11_02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：同时进行多个请求时运行同步服务器的输出](img/B14508_11_02.jpg)'
- en: 'Figure 11.2: Output of running the sync server while making multiple requests simultaneously'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：同时进行多个请求时运行同步服务器的输出
- en: As you can see, Jane had to wait for John's request to finish (5 seconds in
    this case) before the server even started handling her request. The total time
    to greet both users was 10 seconds. Can you imagine what would happen in a real
    server, serving hundreds or more requests at the same time?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，简必须等待约翰的请求完成（在这个例子中是5秒）之后，服务器才开始处理她的请求。问候两个用户所需的总时间是10秒。你能想象在一个真实的服务器上，同时处理数百或更多请求会发生什么吗？
- en: Let's see how callbacks solve this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看回调如何解决这个问题。
- en: 'We first change `fetchGreeting` to use callback APIs – `setTimeout` in this
    case serves the same purpose as the `while` loop from before, while not holding
    up the main thread:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 `fetchGreeting` 更改为使用回调API – 在这种情况下，`setTimeout` 执行与之前的 `while` 循环相同的功能，而不会阻塞主线程：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, change the request handler to use the new implementation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将请求处理器更改为使用新的实现：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And run the client code again. This results in the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行客户端代码。这导致以下输出：
- en: '![Figure 11.3: Output of running the async server while making'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3：同时进行多个请求时运行异步服务器的输出](img/B14508_11_03.jpg)'
- en: multiple requests simultaneously
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 同时进行多个请求
- en: '](img/B14508_11_03.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_11_03.jpg](img/B14508_11_03.jpg)'
- en: 'Figure 11.3: Output of running the async server while making multiple requests
    simultaneously'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：同时进行多个请求时运行异步服务器的输出
- en: As you can see, the server started handing John's request first, since that's
    the first one to arrive, but then immediately switched to handling Jane's request
    while waiting for John's greeting to be ready. When John's greeting was ready
    5 seconds later, the server sent the greeting back, and then waited for Jane's
    greeting to be ready a few milliseconds later and sent that to her.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，服务器首先处理了约翰的请求，因为那是第一个到达的，但随后立即切换到处理简的请求，同时等待约翰的问候语准备好。当5秒后约翰的问候语准备好时，服务器发送了问候语，然后等待简的问候语在几毫秒后准备好，并将其发送给她。
- en: To conclude, the *same flow* as before now took 5 seconds to respond to *both
    users* instead of the 10 seconds from before. In addition, most of that time was
    spent idle – waiting to receive more requests to handle. This is instead of the
    flow prior to the callbacks, where the server was stuck and wasn't able to answer
    any requests for the majority of the time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，现在的 *相同流程* 只用了5秒来响应 *两个用户*，而不是之前的10秒。此外，大部分时间都是空闲的 – 等待接收更多请求来处理。这与回调之前的流程相反，那时服务器被卡住，大部分时间无法回答任何请求。
- en: Callbacks in Node.js
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js中的回调
- en: 'Since callbacks are very common in Node.js, and especially since the whole
    ecosystem relies on using external packages for a lot of things, there is a standard
    callback API structure for any async function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回调在Node.js中非常常见，而且整个生态系统依赖于使用外部包来处理许多事情，因此任何异步函数都有一个标准的回调API结构：
- en: The callback function will be the last parameter.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调函数将是最后一个参数。
- en: The callback function will take `err` as the first parameter, which may be `null`
    (or `undefined`), and the response data as the second parameter.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调函数将`err`作为第一个参数，它可能是`null`（或`undefined`），响应数据作为第二个参数。
- en: 'Further parameters are also allowed, but these two are mandatory. This results
    in a predictable structure for handling callbacks, illustrated by the following
    example for reading a file from the filesystem:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还允许有更多的参数，但这两个是强制性的。这导致处理回调的结构具有可预测性，以下是一个从文件系统中读取文件的示例：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Callback Hell
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调地狱
- en: Unfortunately, code that uses callbacks can make it very hard to follow, understand,
    and reason about very quickly. Every async operation requires another callback
    level, and if you want to run multiple async operations consecutively, you have
    to nest these callbacks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，使用回调的代码可能会使得代码的可读性、理解性和推理性变得非常困难。每一个异步操作都需要另一个回调层级，如果你想要连续运行多个异步操作，你必须嵌套这些回调。
- en: 'For example, let''s say we want to build a social network, which has an endpoint
    where you can ask for a given user''s friends, based on their username. Getting
    this list of friends requires multiple operations, each requiring an async operation
    that depends on the result of the previous one:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要构建一个社交网络，它有一个端点，你可以根据用户名请求特定用户的好友。获取这个好友列表需要多个操作，每个操作都需要一个依赖于前一个操作结果的异步操作：
- en: Get the requested user's ID from the database (given their username).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中获取请求用户的ID（给定他们的用户名）。
- en: Get the privacy settings of the user to make sure they allow others to view
    their list of friends.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的隐私设置，以确保他们允许其他人查看他们的好友列表。
- en: Get the user's friends (from an external service or otherwise).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的好友（来自外部服务或其他方式）。
- en: 'Here is some example code for how this could be done, using callbacks. We''re
    using `express` here to set up a basic server, listening on port `3000`. The server
    can accept a `GET` request to `/:username/friends` (where `:username` will be
    replaced with the actual requested username). After accepting the request, we
    get the ID of the user from the database, then get the user privacy preferences
    using the user''s ID (this can be in an external service, or otherwise) to check
    that they allow others to view their friends'' list, then get the user''s friends,
    and finally return the result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例代码，展示了如何使用回调来实现这一点。我们在这里使用`express`来设置一个基本的服务器，监听端口`3000`。服务器可以接受一个`GET`请求到`/:username/friends`（其中`:username`将被实际请求的用户名替换）。在接收请求后，我们从数据库中获取用户的ID，然后使用用户的ID获取用户隐私偏好（这可以是在外部服务中，或其他方式），以检查他们是否允许其他人查看他们的好友列表，然后获取用户的好友，最后返回结果：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Also note that in each callback, we got an `err` parameter and had to check
    whether it was true, and bail early if it wasn't accompanied by an appropriate
    error code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在每一个回调中，我们都得到了一个`err`参数，并且必须检查它是否为真，如果没有合适的错误代码，就提前退出。
- en: The preceding example is not unrealistic, and a lot of cases require more levels
    than this to get all the data they need in order to perform a task. And so, this
    "callback hell" becomes more apparent, and harder to understand and reason about
    very quickly, since, as discussed previously, a lot of APIs in Node.js work with
    callbacks, due to the nature of how JavaScript works, as explained in the event
    loop section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子并不不切实际，很多情况需要比这更多的层级才能获取完成任务所需的所有数据。因此，“回调地狱”变得更加明显，理解和推理起来也更加困难，因为，如前所述，由于JavaScript的工作方式，Node.js中的许多API都使用回调，这在事件循环部分有解释。
- en: Avoiding Callback Hell
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免回调地狱
- en: 'There are quite a few solutions to the callback hell problem. We''ll take a
    look at the most prominent ones, demonstrating how the preceding code snippet
    would look in each variation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于回调地狱问题，有相当多的解决方案。我们将查看最突出的几个，展示前述代码片段在每个变化中的样子：
- en: Extract the callback functions to function declarations at the file level and
    then use them – this means you only have one level of functions with business
    logic, and the callback hell functions become a lot shorter.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将回调函数提取到文件级别的函数声明中，然后使用它们——这意味着你只有一层具有业务逻辑的函数，回调地狱函数变得更短。
- en: Use a higher-order function to chain the callbacks, meaning only a single level
    of callbacks in practice.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用高阶函数来链式连接回调，这意味着实际上只有一个回调层级。
- en: Use promises, when can be chained together, as explained in *Chapter 13*, *Async
    Await in TypeScript*.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用可以在其上链式调用的`Promise`，如第13章中所述，*TypeScript中的Async Await*。
- en: Use `async`/`await` (which is syntactic sugar on top of `Promise`), as explained
    in *Chapter 13*, *Async Await in TypeScript*.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`async`/`await`（这是在`Promise`之上的语法糖），如第13章中所述，*TypeScript中的Async Await*。
- en: Splitting the Callback Handlers into Function Declarations at the File Level
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文件级别将回调处理程序拆分为函数声明
- en: The simplest way to simplify callback hell is to extract some of the callbacks
    into their own top-level functions and let each one call the next in the logical
    chain.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 简化回调地狱的最简单方法是将一些回调提取到它们自己的顶级函数中，并让每个函数调用逻辑链中的下一个函数。
- en: 'Our main endpoint handler will call the `get` of `db` as before, but then just
    call `handleDatabaseResponse` with the response, leaving it to handle any errors,
    and so on. This is why we also pass in the response object to the function, in
    case it needs to return the data, or an error, to the user:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要端点处理程序将像之前一样调用`db`的`get`方法，但随后只需调用`handleDatabaseResponse`函数并传递响应，让它处理任何错误等。这就是为什么我们也将响应对象传递给函数，以防它需要将数据或错误返回给用户：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `handleDatabaseResponse` function will perform the same logic as before,
    but now pass the handling of the `getUserPrivacyPreferences` response to `handleGetUserPrivacyPreferences`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleDatabaseResponse`函数将执行之前的相同逻辑，但现在将`getUserPrivacyPreferences`响应的处理传递给`handleGetUserPrivacyPreferences`：'
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`handleGetUserPrivacyPreferences` will again perform the same logic as before,
    and pass the handling of the `getFriends` response to `handleGetFriends`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleGetUserPrivacyPreferences`将再次执行之前的相同逻辑，并将`getFriends`响应的处理传递给`handleGetFriends`：'
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And finally, `handleGetFriends` will return the data to the user via the response:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`handleGetFriends`将通过响应将数据返回给用户：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we only have a single nesting level, and no more callback hell.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只有一个嵌套层级，没有更多的回调地狱。
- en: The main trade-off here is that while the code is less nested, it is split among
    multiple functions and may be harder to follow, especially when debugging or skimming
    through it to understand what's going on at a high level.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要权衡是，虽然代码的嵌套程度降低了，但它被分散到多个函数中，可能更难理解，尤其是在调试或快速浏览以了解高层次发生的事情时。
- en: Chaining Callbacks
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链式连接回调
- en: 'There are libraries to help us eliminate the callback hell problem by chaining
    the callbacks to one another – artificially removing nesting levels from our code.
    One of the popular ones is async.js ([https://github.com/caolan/async](https://github.com/caolan/async)),
    which exposes a few functions to compose callback functions, such as `parallel`,
    `series`, and `waterfall`. In our preceding code example, we could use the `waterfall`
    function to chain the callbacks to happen one after the other:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有库可以帮助我们通过将回调链式连接来消除回调地狱问题，从而人为地从我们的代码中移除嵌套层级。其中之一是async.js ([https://github.com/caolan/async](https://github.com/caolan/async))，它公开了一些函数来组合回调函数，例如`parallel`、`series`和`waterfall`。在我们的先前的代码示例中，我们可以使用`waterfall`函数将回调链式连接，使它们依次发生：
- en: 'We implement an array of functions, and a final handler. `async` will then
    call our functions, one by one, when we call the callback in each function, as
    demonstrated here:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现一个函数数组和一个最终处理程序。`async`将依次调用我们的函数，当我们每个函数中的回调被调用时，如这里所示：
- en: '[PRE38]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Get the user ID from the database:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中获取用户ID：
- en: '[PRE39]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Get the user''s privacy settings:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的隐私设置：
- en: '[PRE40]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Check that the user privacy settings allow others to view their friends:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户的隐私设置是否允许他人查看他们的好友：
- en: '[PRE41]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Get the user''s friends:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的好友：
- en: '[PRE42]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, handle any errors that occurred, or the data that was returned from
    the last callback:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，处理发生的任何错误或最后一个回调返回的数据：
- en: '[PRE43]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now the code is much easier to follow – we only have one error handler that's
    tied down to the response object, and we follow the code from top to bottom, with
    not much nesting in between, at least not due to callbacks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码更容易理解——我们只有一个与响应对象相关联的错误处理程序，我们从上到下跟随代码，中间没有太多的嵌套，至少不是由于回调造成的。
- en: Promises
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Promise`'
- en: Promises allow you to essentially flatten the callback tree by doing something
    similar to async.js' waterfall, but it's more seamless, built into the language
    itself, and also allows promises to be "squashed."
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Promises 允许你通过类似于 async.js 的 waterfall 方法来本质上扁平化回调树，但它更加无缝，是语言本身内置的，还允许承诺被“压缩”。
- en: 'We won''t go into too much detail here – refer to *Chapter 13*, *Async Await
    in TypeScript* for an in-depth explanation of promises, but the preceding code,
    using promises, would look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会过多深入——有关承诺的深入解释，请参阅 *第 13 章*，*TypeScript 中的 Async Await*。
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: async/await
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: async/await
- en: 'Async/await builds upon promises and provides further syntactic sugar on top
    of them in order to make promises look and read like synchronous code, even though,
    behind the scenes, it''s still async. You can get a more in-depth explanation
    of them in *Chapter 13*, *Async Await in TypeScript*, but the preceding code that
    used promises is equivalent to the following code that uses async/await:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Async/await 在承诺的基础上构建，并在其之上提供了进一步的语法糖，以便使承诺看起来和读起来像同步代码，尽管在幕后它仍然是异步的。你可以在 *第
    13 章*，*TypeScript 中的 Async Await* 中找到对它们的更深入解释，但使用承诺的前述代码等同于以下使用 async/await 的代码：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Activity 11.01: Higher-Order Pipe Function'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：高阶管道函数
- en: In this activity, you are tasked with implementing a `pipe` function – a higher-order
    function that accepts other functions, as well as a value, and composes them –
    returning a function that accepts the arguments of the first function in the composition,
    runs it through the functions – feeding each function with the output of the previous
    one (and the first function with the initial value), and returns the result of
    the last function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你被要求实现一个 `pipe` 函数——一个接受其他函数以及一个值的更高阶函数，并将它们组合——返回一个接受组合中第一个函数的参数的函数，运行它通过函数——将每个函数的输出作为输入（并将第一个函数的初始值作为输入），并返回最后一个函数的结果。
- en: Such functions exist in utility libraries such as Ramda ([https://ramdajs.com/docs/#pipe](https://ramdajs.com/docs/#pipe)).
    and with variations in other libraries such as Lodash ([https://lodash.com/docs#chain](https://lodash.com/docs#chain))
    and RxJS ([https://rxjs.dev/api/index/function/pipe](https://rxjs.dev/api/index/function/pipe)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数存在于 Ramda 等实用库中（[https://ramdajs.com/docs/#pipe](https://ramdajs.com/docs/#pipe)），以及其他库如
    Lodash ([https://lodash.com/docs#chain](https://lodash.com/docs#chain)) 和 RxJS
    ([https://rxjs.dev/api/index/function/pipe](https://rxjs.dev/api/index/function/pipe))
    中的变体。
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find both the activity starter file and solution at [https://packt.link/CQLfx](https://packt.link/CQLfx).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/CQLfx](https://packt.link/CQLfx)找到活动的起始文件和解决方案。
- en: 'Perform the following steps to implement this activity:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此活动：
- en: Create a `pipe` function that accepts functions as arguments and composes them,
    from left to right.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接受函数作为参数并将它们组合的 `pipe` 函数，从左到右。
- en: Make sure that the return type of the returned functional is correct – it should
    accept arguments of type `T`, `T` being the arguments of the first function in
    the chain, and return type `R`, `R` being the return type of the last function
    in the chain.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保返回函数的返回类型正确——它应该接受类型为 `T` 的参数，其中 `T` 是链中第一个函数的参数，并返回类型为 `R` 的结果，其中 `R` 是链中最后一个函数的返回类型。
- en: Note that due to a current TypeScript limitation, you have to manually type
    this for the number of arguments you want to support.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于当前 TypeScript 的限制，你必须手动为想要支持的参数数量进行类型注解。
- en: Your `pipe` function should be callable in multiple ways – supporting composition
    of up to five functions, and will only support composing functions with a single
    argument, for simplicity.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的 `pipe` 函数应该可以通过多种方式调用——支持最多五个函数的组合，并且将仅支持组合具有单个参数的函数，以简化。
- en: 'Here is the structure of the `pipe` function that you can use:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是你可以使用的 `pipe` 函数的结构：
- en: '[PRE46]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After solving the preceding steps, the expected output for this code is presented
    here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决前面的步骤之后，此代码的预期输出如下所示：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Bonus: As a challenge, try expanding the `pipe` function to support the composition
    of more functions, or more arguments.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励：作为一个挑战，尝试扩展 `pipe` 函数以支持更多函数的组合，或者更多参数。
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor438).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor438)可以找到此活动的解决方案。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we introduced two key concepts in TypeScript – higher-order
    functions and callbacks. The chapter first defined HOCs and illustrated this concept
    with a number of examples. You also orchestrated data filtering and manipulation
    using higher-order functions. Finally, you also tested your skills by creating
    a higher-order pipe function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 TypeScript 中的两个关键概念——高阶函数和回调函数。本章首先定义了高阶组件（HOCs），并通过多个示例来阐述这一概念。您还使用高阶函数进行了数据过滤和操作。最后，您还通过创建一个高阶管道函数来测试了自己的技能。
- en: With regard to callbacks, the chapter first introduced the definition of callbacks
    with a few generic examples, along with examples relating to callbacks in Node.js.
    You also saw how you can easily fall into callback hell and how you can avoid
    it. Although there are several additional steps that you need to take in order
    to master higher-order functions and callback, this chapter got you started on
    the journey. The next chapter deals with another important concept in TypeScript
    – promises.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 关于回调函数，本章首先通过一些通用示例介绍了回调函数的定义，并辅以 Node.js 中与回调函数相关的示例。您还了解到如何轻易陷入回调地狱以及如何避免这种情况。尽管要掌握高阶函数和回调需要采取几个额外的步骤，但本章已经为您开启了这段旅程。下一章将探讨
    TypeScript 中的另一个重要概念——Promise。
