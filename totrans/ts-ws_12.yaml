- en: 11\. Higher-Order Functions and Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces higher-order functions and callbacks in TypeScript.
    You will first understand what higher-order functions are, why they are useful,
    and how to type them correctly in TypeScript. Then, the chapter will teach you
    about what callbacks are, why they are used, and in what situations. You will
    also learn about why callbacks are so widely used, especially in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the chapter will provide you with a basic introduction to the
    event loop. Not only will you learn about "callback hell," but also how you can
    avoid it. By the end of this chapter, you will be able to create a well-typed
    higher-order `pipe` function.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already covered the use of functions in TypeScript in *Chapter 3*,
    *Functions*. This chapter will introduce you to higher-order functions in TypeScript.
    Hitherto, with all the functions that you have used in this book, you either passed
    parameters or arguments into them. However, JavaScript and, by extension, TypeScript,
    has many ways of composing and writing code. In this chapter, we'll explore one
    such pattern – higher-order functions/callbacks (hereinafter called HOCs) are
    functions that either take in another function as an argument or return a function
    (or both).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, this chapter also explores the concept of callbacks. Callbacks
    are required in Node.js, as well as in other JavaScript runtimes, since the language
    is single-threaded and runs in an event loop, and so, in order to not hold up
    the main thread, we let other code run, and when needed it will call our code
    back. This chapter will also touch upon "callback hell" and equip you with the
    skills needed to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to HOCs – Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HOCs are frequently used in JavaScript, and especially in Node.js, where even
    the simplest backend server application contains it. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `createServer` function takes in a request listener *function*,
    which will be used to handle any incoming requests. This function will take in
    two arguments, `req` and `res` – the request object and the response object, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Part of the http module in Node.js describing the callback'
  prefs: []
  type: TYPE_NORMAL
- en: structure of RequestListener
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.1: Part of the http module in Node.js describing the callback structure
    of RequestListener'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `listen` method also takes in an optional function that will
    run when the server is ready to listen for requests.
  prefs: []
  type: TYPE_NORMAL
- en: Both `createServer` and `listen` are HOCs because they take in functions as
    arguments. These argument functions are usually called *callbacks*, since this
    is how our code can get "called back" (notified) when something happens, and,
    if needed, handle it appropriately. In the preceding example, the HTTP server
    needs to know how to handle incoming requests, so it calls our given `requestListener`
    function, which provides the logic for that. Later, the `listen` function wants
    to let us know when it's ready to accept requests, and it calls our given callback
    when it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is the `setTimeout` function, which takes in another *function*
    as an argument to call later – after the timeout has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of an HOC that does not take a callback function is the `memoize`
    function. This takes in a function to `memoize` as an argument and returns a function
    with the same signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `memoize` function takes in a function and returns a function with the same
    type signature; however, the returned function caches the results of the original
    function. This is usually useful for expensive functions that take a long time
    to run and return the same output for the same arguments. *Chapter 9*, *Generics
    and Conditional Types*, *Exercise 9.01*, implements such a `memoize` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll explore both kinds of HOCs in more detail and
    see how we can avoid some of the pitfalls they introduce.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Higher-order functions are regular functions that follow at least one of these
    two principles:'
  prefs: []
  type: TYPE_NORMAL
- en: They take one or more functions as arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They return a function as a result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let''s say we want to write a `greet` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fine function, but it''s very limited – what if each person has a
    favorite greeting? Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We could put that inside the `greet` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But that means that the `greet` function is no longer reusable by itself since,
    if we were to take it, we''d also need to bring along the `favoriteGreetings`
    mapping with it. Instead, we could pass it in as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This works, but it's very cumbersome to pass in the `favoriteGreetings` object
    in every call.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can improve on this by making the `greet` function accept a function that
    will serve as a more generic solution to the favorite-greeting issue – it will
    accept the name and return the greeting to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This may feel the same as our previous solution, which took the mapper object
    as an argument, but passing in a function is much more powerful. We can do a lot
    more with a function than with a static object. For example, we could base the
    greeting on the time of day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An example output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We could even go further and make the function return a random greeting, get
    it from a remote server, and a lot more, something which we couldn't do without
    passing in a function to the `greet` function.
  prefs: []
  type: TYPE_NORMAL
- en: By making `greet` accept a function, we opened up endless possibilities, while
    keeping `greet` reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great, but passing in the `getGreeting` function in each call still
    feels cumbersome. We can change this by changing the `greet` function to both
    accept a function, and return a function. Let''s take a look at how that appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that the logic stays the same as in the previous solution, but
    we split up the function to first take in the `getGreeting` function, and then
    return another function that takes in the `name` argument. This allows us to call
    `greet` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Splitting greet in this way allows us even more flexibility – since we now
    only need the `getGreeting` function once we can inline it, if it doesn''t make
    sense to use it elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also use it to greet an array of people (names), using the `forEach`
    method of `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Higher-order functions, especially ones that accept other functions, are very
    widespread and useful, especially for manipulating datasets. We've even used them
    in previous chapters. For instance, the `map`, `filter`, `reduce`, and `forEach`
    methods of `Array` accept functions as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Orchestrating Data Filtering and Manipulation Using Higher-Order
    Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we get a list of students and want to get the average score
    of the students who graduated in 2010\. This exercise will make use of higher-order
    functions to complete this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of students is given in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to the following starter file to get the code for student interface:
    [https://packt.link/6Jmeu](https://packt.link/6Jmeu).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/fm3O4](https://packt.link/fm3O4).
    Make sure to begin with the code for the student interface, as mentioned previously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function, `getAverageScore`, that will accept a `Student[]` argument,
    and return a `number`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we want to get *only those students who graduated in 2010*. We can use
    the array's `filter` method for that – a higher-order function that accepts a
    predicate, a function that accepts an item from the array and returns `true` or
    `false`, depending on whether the item should be included in the result. `filter`
    returns a new array comprising some of the original array items, depending on
    the predicate. The length of the new array is smaller or equal to the length of
    the original array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update your function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we only care about the score of each student. We can use the array's `map`
    method for that – a higher-order function that accepts a mapping function, a function
    that accepts an item from the array and returns a new, transformed value (of a
    type of your choosing) for each item. `map` returns a new array comprising the
    transformed items.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `map` method as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, we want to get the average from the array of scores. We can use the
    array's `reduce` method for that – a higher-order function that accepts a reducer
    function and an initial value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the function with the `reduce` method as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reducer function accepts the accumulator and the current value and returns
    an accumulator. `reduce` iterates over the items in the array, calling the reducer
    function in each iteration with the current item and the previously returned accumulator
    (or the initial value, for the first run). Finally, it returns the resulting accumulator,
    after iterating through the entire array. In this case, we want to average out
    the numbers in the array, so our reducer function will sum all the items, which
    we'll then divide by the number of female students. We can then call the function
    with any dataset and get the average score.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the file using `npx` `ts-node`. You should see the following output on
    your console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we could also extract each function given to `filter`, `map`,
    and `reduce` into a named, non-inlined function, if it made sense to use it outside
    of this context; for example, if we wanted to test the filtering logic outside
    of `getAverageScoreOf2010Students`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Callbacks are functions that we pass into other functions, which, in turn,
    will be invoked when they are needed. For example, in the client, if you want
    to listen to clicks on a specific DOM element, you attach an event handler via
    `addEventListener`. The function you pass in is then called when clicks on that
    element occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `handleButtonClick` is a *callback function* given to `addEventListener`.
    It will be called whenever someone clicks the `.my-button` element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also inline the `handleButtonClick` function, but you won't be able
    to call `removeEventListener` later, which is required in certain cases, to avoid
    memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server, callbacks are widely used. Even the most basic request handler
    in Node.js'' `http` module requires a callback function to be passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `requestHandler` is a callback function given to `createServer`.
    It will be called whenever a request reaches the server, and this is where we
    define what we want to do with it, and how we want to respond.
  prefs: []
  type: TYPE_NORMAL
- en: The Event Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since JavaScript is single-threaded, callbacks are required to keep the main
    thread free – the basic idea is that you give the engine a function to call when
    something happens, where you can handle it, and then return the control to whatever
    other code needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In more recent versions of browsers and Node.js, you can create threads via
    *Web Workers* on the browser or via *Worker Threads* in Node.js. However, these
    are usually saved for CPU-intensive tasks, and they are not as easy to use as
    callbacks or other alternatives are (for example, Promises – explored in more
    detail in *Chapter 13*, *Async Await in TypeScript*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s look at a version of some JavaScript code where
    there are no callbacks, and we want to create a simple server that greets the
    users by their name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`fetchGreeting` is faking a network operation, which is done synchronously
    to illustrate the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In a more real-world example, `fetchGreening` could be replaced by a call to
    get the user's data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the server and try to request a few greetings simultaneously, you''ll
    notice that they each wait for the previous request to complete before starting
    requesting the data for the current one. We can simulate a few concurrent requests
    by calling fetch multiple times, without waiting for the previous request to finish
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output you''ll see on the server''s console is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Output of running the sync server while making multiple requests simultaneously](img/B14508_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Output of running the sync server while making multiple requests simultaneously'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Jane had to wait for John's request to finish (5 seconds in
    this case) before the server even started handling her request. The total time
    to greet both users was 10 seconds. Can you imagine what would happen in a real
    server, serving hundreds or more requests at the same time?
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how callbacks solve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first change `fetchGreeting` to use callback APIs – `setTimeout` in this
    case serves the same purpose as the `while` loop from before, while not holding
    up the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the request handler to use the new implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And run the client code again. This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Output of running the async server while making'
  prefs: []
  type: TYPE_NORMAL
- en: multiple requests simultaneously
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.3: Output of running the async server while making multiple requests
    simultaneously'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the server started handing John's request first, since that's
    the first one to arrive, but then immediately switched to handling Jane's request
    while waiting for John's greeting to be ready. When John's greeting was ready
    5 seconds later, the server sent the greeting back, and then waited for Jane's
    greeting to be ready a few milliseconds later and sent that to her.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, the *same flow* as before now took 5 seconds to respond to *both
    users* instead of the 10 seconds from before. In addition, most of that time was
    spent idle – waiting to receive more requests to handle. This is instead of the
    flow prior to the callbacks, where the server was stuck and wasn't able to answer
    any requests for the majority of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks in Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since callbacks are very common in Node.js, and especially since the whole
    ecosystem relies on using external packages for a lot of things, there is a standard
    callback API structure for any async function:'
  prefs: []
  type: TYPE_NORMAL
- en: The callback function will be the last parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The callback function will take `err` as the first parameter, which may be `null`
    (or `undefined`), and the response data as the second parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Further parameters are also allowed, but these two are mandatory. This results
    in a predictable structure for handling callbacks, illustrated by the following
    example for reading a file from the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Callback Hell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, code that uses callbacks can make it very hard to follow, understand,
    and reason about very quickly. Every async operation requires another callback
    level, and if you want to run multiple async operations consecutively, you have
    to nest these callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we want to build a social network, which has an endpoint
    where you can ask for a given user''s friends, based on their username. Getting
    this list of friends requires multiple operations, each requiring an async operation
    that depends on the result of the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the requested user's ID from the database (given their username).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the privacy settings of the user to make sure they allow others to view
    their list of friends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's friends (from an external service or otherwise).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is some example code for how this could be done, using callbacks. We''re
    using `express` here to set up a basic server, listening on port `3000`. The server
    can accept a `GET` request to `/:username/friends` (where `:username` will be
    replaced with the actual requested username). After accepting the request, we
    get the ID of the user from the database, then get the user privacy preferences
    using the user''s ID (this can be in an external service, or otherwise) to check
    that they allow others to view their friends'' list, then get the user''s friends,
    and finally return the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Also note that in each callback, we got an `err` parameter and had to check
    whether it was true, and bail early if it wasn't accompanied by an appropriate
    error code.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is not unrealistic, and a lot of cases require more levels
    than this to get all the data they need in order to perform a task. And so, this
    "callback hell" becomes more apparent, and harder to understand and reason about
    very quickly, since, as discussed previously, a lot of APIs in Node.js work with
    callbacks, due to the nature of how JavaScript works, as explained in the event
    loop section.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Callback Hell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are quite a few solutions to the callback hell problem. We''ll take a
    look at the most prominent ones, demonstrating how the preceding code snippet
    would look in each variation:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the callback functions to function declarations at the file level and
    then use them – this means you only have one level of functions with business
    logic, and the callback hell functions become a lot shorter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a higher-order function to chain the callbacks, meaning only a single level
    of callbacks in practice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use promises, when can be chained together, as explained in *Chapter 13*, *Async
    Await in TypeScript*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `async`/`await` (which is syntactic sugar on top of `Promise`), as explained
    in *Chapter 13*, *Async Await in TypeScript*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Splitting the Callback Handlers into Function Declarations at the File Level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to simplify callback hell is to extract some of the callbacks
    into their own top-level functions and let each one call the next in the logical
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our main endpoint handler will call the `get` of `db` as before, but then just
    call `handleDatabaseResponse` with the response, leaving it to handle any errors,
    and so on. This is why we also pass in the response object to the function, in
    case it needs to return the data, or an error, to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handleDatabaseResponse` function will perform the same logic as before,
    but now pass the handling of the `getUserPrivacyPreferences` response to `handleGetUserPrivacyPreferences`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`handleGetUserPrivacyPreferences` will again perform the same logic as before,
    and pass the handling of the `getFriends` response to `handleGetFriends`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, `handleGetFriends` will return the data to the user via the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now we only have a single nesting level, and no more callback hell.
  prefs: []
  type: TYPE_NORMAL
- en: The main trade-off here is that while the code is less nested, it is split among
    multiple functions and may be harder to follow, especially when debugging or skimming
    through it to understand what's going on at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are libraries to help us eliminate the callback hell problem by chaining
    the callbacks to one another – artificially removing nesting levels from our code.
    One of the popular ones is async.js ([https://github.com/caolan/async](https://github.com/caolan/async)),
    which exposes a few functions to compose callback functions, such as `parallel`,
    `series`, and `waterfall`. In our preceding code example, we could use the `waterfall`
    function to chain the callbacks to happen one after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement an array of functions, and a final handler. `async` will then
    call our functions, one by one, when we call the callback in each function, as
    demonstrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the user ID from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the user''s privacy settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the user privacy settings allow others to view their friends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the user''s friends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, handle any errors that occurred, or the data that was returned from
    the last callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the code is much easier to follow – we only have one error handler that's
    tied down to the response object, and we follow the code from top to bottom, with
    not much nesting in between, at least not due to callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Promises allow you to essentially flatten the callback tree by doing something
    similar to async.js' waterfall, but it's more seamless, built into the language
    itself, and also allows promises to be "squashed."
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t go into too much detail here – refer to *Chapter 13*, *Async Await
    in TypeScript* for an in-depth explanation of promises, but the preceding code,
    using promises, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: async/await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Async/await builds upon promises and provides further syntactic sugar on top
    of them in order to make promises look and read like synchronous code, even though,
    behind the scenes, it''s still async. You can get a more in-depth explanation
    of them in *Chapter 13*, *Async Await in TypeScript*, but the preceding code that
    used promises is equivalent to the following code that uses async/await:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 11.01: Higher-Order Pipe Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you are tasked with implementing a `pipe` function – a higher-order
    function that accepts other functions, as well as a value, and composes them –
    returning a function that accepts the arguments of the first function in the composition,
    runs it through the functions – feeding each function with the output of the previous
    one (and the first function with the initial value), and returns the result of
    the last function.
  prefs: []
  type: TYPE_NORMAL
- en: Such functions exist in utility libraries such as Ramda ([https://ramdajs.com/docs/#pipe](https://ramdajs.com/docs/#pipe)).
    and with variations in other libraries such as Lodash ([https://lodash.com/docs#chain](https://lodash.com/docs#chain))
    and RxJS ([https://rxjs.dev/api/index/function/pipe](https://rxjs.dev/api/index/function/pipe)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find both the activity starter file and solution at [https://packt.link/CQLfx](https://packt.link/CQLfx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `pipe` function that accepts functions as arguments and composes them,
    from left to right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the return type of the returned functional is correct – it should
    accept arguments of type `T`, `T` being the arguments of the first function in
    the chain, and return type `R`, `R` being the return type of the last function
    in the chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that due to a current TypeScript limitation, you have to manually type
    this for the number of arguments you want to support.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your `pipe` function should be callable in multiple ways – supporting composition
    of up to five functions, and will only support composing functions with a single
    argument, for simplicity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the structure of the `pipe` function that you can use:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After solving the preceding steps, the expected output for this code is presented
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Bonus: As a challenge, try expanding the `pipe` function to support the composition
    of more functions, or more arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor438).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced two key concepts in TypeScript – higher-order
    functions and callbacks. The chapter first defined HOCs and illustrated this concept
    with a number of examples. You also orchestrated data filtering and manipulation
    using higher-order functions. Finally, you also tested your skills by creating
    a higher-order pipe function.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to callbacks, the chapter first introduced the definition of callbacks
    with a few generic examples, along with examples relating to callbacks in Node.js.
    You also saw how you can easily fall into callback hell and how you can avoid
    it. Although there are several additional steps that you need to take in order
    to master higher-order functions and callback, this chapter got you started on
    the journey. The next chapter deals with another important concept in TypeScript
    – promises.
  prefs: []
  type: TYPE_NORMAL
