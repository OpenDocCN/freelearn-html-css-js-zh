- en: '[CHAPTER 4](toc.xhtml#c04)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Planning the App](toc.xhtml#c04)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](toc.xhtml#s103a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.Js has become the preferred choice when it comes to writing an application.
    There are more than 30 million websites powered by Node.js. These applications
    or websites or projects in general have a fair share of complexity. Netflix, LinkedIn,
    Uber, Paypal, and even NASA-like organizations use Node.js for their applications.
  prefs: []
  type: TYPE_NORMAL
- en: For developing an application, planning is the crucial part. It helps to establish
    a clear goal and a path to follow to achieve the defined goal efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the book, we are going to follow one common example to learn
    the important aspects of an application. We will see how to write, optimize, and
    test the app with standard techniques. We will be writing a project management
    software.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s104a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Project Management Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database Design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Project Structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of Project Dependency
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Directory Structure
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Database Models (entities)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Overview of the Application](toc.xhtml#s105a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any project management software has a simple goal defined. Let the individuals
    and teams plan, organize, and execute the tasks to effectively take the project
    to its completion. A PMS should allow the respective users to create and manage
    projects. For each project, there can be many tasks to perform. Users should be
    able to communicate with each other. We will soon find out about these tasks and
    much more.
  prefs: []
  type: TYPE_NORMAL
- en: Our objective or scope of the Project Management System (PMS) project is to
    develop a small web application that serves as a basic project management tool.
    The application will have various features including secure user login, the ability
    to create projects and tasks, task assignment based on user roles, and the implementation
    of email notifications when tasks are assigned or completed.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the project will explore the implementation of a caching mechanism
    for APIs to enhance response times for requests. Moreover, it covers information
    for developers to do unit testing, along with how to build the application for
    the production environment and finally the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get familiar with what we are going to build, we need to define
    the purpose, tasks we are going to perform, architecture, project structure, database
    design, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: '[Roadmap](toc.xhtml#s106a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical roadmap for a project involves several key stages and activities.
    Here is a high-level overview of what the roadmap covers.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Init the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will cover the first six of the preceding list. The last
    four topics have their dedicated chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '[Scope](toc.xhtml#s107a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose aforementioned has already given a good idea that we are going to
    develop a project management system. At times, we will refer to this as PMS also.
    Our first goal is to identify what our PMS should be capable of.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage users and login into the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and manage projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and manage tasks for the created projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should be able to access and update the task details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should be able to communicate with other members on a task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some basic project reports on a Dashboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining the Modules](toc.xhtml#s108a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the tasks we should be able to perform, we can see that the PMS should
    have these must-have modules in the system.
  prefs: []
  type: TYPE_NORMAL
- en: '[User Module](toc.xhtml#s109a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module will allow us to manage users. We should be able to perform the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add new users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User Login.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a user profile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reset user password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Project Module](toc.xhtml#s110a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project module will allow us to manage the projects. The following key
    tasks should be performed with the help of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update project details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get project detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get project statistics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage project memberships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Task Module](toc.xhtml#s111a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module will allow us to manage tasks within a project. This is a key module
    which will enable us to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update task details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get task details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach supporting files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comment Module](toc.xhtml#s112a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A task will always need a way to enable communication among team members. A
    comment module along with the tasks will facilitate this feature. The following
    tasks we should be able to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Add comments on tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to update their own comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users and admins to delete the comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Database Design](toc.xhtml#s113a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing the database for big projects is a tricky, on-going activity that
    is improvised with project timelines. Although it must be defined at the earliest.
    It involves defining the schema, tables, relationships, constraints, and data
    types to meet the specific requirements of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Normalization helps optimize storage that includes data integrity by applying
    normalization rules to eliminate data redundancy. The goal of normalization is
    to avoid data duplication and maintain data integrity. Each piece of data is stored
    in only one place, reducing the risk of inconsistencies. The relationship between
    tables is maintained using primary and foreign keys.
  prefs: []
  type: TYPE_NORMAL
- en: Normalization has its benefits in terms of storage, non-redundancy, and cleanliness.
    However, as the database grows with the number of tables along with complex features
    added to the application, the number of joins and complexity in the queries increase.
    This impacts readability, and results in slower performance if there are heavy
    read operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, let us design the tables needed for our entities. We will try
    to keep the relationships to the minimum while maintaining a balance between redundancy
    and normalization wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** *For this book, we are going to use the PostgreSQL database. Hence
    the data type in the following tables is specific to PostgreSQL. For each table,
    we will also specify if the column is a primary key or a unique key and if it
    can contain null values. If we are going to reference a column from another table,
    then we will mention the reference table and column.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For all of the modules defined above, we need the following tables for our
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**User**`: Represents all of the users who can access the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Role**`: Each user will have a role assigned, for example, Project Manager,
    Admin, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Project**`: Represents the project entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Task**`: Tasks associated with each project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Comment**`: Comments added to each task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[Figure 4.1](#fig4_1)* shows a basic entity relationship diagram. This figure
    uses only primary keys and foreign keys used for each table.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.1:** High-Level Entity Relationship Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows that each user has a role assigned. Each project is owned by
    a user. Each project has tasks assigned and each task can have comments. This
    diagram is a high-level ER Diagram. Now when we understand the relationship among
    the tables, we can explore each entity in detail followed by a detailed ER Diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '[User Schema Table](toc.xhtml#s114a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us begin with the User table which is vital for user authentication, authorization,
    and maintaining user-related data. It plays a crucial role in ensuring that each
    user’s information is accurately captured and secured while enabling the PMS to
    identify and manage individual users effectively.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we are adding only the user id, name, password,
    and some relevant details needed.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column Name** | **Type** | **Data Type** | **Description** | **Primary?**
    | **Is Null** | **Unique** | **Reference** |'
  prefs: []
  type: TYPE_TB
- en: '| `user_id` | `uuid` | uuid | User’s unique identifier id | true | false |
    true | - |'
  prefs: []
  type: TYPE_TB
- en: '| `email` | `email` | varchar(60) | User’s Email-id | false | false | true
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| `full_name` | `string` | varchar(30) | User’s Full Name | false | true |
    false | - |'
  prefs: []
  type: TYPE_TB
- en: '| username | `string` | varchar(30) | User’s Unique Name | false | false |
    true | - |'
  prefs: []
  type: TYPE_TB
- en: '| `password` | `string` | varchar(100) | User’s hashed Password | false | false
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `role_id` | `uuid` | uuid | User’s role id | false | false | false | Role
    Table (role_id) |'
  prefs: []
  type: TYPE_TB
- en: '| `created_at` | `date` | timestamp | User’s Creation Time | false | false
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `updated_at` | `date` | timestamp | User’s Data Updation Time | false | true
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '**Table 4.1:** User Table'
  prefs: []
  type: TYPE_NORMAL
- en: '[Role Schema Table](toc.xhtml#s115a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User access to the application is determined by the assigned role and the permissions
    granted to that role. Users are allowed to perform specific actions within the
    application based on the rights associated with their assigned role. We have defined
    the role schema table for applications with constraints as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column Name** | **Type** | **Data Type** | **Description** | **Primary?**
    | **Is Null** | **Unique** |'
  prefs: []
  type: TYPE_TB
- en: '| `role_id` | `uuid` | uuid | Role’s unique identifier id | true | false |
    true |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | `email` | varchar(60) | Role’s name | false | false | true |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | `string` | varchar(30) | Role’s description | false | true
    | false |'
  prefs: []
  type: TYPE_TB
- en: '| `rights` | `string` | text | Rights as permission of diff modules | false
    | false | false |'
  prefs: []
  type: TYPE_TB
- en: '| `created_at` | `date` | timestamp | Role Creation Time | false | false |
    false |'
  prefs: []
  type: TYPE_TB
- en: '| `updated_at` | `date` | timestamp | Role’s Data Updation Time | false | true
    | false |'
  prefs: []
  type: TYPE_TB
- en: '**Table 4.2:** Role Table'
  prefs: []
  type: TYPE_NORMAL
- en: '[Project Schema Table](toc.xhtml#s116a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Project Management System (PMS), the project table serves as a central
    repository for storing information about different projects managed within the
    system. Each row in the project table represents a specific project, while each
    column stores various attributes or details related to those projects. We defined
    the schema for that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column Name** | **Type** | **Data Type** | **Description** | **Primary?**
    | **Is Null** | **Unique** | **Reference** |'
  prefs: []
  type: TYPE_TB
- en: '| `project_id` | `uuid` | integer | Project’s unique identifier id | true |
    false | true | - |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | `string` | varchar(60) | Project’s Name | false | false | true |
    - |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | `string` | varchar(200) | Project’s Description | false |
    true | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `user_ids` | `string` | text | Project’s assigned users_ids | false | true
    | false | User Table (user_id) |'
  prefs: []
  type: TYPE_TB
- en: '| `start_time` | `date` | timestamp | Project’s Start Date | false | true |
    false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `end_time` | `date` | timestamp | Project’s End Date | false | true | false
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| `status` | `enum` | varchar(30) | Current Project Status | false | false
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `created_at` | `date` | timestamp | User Creation Time | false | false |
    false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `updated_at` | `date` | timestamp | User Data Updation Time | false | true
    | false |  |'
  prefs: []
  type: TYPE_TB
- en: '**Table 4.3:** Project Table'
  prefs: []
  type: TYPE_NORMAL
- en: '[Task Schema Table](toc.xhtml#s117a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The task table is designed to store information about various tasks or activities
    associated with a specific project. Each row in the task table represents a specific
    task, while each column holds different attributes or details related to those
    tasks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column Name** | **Type** | **Data Type** | **Description** | **Primary?**
    | **Is Null** | **Unique** | **Reference** |'
  prefs: []
  type: TYPE_TB
- en: '| `task_id` | `uuid` | uuid | Task’s unique identifier id | true | false |
    true | - |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | `string` | varchar(60) | Task’s Name | false | false | true | -
    |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | `string` | varchar(300) | Task’s Description | false | true
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `project_id` | `uuid` | varchar(35) | Associated Project Id | false | true
    | false | Project Table (project_id) |'
  prefs: []
  type: TYPE_TB
- en: '| `user_id` | `uuid` | uuid | Assigned User Id | false | true | false | User
    Table (user_id) |'
  prefs: []
  type: TYPE_TB
- en: '| `estimated_start_time` | `date` | timestamp | Task’s Estimated Start Date
    | false | true | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `estimated_end_time` | `date` | timestamp | Task’s Estimated End Date | false
    | true | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `actual_start_time` | `date` | timestamp | Task’s Actual Start Date | false
    | true | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `actual_end_time` | `date` | timestamp | Task’s Actual End Date | false |
    true | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `priority` | `enum` | varchar(20) | Task’s priority e.g., High, Low, Medium
    | false | true | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `status` | `enum` | varchar(30) | Current Task Status | false | false | false
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| `supported_files` | `string` | text | Supported Files url | false | true
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `created_at` | `date` | timestamp | Task’s Creation Time | false | false
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `updated_at` | `date` | timestamp | Task’s Data Updation Time | false | true
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '**Table 4.4:** Task Table'
  prefs: []
  type: TYPE_NORMAL
- en: '[Comment Schema Table](toc.xhtml#s118a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The comment table is designed to store comments or notes associated with various
    tasks. Each row in the comment table represents a specific comment related to
    a particular task, while each column holds different attributes or details related
    to those comments as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column Name** | **Type** | **Data Type** | **Description** | **Primary?**
    | **Is Null** | **Unique** | **Reference** |'
  prefs: []
  type: TYPE_TB
- en: '| `comment_id` | `uuid` | uuid | Comment’s unique identifier id | true | false
    | true | - |'
  prefs: []
  type: TYPE_TB
- en: '| `comment` | `string` | varchar(300) | Comment | false | false | false | -
    |'
  prefs: []
  type: TYPE_TB
- en: '| `task_id` | `uuid` | uuid | Task’s Id of given comment | false | false |
    false | Task Table (task_id) |'
  prefs: []
  type: TYPE_TB
- en: '| `user_id` | `uuid` | uuid | User’s Id on given comment | false | false |
    false | User Table (user_id) |'
  prefs: []
  type: TYPE_TB
- en: '| `supported_files` | `string` | text | attached file’s url | false | true
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `created_at` | `date` | timestamp | Comment’s Creation Time | false | false
    | false | - |'
  prefs: []
  type: TYPE_TB
- en: '| `updated_at` | `date` | timestamp | Comment’s Data Updation Time | false
    | true | false | - |'
  prefs: []
  type: TYPE_TB
- en: '**Table 4.5:** Comment Table'
  prefs: []
  type: TYPE_NORMAL
- en: This is the overview of PMS database design with raw schema tables. Now that
    we have the schema ready, we can head to start writing our project. We will first
    start by defining the project file structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.2:** Entity Relationship Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Up the Project Structure](toc.xhtml#s119a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project structure is flexible and can be customized to suit the specific
    needs of your Node.js application, and we aim to minimize developers’ efforts
    by adhering to established standards throughout the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start developing a PMS application in Node.js through the initialization
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '[Init the project](toc.xhtml#s120a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you begin, ensure that you have installed the LTS (Long Term Support)
    version of Node.js and PostgreSQL on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '**PostgreSQL can be downloaded from [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    There are installers available for Linux, MacOs, Windows, BSD and Solaris. Since
    there are many flavors of Linux, the official website mentioned above also has
    separate instructions for each flavor.**'
  prefs: []
  type: TYPE_NORMAL
- en: The directory name for the project can be kept as `**pms-be**`**.** `**pms**`
    stands for Project Management System and `**-be**` can be appended because we
    are creating an API backend of the app. Let us create a new directory ``**`pms-be`**``
    and navigate to it using the command prompt (`**cmd**`). Inside the directory,
    initiate a new Node.js project by running the command `**"npm init**`.`**"**`
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `**"npm init"**` is executed, the setup process will prompt you to provide
    various details step by step. You can add the appropriate information and press
    `**"Enter"**` for each prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Package Name: (Default is **"**pms-be**"**)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Version: (Default is **"**1.0.0**"**)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description: **"**Project Management System**"**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entry Point: (Default is **"**index.js**"**) You can change it to **"**main.js**"**
    if needed.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test Command: If you don''t have a specific test command, you can leave this
    field blank.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Git Repository: If your project is not using Git, leave this field blank.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Keywords: Add relevant keywords separated by commas.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Author: Add the name of the project''s author.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`License: (Default is **"**ISC**"**) You can choose a different license or
    keep it as **"**ISC.**"**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Press **"**Enter**"** once more to complete the initialization process.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, your project’s initialization process will be successfully completed
    and the `**package.json**` file will be created.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.3:** Init Project'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installation of Project Dependency](toc.xhtml#s121a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the project is initialized, the next step involves installing the necessary
    packages and tools as dependencies. We highly recommend using Visual Studio Code
    as the development tool because it offers various extensions, such as intellisense
    for programming languages, code prettier, and git packages, which significantly
    streamline the development process. These extensions help save a considerable
    amount of effort for developers, making the development experience more efficient
    and enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us start to install the most required packages for project management
    system development such as `**express.js**`, `**postgresql(pg)**`, `**typescript**`,
    `**typeorm**`, `**ts-node**`, `**ts-lint**`, and so on, and later on we will install
    other packages as required while development.
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install express  --save`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install typescript -D`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install pg --save`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install typeorm --save`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install @types/express -D`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install @types/node -D`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install @types/pg -D`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install reflect-metadata --save`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install uuid --save`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install @types/uuid -D`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install ts-node prettier eslint eslint-config-prettier eslint-plugin`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-prettier -D`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install @typescript-eslint/eslint-plugin @typescript-eslint/parser -D`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we share the `**package.json**` file for reference to install all packages
    and it will also change day by day through development.
  prefs: []
  type: TYPE_NORMAL
- en: '`// package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"name": "pms-be",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"version": "1.0.0",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"description": "Project Management System",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"main": "main.js",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"scripts": {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"test": "echo \"Error: no test specified\" && exit 1",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"start": "nodemon dist/src/main.js"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`},`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"author": "Ravi Kumar Gupta, Yamini Panchal",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"license": "Proprietary",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"devDependencies": {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"@types/express": "4.17.17",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"@types/node": "20.4.2",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"@types/pg": "8.10.2",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"@types/uuid": "9.0.2",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"@typescript-eslint/eslint-plugin": "5.59.8",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"@typescript-eslint/parser": "5.59.8",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"eslint": "8.41.0",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"eslint-config-prettier": "8.8.0",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"eslint-plugin-prettier": "4.2.1",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"nodemon": "2.0.22",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"prettier": "2.8.8",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"ts-node": "10.9.1",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"typescript": "5.0.4"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`},`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"dependencies": {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"express": "4.18.2",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"pg": "8.11.1",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"reflect-metadata": "0.1.13",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"typeorm": "0.3.17",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"uuid": "9.0.0"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `**tsconfig.json**` file in the main directory of the project
    with the following code to ensure TypeScript compiles the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// tsconfig.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0][PRE1][PRE2][PRE3][PRE4] [PRE5]`    `npm install`    [PRE6] [PRE7]` [PRE8]`    `tsc
    --watch`    [PRE9] [PRE10]` [PRE11]`    `nodemon dist/src/main.js`    [PRE12]
    [PRE13]` [PRE14]`    `node src/main.js`    [PRE15] [PRE16][PRE17][PRE18]``js[PRE19]js
    `import cluster from ''cluster'';`    `import os from ''os'';`    `const numCPUs
    = os.cpus().length;`    `import { ExpressServer } from ''./express_server'';`    `if
    (cluster.isPrimary) {`    ``console.log(`Master process PID: ${process.pid}`);``    `for
    (let i = 0; i < numCPUs; i++) {`    `cluster.fork();`    `}`    `cluster.on(''exit'',
    (worker, code, signal) => {`    ``console.log(`Worker process ${worker.process.pid}
    exited with code ${code} and signal ${signal}`);``    `setTimeout(() => {`    `cluster.fork();`    `},
    1000);`    `});`    `} else {`    `// connect the express server`    `const server
    = new ExpressServer();`   [PRE20] `process.on(''uncaughtException'', (error: Error)
    => {`    ``console.error(`Uncaught exception in worker process``    ``${process.pid}:`,
    error);``    `// Close any open connections or resources`    `server.closeServer();`    `setTimeout(()
    => {`    `cluster.fork();`    `cluster.worker?.disconnect();`    `}, 1000);`    `});`    `//
    Gracefully handle termination signals`    `process.on(''SIGINT'', () => {`    `console.log(''Received
    SIGINT signal'');`    `// Close any open connections or resources`    `server.closeServer();`    `});`    `process.on(''SIGTERM'',
    () => {`    `console.log(''Received SIGTERM signal'');`    `// Close any open
    connections or resources`    `server.closeServer();`    `});`    `}`    As per
    the preceding code, we need to create `**express_server.ts**` as it is imported.
    So let us make it.    `// express_server.ts`   [PRE21][PRE22]``js[PRE23]`` `export
    interface IServerConfig {`    `port: number;`    `db_config: {`    `''db'': string;`    `''username'':
    string;`    `''password'': string;`    `''host'': string;`    `''port'': number;`    `''dbname'':
    string;`    `};`    `}`    Now to run the app, first compile the code with `**tsc
    --watch**`. After that, a `**dist**` folder will be created, and then run with
    `**nodemon**` `**dist/src/main.js**` while developing the app, the following output
    will be displayed.    Output :  ![](img/4.4.jpg)  **Figure 4.4:** Output Run Application    **Note**:
    *If you are using Visual Studio Code, you can configure and run the TypeScript
    watch task easily. To do this, press* `**"*Ctrl + P*"**`*, then select* `**"*Tasks:
    Run Task*"**` *and configure a task with* `***TypeScript***`*. Choose* `**"*tsc:watch
    -tsconfig.json*"**` *to enable watch mode for TypeScript compilation based on
    your* `***tsconfig.json***` *file.*    # [Connecting the Database](toc.xhtml#s125a)    TypeORM
    is widely used in modern TypeScript and JavaScript applications for its ease of
    use, flexibility, and abstraction of database operations. It simplifies the development
    process and improves maintainability when working with databases in Node.js. We
    already installed packages for `**postgreSQL**` and `**typeorm**`, respectively,
    using the following commands: `**npm i pg --save**`**,** `**npm i @types/pg -D**`
    and `**npm i typeorm -- save**`.    Now creates `**db.ts**` file in utils directory
    with the following code:    `// db.ts`    `import { DataSource } from ''typeorm'';`    `import
    { IServerConfig } from ''./config'';`    `import * as config from ''../../server_config.json'';`    `export
    class DatabaseUtil {`    `public server_config: IServerConfig = config;`    `constructor()
    {`    `this.connectDatabase();`    `}`    `private connectDatabase() {`    `try
    {`    `const db_config = this.server_config.db_config;`    `const AppDataSource
    = new DataSource({`    `type: ''postgres'',`    `host: db_config.host,`    `port:
    db_config.port,`    `username: db_config.username,`    `password: db_config.password,`    `database:
    db_config.dbname,`    `entities: [],`    `synchronize: true,`    `logging: false,`    `});`    `AppDataSource.initialize()`    `.then(()
    => {`    `console.log(''Connected to the database'');`    `})`    `.catch((error)
    => console.log(error));`    `} catch (error) {`    `console.error(''Error connecting
    to the database:'', error);`    `}`    `}`    `}`    For now, we have entities
    as blank arrays since we do not have any entities defined. Then import the database
    connection in `**main.ts**` with the updated following code:    `// main.ts`    `import
    cluster from ''cluster'';`    `import { ExpressServer } from ''./express_server'';`    `import
    { DatabaseUtil } from ''./utils/db'';`   [PRE24]`` `// connect the express server`    `const
    server = new ExpressServer();`    `// connect the database`    `new DatabaseUtil();`    `process.on(''uncaughtException'',
    (error: Error) => {`    ``console.error(`Uncaught exception in worker process
    ${process.pid}:`, error);``    `// Close any open connections or resources`    `server.closeServer();`    `setTimeout(()
    => {`    `cluster.fork();`    `cluster.worker?.disconnect();`    `}, 1000);`    `});`    `//
    Gracefully handle termination signals`    `process.on(''SIGINT'', () => {`    `console.log(''Received
    SIGINT signal'');`    `// Close any open connections or resources`    `server.closeServer();`    `});`    `process.on(''SIGTERM'',
    () => {`    `console.log(''Received SIGTERM signal'');`    `// Close any open
    connections or resources`    `server.closeServer();`    `});`    After running,
    the following output will be displayed on a successfully connected database.    Output:  ![](img/4.5.jpg)  **Figure
    4.5:** Database Connected Output    This way using typeorm postgreSQL database
    connected based on the database config defined in `**server_config.json**`.    #
    [Database Models (Entities)](toc.xhtml#s126a)    We have already seen database
    schema tables . To integrate the database schema into the code, we will create
    a components directory and subdirectories for roles, users, projects, tasks, and
    comments. In each of these directories, we will create a corresponding entity
    file.    `components`    `├── roles`    `│   └── roles_entity.ts`    `├── users`    `│  
    └── users_entity.ts`    `├── projects`    `│   └── projects_entity.ts`    `├──
    tasks`    `│   └── tasks_entity.ts`    `└── comments`    `└── comments_entity.ts`    We
    will start by defining the Roles entity:    # [Role Entity](toc.xhtml#s127a)    Create
    file `**role_entity.ts**` in role directory with the following code.    `// role_entity.ts`   [PRE25]`
    `import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn,`    `UpdateDateColumn
    } from ''typeorm'';`    `@Entity()`    `export class Roles {`    `@PrimaryGeneratedColumn(''uuid'')`    `role_id:
    string;`    `@Column({ length: 60, nullable: false, unique: true })`    `name:
    string;`    `@Column({ length: 200 })`    `description: string;`    `@Column({
    type: ''text'' })`    `rights: string;`    `@CreateDateColumn()`    `created_at:
    Date;`    `@UpdateDateColumn()`    `updated_at: Date;`    `}`    The code imports
    necessary decorators from TypeORM. These decorators are used to define the entity
    and its properties.    The `**@Entity()**` decorator marks the class `Roles` as
    a TypeORM entity, indicating that it represents a database table. It has the `**role_id**`
    as the primary key decorated with `**PrimaryGeneratedColumn**` with an auto-generated
    `UUID`, and the `name` field is defined as `unique` and `not` `nullable`.    The
    `**description**` field has a maximum length of 200 characters. The `**rights**`
    field uses the `**text**` data type to store larger textual data. The `**@CreateDateColumn()**`
    and `**@UpdateDateColumn()**` decorators handle the automatic insertion of data
    for respective insertion and updation time.    # [User Entity](toc.xhtml#s128a)    The
    Users entity represents the user information in the application’s database. Create
    `users_entity.ts` with the following code:    `// user_entity.ts`   [PRE26] `import
    { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn,`    `UpdateDateColumn,
    OneToOne, JoinColumn } from ''typeorm'';`    `import { Roles } from ''../roles/roles_entity'';`    `@Entity()`    `export
    class Users {`    `@PrimaryGeneratedColumn(''uuid'')`    `user_id: string;`    `@Column({
    length: 50, nullable: true })`    `fullname: string;`    `@Column({ length: 30,
    nullable: false, unique: true })`    `username: string;`    `@Column({ length:
    60, nullable: false, unique: true })`    `email: string;`    `@Column({ nullable:
    false })`    `password: string;`    `@Column({ nullable: false })`    `@ManyToOne(()
    => Roles)`    `@JoinColumn({ name: ''role_id'' })`    `role_id: Roles[''role_id''];`    `@CreateDateColumn()`    `created_at:
    Date;`    `@UpdateDateColumn()`    `updated_at: Date;`    `}`    As per user-defined
    entity, `**user_id**` serves as the primary key with auto-generated `**uuid**`,
    `**username**` and `**email**` will be unique with not-null constraints, `**fullname**`
    allows maximum 50 characters, and `**password**` also has a not-null constraints.    In
    this context, each user is linked with one role, establishing a many-to-one relationship
    between them, so there is many-to-one join established between two tables users
    and roles.    `**@ManyToOne(() => Roles)**`: This decorator specifies a many-to-one
    relationship between entities. It indicates that the current entity (likely representing
    a user or some other entity) has a many-to-one relationship with the Roles entity.
    The Roles entity is specified using a function that returns the target entity
    class.    `**@JoinColumn({ name: ''role_id**'' **})**`: This decorator specifies
    the column in the current entity that serves as the foreign key to establish the
    relationship. In this case, the `**role_id**` column is used as the foreign key.    `**role_id:
    Roles[''role_id**''**]**`: This line defines a TypeScript property `**role_id**`
    of type `**Roles[''role_id**''**]**`. It’s likely that Roles is an entity class
    representing roles in your application, and `**role_id**` is a property of that
    class representing the primary key or unique identifier of a role.    This is
    a basic overview of a many-to-one relationship.    # [Project Entity](toc.xhtml#s129a)    Now
    create a file `**projects_entity.ts**` with the following code:    `// projects_entity.ts`   [PRE27]`js
    [PRE28]js`` [PRE29]js[PRE30][PRE31][PRE32][PRE33]js[PRE34]js` [PRE35]`js`` [PRE36]`js[PRE37][PRE38][PRE39]'
  prefs: []
  type: TYPE_NORMAL
