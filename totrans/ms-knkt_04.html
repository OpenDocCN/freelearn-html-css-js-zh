<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Application Development with Components and Modules</h1></div></div></div><p class="calibre8">Okay, time to get back to application development. We touched briefly on this back in <a class="calibre1" title="Chapter 1. Knockout Essentials" href="part0015_split_000.html#page">Chapter 1</a>, <em class="calibre12">Knockout Essentials</em>; we will be returning to it here. This chapter is all about how to work with Knockout inside modern web applications. In this chapter, we will look at the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Using modules with RequireJS</li><li class="listitem">Creating reusable components</li><li class="listitem">Extending Knockout with custom component loaders</li><li class="listitem"><strong class="calibre9">Single Page Application</strong> (<strong class="calibre9">SPA</strong>) routing</li></ul></div><p class="calibre8">Because Knockout is a library—a fact it proclaims proudly on the home page—it doesn't cover everything you need in complete web applications. This allows Knockout to specialize by focusing on a limited feature set, but it leaves the task of deciding how to build the rest of the application to you, the developer. The methods we cover in this chapter are not the only available options—we don't have that kind of time or space—but they should provide enough general guidance to help you make your own decisions while keeping in mind Knockout's strengths.</p><p class="calibre8">We are also going to transform the <code class="literal">Contacts List</code> application to an SPA—an application that uses JavaScript to change the template of the current view, mimicking a page change instead of using browser navigation. This pattern has become so popular that most developers consider it a given when working on new JavaScript web clients, so it's important to understand how Knockout fits into this model of development.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec31" class="calibre1"/>RequireJS – AMD viewmodels</h1></div></div></div><p class="calibre8">RequireJS (<a class="calibre1" href="http://requirejs.org/">http://requirejs.org/</a>) <a id="id288" class="calibre1"/>is <a id="id289" class="calibre1"/>a library that you should have at least heard of already, if not used. This is still a book about Knockout, and if you are planning to use RequireJS in an application, you should read up on it first, but I will still give you a brief overview here.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec55" class="calibre1"/>An overview of RequireJS</h2></div></div></div><p class="calibre8">RequireJS's purpose is<a id="id290" class="calibre1"/> to allow your code to be broken into modules that declare their dependencies so that they can be injected at runtime. This has several important benefits. As RequireJS loads your JavaScript, you don't have to include each script with a <code class="literal">script</code> tag in your HTML. As RequireJS loads the scripts based on their dependencies, you don't have to worry about the order they are loaded in. As each module's dependencies are injected, the module can be tested easily with mocks. RequireJS also keeps all the objects it loads out of the global scope, which decreases the likelihood of namespace collisions in addition to being considered a good general practice.</p><p class="calibre8">By default, RequireJS will asynchronously load all of your scripts on demand at runtime. In some cases, this lazy loading is beneficial, but in production, you will want your code bundled into a single file most of the time. RequireJS provides <strong class="calibre9">r.js</strong>, its optimizer, for this. RequireJS can even combine these techniques by bundling multiple groups of files together and then loading these groups on demand at runtime. The best part is that your code won't have to change, regardless of which mode you work in!</p><div><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">We won't be covering <code class="literal">r.js</code>, but if you are developing web applications, it might be worth investigating <a id="id291" class="calibre1"/>this (see <a class="calibre1" href="http://requirejs.org/docs/optimization.html">http://requirejs.org/docs/optimization.html</a>).</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec56" class="calibre1"/>Asynchronous Module Definitions</h2></div></div></div><p class="calibre8">
<strong class="calibre9">Asynchronous Module Definitions</strong> (<strong class="calibre9">AMD</strong>) is an important concept in <a id="id292" class="calibre1"/>RequireJS: it declares a function whose return value represents the module. In form, it isn't too different from the <strong class="calibre9">Immediately Evaluating Function Expressions</strong> (<strong class="calibre9">IEFE</strong>)<a id="id293" class="calibre1"/> we saw in <a class="calibre1" title="Chapter 1. Knockout Essentials" href="part0015_split_000.html#page">Chapter 1</a>, <em class="calibre12">Knockout Essentials</em>. This is a typical module definition:</p><div><pre class="programlisting">define('moduleName', ['pathto/dependency'], dependency'], function(injectedModule) {
  return //Some module code;
});</pre></div><p class="calibre8">The <code class="literal">define</code> method<a id="id294" class="calibre1"/> forms the first and only top-level statement in the file. RequireJS actually enforces a one-module-per-file limit by ignoring multiple calls to <code class="literal">define</code>. The <code class="literal">define</code> call takes the following three parameters, and the first two are optional:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Module name</strong>: This <a id="id295" class="calibre1"/>parameter is often ignored, as the standard way to reference modules is by their path. Hence, we will not use this parameter.</li><li class="listitem"><strong class="calibre9">Dependencies</strong>: This is <a id="id296" class="calibre1"/>an array of module names or paths that the module depends on. Paths do not require the <code class="literal">.js</code> suffix; RequireJS already knows it's loading JavaScript.</li><li class="listitem"><strong class="calibre9">Module function</strong>: This <a id="id297" class="calibre1"/>function receives each dependency from the previous array as a parameter and should return the module.</li></ul></div><p class="calibre8">When RequireJS tries to load a module, it locates the module by path or name and runs the <code class="literal">define</code> method it finds in that file. First, it checks whether all of the dependencies have been loaded; if they have not been loaded, it recursively loads them, asynchronously and in parallel. When all dependent modules are loaded, it runs the module function, passing in each dependency as a parameter in the same order in which they were declared as dependencies. The return value of the module-loading function is the value that is passed as a parameter to any modules that require it as a dependency.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec57" class="calibre1"/>Starting RequireJS</h2></div></div></div><p class="calibre8">There are actually multiple ways to start an app using RequireJS, but by far, the most common way is with a <code class="literal">script</code> tag that points to the initial script of your application:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/require-2.1.js" data-main="/app/main"&gt;&lt;/script&gt;</pre></div><p class="calibre8">The <code class="literal">data-main</code> attribute<a id="id298" class="calibre1"/> indicates which script will configure RequireJS and start the application. Note that the <code class="literal">.js</code> suffix is not necessary, as with normal module paths.</p><p class="calibre8">This <code class="literal">script</code> tag typically goes in your shell (or layout) file, and it replaces all of the <code class="literal">script</code> tags that RequireJS is responsible for loading. In many cases, this means that the only JavaScript <code class="literal">script</code> tag is the one that loads RequireJS. This is one of the killer features of RequireJS: as we develop, we no longer need to add <code class="literal">script</code> tags to our HTML code.</p><p class="calibre8">Note that the path starts with a forward slash, which makes it an absolute path. It's required because the shell is used on multiple pages, and a relative path will not work on a URL such as <code class="literal">/contacts/1</code>, as it will look in <code class="literal">/contacts/app/main.js</code> for our script.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec58" class="calibre1"/>Configuration</h2></div></div></div><p class="calibre8">The <code class="literal">main.js</code> file (the conventional name for the entry point of an AMD application) typically contains a configuration section before the start. Here is the configuration that we will be using:</p><div><pre class="programlisting">require.config({
  paths: {
    'knockout': '/lib/knockout-3.2.0',
    'bootstrap': '/lib/bootstrap-3.1.1',
    'jquery': '/lib/jquery-2.1.1.min'
  },
  shim: {
    'bootstrap': {
      deps: ['jquery'],
      exports: '$.fn.popover'
    }
  }
});</pre></div><p class="calibre8">The <code class="literal">paths</code> section allows <a id="id299" class="calibre1"/>us to map paths to module names for use in the dependency arrays. This is a good practice for all library code so that our application code can use a simple, consistent name. Again, the use of absolute paths is important.</p><p class="calibre8">The <code class="literal">shim</code> section is necessary for loading scripts that depend on globally available objects. In the preceding example, the shim for <code class="literal">bootstrap</code> declares jQuery as a dependency and indicates that it exports <code class="literal">$.fn.popover</code>. Normally, you would look for a new namespace such as <code class="literal">$.bootstrap</code>, but as <code class="literal">bootstrap</code> doesn't create a single endpoint; we are looking for one of the plugins it adds. Any exported value can be used here; <code class="literal">popover</code> was just the chosen one.</p><p class="calibre8">Many libraries are starting to support being loaded as AMD: they look for RequireJS or other module loaders and use them if they are available. Not all libraries do this, though, and the standard model of JavaScript libraries has always been to just look for dependencies in the global scope. As <code class="literal">bootstrap</code> needs <code class="literal">jQuery</code> but does not indicate this dependency to RequireJS, it will fail if we tried to load it normally. The shim tells RequireJS that this library is an old global-scope style script and manually indicates its dependencies. The <code class="literal">exports</code> section provides an object that RequireJS can look for to check whether the script has finished loading. RequireJS will wait until the specified object exists before allowing any AMDs that depend on <code class="literal">bootstrap</code> to start. Essentially, the <code class="literal">shim</code> section is how RequireJS uses non-AMD code as an asynchronous dependency. If you need to use jQuery plugins or other non-AMD compatible libraries, just make a shim for them.</p><p class="calibre8">There are many other options for the <a id="id300" class="calibre1"/>RequireJS configuration—too many to cover here. If you want to learn more, check out their documentation, which is available at <a class="calibre1" href="http://requirejs.org/docs/api.html#config">http://requirejs.org/docs/api.html#config</a>.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch04lvl2sec59" class="calibre1"/>Starting the app</h2></div></div></div><p class="calibre8">Now that RequireJS is <a id="id301" class="calibre1"/>configured, it's time to start the application. The main script, which contains our configuration, is also where RequireJS looks for the initial module, which looks like this:</p><div><pre class="programlisting">require.config({
  //config
});

define(['jquery', 'knockout', 'contactsPage', 'bootstrap'], function($, ko, ContactsPageViewmodel) {
    $(document).ready(function() {
      ko.applyBindings(new ContactsPageViewmodel());
    });
});</pre></div><p class="calibre8">The main module is just like other modules, except that RequireJS will run it as soon as its dependencies are available. This code is the same startup code that used to be in the <strong class="calibre9">Contacts</strong> page's script. You might notice that the dependencies for this module don't match the names of the parameters being passed in. jQuery is being injected as <code class="literal">$</code>, Knockout as <code class="literal">ko</code>, and the <strong class="calibre9">Contacts</strong> page constructor as <code class="literal">ContactsPageViewModel</code>. All of these are conventional JavaScript names for their matching objects. The modules are injected in the order of the dependency array; RequireJS doesn't actually look at the name of the parameter. This is no different from standard functions; callers don't care about the names of parameters, they only care about the order. This isn't always obvious to new users, though.</p><p class="calibre8">You probably also noticed that <code class="literal">bootstrap</code> doesn't even have a parameter. This is because <code class="literal">bootstrap</code> doesn't get its own object; all it does is add functions to jQuery. However, RequireJS won't load it (or shim it, in this case) until a dependency requires it to. It's common to see plugin-style dependencies initialized in this manner, as we want them to be available as soon as the app starts.</p><p class="calibre8">To see the <code class="literal">Contacts List</code> application after it is converted into AMD modules, open the <code class="literal">cp4-contacts</code> branch. The code was already in IEFE blocks, so not much has changed. The <code class="literal">app</code> object is no longer required, as namespacing has been replaced with the dependency injection. All of the <code class="literal">script</code> tags, except for RequireJS, have been removed from the HTML code. The application still functions in the same manner, but by using RequireJS, we no longer have to worry about loading the script. This might seem like a minor gain now, but it will make a big difference when your app starts to grow.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_7"><a id="ch04lvl2sec60" class="calibre1"/>The text plugin</h2></div></div></div><p class="calibre8">Managing HTML<a id="id302" class="calibre1"/> templates can be tricky, because there is no native way to reference or embed<a id="id303" class="calibre1"/> external HTML files like there is with scripts. If you are familiar with the Knockout community, you might have encountered some of the plugins designed to solve the problem, such as <em class="calibre12">Knockout-External-Templates</em> (which has been discontinued). RequireJS solves this problem cleanly with the text plugin. The text plugin works much like standard modules: you declare a dependency on external text, and RequireJS injects it into the module just like a normal JavaScript module.</p><p class="calibre8">To get started, you should add the text library to your RequireJS config. Using a name such as <code class="literal">text</code> is standard:</p><div><pre class="programlisting">require.config({
  paths: {
    'text': '/lib/require-text-2.0.12',
    'knockout': '/lib/knockout-3.2.0',
    'bootstrap': '/lib/bootstrap-3.1.1',
    'jquery': '/lib/jquery-2.1.1.min'
  }
});</pre></div><p class="calibre8">Once the text plugin is available, you can use it in external files like this:</p><div><pre class="programlisting">define(['text!some.html'], function (htmlString) {
  
});</pre></div><p class="calibre8">This configuration part is optional if the text plugin is at the root of your app and you use the <code class="literal">text!</code> prefix for dependencies. As we have been putting our third-party libraries in a different folder, the configuration is necessary.</p><p class="calibre8">In the next section, we will look at how to combine this ability with components in order to create reusable templates with external, isolated HTML views.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>Components</h1></div></div></div><p class="calibre8">In Version 3.2, Knockout added <a id="id304" class="calibre1"/>components using the combination of a template (view) with a viewmodel to create reusable, behavior-driven DOM objects. Knockout components are inspired by web components, a new (and experimental, at the time of writing this) set of standards that allow developers to define custom HTML elements paired with JavaScript that create packed controls. Like web components, Knockout allows the developer to use custom HTML tags to represent these components in the DOM. Knockout also allows components to be instantiated with a binding handler on standard HTML elements. Knockout binds components by injecting an HTML template, which is bound to its own viewmodel.</p><p class="calibre8">This is probably the single<a id="id305" class="calibre1"/> largest feature Knockout has ever added to the core library. The reason we started with RequireJS is that components can optionally be loaded and defined with module loaders, including their HTML templates! This means that our entire application (even the HTML) can be defined in independent modules, instead of as a single hierarchy, and loaded asynchronously.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec61" class="calibre1"/>The basic component registration</h2></div></div></div><p class="calibre8">Unlike <a id="id306" class="calibre1"/>extenders and binding handlers, which are created by just <a id="id307" class="calibre1"/>adding an object to Knockout, components are created by calling the <code class="literal">ko.components.register</code> function:</p><div><pre class="programlisting">ko.components.register('contact-list, {
  viewModel: function(params) { },
  template: //template string or object
});</pre></div><p class="calibre8">This will create a new component named <code class="literal">contact-list</code>, which uses the object returned by the <code class="literal">viewModel</code> function as a binding context, and the template as its view. It is recommended that you use lowercase, dash-separated names for components so that they can easily be used as custom elements in your HTML.</p><p class="calibre8">To use this newly created component, you can use a custom element or the component binding. All the following three tags produce equivalent results:</p><div><pre class="programlisting">&lt;contact-list params="data: contacts"&gt;&lt;contact-list&gt;
&lt;div data-bind="component: { name: 'contact-list', params: { data: contacts }"&gt;&lt;/div&gt;
&lt;!-- ko component: { name: 'contact-list', params: { data: contacts } --&gt;&lt;!-- /ko --&gt;</pre></div><p class="calibre8">Obviously, the custom element syntax is much cleaner and easier to read. It is important to note that custom elements cannot be self-closing tags. This is a restriction of the HTML parser and <em class="calibre12">cannot</em> be controlled by Knockout.</p><p class="calibre8">There is one advantage of using the component binding: the name of the component can be an observable. If the name of the component changes, the previous component will be disposed (just like it would if a control flow binding removed it) and the new component will be initialized.</p><p class="calibre8">The <code class="literal">params</code> attribute of custom elements work in a manner that is similar to the <code class="literal">data-bin</code>d attribute. Comma-separated key/value pairs are parsed to create a property bag, which is given to the component. The values can contain JavaScript literals, observable properties, or expressions. It is also possible to register a component without a viewmodel, in which case, the object created by <code class="literal">params</code> is directly used as the binding context.</p><p class="calibre8">To see this, we'll convert the list of contacts into a component:</p><div><pre class="programlisting">&lt;contact-list params="contacts: displayContacts, 
  edit: editContact, 
  delete: deleteContact"&gt;
&lt;/contact-list&gt;</pre></div><p class="calibre8">The HTML code for the list is replaced with a custom element with parameters for the list as well as callbacks for the two buttons, which are <code class="literal">edit</code> and <code class="literal">delete</code>:</p><div><pre class="programlisting">ko.components.register('contact-list', {
  template: 
  '&lt;ul class="list-unstyled" data-bind="foreach: contacts"&gt;'
    +'&lt;li&gt;'
      +'&lt;h3&gt;'
        +'&lt;span data-bind="text: displayName"&gt;&lt;/span&gt; &lt;small data-bind="text: phoneNumber"&gt;&lt;/small&gt; '
        +'&lt;button class="btn btn-sm btn-default" data-bind="click: $parent.edit"&gt;Edit&lt;/button&gt; '
        +'&lt;button class="btn btn-sm btn-danger" data-bind="click: $parent.delete"&gt;Delete&lt;/button&gt;'
      +'&lt;/h3&gt;'
    +'&lt;/li&gt;'
  +'&lt;/ul&gt;'
});</pre></div><p class="calibre8">This component<a id="id308" class="calibre1"/> registration uses an inline template. You can see this component in the <code class="literal">cp4-inline-component</code> branch. Everything still looks and works the same, <a id="id309" class="calibre1"/>but the resulting HTML now includes our custom element.</p><div><img src="img/00007.jpeg" alt="The basic component registration" class="calibre10"/></div><p class="calibre11"> </p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec16" class="calibre1"/>Custom elements in IE 8 and higher</h3></div></div></div><p class="calibre8">IE 9 and later versions as well as all <a id="id310" class="calibre1"/>other major browsers have no issue with seeing custom elements in the DOM before they have been registered. However, older versions of IE will remove the element if it hasn't been registered. The registration can be done either with Knockout, with <code class="literal">ko.components.register('component-name')</code>, or with the standard <code class="literal">document.createElement('component-name')</code> expression statement. One of these must come before the custom element, either by the script containing them being first in the DOM, or by the custom element being added at runtime.</p><p class="calibre8">When using RequireJS, being in the DOM first won't help as the loading is asynchronous. If you need to support older IE versions, it is recommended that you include a separate script to register the custom element names at the top of the <code class="literal">body</code> tag or in the <code class="literal">head</code> tag:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;script&gt;
      document.createElement('my-custom-element');
    &lt;/script&gt;
    &lt;script src='require.js' data-main='app/startup'&gt;&lt;/script&gt;

    &lt;my-custom-element&gt;&lt;/my-custom-element&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">Once this has been done, components will work in IE 6 and higher even with custom elements.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec62" class="calibre1"/>Template registration</h2></div></div></div><p class="calibre8">The <code class="literal">template</code> property of the <a id="id311" class="calibre1"/>configuration sent to register can take any of the <a id="id312" class="calibre1"/>following formats:</p><div><pre class="programlisting">ko.components.register('component-name', {
  template: [OPTION]
});</pre></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec17" class="calibre1"/>The element ID</h3></div></div></div><p class="calibre8">Consider the<a id="id313" class="calibre1"/> following code statement:</p><div><pre class="programlisting">template: { element: 'component-template' }</pre></div><p class="calibre8">If you specify the ID of an element in the DOM, the contents of that element will be used as the template for the component. Although it isn't supported in IE yet, the template element is a good candidate, as browsers do not visually render the contents of template elements.</p><p class="calibre8">This method can be seen in the <code class="literal">cp4-component-id</code> branch.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec18" class="calibre1"/>The element instance</h3></div></div></div><p class="calibre8">Consider the following <a id="id314" class="calibre1"/>code statement:</p><div><pre class="programlisting">template: { element: instance }</pre></div><p class="calibre8">You can pass a real DOM element to the template to be used. This might be useful in a scenario where the template was constructed programmatically. Like the element ID method, only the contents of the elements will be used as the template:</p><div><pre class="programlisting">var template = document.getElementById('contact-list-template');
ko.components.register('contact-list', {
  template: { element: template }
});</pre></div><p class="calibre8">This method can be seen in the <code class="literal">cp4-component-instance</code> branch.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec19" class="calibre1"/>An array of DOM nodes</h3></div></div></div><p class="calibre8">Consider the <a id="id315" class="calibre1"/>following code statement:</p><div><pre class="programlisting">template: [nodes]</pre></div><p class="calibre8">If you pass an array of DOM nodes to the template configuration, then the entire array will be used as a template and not just the descendants:</p><div><pre class="programlisting">var template = document.getElementById('contact-list-template')
nodes = Array.prototype.slice.call(template.content.childNodes);
ko.components.register('contact-list', {
  template: nodes
});</pre></div><p class="calibre8">This can be seen in the <code class="literal">cp4-component-arrray</code> branch.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec20" class="calibre1"/>Document fragments</h3></div></div></div><p class="calibre8">Consider the following <a id="id316" class="calibre1"/>code statement:</p><div><pre class="programlisting">template: documentFragmentInstance</pre></div><p class="calibre8">If you pass a document fragment, the entire fragment will be used as a template instead of just the descendants:</p><div><pre class="programlisting">var template = document.getElementById('contact-list-template');
ko.components.register('contact-list', {
  template: template.content
});</pre></div><p class="calibre8">This example works because<a id="id317" class="calibre1"/> template elements wrap their contents in a document fragment in order to stop the normal rendering. Using the content is the same method that Knockout uses internally when a template element is supplied. This example can be seen in the <code class="literal">cp4-component-fragment</code> branch.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec21" class="calibre1"/>HTML strings</h3></div></div></div><p class="calibre8">We already saw an example for <a id="id318" class="calibre1"/>HTML strings in the previous section. While using the value inline is probably uncommon, supplying a string would be an easy thing to do if your build system provided it for you.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec22" class="calibre1"/>Registering templates using the AMD module</h3></div></div></div><p class="calibre8">Consider the following code statement:</p><div><pre class="programlisting">template: { require: 'module/path' }</pre></div><p class="calibre8">If a <code class="literal">require</code> property is <a id="id319" class="calibre1"/>passed to the configuration object of a template, the default module loader will load the module and use it as the template. The module can return any of the preceding formats. This is especially useful for the RequireJS text plugin:</p><div><pre class="programlisting">ko.components.register('contact-list', {
  template: { require: 'text!contact-list.html'}
});</pre></div><p class="calibre8">Using this method, we can extract the HTML template into its own file, drastically improving its organization. By itself, this is a huge benefit to development. An example of this can be seen in the <code class="literal">cp4-component-text</code> branch.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec63" class="calibre1"/>The viewmodel registration</h2></div></div></div><p class="calibre8">Like template registration, viewmodels <a id="id320" class="calibre1"/>can be registered using several<a id="id321" class="calibre1"/> different formats. To demonstrate this, we'll use a simple viewmodel of our contacts list components:</p><div><pre class="programlisting">function ListViewmodel(params) {
  this.contacts = params.contacts;
  this.edit = params.edit;
  this.delete = function(contact) {
    console.log('Mock Deleting Contact', ko.toJS(contact));
  };
};</pre></div><p class="calibre8">To verify that things are getting wired up properly, you'll want something interactive; hence, we <a id="id322" class="calibre1"/>use <a id="id323" class="calibre1"/>the fake <code class="literal">delete</code> function.</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec23" class="calibre1"/>The constructor function</h3></div></div></div><p class="calibre8">Consider the following<a id="id324" class="calibre1"/> code statement:</p><div><pre class="programlisting">viewModel: Constructor</pre></div><p class="calibre8">If you supply a function to the <code class="literal">viewModel</code> property, it will be treated as a constructor. When the component is instantiated, <code class="literal">new</code> will be called on the function, with the <code class="literal">params</code> object as its first parameter:</p><div><pre class="programlisting">ko.components.register('contact-list', {
  template: { require: 'text!contact-list.html'},
  viewModel: ListViewmodel //Defined above
});</pre></div><p class="calibre8">This method can be seen in the <code class="literal">cp4-components-constructor</code> branch.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec24" class="calibre1"/>A singleton object</h3></div></div></div><p class="calibre8">Consider the <a id="id325" class="calibre1"/>following code statement:</p><div><pre class="programlisting">viewModel: { instance: singleton }</pre></div><p class="calibre8">If you want all your component instances to be backed by a shared object—though this is not recommended—you can pass it as the <code class="literal">instance</code> property of a configuration object. Because the object is shared, parameters cannot be passed to the viewmodel using this method.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec25" class="calibre1"/>The factory function</h3></div></div></div><p class="calibre8">Consider the <a id="id326" class="calibre1"/>following code statement:</p><div><pre class="programlisting">viewModel: { createViewModel: function(params, componentInfo) {} }</pre></div><p class="calibre8">This method is useful because it supplies the container element of the component to the second parameter on <code class="literal">componentInfo.element</code>. It also provides you with the opportunity to perform any other setup, such as modifying or extending the constructor parameters. The <code class="literal">createViewModel</code> function should return an instance of a viewmodel component:</p><div><pre class="programlisting">ko.components.register('contact-list', {
  template: { require: 'text!contact-list.html'},
  viewModel: { createViewModel: function(params, componentInfo) {
    console.log('Initializing component for', componentInfo.element);
    return new ListViewmodel(params);
  }}
});</pre></div><p class="calibre8">This example can be<a id="id327" class="calibre1"/> seen in the <code class="literal">cp4-component-factory</code> branch.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec26" class="calibre1"/>Registering viewmodels using an AMD module</h3></div></div></div><p class="calibre8">Consider the following <a id="id328" class="calibre1"/>code statement:</p><div><pre class="programlisting">viewModel: { require: 'module-path' }</pre></div><p class="calibre8">Just like templates, viewmodels can be registered with an AMD module that returns any of the preceding formats.</p><p class="calibre8">In the <code class="literal">cp4-component-module</code> branch, you can see an example of this. The component registration has been moved to the <code class="literal">main.js</code> file.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec64" class="calibre1"/>Registering AMD</h2></div></div></div><p class="calibre8">In addition to<a id="id329" class="calibre1"/> registering the template and the viewmodel as AMD modules individually, you<a id="id330" class="calibre1"/> can register the entire component with a require call:</p><div><pre class="programlisting">ko.components.register('contact-list', { require: 'contact-list' });</pre></div><p class="calibre8">The AMD module will return the entire component configuration:</p><div><pre class="programlisting">define(['knockout', 'text!contact-list.html'], function(ko, templateString) {
  function ListViewmodel(params) {
    this.contacts = params.contacts;
    this.edit = params.edit;
    this.delete = function(contact) {
      console.log('Mock Deleting Contact', ko.toJS(contact));
    };
  }

  return { template: templateString, viewModel: ListViewmodel };
});</pre></div><p class="calibre8">As the Knockout documentation points out, this method has several benefits:</p><div><ul class="itemizedlist"><li class="listitem">The registration call is just a <code class="literal">require</code> path, which is easy to manage.</li><li class="listitem">The component is composed of two parts: a JavaScript module and an HTML module. This provides both simple organization and clean separation.</li><li class="listitem">The <a id="id331" class="calibre1"/>RequireJS optimizer, which is <code class="literal">r.js</code>, can use the text dependency on the HTML module to bundle the HTML code with the bundled output. This means your entire application, including the HTML templates, can be a single file in production (or a collection of bundles if you want to take advantage of lazy loading).</li></ul></div><p class="calibre8">You can see an example of <a id="id332" class="calibre1"/>this in the <code class="literal">cp4-component-amd</code> branch. This is the recommended pattern for components and is the one that will be used for the rest of the examples in this chapter.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec65" class="calibre1"/>Observing changes in component parameters</h2></div></div></div><p class="calibre8">Component parameters will be <a id="id333" class="calibre1"/>passed via the <code class="literal">params</code> object to the component's viewmodel in one of the following three ways:</p><div><ul class="itemizedlist"><li class="listitem">No observable expression evaluation needs to occur, and the value is passed literally:<div><pre class="programlisting">&lt;component params="name: 'Timothy Moran'"&gt;&lt;/component&gt;
&lt;component params="name: nonObservableProperty"&gt;&lt;/component&gt;
&lt;component params="name: observableProperty"&gt;&lt;/component&gt;
&lt;component params="name: viewModel.observableSubProperty"&gt;&lt;/component&gt;</pre></div><p class="calibre13">In all of these cases, the value is passed directly to the component on the <code class="literal">params</code> object. This means that changes to these values will change the property on the instantiating viewmodel, except for the first case (literal values). Observable values can be subscribed to normally.</p></li><li class="listitem">An observable expression needs to be evaluated, so it is wrapped in a computed observable:<div><pre class="programlisting">&lt;component params="name: name() + '!'"&gt;&lt;/component&gt;</pre></div><p class="calibre13">In this case, <code class="literal">params.name</code> is not the original property. Calling <code class="literal">params.name()</code> will evaluate the computed wrapper. Trying to modify the value will fail, as the computed value is not writable. The value can be subscribed to normally.</p></li><li class="listitem">An observable expression evaluates an observable instance, so it is wrapped in an observable that unwraps the result of the expression:<div><pre class="programlisting">&lt;component params="name: isFormal() ? firstName : lastName"&gt;&lt;/component&gt;</pre></div><p class="calibre13">In this example, <code class="literal">firstName</code> and <code class="literal">lastName</code> are both observable properties. If calling <code class="literal">params.name()</code> returned the observable, you will need to call <code class="literal">params.name()()</code> to get the actual value, which is rather ugly. Instead, Knockout automatically unwraps the expression so that calling <code class="literal">params.name()</code> returns the actual value of either <code class="literal">firstNam</code>e or <code class="literal">lastName</code>.</p></li></ul></div><p class="calibre8">If you need to<a id="id334" class="calibre1"/> access the actual observable instances to, for example, write a value to them, trying to write to <code class="literal">params.name</code> will fail, as it is a computed observable. To get the unwrapped value, you can use the <code class="literal">params.$raw</code> object, which provides the unwrapped values. In this case, you can update the name by calling <code class="literal">params.$raw.name('New')</code>.</p><p class="calibre8">In general, this case should be avoided by removing the logic from the binding expression and placing it in a computed observable in the viewmodel.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch04lvl2sec66" class="calibre1"/>The component's life cycle</h2></div></div></div><p class="calibre8">When a component binding is <a id="id335" class="calibre1"/>applied, Knockout takes the following steps.</p><div><ol class="orderedlist"><li class="listitem" value="1">The component loader asynchronously creates the viewmodel factory and template. This result is cached so that it is only performed once per component.</li><li class="listitem" value="2">The template is cloned and injected into the container (either the custom element or the element with the component binding).</li><li class="listitem" value="3">If the component has a viewmodel, it is instantiated. This is done synchronously.</li><li class="listitem" value="4">The component is bound to either the viewmodel or the <code class="literal">params</code> object.</li><li class="listitem" value="5">The component is left <em class="calibre12">active</em> until it is disposed.</li><li class="listitem" value="6">The component is disposed. If the viewmodel has a <code class="literal">dispose</code> method, it is called, and then the template is removed from the DOM.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_7"><a id="ch04lvl2sec67" class="calibre1"/>The component's disposal</h2></div></div></div><p class="calibre8">If the component is removed from <a id="id336" class="calibre1"/>the DOM by Knockout, either because of the name of the component binding or a control flow binding being changed (for example, <code class="literal">if</code> and <code class="literal">foreach</code>), the component will be disposed. If the component's viewmodel has a <code class="literal">dispose</code> function, it will be called. Normal Knockout bindings in the components view will be automatically disposed, just as they would in a normal control flow situation. However, anything set up by the viewmodel needs to be manually cleaned up. Some examples of viewmodel cleanup include the following:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">setInterval</code> callbacks can be removed with <code class="literal">clearInterval</code>.</li><li class="listitem">Computed observables can be removed by calling their <code class="literal">dispose</code> method. Pure computed observables don't need to be disposed. Computed observables that are only used by bindings or other viewmodel properties also do not need to be disposed, as garbage collection will catch them.</li><li class="listitem">Observable subscriptions can be disposed by calling their <code class="literal">dispose</code> method.</li><li class="listitem">Event handlers can be created by components that are not part of a normal Knockout binding.</li></ul></div><p class="calibre8">You can see a simple dispose handler in the <code class="literal">cp4-dispose</code> branch. It just logs to the console to demonstrate when it will fire; try editing a contact to make the control flow remove the list from the page.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_8"><a id="ch04lvl2sec68" class="calibre1"/>Combining components with data bindings</h2></div></div></div><p class="calibre8">There is only one restriction<a id="id337" class="calibre1"/> of <code class="literal">data-bind</code> attributes that are <a id="id338" class="calibre1"/>used on custom elements with the component binding: the binding handlers cannot use <code class="literal">controlsDescendantBindings</code>. This isn't a new restriction; two bindings that control descendants cannot be on a single element, and since components control descendant bindings that cannot be combined with a binding handler that also controls descendants. It is worth remembering, though, as you might be inclined to place an <code class="literal">if</code> or <code class="literal">foreach</code> binding on a component; doing this will cause an error. Instead, wrap the component with an element or a containerless binding:</p><div><pre class="programlisting">&lt;ul data-bind='foreach: allProducts'&gt;
  &lt;product-details params='product: $data'&gt;&lt;/product-details&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">It's also worth noting that bindings such as <code class="literal">text</code> and <code class="literal">html</code> will replace the contents of the element they are on. When used with components, this will potentially result in the component being lost, so it's not a good idea.</p><p class="calibre8"><strong class="calibre9">Custom component loaders</strong></p><p class="calibre8">So far, we have covered the<a id="id339" class="calibre1"/> behavior of the default component loader. It is quite flexible, and for many developers, it will be quite sufficient for most use cases. However, it is possible to implement the custom component-loading functionality. In fact, you can have multiple component loaders active simultaneously, each providing different capabilities.</p><p class="calibre8">This section will deal with creating custom component loaders. If you are satisfied with the functionality of the default loader, you might want to skip this section and continue to single page application routing.</p><p class="calibre8">First, let's cover how the component-loading system works. Component loading is only done once per component. Knockout caches the loaded components. This cache provides the following two public functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">ko.components.get(name, callback)</code>: This <a id="id340" class="calibre1"/>function loops through all the loaders until one of them returns a component. This component is cached, and then the callback is invoked with it.</li><li class="listitem"><code class="literal">ko.components.clearCachedDefinition(name)</code>: This<a id="id341" class="calibre1"/> function removes the component from the registry.</li></ul></div><p class="calibre8">Knockout maintains an array of loaders on <code class="literal">ko.components.loaders</code>. By default, this array only contains a single loader, which also lives on <code class="literal">ko.components.defaultLoader</code>. When a component binding requests a component, or you call <code class="literal">ko.components.get</code>, Knockout loops through the loaders, calling <code class="literal">getConfig</code> on each component until it gets a non-null object. This configuration is then passed to each loader until a valid component object is returned. The loaded component is then cached. A valid component object has the following properties:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">template</code>: This is <a id="id342" class="calibre1"/>an array of DOM nodes</li><li class="listitem"><code class="literal">createViewModel(params, componentInfo)</code>: This is <a id="id343" class="calibre1"/>an optional factory method to build components</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_9"><a id="ch04lvl2sec69" class="calibre1"/>Implementing a component loader</h2></div></div></div><p class="calibre8">All of the methods are optional on<a id="id344" class="calibre1"/> a component loader, as Knockout will run through each method on each loader until it gets a valid response before repeating it on the next method. All component loader functions are asynchronous by supplying a callback. Remember, the result will be cached unless manually cleared with <code class="literal">ko.components.clearCachedDefinition(componentName)</code>. The following are the methods used to implement a component loader:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">getConfig(name, callback)</code>: This <a id="id345" class="calibre1"/>returns a component configuration object. A configuration object is <a id="id346" class="calibre1"/>anything that any loader's <code class="literal">loadComponent</code> function can understand.</li><li class="listitem"><code class="literal">loadComponent(name, componentConfig, callback)</code>: This<a id="id347" class="calibre1"/> supplies a component object of the <code class="literal">{ template: domNodeArray, createViewModel(params, componentInfo) }</code> type.</li><li class="listitem"><code class="literal">loadTemplate(name, templateConfig, callback)</code>: This <a id="id348" class="calibre1"/>supplies an array of DOM nodes to be used as the template.</li><li class="listitem"><code class="literal">loadViewModel(name, viewModelConfig, callback)</code>: This<a id="id349" class="calibre1"/> supplies a function to be used as the <code class="literal">createViewModel(params, componentInfo)</code> factory.</li></ul></div><p class="calibre8">To implement a method, just include it in your loader. To have your loader skip a method that it has implemented, call <code class="literal">callback(null)</code>.</p><p class="calibre8">The last two methods are not directly called by the Knockout component system but by the default loader's <code class="literal">loadComponent</code> method.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_10"><a id="ch04lvl2sec70" class="calibre1"/>The default loader</h2></div></div></div><p class="calibre8">To understand how the<a id="id350" class="calibre1"/> methods on a custom loader can be made optional, you must understand how the default loader works. The default loader has an internal registry for component configurations—not to be confused with the cache for components. The default loader adds the following methods to the <code class="literal">ko.components</code> object in order to work with the component configuration registry:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">ko.components.register(name, configuration)</code>: This is<a id="id351" class="calibre1"/> covered in the previous section in detail</li><li class="listitem"><code class="literal">ko.components.isRegistered(name)</code>: This <a id="id352" class="calibre1"/>returns <code class="literal">true</code> if the component configuration is in the registry; otherwise, it returns <code class="literal">false</code></li><li class="listitem"><code class="literal">ko.unregister(name)</code>: This <a id="id353" class="calibre1"/>removes the named configuration if it exists</li></ul></div><p class="calibre8">When Knockout tries to load a component for the first time, it calls <code class="literal">getConfig</code> on each loader in <code class="literal">ko.components.loaders</code> until one returns a non-null object. Then, it passes that configuration object to <code class="literal">loadComponent</code> on each loader until one returns a non-null component object. If a loader other than the default loader returns a component from <code class="literal">loadComponent</code>, the chain ends there.</p><p class="calibre8">However, the <a id="id354" class="calibre1"/>default loader's <code class="literal">loadComponent</code> method calls <code class="literal">loadTemplate</code> and <code class="literal">loadViewModel</code> on each loader (including itself) until it gets both a template and a viewmodel. These calls are independent; the default loader will take the first template it gets and the first viewmodel it gets even if they are from different loaders. If your custom loader has a higher priority than the default loader, or if the default loader can't understand your configuration, your custom loader will have a chance to supply its own template and/or viewmodel by implementing <code class="literal">loadTemplate</code> or <code class="literal">loadViewModel</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_11"><a id="ch04lvl2sec71" class="calibre1"/>Registering a custom loader</h2></div></div></div><p class="calibre8">Unlike <code class="literal">ko.bindingHandlers</code> and <code class="literal">ko.extenders</code>, which are both objects, <code class="literal">ko.components.loaders</code> is an array. Once<a id="id355" class="calibre1"/> you have created your custom loader, you can add it to the <code class="literal">loaders</code> array. The order of the <code class="literal">loaders</code> array determines the priority; Knockout always loops through the loaders from the first to the last:</p><div><ul class="itemizedlist"><li class="listitem">For a lower priority custom loader, use <code class="literal">ko.components.loaders.push(loader)</code></li><li class="listitem">For a higher priority custom loader, use <code class="literal">ko.components.loaders.unshift(loader)</code></li><li class="listitem">For a fine-grained control custom loader, use <code class="literal">ko.components.loaders.splice(priority, 0, loader)</code>, where priority is the 0-index rank of the new loader</li></ul></div><p class="calibre8">If you remove the default loader from <code class="literal">ko.component.loaders</code>, then <code class="literal">loadTemplate</code> and <code class="literal">loadViewModel</code> will no longer be called (unless they are called by another custom loader). As it is possible to simply add a custom loader with a higher priority, there is little value in removing the default loader.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_12"><a id="ch04lvl2sec72" class="calibre1"/>Registering custom elements</h2></div></div></div><p class="calibre8">Custom elements <a id="id356" class="calibre1"/>work in Knockout by wrapping the component binding. There are two options that can be used to get Knockout to treat a custom element as a component:</p><div><ul class="itemizedlist"><li class="listitem">Call <code class="literal">ko.components.register('component-name', { /* config */ }</code>.</li><li class="listitem">Override <code class="literal">ko.components.getComponentNameForNode(node)</code> so that it returns the name of a component. Components do not need to be registered as long as a loader that can load the name returned by this method exists. The default loader will only load components registered with <code class="literal">ko.components.register</code>.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_13"><a id="ch04lvl2sec73" class="calibre1"/>Loading components with custom configurations</h2></div></div></div><p class="calibre8">Alright, it's time to <a id="id357" class="calibre1"/>look at an example. This one is<a id="id358" class="calibre1"/> taken from the Knockout component's documentation. Let's say you are using our own asynchronous loading library for the HTML, and you want your custom loader to use it. This could be true for a JavaScript loader, which the documentation provides as an example, but it would be similar enough to be redundant here. It will use its own configuration property name in order to avoid confusion with the default loader:</p><div><pre class="programlisting">ko.components.register('contact-list', {
  template: { fromUrl: 'contact-list.html', maxCacheAge: 100 },
  viewModel: { require: 'contact-list'  }
});</pre></div><p class="calibre8">As the default loader will pass this configuration to the <code class="literal">loadTemplate</code> method of each loader, we can just implement that one method:</p><div><pre class="programlisting">var templateFromUrlLoader = {
  loadTemplate: function(name, templateConfig, callback) {
    if (templateConfig.fromUrl) {
      // Uses jQuery's ajax facility to load the markup from a file
      var fullUrl = '/app/' + templateConfig.fromUrl + '?cacheAge=' + templateConfig.maxCacheAge;
      $.get(fullUrl, function(markupString) {
        callback($.parseHTML(markupString));
      });
    } else {
      // Unrecognized config format. Let another loader handle it.
      callback(null);
   }
  }
};</pre></div><p class="calibre8">This loader will use jQuery to retrieve and parse the template if it has the <code class="literal">fromUrl</code> property; otherwise, it will do nothing. The only thing that's left is to add the loader to Knockout:</p><div><pre class="programlisting">ko.components.loaders.unshift(templateFromUrlLoader);</pre></div><p class="calibre8">You can see this custom loader in the <code class="literal">cp4-loader</code> branch; it is in the <code class="literal">main.js</code> file.</p><p class="calibre8">Knockout's default component loader is already flexible, but the ability to provide your own custom loader for both configuration and instantiation gives the Knockout component system the ability to work with whichever format you want to create.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Single Page Application (SPA) routing</h1></div></div></div><p class="calibre8">A big part of the appeal of <a id="id359" class="calibre1"/>Knockout (or any MV* framework) is that its template engine allows us to rerender parts of the page without the need to talk to the server. Being able to make incremental page updates on the client side means less latency, giving the application a much snappier feel. SPAs take this concept to the next level by letting the JavaScript client control navigation between pages. When the browser navigates, it has to rerender the whole page, which means reloading the JavaScript, HTML, CSS, and everything. When JavaScript <em class="calibre12">navigates</em>, it just has to change part of the HTML, which ends up being much faster in most cases.</p><p class="calibre8">Knockout can provide this virtual page-changing functionality relatively easily, but an important component of SPAs is that page changes still update the URL. This helps the user check whether a change has occurred, but more importantly, it means that if the user refreshes the page or shares the link, the application will go to the right page. Without the URL update, the user will always end up on the home screen. This feature is commonly known as <a id="id360" class="calibre1"/>
<strong class="calibre9">routing</strong>. Knockout does not provide this mechanism.</p><p class="calibre8">To explore how Knockout fits into an SPA scenario, we are going to use SammyJS<a id="id361" class="calibre1"/> (<a class="calibre1" href="http://sammyjs.org/">http://sammyjs.org/</a>). SammyJS is a popular library used for routing; Knockout even uses it on its tutorial site. There are many other options, of course, but the concept should be very similar regardless of which library you use.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec74" class="calibre1"/>An overview of SammyJS</h2></div></div></div><p class="calibre8">SammyJS's default <a id="id362" class="calibre1"/>routing uses hash-change navigation, which uses the URL hash to store the current state. As the hash is not sent to the server by the browser, the server always sees the URL as a request for the home page. Once the page loads, Sammy will inspect the hash and locate the matching route, if one exists. If it finds a route, it runs the callback for that route. The callback is responsible for performing whatever application logic is necessary for navigation. The following code demonstrates this:</p><div><pre class="programlisting">var app = Sammy('#appHost', function() {
  //Home route
   this.get('#/', function() {
    //Load home page
  });
  this.get('#/contacts/:id', function() {
    var contactId = this.params.id;
    //Load contact
  });
}).run('#/');</pre></div><p class="calibre8">This is a typical <a id="id363" class="calibre1"/>Sammy application configuration. The <code class="literal">Sammy</code> object is a function that takes an element's ID, which it will scope the handler to, and an initialization handler and returns the application object. Inside the initialization handler, this has methods for each HTTP verb that registers routes. The preceding sample registers a route for <code class="literal">#/</code> (a standard <em class="calibre12">home</em> route) and a route for <code class="literal">#/contacts/:id</code>. The <code class="literal">:id</code> part of the route indicates a parameter that will match any contents and provide the value on the <code class="literal">params</code> object inside the route's callback.</p><p class="calibre8">The application object that is returned from <code class="literal">Sammy()</code> will not start until <code class="literal">run()</code> is called, which should wait for the DOM to be ready. The <code class="literal">run()</code> method takes a default route, which will be loaded if no hash is present (such as when navigating to the bare domain URL).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec75" class="calibre1"/>Controlling the navigation</h2></div></div></div><p class="calibre8">SammyJS <a id="id364" class="calibre1"/>monitors the <code class="literal">window.location.hash</code> property for any changes and runs the matching route handler. This can happen when a user clicks on an a tag with an <code class="literal">href</code> attribute containing a hash or by setting <code class="literal">window.location.hash</code> from JavaScript. Using the window object inside viewmodels is generally discouraged, as it is difficult to mock in unit tests. It would also be nice to keep the navigation logic centralized, just in case it needs to be changed later. To do this, we will encapsulate the navigation into a router module. For now, it only needs a single method:</p><div><pre class="programlisting">define(function() {
  return {
    navigate: function(path) {
      window.location.hash = '#' + path;
    }
  };
});</pre></div><p class="calibre8">Once injected with RequireJS, viewmodels can be navigated by calling <code class="literal">router.navigate</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec76" class="calibre1"/>Creating page components</h2></div></div></div><p class="calibre8">There are a lot of different <a id="id365" class="calibre1"/>ways to <a id="id366" class="calibre1"/>organize Knockout viewmodels in SPAs and web apps in general. As we just learned how to create components, we are going to look at a method used to structure each page as a component. This gives us a few solid advantages:</p><div><ul class="itemizedlist"><li class="listitem">The pages will be decoupled from each other</li><li class="listitem">Each page will have its own HTML and JavaScript file, which feels natural</li><li class="listitem">A single component binding on the shell can hold the <em class="calibre12">body</em> of the page while maintaining a static layout for the navigation bar</li></ul></div><p class="calibre8">At some point, we will need to introduce a folder structure that will keep these files organized, so we might as well start now.</p><div><img src="img/00008.jpeg" alt="Creating page components" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The home page (which was just a greeting) has been removed, but the placeholder settings page is still there so that we have at least two links to test navigation with. The router and mock data service have been moved into the <code class="literal">core</code> folder (a name I prefer because it's shorter than <code class="literal">common</code>). The rest of the code, which consists of the contact model and the two pages, has been moved into the <code class="literal">contacts</code> folder. The <code class="literal">main.js</code> starting file hasn't moved.</p><p class="calibre8">You can, of course, group files whichever way you want; nothing we have covered so far will require any specific file structure.</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec27" class="calibre1"/>The edit page</h3></div></div></div><p class="calibre8">Previously, both pages were <a id="id367" class="calibre1"/>managed by a single viewmodel that switched between them using a null <em class="calibre12">editing</em> contact. However, it was clear that this combined viewmodel was serving multiple roles. Splitting the editing code should reduce some confusion:</p><div><pre class="programlisting">define(['knockout', 'text!contacts/edit.html', 'core/dataService', 'core/router', 'contacts/contact'], 
function(ko, templateString, dataService, router, Contact) {

  function ContactEditViewmodel(params) {
    self.entryContact = ko.observable(new Contact());
    if (params &amp;&amp; params.id) {
      dataService.getContact(params.id, function(contact) {
        if (contact)
        self.entryContact(contact);
      });
    }

    self.cancelEntry = function() {
      router.navigate('/');
    };
    self.saveEntry = function() {

      var action = self.entryContact().id() === 0 
      ? dataService.createContact 
      : dataService.updateContact;

      action(self.entryContact(), function() {
        router.navigate('/');
      });
    };
    self.dispose = function() {
      self.entryContact(null);
    };
  }

  return { 
    template: templateString, 
    viewModel: ContactEditViewmodel 
  };
});</pre></div><p class="calibre8">There are only<a id="id368" class="calibre1"/> three real changes here:</p><div><ul class="itemizedlist"><li class="listitem">First, instead of clearing the <code class="literal">entryContact</code> object to indicate that editing is finished, the viewmodel calls <code class="literal">router.navigate('/')</code>. As we don't have a home page anymore, the list page will be used as the default page, which will be tied to the <code class="literal">/</code> route.</li><li class="listitem">Secondly, as editing will occur based on navigation instead of the <code class="literal">entryContact</code> object being set directly, the viewmodel uses the <code class="literal">params</code> component to look for an ID. If an ID isn't present, it is assumed that we are creating a new contact; if an ID is present, the contact is loaded from the data service.</li><li class="listitem">Finally, a <code class="literal">dispose</code> method has been added, which will clear the <code class="literal">entryContact</code> object. This isn't actually necessary, but it demonstrates how the clean up will be done.</li></ul></div><p class="calibre8">The HTML code hasn't really changed, except that it will be in its own file now.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec28" class="calibre1"/>The list page</h3></div></div></div><p class="calibre8">The list page will be the new <a id="id369" class="calibre1"/>home page. Like the edit page, it will need to use the router to navigate to the edit page instead of using the <code class="literal">entryContact</code> object. The list page doesn't need any parameters:</p><div><pre class="programlisting">define(['knockout', 'text!contacts/list.html', 'core/dataService', 'core/router'], 
function(ko, templateString, dataService, router) {

  function ContactsListViewmodel() {
    var self = this;

    self.contacts = ko.observableArray();

    dataService.getContacts(function(contacts) {
      self.contacts(contacts);
    });
    self.newEntry = function() { router.navigate('/contacts/new'); };
    self.editContact = function(contact) { router.navigate('/contacts/' + contact.id()); };

    self.deleteContact = function(contact) {
      dataService.removeContact(contact.id(), function() {
        self.contacts.remove(contact);
       });
    };

    self.query = ko.observable('');
    self.clearQuery = function() { self.query(''); };

    self.displayContacts = ko.computed(function() {
      //Same as before
    });

    self.dispose = function() {
      self.contacts.removeAll();
    };
  }

  return { 
    template: templateString, 
    viewModel: ContactsListViewmodel 
  };
});</pre></div><p class="calibre8">Here too, the HTML code hasn't <a id="id370" class="calibre1"/>changed much, except that the <code class="literal">contact-list</code> component has been removed, so its view has been re-added to the list page.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec77" class="calibre1"/>Coordinating pages</h2></div></div></div><p class="calibre8">So far, the example server has been <a id="id371" class="calibre1"/>responsible for putting each page into our shell/layout HTML by performing a string replace. To get the experience of a real SPA, we are going to change the server to return an index file without performing any parsing or rendering on it:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    //Same as before
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- Navbar --&gt;
    &lt;nav class="navbar navbar-default" role="navigation"&gt;
      //Same as before
    &lt;/nav&gt;

    &lt;!-- Main Application Body --&gt;
    &lt;div id="appHost" class="container" data-bind="if: name"&gt;
      &lt;!-- ko component: { name: name, params: data } --&gt;&lt;!-- /ko --&gt;
    &lt;/div&gt;
    &lt;script type="text/javascript" src="img/require-2.1.js" data-main="/app/main"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">The <code class="literal">appHost</code> element in the <a id="id372" class="calibre1"/>preceding code contains a containerless component binding that uses an observable <code class="literal">name</code> and <code class="literal">params</code> value. It's wrapped in an <code class="literal">if</code> binding that ensures that the component binding isn't active until a page has been selected. All the root viewmodel has to do is supply the <code class="literal">name</code> and <code class="literal">params</code> properties.</p><p class="calibre8">For this, our <code class="literal">main.js</code> will contain a simple viewmodel that contains each property. The SammyJS route handlers will set this viewmodel when the routes are activated. The <code class="literal">main.js</code> file will also be responsible for registering the page components with Knockout. It's long, so we are going to break it up into chunks:</p><div><pre class="programlisting">define(['jquery', 'knockout', 'sammy', 'bootstrap'], function($, ko, Sammy) {
  var pageVm = {
    name: ko.observable(),
    data: ko.observable(),
    setRoute: function(name, data) {
      //Set data first, otherwise component will get old data
      this.data(data);
      this.name(name);
    }
  };

  //Sammy Setup
  Var sammyConfig = /* see below */

  $(document).ready(function() {
    sammyConfig.run('#/');
    ko.applyBindings(pageVm);
  });
});</pre></div><p class="calibre8">SammyJS has been added as a dependency and injected in. The RequireJS configuration isn't shown, but it doesn't require a shim. SammyJS plays nicely as an AMD. The <code class="literal">pageVm</code> object is created with two observable properties and a helper method for setting them. The order is important because component viewmodels are instantiated synchronously, and the data bound to the <code class="literal">params</code> object needs to already be in place when the component name changes; otherwise, the component will initialize before the <code class="literal">params</code> objects are set.</p><p class="calibre8">After SammyJS has been set up, the document-ready handler starts it using a default route and then applies bindings with the <code class="literal">pageVm</code> object.</p><p class="calibre8">One way to perform the SammyJS configuration would be to write out each component register and route handler, as follows:</p><div><pre class="programlisting">ko.components.register('contact-edit', { require: 'contacts/edit' });
self.get('#/contacts/:id', function() {
  pageVm.setRoute('contact-edit', { id: this.params.id });
});</pre></div><p class="calibre8">Personally, I think this ends up being a bit messy. It also duplicates the component name in <code class="literal">register</code> and <code class="literal">setRoute</code>. SammyJS also doesn't allow you to bind multiple routes to the same handler in a single call; you have to write both of them out. This is especially annoying for the home page, because SammyJS treats an empty route and the <code class="literal">#/</code> route as different routes, even though they both conventionally mean <em class="calibre12">home</em>. To solve these, we can combine the <a id="id373" class="calibre1"/>component and route definitions into a page object, and then loop over them:</p><div><pre class="programlisting">var sammyConfig = Sammy('#appHost', function() {
  var self = this;
  var pages = [
    { route: ['/', '#/'], component: 'contact-list', 	module: 'contacts/list'}, { route: ['#/contacts/new', '#/contacts/:id'], component: 'contact-edit', 	module: 'contacts/edit' }, { route: '#/settings', component: 'settings-page', module: 'settings/page' }
  ];

  pages.forEach(function(page) {
    //Register the component, only needs to happen
    ko.components.register(page.component, { require: page.module });

    //Force routes to be an array
    if (!(page.route instanceof Array))
    page.route = [page.route];

    //Register routes with Sammy
    page.route.forEach(function(route) {
      self.get(route, function() {

        //Collect the parameters, if present
        var params = {};
        ko.utils.objectForEach(this.params, function(name, value) {
          params[name] = value;
        });

        //Set the page
        pageVm.setRoute(page.component, params);
      });
    });
  });
});</pre></div><p class="calibre8">Much better. Now, it's<a id="id374" class="calibre1"/> easy to see how the routes and components are related, and defining multiple routes for a single component is simple. It also removes the duplicated component name.</p><p class="calibre8">The <code class="literal">instanceof</code> check lets us use an array or a string for the <code class="literal">page.route</code> property by always making it an array. The <code class="literal">params</code> section will include any parameters captured by the route handler and will pass them as the data used by the component binding for the <code class="literal">params</code> object.</p><p class="calibre8">All the code we just covered can be seen in the <code class="literal">cp4-spa</code> branch. Be sure to use each page on the app, and notice the URL change. If you go to a page, such as a specific contact, and refresh the browser, SammyJS will make sure that the correct page is loaded instead of always going to the home page. This gives the application a very natural feel. You should also notice that moving between pages happens with little or no delay (depending on your CPU). For comparison, try to view changes between the <code class="literal">/contacts</code> and <code class="literal">/settings</code> pages in the <code class="literal">cp4-contacts</code> branch. The SPA navigation is much faster.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">By now, you should have a good idea or two about how to structure a Knockout web application, specifically, a single page application. The Knockout components feature gives you a powerful tool that will help you create reusable, behavior-driven DOM elements, and writing custom loaders allows you to fully control how components are used. The RequireJS AMD patterns make application organization easy by splitting up JavaScript and HTML into independent modules. Because these modules use dependency injection, creating mocks for unit testing is also possible. Finally, you saw how SammyJS can create fast client-side JavaScript navigation with pages controlled by components.</p><p class="calibre8">In the next chapter, we will look at the Durandal framework, which will make the single page application development even easier.</p></div></body></html>