- en: Chapter 3. Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mastering functions is an important skill when you learn any programming language,
    and even more so when it comes to JavaScript. This is because JavaScript has many
    uses for functions, and much of the language''s flexibility and expressiveness
    comes from them. Where most programming languages have a special syntax for some
    object-oriented features, JavaScript just uses functions. This chapter will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to define and use a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predefined functions that are available to you for free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of variables in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept that functions are just data, albeit a special type of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding these topics will provide a solid base that will allow you to
    dive into the second part of the chapter, which shows some interesting applications
    of functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediate (self-invoking) functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inner functions (functions defined inside other functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that return functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that redefine themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a function?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions allow you to group together a code, give it a name, and reuse it
    later, addressing it by the name you gave it. Let''s consider the following code
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The parts that make up a function are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `function` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the function; in this case, `sum`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function parameters; in this case, `a` and `b`. A function can take any
    number of parameters, or no parameters, separated by commas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code block, also called the body of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` statement. A function always returns a value. If it doesn't return
    a value explicitly, it implicitly returns the value `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that a function can only return a single value. If you need to return more
    values, you can simply return an array that contains all of the values you need
    as elements of this array.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding syntax is called a function declaration. It's just one of the
    ways to create a function in JavaScript, and more ways are coming up.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to make use of a function, you will need to call it. You can call a
    function simply using its name, optionally, followed by any number of values in
    parentheses. To invoke a function is another way of saying to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call the `sum()`function, passing two arguments and assigning the value
    that the function returns to the variable `result`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When defining a function, you can specify what parameters the function expects
    to receive when it''s called. A function may not require any parameters, but if
    it does, and you forget to pass them, JavaScript will assign the `undefined` value
    to the ones you skipped. In the next example, the function call returns `NaN`
    because it tries to sum `1` and `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically speaking, there is a difference between parameters and arguments,
    although the two are often used interchangeably. Parameters are defined together
    with the function, while arguments are passed to the function when it''s called.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `a` and `b` are parameters, while `1` and `2` are arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is not picky at all when it comes to accepting arguments. If you
    pass more than the function expects, the extra ones will be silently ignored,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s more, you can create functions that are flexible about the number of
    parameters they accept. This is possible thanks to the special value `arguments`
    that are created automatically inside each function. Here''s a function that simply
    returns whatever arguments are passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `arguments`, you can improve the `sum()` function to accept any number
    of arguments and add them all up, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you test this function by calling it with a different number of arguments,
    or even none at all, you can verify that it works as expected, as you can see
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `arguments.length` expression returns the number of arguments passed when
    the function was called. Don't worry if the syntax is unfamiliar, we'll examine
    it in detail in the next chapter. You'll also see that `arguments` is not an array
    (although it sure looks like one), but an array-like object.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 introduces several important improvements around function parameters. ES6
    function parameters can now have default values, rest parameters, and allows destructuring.
    The next section discusses each of these concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function parameters can be assigned default values. While calling the function,
    if a parameter is omitted, the default value assigned to the parameter is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are omitting the `spark_level` parameter, and hence the
    default value assigned to the parameter is used. It is important to note that
    `undefined` is considered as an absence of parameter value; consider the following
    line of code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While providing default values of parameters, it is possible to refer to other
    parameters as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Default parameters have their own scope; this scope is sandwiched between the
    outer function scope and the inner scope of the function. If the parameter is
    shadowed by a variable in inner scope, surprisingly, the inner variable is not
    available. The following example will help explain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You may expect `val` to get shadowed by the inner definition of the `scope`
    variable, but as the default parameters have their own scope, the value assigned
    to `val` is unaffected by the inner scope.
  prefs: []
  type: TYPE_NORMAL
- en: Rest parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 introduces rest parameters. Rest parameters allow us to send an arbitrary
    number of parameters to a function in the form of an array. Rest parameter can
    only be the last one in the list of parameters, and there can only be one rest
    parameter. Putting a rest operator(`...`) before the last formal parameter indicates
    that parameter is a rest parameter. The following example shows adding a rest
    operator before the last formal parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter passed to the function is received in `tone`, while the
    rest of the parameters are received as an array. Variable arguments (var-args)
    have been part of several other languages and a welcome edition to ES6\. Rest
    parameters can replace the slightly controversial `arguments` variable. The major
    difference between rest parameters and the `arguments` variable is that the rest
    parameters are real arrays. All array methods are available to rest parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Spread operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A spread operator looks exactly like a rest operator but performs the exact
    opposite function. Spread operators are used while providing arguments while calling
    a function or defining an array. The spread operator takes an array and splits
    its element into individual variables. The following example illustrates how the
    spread operator provides a much clearer syntax while calling functions that take
    an array as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In ES5, it is common to use the `apply()` function when passing an array as
    an argument to a function. In the preceding example, we have an array we need
    to pass to a function where the function accepts three variables. The ES5 method
    of passing an array to this function uses the `apply()` function, where the second
    argument allows an array to be passed to the function being called. ES6 spread
    operators give a much cleaner and precise way to deal with this situation. While
    calling `sumAll()`, we use the spread operator(`...`) and pass the `numbers` array
    to the function call. The array is then split into individual variables-`a`, `b`,
    and `c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spread operators improve the capabilities of arrays in JavaScript. If you want
    to create an array that is made up of another array, the existing array syntax
    does not support this. You have to use `push`, `splice`, and `concat` to achieve
    this. However, using spread operators, this becomes trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are constructing a `week` array using two arrays,
    `midweek` and `weekend`, using the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of functions that are built into the JavaScript engine and
    are available for you to use. Let''s take a look at them. While doing so, you''ll
    have a chance to experiment with functions, their arguments and return values,
    and become comfortable working with functions. The following is a list of the
    built-in functions:'
  prefs: []
  type: TYPE_NORMAL
- en: parseInt()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: parseFloat()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: isNaN()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: isFinite()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: encodeURI()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: decodeURI()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: encodeURIComponent()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: decodeURIComponent()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: eval()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The black box function**'
  prefs: []
  type: TYPE_NORMAL
- en: Often, when you invoke functions, your program doesn't need to know how these
    functions work internally. You can think of a function as a black box, give it
    some values (as input arguments), and then take the output result it returns.
    This is true for any function-one that's built into the JavaScript engine, one
    that you create, or one that a co-worker or someone else created.
  prefs: []
  type: TYPE_NORMAL
- en: parseInt()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `parseInt()` function takes any type of input (most often a string) and
    tries to make an integer out of it. If it fails, it returns `NaN`, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The function accepts an optional second parameter, which is the radix, telling
    the function what type of number to expect-decimal, hexadecimal, binary, and so
    on. For example, trying to extract a decimal number out of the `FF` string makes
    no sense, so the result is `NaN`, but if you try `FF` as a hexadecimal, then you
    get `255`, as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example would be parsing a string with a base `10` (decimal) and base
    `8` (octal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the second argument when calling `parseInt()`, the function will
    assume `10` (a decimal), with the following exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: If you pass a string beginning with `0x`, then the radix is assumed to be `16`
    (a hexadecimal number is assumed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the string you pass starts with `0`, the function assumes radix `8` (an
    octal number is assumed). Consider the following examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The safest thing to do is to always specify the radix. If you omit the radix,
    your code will probably still work in 99 percent of cases (because most often
    you parse decimals); however, every once in a while, it might cause you a bit
    of hair loss while debugging some edge cases. For example, imagine you have a
    form field that accepts calendar days or months and the user types `06` or `08`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ECMAScript 5 removes the octal literal values and avoids the confusion with
    `parseInt()` and unspecified radix.
  prefs: []
  type: TYPE_NORMAL
- en: parseFloat()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `parseFloat()` function is similar to the `parseInt()` function, but it
    also looks for decimals when trying to figure out a number from your input. This
    function takes only one parameter, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `parseInt()`, `parseFloat()` gives up at the first occurrence of an
    unexpected character, even though the rest of the string might have usable numbers
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseFloat()` function understands exponents in the input (unlike `parseInt()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: isNaN()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `isNaN()`, you can check if an input value is a valid number that can
    safely be used in arithmetic operations. This function is also a convenient way
    to check whether `parseInt()`, `parseFloat()`, or any arithmetic operation succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The function will also try to convert the input to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `isNaN()` function is useful because the special value `NaN` is not equal
    to anything, including itself. In other words, `NaN === NaN` is `false`. So, `NaN`
    cannot be used to check if a value is a valid number.
  prefs: []
  type: TYPE_NORMAL
- en: isFinite()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `isFinite()` function checks whether the input is a number that is neither
    `Infinity` nor `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering about the results returned by the last two calls, remember
    from the previous chapter that the biggest number in JavaScript is `1.7976931348623157e+308`,
    so `1e309` is effectively infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Encode/decode URIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a **Uniform Resource Locator** (**URL**) or a **Uniform Resource Identifier**
    (**URI**), some characters have special meanings. If you want to escape those
    characters, you can use the `encodeURI()` or `encodeURIComponent()`functions.
    The first one will return a usable URL, while the second one assumes you''re only
    passing a part of the URL, such as a query string for example, and will encode
    all applicable characters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The opposites of `encodeURI()` and `encodeURIComponent()` are `decodeURI()`
    and `decodeURIComponent()`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, in legacy code, you might see the functions `escape()` and `unescape()`
    used to encode and decode URLs, but these functions have been deprecated; they
    encode differently and should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: eval()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `eval()` function takes a string input and executes it as a JavaScript
    code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So, `eval('var ii = 2;')` is the same as `var ii = 2;`
  prefs: []
  type: TYPE_NORMAL
- en: 'The `eval()` function can be useful sometimes, but it should be avoided if
    there are other options. Most of the time, there are alternatives, and in most
    cases, the alternatives are more elegant and easier to write and maintain. *Eval
    is evil* is a mantra you can often hear from seasoned JavaScript programmers.
    The drawbacks of using `eval()` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: JavaScript is powerful, which also means it can cause damage.
    If you don''t trust the source of the input you pass to `eval()`, just don''t
    use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: It''s slower to evaluate live code than to have the code directly
    in the script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bonus - the alert() function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's take a look at another common function-`alert()`. It's not part of the
    core JavaScript (it's nowhere to be found in the ECMA specification), but it's
    provided by the host environment-the browser. It shows a string of text in a message
    box. It can also be used as a primitive debugging tool, although the debuggers
    in modern browsers are much better suited for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot showing the result of executing the `alert("Hi There")`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A bonus - the alert() function](img/alert-e1483529706612.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before using this function, bear in mind that it blocks the browser thread,
    meaning that no other code will be executed until the user closes the alert. If
    you have a busy Ajax-type application, it's generally not a good idea to use `alert()`.
  prefs: []
  type: TYPE_NORMAL
- en: Scope of variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to note, especially if you have come to JavaScript from another
    language, that variables in JavaScript are not defined in a block scope, but in
    a function scope. This means that if a variable is defined inside a function,
    it's not visible outside of the function. However, if it's defined inside an `if`
    or a `for` code block, it's visible outside the block. The term global variables
    describes variables you define outside of any function (in the global program
    code), as opposed to local variables, which are defined inside a function. The
    code inside a function has access to all global variables as well as to its own
    local ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: The `f()`function has access to the `global` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside the `f()`function, the `local` variable doesn't exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also important to note that if you don''t use `var` to declare a variable,
    this variable is automatically assigned a global scope. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scope of variables](img/image_03_001-e1482742379131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What happened? The `f()`function contains the `local` variable. Before calling
    the function, the variable doesn't exist. When you call the function for the first
    time, the `local` variable is created with a global scope. Then, if you access
    the `local` variable outside the function, it will be available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice tips**'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize the number of global variables in order to avoid naming collisions.
    Imagine two people working on two different functions in the same script, and
    they both decide to use the same name for their global variable. This could easily
    lead to unexpected results and hard-to-find bugs. Always declare your variables
    with the `var` statement. Consider a single `var` pattern. Define all variables
    needed in your function at the very top of the function so you have a single place
    to look for variables and, hopefully, prevent accidental globals.
  prefs: []
  type: TYPE_NORMAL
- en: Variable hoisting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an interesting example that shows an important aspect of local versus
    global scoping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You might expect that the first `alert()` function will display `123` (the value
    of the global variable `a`) and the second will display `1` (the local variable
    `a`). But, this is not the case. The first alert will show `undefined`. This is
    because, inside the function, the local scope is more important than the global
    scope. So, a local variable overwrites any global variable with the same name.
    At the time of the first `alert()`, the `a` variable was not yet defined (hence
    the `undefined` value), but it still existed in the local space due to the special
    behavior called **hoisting**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your JavaScript program execution enters a new function, all the variables
    declared anywhere in the function are moved, elevated, or hoisted to the top of
    the function. This is an important concept to keep in mind. Further, only the
    declaration is hoisted, meaning only the presence of the variable is moved to
    the top. Any assignments stay where they are. In the preceding example, the declaration
    of the local variable `a` was hoisted to the top. Only the declaration was hoisted,
    but not the assignment to `1`. It''s as if the function was written in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can also adopt the single var pattern mentioned previously in the best practice
    section. In this case, you'll be doing a sort of manual variable hoisting to prevent
    confusion with the JavaScript hoisting behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Block scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 provides additional scope while declaring variables. We looked at function
    scope and how it affects variables declared with the `var` keyword. If you are
    coding in ES6, block scope will mostly replace your need to use variables declared
    using `var`. Although, if you are still with ES5, we want you to make sure that
    you look at hoisting behavior carefully.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 introduces the `let` and `const` keywords that allow us to declare variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables declared with `let` are block-scoped. They exist only within the
    current block. Variables declared with `var` are function scoped, as we saw earlier.
    The following example illustrates the block scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The scope between an opening brace`''{''` and a closing brace `''}''` is a
    block. If you are coming from a background in Java or C/C++, the concept of a
    block scope will be very familiar to you. In those languages, programmers introduced
    blocks just to define a scope. In JavaScript, however, there was a need to idiomatically
    introduce blocks as they didn''t have a scope associated to it. However, ES6 allows
    you to create block-scoped variables using the `let` keyword. As you can see in
    the preceding example, variable `a` created inside the block is available within
    the block. While declaring block-scoped variables, it is generally recommended
    to add the `let` declaration at the top of the block. Let''s look at another example
    to clearly distinguish function and block scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `tmp` is declared with `let` and is available only in the block
    in which it was defined. For all practical purposes, you should maximize your
    use of block-scoped variables. Unless there is something very specific you are
    trying to do that makes it necessary for you to use `var` declarations, make sure
    you prefer block scoped variables. However, incorrectly using the `let` keyword
    can cause a couple of problems. First, you cannot redeclare the same variable
    within the same function or block scope using the `let` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In ES6, variables declared by the `let` keyword are hoisted to block scope.
    However, referencing the variable before its declaration is an error.
  prefs: []
  type: TYPE_NORMAL
- en: Another keyword introduced in ES6 is `const`. A variable declared with the `const`
    keyword creates a read-only reference to a value. This does not mean that the
    value held by the reference is immutable. However, the variable identifier cannot
    be reassigned. Constants are block-scoped just like variables created using the
    `let` keyword. Also, you have to assign a value to the variable while declaring
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it sounds like it does, `const` has nothing to do with immutable values.
    Constants create immutable binding. This is an important distinction and needs
    to be understood correctly. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a valid code; here we are assigning value `{}` to a constant `car`.
    Once assigned, this reference cannot be changed. In ES6, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `const` where possible. Use them for all variables whose values don''t
    change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Avoid `var`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions in JavaScript are actually data. This is an important concept that
    we''ll need later on. This means that you can create a function and assign it
    to a variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This way of defining a function is sometimes referred to as **function literal
    notation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `function () { return 1;}` part is a **function expression**. A function
    expression can optionally have a name, in which case it becomes a **named function
    expression** (**NFE**). So, this is also allowed, although rarely seen in practice
    (and causes IE to mistakenly create two variables in the enclosing scope-`f` and
    `myFunc`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there's no difference between a named function expression and
    a function declaration. But they are, in fact, different. The only way to distinguish
    between the two is to look at the context in which they are used. Function declarations
    may only appear in program code (in a body of another function or in the main
    program). You'll see many more examples of functions later on in the book that
    will clarify these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use the `typeof` operator on a variable that holds a function value,
    it returns the string `"function"` as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, JavaScript functions are data, but a special kind of data with the following
    two important features:'
  prefs: []
  type: TYPE_NORMAL
- en: They contain code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are executable (they can be invoked)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you have seen before, the way to execute a function is by adding parentheses
    after its name. As the next example demonstrates, this works regardless of how
    the function was defined. In the example, you can also see how a function is treated
    as a regular value; it can be copied to a different variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As functions are data assigned to variables, the same rules for naming functions
    apply as for naming variables-a function name cannot start with a number and it
    can contain any combination of letters, numbers, the underscore character, and
    the dollar sign.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you now know, there exists a function expression syntax where you can have
    a function defined like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also often called an **anonymous function** (as it doesn''t have a
    name), especially when such a function expression is used even without assigning
    it to a variable. In this case, there can be two elegant uses for such anonymous
    functions, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can pass an anonymous function as a parameter to another function. The receiving
    function can do something useful with the function that you pass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define an anonymous function and execute it right away.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see these two applications of anonymous functions in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Callback functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a function is just like any other data assigned to a variable, it can be
    defined, copied, and also passed as an argument to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a function that accepts two functions as parameters,
    executes them, and returns the sum of what each of them returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define two simple additional functions using a function declaration
    pattern that only returns hardcoded values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can pass those functions to the original function, `invokeAdd()`, and
    get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of passing a function as a parameter is to use anonymous functions
    (function expressions). Instead of defining `one()` and `two()`, you can simply
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can make it more readable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When you pass a function, A, to another function, B, and then B executes A,
    it's often said that A is a **callback** function. If A doesn't have a name, then
    you can say that it's an anonymous callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When are callback functions useful? Let''s see some examples that demonstrate
    the benefits of callback functions, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: They let you pass functions without the need to name them, which means there
    are fewer variables floating around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can delegate the responsibility of calling a function to another function,
    which means there is less code to write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can help with performance by deferring the execution or by unblocking calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at this common scenario-you have a function that returns a value,
    which you then pass to another function. In our example, the first function, `multiplyByTwo()`,
    accepts three parameters, loops through them, multiplies them by two, and returns
    an array containing the result. The second function, `addOne()`, takes a value,
    adds one to it, and returns it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say you want to have an array, `myarr`, that contains three elements,
    and each of the elements is to be passed through both functions. First, let''s
    start with a call to `multiplyByTwo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, loop through each element, passing it to `addOne()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, everything works fine, but there''s room for improvement. For
    example, there were two loops. Loops can be expensive if they go through a lot
    of repetitions. You can achieve the same result with only one loop. Here''s how
    to modify `multiplyByTwo()` so that it accepts a callback function and invokes
    that callback on every iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the modified function, all the work is done with just one function call,
    which passes the start values and the `callback` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of defining `addOne()`, you can use an anonymous function, therefore
    saving an extra global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Anonymous functions are easy to change should the need arise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Immediate functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have discussed using anonymous functions as callbacks. Let''s see
    another application of an anonymous function-calling a function immediately after
    it''s defined. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax may look a little scary at first, but all you do is simply place
    a function expression inside parentheses followed by another set of parentheses.
    The second set says execute now and is also the place to put any arguments that
    your anonymous function might accept, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can move the closing of the first set of parentheses to
    the end. Both of these work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: One good application of immediate (self-invoking) anonymous functions is when
    you want to have some work done without creating extra global variables. A drawback,
    of course, is that you cannot execute the same function twice. This makes immediate
    functions best suited for one-off or initialization tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'An immediate function can also optionally return a value if you need one. It''s
    not uncommon to see code that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you don''t need to wrap the function expression in parentheses;
    you only need the parentheses that invoke the function. So, the following piece
    of code also works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This syntax works, but may look slightly confusing; without reading the end
    of the function, you don't know if `result` is a function or the return value
    of the immediate function.
  prefs: []
  type: TYPE_NORMAL
- en: Inner (private) functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bearing in mind that a function is just like any other value, there''s nothing
    that stops you from defining a function inside another function, here''s the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a function expression, this can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call the global `outer()`function, it will internally call the local
    `inner()`function. As `inner()` is local, it''s not accessible outside `outer()`,
    so you can say it''s a private function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefits of using private functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can keep the global namespace clean, which is less likely to cause naming
    collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privacy-you can expose only those functions to the outside world that you decide,
    and keep the functionality that is not meant to be consumed by the rest of the
    application to yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that return functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, a function always returns a value, and if it doesn''t
    do it explicitly with `return`, then it does so implicitly by returning `undefined`.
    A function can return only one value, and this value can just as easily be another
    function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `a()`function does its job (says `A!`) and returns another
    function that does something else (says `B!`). You can assign the return value
    to a variable and then use this variable as a normal function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first line will alert `A!` and the second will alert `B!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to execute the returned function immediately without assigning
    it to a new variable, you can simply use another set of parentheses. The end result
    will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Function, rewrite thyself!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a function can return a function, you can use the new function to replace
    the old one. Continuing with the previous example, you can take the value returned
    by the call to `a()` to overwrite the actual `a()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code alerts `A!`, but the next time you call `a()` it
    alerts `B!`. This is useful when a function has some initial one-off work to do.
    The function overwrites itself after the first call in order to avoid doing unnecessary
    repetitive work every time it's called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the function was redefined from the outside and the
    returned value was assigned back to the function. But, the function can actually
    rewrite itself from the inside, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call this function for the first time, it will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Alert `A!` (consider this as being the one-off preparatory work)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redefine the global variable `a` and assigning a new function to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every subsequent time that the function is called, it will alert `B!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another example that combines several of the techniques discussed in
    the last few sections of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'From this example, you can note the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: You have private functions; `someSetup()` and `actualWork()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have an immediate function: an anonymous function that calls itself using
    the parentheses following its definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function executes for the first time, calls `someSetup()`, and then returns
    a reference to the `actualWork` variable, which is a function. Notice that there
    are no parentheses in the `return` statement because you're returning a function
    reference, not the result of invoking this function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the whole thing starts with `var a =`, the value returned by the self-invoked
    function is assigned to `a`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to test your understanding of the topics just discussed, answer
    the following questions. What will the preceding code alert be in the following
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: It is initially loaded?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You call `a()` afterwards?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques could be really useful when working in the browser environment.
    Different browsers can have different ways of achieving the same result. If you
    know that the browser features won't change between function calls, you can have
    a function determine the best way to do the work in the current browser, then
    redefine itself so that the browser capability detection is done only once. You'll
    see concrete examples of this scenario later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rest of the chapter is about closures (what better way to close a chapter?).
    Closures can be a little hard to grasp initially, so don't feel discouraged if
    you don't get it during the first read. You should go through the rest of the
    chapter and experiment with the examples on your own, but if you feel you don't
    fully understand the concept, you can come back to it later when the topics discussed
    previously in this chapter have had a chance to sink in.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to closures, let's first review and expand on the concept of
    scope in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Scope chain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know, in JavaScript, there is no curly braces scope, but there is a
    function scope. A variable defined in a function is not visible outside the function,
    but a variable defined in a code block (for example an `if` or a `for` loop) is
    visible outside the block, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `a` variable is in the global space, while `b` is in the scope of the function
    `f()`. So, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside `f()`, both `a` and `b` are visible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside `f()`, `a` is visible, but `b` is not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you define an `inner()`function nested inside `outer()`, it will have access
    to variables in its own scope, plus the scope of its parents. This is known as
    a scope chain, and the chain can be as long (deep) as you need it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test if the `inner()` function has access to all variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Breaking the chain with a closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s introduce closures with an illustration and look at the following code
    and see what''s happening there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'First, there is the global scope **G**. Think of it as the universe, as if
    it contains everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking the chain with a closure](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It can contain global variables such as **a1** and **a2** and global functions
    such as **F**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking the chain with a closure](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Functions have their own private space and can use it to store other variables,
    such as **b**, and inner functions, such as **N** (for inner). At some point,
    you will end up with a picture like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking the chain with a closure](img/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you're at point a, you're inside the global space. If you're at point **b**,
    which is inside the space of the **F** function, then you have access to the global
    space and to the **F** space. If you're at point **c**, which is inside the **N**
    function, then you can access the global space, the **F** space, and the **N**
    space. You cannot reach from **a** to **b**, because **b** is invisible outside
    **F**. But, you can get from **c** to **b** if you want or from **N** to **b**.
    The interesting part is that the closure effect happens when somehow **N** breaks
    out of **F** and ends up in the global space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking the chain with a closure](img/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What happens then? **N** is in the same global space as **a**. And, as functions
    remember the environment in which they were defined, **N** will still have access
    to the **F** space, and hence, can access **b**. This is interesting, because
    **N** is where **a** is and yet **N** does have access to **b**, but **a** doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, how does **N** break the chain? By making itself global (omitting
    `var`) or by having **F** deliver (or `return`) it to the global space. Let's
    see how this is done in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closure #1'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at the following function, which is the same as before, only `F`
    returns `N` and also `N` returns `b`, to which it has access via the scope chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `F` function contains the `b` variable, which is local, and therefore inaccessible
    from the global space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `N` function has access to its private space, to the `F()` function''s
    space, and to the global space. So, it can see `b`. As `F()` is callable from
    the global space (it''s a global function), you can call it and assign the returned
    value to another global variable. The result - a new global function that has
    access to the `F()` function''s private space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Closure #2'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final result of the next example will be the same as the previous example,
    but the way to achieve it is a little different. `F()` doesn't return a function,
    but instead it creates a new global function, `inner()`, inside its body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by declaring a placeholder for the global function-to-be. This
    is optional, but it''s always good to declare your variables. Then, you can define
    the `F()`function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what happens if you invoke `F()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'A new function, `N()`,is defined inside `F()` and assigned to the global `inner`
    function. During definition time, `N()` was inside `F()`, so it had access to
    the `F()` function''s scope. The `inner()` function will keep its access to the
    `F()` function''s scope, even though it''s part of the global space, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'A definition and closure #3'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every function can be considered a closure. This is because every function maintains
    a secret link to the environment (the scope) in which it was created. But, most
    of the time, this scope is destroyed unless something interesting happens (as
    shown in the preceding code) that causes it to be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Based on what you've seen so far, you can say that a closure is created when
    a function keeps a link to its parent scope even after the parent has returned.
    And, every function is a closure because, at the very least, every function maintains
    access to the global scope, which is never destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see one more example of a closure, this time using the function parameters.
    Function parameters behave like local variables to this function, but they are
    implicitly created; you don''t need to use `var` for them. You can create a function
    that returns another function, which in turn returns its parent''s parameter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `param++` was incremented after the function was defined and yet,
    when called, `inner()` returned the updated value. This demonstrates that the
    function maintains a reference to the scope where it was defined, and not to the
    variables and their values found in the scope during the function execution.
  prefs: []
  type: TYPE_NORMAL
- en: Closures in a loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at a canonical rookie mistake when it comes to closures. It
    can easily lead to hard-to-spot bugs, because on the surface, everything looks
    normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s loop three times, each time creating a new function that returns the
    loop sequence number. The new functions will be added to an array and the array
    is returned at the end. Here''s the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the function, assigning the result to the `arr` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have an array of three functions. Let''s invoke them by adding parentheses
    after each array element. The expected behavior is to see the loop sequence printed
    out as `0`, `1`, and `2`. Let''s try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm, not quite as expected. What happened here? All three functions point to
    the same local variable: `i`. Why? The functions don''t remember values, they
    only keep a link (reference) to the environment where they were created. In this
    case, the `i` variable happens to live in the environment where the three functions
    were defined. So, all functions, when they need to access the value, reach back
    to the environment and find the most current value of `i`. After the loop, the
    `i` variable''s value is `3`. So, all three functions point to the same value.'
  prefs: []
  type: TYPE_NORMAL
- en: Why three and not two is another good question to think about for better understanding
    the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you implement the correct behavior? The answer is to use another
    closure, as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives you the expected result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of just creating a function that returns `i`, you pass the `i`
    variable's current value to another immediate function. In this function, `i`
    becomes the local value `x`, and `x` has a different value every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use a normal (as opposed to an immediate) inner function
    to achieve the same result. The key is to use the middle function to localize
    the value of `i` at every iteration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Getter and setter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see two more examples of using closures. The first one involves the creation
    of the getter and setter functions. Imagine that you have a variable that should
    contain a specific type of value or a specific range of values. You don't want
    to expose this variable because you don't want just any part of the code to be
    able to alter its value. You can protect this variable inside a function and provide
    two additional functions-one to get the value and one to set it. The one that
    sets it could contain some logic to validate a value before assigning it to the
    protected variable. Let's make the validation part simple (for the sake of keeping
    the example short) and only accept number values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can place both the getter and the setter functions inside the same function
    that contains the `secret` variable so that they share the same scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the function that contains everything is an immediate function.
    It defines `setValue()` and `getValue()` as global functions, while the `secret`
    variable remains local and inaccessible directly, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last closure example (also the last example in this chapter) shows the use
    of a closure to accomplish an iterator functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to loop through a simple array, but there might be cases
    where you have a more complicated data structure with different rules as to what
    the sequence of values has. You can wrap the complicated who's next logic into
    an easy-to-use `next()` function. Then, you can simply call `next()` every time
    you need the consecutive value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, let''s just use a simple array and not a complex data structure.
    Here''s an initialization function that takes an input array and also defines
    a secret pointer, `i`, that will always point to the next element in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the `setup()` function with a data array will create the `next()` function
    for you, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'From there it''s easy and fun; calling the same function over and over again
    gives you the next element, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: IIFE versus blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As ES5 did not provide block scope, a popular pattern to achieve block scope
    was to use **immediately invoked function expressions** (**IIFE**), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: With ES6's support for block scopes, you can simply use a `let` or `const` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript uses almost all variations of arrows. With ES6, it introduces a
    new syntax for writing functions. We have always written function expressions
    in JavaScript. It is idiomatic to write code like this in JavaScript (this example
    is in jQuery):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This is a typical jQuery event handler. The event handler `click()` function
    accepts a function as a parameter and we will simply create an inline anonymous
    function expression and pass it to the click function. This style of writing anonymous
    function expressions is known as **Lambda functions**. Several other languages
    support this feature. Though lambdas are more or less standard in new languages,
    JavaScript was responsible for popularizing their usage. However, the lambda syntax
    in JavaScript has not been very concise. ES6 arrow functions fill that gap and
    provide a concise syntax to write functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrow function provide a more concise syntax than the traditional function
    expressions; for example, consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrow functions syntax can simplify the function to the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no `function` or `return` keyword anywhere. If your
    function has only one argument, you will end up writing the function as `identifer
    => expression`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you need multiple arguments, you need to wrap the argument list in braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No parameters**: `() => {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One parameter**: `a => {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More than one parameters**: `(a,b) => {...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrow functions can have both the statement block bodies as well as expression
    bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Both are equivalent but the second variation is concise and preferred. Arrow
    functions are always anonymous. One important aspect of arrow functions that we
    will discuss a little later is that arrow functions do not bind their own values
    of the `this` keyword-the value is lexically derived from the surrounding scope.
    As we have not yet looked at the `this` keyword in detail, we will defer the discussion
    to a later part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a function that converts a hexadecimal color, for example blue (`#0000FF`),
    into its RGB representation, `rgb(0, 0, 255)`. Name your function `getRGB()` and
    test it with the following code (hint: treat the string as an array of characters):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What do each of these following lines print in the console?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does this following code alert?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All these following examples alert `"Boo!"`. Can you explain why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Example 1:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Example 2:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Example 3:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have now completed the introduction to the fundamental concepts related
    to functions in JavaScript. This has laid the groundwork that will allow you to
    quickly grasp the concepts of object-oriented JavaScript and the patterns used
    in modern JavaScript programming. So far, we''ve been avoiding the OO features,
    but as you have reached this point in the book, it''s only going to get more interesting
    from here on in. Let''s take a moment to review the topics discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of how to define and invoke (call) a function using either a function
    declaration syntax or a function expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function parameters and their flexibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in functions-`parseInt()`, `parseFloat()`, `isNaN()`, `isFinite()`, and
    `eval()`-and the four functions to encode/decode a URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of variables in JavaScript-no curly braces scope, variables have only
    function scope and the scope chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functions as data-a function is like any other piece of data that you assign
    to a variable and a lot of interesting applications follow from this, such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private functions and private variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediate functions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions overwriting themselves
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
