- en: Chapter 3. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 函数
- en: 'Mastering functions is an important skill when you learn any programming language,
    and even more so when it comes to JavaScript. This is because JavaScript has many
    uses for functions, and much of the language''s flexibility and expressiveness
    comes from them. Where most programming languages have a special syntax for some
    object-oriented features, JavaScript just uses functions. This chapter will cover
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 精通函数是学习任何编程语言时的重要技能，尤其是在学习JavaScript时更是如此。这是因为JavaScript有很多用途，而且语言的大部分灵活性和表现力都来自于函数。大多数编程语言都有特殊语法来表示某些面向对象特性，而JavaScript只是使用函数。本章将涵盖以下主题：
- en: How to define and use a function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义和使用函数
- en: Passing arguments to a function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数传递给函数
- en: Predefined functions that are available to you for free
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可免费使用的预定义函数
- en: The scope of variables in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中变量的作用域
- en: The concept that functions are just data, albeit a special type of data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数只是数据的概念，尽管是一种特殊类型的数据
- en: 'Understanding these topics will provide a solid base that will allow you to
    dive into the second part of the chapter, which shows some interesting applications
    of functions, as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些主题将为你提供一个坚实的基础，这将使你能够深入到本章的第二部分，该部分展示了函数的一些有趣应用，如下所示：
- en: Using anonymous functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匿名函数
- en: Callbacks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Immediate (self-invoking) functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即（自调用）函数
- en: Inner functions (functions defined inside other functions)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部函数（在其它函数内部定义的函数）
- en: Functions that return functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回函数的函数
- en: Functions that redefine themselves
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义自己的函数
- en: Closures
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: What is a function?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是什么？
- en: 'Functions allow you to group together a code, give it a name, and reuse it
    later, addressing it by the name you gave it. Let''s consider the following code
    as an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数允许你将代码分组，给它一个名字，并在以后通过这个名字重用它。让我们考虑以下代码作为例子：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The parts that make up a function are shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的组成部分如下所示：
- en: The `function` keyword.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`关键字。'
- en: The name of the function; in this case, `sum`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的名称；在这种情况下，`sum`。
- en: The function parameters; in this case, `a` and `b`. A function can take any
    number of parameters, or no parameters, separated by commas.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数；在这种情况下，`a` 和 `b`。一个函数可以接受任意数量的参数，或者不接受任何参数，参数之间用逗号分隔。
- en: A code block, also called the body of the function.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块，也称为函数体。
- en: The `return` statement. A function always returns a value. If it doesn't return
    a value explicitly, it implicitly returns the value `undefined`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`语句。函数总是返回一个值。如果它没有显式返回值，它隐式地返回`undefined`值。'
- en: Note that a function can only return a single value. If you need to return more
    values, you can simply return an array that contains all of the values you need
    as elements of this array.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个函数只能返回一个值。如果你需要返回多个值，你可以简单地返回一个包含所有所需值的数组。
- en: The preceding syntax is called a function declaration. It's just one of the
    ways to create a function in JavaScript, and more ways are coming up.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法称为函数声明。这只是创建函数在JavaScript中的多种方式之一，还有更多方式即将到来。
- en: Calling a function
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数
- en: In order to make use of a function, you will need to call it. You can call a
    function simply using its name, optionally, followed by any number of values in
    parentheses. To invoke a function is another way of saying to call.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用一个函数，你需要调用它。你可以简单地通过其名称来调用一个函数，后面可以跟任意数量的括号内的值。调用函数是另一种说法。
- en: 'Let''s call the `sum()`function, passing two arguments and assigning the value
    that the function returns to the variable `result`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`sum()`函数，传递两个参数，并将函数返回的值赋给变量`result`：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Parameters
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: 'When defining a function, you can specify what parameters the function expects
    to receive when it''s called. A function may not require any parameters, but if
    it does, and you forget to pass them, JavaScript will assign the `undefined` value
    to the ones you skipped. In the next example, the function call returns `NaN`
    because it tries to sum `1` and `undefined`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，你可以指定函数在调用时期望接收哪些参数。一个函数可能不需要任何参数，但如果它需要，而你忘记了传递它们，JavaScript将把`undefined`值分配给你跳过的那些参数。在下一个示例中，函数调用返回`NaN`，因为它试图将`1`和`undefined`相加：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Technically speaking, there is a difference between parameters and arguments,
    although the two are often used interchangeably. Parameters are defined together
    with the function, while arguments are passed to the function when it''s called.
    Consider the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，参数和参数之间有一个区别，尽管这两个词经常被互换使用。参数是在定义函数时定义的，而参数是在函数被调用时传递给函数的。考虑以下示例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `a` and `b` are parameters, while `1` and `2` are arguments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a`和`b`是参数，而`1`和`2`是参数。
- en: 'JavaScript is not picky at all when it comes to accepting arguments. If you
    pass more than the function expects, the extra ones will be silently ignored,
    as shown in the following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到接受参数时，JavaScript非常宽容。如果你传递的参数多于函数期望的，额外的参数将被静默忽略，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What''s more, you can create functions that are flexible about the number of
    parameters they accept. This is possible thanks to the special value `arguments`
    that are created automatically inside each function. Here''s a function that simply
    returns whatever arguments are passed to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以创建对接受参数数量灵活的函数。这是由于在函数内部自动创建的特殊值`arguments`。以下是一个简单地返回传递给它的任何参数的函数：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using `arguments`, you can improve the `sum()` function to accept any number
    of arguments and add them all up, as shown in the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`arguments`，你可以改进`sum()`函数，使其能够接受任意数量的参数并将它们全部相加，如下面的示例所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you test this function by calling it with a different number of arguments,
    or even none at all, you can verify that it works as expected, as you can see
    in the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过调用该函数并传递不同数量的参数，甚至一个都不传递来测试这个函数，你可以验证它按预期工作，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `arguments.length` expression returns the number of arguments passed when
    the function was called. Don't worry if the syntax is unfamiliar, we'll examine
    it in detail in the next chapter. You'll also see that `arguments` is not an array
    (although it sure looks like one), but an array-like object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.length`表达式返回函数被调用时传递的参数数量。不必担心语法不熟悉，我们将在下一章详细检查它。你也会看到`arguments`不是一个数组（尽管它看起来像），而是一个类似数组的对象。'
- en: ES6 introduces several important improvements around function parameters. ES6
    function parameters can now have default values, rest parameters, and allows destructuring.
    The next section discusses each of these concepts in detail.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ES6在函数参数方面引入了几个重要的改进。ES6函数参数现在可以有默认值、剩余参数，并允许解构。下一节将详细讨论这些概念。
- en: Default parameters
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'Function parameters can be assigned default values. While calling the function,
    if a parameter is omitted, the default value assigned to the parameter is used:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数可以指定默认值。在调用函数时，如果省略了参数，则使用分配给该参数的默认值：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we are omitting the `spark_level` parameter, and hence the
    default value assigned to the parameter is used. It is important to note that
    `undefined` is considered as an absence of parameter value; consider the following
    line of code, for example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们省略了`spark_level`参数，因此使用了分配给该参数的默认值。重要的是要注意，`undefined`被视为参数值的缺失；例如，考虑以下代码行：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While providing default values of parameters, it is possible to refer to other
    parameters as well:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供参数的默认值时，也可以引用其他参数：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Default parameters have their own scope; this scope is sandwiched between the
    outer function scope and the inner scope of the function. If the parameter is
    shadowed by a variable in inner scope, surprisingly, the inner variable is not
    available. The following example will help explain this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数有自己的作用域；这个作用域位于外部函数作用域和函数内部作用域之间。如果参数被内部作用域中的变量所覆盖，出人意料的是，内部变量不可用。以下示例将有助于解释这一点：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may expect `val` to get shadowed by the inner definition of the `scope`
    variable, but as the default parameters have their own scope, the value assigned
    to `val` is unaffected by the inner scope.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会预期`val`会被`scope`变量的内部定义所覆盖，但由于默认参数有自己的作用域，因此分配给`val`的值不会受到内部作用域的影响。
- en: Rest parameters
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余参数
- en: 'ES6 introduces rest parameters. Rest parameters allow us to send an arbitrary
    number of parameters to a function in the form of an array. Rest parameter can
    only be the last one in the list of parameters, and there can only be one rest
    parameter. Putting a rest operator(`...`) before the last formal parameter indicates
    that parameter is a rest parameter. The following example shows adding a rest
    operator before the last formal parameter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了剩余参数。剩余参数允许我们将任意数量的参数以数组的形式发送给函数。剩余参数只能是参数列表中的最后一个，并且只能有一个剩余参数。在最后一个形式参数之前放置剩余运算符（`...`）表示该参数是剩余参数。以下示例显示了在最后一个形式参数之前添加剩余运算符：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first parameter passed to the function is received in `tone`, while the
    rest of the parameters are received as an array. Variable arguments (var-args)
    have been part of several other languages and a welcome edition to ES6\. Rest
    parameters can replace the slightly controversial `arguments` variable. The major
    difference between rest parameters and the `arguments` variable is that the rest
    parameters are real arrays. All array methods are available to rest parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给函数的第一个参数在 `tone` 中接收，其余参数作为数组接收。可变参数（var-args）是许多其他语言的一部分，也是 ES6 的受欢迎的补充。剩余参数可以替代有争议的
    `arguments` 变量。剩余参数与 `arguments` 变量的主要区别在于剩余参数是真正的数组。所有数组方法都对剩余参数可用。
- en: Spread operators
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展运算符
- en: 'A spread operator looks exactly like a rest operator but performs the exact
    opposite function. Spread operators are used while providing arguments while calling
    a function or defining an array. The spread operator takes an array and splits
    its element into individual variables. The following example illustrates how the
    spread operator provides a much clearer syntax while calling functions that take
    an array as an argument:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符看起来与剩余运算符非常相似，但执行的是完全相反的功能。扩展运算符在调用函数或定义数组时使用。扩展运算符接受一个数组并将其元素拆分为单独的变量。以下示例说明了扩展运算符在调用接受数组作为参数的函数时提供了更清晰的语法：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In ES5, it is common to use the `apply()` function when passing an array as
    an argument to a function. In the preceding example, we have an array we need
    to pass to a function where the function accepts three variables. The ES5 method
    of passing an array to this function uses the `apply()` function, where the second
    argument allows an array to be passed to the function being called. ES6 spread
    operators give a much cleaner and precise way to deal with this situation. While
    calling `sumAll()`, we use the spread operator(`...`) and pass the `numbers` array
    to the function call. The array is then split into individual variables-`a`, `b`,
    and `c`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，当将数组作为参数传递给函数时，通常使用 `apply()` 函数。在上一个示例中，我们有一个需要传递给函数的数组，该函数接受三个变量。将数组传递给此函数的
    ES5 方法使用 `apply()` 函数，其中第二个参数允许将数组传递给被调用的函数。ES6 扩展运算符提供了处理这种情况的更简洁、更精确的方法。在调用
    `sumAll()` 时，我们使用扩展运算符（`...`）并将 `numbers` 数组传递给函数调用。然后数组被拆分为单独的变量 - `a`、`b` 和
    `c`。
- en: 'Spread operators improve the capabilities of arrays in JavaScript. If you want
    to create an array that is made up of another array, the existing array syntax
    does not support this. You have to use `push`, `splice`, and `concat` to achieve
    this. However, using spread operators, this becomes trivial:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符增强了 JavaScript 中数组的功能。如果你想要创建一个由另一个数组组成的数组，现有的数组语法不支持这一点。你必须使用 `push`、`splice`
    和 `concat` 来实现这一点。然而，使用扩展运算符，这变得非常简单：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we are constructing a `week` array using two arrays,
    `midweek` and `weekend`, using the spread operator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用扩展运算符构建了一个 `week` 数组，该数组由两个数组 `midweek` 和 `weekend` 组成。
- en: Predefined functions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义函数
- en: 'There are a number of functions that are built into the JavaScript engine and
    are available for you to use. Let''s take a look at them. While doing so, you''ll
    have a chance to experiment with functions, their arguments and return values,
    and become comfortable working with functions. The following is a list of the
    built-in functions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多函数是内置在 JavaScript 引擎中的，可供你使用。让我们来看看它们。在这样做的时候，你将有机会实验函数、它们的参数和返回值，并熟悉与函数一起工作。以下是一个内置函数的列表：
- en: parseInt()
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: parseInt()
- en: parseFloat()
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: parseFloat()
- en: isNaN()
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isNaN()
- en: isFinite()
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isFinite()
- en: encodeURI()
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: encodeURI()
- en: decodeURI()
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decodeURI()
- en: encodeURIComponent()
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: encodeURIComponent()
- en: decodeURIComponent()
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decodeURIComponent()
- en: eval()
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eval()
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The black box function**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑盒函数**'
- en: Often, when you invoke functions, your program doesn't need to know how these
    functions work internally. You can think of a function as a black box, give it
    some values (as input arguments), and then take the output result it returns.
    This is true for any function-one that's built into the JavaScript engine, one
    that you create, or one that a co-worker or someone else created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你调用函数时，你的程序不需要知道这些函数的内部工作方式。你可以将函数视为一个黑盒，给它一些值（作为输入参数），然后获取它返回的输出结果。这对任何函数都适用——无论是内置在
    JavaScript 引擎中的，还是你自己创建的，或者是同事或其他人创建的。
- en: parseInt()
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parseInt()
- en: 'The `parseInt()` function takes any type of input (most often a string) and
    tries to make an integer out of it. If it fails, it returns `NaN`, as shown in
    the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()` 函数接受任何类型的输入（通常是字符串）并尝试将其转换为整数。如果失败，它返回 `NaN`，如下面的代码所示：'
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The function accepts an optional second parameter, which is the radix, telling
    the function what type of number to expect-decimal, hexadecimal, binary, and so
    on. For example, trying to extract a decimal number out of the `FF` string makes
    no sense, so the result is `NaN`, but if you try `FF` as a hexadecimal, then you
    get `255`, as shown in the following piece of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受一个可选的第二个参数，即基数，告诉函数期望哪种类型的数字。例如，尝试从 `FF` 字符串中提取十进制数字没有意义，所以结果是 `NaN`，但如果你尝试将
    `FF` 作为十六进制，那么你得到 `255`，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another example would be parsing a string with a base `10` (decimal) and base
    `8` (octal):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是解析以基数 `10`（十进制）和基数 `8`（八进制）开头的字符串：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you omit the second argument when calling `parseInt()`, the function will
    assume `10` (a decimal), with the following exceptions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用 `parseInt()` 时省略第二个参数，该函数将假定 `10`（十进制），但有以下例外：
- en: If you pass a string beginning with `0x`, then the radix is assumed to be `16`
    (a hexadecimal number is assumed).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你传递以 `0x` 开头的字符串，则基数假定是 `16`（假设为十六进制数）。
- en: 'If the string you pass starts with `0`, the function assumes radix `8` (an
    octal number is assumed). Consider the following examples:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你传递的字符串以 `0` 开头，该函数假定基数 `8`（假设为八进制数）。考虑以下示例：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The safest thing to do is to always specify the radix. If you omit the radix,
    your code will probably still work in 99 percent of cases (because most often
    you parse decimals); however, every once in a while, it might cause you a bit
    of hair loss while debugging some edge cases. For example, imagine you have a
    form field that accepts calendar days or months and the user types `06` or `08`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的事情是始终指定基数。如果你省略基数，你的代码在 99% 的情况下可能仍然可以工作（因为通常你解析的是十进制数）；然而，偶尔它可能会在调试一些边缘情况时让你头疼。例如，想象你有一个接受日历天数或月份的表单字段，用户输入
    `06` 或 `08`。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ECMAScript 5 removes the octal literal values and avoids the confusion with
    `parseInt()` and unspecified radix.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5 移除了八进制字面量值，并避免了与 `parseInt()` 和未指定基数混淆。
- en: parseFloat()
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parseFloat()
- en: 'The `parseFloat()` function is similar to the `parseInt()` function, but it
    also looks for decimals when trying to figure out a number from your input. This
    function takes only one parameter, which is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseFloat()` 函数与 `parseInt()` 函数类似，但在尝试从输入中解析数字时也会寻找小数。此函数只接受一个参数，如下所示：'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As with `parseInt()`, `parseFloat()` gives up at the first occurrence of an
    unexpected character, even though the rest of the string might have usable numbers
    in it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `parseInt()` 一样，`parseFloat()` 在遇到第一个意外的字符时会放弃，即使字符串的其余部分可能包含可用的数字：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `parseFloat()` function understands exponents in the input (unlike `parseInt()`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseFloat()` 函数理解输入中的指数（与 `parseInt()` 不同）：'
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: isNaN()
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isNaN()
- en: 'Using `isNaN()`, you can check if an input value is a valid number that can
    safely be used in arithmetic operations. This function is also a convenient way
    to check whether `parseInt()`, `parseFloat()`, or any arithmetic operation succeeded:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `isNaN()`，你可以检查输入值是否为有效的数字，可以安全地用于算术运算。此函数也是检查 `parseInt()`、`parseFloat()`
    或任何算术操作是否成功的一个方便方法：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function will also try to convert the input to a number:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还会尝试将输入转换为数字：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `isNaN()` function is useful because the special value `NaN` is not equal
    to anything, including itself. In other words, `NaN === NaN` is `false`. So, `NaN`
    cannot be used to check if a value is a valid number.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNaN()` 函数很有用，因为特殊值 `NaN` 与任何东西都不相等，包括它自己。换句话说，`NaN === NaN` 是 `false`。因此，`NaN`
    不能用来检查一个值是否为有效的数字。'
- en: isFinite()
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isFinite()
- en: 'The `isFinite()` function checks whether the input is a number that is neither
    `Infinity` nor `NaN`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`isFinite()`函数检查输入是否是一个既不是`Infinity`也不是`NaN`的数字：'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you are wondering about the results returned by the last two calls, remember
    from the previous chapter that the biggest number in JavaScript is `1.7976931348623157e+308`,
    so `1e309` is effectively infinity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对最后两个调用的结果感到好奇，请记住，在前一章中提到JavaScript中的最大数字是`1.7976931348623157e+308`，因此`1e309`实际上是无穷大。
- en: Encode/decode URIs
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码/解码URI
- en: 'In a **Uniform Resource Locator** (**URL**) or a **Uniform Resource Identifier**
    (**URI**), some characters have special meanings. If you want to escape those
    characters, you can use the `encodeURI()` or `encodeURIComponent()`functions.
    The first one will return a usable URL, while the second one assumes you''re only
    passing a part of the URL, such as a query string for example, and will encode
    all applicable characters, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在**统一资源定位符**（**URL**）或**统一资源标识符**（**URI**）中，一些字符具有特殊含义。如果您想转义这些字符，可以使用`encodeURI()`或`encodeURIComponent()`函数。第一个会返回一个可用的URL，而第二个假设您只传递URL的一部分，例如查询字符串，例如，它将编码所有适用的字符，如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The opposites of `encodeURI()` and `encodeURIComponent()` are `decodeURI()`
    and `decodeURIComponent()`, respectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURI()`和`encodeURIComponent()`的反义词分别是`decodeURI()`和`decodeURIComponent()`。'
- en: Sometimes, in legacy code, you might see the functions `escape()` and `unescape()`
    used to encode and decode URLs, but these functions have been deprecated; they
    encode differently and should not be used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在旧代码中，您可能会看到使用`escape()`和`unescape()`函数来编码和解码URL，但这些函数已被弃用；它们以不同的方式编码，不应使用。
- en: eval()
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`eval()`'
- en: 'The `eval()` function takes a string input and executes it as a JavaScript
    code, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`函数接受一个字符串输入，并将其作为JavaScript代码执行，如下所示：'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, `eval('var ii = 2;')` is the same as `var ii = 2;`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`eval('var ii = 2;')`与`var ii = 2;`相同
- en: 'The `eval()` function can be useful sometimes, but it should be avoided if
    there are other options. Most of the time, there are alternatives, and in most
    cases, the alternatives are more elegant and easier to write and maintain. *Eval
    is evil* is a mantra you can often hear from seasoned JavaScript programmers.
    The drawbacks of using `eval()` are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`函数有时很有用，但如果还有其他选择，应避免使用。大多数时候，都有替代方案，而且在大多数情况下，替代方案更优雅，更容易编写和维护。“*Eval是邪恶的*”是经验丰富的JavaScript程序员经常听到的一个咒语。使用`eval()`的缺点如下：'
- en: '**Security**: JavaScript is powerful, which also means it can cause damage.
    If you don''t trust the source of the input you pass to `eval()`, just don''t
    use it.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：JavaScript功能强大，这也意味着它可以造成损害。如果您不相信传递给`eval()`的输入源，就请不要使用它。'
- en: '**Performance**: It''s slower to evaluate live code than to have the code directly
    in the script.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：评估实时代码比直接在脚本中拥有代码要慢。'
- en: A bonus - the alert() function
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个额外的功能 - alert()函数
- en: Let's take a look at another common function-`alert()`. It's not part of the
    core JavaScript (it's nowhere to be found in the ECMA specification), but it's
    provided by the host environment-the browser. It shows a string of text in a message
    box. It can also be used as a primitive debugging tool, although the debuggers
    in modern browsers are much better suited for this purpose.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个常见的函数-`alert()`。它不是JavaScript的核心部分（在ECMA规范中找不到），但它由宿主环境提供-浏览器。它在一个消息框中显示文本字符串。它也可以用作原始的调试工具，尽管现代浏览器的调试器更适合这个目的。
- en: 'Here''s a screenshot showing the result of executing the `alert("Hi There")`
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个显示执行`alert("Hi There")`代码结果的截图：
- en: '![A bonus - the alert() function](img/alert-e1483529706612.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![一个额外的功能 - alert()函数](img/alert-e1483529706612.jpg)'
- en: Before using this function, bear in mind that it blocks the browser thread,
    meaning that no other code will be executed until the user closes the alert. If
    you have a busy Ajax-type application, it's generally not a good idea to use `alert()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此函数之前，请记住它阻止了浏览器线程，这意味着在用户关闭警告之前，不会执行其他代码。如果您有一个繁忙的Ajax类型的应用程序，通常不建议使用`alert()`。
- en: Scope of variables
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: It's important to note, especially if you have come to JavaScript from another
    language, that variables in JavaScript are not defined in a block scope, but in
    a function scope. This means that if a variable is defined inside a function,
    it's not visible outside of the function. However, if it's defined inside an `if`
    or a `for` code block, it's visible outside the block. The term global variables
    describes variables you define outside of any function (in the global program
    code), as opposed to local variables, which are defined inside a function. The
    code inside a function has access to all global variables as well as to its own
    local ones.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，特别是如果你是从其他语言转向JavaScript的，JavaScript中的变量不是在块作用域中定义的，而是在函数作用域中定义的。这意味着如果一个变量在函数内部定义，它在外部函数中是不可见的。然而，如果它在`if`或`for`代码块内部定义，它在外部是可见的。全局变量这个术语描述的是你定义在任何函数之外的变量（在全局程序代码中），与局部变量相对，局部变量是在函数内部定义的。函数内部的代码可以访问所有全局变量以及它自己的局部变量。
- en: 'In the next example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中：
- en: The `f()`function has access to the `global` variable
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f()`函数可以访问`global`变量'
- en: Outside the `f()`function, the `local` variable doesn't exist
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`f()`函数外部，`local`变量不存在
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s test this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It''s also important to note that if you don''t use `var` to declare a variable,
    this variable is automatically assigned a global scope. Let''s see an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要指出的是，如果你不使用`var`来声明一个变量，这个变量会自动被分配一个全局作用域。让我们看一个例子：
- en: '![Scope of variables](img/image_03_001-e1482742379131.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![变量作用域](img/image_03_001-e1482742379131.jpg)'
- en: What happened? The `f()`function contains the `local` variable. Before calling
    the function, the variable doesn't exist. When you call the function for the first
    time, the `local` variable is created with a global scope. Then, if you access
    the `local` variable outside the function, it will be available.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？`f()`函数包含`local`变量。在调用函数之前，该变量不存在。当你第一次调用函数时，`local`变量会以全局作用域的形式创建。然后，如果你在函数外部访问`local`变量，它将是可用的。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice tips**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践提示**'
- en: Minimize the number of global variables in order to avoid naming collisions.
    Imagine two people working on two different functions in the same script, and
    they both decide to use the same name for their global variable. This could easily
    lead to unexpected results and hard-to-find bugs. Always declare your variables
    with the `var` statement. Consider a single `var` pattern. Define all variables
    needed in your function at the very top of the function so you have a single place
    to look for variables and, hopefully, prevent accidental globals.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化全局变量的数量，以避免命名冲突。想象两个人在同一个脚本中分别工作两个不同的函数，他们都决定为他们的全局变量使用相同的名称。这很容易导致意外的结果和难以发现的错误。始终使用`var`语句声明你的变量。考虑单一的`var`模式。在函数的顶部定义所有需要的变量，这样你就有了一个查找变量的单一位置，并希望防止意外创建全局变量。
- en: Variable hoisting
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量提升
- en: 'Here''s an interesting example that shows an important aspect of local versus
    global scoping:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的例子，展示了局部作用域与全局作用域的重要区别：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You might expect that the first `alert()` function will display `123` (the value
    of the global variable `a`) and the second will display `1` (the local variable
    `a`). But, this is not the case. The first alert will show `undefined`. This is
    because, inside the function, the local scope is more important than the global
    scope. So, a local variable overwrites any global variable with the same name.
    At the time of the first `alert()`, the `a` variable was not yet defined (hence
    the `undefined` value), but it still existed in the local space due to the special
    behavior called **hoisting**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能预期第一个`alert()`函数将显示`123`（全局变量`a`的值），第二个将显示`1`（局部变量`a`）。但这并不是事实。第一个`alert()`将显示`undefined`。这是因为，在函数内部，局部作用域比全局作用域更重要。所以，一个局部变量会覆盖任何同名的全局变量。在第一次`alert()`时，`a`变量尚未定义（因此显示`undefined`值），但它仍然由于称为**提升**的特殊行为而在局部空间中存在。
- en: 'When your JavaScript program execution enters a new function, all the variables
    declared anywhere in the function are moved, elevated, or hoisted to the top of
    the function. This is an important concept to keep in mind. Further, only the
    declaration is hoisted, meaning only the presence of the variable is moved to
    the top. Any assignments stay where they are. In the preceding example, the declaration
    of the local variable `a` was hoisted to the top. Only the declaration was hoisted,
    but not the assignment to `1`. It''s as if the function was written in the following
    way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 JavaScript 程序执行进入一个新的函数时，该函数中任何地方声明的所有变量都会被移动、提升或提升到函数的顶部。这是一个需要记住的重要概念。此外，只有声明被提升，这意味着只有变量的存在被移动到顶部。任何赋值都保持原位。在先前的例子中，局部变量
    `a` 的声明被提升到顶部。只有声明被提升，但赋值给 `1` 的操作没有。这就像函数是以以下方式编写的：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can also adopt the single var pattern mentioned previously in the best practice
    section. In this case, you'll be doing a sort of manual variable hoisting to prevent
    confusion with the JavaScript hoisting behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以采用之前在最佳实践部分提到的单 `var` 模式。在这种情况下，你将进行一种手动变量提升，以防止与 JavaScript 提升行为混淆。
- en: Block scope
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块作用域
- en: ES6 provides additional scope while declaring variables. We looked at function
    scope and how it affects variables declared with the `var` keyword. If you are
    coding in ES6, block scope will mostly replace your need to use variables declared
    using `var`. Although, if you are still with ES5, we want you to make sure that
    you look at hoisting behavior carefully.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 在声明变量时提供了额外的范围。我们讨论了函数作用域以及它如何影响使用 `var` 关键字声明的变量。如果你在 ES6 中编码，块作用域将主要取代你使用使用
    `var` 声明变量的需求。尽管如此，如果你仍然使用 ES5，我们希望确保你仔细查看提升行为。
- en: ES6 introduces the `let` and `const` keywords that allow us to declare variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了 `let` 和 `const` 关键字，允许我们声明变量。
- en: 'Variables declared with `let` are block-scoped. They exist only within the
    current block. Variables declared with `var` are function scoped, as we saw earlier.
    The following example illustrates the block scope:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let` 声明的变量是块作用域的。它们只存在于当前块内。使用 `var` 声明的变量是函数作用域的，正如我们之前看到的。以下示例说明了块作用域：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The scope between an opening brace`''{''` and a closing brace `''}''` is a
    block. If you are coming from a background in Java or C/C++, the concept of a
    block scope will be very familiar to you. In those languages, programmers introduced
    blocks just to define a scope. In JavaScript, however, there was a need to idiomatically
    introduce blocks as they didn''t have a scope associated to it. However, ES6 allows
    you to create block-scoped variables using the `let` keyword. As you can see in
    the preceding example, variable `a` created inside the block is available within
    the block. While declaring block-scoped variables, it is generally recommended
    to add the `let` declaration at the top of the block. Let''s look at another example
    to clearly distinguish function and block scope:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 开放花括号 `'{ '` 和闭合花括号 `'}'` 之间的范围是一个块。如果你来自 Java 或 C/C++ 的背景，块作用域的概念将非常熟悉。在这些语言中，程序员引入块只是为了定义作用域。然而，在
    JavaScript 中，由于没有与之关联的作用域，因此需要以惯用的方式引入块。但是，ES6 允许你使用 `let` 关键字创建块作用域变量。正如先前的例子所示，在块内创建的变量
    `a` 在块内可用。在声明块作用域变量时，通常建议在块的顶部添加 `let` 声明。让我们看看另一个例子，以清楚地区分函数作用域和块作用域：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, `tmp` is declared with `let` and is available only in the block
    in which it was defined. For all practical purposes, you should maximize your
    use of block-scoped variables. Unless there is something very specific you are
    trying to do that makes it necessary for you to use `var` declarations, make sure
    you prefer block scoped variables. However, incorrectly using the `let` keyword
    can cause a couple of problems. First, you cannot redeclare the same variable
    within the same function or block scope using the `let` keyword:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`tmp` 使用 `let` 声明，并且仅在定义它的块内可用。从实际应用的角度来看，你应该最大限度地使用块作用域变量。除非你有非常具体的目标，需要使用
    `var` 声明，否则请确保你优先选择块作用域变量。然而，不正确地使用 `let` 关键字可能会导致一些问题。首先，你不能在同一个函数或块作用域内使用 `let`
    关键字重新声明相同的变量：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In ES6, variables declared by the `let` keyword are hoisted to block scope.
    However, referencing the variable before its declaration is an error.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，使用 `let` 关键字声明的变量会被提升到块作用域。然而，在声明之前引用变量是一个错误。
- en: Another keyword introduced in ES6 is `const`. A variable declared with the `const`
    keyword creates a read-only reference to a value. This does not mean that the
    value held by the reference is immutable. However, the variable identifier cannot
    be reassigned. Constants are block-scoped just like variables created using the
    `let` keyword. Also, you have to assign a value to the variable while declaring
    them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ES6中引入的另一个关键字是`const`。使用`const`关键字声明的变量创建了对值的只读引用。这并不意味着该引用所持有的值是不可变的。然而，变量标识符不能被重新赋值。常量与使用`let`关键字创建的变量具有相同的块作用域。此外，你必须在声明它们时为变量赋值。
- en: 'Although it sounds like it does, `const` has nothing to do with immutable values.
    Constants create immutable binding. This is an important distinction and needs
    to be understood correctly. Let''s consider the following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来是这样，但`const`与不可变值无关。常量创建不可变绑定。这是一个重要的区别，需要正确理解。让我们考虑以下示例：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is a valid code; here we are assigning value `{}` to a constant `car`.
    Once assigned, this reference cannot be changed. In ES6, you should do the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段有效的代码；在这里，我们将空对象`{}`赋值给一个常量`car`。一旦赋值，这个引用就不能更改。在ES6中，你应该这样做：
- en: 'Use `const` where possible. Use them for all variables whose values don''t
    change:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`const`。将它们用于所有值不改变的变量：
- en: '[PRE35]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Avoid `var`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用`var`。
- en: Functions are data
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是数据
- en: 'Functions in JavaScript are actually data. This is an important concept that
    we''ll need later on. This means that you can create a function and assign it
    to a variable, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的函数实际上是数据。这是一个重要的概念，我们稍后会用到。这意味着你可以创建一个函数并将其赋值给一个变量，如下所示：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This way of defining a function is sometimes referred to as **function literal
    notation**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义函数的方式有时被称为**函数字面量表示法**。
- en: 'The `function () { return 1;}` part is a **function expression**. A function
    expression can optionally have a name, in which case it becomes a **named function
    expression** (**NFE**). So, this is also allowed, although rarely seen in practice
    (and causes IE to mistakenly create two variables in the enclosing scope-`f` and
    `myFunc`):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`function () { return 1;}`部分是一个**函数表达式**。函数表达式可以有一个可选的名称，在这种情况下，它成为一个**命名函数表达式**（**NFE**）。因此，这也是允许的，尽管在实践中很少见（并且会导致IE在封装作用域中错误地创建两个变量-`f`和`myFunc`）：'
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, there's no difference between a named function expression and
    a function declaration. But they are, in fact, different. The only way to distinguish
    between the two is to look at the context in which they are used. Function declarations
    may only appear in program code (in a body of another function or in the main
    program). You'll see many more examples of functions later on in the book that
    will clarify these concepts.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命名函数表达式和函数声明之间没有区别。但实际上，它们是不同的。区分这两种方法的唯一方法是查看它们被使用的上下文。函数声明只能出现在程序代码中（在另一个函数的主体中或在主程序中）。你将在本书后面的部分看到更多关于函数的示例，这些示例将阐明这些概念。
- en: 'When you use the `typeof` operator on a variable that holds a function value,
    it returns the string `"function"` as shown in the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在包含函数值的变量上使用`typeof`运算符时，它将返回字符串`"function"`，如下面的示例所示：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, JavaScript functions are data, but a special kind of data with the following
    two important features:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript函数是数据，但具有以下两个重要特性的特殊数据：
- en: They contain code
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们包含代码
- en: They are executable (they can be invoked)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可执行的（它们可以被调用）
- en: 'As you have seen before, the way to execute a function is by adding parentheses
    after its name. As the next example demonstrates, this works regardless of how
    the function was defined. In the example, you can also see how a function is treated
    as a regular value; it can be copied to a different variable, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，执行函数的方法是在其名称后添加括号。正如下一个示例所演示的，这适用于函数定义的任何方式。在示例中，你还可以看到函数如何被视为常规值；它可以被复制到不同的变量中，如下所示：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As functions are data assigned to variables, the same rules for naming functions
    apply as for naming variables-a function name cannot start with a number and it
    can contain any combination of letters, numbers, the underscore character, and
    the dollar sign.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是分配给变量的数据，因此命名函数的规则与命名变量的规则相同——函数名不能以数字开头，它可以包含任何字母、数字、下划线字符和美元符号的组合。
- en: Anonymous functions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'As you now know, there exists a function expression syntax where you can have
    a function defined like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，存在一种函数表达式语法，你可以定义函数如下：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is also often called an **anonymous function** (as it doesn''t have a
    name), especially when such a function expression is used even without assigning
    it to a variable. In this case, there can be two elegant uses for such anonymous
    functions, which are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这也常被称为一个**匿名函数**（因为它没有名字），尤其是在这种函数表达式被使用，甚至没有分配给变量的情况下。在这种情况下，这样的匿名函数可以有如下两种优雅的使用方式：
- en: You can pass an anonymous function as a parameter to another function. The receiving
    function can do something useful with the function that you pass.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将匿名函数作为参数传递给另一个函数。接收函数可以使用你传递的函数做一些有用的事情。
- en: You can define an anonymous function and execute it right away.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以定义一个匿名函数并立即执行它。
- en: Let's see these two applications of anonymous functions in more detail.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看匿名函数的这两个应用。
- en: Callback functions
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调函数
- en: As a function is just like any other data assigned to a variable, it can be
    defined, copied, and also passed as an argument to other functions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数就像任何其他分配给变量的数据一样，它可以被定义、复制，也可以作为参数传递给其他函数。
- en: 'Here''s an example of a function that accepts two functions as parameters,
    executes them, and returns the sum of what each of them returns:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，该函数接受两个函数作为参数，执行它们，并返回每个函数返回值的总和：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s define two simple additional functions using a function declaration
    pattern that only returns hardcoded values:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用函数声明模式定义两个简单的附加函数，该模式只返回硬编码的值：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now you can pass those functions to the original function, `invokeAdd()`, and
    get the following result:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将这些函数传递给原始函数`invokeAdd()`，并得到以下结果：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another example of passing a function as a parameter is to use anonymous functions
    (function expressions). Instead of defining `one()` and `two()`, you can simply
    do the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为参数传递的另一个例子是使用匿名函数（函数表达式）。你不需要定义`one()`和`two()`，你可以简单地做以下操作：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or, you can make it more readable, as shown in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以让它更易于阅读，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or, you can do the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以这样做：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When you pass a function, A, to another function, B, and then B executes A,
    it's often said that A is a **callback** function. If A doesn't have a name, then
    you can say that it's an anonymous callback function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个函数A传递给另一个函数B，然后B执行A时，通常说A是一个**回调**函数。如果A没有名字，那么你可以称它为匿名回调函数。
- en: 'When are callback functions useful? Let''s see some examples that demonstrate
    the benefits of callback functions, namely:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当回调函数有用时？让我们看看一些示例，展示回调函数的好处，特别是：
- en: They let you pass functions without the need to name them, which means there
    are fewer variables floating around
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许你传递函数而不需要命名它们，这意味着浮动的变量更少
- en: You can delegate the responsibility of calling a function to another function,
    which means there is less code to write
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将调用函数的责任委托给另一个函数，这意味着需要编写的代码更少
- en: They can help with performance by deferring the execution or by unblocking calls
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以通过延迟执行或解除阻塞调用来帮助提高性能
- en: Callback examples
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调示例
- en: 'Take a look at this common scenario-you have a function that returns a value,
    which you then pass to another function. In our example, the first function, `multiplyByTwo()`,
    accepts three parameters, loops through them, multiplies them by two, and returns
    an array containing the result. The second function, `addOne()`, takes a value,
    adds one to it, and returns it, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个常见的场景——你有一个返回值的函数，然后你将其传递给另一个函数。在我们的例子中，第一个函数`multiplyByTwo()`接受三个参数，遍历它们，将它们乘以二，并返回包含结果的数组。第二个函数`addOne()`接受一个值，将其加一，并返回它，如下所示：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s test these functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试这些函数：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let''s say you want to have an array, `myarr`, that contains three elements,
    and each of the elements is to be passed through both functions. First, let''s
    start with a call to `multiplyByTwo()`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要一个包含三个元素的数组`myarr`，并且每个元素都要通过这两个函数。首先，让我们从调用`multiplyByTwo()`函数开始：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, loop through each element, passing it to `addOne()`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，遍历每个元素，将其传递给`addOne()`函数：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, everything works fine, but there''s room for improvement. For
    example, there were two loops. Loops can be expensive if they go through a lot
    of repetitions. You can achieve the same result with only one loop. Here''s how
    to modify `multiplyByTwo()` so that it accepts a callback function and invokes
    that callback on every iteration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一切正常，但仍有改进的空间。例如，有两个循环。如果循环进行了很多次重复，循环可能会很昂贵。你可以只用一个循环达到相同的结果。以下是修改 `multiplyByTwo()`
    以使其接受一个回调函数并在每次迭代中调用该回调函数的方法：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using the modified function, all the work is done with just one function call,
    which passes the start values and the `callback` function, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修改后的函数，所有的工作只需一个函数调用就能完成，该调用传递起始值和 `callback` 函数，如下所示：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Instead of defining `addOne()`, you can use an anonymous function, therefore
    saving an extra global variable:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要定义 `addOne()`，可以使用匿名函数，因此可以节省一个额外的全局变量：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Anonymous functions are easy to change should the need arise:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，匿名函数很容易更改：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Immediate functions
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即函数
- en: 'So far, we have discussed using anonymous functions as callbacks. Let''s see
    another application of an anonymous function-calling a function immediately after
    it''s defined. Here''s an example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了使用匿名函数作为回调。让我们看看匿名函数的另一个应用——在定义后立即调用函数。以下是一个例子：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The syntax may look a little scary at first, but all you do is simply place
    a function expression inside parentheses followed by another set of parentheses.
    The second set says execute now and is also the place to put any arguments that
    your anonymous function might accept, for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 语法一开始可能看起来有点吓人，但你只需简单地将一个函数表达式放在括号内，然后跟另一组括号。第二组括号表示立即执行，也是放置匿名函数可能接受的任何参数的地方，例如：
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Alternatively, you can move the closing of the first set of parentheses to
    the end. Both of these work:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将第一组括号的关闭移到末尾。这两种方法都有效：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: One good application of immediate (self-invoking) anonymous functions is when
    you want to have some work done without creating extra global variables. A drawback,
    of course, is that you cannot execute the same function twice. This makes immediate
    functions best suited for one-off or initialization tasks.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 立即（自调用）匿名函数的一个很好的应用场景是当你想在不需要创建额外的全局变量的情况下完成一些工作。当然，缺点是你不能两次执行同一个函数。这使得立即函数最适合一次性或初始化任务。
- en: 'An immediate function can also optionally return a value if you need one. It''s
    not uncommon to see code that looks like the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，立即函数也可以选择性地返回一个值。看到如下代码并不罕见：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this case, you don''t need to wrap the function expression in parentheses;
    you only need the parentheses that invoke the function. So, the following piece
    of code also works:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你不需要将函数表达式包裹在括号内；你只需要调用函数的括号。所以，以下这段代码也有效：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This syntax works, but may look slightly confusing; without reading the end
    of the function, you don't know if `result` is a function or the return value
    of the immediate function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法是有效的，但可能看起来有点令人困惑；如果不阅读函数的结尾，你不知道 `result` 是一个函数还是立即函数的返回值。
- en: Inner (private) functions
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部（私有）函数
- en: 'Bearing in mind that a function is just like any other value, there''s nothing
    that stops you from defining a function inside another function, here''s the example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到函数就像任何其他值一样，没有什么是阻止你在另一个函数内部定义函数的。以下是一个例子：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using a function expression, this can also be written as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数表达式，这也可以写成如下形式：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When you call the global `outer()`function, it will internally call the local
    `inner()`function. As `inner()` is local, it''s not accessible outside `outer()`,
    so you can say it''s a private function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用全局的 `outer()` 函数时，它将内部调用局部的 `inner()` 函数。由于 `inner()` 是局部的，它不能在 `outer()`
    之外访问，所以可以说它是一个私有函数：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The benefits of using private functions are as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有函数的好处如下：
- en: You can keep the global namespace clean, which is less likely to cause naming
    collisions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以保持全局命名空间干净，这减少了命名冲突的可能性
- en: Privacy-you can expose only those functions to the outside world that you decide,
    and keep the functionality that is not meant to be consumed by the rest of the
    application to yourself
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐私——你可以只暴露你决定暴露给外界的那些函数，并将那些不打算被应用程序其他部分消费的功能保留给自己
- en: Functions that return functions
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回函数的函数
- en: 'As mentioned earlier, a function always returns a value, and if it doesn''t
    do it explicitly with `return`, then it does so implicitly by returning `undefined`.
    A function can return only one value, and this value can just as easily be another
    function, for example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数总是返回一个值，如果它没有使用`return`显式地返回，那么它就隐式地通过返回`undefined`来返回。函数只能返回一个值，而这个值也可以是一个函数，例如：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this example, the `a()`function does its job (says `A!`) and returns another
    function that does something else (says `B!`). You can assign the return value
    to a variable and then use this variable as a normal function, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a()`函数完成了它的任务（说`A!`）并返回另一个执行其他操作（说`B!`）的函数。你可以将返回值分配给一个变量，然后像使用普通函数一样使用这个变量，如下所示：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, the first line will alert `A!` and the second will alert `B!`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一行会提示`A!`，第二行会提示`B!`。
- en: 'If you want to execute the returned function immediately without assigning
    it to a new variable, you can simply use another set of parentheses. The end result
    will be the same:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要立即执行返回的函数而不将其分配给新变量，你可以简单地使用另一组括号。最终结果将是相同的：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Function, rewrite thyself!
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数，重写你自己！
- en: 'As a function can return a function, you can use the new function to replace
    the old one. Continuing with the previous example, you can take the value returned
    by the call to `a()` to overwrite the actual `a()` function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以返回一个函数，你可以使用新函数来替换旧函数。继续前面的例子，你可以使用对`a()`的调用返回的值来覆盖实际的`a()`函数：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding line of code alerts `A!`, but the next time you call `a()` it
    alerts `B!`. This is useful when a function has some initial one-off work to do.
    The function overwrites itself after the first call in order to avoid doing unnecessary
    repetitive work every time it's called.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码会提示`A!`，但下次调用`a()`时会提示`B!`。这在函数需要执行一些初始的一次性工作时很有用。函数在第一次调用后会覆盖自身，以避免每次调用时都执行不必要的重复工作。
- en: 'In the preceding example, the function was redefined from the outside and the
    returned value was assigned back to the function. But, the function can actually
    rewrite itself from the inside, as shown in the following example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，函数是从外部重新定义的，返回值被分配回函数。但实际上，函数可以从内部重新编写自己，如下面的例子所示：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you call this function for the first time, it will do the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次调用这个函数，它将执行以下操作：
- en: Alert `A!` (consider this as being the one-off preparatory work)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示`A!`（可以将其视为一次性准备工作）
- en: Redefine the global variable `a` and assigning a new function to it
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义全局变量`a`并将其分配给一个新的函数
- en: Every subsequent time that the function is called, it will alert `B!`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每次函数被调用后的后续时间，它将提示`B!`。
- en: 'Here''s another example that combines several of the techniques discussed in
    the last few sections of this chapter:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，它结合了本章最后几节讨论的几种技术：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'From this example, you can note the following things:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，你可以注意以下几点：
- en: You have private functions; `someSetup()` and `actualWork()`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有私有函数；`someSetup()`和`actualWork()`。
- en: 'You have an immediate function: an anonymous function that calls itself using
    the parentheses following its definition.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个立即执行的函数：一个匿名函数，它使用其定义后的括号调用自身。
- en: The function executes for the first time, calls `someSetup()`, and then returns
    a reference to the `actualWork` variable, which is a function. Notice that there
    are no parentheses in the `return` statement because you're returning a function
    reference, not the result of invoking this function.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数首次执行时，调用`someSetup()`，然后返回`actualWork`变量的引用，该变量是一个函数。请注意，在`return`语句中没有括号，因为您返回的是函数引用，而不是调用此函数的结果。
- en: As the whole thing starts with `var a =`, the value returned by the self-invoked
    function is assigned to `a`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于整个操作从`var a =`开始，自调用的函数返回的值被分配给`a`。
- en: 'If you want to test your understanding of the topics just discussed, answer
    the following questions. What will the preceding code alert be in the following
    cases:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试你对刚才讨论的主题的理解，请回答以下问题。在以下情况下，前面的代码会提示什么：
- en: It is initially loaded?
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它最初被加载？
- en: You call `a()` afterwards?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你之后调用`a()`吗？
- en: These techniques could be really useful when working in the browser environment.
    Different browsers can have different ways of achieving the same result. If you
    know that the browser features won't change between function calls, you can have
    a function determine the best way to do the work in the current browser, then
    redefine itself so that the browser capability detection is done only once. You'll
    see concrete examples of this scenario later in this book.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术在工作在浏览器环境中时可能非常有用。不同的浏览器可能有不同的实现相同结果的方式。如果你知道浏览器特性在函数调用之间不会改变，你可以让一个函数确定在当前浏览器中完成工作的最佳方式，然后重新定义自己，以便浏览器能力检测只进行一次。你将在本书后面的具体例子中看到这种情况。
- en: Closures
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: The rest of the chapter is about closures (what better way to close a chapter?).
    Closures can be a little hard to grasp initially, so don't feel discouraged if
    you don't get it during the first read. You should go through the rest of the
    chapter and experiment with the examples on your own, but if you feel you don't
    fully understand the concept, you can come back to it later when the topics discussed
    previously in this chapter have had a chance to sink in.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将关于闭包（还有什么比结束章节更好的方式？）。闭包可能一开始有点难以理解，所以如果你在第一次阅读时没有完全理解，不要气馁。你应该阅读本章的其余部分，并亲自尝试这些例子，但如果你觉得你还没有完全理解这个概念，你可以在本章前面讨论的主题有所沉淀后再回来学习。
- en: Before moving on to closures, let's first review and expand on the concept of
    scope in JavaScript.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论闭包之前，让我们首先回顾和扩展JavaScript中的作用域概念。
- en: Scope chain
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域链
- en: 'As you know, in JavaScript, there is no curly braces scope, but there is a
    function scope. A variable defined in a function is not visible outside the function,
    but a variable defined in a code block (for example an `if` or a `for` loop) is
    visible outside the block, for example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在JavaScript中，没有花括号作用域，但有一个函数作用域。在函数中定义的变量在函数外部是不可见的，但在代码块（例如`if`或`for`循环）中定义的变量在块外部是可见的，例如：
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `a` variable is in the global space, while `b` is in the scope of the function
    `f()`. So, we have the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`a`在全局空间中，而`b`在函数`f()`的作用域中。因此，我们有以下情况：
- en: Inside `f()`, both `a` and `b` are visible
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`f()`内部，`a`和`b`都是可见的
- en: Outside `f()`, `a` is visible, but `b` is not
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`f()`外部，`a`是可见的，但`b`是不可见的
- en: 'If you define an `inner()`function nested inside `outer()`, it will have access
    to variables in its own scope, plus the scope of its parents. This is known as
    a scope chain, and the chain can be as long (deep) as you need it to be:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个嵌套在`outer()`中的`inner()`函数中定义，它将有权访问它自己的作用域中的变量，以及其父作用域中的变量。这被称为作用域链，链的长度（深度）可以是你需要的任何长度：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s test if the `inner()` function has access to all variables:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试`inner()`函数是否有权访问所有变量：
- en: '[PRE71]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Breaking the chain with a closure
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用闭包打破链
- en: 'Let''s introduce closures with an illustration and look at the following code
    and see what''s happening there:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来介绍闭包，并查看以下代码，看看那里发生了什么：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'First, there is the global scope **G**. Think of it as the universe, as if
    it contains everything:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有全局作用域**G**。把它想象成宇宙，就像它包含了一切：
- en: '![Breaking the chain with a closure](img/image_03_002.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包打破链](img/image_03_002.jpg)'
- en: 'It can contain global variables such as **a1** and **a2** and global functions
    such as **F**:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以包含全局变量，如**a1**和**a2**，以及全局函数，如**F**：
- en: '![Breaking the chain with a closure](img/image_03_003.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包打破链](img/image_03_003.jpg)'
- en: 'Functions have their own private space and can use it to store other variables,
    such as **b**, and inner functions, such as **N** (for inner). At some point,
    you will end up with a picture like the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有自己的私有空间，并可以使用它来存储其他变量，如**b**，以及内部函数，如**N**（表示内部）。在某个时刻，你最终会得到以下这样的图：
- en: '![Breaking the chain with a closure](img/image_03_004.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包打破链](img/image_03_004.jpg)'
- en: If you're at point a, you're inside the global space. If you're at point **b**,
    which is inside the space of the **F** function, then you have access to the global
    space and to the **F** space. If you're at point **c**, which is inside the **N**
    function, then you can access the global space, the **F** space, and the **N**
    space. You cannot reach from **a** to **b**, because **b** is invisible outside
    **F**. But, you can get from **c** to **b** if you want or from **N** to **b**.
    The interesting part is that the closure effect happens when somehow **N** breaks
    out of **F** and ends up in the global space.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处于点a，你处于全局空间内。如果你处于点**b**，它位于**F**函数的空间内，那么你可以访问全局空间和**F**空间。如果你处于点**c**，它位于**N**函数内，那么你可以访问全局空间、**F**空间和**N**空间。你不能从**a**到达**b**，因为**b**在**F**外部是不可见的。但是，如果你想从**c**到达**b**或者从**N**到达**b**，是可以的。有趣的部分是，当**N**以某种方式从**F**中跳出并最终进入全局空间时，闭包效果就会发生。
- en: '![Breaking the chain with a closure](img/image_03_005.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包打破链](img/image_03_005.jpg)'
- en: What happens then? **N** is in the same global space as **a**. And, as functions
    remember the environment in which they were defined, **N** will still have access
    to the **F** space, and hence, can access **b**. This is interesting, because
    **N** is where **a** is and yet **N** does have access to **b**, but **a** doesn't.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来会发生什么？**N**与**a**处于同一个全局空间。而且，由于函数会记住它们定义时的环境，**N**仍然可以访问**F**空间，因此可以访问**b**。这很有趣，因为**N**在**a**的位置，但**N**确实可以访问**b**，而**a**则不能。
- en: Additionally, how does **N** break the chain? By making itself global (omitting
    `var`) or by having **F** deliver (or `return`) it to the global space. Let's
    see how this is done in practice.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**N**是如何打破链的？通过将其自身变为全局的（省略`var`）或者通过让**F**将其传递（或`return`）到全局空间。让我们看看这在实践中是如何实现的。
- en: 'Closure #1'
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '闭包 #1'
- en: 'Take a look at the following function, which is the same as before, only `F`
    returns `N` and also `N` returns `b`, to which it has access via the scope chain:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的函数，它与之前相同，只是`F`返回`N`，而`N`也返回`b`，它可以通过作用域链访问：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `F` function contains the `b` variable, which is local, and therefore inaccessible
    from the global space:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`F`函数包含一个局部变量`b`，因此无法从全局空间访问：'
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `N` function has access to its private space, to the `F()` function''s
    space, and to the global space. So, it can see `b`. As `F()` is callable from
    the global space (it''s a global function), you can call it and assign the returned
    value to another global variable. The result - a new global function that has
    access to the `F()` function''s private space:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`N`函数可以访问其私有空间、`F()`函数的空间和全局空间。因此，它可以看到`b`。由于`F()`可以从全局空间调用（它是一个全局函数），你可以调用它并将返回值赋给另一个全局变量。结果是
    - 一个新的全局函数，它可以访问`F()`函数的私有空间：'
- en: '[PRE75]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Closure #2'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '闭包 #2'
- en: The final result of the next example will be the same as the previous example,
    but the way to achieve it is a little different. `F()` doesn't return a function,
    but instead it creates a new global function, `inner()`, inside its body.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例的最终结果将与上一个示例相同，但实现它的方法略有不同。`F()`函数不返回一个函数，而是在其体内创建一个新的全局函数`inner()`。
- en: 'Let''s start by declaring a placeholder for the global function-to-be. This
    is optional, but it''s always good to declare your variables. Then, you can define
    the `F()`function as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从声明一个全局函数占位符开始。这是可选的，但总是好的，要声明你的变量。然后，你可以定义`F()`函数如下：
- en: '[PRE76]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, let''s see what happens if you invoke `F()`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看调用`F()`会发生什么：
- en: '[PRE77]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'A new function, `N()`,is defined inside `F()` and assigned to the global `inner`
    function. During definition time, `N()` was inside `F()`, so it had access to
    the `F()` function''s scope. The `inner()` function will keep its access to the
    `F()` function''s scope, even though it''s part of the global space, for example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在`F()`内部定义了一个新的函数`N()`，并将其赋值给全局的`inner`函数。在定义时，`N()`位于`F()`内部，因此它可以访问`F()`函数的作用域。`inner()`函数将保持对`F()`函数作用域的访问，即使它现在是全局空间的一部分，例如：
- en: '[PRE78]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A definition and closure #3'
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '定义和闭包 #3'
- en: Every function can be considered a closure. This is because every function maintains
    a secret link to the environment (the scope) in which it was created. But, most
    of the time, this scope is destroyed unless something interesting happens (as
    shown in the preceding code) that causes it to be maintained.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都可以被视为一个闭包。这是因为每个函数都维护着一个秘密的链接到其创建时的环境（作用域）。但是，大多数情况下，这个作用域会被销毁，除非发生了某些有趣的事情（如前述代码所示），导致它被保留。
- en: Based on what you've seen so far, you can say that a closure is created when
    a function keeps a link to its parent scope even after the parent has returned.
    And, every function is a closure because, at the very least, every function maintains
    access to the global scope, which is never destroyed.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你迄今为止所看到的，你可以这样说，当一个函数在父作用域返回后仍然保持对其的链接时，就会创建一个闭包。而且，每个函数都是一个闭包，因为至少每个函数都保持对全局作用域的访问，而全局作用域永远不会被销毁。
- en: 'Let''s see one more example of a closure, this time using the function parameters.
    Function parameters behave like local variables to this function, but they are
    implicitly created; you don''t need to use `var` for them. You can create a function
    that returns another function, which in turn returns its parent''s parameter,
    as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个闭包的例子，这次使用函数参数。函数参数对这个函数的行为就像局部变量一样，但它们是隐式创建的；你不需要为它们使用`var`。你可以创建一个函数，该函数返回另一个函数，而该函数又返回其父参数，如下所示：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You can use the function as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用该函数如下：
- en: '[PRE80]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Notice how `param++` was incremented after the function was defined and yet,
    when called, `inner()` returned the updated value. This demonstrates that the
    function maintains a reference to the scope where it was defined, and not to the
    variables and their values found in the scope during the function execution.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意观察`param++`在函数定义之后被增加，然而，当调用`inner()`时，它返回了更新后的值。这表明函数保持对其定义的作用域的引用，而不是在函数执行期间在该作用域中找到的变量及其值。
- en: Closures in a loop
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环中的闭包
- en: Let's take a look at a canonical rookie mistake when it comes to closures. It
    can easily lead to hard-to-spot bugs, because on the surface, everything looks
    normal.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看关于闭包的一个典型的初学者错误。它很容易导致难以发现的错误，因为从表面上看，一切看起来都很正常。
- en: 'Let''s loop three times, each time creating a new function that returns the
    loop sequence number. The new functions will be added to an array and the array
    is returned at the end. Here''s the function:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们循环三次，每次创建一个新的函数，该函数返回循环的序列号。新函数将被添加到数组中，并在最后返回该数组。以下是该函数：
- en: '[PRE81]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s run the function, assigning the result to the `arr` array:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个函数，将结果赋值给`arr`数组：
- en: '[PRE82]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now you have an array of three functions. Let''s invoke them by adding parentheses
    after each array element. The expected behavior is to see the loop sequence printed
    out as `0`, `1`, and `2`. Let''s try:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个包含三个函数的数组。让我们通过在每个数组元素后添加括号来调用它们。预期的行为是打印出循环序列`0`、`1`和`2`。让我们试试：
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Hmm, not quite as expected. What happened here? All three functions point to
    the same local variable: `i`. Why? The functions don''t remember values, they
    only keep a link (reference) to the environment where they were created. In this
    case, the `i` variable happens to live in the environment where the three functions
    were defined. So, all functions, when they need to access the value, reach back
    to the environment and find the most current value of `i`. After the loop, the
    `i` variable''s value is `3`. So, all three functions point to the same value.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，并不完全符合预期。这里发生了什么？所有三个函数都指向同一个局部变量：`i`。为什么？函数不记得值，它们只保持对它们创建的环境的链接（引用）。在这种情况下，`i`变量恰好存在于定义三个函数的环境中。因此，所有函数在需要访问值时都会回溯到环境，并找到`i`的最新值。循环结束后，`i`变量的值是`3`。所以，所有三个函数都指向同一个值。
- en: Why three and not two is another good question to think about for better understanding
    the `for` loop.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是三个而不是两个，这是另一个值得思考的问题，以更好地理解`for`循环。
- en: 'So, how do you implement the correct behavior? The answer is to use another
    closure, as shown in the following piece of code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你该如何实现正确的行为呢？答案是使用另一个闭包，如下面的代码片段所示：
- en: '[PRE84]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This gives you the expected result as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下预期的结果：
- en: '[PRE85]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, instead of just creating a function that returns `i`, you pass the `i`
    variable's current value to another immediate function. In this function, `i`
    becomes the local value `x`, and `x` has a different value every time.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你不仅创建了一个返回`i`的函数，而且还传递了`i`变量当前值到另一个立即执行的函数。在这个函数中，`i`成为局部值`x`，而`x`每次都有不同的值。
- en: 'Alternatively, you can use a normal (as opposed to an immediate) inner function
    to achieve the same result. The key is to use the middle function to localize
    the value of `i` at every iteration, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用一个正常的（而不是立即执行的）内部函数来达到相同的结果。关键是使用中间函数在每个迭代中将`i`的值本地化，如下所示：
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Getter and setter
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: Let's see two more examples of using closures. The first one involves the creation
    of the getter and setter functions. Imagine that you have a variable that should
    contain a specific type of value or a specific range of values. You don't want
    to expose this variable because you don't want just any part of the code to be
    able to alter its value. You can protect this variable inside a function and provide
    two additional functions-one to get the value and one to set it. The one that
    sets it could contain some logic to validate a value before assigning it to the
    protected variable. Let's make the validation part simple (for the sake of keeping
    the example short) and only accept number values.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用闭包的另外两个示例。第一个示例涉及创建获取器和设置器函数。想象一下，你有一个变量应该包含特定类型的值或特定范围的值。你不希望暴露这个变量，因为你不想让代码的任何部分都能改变它的值。你可以在函数内部保护这个变量，并提供两个额外的函数——一个用于获取值，一个用于设置值。设置值时，可以包含一些逻辑来验证值，然后再将其分配给受保护的变量。为了使示例简短，让我们简化验证部分，并只接受数值。
- en: 'You can place both the getter and the setter functions inside the same function
    that contains the `secret` variable so that they share the same scope:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将获取器和设置器函数放在包含`secret`变量的同一个函数中，这样它们就共享相同的范围：
- en: '[PRE87]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In this case, the function that contains everything is an immediate function.
    It defines `setValue()` and `getValue()` as global functions, while the `secret`
    variable remains local and inaccessible directly, as shown in the following example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，包含所有内容的函数是一个立即函数。它将`setValue()`和`getValue()`定义为全局函数，而`secret`变量保持局部且无法直接访问，如下例所示：
- en: '[PRE88]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Iterator
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: The last closure example (also the last example in this chapter) shows the use
    of a closure to accomplish an iterator functionality.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个闭包示例（也是本章的最后一个示例）展示了如何使用闭包来实现迭代器功能。
- en: You already know how to loop through a simple array, but there might be cases
    where you have a more complicated data structure with different rules as to what
    the sequence of values has. You can wrap the complicated who's next logic into
    an easy-to-use `next()` function. Then, you can simply call `next()` every time
    you need the consecutive value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何遍历简单的数组，但可能存在更复杂的数据结构，其值的序列有不同的规则。你可以将复杂的“下一个”逻辑包装在一个易于使用的`next()`函数中。然后，每次你需要连续的值时，只需简单地调用`next()`。
- en: 'For this example, let''s just use a simple array and not a complex data structure.
    Here''s an initialization function that takes an input array and also defines
    a secret pointer, `i`, that will always point to the next element in the array:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们只需使用一个简单的数组，而不是复杂的数据结构。以下是一个初始化函数，它接受一个输入数组，并定义一个秘密指针`i`，该指针始终指向数组中的下一个元素：
- en: '[PRE89]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Calling the `setup()` function with a data array will create the `next()` function
    for you, as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据数组调用`setup()`函数将为你创建`next()`函数，如下所示：
- en: '[PRE90]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'From there it''s easy and fun; calling the same function over and over again
    gives you the next element, which is as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，操作变得简单且有趣；反复调用相同的函数会给你下一个元素，如下所示：
- en: '[PRE91]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: IIFE versus blocks
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIFE 与块级作用域的比较
- en: 'As ES5 did not provide block scope, a popular pattern to achieve block scope
    was to use **immediately invoked function expressions** (**IIFE**), for example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ES5 没有提供块级作用域，实现块级作用域的一种流行模式是使用**立即调用的函数表达式**（**IIFE**），例如：
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: With ES6's support for block scopes, you can simply use a `let` or `const` declaration.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ES6 支持块级作用域，你可以简单地使用`let`或`const`声明。
- en: Arrow functions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'JavaScript uses almost all variations of arrows. With ES6, it introduces a
    new syntax for writing functions. We have always written function expressions
    in JavaScript. It is idiomatic to write code like this in JavaScript (this example
    is in jQuery):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 几乎使用了所有箭头函数的变体。随着 ES6 的引入，它为编写函数引入了一种新的语法。在 JavaScript 中，编写这样的代码是惯用的（以下示例使用
    jQuery）：
- en: '[PRE93]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is a typical jQuery event handler. The event handler `click()` function
    accepts a function as a parameter and we will simply create an inline anonymous
    function expression and pass it to the click function. This style of writing anonymous
    function expressions is known as **Lambda functions**. Several other languages
    support this feature. Though lambdas are more or less standard in new languages,
    JavaScript was responsible for popularizing their usage. However, the lambda syntax
    in JavaScript has not been very concise. ES6 arrow functions fill that gap and
    provide a concise syntax to write functions.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的jQuery事件处理器。事件处理器`click()`函数接受一个函数作为参数，我们将简单地创建一个内联匿名函数表达式并将其传递给`click`函数。这种编写匿名函数表达式的风格被称为**Lambda函数**。几种其他语言也支持这个特性。尽管Lambda在新的语言中或多或少是标准的，但JavaScript负责推广它们的用法。然而，JavaScript中的Lambda语法并不十分简洁。ES6箭头函数填补了这个空白，并提供了一种简洁的语法来编写函数。
- en: 'Arrow function provide a more concise syntax than the traditional function
    expressions; for example, consider the following piece of code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数提供了比传统函数表达式更简洁的语法；例如，考虑以下代码片段：
- en: '[PRE94]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Arrow functions syntax can simplify the function to the following line of code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的语法可以将函数简化为以下一行代码：
- en: '[PRE95]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As you can see, there is no `function` or `return` keyword anywhere. If your
    function has only one argument, you will end up writing the function as `identifer
    => expression`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，任何地方都没有`function`或`return`关键字。如果您的函数只有一个参数，您最终会写成`identifier => expression`的形式。
- en: 'When you need multiple arguments, you need to wrap the argument list in braces:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要多个参数时，您需要将参数列表用大括号括起来：
- en: '**No parameters**: `() => {...}`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无参数**：`() => {...}`'
- en: '**One parameter**: `a => {...}`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个参数**：`a => {...}`'
- en: '**More than one parameters**: `(a,b) => {...}`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个参数**：`(a,b) => {...}`'
- en: 'Arrow functions can have both the statement block bodies as well as expression
    bodies:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数可以同时具有语句块体和表达式体：
- en: '[PRE96]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Both are equivalent but the second variation is concise and preferred. Arrow
    functions are always anonymous. One important aspect of arrow functions that we
    will discuss a little later is that arrow functions do not bind their own values
    of the `this` keyword-the value is lexically derived from the surrounding scope.
    As we have not yet looked at the `this` keyword in detail, we will defer the discussion
    to a later part of this book.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都等效，但第二种变化更为简洁，更受欢迎。箭头函数始终是匿名的。我们稍后会讨论箭头函数的一个重要方面，即箭头函数不会绑定它们自己的`this`关键字值——这个值是从周围的作用域中按词法推导出来的。由于我们还没有详细查看`this`关键字，我们将把这个讨论推迟到本书的后面部分。
- en: Exercises
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write a function that converts a hexadecimal color, for example blue (`#0000FF`),
    into its RGB representation, `rgb(0, 0, 255)`. Name your function `getRGB()` and
    test it with the following code (hint: treat the string as an array of characters):'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，将十六进制颜色（例如蓝色`#0000FF`）转换为它的RGB表示形式，`rgb(0, 0, 255)`。将您的函数命名为`getRGB()`，并使用以下代码进行测试（提示：将字符串视为字符数组）：
- en: '[PRE97]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: What do each of these following lines print in the console?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每一行代码在控制台打印什么？
- en: '[PRE98]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: What does this following code alert?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码会弹出什么？
- en: '[PRE99]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: All these following examples alert `"Boo!"`. Can you explain why?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有以下示例都会弹出`"Boo!"`。你能解释为什么吗？
- en: 'Example 1:'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '示例 1:'
- en: '[PRE100]'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Example 2:'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '示例 2:'
- en: '[PRE101]'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Example 3:'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '示例 3:'
- en: '[PRE102]'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'You have now completed the introduction to the fundamental concepts related
    to functions in JavaScript. This has laid the groundwork that will allow you to
    quickly grasp the concepts of object-oriented JavaScript and the patterns used
    in modern JavaScript programming. So far, we''ve been avoiding the OO features,
    but as you have reached this point in the book, it''s only going to get more interesting
    from here on in. Let''s take a moment to review the topics discussed in this chapter:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经完成了与JavaScript中函数相关的基本概念的介绍。这为快速掌握面向对象的JavaScript概念和现代JavaScript编程中使用的模式奠定了基础。到目前为止，我们一直在避免使用OO特性，但随着您达到本书的这一部分，从现在开始只会越来越有趣。让我们花点时间回顾本章讨论的主题：
- en: The basics of how to define and invoke (call) a function using either a function
    declaration syntax or a function expression
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数声明语法或函数表达式语法定义和调用函数的基本方法
- en: Function parameters and their flexibility
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数及其灵活性
- en: Built-in functions-`parseInt()`, `parseFloat()`, `isNaN()`, `isFinite()`, and
    `eval()`-and the four functions to encode/decode a URL
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数-`parseInt()`、`parseFloat()`、`isNaN()`、`isFinite()`和`eval()`-以及用于编码/解码URL的四个函数
- en: The scope of variables in JavaScript-no curly braces scope, variables have only
    function scope and the scope chain
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中变量的作用域-没有花括号作用域，变量只有函数作用域和作用域链
- en: 'Functions as data-a function is like any other piece of data that you assign
    to a variable and a lot of interesting applications follow from this, such as:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为数据-一个函数就像任何其他分配给变量的数据一样，由此产生了许多有趣的应用，例如：
- en: Private functions and private variables
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有函数和私有变量
- en: Anonymous functions
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Callbacks
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数
- en: Immediate functions
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即执行函数
- en: Functions overwriting themselves
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自写函数覆盖
- en: Closures
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Arrow functions
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
