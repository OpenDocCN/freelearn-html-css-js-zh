<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-120"><a id="_idTextAnchor119"/>10</h1>
<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Test-Driving API Endpoints</h1>
<p>SvelteKit makes creating API endpoints a breeze. This chapter looks at how you can use tests to drive and prove your <span class="No-Break">API endpoints.</span></p>
<p>In the preceding chapter, you saw how we could push business logic out of SvelteKit and into plain JavaScript. We can make use of the extracted <strong class="source-inline">birthdayRepository</strong> object in the new API endpoints. We will now add endpoints for creating, updating, and getting birthdays using the <strong class="source-inline">addNew</strong>, <strong class="source-inline">replace</strong>, and <strong class="source-inline">getAll</strong> functions from <span class="No-Break">the repository.</span></p>
<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.1</em> shows how our system design is shaping up. The endpoints we’ll create in this chapter are very lightweight, thanks to the fully specified <span class="No-Break"><strong class="source-inline">birthdayRepository</strong></span><span class="No-Break"> object:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 10.1 – SvelteKit components flowing into the inner system" height="739" src="image/Figure_10.1_B19611.jpg" width="1059"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – SvelteKit components flowing into the inner system</p>
<p>We will cover the following key topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Creating a service test <span class="No-Break">with Playwright</span></li>
<li>Adding an API endpoint for <span class="No-Break">retrieving data</span></li>
<li>Adding an API endpoint for <span class="No-Break">saving data</span></li>
<li>Adding an API endpoint for <span class="No-Break">updating data</span></li>
</ul>
<p>By the end of the chapter, you’ll have learned how to implement API endpoints using <span class="No-Break">test-driven development.</span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Creating a service test with Playwright</h1>
<p>You’ve <a id="_idIndexMarker331"/>already seen <a id="_idIndexMarker332"/>how Playwright can be used to create end-to-end tests that drive the application through the web browser interface. It can also be used to drive the API endpoints directly, and that’s what you’ll learn to do in this section. The benefit of writing up-front Playwright API tests is that we can very carefully plan out how our API <span class="No-Break">will look.</span></p>
<p>We’ll write just a single test named <strong class="source-inline">creating and reading a birthday</strong>. It will do two things: first, create a request to <strong class="source-inline">POST</strong> <strong class="source-inline">/api/birthdays</strong> that will create a birthday. Then we’ll call <strong class="source-inline">GET</strong> <strong class="source-inline">/api/birthdays</strong> and check that the previously created birthday is returned in <span class="No-Break">the response:</span></p>
<ol>
<li>Create a new file named <strong class="source-inline">tests/api/birthdays.test.js</strong> with the following content, which is the first half of <span class="No-Break">that test:</span><pre class="source-code">
import { expect, test } from '@playwright/test';
test('creating and reading a birthday', async ({
  request
}) =&gt; {
  const newBirthday = await request.post(
    '/api/birthdays',
    {
      data: {
        name: 'Nyx',
        dob: '1993-02-04'
      }
    }
  );
  expect(newBirthday.ok()).toBeTruthy();
});</pre></li>
</ol>
<p>The<a id="_idIndexMarker333"/> preceding code snippet uses the test’s <a id="_idIndexMarker334"/>request parameter. It has a <strong class="source-inline">request.post</strong> method that we invoke to make the API request. The <strong class="source-inline">data</strong> prop is the JSON object we want to send across. Playwright takes care of converting that into an HTTP request and response. The request looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
POST http://localhost:1234/api/birthdays
{
  "name": "Nyx",
  "dob": "1993-02-04"
}</pre>
<p>The returned object, which we call <strong class="source-inline">newBirthday</strong>, has an <strong class="source-inline">ok</strong> method that we call to figure out whether the endpoint returned a <span class="No-Break"><strong class="source-inline">200</strong></span><span class="No-Break"> response.</span></p>
<p class="callout-heading">Mixing assertions into test actions</p>
<p class="callout">In previous chapters, all our tests have been structured in the <em class="italic">Arrange-Act-Assert</em> format. When it comes to Playwright tests, it’s okay to occasionally have repeated cycles of <em class="italic">Act</em>-<em class="italic">Assert</em>, ending up with something <span class="No-Break">like </span><span class="No-Break"><em class="italic">Arrange-Act-Assert-Act-Assert…</em></span><span class="No-Break">.</span></p>
<p class="callout">I wouldn’t do that in my unit tests, but in end-to-end and service tests, it can sometimes make sense because they help the tests play out <strong class="bold">user scenarios</strong>. The tests follow the steps that a typical user would take. The assertions sprinkled throughout the test serve as checkpoints to check whether the test is on the <span class="No-Break">right path.</span></p>
<ol>
<li value="2">Next, complete <a id="_idIndexMarker335"/>the test with a call to the <a id="_idIndexMarker336"/>GET <strong class="source-inline">/api/birthdays</strong> endpoint. Of interest here is the use of <strong class="source-inline">expect.anything()</strong> to say <em class="italic">I expect an ID back, but I don’t care what </em><span class="No-Break"><em class="italic">it is</em></span><span class="No-Break">:</span><pre class="source-code">
test('creating and reading a birthday', async ({
  request
}) =&gt; {
  ...
  const birthdays = await request.get(
    '/api/birthdays'
  );
  expect(birthdays.ok()).toBeTruthy();
  expect(await birthdays.json()).toEqual({
    birthdays: expect.arrayContaining([
      {
        name: 'Nyx',
        dob: '1993-02-04',
        id: expect.anything()
      }
    ])
  });
});</pre></li>
</ol>
<p>That completes<a id="_idIndexMarker337"/> the test; go ahead and run the test and<a id="_idIndexMarker338"/> check that it currently fails (since the endpoint doesn’t <span class="No-Break">exist yet).</span></p>
<p class="callout-heading">Avoiding data clashes in Playwright tests</p>
<p class="callout">The <a id="_idIndexMarker339"/>preceding example used the name <strong class="source-inline">Nyx</strong> in the test example. This name hasn’t been used before, but if you had used one of the previous names, such as <strong class="source-inline">Hercules</strong> or <strong class="source-inline">Athena</strong>, you would have seen other <span class="No-Break">tests fail.</span></p>
<p class="callout">The current Playwright test suite does not clear the test database between individual test runs. Here, we solved the issue by ensuring that each of our tests uses independent pieces <span class="No-Break">of data.</span></p>
<p class="callout">An alternative approach would be to always clean down the database before each test or test suite, similar to how the Vitest unit tests <span class="No-Break">are written.</span></p>
<p class="callout">There’s an advantage to the first approach, however: you can point Playwright to deployed environments that are already primed with data that you don’t control and still expect the tests <span class="No-Break">to pass.</span></p>
<ol>
<li>Add a second test for updating a birthday using the <strong class="source-inline">PUT</strong> HTTP verb. The request will look <span class="No-Break">like this:</span><pre class="source-code">
PUT http://localhost:1234/api/birthday/abc123
{
  "name": "Nyx",
  "dob": "1992-01-02"
}</pre></li>
</ol>
<p>Start with the first half of the test, given as follows. Notice how this pulls out the returned <strong class="source-inline">id</strong> field so<a id="_idIndexMarker340"/> that we can use it in the <a id="_idIndexMarker341"/>second half of <span class="No-Break">the test:</span></p>
<pre class="source-code">
test('updating a birthday', async ({ request }) =&gt; {
  const newBirthday = await request.post(
    '/api/birthdays',
    {
      data: {
        name: 'Nyx',
        dob: '1993-02-04'
      }
    }
  );
  expect(newBirthday.ok()).toBeTruthy();
  const { id } = await newBirthday.json();
});</pre>
<ol>
<li value="2">Then add the second half of the test, which performs the <strong class="source-inline">PUT</strong> request using <strong class="source-inline">id</strong> and checks <span class="No-Break">the result:</span><pre class="source-code">
test('updating a birthday', async ({ request }) =&gt; {
  ...
  const birthdays = await request.put(
    `/api/birthday/${id}`,
    {
      data: {
        name: 'Nyxx',
        dob: '1992-01-03'
      }
    }
  );
  expect(birthdays.ok()).toBeTruthy();
  const updatedBirthdays = await request.get(
    '/api/birthdays'
  );
  expect(await updatedBirthdays.json()).toEqual({
    birthdays: expect.arrayContaining([
      {
        name: 'Nyxx',
        dob: '1992-01-03',
        id
      }
    ])
  });
});</pre></li>
</ol>
<p>This last <a id="_idIndexMarker342"/>expectation doesn’t make use of <strong class="source-inline">expect.anything</strong>. Instead, it checks <a id="_idIndexMarker343"/>that <strong class="source-inline">id</strong> remains <span class="No-Break">the same.</span></p>
<p>That completes the two Playwright tests, covering the three new endpoints. In the next section, we’ll use the <strong class="source-inline">GET</strong> request to retrieve all the birthdays from <span class="No-Break">the system.</span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Adding an API endpoint for retrieving data</h1>
<p>Now <a id="_idIndexMarker344"/>we get on to the fun bit: introducing new functionality for the API. In a SvelteKit application, a <strong class="source-inline">GET</strong> request is very directly specified by creating a function named <strong class="source-inline">GET</strong> inside of <span class="No-Break">a route.</span></p>
<p>Although we won’t use it for our endpoint, this function has a <strong class="source-inline">params</strong> argument that contains the <strong class="source-inline">route</strong> parameter. You’ll see this later in the chapter when we implement the <strong class="source-inline">PUT</strong> request in the <em class="italic">Adding an API endpoint for updating </em><span class="No-Break"><em class="italic">data</em></span><span class="No-Break"> section.</span></p>
<p>Valid responses from the endpoint must be proper response objects. We can use SvelteKit’s JSON helper to define a valid JSON response. Error responses are handled by throwing an exception that is built by calling SvelteKit’s error helper. We’ll use both of <span class="No-Break">these now.</span></p>
<p class="callout-heading">The json helper in Node versions below 18</p>
<p class="callout">Calls to the <strong class="source-inline">json</strong> function may fail with a <strong class="source-inline">Response is not defined</strong> error. If you see this error when implementing the following tests, you can<a id="_idIndexMarker345"/> install the <strong class="bold">node-fetch</strong> package (<a href="https://github.com/node-fetch/node-fetch">https://github.com/node-fetch/node-fetch</a>) and ensure it loads as part of your Vitest <span class="No-Break">setup files.</span></p>
<p>Let’s start by defining a new <span class="No-Break">test suite:</span></p>
<ol>
<li>Create a new test file, <strong class="source-inline">src/routes/api/birthdays/server.test.js</strong>, that begins with the following <strong class="source-inline">import</strong> statements. The <strong class="source-inline">birthdayRepository</strong> module is imported so that the repository can be populated before calling the <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> function:</span><pre class="source-code">
import {
  describe, it, expect, beforeEach
} from 'vitest';
import {
  createBirthday
} from 'src/factories/birthday.js';
import
   as birthdayRepository
from '$lib/server/birthdayRepository.js';
import { GET } from './+server.js';</pre></li>
<li>Next <a id="_idIndexMarker346"/>define the following helper method, <strong class="source-inline">bodyOfResponse</strong>, which we’ll use in the first test to pull out data from the HTTP response. This can go just below <span class="No-Break">the imports:</span><pre class="source-code">
const bodyOfResponse = (response) =&gt; response.json();</pre></li>
<li>Then, create a new <strong class="source-inline">describe</strong> block with the following test. It creates two birthdays and checks that they <span class="No-Break">are returned:</span><pre class="source-code">
describe('GET', () =&gt; {
  it('returns all the birthdays from the store', async
  () =&gt; {
    birthdayRepository.addNew(
      createBirthday('Hercules', '2010-04-05')
      );
    birthdayRepository.addNew(
      createBirthday('Ares', '2008-03-02')
    );
    const { birthdays } = await bodyOfResponse(GET());
    expect(birthdays).toEqual([
      expect.objectContaining(
        createBirthday('Hercules', '2010-04-05')
      ),
      expect.objectContaining(
        createBirthday('Ares', '2008-03-02')
      )
    ]);
  });
});</pre></li>
</ol>
<p class="callout-heading">Testing array responses</p>
<p class="callout">I find that when I’m testing array objects, it’s always best to use two (and sometimes three) items in the list rather than just one. That way, it’s clear that the test is operating on lists of items, not just <span class="No-Break">single items.</span></p>
<ol>
<li value="4">To make<a id="_idIndexMarker347"/> that test pass, create a new file named <strong class="source-inline">src/routes/api/birthdays/+server.js</strong> with the following content. The implementation works like this: it passes the request right through to the store using the <strong class="source-inline">getAll</strong> function and then wraps the response with a call to SvelteKit’s <span class="No-Break"><strong class="source-inline">json</strong></span><span class="No-Break"> function:</span><pre class="source-code">
import {
  getAll
} from '$lib/server/birthdayRepository.js';
import { json } from '@sveltejs/kit';
export const GET = () =&gt;
  json({ birthdays: getAll() });</pre></li>
</ol>
<p>That completes the <strong class="source-inline">GET</strong> request. Next, we’ll work on the <strong class="source-inline">POST</strong> and <span class="No-Break"><strong class="source-inline">PUT</strong></span><span class="No-Break"> requests.</span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Adding an API endpoint for saving data</h1>
<p>In this <a id="_idIndexMarker348"/>section, we’ll start by adding the <strong class="source-inline">POST</strong> request handler function for saving data and then continue with the <strong class="source-inline">PUT</strong> function, in its own route file, for <span class="No-Break">updating data.</span></p>
<p>Let’s begin with a <span class="No-Break">test helper:</span></p>
<ol>
<li>Create a new file, <strong class="source-inline">src/factories/request.js</strong>, with the following content. This will be used by both the <strong class="source-inline">POST</strong> and <strong class="source-inline">PUT</strong> functions to read the data of the request. SvelteKit will pass a <strong class="source-inline">Request</strong> argument. The only bit of this we need to provide is the <strong class="source-inline">json</strong> method, as <span class="No-Break">shown here:</span><pre class="source-code">
export const createRequest = (json) =&gt; ({
  json: () =&gt; Promise.resolve(json)
});</pre></li>
</ol>
<p class="callout-heading">Providing minimal versions of collaborating objects</p>
<p class="callout">SvelteKit passes the <strong class="source-inline">Request</strong> objects into our request handler functions. But for our unit tests we don’t need fully formed <strong class="source-inline">Request</strong> objects, we just need an object that implements the parts of the interface that we use. Our application code doesn’t use anything but the <strong class="source-inline">json</strong> method for reading the request body in JSON format, so that’s the only method <span class="No-Break">we need.</span></p>
<ol>
<li value="2">Now move to <strong class="source-inline">src/api/birthdays/server.test.js</strong> and add an <strong class="source-inline">import</strong> statement for the <strong class="source-inline">createRequest</strong> method. Also, update the <strong class="source-inline">+server.js</strong> import to include the <strong class="source-inline">POST</strong> request <span class="No-Break">handler function:</span><pre class="source-code">
<strong class="bold">import {</strong>
<strong class="bold">  createRequest</strong>
<strong class="bold">} from 'src/factories/request.js';</strong>
import { GET<strong class="bold">, POST</strong> } from './+server.js';</pre></li>
<li>Next, add a new <strong class="source-inline">describe</strong> block for the <strong class="source-inline">POST</strong> function, just below the <strong class="source-inline">describe</strong> block <a id="_idIndexMarker349"/>for the <strong class="source-inline">GET</strong> function, and include this <span class="No-Break">one test:</span><pre class="source-code">
describe('POST', () =&gt; {
  beforeEach(birthdayRepository.clear);
  it('saves the birthday in the store', async () =&gt; {
    await POST({
      request: createRequest(
        createBirthday('Hercules', '2009-03-01')
      )
    });
    expect(birthdayRepository.getAll()).toHaveLength(1
      );
    expect(birthdayRepository.getAll()[0]).toContain(
      createBirthday('Hercules', '2009-03-01')
    );
  });
});</pre></li>
<li>To make that pass, first update the import in <strong class="source-inline">src/api/birthdays/+server.js</strong> to include the <span class="No-Break"><strong class="source-inline">addNew</strong></span><span class="No-Break"> function:</span><pre class="source-code">
import {
  <strong class="bold">addNew,</strong>
  getAll
} from '$lib/server/birthdayRepository.js';</pre></li>
<li>Continue <a id="_idIndexMarker350"/>by adding a definition for <strong class="source-inline">POST</strong>, as shown in the following code block. After this change, your test <span class="No-Break">should pass:</span><pre class="source-code">
export const POST = async ({ request }) =&gt; {
  const { name, dob } = await request.json();
  addNew({ name, dob });
};</pre></li>
<li>Now that we have data saved into the repository, it’s time to check the HTTP response. We want any API caller to receive the same data back. The following test makes use of the <strong class="source-inline">toContain</strong> matcher rather than <strong class="source-inline">toEqual</strong>. That’s because we already know that the response will contain an <strong class="source-inline">id</strong> field that isn’t relevant to <span class="No-Break">this test:</span><pre class="source-code">
it('returns a json response with the data', async () =&gt; {
  const response = await POST({
    request: createRequest(
      createBirthday('Hercules', '2009-03-01')
    )
  });
  expect(await bodyOfResponse(response)).toContain(
    createBirthday('Hercules', '2009-03-01')
  );
});</pre></li>
</ol>
<p class="callout-heading">Testing the presence of an id field</p>
<p class="callout">Why is the <strong class="source-inline">id</strong> field <a id="_idIndexMarker351"/>not included in the expectation of this test? Because it has a different lifecycle from the other data. This test verifies that the user-provided information is stored. But the <strong class="source-inline">id</strong> field is auto-generated, so it belongs to a separate test. I’ve omitted it here because it’s already tested in both the repository and the Playwright API test, but you may feel more comfortable including <span class="No-Break">the test.</span></p>
<ol>
<li value="7">To make<a id="_idIndexMarker352"/> the test pass, add a <strong class="source-inline">return</strong> value to the function that uses the <strong class="source-inline">json</strong> <span class="No-Break">function import:</span><pre class="source-code">
export const POST = async ({ request }) =&gt; {
  const { name, dob } = await request.json();
  <strong class="bold">const result = </strong>addNew({ name, dob });
  <strong class="bold">return json(result);</strong>
};</pre></li>
<li>The final test for the <strong class="source-inline">POST</strong> request handler is to check that the function throws an exception if the data is invalid. Throwing errors can complicate tests: here, the test uses a call to <strong class="source-inline">expect.hasAssertions</strong> to ensure that Vitest will fail the test if the call does <em class="italic">not</em> raise <span class="No-Break">an error:</span><pre class="source-code">
it('throws an error if the data is invalid', async () =&gt; {
  expect.hasAssertions();
  try {
    await POST({
      request: createRequest(
        createBirthday('Ares', '')
      )
    });
  } catch (error) {
    expect(error.status).toEqual(422);
    expect(error.body).toEqual({
      message:
        'Please provide a date of birth in the YYYY-
          MM-DD format.'
    });
  }
});</pre></li>
</ol>
<p>Try <a id="_idIndexMarker353"/>running this test now: you’ll see the <strong class="source-inline">expected any number of assertions, but got none</strong> failure. That is courtesy of the <strong class="source-inline">hasAssertions</strong> statement at the top of <span class="No-Break">the test.</span></p>
<p class="callout-heading">Understanding the hasAssertions helper</p>
<p class="callout">Try deleting the <strong class="source-inline">expect.hasAssertions</strong> line from the test. You will notice that the test already passes. That’s <a id="_idIndexMarker354"/>because the expectations were never met. This is the point of the <strong class="source-inline">hasAssertions</strong> call: it is useful in tests that rely on having expectations within <strong class="source-inline">catch</strong> blocks that won’t be called until you implement the exception-throwing behavior in your <span class="No-Break">application code.</span></p>
<ol>
<li value="9">To make that pass, first update the <strong class="source-inline">import</strong> statement in <strong class="source-inline">src/api/birthdays/+server.js</strong> to include the <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> helper:</span><pre class="source-code">
import { json<strong class="bold">, error</strong> } from '@sveltejs/kit';</pre></li>
<li>Then update the <strong class="source-inline">POST</strong> function to re-package any errors from the repository into an <strong class="source-inline">error</strong> object that’s <span class="No-Break">then thrown:</span><pre class="source-code">
export const POST = async ({ request }) =&gt; {
  const { name, dob } = await request.json();
  const result = addNew({ name, dob });
  <strong class="bold">if (result.error) throw error(422, result.error);</strong>
  return json(result);
};</pre></li>
</ol>
<p>That <a id="_idIndexMarker355"/>completes the <strong class="source-inline">POST</strong> request handler for inserting new birthdays; the next section completes the chapter with the addition of the <strong class="source-inline">PUT</strong> request handler for updating <span class="No-Break">existing birthdays.</span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Adding an API endpoint for updating data</h1>
<p>The<a id="_idIndexMarker356"/> final piece of the puzzle is to add a <strong class="source-inline">PUT</strong> request handler function for dealing with updates. Similar to the <strong class="source-inline">POST</strong> function, we must provide the request body using the <span class="No-Break"><strong class="source-inline">createRequest</strong></span><span class="No-Break"> helper.</span></p>
<p>The form of our <strong class="source-inline">PUT</strong> request means that <strong class="source-inline">id</strong> is passed as a parameter in the URL, <span class="No-Break">like this:</span></p>
<p>Here’s a reminder of how the URL must <span class="No-Break">be passed:</span></p>
<pre class="source-code">
PUT http://localhost:1234/api/birthday/abc123</pre>
<p>To make SvelteKit register the <strong class="source-inline">abc123</strong> value as a parameter, we need to create a new route directory at <strong class="source-inline">src/routes/api/birthday/[id]</strong>. SvelteKit will then know that <strong class="source-inline">abc123</strong> matches the <strong class="source-inline">[id]</strong> bit of the directory path. The directory itself will then contain the <strong class="source-inline">+server.js</strong> file and <span class="No-Break">its tests.</span></p>
<p>Let’s start with <span class="No-Break">the tests:</span></p>
<ol>
<li>Create a new file named <strong class="source-inline">src/routes/api/birthday/[id]/server.test.js</strong> and add the following imports. This has everything we’ve used previously for the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> functions, together with an import for the <span class="No-Break"><strong class="source-inline">PUT</strong></span><span class="No-Break"> function:</span><pre class="source-code">
import {
  describe,
  it,
  expect,
  beforeEach
} from 'vitest';
import
   as birthdayRepository
from '$lib/server/birthdayRepository.js';
import {
  createBirthday
} from 'src/factories/birthday.js';
import {
  createRequest
} from 'src/factories/request.js';
import { PUT } from './+server.js';</pre></li>
<li>Then <a id="_idIndexMarker357"/>create this new <strong class="source-inline">describe</strong> block. It contains a <strong class="source-inline">beforeEach</strong> block that not only clears the repository but inserts a new item, ready <span class="No-Break">for editing:</span><pre class="source-code">
describe('PUT', () =&gt; {
  beforeEach(() =&gt; {
    birthdayRepository.clear();
    birthdayRepository.addNew(
      createBirthday('Hercules', '2009-03-01')
    );
  });
});</pre></li>
<li>Before we get to the first test, add the <span class="No-Break">following helper:</span><pre class="source-code">
const storedId = () =&gt;
  birthdayRepository.getAll()[0].id;</pre></li>
<li>Now add the first test, as shown here. It mimics SvelteKit’s call semantics by passing <a id="_idIndexMarker358"/>a new <strong class="source-inline">params</strong> object into <span class="No-Break">the handler:</span><pre class="source-code">
it('updates the birthday in the store', async () =&gt; {
  await PUT({
    request: createRequest(
      createBirthday('Hercules', '1999-03-01')
    ),
    params: { id: storedId() }
  });
  expect(birthdayRepository.getAll()).toHaveLength(1);
  expect(birthdayRepository.getAll()[0]).toContain(
    createBirthday('Hercules', '1999-03-01')
  );
});</pre></li>
<li>To make that pass, create a new file named <strong class="source-inline">src/routes/api/birthday/[id]/+server.js</strong> with the following content. This should immediately make the <span class="No-Break">test pass:</span><pre class="source-code">
import {
  replace
} from '$lib/server/birthdayRepository.js';
export const PUT = async ({
  request,
  params: { id }
}) =&gt; {
  const { name, dob } = await request.json();
  const result = replace(id, { name, dob });
};</pre></li>
<li>For the<a id="_idIndexMarker359"/> next test, we’ll begin by repeating a helper from the <strong class="source-inline">GET</strong> tests. Add the <strong class="source-inline">bodyOfResponse</strong> function, as <span class="No-Break">shown here:</span><pre class="source-code">
const bodyOfResponse = (response) =&gt; response.json();</pre></li>
<li>Then, add the next test, which uses this function to check <span class="No-Break">the response:</span><pre class="source-code">
it('returns a json response with the data', async () =&gt; {
  const response = await PUT({
    request: createRequest(
      createBirthday('Hercules', '1999-03-01')
    ),
    params: { id: storedId() }
  });
  expect(await bodyOfResponse(response)).toContain(
    createBirthday('Hercules', '1999-03-01', {
      id: storedId()
    })
  );
});</pre></li>
<li>To make that pass, start by adding the import for <strong class="source-inline">json</strong> in the <span class="No-Break">application code:</span><pre class="source-code">
import { json } from '@sveltejs/kit';</pre></li>
<li>Then, update<a id="_idIndexMarker360"/> the <strong class="source-inline">PUT</strong> function to return the result of the repository action, just as we did with the <strong class="source-inline">POST</strong> request <span class="No-Break">handler function:</span><pre class="source-code">
export const PUT = async ({
  request,
  params: { id }
}) =&gt; {
  const { name, dob } = await request.json();
  const result = replace(id, { name, dob });
  <strong class="bold">return json(result);</strong>
};</pre></li>
<li>The final test repeats the mechanics of the final <strong class="source-inline">POST</strong> test, checking what happens if the data <span class="No-Break">is invalid:</span><pre class="source-code">
it('throws an error if the data is invalid', async () =&gt; {
  expect.hasAssertions();
  try {
    await PUT({
      request: createRequest(
        createBirthday('Hercules', '')
      ),
      params: { id: storedId() }
    });
  } catch (error) {
    expect(error.status).toEqual(422);
    expect(error.body).toEqual({
      message:
        'Please provide a date of birth in the YYYY-
          MM-DD format.'
    });
  }
});</pre></li>
<li>To <a id="_idIndexMarker361"/>make that pass, start by updating the <strong class="source-inline">import</strong> statement in the application code to include the <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> function:</span><pre class="source-code">
import { json<strong class="bold">, error</strong> } from '@sveltejs/kit';</pre></li>
<li>Finally, include the guard clause in the <strong class="source-inline">PUT</strong> function, as <span class="No-Break">shown here:</span><pre class="source-code">
export const PUT = async ({
  request,
  params: { id }
}) =&gt; {
  const { name, dob } = await request.json();
  const result = replace(id, { name, dob });
  <strong class="bold">if (result.error) throw error(422, result.error);</strong>
  return json(result);
};</pre></li>
</ol>
<p>That’s it. If you run both the Vitest and Playwright tests now, you should find they <span class="No-Break">all pass.</span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Summary</h1>
<p>This chapter has shown how to make quick work of API endpoints. Playwright tests can be used to specify how an API should behave, and the unit tests can be used to drive the design and ensure that we end up with <span class="No-Break">minimal implementation.</span></p>
<p>The next chapter completes the API story arc: we will update the form actions to use the new API endpoints rather than going directly to <span class="No-Break">the repository.</span></p>
</div>
</div></body></html>