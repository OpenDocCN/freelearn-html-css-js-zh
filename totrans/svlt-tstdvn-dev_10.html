<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-120"><a id="_idTextAnchor119"/>10</h1>
<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Test-Driving API Endpoints</h1>
<p>SvelteKit makes creating API endpoints a breeze. This chapter looks at how you can use tests to drive and prove your API endpoints.</p>
<p>In the preceding chapter, you saw how we could push business logic out of SvelteKit and into plain JavaScript. We can make use of the extracted <code>birthdayRepository</code> object in the new API endpoints. We will now add endpoints for creating, updating, and getting birthdays using the <code>addNew</code>, <code>replace</code>, and <code>getAll</code> functions from the repository.</p>
<p><em class="italic">Figure 10</em><em class="italic">.1</em> shows how our system design is shaping up. The endpoints we’ll create in this chapter are very lightweight, thanks to the fully specified <code>birthdayRepository</code> object:</p>
<div><div><img alt="Figure 10.1 – SvelteKit components flowing into the inner system" height="739" src="img/Figure_10.1_B19611.jpg" width="1059"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – SvelteKit components flowing into the inner system</p>
<p>We will cover the following key topics in this chapter:</p>
<ul>
<li>Creating a service test with Playwright</li>
<li>Adding an API endpoint for retrieving data</li>
<li>Adding an API endpoint for saving data</li>
<li>Adding an API endpoint for updating data</li>
</ul>
<p>By the end of the chapter, you’ll have learned how to implement API endpoints using test-driven development.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start</a>.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Creating a service test with Playwright</h1>
<p>You’ve <a id="_idIndexMarker331"/>already seen <a id="_idIndexMarker332"/>how Playwright can be used to create end-to-end tests that drive the application through the web browser interface. It can also be used to drive the API endpoints directly, and that’s what you’ll learn to do in this section. The benefit of writing up-front Playwright API tests is that we can very carefully plan out how our API will look.</p>
<p>We’ll write just a single test named <code>creating and reading a birthday</code>. It will do two things: first, create a request to <code>POST</code> <code>/api/birthdays</code> that will create a birthday. Then we’ll call <code>GET</code> <code>/api/birthdays</code> and check that the previously created birthday is returned in the response:</p>
<ol>
<li>Create a new file named <code>tests/api/birthdays.test.js</code> with the following content, which is the first half of that test:<pre class="source-code">
import { expect, test } from '@playwright/test';
test('creating and reading a birthday', async ({
  request
}) =&gt; {
  const newBirthday = await request.post(
    '/api/birthdays',
    {
      data: {
        name: 'Nyx',
        dob: '1993-02-04'
      }
    }
  );
  expect(newBirthday.ok()).toBeTruthy();
});</pre></li>
</ol>
<p>The<a id="_idIndexMarker333"/> preceding code snippet uses the test’s <a id="_idIndexMarker334"/>request parameter. It has a <code>request.post</code> method that we invoke to make the API request. The <code>data</code> prop is the JSON object we want to send across. Playwright takes care of converting that into an HTTP request and response. The request looks like this:</p>
<pre class="source-code">
POST http://localhost:1234/api/birthdays
{
  "name": "Nyx",
  "dob": "1993-02-04"
}</pre>
<p>The returned object, which we call <code>newBirthday</code>, has an <code>ok</code> method that we call to figure out whether the endpoint returned a <code>200</code> response.</p>
<p class="callout-heading">Mixing assertions into test actions</p>
<p class="callout">In previous chapters, all our tests have been structured in the <em class="italic">Arrange-Act-Assert</em> format. When it comes to Playwright tests, it’s okay to occasionally have repeated cycles of <em class="italic">Act</em>-<em class="italic">Assert</em>, ending up with something like <em class="italic">Arrange-Act-Assert-Act-Assert…</em>.</p>
<p class="callout">I wouldn’t do that in my unit tests, but in end-to-end and service tests, it can sometimes make sense because they help the tests play out <strong class="bold">user scenarios</strong>. The tests follow the steps that a typical user would take. The assertions sprinkled throughout the test serve as checkpoints to check whether the test is on the right path.</p>
<ol>
<li value="2">Next, complete <a id="_idIndexMarker335"/>the test with a call to the <a id="_idIndexMarker336"/>GET <code>/api/birthdays</code> endpoint. Of interest here is the use of <code>expect.anything()</code> to say <em class="italic">I expect an ID back, but I don’t care what </em><em class="italic">it is</em>:<pre class="source-code">
test('creating and reading a birthday', async ({
  request
}) =&gt; {
  ...
  const birthdays = await request.get(
    '/api/birthdays'
  );
  expect(birthdays.ok()).toBeTruthy();
  expect(await birthdays.json()).toEqual({
    birthdays: expect.arrayContaining([
      {
        name: 'Nyx',
        dob: '1993-02-04',
        id: expect.anything()
      }
    ])
  });
});</pre></li>
</ol>
<p>That completes<a id="_idIndexMarker337"/> the test; go ahead and run the test and<a id="_idIndexMarker338"/> check that it currently fails (since the endpoint doesn’t exist yet).</p>
<p class="callout-heading">Avoiding data clashes in Playwright tests</p>
<p class="callout">The <a id="_idIndexMarker339"/>preceding example used the name <code>Nyx</code> in the test example. This name hasn’t been used before, but if you had used one of the previous names, such as <code>Hercules</code> or <code>Athena</code>, you would have seen other tests fail.</p>
<p class="callout">The current Playwright test suite does not clear the test database between individual test runs. Here, we solved the issue by ensuring that each of our tests uses independent pieces of data.</p>
<p class="callout">An alternative approach would be to always clean down the database before each test or test suite, similar to how the Vitest unit tests are written.</p>
<p class="callout">There’s an advantage to the first approach, however: you can point Playwright to deployed environments that are already primed with data that you don’t control and still expect the tests to pass.</p>
<ol>
<li>Add a second test for updating a birthday using the <code>PUT</code> HTTP verb. The request will look like this:<pre class="source-code">
PUT http://localhost:1234/api/birthday/abc123
{
  "name": "Nyx",
  "dob": "1992-01-02"
}</pre></li>
</ol>
<p>Start with the first half of the test, given as follows. Notice how this pulls out the returned <code>id</code> field so<a id="_idIndexMarker340"/> that we can use it in the <a id="_idIndexMarker341"/>second half of the test:</p>
<pre class="source-code">
test('updating a birthday', async ({ request }) =&gt; {
  const newBirthday = await request.post(
    '/api/birthdays',
    {
      data: {
        name: 'Nyx',
        dob: '1993-02-04'
      }
    }
  );
  expect(newBirthday.ok()).toBeTruthy();
  const { id } = await newBirthday.json();
});</pre>
<ol>
<li value="2">Then add the second half of the test, which performs the <code>PUT</code> request using <code>id</code> and checks the result:<pre class="source-code">
test('updating a birthday', async ({ request }) =&gt; {
  ...
  const birthdays = await request.put(
    `/api/birthday/${id}`,
    {
      data: {
        name: 'Nyxx',
        dob: '1992-01-03'
      }
    }
  );
  expect(birthdays.ok()).toBeTruthy();
  const updatedBirthdays = await request.get(
    '/api/birthdays'
  );
  expect(await updatedBirthdays.json()).toEqual({
    birthdays: expect.arrayContaining([
      {
        name: 'Nyxx',
        dob: '1992-01-03',
        id
      }
    ])
  });
});</pre></li>
</ol>
<p>This last <a id="_idIndexMarker342"/>expectation doesn’t make use of <code>expect.anything</code>. Instead, it checks <a id="_idIndexMarker343"/>that <code>id</code> remains the same.</p>
<p>That completes the two Playwright tests, covering the three new endpoints. In the next section, we’ll use the <code>GET</code> request to retrieve all the birthdays from the system.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Adding an API endpoint for retrieving data</h1>
<p>Now <a id="_idIndexMarker344"/>we get on to the fun bit: introducing new functionality for the API. In a SvelteKit application, a <code>GET</code> request is very directly specified by creating a function named <code>GET</code> inside of a route.</p>
<p>Although we won’t use it for our endpoint, this function has a <code>params</code> argument that contains the <code>route</code> parameter. You’ll see this later in the chapter when we implement the <code>PUT</code> request in the <em class="italic">Adding an API endpoint for updating </em><em class="italic">data</em> section.</p>
<p>Valid responses from the endpoint must be proper response objects. We can use SvelteKit’s JSON helper to define a valid JSON response. Error responses are handled by throwing an exception that is built by calling SvelteKit’s error helper. We’ll use both of these now.</p>
<p class="callout-heading">The json helper in Node versions below 18</p>
<p class="callout">Calls to the <code>json</code> function may fail with a <code>Response is not defined</code> error. If you see this error when implementing the following tests, you can<a id="_idIndexMarker345"/> install the <strong class="bold">node-fetch</strong> package (<a href="https://github.com/node-fetch/node-fetch">https://github.com/node-fetch/node-fetch</a>) and ensure it loads as part of your Vitest setup files.</p>
<p>Let’s start by defining a new test suite:</p>
<ol>
<li>Create a new test file, <code>src/routes/api/birthdays/server.test.js</code>, that begins with the following <code>import</code> statements. The <code>birthdayRepository</code> module is imported so that the repository can be populated before calling the <code>GET</code> function:<pre class="source-code">
import {
  describe, it, expect, beforeEach
} from 'vitest';
import {
  createBirthday
} from 'src/factories/birthday.js';
import
   as birthdayRepository
from '$lib/server/birthdayRepository.js';
import { GET } from './+server.js';</pre></li>
<li>Next <a id="_idIndexMarker346"/>define the following helper method, <code>bodyOfResponse</code>, which we’ll use in the first test to pull out data from the HTTP response. This can go just below the imports:<pre class="source-code">
const bodyOfResponse = (response) =&gt; response.json();</pre></li>
<li>Then, create a new <code>describe</code> block with the following test. It creates two birthdays and checks that they are returned:<pre class="source-code">
describe('GET', () =&gt; {
  it('returns all the birthdays from the store', async
  () =&gt; {
    birthdayRepository.addNew(
      createBirthday('Hercules', '2010-04-05')
      );
    birthdayRepository.addNew(
      createBirthday('Ares', '2008-03-02')
    );
    const { birthdays } = await bodyOfResponse(GET());
    expect(birthdays).toEqual([
      expect.objectContaining(
        createBirthday('Hercules', '2010-04-05')
      ),
      expect.objectContaining(
        createBirthday('Ares', '2008-03-02')
      )
    ]);
  });
});</pre></li>
</ol>
<p class="callout-heading">Testing array responses</p>
<p class="callout">I find that when I’m testing array objects, it’s always best to use two (and sometimes three) items in the list rather than just one. That way, it’s clear that the test is operating on lists of items, not just single items.</p>
<ol>
<li value="4">To make<a id="_idIndexMarker347"/> that test pass, create a new file named <code>src/routes/api/birthdays/+server.js</code> with the following content. The implementation works like this: it passes the request right through to the store using the <code>getAll</code> function and then wraps the response with a call to SvelteKit’s <code>json</code> function:<pre class="source-code">
import {
  getAll
} from '$lib/server/birthdayRepository.js';
import { json } from '@sveltejs/kit';
export const GET = () =&gt;
  json({ birthdays: getAll() });</pre></li>
</ol>
<p>That completes the <code>GET</code> request. Next, we’ll work on the <code>POST</code> and <code>PUT</code> requests.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Adding an API endpoint for saving data</h1>
<p>In this <a id="_idIndexMarker348"/>section, we’ll start by adding the <code>POST</code> request handler function for saving data and then continue with the <code>PUT</code> function, in its own route file, for updating data.</p>
<p>Let’s begin with a test helper:</p>
<ol>
<li>Create a new file, <code>src/factories/request.js</code>, with the following content. This will be used by both the <code>POST</code> and <code>PUT</code> functions to read the data of the request. SvelteKit will pass a <code>Request</code> argument. The only bit of this we need to provide is the <code>json</code> method, as shown here:<pre class="source-code">
export const createRequest = (json) =&gt; ({
  json: () =&gt; Promise.resolve(json)
});</pre></li>
</ol>
<p class="callout-heading">Providing minimal versions of collaborating objects</p>
<p class="callout">SvelteKit passes the <code>Request</code> objects into our request handler functions. But for our unit tests we don’t need fully formed <code>Request</code> objects, we just need an object that implements the parts of the interface that we use. Our application code doesn’t use anything but the <code>json</code> method for reading the request body in JSON format, so that’s the only method we need.</p>
<ol>
<li value="2">Now move to <code>src/api/birthdays/server.test.js</code> and add an <code>import</code> statement for the <code>createRequest</code> method. Also, update the <code>+server.js</code> import to include the <code>POST</code> request handler function:<pre class="source-code">
<strong class="bold">import {</strong>
<strong class="bold">  createRequest</strong>
<strong class="bold">} from 'src/factories/request.js';</strong>
import { GET<strong class="bold">, POST</strong> } from './+server.js';</pre></li>
<li>Next, add a new <code>describe</code> block for the <code>POST</code> function, just below the <code>describe</code> block <a id="_idIndexMarker349"/>for the <code>GET</code> function, and include this one test:<pre class="source-code">
describe('POST', () =&gt; {
  beforeEach(birthdayRepository.clear);
  it('saves the birthday in the store', async () =&gt; {
    await POST({
      request: createRequest(
        createBirthday('Hercules', '2009-03-01')
      )
    });
    expect(birthdayRepository.getAll()).toHaveLength(1
      );
    expect(birthdayRepository.getAll()[0]).toContain(
      createBirthday('Hercules', '2009-03-01')
    );
  });
});</pre></li>
<li>To make that pass, first update the import in <code>src/api/birthdays/+server.js</code> to include the <code>addNew</code> function:<pre class="source-code">
import {
  <strong class="bold">addNew,</strong>
  getAll
} from '$lib/server/birthdayRepository.js';</pre></li>
<li>Continue <a id="_idIndexMarker350"/>by adding a definition for <code>POST</code>, as shown in the following code block. After this change, your test should pass:<pre class="source-code">
export const POST = async ({ request }) =&gt; {
  const { name, dob } = await request.json();
  addNew({ name, dob });
};</pre></li>
<li>Now that we have data saved into the repository, it’s time to check the HTTP response. We want any API caller to receive the same data back. The following test makes use of the <code>toContain</code> matcher rather than <code>toEqual</code>. That’s because we already know that the response will contain an <code>id</code> field that isn’t relevant to this test:<pre class="source-code">
it('returns a json response with the data', async () =&gt; {
  const response = await POST({
    request: createRequest(
      createBirthday('Hercules', '2009-03-01')
    )
  });
  expect(await bodyOfResponse(response)).toContain(
    createBirthday('Hercules', '2009-03-01')
  );
});</pre></li>
</ol>
<p class="callout-heading">Testing the presence of an id field</p>
<p class="callout">Why is the <code>id</code> field <a id="_idIndexMarker351"/>not included in the expectation of this test? Because it has a different lifecycle from the other data. This test verifies that the user-provided information is stored. But the <code>id</code> field is auto-generated, so it belongs to a separate test. I’ve omitted it here because it’s already tested in both the repository and the Playwright API test, but you may feel more comfortable including the test.</p>
<ol>
<li value="7">To make<a id="_idIndexMarker352"/> the test pass, add a <code>return</code> value to the function that uses the <code>json</code> function import:<pre class="source-code">
export const POST = async ({ request }) =&gt; {
  const { name, dob } = await request.json();
  <strong class="bold">const result = </strong>addNew({ name, dob });
  <strong class="bold">return json(result);</strong>
};</pre></li>
<li>The final test for the <code>POST</code> request handler is to check that the function throws an exception if the data is invalid. Throwing errors can complicate tests: here, the test uses a call to <code>expect.hasAssertions</code> to ensure that Vitest will fail the test if the call does <em class="italic">not</em> raise an error:<pre class="source-code">
it('throws an error if the data is invalid', async () =&gt; {
  expect.hasAssertions();
  try {
    await POST({
      request: createRequest(
        createBirthday('Ares', '')
      )
    });
  } catch (error) {
    expect(error.status).toEqual(422);
    expect(error.body).toEqual({
      message:
        'Please provide a date of birth in the YYYY-
          MM-DD format.'
    });
  }
});</pre></li>
</ol>
<p>Try <a id="_idIndexMarker353"/>running this test now: you’ll see the <code>expected any number of assertions, but got none</code> failure. That is courtesy of the <code>hasAssertions</code> statement at the top of the test.</p>
<p class="callout-heading">Understanding the hasAssertions helper</p>
<p class="callout">Try deleting the <code>expect.hasAssertions</code> line from the test. You will notice that the test already passes. That’s <a id="_idIndexMarker354"/>because the expectations were never met. This is the point of the <code>hasAssertions</code> call: it is useful in tests that rely on having expectations within <code>catch</code> blocks that won’t be called until you implement the exception-throwing behavior in your application code.</p>
<ol>
<li value="9">To make that pass, first update the <code>import</code> statement in <code>src/api/birthdays/+server.js</code> to include the <code>error</code> helper:<pre class="source-code">
import { json<strong class="bold">, error</strong> } from '@sveltejs/kit';</pre></li>
<li>Then update the <code>POST</code> function to re-package any errors from the repository into an <code>error</code> object that’s then thrown:<pre class="source-code">
export const POST = async ({ request }) =&gt; {
  const { name, dob } = await request.json();
  const result = addNew({ name, dob });
  <strong class="bold">if (result.error) throw error(422, result.error);</strong>
  return json(result);
};</pre></li>
</ol>
<p>That <a id="_idIndexMarker355"/>completes the <code>POST</code> request handler for inserting new birthdays; the next section completes the chapter with the addition of the <code>PUT</code> request handler for updating existing birthdays.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Adding an API endpoint for updating data</h1>
<p>The<a id="_idIndexMarker356"/> final piece of the puzzle is to add a <code>PUT</code> request handler function for dealing with updates. Similar to the <code>POST</code> function, we must provide the request body using the <code>createRequest</code> helper.</p>
<p>The form of our <code>PUT</code> request means that <code>id</code> is passed as a parameter in the URL, like this:</p>
<p>Here’s a reminder of how the URL must be passed:</p>
<pre class="source-code">
PUT http://localhost:1234/api/birthday/abc123</pre>
<p>To make SvelteKit register the <code>abc123</code> value as a parameter, we need to create a new route directory at <code>src/routes/api/birthday/[id]</code>. SvelteKit will then know that <code>abc123</code> matches the <code>[id]</code> bit of the directory path. The directory itself will then contain the <code>+server.js</code> file and its tests.</p>
<p>Let’s start with the tests:</p>
<ol>
<li>Create a new file named <code>src/routes/api/birthday/[id]/server.test.js</code> and add the following imports. This has everything we’ve used previously for the <code>GET</code> and <code>POST</code> functions, together with an import for the <code>PUT</code> function:<pre class="source-code">
import {
  describe,
  it,
  expect,
  beforeEach
} from 'vitest';
import
   as birthdayRepository
from '$lib/server/birthdayRepository.js';
import {
  createBirthday
} from 'src/factories/birthday.js';
import {
  createRequest
} from 'src/factories/request.js';
import { PUT } from './+server.js';</pre></li>
<li>Then <a id="_idIndexMarker357"/>create this new <code>describe</code> block. It contains a <code>beforeEach</code> block that not only clears the repository but inserts a new item, ready for editing:<pre class="source-code">
describe('PUT', () =&gt; {
  beforeEach(() =&gt; {
    birthdayRepository.clear();
    birthdayRepository.addNew(
      createBirthday('Hercules', '2009-03-01')
    );
  });
});</pre></li>
<li>Before we get to the first test, add the following helper:<pre class="source-code">
const storedId = () =&gt;
  birthdayRepository.getAll()[0].id;</pre></li>
<li>Now add the first test, as shown here. It mimics SvelteKit’s call semantics by passing <a id="_idIndexMarker358"/>a new <code>params</code> object into the handler:<pre class="source-code">
it('updates the birthday in the store', async () =&gt; {
  await PUT({
    request: createRequest(
      createBirthday('Hercules', '1999-03-01')
    ),
    params: { id: storedId() }
  });
  expect(birthdayRepository.getAll()).toHaveLength(1);
  expect(birthdayRepository.getAll()[0]).toContain(
    createBirthday('Hercules', '1999-03-01')
  );
});</pre></li>
<li>To make that pass, create a new file named <code>src/routes/api/birthday/[id]/+server.js</code> with the following content. This should immediately make the test pass:<pre class="source-code">
import {
  replace
} from '$lib/server/birthdayRepository.js';
export const PUT = async ({
  request,
  params: { id }
}) =&gt; {
  const { name, dob } = await request.json();
  const result = replace(id, { name, dob });
};</pre></li>
<li>For the<a id="_idIndexMarker359"/> next test, we’ll begin by repeating a helper from the <code>GET</code> tests. Add the <code>bodyOfResponse</code> function, as shown here:<pre class="source-code">
const bodyOfResponse = (response) =&gt; response.json();</pre></li>
<li>Then, add the next test, which uses this function to check the response:<pre class="source-code">
it('returns a json response with the data', async () =&gt; {
  const response = await PUT({
    request: createRequest(
      createBirthday('Hercules', '1999-03-01')
    ),
    params: { id: storedId() }
  });
  expect(await bodyOfResponse(response)).toContain(
    createBirthday('Hercules', '1999-03-01', {
      id: storedId()
    })
  );
});</pre></li>
<li>To make that pass, start by adding the import for <code>json</code> in the application code:<pre class="source-code">
import { json } from '@sveltejs/kit';</pre></li>
<li>Then, update<a id="_idIndexMarker360"/> the <code>PUT</code> function to return the result of the repository action, just as we did with the <code>POST</code> request handler function:<pre class="source-code">
export const PUT = async ({
  request,
  params: { id }
}) =&gt; {
  const { name, dob } = await request.json();
  const result = replace(id, { name, dob });
  <strong class="bold">return json(result);</strong>
};</pre></li>
<li>The final test repeats the mechanics of the final <code>POST</code> test, checking what happens if the data is invalid:<pre class="source-code">
it('throws an error if the data is invalid', async () =&gt; {
  expect.hasAssertions();
  try {
    await PUT({
      request: createRequest(
        createBirthday('Hercules', '')
      ),
      params: { id: storedId() }
    });
  } catch (error) {
    expect(error.status).toEqual(422);
    expect(error.body).toEqual({
      message:
        'Please provide a date of birth in the YYYY-
          MM-DD format.'
    });
  }
});</pre></li>
<li>To <a id="_idIndexMarker361"/>make that pass, start by updating the <code>import</code> statement in the application code to include the <code>error</code> function:<pre class="source-code">
import { json<strong class="bold">, error</strong> } from '@sveltejs/kit';</pre></li>
<li>Finally, include the guard clause in the <code>PUT</code> function, as shown here:<pre class="source-code">
export const PUT = async ({
  request,
  params: { id }
}) =&gt; {
  const { name, dob } = await request.json();
  const result = replace(id, { name, dob });
  <strong class="bold">if (result.error) throw error(422, result.error);</strong>
  return json(result);
};</pre></li>
</ol>
<p>That’s it. If you run both the Vitest and Playwright tests now, you should find they all pass.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Summary</h1>
<p>This chapter has shown how to make quick work of API endpoints. Playwright tests can be used to specify how an API should behave, and the unit tests can be used to drive the design and ensure that we end up with minimal implementation.</p>
<p>The next chapter completes the API story arc: we will update the form actions to use the new API endpoints rather than going directly to the repository.</p>
</div>
</div></body></html>