- en: Chapter 5. Adding and Modifying Elements with Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take a look at how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new `View` classes and instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Views to render DOM elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect Views to Models and Collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Respond to DOM events using Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide the rendering style(s) that best fits your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views are the core of Backbone-powered sites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While data is certainly important in any application, you can't have an application
    without a user interface at all. On the web, this means that you have a combination
    of DOM elements (to display information to the user) and event handlers (to receive
    input from the user). In Backbone, both of these things are managed by Views;
    in fact, it's only fair to say that Views pretty much control all the input and
    output on a Backbone-powered site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as Models wrap an `attributes` object and Collections wrap a `models`
    array, `Views` wrap a DOM element inside a property called `el`. Unlike attributes
    and models, however, `el` is not hidden, and Backbone doesn''t watch it for changes,
    so there''s nothing wrong with referencing a View''s `el` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new `View` subclass, simply extend `Backbone.View` in the same
    way as you created new `Model` and `Collection` subclasses, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in [Chapter 2](part0021.xhtml#aid-K0RQ1 "Chapter 2. Object-Oriented
    JavaScript with Backbone Classes"), *Object-oriented JavaScript with Backbone
    Classes*, Views take only a single `options` argument when instantiated. The most
    important part of these options is the `el` property, which defines the DOM element
    that the View will wrap as its `el`. A View''s `el` option can be defined in one
    of the following three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML (`new Backbone.View ({el: <div id=''foo''></div>})`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'jQuery Selector (`new Backbone.View ({el: ''#foo''})`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DOM element (`new Backbone.View ({el: document.getElementById(''foo'')})`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also choose not to provide an `el` option, in which case Backbone will
    create the View''s `el` option for you. By default, Backbone will simply create
    an empty `DIV` element (`<div></div>`), although you can change this by providing
    other options when you create your view. You can provide the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tagName`: This changes the generated elements'' tag from `div` to the specified
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`className`: This specifies the HTML `class` attribute that the element should
    have'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: This specifies the HTML `id` attribute that the element should have'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributes`: This specifies the HTML attributes that the element should have'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, you can specify both the class and ID of a View's element using
    the `attributes` option, but because they are important to the definition of a
    View, Backbone provides separate `id` and `className` options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of defining the preceding options when you instantiate your View, you
    can also choose to define them in a `View` class. For instance, if you want to
    create a `View` class that generates a `<form>` element with a class of `nifty`,
    you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rendering view content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Views can take an `el` option to define their initial element, it is rare
    for them to leave this `el` option unchanged. For instance, a `list` View might
    take an `<ul>` element as its `el` option but then fill this list with the `<li>`
    elements (possibly using data from a Collection). In Backbone, this generation
    of inner HTML is done inside the View's `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when you try to use the `render` method of an unmodified View, you
    quickly notice a problem with Backbone''s default implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the default `render` method doesn't actually render anything.
    This is because different Views can have entirely different content, so it doesn't
    make sense for Backbone to provide only one way of generating that content. Instead,
    Backbone leaves the implementation of your View's `render` method entirely up
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, in this chapter, we'll consider the various strategies for how you
    might want to implement `render` methods on your site, but before we get to that,
    let's first examine how to connect Models and Collections to Views as well as
    how Views handle event bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Views to Models and Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a View is created, it can take two important options: `Model` and `Collection`.
    Both of these options are simple property options, which is to say that Backbone
    doesn''t actually do anything with them other than add them as properties to the
    View. Even so, these properties can be very useful when you want to display or
    edit data that you''ve previously generated. For instance, if you want to associate
    a View with a `book` Model that you have created, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you write the `render` method for your `book` View, you can use that Model
    in order to get the data to generate the appropriate HTML. For instance, here''s
    a simple implementation of `render`, loosely borrowed from the Backbone documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the imaginary `render` method passes the output of the Model's
    `toJSON` to the View's templating system, presumably so that the templating system
    can use the Model's attributes to render the View.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a View's el element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve created a View, you can access the element that it wraps at any
    time by referring to its `el` property. You can also access a jQuery-wrapped version
    of the same element by referring to the View''s `$el` property. Take an example
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Backbone also provides another convenient shortcut when you want to access
    elements inside a View''s element: the `$` method. When you use this method, it''s
    effectively the same as calling jQuery''s `find` method from the View''s element.
    Because the search for the element is localized to only look through the View''s
    `el` element and not through the entire page''s DOM, it will perform much better
    than a global jQuery selection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you create a View of a `<form>` element with an `<input>` element
    inside it, you can use the View''s `$` method to access the `<input>` element
    , as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A brief aside on $Variable names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with jQuery objects in Backbone (or even just in JavaScript, in
    general), it may often be difficult to tell whether a given variable refers to
    a `View` element or to its `el` element. In order to avoid confusion, many programmers
    (including the authors of both Backbone and jQuery) preface any variable that
    points to a jQuery object with the `$` symbol, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While this practice is certainly not necessary to use Backbone, adopting it
    will likely save you from confusion in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the Views we''ve described so far are great for creating and/or wrapping
    existing HTML elements, they''re not very good at responding when a user interacts
    with them. One approach to solve this problem will be to hook up event handlers
    inside a View''s `initialize` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there are two problems with this approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's not terribly readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to bind the event handler when we create it so that we can still reference
    `this` from inside it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Luckily, Backbone offers a better way, in the form of an optional property
    called `events`. We can use this `events` property to simplify our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the `events` property saves us from even having to write
    an `initialize` method at all, while at the same time, it also takes care of binding
    the `handleClick` event handler to the View itself. In addition, by defining the
    event handlers in this way, we let Backbone know about them so that it can manage
    to remove or rebind them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: When you instantiate a View, Backbone calls a `delegateEvents` method, which
    checks the `events` property, binds all the handlers found in it, and then creates
    listeners for the appropriate events using jQuery. There is also a corresponding
    `undelegateEvents` method, which can be used to remove all the event handlers.
    Normally, you won't need to call either of these methods yourself because Backbone
    will call them for you.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you change a View's `el` element without telling Backbone (for example,
    `yourView.el = $('#foo')[0]`), Backbone won't know that it needs to hook up the
    events to the new element, and you will have to call `delegateEvents` yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, instead of changing a View''s `el` element manually and then
    calling `delegateEvents` afterwards, you can use a View''s `setElement` method
    to do both at the same time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Rendering strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've covered all of View's capabilities, it's time to return to the
    question of how to render a View. Specifically, let's look at the main options
    available to you, which are explained in the sections that follow, when you overwrite
    the `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: Simple templating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first, and perhaps the most obvious, approach for rendering is to use a
    simple, logic-less templating system. The `render` method provided in the Backbone
    documentation is a perfect example of this, as it relies on the Underscore library''s
    `template` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `template` method takes a string, which contains one or more specially
    designated sections, and then combines this string with an object, filling in
    the designated sections with that object''s values. This is best explained with
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While the `template` function works with any string and data source, when used
    as part of a Backbone View, it is typically used with an HTML string and a `Backbone.Model`
    data source. Underscore's `template` function lets us combine the two to easily
    create a `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you want to create a `<div>` tag with an `<h1>` tag inside
    containing an author's name and genre and then add an emphasis (in other words,
    an `<em>` tag) around the genre, you can create a `template` string with the desired
    HTML and placeholders for the first name, last name, and genre. We can then use
    the `_.` template to create a `template` function and then use this `template`
    function in a `render` method with an author Model's attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, as we mentioned in [Chapter 3](part0029.xhtml#aid-RL0A1 "Chapter 3. Accessing
    Server Data with Models"), *Accessing Server Data with Models*, it''s safer if
    we don''t access a Model''s attributes directly; so, we''ll want to use the Model''s
    `toJSON` method instead. Putting all of this together, we get the following block
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: One major advantage of this approach is that because our HTML is completely
    separated into a string, we can optionally choose to move it out into a separate
    file and then bring it in using jQuery or a dependency library, such as `Require.js`.
    HTML that is stored separately like this can be easier for a designer to work
    with, if you have such a person in your team.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced templating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using Underscore''s `template` method, you can also employ one of
    the many quality third-party templating libraries available, such as Handlebars,
    Mustache, Hamljs, or Eco. All these libraries offer the same basic ability to
    combine a data object with a template string, but they also offer the possibility
    to include logic inside the template. For instance, here''s an example of a Handlebars
    template string that uses an `if` statement, which is based on a provided `isMale`
    data property, to select the correct gender pronoun inside a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use Handlebars'' `compile` method to turn that into a template, we can
    then use it just as we will use an Underscore template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll discuss more about Handlebars in [Chapter 11](part0095.xhtml#aid-2QJ5E1
    "Chapter 11. (Not) Re-Inventing the Wheel – Utilizing Third-Party Libraries"),
    *(Not) Re-inventing the Wheel: Utilizing Third-Party Libraries* but the important
    thing to understand for now is that no matter which templating library you choose,
    you can easily incorporate it as part of your View''s `render` method. The difficult
    part is deciding whether or not you want to allow logic inside your templates
    and if so, how much.'
  prefs: []
  type: TYPE_NORMAL
- en: Logic-based
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of relying on templating libraries, another option is to use Backbone''s
    View logic, jQuery methods, and/or string concatenation to power your `render`
    methods. For instance, you can reimplement the preceding `AuthorView` without
    using templates at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are both advantages and disadvantages to a purely logic-based
    approach. The main advantage, of course, is that we don't have to deal with a
    template at all. This means that we can see exactly what logic is being used,
    because nothing is hidden inside the template library's code. Also, there is no
    limit on this logic; you can do anything that you will normally do in JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: However, we also lost a good deal of readability by not using a template, and
    if we had a designer on our team who wanted to edit the HTML, they would find
    `that` code very difficult to work with. In the first version, they will see a
    familiar HTML structure, but in the second version, they will have to work with
    the JavaScript code even though they (probably) aren't familiar with programming.
    Yet another downside is that because we've mixed the logic with the HTML code,
    there's no way to store the HTML in a separate file, the way we can if it were
    a template.
  prefs: []
  type: TYPE_NORMAL
- en: The combined approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All three preceding approaches have advantages and disadvantages, and rather
    than settling for just one, you can choose to combine some of them instead. There's
    no reason why, for instance, you can't use a templating system (either Underscore's
    for simplicity or an external one for power) and then switch to using logic when
    you want to do something that doesn't fit neatly into a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say you want to render a `<ul>` with a `class` HTML attribute
    derived from the attributes of a Model—this sounds like something that will be
    easier with JavaScript logic. However, let''s say you also want this `<ul>` to
    contain `<li>` elements with text based on a template and filled in with the attributes
    of Models in a Collection; that sounds like something we can best handle with
    a template. Luckily, there is nothing stopping you from combining the two approaches,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Of course, mixing approaches means that you won't always get the full benefits
    of both. The most notable issue will be that any HTML that you render via Backbone's
    Views or other JavaScript logic won't be accessible to a non-programming designer.
    If you don't have such a role in your team, then this limitation won't bother
    you, but if you do, you should probably try to keep as much HTML inside templates
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Other render considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to deciding whether you can rely on templates and how much you can
    rely on them in your render methods, there are a few other things that you need
    to consider when writing them. None of these choices are completely binary, but
    you should strive for as consistent an approach as possible. This means that the
    real question isn't about which one you should choose, as it is about when you
    will choose one over the other. Ultimately, a consistent strategy will make it
    such that both you and your co-workers don't have to think in order to decide
    which approach to use when writing new `render` methods or editing existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Child views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Very often, in Backbone, you will want to create one View for a container element,
    such as a `<ul>` element, and another View for its child elements, such as its
    `<li>` element. When creating these child Views, you can either choose to have
    a child View create the child elements, or you can have the parent View create
    them and pass a jQuery selector as the child View''s `el` element, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The primary advantage of generating the child element in the View is encapsulation.
    By taking this approach, you can keep all the logic related to the child element
    within the child View. This will make the code easier to work with, as you won't
    have to think about both the child and parent Views at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when you are using templates, it may be inconvenient to split
    the template into parts in order to render the overall container element. Also,
    rendering the child elements in the parent view provides a good separation between
    DOM-generating Views and purely event handling Views, which can help you to sort
    your logic better.
  prefs: []
  type: TYPE_NORMAL
- en: Neither approach has to be taken to the extreme. While you can have a single
    page View with a single template for all your content or you can have every single
    child View generate its DOM elements, you can also choose to have a mix of approaches
    in your Views. In fact, unless you want to have a single page template for a top-level
    render, which generates the entire DOM, you will probably want to take a combined
    approach, so the real question is how much do you want to rely on each technique?
    The more you rely on the parent View, the easier it is to see the big picture;
    but the more you rely on DOM generation in child Views, the easier it will be
    to encapsulate your logic.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable versus one-time renders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another thing that you'll want to consider is whether to design your `render`
    methods to be rendered once (usually when the View is first created), or whether
    you want to be able to call your `render` method multiple times in response to
    changes. The render methods that are designed to render only once are the simplest
    to write and the simplest to work with; when something needs to change with your
    View's DOM element, you simply call the View's `render` method again and the DOM
    gets updated.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach can also lead to performance issues, particularly if
    the View involved contains a great number of child Views. To avoid this, you might
    instead want to write `render` methods that don't blindly replace their content
    but instead update them in response to changes. For instance, if you have a `<ul>`
    elements where you want some of the child `<li>` elements to appear or disappear
    in response to user actions, you might want to have your `render` method check
    whether the `<li>` elements already exist first and then simply apply changes
    to their display style rather than rebuilding the entire `<ul>` from scratch every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you'll probably want to mix the two approaches based on the type of View
    you are writing. If performance is a high priority for you, then you'll likely
    want to think carefully about how you can reuse previously-generated DOM elements
    in your `render` methods. On the other hand, if performance is less important,
    designing your `render` method for one-time DOM generation will keep its logic
    a lot simpler. Also, if performance problems crop up, you can always change the
    `render` method in question to reuse existing elements.
  prefs: []
  type: TYPE_NORMAL
- en: Return value – this or this.$el
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sample `render` method from the Backbone documentation returns `this` when
    it completes. This approach allows you to easily access the `el` property of the
    render by simply calling it on the `render` method''s return value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can make it even easier to access the View''s `el` by returning
    that `el` instead of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside of returning the `$el` from a `render` method is that you can
    no longer chain other View methods from the return value of the render method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, what this choice really comes down to is how much you plan to post-render
    your Views and how much you plan to call those post-rendering methods from outside
    the View itself (if you call them from within the render method, their return
    values are irrelevant). If you're not sure, the safest bet is to follow the `render`
    method in Backbone's documentation and return `this`, as it offers maximum flexibility
    (at the cost of a slightly less-concise code).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whatever you choose, you'll likely want to keep it consistent across all your
    Views. If you don't, you will find yourself constantly having to look up a View's
    `render` method every time you want to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Backbone's `View` class. You learned how to create
    DOM elements by instantiating a View as well as how to pass in existing elements
    to new Views. You also learned how to use Views to hook up event handlers on the
    View's `el` and how to remove/reattach these handlers to the `undelegate` and
    `delegate` methods. Finally, we considered how Backbone's (deliberately) empty
    implementation of the `render` method leaves us many different options for how
    to implement our own `render` method and what factors influence those choices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at Backbone's final class, the `Router`
    class. This class lets us simulate traditional web pages, only using Views instead
    of separate HTML files to generate those pages.
  prefs: []
  type: TYPE_NORMAL
