<html><head></head><body>
        

                            
                    <h1 class="header-title">Introducing Vuex</h1>
                
            
            
                
<p>Vuex is a library that we can use with Vue.js to manage different states in an application. If you are building a small application that does not require much data exchange between its components, you are better off not using this library. However, as your application grows, complexities crawl along with it. There will be several components in the application, and, most obviously, you will need to exchange data from one component to another or share the same data across multiple components. That is when Vuex comes to the rescue.</p>
<p>Vue.js also provides an <kbd>emit</kbd> method to pass data between different components, which we used in previous chapters. As your application grows, you might also want to update data across several components when your data gets updated.</p>
<p>So, Vuex provides a centralized place to store all the pieces of data in our application. Whenever data changes, this new set of data will be stored in this centralized place. Also, all of the components that want to use that data will be fetched from the store. This means that we have a single source to store all the data, and all the components that we build will be able to access that data. </p>
<p>Let's first get acquainted with some of the terminology that come with Vuex:</p>
<ul>
<li><strong>State</strong>: This is an object that contains the data. Vuex uses a single state tree, which means that it is a single object that contains all the pieces of data for the application.</li>
<li><strong>Getters</strong>: It is used to fetch data from the state tree.</li>
<li><strong>mutations</strong>: They are the methods that change the data in the state tree.</li>
<li><strong>Actions</strong>: They are the functions that perform mutations.</li>
</ul>
<p>We will discuss each of these in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Traditional multi-web page application</h1>
                
            
            
                
<p>In traditional multi web page application, when we build a web application and open a website by navigating to the browser, it requests the web server to fetch that page and serve it to the browser. When we click on a button on the same website, it again requests the web server to fetch another page and again serve it. This process happens for every single interaction we do on the website. So, basically, the website gets reloaded on every single interaction, which consumes a lot of time.</p>
<p>The following is a sample diagram that explains how a multi-page application works:</p>
<div><img class="alignnone size-full wp-image-554 image-border" src="img/358fe12c-59b3-4c01-840a-49d48a1c85b9.jpg" style="width:34.00em;height:26.83em;"/></div>
<p>When a request is sent from the browser, the request is sent to the server. The server then returns the HTML content and serves a whole new whole page.</p>
<p><strong>Multi Page Applications </strong>(<strong>MPA</strong>) can provide several benefits as well. It's not a matter of whether to choose MPA or a <strong>Single Page Application</strong> (<strong>SPA</strong>), but it all depends on the content of your application. If your application contains a lot of user interaction, you should go for an SPA; however, if the only purpose of your application is to serve the users with the content, you can go with an MPA. We will explore more about SPAs and MPAs later in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An introduction to SPAs</h1>
                
            
            
                
<p>Contrary to the traditional MPAs, SPAs are designed specifically for web-based applications. The SPA fetches all the data when you first load the website in the browser. Once all the data is fetched, you don't need to fetch any more data. When any other interactions are done, that data is fetched over the internet, without having to send a request to the server and without reloading the page. This means that SPAs are much faster than the traditional MPAs. However, since SPAs fetch everything at once on the first load, the first page load time could be slow. Some applications that have SPA integration are Gmail, Facebook, GitHub, Trello, and so on. SPAs are all about making the user experience better by putting the content on one single page and not making the users wait for the information they want.</p>
<p>The following is a sample diagram of how SPAs work:</p>
<div><img src="img/ff9dc3a1-41a1-45fd-a694-0fd9084e8584.jpg" style="width:36.58em;height:27.42em;"/></div>
<p>The website has all the content that it needs on the first page-load. When a user clicks on something, it just fetches the information for that particular area and refreshes only that part of the web page.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">SPA versus MPA</h1>
                
            
            
                
<p>SPA and MPA serve different purposes. You may want to use one over the other, depending on your needs. Before you start your application, ensure that you are clear about the kind of application that you want to build.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pros of using MPAs</h1>
                
            
            
                
<p>MPAs are the best approach if you want to make your application SEO friendly. Google can crawl different pages of your application by searching the keywords that you assign on each page, which is not possible in an SPA since it has only a single page.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cons of using MPAs</h1>
                
            
            
                
<p>There are a few cons of using MPAs:</p>
<ul>
<li>The development work for an MPA is much greater than for an SPA because the frontend and backend are tightly coupled.</li>
<li>MPAs have tightly coupled frontend and backend, which makes it harder to separate the work between frontend and backend developers.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Pros of using SPAs </h1>
                
            
            
                
<p>SPAs provides a lot of benefits:</p>
<ul>
<li><strong>Reduced server response tim</strong>e: SPAs fetch all the data needed on the first load of the website. With such an application, the server does not need to reload the resources on the website. If new data needs to be fetched, it only fetches the updated piece of information from the server, unlike multi-page apps, decreasing the server response time significantly.</li>
<li><strong>Better user interaction</strong>: The decrease in server response time ultimately improves the user experience. With every interaction, the user gets a more quickly rendered page, which means <em>happy customers</em>.</li>
<li><strong>Flexibility to change the UI</strong>: SPAs do not have a coupled frontend and backend. This means that we can change the frontend and completely rewrite it without having to worry about breaking anything on the server side.</li>
<li><strong>Data caching</strong>: SPAs cache the data in the local storage. It only makes a single request the first time and saves the data. This makes the application available even when the internet is cut off. </li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Cons of using  SPAs </h1>
                
            
            
                
<p>There are few downsides of using SPAs as well:</p>
<ul>
<li>SPAs are not SEO friendly. Since everything is done on a single page, the crawlability is very low.</li>
<li>You cannot share a particular piece of information with others since there is the only one link to the page. </li>
<li>Security concerns are much greater with SPAs than in MPAs.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">An introduction to Vuex</h1>
                
            
            
                
<p>Vuex is a state management library that is specifically designed to work with applications built with Vue.js. It is centralized state management for Vuex.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Core concepts of Vuex</h1>
                
            
            
                
<p>We got a glimpse of these core concepts in the introduction. Now, let's dive into a little bit more detail on each of these concepts:</p>
<div><img class="alignnone size-full wp-image-555 image-border" src="img/ed51d06e-04d0-4f06-beee-3a3f7d86ae7f.png" style="width:19.58em;height:15.67em;"/></div>
<p>The preceding diagram is a simple diagram that explains how Vuex works. Initially, everything is stored in a state, which is the single source of truth. Every view component fetches data from this state. Whenever something needs to be changed, actions perform mutations on the data and store it back in the state:</p>
<div><img class="alignnone size-full wp-image-556 image-border" src="img/f4523972-cb5b-4dd8-8639-4bc547976d96.png" style="width:41.75em;height:31.50em;"/></div>
<p>When we open our application in the browser, all the Vue components will be loaded. When we click on a button to fetch certain information from a component, that component dispatches an action that performs mutations on the data. When the mutation is successfully done, the state object is updated and new values are used. Then, we can use the new state for our components and display it in the browser.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a simple Vuex application</h1>
                
            
            
                
<p>We will start a fresh new application to learn the basics of Vuex. Let's get started.</p>
<p>Let's first create a new application:</p>
<pre><strong>$ vue init webpack vuex-tutorial</strong></pre>
<p>The preceding code snippet will ask you few questions about the application setup. You can choose what you want to keep. I will go with the following configuration:</p>
<div><img class="alignnone size-full wp-image-557 image-border" src="img/433b4667-cdfc-434e-ae05-d12d2a43efec.png" style="width:50.00em;height:27.50em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">After the installation, navigate to the project directory:</p>
<pre><strong>$ cd vuex-tutorial</strong></pre>
<p>The next thing to do is to run the following command:</p>
<pre><strong>$ npm install</strong></pre>
<p>After that, run the following command:</p>
<pre><strong>$ npm run dev</strong></pre>
<p>The preceding command will spin up your server and open a port in <kbd>localhost:8080</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Vuex</h1>
                
            
            
                
<p>The next step is to install <kbd>vuex</kbd>. To do that, run the following command:</p>
<pre><strong>$ npm install --save vuex</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up Vuex</h1>
                
            
            
                
<p>Now, let's create a <kbd>store</kbd> folder to manage the <kbd>vuex</kbd> in our application. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a store file</h1>
                
            
            
                
<p>In the <kbd>src</kbd> directory, create a <kbd>store</kbd> folder and <kbd>store.js</kbd> file. Then, add the following to the <kbd>store.js</kbd> file:</p>
<pre><strong>import Vue from 'vue'</strong><br/><strong>import Vuex from 'vuex'</strong><br/><br/><strong>Vue.use(Vuex)</strong></pre>
<p>In the preceding code block, the line <kbd>Vue.use(Vuex)</kbd> imports the Vuex library. Without this, we will not be able to use any of the <kbd>vuex</kbd> functionalities. Now, let's build a store object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">State</h1>
                
            
            
                
<p>In the same <kbd>store.js</kbd> file, add the following lines of code:</p>
<pre class="mce-root">import Vue from 'vue'<br/>import Vuex from 'vuex'<br/><br/>Vue.use(Vuex)<br/><br/><strong>const state = {</strong><br/><strong>  count: 0</strong><br/><strong>}</strong><br/><br/><strong>export const store = new Vuex.Store({</strong><br/><strong>  state</strong><br/><strong>})</strong></pre>
<p>In the preceding code, we set the default state for a variable called <kbd>count</kbd> as <kbd>0</kbd> and exported a Vuex state through the store.</p>
<p>Now, we will need to modify <kbd>src/main.js</kbd>:</p>
<pre>// The Vue build version to load with the `import` command<br/>// (runtime-only or standalone) has been set in webpack.base.conf with an alias.<br/>import Vue from 'vue'<br/>import App from './App'<br/><strong>import { store } from './store/store'</strong><br/><br/>Vue.config.productionTip = false<br/><br/>/* eslint-disable no-new */<br/>new Vue({<br/>  el: '#app',<br/>  <strong>store</strong>,<br/>  components: { App },<br/>  template: '&lt;App/&gt;'<br/>})</pre>
<p>The preceding code imports the store file that we just created, and we can access this variable in our vue components.</p>
<p>Let's move on to creating a component that will fetch this store data. A default component is created when we create a new application with Vue. If we look into the <kbd>src/components</kbd> directory, we will find a file called <kbd>HelloWorld.vue</kbd>. Let's use the same component, <kbd>HelloWorld.vue</kbd>, or you can create a new one. Let's modify this file to access the <kbd>count</kbd>, which we defined in the state.</p>
<p>In <kbd>src/components/HelloWorld.vue</kbd>, add the following code:</p>
<pre>&lt;template&gt;<br/>  <strong>&lt;div class="hello"&gt;</strong><br/><strong>    &lt;h1&gt;{{ $store.state.count }}&lt;/h1&gt;</strong><br/><strong>  &lt;/div&gt;</strong><br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>export default {<br/>  name: 'HelloWorld',<br/>  data () {<br/>    return {<br/>      msg: 'Welcome to Your Vue.js App'<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;<br/><br/>&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;<br/>&lt;style scoped&gt;<br/>&lt;/style&gt;</pre>
<p>The following is the final folder structure:</p>
<div><img class="alignnone size-full wp-image-558 image-border" src="img/1eef5543-52e1-4b33-9e48-a7efbc92001a.png" style="width:13.42em;height:33.75em;"/></div>
<p class="mce-root CDPAlignCenter CDPAlign CDPAlignLeft">The preceding screenshot should print the default value of count in the <kbd>HelloWorld.vue</kbd> component. If you navigate to <kbd>http://localhost:8080/#/</kbd>, you should see the following screenshot:</p>
<div><img class="alignnone size-full wp-image-559 image-border" src="img/964f5d82-853f-466c-a069-799ed8e9f367.png" style="width:14.67em;height:12.42em;"/></div>
<p>In the preceding screenshot, we accessed the count variable in the store directly using the <kbd>$</kbd> operator, which is not the preferred way of doing it. We have learned the fundamentals of using the state. Now, the proper way to access the variables is by using getters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getters</h1>
                
            
            
                
<p>A <kbd>getter</kbd> is a function that is used to access the objects from the store. Let's create a <kbd>getter</kbd> method to fetch the count that we have in our store.</p>
<p>In <kbd>store.js</kbd>, add the following code:</p>
<pre>import Vue from 'vue'<br/>import Vuex from 'vuex'<br/><br/>Vue.use(Vuex)<br/><br/>const state = {<br/>  count: 0<br/>}<br/><br/><strong>const getters = {</strong><br/><strong>  fetchCount: state =&gt; state.count</strong><br/><strong>}</strong><br/><br/>export const store = new Vuex.Store({<br/>  state,<br/>  <strong>getters</strong><br/>})</pre>
<p>In the preceding code, we added a method called <kbd>fetchCount</kbd>, which returns the current value of <kbd>count</kbd>. Now, to access this in our vue component—<kbd>HelloWorld.vue</kbd>, we will need to update the content with the following code:</p>
<pre>&lt;template&gt;<br/>  &lt;div class="hello"&gt;<br/><strong>    &lt;h1&gt;The count is: {{ fetchCount }}&lt;/h1&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/><strong>import { mapGetters } from 'vuex'</strong><br/>export default {<br/>  name: 'HelloWorld',<br/>  <strong>computed: mapGetters([</strong><br/><strong>    'fetchCount'</strong><br/><strong>  ])</strong><br/>}<br/>&lt;/script&gt;<br/><br/>&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;<br/>&lt;style scoped&gt;<br/>&lt;/style&gt;</pre>
<p>We have to import a module called <kbd>mapGetters</kbd> from Vuex, which is used to import the <kbd>fetchCount</kbd> method that we create as a <kbd>getter</kbd> method in <kbd>store.js</kbd>. Now, check the number by reloading the browser; this should also print the count as <kbd>0</kbd>:</p>
<div><img class="alignnone size-full wp-image-560 image-border" src="img/092909d8-925c-4beb-a34f-525086a77929.png" style="width:17.67em;height:14.50em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">mutations</h1>
                
            
            
                
<p>Let's move on to <kbd>mutations</kbd>. <kbd>mutations</kbd> are methods that perform modifications to the state of the store. We will define the <kbd>mutations</kbd> just as we defined <kbd>getters</kbd>.</p>
<p>In <kbd>store.js</kbd>, add the following lines:</p>
<pre>import Vue from 'vue'<br/>import Vuex from 'vuex'<br/><br/>Vue.use(Vuex)<br/><br/>const state = {<br/>  count: 0<br/>}<br/><br/>const getters = {<br/>  fetchCount: state =&gt; state.count<br/>}<br/><br/><strong>const mutations = {</strong><br/><strong>  increment: state =&gt; state.count++,</strong><br/><strong>  decrement: state =&gt; state.count--</strong><br/><strong>}</strong><br/><br/>export const store = new Vuex.Store({<br/>  state,<br/>  getters,<br/>  <strong>mutations</strong><br/>})</pre>
<p>We added two different <kbd>mutation</kbd> functions in the preceding code. The <kbd>increment</kbd> method increments the count by 1, whereas the <kbd>decrement</kbd> method decreases the count by 1. This is where we introduce actions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Actions</h1>
                
            
            
                
<p>Actions are the methods that dispatch mutation functions. Actions perform <kbd>mutations</kbd>. Since <kbd>actions</kbd> are asynchronous and <kbd>mutations</kbd> are synchronous, it's always a good practice to use <kbd>actions</kbd> to mutate the state. Now, just like <kbd>getters</kbd> and <kbd>mutations</kbd>, let's define the <kbd>actions</kbd> as well. In the same file, that is, <kbd>store.js</kbd>, add the following lines of code:</p>
<pre>import Vue from 'vue'<br/>import Vuex from 'vuex'<br/><br/>Vue.use(Vuex)<br/><br/>const state = {<br/>  count: 0<br/>}<br/><br/>const getters = {<br/>  fetchCount: state =&gt; state.count<br/>}<br/><br/>const mutations = {<br/>  increment: state =&gt; state.count++,<br/>  decrement: state =&gt; state.count--<br/>}<br/><br/><strong>const actions = {</strong><br/><strong>  increment: ({ commit }) =&gt; commit('increment'),</strong><br/><strong>  decrement: ({ commit }) =&gt; commit('decrement')</strong><br/><strong>}</strong><br/><br/>export const store = new Vuex.Store({<br/>  state,<br/>  getters,<br/>  mutations,<br/>  <strong>actions</strong><br/>})</pre>
<p>In the preceding code, we added two different functions for incrementing and decrementing. Since these methods commit the <kbd>mutations</kbd>, we will need to pass a parameter to make the <kbd>commit</kbd> method available.</p>
<p>Now we need to use the previously defined <kbd>actions</kbd> and make them available in our vue component, in <kbd>HelloWorld.vue</kbd>:</p>
<pre>&lt;template&gt;<br/>  &lt;div class="hello"&gt;<br/>    &lt;h1&gt;The count is: {{ fetchCount }}&lt;/h1&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import { mapGetters, <strong>mapActions</strong> } from 'vuex'<br/>export default {<br/>  name: 'HelloWorld',<br/>  computed: mapGetters([<br/>    'fetchCount'<br/>  ]),<br/>  <strong>methods: mapActions([</strong><br/><strong>    'increment',</strong><br/><strong>    'decrement'</strong><br/><strong>  ])</strong><br/>}<br/>&lt;/script&gt;<br/><br/>&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;<br/>&lt;style scoped&gt;<br/>&lt;/style&gt;</pre>
<p>To invoke these actions, let's create two buttons. In <kbd>HelloWorld.vue</kbd>, let's add the following lines of code:</p>
<pre>&lt;template&gt;<br/>  &lt;div class="hello"&gt;<br/>    &lt;h1&gt;The count is: {{ fetchCount }}&lt;/h1&gt;<br/>    <strong>&lt;button class="btn btn-primary" @click="increment"&gt;Increase&lt;/button&gt;</strong><br/><strong>    &lt;button class="btn btn-primary" @click="decrement"&gt;Decrease&lt;/button&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>...</pre>
<p>The preceding lines of code add two buttons, which, when clicked, call a method to increment or decrement the count. Let's also import Bootstrap for CSS. In <kbd>index.html</kbd>, add the following code:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt;<br/>    <strong>&lt;!-- Latest compiled and minified CSS --&gt;</strong><br/>    <strong>&lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt;</strong><br/>    &lt;title&gt;vuex-tutorial&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;&lt;/div&gt;<br/>    &lt;!-- built files will be auto injected --&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>That's it. Now, if you reload the browser, you should be able to see the following result:</p>
<div><img class="alignnone size-full wp-image-561 image-border" src="img/02e6929a-410b-4b2e-a264-0f595157d624.png" style="width:29.75em;height:23.67em;"/></div>
<p>The count should increase or decrease when you click on the relevant button. This gives you a basic idea about how to implement Vuex in an application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing and using Vuex in a movie application</h1>
                
            
            
                
<p>We covered the basics of Vuex—how it works in an application and the core concepts. We covered how to create a store and mutations and how to use actions to dispatch them, and also discussed how to use getters to fetch information from the store.</p>
<p>We built an application in the previous chapters for a movie listing page. We will use the same application for Vuex. We will be doing the following actions:</p>
<ul>
<li>We will define a store where all the movies will be stored</li>
<li>When a new movie is added, we will automatically display that to the movie listing page without reloading the page</li>
</ul>
<p>Let's open the application and run the frontend and backend servers:</p>
<pre><strong>$ cd movie_rating_app</strong><br/><strong>$ npm run build<br/>$ nodemon server.js</strong></pre>
<p>Also, run the <kbd>mongo</kbd> server with the following command:</p>
<pre><strong>$ mongod</strong></pre>
<p>The movie listing page should look like this:</p>
<div><img class="alignnone size-full wp-image-562 image-border" src="img/2e905eea-dc88-42f3-8715-2cdf705c9317.png" style="width:60.08em;height:33.33em;"/></div>
<p>Let's start by installing <kbd>vuex</kbd>:</p>
<pre><strong>$ npm install --save vuex</strong></pre>
<p>Check your <kbd>package.json</kbd> file; <kbd>vuex</kbd> should be listed on the dependencies:</p>
<pre>...<br/>"vue-router": "^3.0.1",<br/>    "vue-swal": "0.0.6",<br/>    "vue-template-compiler": "^2.5.14",<br/>    "vuetify": "^0.17.6",<br/>    <strong>"vuex": "^3.0.1"</strong><br/>  },<br/>...</pre>
<p>Now, let's create a file, where we will be able to put all our <kbd>getters</kbd>, <kbd>mutations</kbd>, and <kbd>actions</kbd> that we will define as we go forward.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining a store</h1>
                
            
            
                
<p>Let's create a folder named <kbd>store</kbd> inside the <kbd>src</kbd> directory, and a new file called <kbd>store.js</kbd> inside the <kbd>store</kbd> directory, and add the following lines of code to it:</p>
<pre><strong>import Vue from 'vue';</strong><br/><strong>import Vuex from 'vuex';</strong><br/><strong>import axios from 'axios';</strong><br/><br/><strong>Vue.use(Vuex);</strong><br/><br/><strong>export const store = new Vuex.Store({</strong><br/><strong>})</strong></pre>
<p>Just like we did in the preceding sample application, let's add a <kbd>state</kbd> variable to store the current state of the application for movies listing page.</p>
<p>In <kbd>store.js</kbd>, add the following lines of code:</p>
<pre>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import axios from 'axios';<br/><br/>Vue.use(Vuex);<br/><br/>export const store = new Vuex.Store({<br/>  <strong>state: {</strong><br/><strong>    movies: []</strong><br/><strong>  },</strong><br/>})</pre>
<p>This means that the initial state of the application will have an empty movie listing.</p>
<p>Now, we need to import this <kbd>store</kbd> into <kbd>main.js</kbd> so that it is accessible throughout the components. Add the following lines of code in <kbd>src/main.js</kbd>:</p>
<pre>// The Vue build version to load with the `import` command<br/>// (runtime-only or standalone) has been set in webpack.base.conf with an alias.<br/>import 'bootstrap/dist/css/bootstrap.min.css';<br/>import 'bootstrap-vue/dist/bootstrap-vue.css';<br/><br/>import BootstrapVue from 'bootstrap-vue';<br/>import Vue from 'vue';<br/>import Vuetify from 'vuetify';<br/>import VueSwal from 'vue-swal';<br/>import App from './App';<br/>import router from './router';<br/><strong>import { store } from './store/store';</strong><br/><br/>Vue.use(BootstrapVue);<br/>Vue.use(Vuetify);<br/>Vue.use(VueSwal);<br/><br/>Vue.config.productionTip = false;<br/><br/>/* eslint-disable no-new */<br/>new Vue({<br/>  el: '#app',<br/>  <strong>store,</strong><br/>  router,<br/>  components: { App },<br/>  template: '&lt;App/&gt;',<br/>});</pre>
<p>Now, we will need to fetch the movies when we open the location <kbd>http://localhost:8081/</kbd> in the browser. Here is what we will do:</p>
<ol>
<li>Modify <kbd>Home.vue</kbd> to call the action that fetches the movies</li>
<li>Create an action that will fetch all the movies</li>
<li>Create a mutation to store the fetched movies in the movies store</li>
<li>Create a getter method to fetch the movies from the state to display on the home page</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying Home.vue </h1>
                
            
            
                
<p>Let's start this section by modifying our <kbd>Home.vue</kbd> component. Update the <kbd>script</kbd> part of the file with the following lines of code:</p>
<pre>&lt;script&gt;<br/>export default {<br/>  name: 'Movies',<br/>  <strong>computed: {</strong><br/><strong>    movies() {</strong><br/><strong>      return this.$store.getters.fetchMovies;</strong><br/><strong>    }</strong><br/><strong>  },</strong><br/><strong>  mounted() {</strong><br/><strong>    this.$store.dispatch("fetchMovies");</strong><br/><strong>  },</strong><br/>};<br/>&lt;/script&gt;</pre>
<p>In the preceding code, in the <kbd>mounted()</kbd> method, we have dispatched an action called <kbd>fetchMovies</kbd>, which we will define in our action.</p>
<p>When the movies are fetched successfully, we will use the <kbd>computed</kbd> method, which will be mapped to the <kbd>movies</kbd> variable, which we will use in our template:</p>
<pre>&lt;template&gt;<br/>  &lt;v-layout row wrap&gt;<br/><strong>    &lt;v-flex xs4 v-for="movie in movies" :key="movie._id"&gt;</strong><br/>      &lt;v-card&gt;<br/>        &lt;v-card-title primary-title&gt;<br/>        ...</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an action</h1>
                
            
            
                
<p>Let's move on to add an action to the <kbd>store.js</kbd> file:</p>
<pre>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import axios from 'axios';<br/><br/>Vue.use(Vuex);<br/><br/>export const store = new Vuex.Store({<br/>  state: {<br/>    movies: []<br/>  },<br/>  <strong>actions: {</strong><br/><strong>    fetchMovies: (context, payload) =&gt; {</strong><br/><strong>      axios({</strong><br/><strong>        method: 'get',</strong><br/><strong>        url: '/movies',</strong><br/><strong>      })</strong><br/><strong>        .then((response) =&gt; {</strong><br/><strong>          context.commit("MOVIES", response.data.movies);</strong><br/><strong>        })</strong><br/><strong>        .catch(() =&gt; {</strong><br/><strong>        });</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/>})</pre>
<p>In the preceding code, we have moved the <kbd>axios</kbd> part from the component. When we get a successful response, we will commit a mutation called <kbd>MOVIES</kbd>, which then mutates the value of the <kbd>movies</kbd> in the state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a mutation</h1>
                
            
            
                
<p>Let's go on and add a mutation as well. In <kbd>store.js</kbd>, replace the contents with the following code:</p>
<pre>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import axios from 'axios';<br/><br/>Vue.use(Vuex);<br/><br/>export const store = new Vuex.Store({<br/>  state: {<br/>    movies: []<br/>  },<br/>  <strong>mutations: {</strong><br/><strong>    MOVIES: (state, payload) =&gt; {</strong><br/><strong>      state.movies = payload;</strong><br/><strong>    }</strong><br/><strong>  },</strong><br/>  actions: {<br/>    fetchMovies: (context, payload) =&gt; {<br/>      axios({<br/>        method: 'get',<br/>        url: '/movies',<br/>      })<br/>        .then((response) =&gt; {<br/>          context.commit("MOVIES", response.data.movies);<br/>        })<br/>        .catch(() =&gt; {<br/>        });<br/>    }<br/>  }<br/>})</pre>
<p>The preceding <kbd>mutations</kbd> mutate the state of the movies of the application.</p>
<p>We now have the <kbd>action</kbd> and the <kbd>mutation</kbd>. Now, the last part is to add a <kbd>getter</kbd> method, which gets the value of the <kbd>movies</kbd> from the state. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a getter</h1>
                
            
            
                
<p>Let's add the <kbd>getter</kbd> method in <kbd>store.js</kbd> that we created to manage the state of our application:</p>
<pre>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import axios from 'axios';<br/><br/>Vue.use(Vuex);<br/><br/>export const store = new Vuex.Store({<br/>  state: {<br/>    movies: []<br/>  },<br/>  <strong>getters: {</strong><br/><strong>    fetchMovies: state =&gt; state.movies,</strong><br/><strong>  },</strong><br/>  mutations: {<br/>    MOVIES: (state, payload) =&gt; {<br/>      state.movies = payload;<br/>    }<br/>  },<br/>  actions: {<br/>    fetchMovies: (context, payload) =&gt; {<br/>      axios({<br/>        method: 'get',<br/>        url: '/movies',<br/>      })<br/>        .then((response) =&gt; {<br/>          context.commit("MOVIES", response.data.movies);<br/>        })<br/>        .catch(() =&gt; {<br/>        });<br/>    }<br/>  }<br/>})</pre>
<p>That's it. When we navigate to <kbd>http://localhost:8081/movies/add</kbd>, we should have a functional Vuex implementation that fetches the movies to the home page.</p>
<p>Let's move on to implement the store when we add a movie to the application. We will follow the same process as we did earlier:</p>
<ol>
<li>Modify <kbd>AddMovie.vue</kbd> to call the action to create the movie</li>
<li>Create an <kbd>action</kbd> that calls the POST API to create movies</li>
<li>Create a <kbd>mutation</kbd> to <kbd>store</kbd> the added new movie to the <kbd>movies</kbd> store</li>
</ol>
<p>Replace the <kbd>script</kbd> contents in <kbd>AddMovie.vue</kbd> with the following code:</p>
<pre>&lt;script&gt;<br/>export default {<br/>  data: () =&gt; ({<br/>    movie: null,<br/>    valid: true,<br/>    name: '',<br/>    description: '',<br/>    genre: '',<br/>    release_year: '',<br/>    nameRules: [<br/>      v =&gt; !!v || 'Movie name is required',<br/>    ],<br/>    genreRules: [<br/>      v =&gt; !!v || 'Movie genre year is required',<br/>      v =&gt; (v &amp;&amp; v.length &lt;= 80) || 'Genre must be less than equal to <br/>      80 characters.',<br/>    ],<br/>    releaseRules: [<br/>      v =&gt; !!v || 'Movie release year is required',<br/>    ],<br/>    select: null,<br/>    years: [<br/>      '2018',<br/>      '2017',<br/>      '2016',<br/>      '2015',<br/>    ],<br/>  }),<br/>  methods: {<br/>    <strong>submit() {</strong><br/><strong>      if (this.$refs.form.validate()) {</strong><br/><strong>        const movie = {</strong><br/><strong>          name: this.name,</strong><br/><strong>          description: this.description,</strong><br/><strong>          release_year: this.release_year,</strong><br/><strong>          genre: this.genre,</strong><br/><strong>        }</strong><br/><strong>        this.$store.dispatch("addMovie", movie);</strong><br/><strong>        this.$refs.form.reset();</strong><br/><strong>        this.$router.push({ name: 'Home' });</strong><br/><strong>      }</strong><br/><strong>      return true;</strong><br/><strong>    },</strong><br/>    clear() {<br/>      this.$refs.form.reset();<br/>    },<br/>  },<br/>};<br/>&lt;/script&gt;</pre>
<p>Then, add the <kbd>action</kbd> and <kbd>mutations</kbd> to the <kbd>store.js</kbd> file:</p>
<pre>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import axios from 'axios';<br/><br/>Vue.use(Vuex);<br/><br/>export const store = new Vuex.Store({<br/>  state: {<br/>    movies: []<br/>  },<br/>  getters: {<br/>    fetchMovies: state =&gt; state.movies,<br/>  },<br/>  mutations: {<br/>    <strong>ADD_MOVIE: (state, payload) =&gt; {</strong><br/><strong>      state.movies.unshift(payload);</strong><br/><strong>    },</strong><br/>    MOVIES: (state, payload) =&gt; {<br/>      state.movies = payload;<br/>    }<br/>  },<br/>  actions: {<br/>    <strong>addMovie: (context, payload) =&gt; {</strong><br/><strong>      return axios({</strong><br/><strong>          method: 'post',</strong><br/><strong>          data: payload,</strong><br/><strong>          url: '/movies',</strong><br/><strong>          headers: {</strong><br/><strong>            'Content-Type': 'application/json',</strong><br/><strong>          },</strong><br/><strong>        })</strong><br/><strong>          .then((response) =&gt; {</strong><br/><strong>            context.commit("ADD_MOVIE", response.data)</strong><br/><strong>            this.$swal(</strong><br/><strong>              'Great!',</strong><br/><strong>              'Movie added successfully!',</strong><br/><strong>              'success',</strong><br/><strong>            );</strong><br/><strong>          })</strong><br/><strong>          .catch(() =&gt; {</strong><br/><strong>            this.$swal(</strong><br/><strong>              'Oh oo!',</strong><br/><strong>              'Could not add the movie!',</strong><br/><strong>              'error',</strong><br/><strong>            );</strong><br/><strong>          });</strong><br/><strong>    },</strong><br/>    fetchMovies: (context, payload) =&gt; {<br/>      axios({<br/>        method: 'get',<br/>        url: '/movies',<br/>      })<br/>        .then((response) =&gt; {<br/>          context.commit("MOVIES", response.data.movies);<br/>        })<br/>        .catch(() =&gt; {<br/>        });<br/>    }<br/>  }<br/>})</pre>
<p>Finally, run the following command to build our static files for Vue components:</p>
<pre><strong>$ npm run build</strong></pre>
<p>Now, when we log in and add a movie with the admin user, the movie should be added to the database and also be listed on the home page.</p>
<p>Using Vuex in a small application such as this is overkill. The best use of Vuex is in large-scale applications where data needs to be transferred and shared among several components. This gives you an idea of how Vuex works and how to implement it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we discussed what Vuex is—the core concepts of Vuex state, getters, mutations, actions, and how to use them in an application. We discussed how to structure our application to implement Vuex and the benefits it adds when the application grows larger.</p>
<p>In the next chapter, we will cover how to write unit tests and integration for Vue.js and Node.js application.</p>


            

            
        
    </body></html>