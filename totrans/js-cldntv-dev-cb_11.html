<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Welcoming Polycloud</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, the following recipes will be covered:</p>
<ul>
<li>Creating a service in Google Cloud Functions</li>
<li>Creating a service in Azure Functions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Vendor lock-in is a common concern with serverless, cloud-native development. However, this concern is a relic of the monolithic thinking that stems from monolithic systems that must be changed in whole from one vendor to another. Autonomous services, on the other hand, can be changed one by one. Nevertheless, the elusive promise of <em>write once; run anywhere</em> is still the battle cry of the <em>multi-cloud</em> approach. Yet, this approach ignores the fact that the part that is written once is only the tip of a very big iceberg, and what lies below the waterline embodies the most risk and does not translate directly between cloud providers. This inevitably leads to the use of a least-common denominator set of tools and techniques that can more easily be lifted and shifted from one provider to another.</p>
<p>We chose instead to embrace the <em>disposable architecture</em> of fully managed, value-added cloud services. This <em>serverless-first</em> approach empowers self-sufficient, full-stack teams to be lean and experiment with new ideas, fail-fast, learn, and adjust course quickly. This leads naturally to a <em>polyglot-cloud</em> or <em>polycloud</em> approach, where teams select the best cloud provider service by service. Ultimately, companies do have a preferred cloud provider. But there is an argument to be made for diversification, where some percentage of services are implemented on different cloud providers to gain experience and leverage. The goal then is to have a consistent pipeline experience across services with similar, if not the same, tools, techniques, and patterns for development, testing, deployment, and monitoring. The recipes in many of the previous chapters focused on AWS fully managed, value-added cloud services. The recipes in this chapter demonstrate how a consistent cloud-native development pipeline experience is possible with additional cloud providers, such as Google and Azure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a service with Google Cloud Functions</h1>
                </header>
            
            <article>
                
<p>The <strong>Serverless Framework</strong> provides an abstraction layer above many different cloud providers that facilitates a consistent development and deployment experience. This recipe demonstrates how to create a service with Google Cloud Functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Before starting this recipe, you will need a Google Cloud Billing Account, project, and credentials that are configured for the Serverless Framework (<a href="https://serverless.com/framework/docs/providers/google/guide/credentials">https://serverless.com/framework/docs/providers/google/guide/credentials</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch11/gcp --path cncb-gcp</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-gcp</kbd> directory<span> with </span><kbd>cd cncb-gcp</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-gcp<br/><br/>provider:<br/>  name: <strong>google</strong><br/>  runtime: nodejs8<br/>  project: cncb-project<br/>  region: ${opt:region}<br/>  <strong>credentials</strong>: ~/.gcloud/keyfile.json<br/><br/>plugins:<br/>  - <strong>serverless-google-cloudfunctions</strong><br/><br/>functions:<br/>  hello:<br/>    handler: hello<br/>    events:<br/>      - http: path<br/>...<br/>#resources:<br/>#  resources:<br/>#    - type: storage.v1.bucket<br/>#      name: my-serverless-service-bucket</pre>
<ol start="4">
<li>Review the file named <kbd>index.js</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">exports.hello = <strong>(request, response)</strong> =&gt; {<br/>  console.log('env: %j', process.env);<br/>  response.status(200).send('... Your function executed successfully!');<br/>};</pre>
<ol start="5">
<li>Install the dependencies with <kbd>npm install</kbd>.</li>
<li>Run the tests<span> with </span><kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack: </li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-gcp@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-gcp<br/>&gt; sls deploy -v --r us-east1 "-s" "john"<br/>...<br/>Serverless: Done...<br/>Service Information<br/>service: cncb-gcp<br/>project: cncb-project<br/>stage: john<br/>region: us-east1<br/><br/>Deployed functions<br/>hello<br/>  <strong>https://us-east1-cncb-project.cloudfunctions.net/hello</strong></pre>
<ol start="9">
<li>Review the deployment and resources in the Google Cloud console.</li>
<li>Invoke the endpoint shown in the stack output in the following commands:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl -v https://us-east1-cncb-project.cloudfunctions.net/hello</strong><br/>...<br/>JavaScript Cloud Native Development Cookbook! Your function executed successfully!</pre>
<ol start="11">
<li>Take a look at the logs:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ sls logs -f hello -r us-east1 -s $MY_STAGE</strong><br/>...<br/>2018-08-24T05:10:20...: Function execution took 12 ms, finished with status code: 200    <br/>...</pre>
<ol start="12">
<li>Remove the stack once you are finished<span> with </span><kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The first thing to note is that the steps of the <em>How to do it…</em> section are virtually the same as all the previous recipes. This is because the Serverless Framework abstracts away the deployment details, and we further wrap all the commands with <em>NPM</em> scripts to encapsulate dependency management. From here, we can use all the same tools and techniques for development and testing as outlined in <a href="390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml" target="_blank">Chapter 6</a>, <em>Building a Continuous Deployment Pipeline</em>. This enables team members to transition smoothly when working across services that are implemented on different cloud providers.</p>
<p>The <kbd>serverless-google-cloudfunctions</kbd> plugin handles the details of interacting with the Google Cloud APIs, such as Cloud Functions and Deployment Manager, to provision the service. The <kbd>serverless.yml</kbd> file should look very familiar. We specify the <kbd>provider.name</kbd> as <kbd>google</kbd> and set up the <kbd>plugins</kbd>, and then we focus on defining the <kbd>functions</kbd> and <kbd>resources</kbd>. The details are cloud provider-specific, but the details of cloud provider-specific, value-added services are usually why we choose a specific provider for a specific service. The Node.js code in the <kbd>index.js</kbd> file is familiar as well, though the function signature is different. Ultimately, there is a clear mapping of Google Cloud services for implementing the cloud-native patterns and techniques enumerated in the recipes throughout this cookbook.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a service with Azure Functions</h1>
                </header>
            
            <article>
                
<p>The Serverless Framework provides an abstraction layer above many different cloud providers that facilitates a consistent development and deployment experience. This recipe demonstrates how to create a service with Azure Functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Before starting this recipe, you will need an Azure account and credentials configured for the Serverless Framework (<a href="https://serverless.com/framework/docs/providers/azure/guide/credentials">https://serverless.com/framework/docs/providers/azure/guide/credentials</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create the project from the following template:</li>
</ol>
<pre style="padding-left: 30px">$ sls create --template-url https://github.com/danteinc/js-cloud-native-cookbook/tree/master/ch11/azure --path cncb-azure</pre>
<ol start="2">
<li>Navigate to the <kbd>cncb-azure</kbd> directory<span> with </span><kbd>cd cncb-azure</kbd>.</li>
<li>Review the file named <kbd>serverless.yml</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">service: cncb-azure-${opt:stage}<br/><br/>provider:<br/>  name: <strong>azure</strong><br/>  location: ${opt:region}<br/><br/>plugins:<br/>  - <strong>serverless-azure-functions</strong><br/><br/>functions:<br/>  hello:<br/>    handler: handler.hello<br/>    events:<br/>      - http: true<br/>        x-azure-settings:<br/>          authLevel : anonymous<br/>      - http: true<br/>        x-azure-settings:<br/>          direction: out<br/>          name: res</pre>
<ol start="4">
<li>Review the file named <kbd>handler.js</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 30px">module.exports.hello = function <strong>(context)</strong> {<br/>  context.log('context: %j', context);<br/>  context.log('env: %j', process.env);<br/><br/>  context.res = {<br/>    status: 200,<br/>    body: '... Your function executed successfully!',<br/>  };<br/><br/>  context.done();<br/>};</pre>
<ol start="5">
<li>Install the dependencies<span> with </span><kbd>npm install</kbd>.</li>
<li>Run the tests<span> with </span><kbd>npm test</kbd>.</li>
<li>Review the contents generated in the <kbd>.serverless</kbd> directory.</li>
<li>Deploy the stack: </li>
</ol>
<pre style="padding-left: 30px"><strong>$ npm run dp:lcl -- -s $MY_STAGE</strong><br/><br/>&gt; cncb-azure@1.0.0 dp:lcl &lt;path-to-your-workspace&gt;/cncb-azure<br/>&gt; sls deploy -v -r 'East US' "-s" "john"<br/>...<br/>Serverless: Creating resource group: cncb-azure-john-rg<br/>Serverless: Creating function app: cncb-azure-john<br/>...<br/>Serverless: Successfully created Function App</pre>
<ol start="9">
<li>Review the deployment and resources in the Azure console.</li>
<li>Tail the logs from another terminal:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ sls logs -f hello -r 'East US' -s $MY_STAGE</strong><br/>Serverless: Logging in to Azure<br/>Serverless: Pinging host status...<br/>2018-08-25T04:02:34  Welcome, you are now connected to log-streaming service.<br/>2018-08-25T04:05:00.843 [Info] Function started (Id=...)<br/>2018-08-25T04:05:00.856 [Info] context: {...}<br/>2018-08-25T04:05:00.856 [Info] env: {...}<br/>2018-08-25T04:05:00.856 [Info] Function completed (Success, Id=..., Duration=19ms)</pre>
<ol start="11">
<li>Invoke the endpoint shown in the stack output in the following commands:</li>
</ol>
<pre style="padding-left: 30px"><strong>$ curl -v https://cncb-azure-$MY_STAGE.azurewebsites.net/api/hello</strong><br/>...<br/>JavaScript Cloud Native Development Cookbook! Your function executed successfully!</pre>
<ol start="12">
<li>Remove the stack once you are finished<span> with </span><kbd>npm run rm:lcl -- -s $MY_STAGE</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The first thing to note is that the steps of the <em>How to do it…</em> section are virtually the same as in all the previous recipes. This is because the Serverless Framework abstracts away the deployment details, and we further wrap all the commands with <em>NPM scripts</em> to encapsulate dependency management. From here we can use all the same tools and techniques for development and testing as outlined in <a href="390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml" target="_blank">Chapter 6</a>, <em>Building a Continuous Deployment Pipeline</em>. This enables team members to transition smoothly when working across services that are implemented on different cloud providers.</p>
<p>The <kbd>serverless-azure-cloudfunctions</kbd> plugin handles the details of interacting with the Azure APIs, such as Azure Functions and Resource Manager, to provision the service. The <kbd>serverless.yml</kbd> file should look very familiar. We specify the <kbd>provider.name</kbd> as <kbd>azure</kbd> and set up the <kbd>plugins</kbd>, and then we focus on defining the <kbd>functions</kbd>. The details are cloud provider-specific, but the details of the cloud provider-specific, value-added services are usually why we choose a specific provider for a specific service. The Node.js code in the <kbd>handler.js</kbd> file is familiar as well, though the function signature is different. Ultimately, there is a clear mapping of Azure services for implementing the cloud-native patterns and techniques enumerated in the recipes throughout this cookbook.</p>


            </article>

            
        </section>
    </body></html>