["```js```", "````js````", "```js `{`    `\"compilerOptions\": {`    `\"module\": \"commonjs\",`    `\"moduleResolution\": \"node\",`    `\"pretty\": true,`    `\"sourceMap\": false,`    `\"target\": \"ESNext\",`    `\"outDir\": \"./dist\",`    `\"baseUrl\": \"./src\",`    `\"noImplicitAny\": false,`    `\"esModuleInterop\": true,`    `\"removeComments\": true,`    `\"preserveConstEnums\": true,`    `\"experimentalDecorators\": true,`    `\"alwaysStrict\": true,`    `\"forceConsistentCasingInFileNames\": true,`    `\"emitDecoratorMetadata\": true,`    `\"resolveJsonModule\": true,`    `\"skipLibCheck\": true`    `},`    `\"include\": [\"src/**/*.ts\", \"src/**/*.json\"],`    `\"exclude\": [\"node_modules\"],`    `\"files\": [\"node_modules/@types/node/index.d.ts\"]`    `}`    Thereafter, create `**server_config.json**` which will be used for all configurations, such as, `**port**`, `**database config**`, and so on.    `// server_config.json`   ```", "```js```", "````js``` `{`    `\"port\": 3000,`    `\"db_config\": {`    `\"db\": \"postgres\",`    `\"username\": \"root\",`    `\"password\": \"123456\",`    `\"host\": \"localhost\",`    `\"port\": 5432,`    `\"dbname\": \"pms\"`    `}`    `}`    **Note**: *Please always keep stronger passwords for any account*.    As part of the configuration process, we will integrate `**ESLint**` to enhance development practices. We will include a `**.eslintrc.json**` file in the project’s root directory, as demonstrated in the code snippet as follows:    `.eslintrc.json`    `{`    `\"env\": {`    `\"browser\": true,`    `\"es2021\": true`    `},`    `\"extends\": [\"eslint:recommended\", \"plugin:@typescript-eslint/recommended\"],`    `\"overrides\": [],`    `\"parser\": \"@typescript-eslint/parser\",`    `\"parserOptions\": {`    `\"ecmaVersion\": \"latest\",`    `\"sourceType\": \"module\"`    `},`    `\"plugins\": [\"@typescript-eslint\"],`    `\"rules\": {`    `\"linebreak-style\": [\"error\", \"unix\"],`    `\"quotes\": [\"error\", \"single\"],`    `\"semi\": [\"error\", \"always\"]`    `}`    `}`    Nodemon is beneficial for Node.js developers as it enhances development workflow, improves productivity, and provides real-time feedback during the development process.    With Nodemon, developers receive immediate feedback on code changes as the server restarts instantly. This allows for quick validation of code modifications and helps catch errors early in the development process. This eliminates the need to manually stop and restart the server after every code modification, saving time and streamlining the development process.    Let us install `**nodemon**` open root directory of project on terminal and paste following command:    `$ npm install nodemon -D`    # [Project Directory Structure](toc.xhtml#s122a)    When structuring a `**Node.js**` project with `**Express**` and `**TypeScript**`, a common directory structure can be as follows:    `pms-be/`    `|-- src/`    `|   |-- components/`    `|   |   |-- users/`    `|   |   |   |-- users_controller.ts`    `|   |   |   |-- users_entity.ts`    `|   |   |   |-- users_routes.ts`    `|   |   |   |-- users_service.ts`    `|   |   |-- projects/`    `|   |   |   |-- projects_controller.ts`    `|   |   |   |-- projects_entity.ts`    `|   |   |   |-- projects_routes.ts`    `|   |   |   |-- projects_service.ts`    `|   |   |-- tasks/`    `|   |   |   |-- tasks_controller.ts`    `|   |   |   |-- tasks_entity.ts`    `|   |   |   |-- tasks_routes.ts`    `|   |   |   |-- tasks_service.ts`    `|   |-- utils/`    `|   |   |-- db_utils.ts`    `|   |   |-- common.ts`    `|   |-- routes/`    `|   |   |-- index.ts`    `|   |--express_server.ts`    `|   |-- main.ts`    `|-- tests/`    `|   |-- users_spec.tjs`    `|-- package-lock.json`    `|-- package.json`    `|-- node_modules`    `|-- tsconfig.json`    `|-- server_config.json`    `|-- .gitignore`    `|-- README.md`    As shown in the project directory structure, we have already set up `**server_config.json**` and `**tsconfig.json**` files. As we proceed with the development, we will create various folders and files to organize the code and manage different aspects of the project.    # [Create Express Server](toc.xhtml#s123a)    Before creating an express server, add one `**README.md**` file that includes how this project will run and the required configuration so anyone can easily work on that.    **README.md**    `# Project Management System API`    `## Prerequisites`    `-   Node.js: Ensure that Node.js is installed on your machine. You can download it from [here](https://nodejs.org).`    `## Install Project Dependency Packages`    ````", "```js ```", "```js` ```", "```js`    `## Configuration`    `create server_config.json file in the root directory and save it. Inside that file, add the desired configuration values in the format KEY:VALUE.`    `-   Configuration Options`    `| Configuration Key | Description                           |`    `| ----------------- | ------------------------------------ |`    `| PORT              | The port number on which project run |`    `## Compile Project`    `Once you are in the project's root directory, you can use the tsc command with the --watch flag to enable automatic recompilation when changes are detected. Run the following command`    ```", "```js ```", "```js` ```", "```js`    `## Run Project`    `-   on local machine run during development`    ```", "```js ```", "```js` ```", "```js`    `-   on server after development`    ```", "```js ```", "```js` ```", "```js`    Let us create a new directory called `**\"src\"**` and inside it, create two files named `**\"main.ts\"**` and `**\"express_server.ts\"**` to set up an Express `HTTP` server with the following code. As our project is currently small-scale, we will not be using `**cluster**` and `**forks**` at the OS level, but we will implement reconnection to the server in case of any exceptions. Depending on your project’s specific requirements, you can choose to use the `**\"main.ts\"**` file with or without `**cluster**` functionality.    `// main.ts`   ```", "```js```", "````js`` `import cluster from 'cluster';`    `import { ExpressServer } from './express_server';`   ````", "```````js` `// connect the express server`    `const server = new ExpressServer();`    `process.on('uncaughtException', (error: Error) => {`    ``console.error(`Uncaught exception in worker process ${process.pid}:`, error);``    `// Close any open connections or resources`    `server.closeServer();`    `setTimeout(() => {`    `cluster.fork();`    `cluster.worker?.disconnect();`    `}, 1000);`    `});`    `// Gracefully handle termination signals`    `process.on('SIGINT', () => {`    `console.log('Received SIGINT signal');`    `// Close any open connections or resources`    `server.closeServer();`    `});`    `process.on('SIGTERM', () => {`    `console.log('Received SIGTERM signal');`    `// Close any open connections or resources`    `server.closeServer();`    `});`    # [With Cluster for a Large Project](toc.xhtml#s124a)    With the presence of the `cluster` module, if the server crashes due to any reason, we can catch the event when the process exits and spawn another child. This way, we ensure that the server does not crash and it remains available for serving upcoming requests.    `// main.ts`   ``````js```````", "``````js``````", "```js```", "````js` `import express, { Application } from 'express';`    `import { IServerConfig } from './utils/config';`    `import * as config from '../server_config.json';`    `export class ExpressServer {`    `private static server = null;`    `public server_config: IServerConfig = config;`    `constructor() {`    `const port = this.server_config.port ?? 3000;`    `// initialize express app`    `const app = express();`   ````", "```` `app.get('/ping', (req, res) => {`    `res.send('pong');`    `});`    `ExpressServer.server = app.listen(port, () => {`    ``console.log(`Server is running on port ${port} with pid = ${process.pid}`);``    `});`    `}`    `//close the express server for safe on uncaughtException`    `public closeServer(): void {`    `ExpressServer.server.close(() => {`    `console.log('Server closed');`    `process.exit(0);`    `});`    `}`    `}`    Afterwards, create a directory with `**utils**` and inside add `**config.ts**` file for define config interface as follows:    `// config.ts`   ```js````", "```js```", "```js```", "```js```", "````` `import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn,`    `UpdateDateColumn } from 'typeorm';`    `@Entity()`    `export class Projects {`    `@PrimaryGeneratedColumn('uuid')`    `project_id: string;`    `@Column({ length: 30, nullable: false, unique: true })`    `name: string;`    `@Column({ length: 500 })`    `description: string;`    `@Column('uuid', { array: true, default: [] })`    `user_ids: string[];`    `@Column()`    `start_time: Date;`    `@Column()`    `end_time: Date;`    `@CreateDateColumn()`    `created_at: Date;`    `@UpdateDateColumn()`    `updated_at: Date;`    `}`    The `**@PrimaryGeneratedColumn('uuid**'**)**` decorator specifies that the `**project_id**` property is the primary key of the `**projects**` table and will be automatically generated as a `**UUID**` when a new project is inserted.    The `**@Column({ length: 30, nullable: false, unique: true })**` decorator is applied to the `**name**` property, indicating that it is a string with a maximum length of 30 characters. It is also marked as `**nullable: false**` (required) and `**unique: true**` (must be unique among projects).    The `**@Column({ length: 500 })**` decorator is used for the description property, representing a string with a maximum length of 500 characters.    The `**@Column('uuid**'**, { array: true, default: [] })**` decorator is applied to the `**user_ids**` property, indicating that it is an array of strings (`**string[]**`) that will store user IDs associated with the project. The default value for the array is set to an empty array (`**[]**`).    The `@Column()` decorator is used for both the `start_time` and `end_time` properties, which represent Date objects.    In the context of the application, every project comprises multiple tasks, and each task is linked to a single project. Consequently, within the tasks entity, there exists a one-to-one relationship with the project entity. Similarly user and role joins here project and task join will be established with join columns as `**project_id**` for both tables in the following task entity that we will explore in detail.    # [Task Entity](toc.xhtml#s130a)    Create a new file named `**tasks_entity.ts**` and include the following code in it:    `// tasks_entity.ts`    `import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn,`    `UpdateDateColumn, ManyToOne, JoinColumn } from 'typeorm';`    `import { Users } from '../users/users_entity';`    `import { Projects } from '../projects/projects_entity';`    `export enum Status {`    `NotStarted = 'Not-Started',`    `InProgress = 'In-Progress',`    `Completed = 'Completed',`    `}`    `export enum Priority {`    `Low = 'Low',`    `Medium = 'Medium',`    `High = 'High',`    `}`    `@Entity()`    `export class Tasks {`    `@PrimaryGeneratedColumn('uuid')`    `task_id: string;`    `@Column({ length: 30, nullable: false, unique: true })`    `name: string;`    `@Column({ length: 500 })`    `description: string;`    `@Column()`    `@ManyToOne(() => Projects, (projectData) => projectData.project_id)`    `@JoinColumn({ name: 'project_id' })`    `project_id: string;`    `@Column()`    `@ManyToOne (() => Users, (userData) => userData.user_id)`    `@JoinColumn({ name: 'user_id' })`    `user_id: string;`    `@Column()`    `estimated_start_time: Date;`    `@Column()`    `estimated_end_time: Date;`    `@Column()`    `actual_start_time: Date;`    `@Column()`    `actual_end_time: Date;`    `@Column({`    `type: 'enum',`    `enum: Priority, // Use the enum type here`    `default: Priority.Low, // Set a default value as Low`    `})`    `priority: Priority;`    `@Column({`    `type: 'enum',`    `enum: Status, // Use the enum type here`    `default: Status.NotStarted, // Set a default value as Not-Started`    `})`    `status: Status;`    `@Column('text', { array: true, default: [] })`    `supported_files: string[];`    `@CreateDateColumn()`    `created_at: Date;`    `@UpdateDateColumn()`    `updated_at: Date;`    `}`    The code imports necessary decorators from TypeORM, including `Entity`, `**PrimaryGeneratedColumn**`, `**Column**`, `**CreateDateColumn**`, and `**UpdateDateColumn**`. It also imports the `**Users**` and `**Projects**` entities, as they will be used to establish one-to-one relationships with the `Tasks` entity.    `**Priority**` and `**Status**` `**enums**` define possible values for the status and priority columns of the `**Tasks**` entity. By using `**enums**`, we ensure that only specific predefined values can be assigned to these columns.    `**@ManyToOne**` decorators establish many-to-one relationships with the `**Projects**` and Users entities. The first argument of `**@ManyToOne**` is a function that returns the related `**entity**` class. This signifies that many tasks can be associated with one project or user. This second argument denotes the inverse side of the relationship, indicating the properties `**project_id**` and `**user_id**` in the `**Projects**` and `**Users**` entities, respectively, which reference the tasks entity. The `**@JoinColumn**` decorator specifies the name of the foreign key column in the `**tasks**` table that links to the related `**Projects**` and `**Users**` entities.    # [Comment Entity](toc.xhtml#s131a)    Let us define the comment entity in `**comments_entity.ts**` with the following code:    `// comments_entity.ts`    `import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn,`    `UpdateDateColumn, JoinColumn, OneToOne } from 'typeorm';`    `import { Users } from '../users/users_entity';`    `import { Tasks } from '../tasks/tasks_entity';`    `@Entity()`    `export class Comments {`    `@PrimaryGeneratedColumn('uuid')`    `comment_id: string;`    `@Column({ type: 'text' })`    `comment: string;`    `@OneToOne(() => Users, (userData) => userData.user_id)`    `@JoinColumn({ name: 'user_id' })`    `user_id: string;`    `@OneToOne(() => Tasks, (taskData) => taskData.task_id)`    `@JoinColumn({ name: 'task_id' })`    `task_id: string;`    `@Column('text', { array: true, default: [] })`    `supported_files: string[];`    `@CreateDateColumn()`    `created_at: Date;`    `@UpdateDateColumn()`    `updated_at: Date;`    `}`    The provided code includes essential TypeORM decorators like `Entity`, `**PrimaryGeneratedColumn**`, `**Column**`, `**CreateDateColumn**`, and `**UpdateDateColumn**`. Additionally, it imports the `Users` and `Tasks` entities, which play a crucial role in setting up one-to-one relationships with the `**Comments**` entity.    The `**@PrimaryGeneratedColumn('uuid**'**)**` decorator specifies that the `**comment_id**` property is the primary key of the comments table and will be automatically generated as a `UUID` when a new comment is inserted. The comment property is of type text, allowing it to store larger textual data.    `**@OneToOne**` decorators establish one-to-one relationships with the `Users` and `Tasks` entities. The first argument of `**@OneToOne**` is a function that returns the related `**entity**` class. Meanwhile, the second argument defines the inverse side of the relationship, referring to the properties `**user_id**` and `**task_id**` in the `Users` and `Tasks` entities, respectively. The `**@JoinColumn**` decorator then specifies the name of the foreign key column in the `**comments**` table, which references the related `Users` and `Tasks` entities.    The `**supported_files**` property is an array of strings (`**string[]**`) which will store the urls of different files in the array.    After defining all the entities, their purpose remains incomplete without synchronization to the database. So, let us synchronize them with the database and automatically create the corresponding tables. To achieve this, we can update the `**db.ts**` file with the following code:    `// db.ts`    `import { DataSource } from 'typeorm';`    `import { IServerConfig } from './config';`    `import * as config from '../../server_config.json';`    `import { Roles } from '../components/roles/roles_entity';`    `import { Users } from '../components/users/users_entity';`    `import { Projects } from '../components/projects/projects_entity';`    `import { Tasks } from '../components/tasks/tasks_entity';`    `import { Comments } from '../components/comments/comments_entity';`    `export class DatabaseUtil {`    `public server_config: IServerConfig = config;`    `constructor() {`    `this.connectDatabase();`    `}`    `private connectDatabase() {`    `try {`    `const db_config = this.server_config.db_config;`    `const AppDataSource = new DataSource({`    `type: 'postgres',`    `host: db_config.host,`    `port: db_config.port,`    `username: db_config.username,`    `password: db_config.password,`    `database: db_config.dbname,`    `entities: [Roles, Users, Projects, Tasks, Comments],`    `synchronize: true,`    `logging: false,`    `});`    `AppDataSource.initialize()`    `.then(() => {`    `console.log('Connected to the database');`    `})`    `.catch((error) => console.log(error));`    `} catch (error) {`    `console.error('Error connecting to the database:', error);`    `}`    `}`    `}`    The entities array should include all the entity classes you have defined (`**Users**`, `**Projects**`, `**Tasks**`, and `**Comments**`) to be synchronized with the database.    Setting `**synchronize:**` `**true**` ensures that the database tables are automatically created or updated to match the defined entities.    Once you run this code, the defined entities will be synchronized with the database, and the corresponding tables will be created or updated accordingly.    # [Routes](toc.xhtml#s132a)    Routing plays a crucial role in modern application development. Routing provides a structured way to navigate through an application. By establishing routes, users can seamlessly interact with distinct sections of the application through designated URLs.    Routing is basically a way to respond to any request coming to a specific endpoint based on method and parameters.    Route Definition follows this pattern:    `app.METHOD(PATH, HANDLER)`    `**\"app\"**` refers to an instance of `Express`.    `**\"METHOD\"**` pertains to an `HTTP` request method, written in lowercase.    `**\"PATH\"**` designates a specific server path.    `**\"HANDLER\"**` represents the function executed upon matching the route.    Routes consist of basically four parts:    *   **URL Paths**:          Each route definition includes a URL path or pattern that users can enter in the browser’s address bar or click as links.                    For example, `**\"/api/login\"**`           *   **HTTP Method**:          Routes specify the HTTP methods (`**GET**`, `**POST**`, `**PUT**`, `**DELETE**`, and so on) that are allowed for each path. Different HTTP methods trigger different actions in the application. For example, a `GET` request might retrieve data, while a `POST` request might submit data. You can explore it in detail through this link [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)           *   **Route Handlers**:          For each URL path, there is a corresponding handler function or controller that defines the actual logic for functionality to be executed. This can include rendering a specific view, fetching data from a database, processing user input, and more.           *   **Route Parameters**: Some paths might include dynamics that act as placeholders for specific values. These are often indicated with a colon, like `**\":id\"**`.          For example, `**\"/users/:id\"**` could represent a user’s profile page, where `**\":id\"**` is replaced with the actual user’s ID.              Let us construct routes following the outlined structure:    `├── routes`    `│   └── index.ts  `    `├── components`    `├── roles`    `│   └── roles_entity.ts`    `│   └── roles_routes.ts`    `│   └── roles_controller.ts`    `├── users`    `│   └── users_entity.ts`    `│   └── users_routes.ts`    `│   └── users_controller.ts`    `├── projects`    `│   └── projects_entity.ts`    `│   └── projects_routes.ts`    `│   └── projects_controller.ts`    `├── tasks`    `│   └── tasks_entity.ts`    `│   └── tasks_routes.ts`    `│   └── tasks_controller.ts`    `|── comments`    `|    └── comments_entity.ts`    `|    └── comments_routes.ts`    `|    └── comments_controller.ts`    By the preceding structure, we will establish a `**\"routes\"**` directory, containing an `**\"index.ts\"**` file, within the `**\"src\"**` directory. This `**\"index.ts\"**` file will function as the root for the individual routes of each module. We will also create all individual routes and controller files for each component and update them as we develop APIs step by step.    Each module encompasses functionalities for adding, updating, retrieving, and deleting, along with obtaining specific details about a particular data. Each route can cover CRUD (`**Create**`, `**Read**`, `**Update**`, `**Delete**`) operations having a basepoint as `**\"/api/componentname\"**` where `**componentname**` can be `**roles**`, `**users**`, `**projects**`, `**task**` and `**comments**`:    *   `**Create**`: This route allows the addition of new data. It is typically associated with an HTTP `**POST**` request to a path ex. `**\"/api/componentname\"**`. *   `**Update**`: The update route lets you modify existing data. It is triggered by an HTTP `**PUT**` request to a path like `**\"/api/componentname/:id\"**`, where `**\":id\"**` represents the specific entries identifier. *   `**Retrieve All**`: This route enables the retrieval of a list of all roles. It is often invoked via an HTTP `**GET**` request to the `**\"/api/componentname\"**` path. *   `**Retrieve Specific**`: This route is used to fetch details about a specific role. It is initiated by an HTTP `GET` request to a path like `**\"/api/componentname/:id\"**`. *   `**Delete**`: The delete route allows the removal of roles. It is typically triggered by an HTTP `DELETE` request to a path like `**\"/api/componentname/:id\"**`.    # [Role Routes](toc.xhtml#s133a)    Now, update `**role_controller.ts**` file with empty skeleton functions.    `// role_controller.ts`    `export class RoleController {`    `public addHandler() {`    `// addHandler`    `}`    `public getAllHandler() {`    `// getAllHandler`    `}`    `public getDetailsHandler() {`    `// getDetailsHandler`    `}`    `public async updateHandler() {`    `// updateHandler`    `}`    `public async deleteHandler() {`    `// deleteHandler`    `}`    `}`    Afterwards, modified `**role_routes.ts**` with the following code:    `// role_routes.ts`    `import { Express } from 'express';`    `import { RoleController } from './roles_controller';`    `export class RoleRoutes {`    `private baseEndPoint = '/api/roles';`    `constructor(app: Express) {`    `const controller = new RoleController();`    `app.route(this.baseEndPoint)`    `.get(controller.getAllHandler)`    `.post(controller.addHandler);`    `app.route(this.baseEndPoint + '/:id')`    `.get(controller.getDetailsHandler)`    `.put(controller.updateHandler)`    `.delete(controller.deleteHandler);`    `}`    `}`    Similarly, we will update all controller files by changing class names, such as `**UserController**`, `**ProjectController**`, `**TaskController**`, and `**CommentController**`, and import them in respective route files with modifying basepoint.    # [User Routes](toc.xhtml#s134a)    Let us modify `**users_controller.ts**` and `**users_routes.ts**` files, respectively, as follows:    `// users_controller.ts`    `export class UserController {`    `public addHandler() {`    `// addHandler`    `}`    `public getAllHandler() {`    `// getAllHandler`    `}`    `public getDetailsHandler() {`    `// getDetailsHandler`    `}`    `public async updateHandler() {`    `// updateHandler`    `}`    `public async deleteHandler() {`    `// deleteHandler`    `}`    `}`    `// users_routes.ts`    `import { Express } from 'express';`    `import { UserController } from './users_controller';`    `export class UserRoutes {`    `private baseEndPoint = '/api/users';`    `constructor(app: Express) {`    `const controller = new UserController();`    `app.route(this.baseEndPoint)`    `.get(controller.getAllHandler)`    `.post(controller.addHandler);`    `app.route(this.baseEndPoint + '/:id')`    `.get(controller.getDetailsHandler)`    `.put(controller.updateHandler)`    `.delete(controller.deleteHandler);`    `}`    `}`    # [Project Routes](toc.xhtml#s135a)    Let us modify `**projects_controller.ts**` and `**projects_routes.ts**` files, respectively, as follows:    `// project_controller.ts`    `export class ProjectController {`    `public addHandler() {`    `// addHandler`    `}`    `public getAllHandler() {`    `// getAllHandler`    `}`    `public getDetailsHandler() {`    `// getDetailsHandler`    `}`    `public async updateHandler() {`    `// updateHandler`    `}`    `public async deleteHandler() {`    `// deleteHandler`    `}`    `}`    `// projects_routes.ts`    `import { Express } from 'express';`    `import { ProjectController } from './projects_controller';`    `export class ProjectRoutes {`    `private baseEndPoint = '/api/projects';`    `constructor(app: Express) {`    `const controller = new ProjectController();`    `app.route(this.baseEndPoint)`    `.get(controller.getAllHandler)`    `.post(controller.addHandler);`    `app.route(this.baseEndPoint + '/:id')`    `.get(controller.getDetailsHandler)`    `.put(controller.updateHandler)`    `.delete(controller.deleteHandler);`    `}`    `}`    # [Task Routes](toc.xhtml#s136a)    Let us modify `**tasks_controller.ts**` and `**tasks_routes.ts**` files, respectively, as follows:    `// tasks_controller.ts`    `export class TaskController {`    `public addHandler() {`    `// addHandler`    `}`    `public getAllHandler() {`    `// getAllHandler`    `}`    `public getDetailsHandler() {`    `// getDetailsHandler`    `}`    `public async updateHandler() {`    `// updateHandler`    `}`    `public async deleteHandler() {`    `// deleteHandler`    `}`    `}`    `// tasks_routes.ts`    `import { Express } from 'express';`    `import { TaskController } from './tasks_controller';`    `export class TaskRoutes {`    `private baseEndPoint = '/api/tasks';`    `constructor(app: Express) {`    `const controller = new TaskController();`    `app.route(this.baseEndPoint)`    `.get(controller.getAllHandler)`    `.post(controller.addHandler);`    `app.route(this.baseEndPoint + '/:id')`    `.get(controller.getDetailsHandler)`    `.put(controller.updateHandler)`    `.delete(controller.deleteHandler);`    `}`    `}`    # [Comment Routes](toc.xhtml#s137a)    Let us modify `**comments_controller.ts**` and `**comments_routes.ts**` files, respectively, as follows:    `// comments_controller.ts`    `export class CommentController {`    `public addHandler() {`    `// addHandler`    `}`    `public getAllHandler() {`    `// getAllHandler`    `}`    `public getDetailsHandler() {`    `// getDetailsHandler`    `}`    `public async updateHandler() {`    `// updateHandler`    `}`    `public async deleteHandler() {`    `// deleteHandler`    `}`    `}`    `// comments_routes.ts`    `import { Express } from 'express';`    `import { CommentController } from './comments_controller';`    `export class CommentRoutes {`    `private baseEndPoint = '/api/comments';`    `constructor(app: Express) {`    `const controller = new CommentController();`    `app.route(this.baseEndPoint)`    `.get(controller.getAllHandler)`    `.post(controller.addHandler);`    `app.route(this.baseEndPoint + '/:id')`    `.get(controller.getDetailsHandler)`    `.put(controller.updateHandler)`    `.delete(controller.deleteHandler);`    `}`    `}`    We define all routes based on components individually. However, these routes need to be initialized from the Express server, so import all routes in one file and call it from the Express server.    Create `**routes**` directory and `**index.ts**` with the following code:    `// index.ts`   ```js` `import { Express, Router } from 'express';`    `import { RoleRoutes } from '../components/roles/roles_routes';`    `import { UserRoutes } from '../components/users/users_routes';`    `import { ProjectRoutes } from '../components/projects/projects_routes';`    `import { TaskRoutes } from '../components/tasks/tasks_routes';`    `import { CommentRoutes } from '../components/comments/comments_routes';`    `export class Routes {`    `public router: Router;`    `constructor(app: Express) {`    `const routeClasses = [`    `RoleRoutes,`    `UserRoutes,`    `ProjectRoutes,`    `TaskRoutes,`    `CommentRoutes`    `];`    `for (const routeClass of routeClasses) {`    `try {`    `new routeClass(app);`    ``console.log(`Router : ${routeClass.name} - Connected`);``    `} catch (error) {`    ``console.log(`Router : ${routeClass.name} - Failed`);``    `}`    `}`    `}`    `}`    Afterward, modify `**express_server.ts**` with import `**routes**` in the `app`:    `// express_server.ts`   ``` `import expressfrom 'express';`    `import { IServerConfig } from './utils/config';`    `import * as config from '../server_config.json';`    `import { Routes } from './routes';`    `export class ExpressServer {`    `private static server = null;`    `public server_config: IServerConfig = config;`    `constructor() {`    `const port = this.server_config.port ?? 3000;`    `// initialize express app`    `const app = express();`    `app.use(bodyParser.urlencoded({ extended: false }));`    `app.use(bodyParser.json());`    `app.get('/ping', (req, res) => {`    `res.send('pong');`    `});`    `const routes = new Routes(app);`    `if (routes) {`    `console.log('Server Routes started for server');`    `}`    `ExpressServer.server = app.listen(port, () => {`    ``console.log(`Server is running on port ${port} with pid =``    ``${process.pid}`);``    `});`    `}`    `//close the express server for safe on uncaughtException`    `public closeServer(): void {`    `ExpressServer.server.close(() => {`    `console.log('Server closed');`    `process.exit(0);`    `});`    `}`    `}`    While running the application, the following output will display in the terminal:    Output:    `Router : RoleRoutes - Connected`    `Router : UserRoutes - Connected`    `Router : ProjectRoutes - Connected`    `Router : TaskRoutes - Connected`    `Router : CommentRoutes - Connected`    `Server Routes started for server`    `Server is running on port 5000 with pid = 251784`    `Connected to the database`    # [Conclusion](toc.xhtml#s138a)    At this moment, now our server is running with a database utility, all entities along with their routes.    We learned about the use of the cluster module, using TypeORM for our database connection and query needs. We have our entities with all required columns.    As of now, we have empty and un-implemented route functions. In the next chapters, we will take each entity and implement the API.    # [Multiple Choice Questions](toc.xhtml#s139a)    1.  What is the primary goal of any project management software, including the PMS (Project Management System) discussed here?     1.  To develop web applications     2.  To allow individuals and teams to plan and execute tasks     3.  To organize data effectively     4.  To provide secure user login 2.  Which modules are considered must-have in the PMS system based on the defined tasks?     1.  User Module, Project Module, Task Module, and Comment Module     2.  Planning Module, API Development Module, and Unit Testing Module     3.  Communication Module, Deployment Module, and Database Design Module     4.  API Caching Module, Project Reports Module, and User Profile Module 3.  What is the primary objective of normalization in database design?     1.  To increase data redundancy     2.  To maintain data integrity and avoid data duplication     3.  To slow down query performance     4.  To increase the complexity of queries 4.  What role does the Role Table play in the PMS database?     1.  It defines the rights and permissions of users     2.  It stores project-related data     3.  It manages user profiles     4.  It records project creation and modification times 5.  Which file is typically generated as a result of running `**\"**npm init**\"**` for a Node.js project?     1.  `package-lock.json`     2.  `tsconfig.json`     3.  `server_config.json`     4.  `package.json` 6.  What does the `**\"**tsconfig.json**\"**` file specify in a TypeScript project?     1.  The project’s description     2.  The project’s dependencies     3.  TypeScript compiler options and settings     4.  The project’s test commands 7.  Which of the following decorators from TypeORM is used to mark a class as a TypeORM entity representing a database table?     1.  `@Entity()`     2.  `@Table()`     3.  `@Database()`     4.  `@Model()` 8.  Which TypeScript feature is used to define and enforce specific predefined values for the `**\"**status**\"**` and `**\"**priority**\"**` columns in the `**\"**Tasks**\"**` entity?     1.  Type assertions     2.  Type inference     3.  Enums     4.  Generics 9.  What is the purpose of the `@JoinColumn` decorator in the `**\"**Tasks**\"**` entity class?     1.  To specify the name of the entity class     2.  To define a foreign key constraint     3.  To specify the name of the foreign key column     4.  To create a new table in the database 10.  How would you trigger the update route for modifying existing data in Express.js?     1.  Send an HTTP POST request to a path like `**\"**/api/componentname**\"**`     2.  Send an HTTP PUT request to a path like `**\"**/api/componentname/:id**\"**`     3.  Send an HTTP GET request to a path like `**\"**/api/componentname**\"**`     4.  Send an HTTP DELETE request to a path like `**\"**/api/componentname/:id**\"**`    # [Answers](toc.xhtml#s140a)    1.  b 2.  a 3.  b 4.  a 5.  d 6.  c 7.  a 8.  c 9.  c 10.  b    # [Further Reading](toc.xhtml#s141a)    [https://www.postgresqltutorial.com](https://www.postgresqltutorial.com)    [https://typeorm.io](https://typeorm.io)    [https://www.npmjs.com/package/pg](https://www.npmjs.com/package/pg) ```js ```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````", "```js` ```", "```js```", "``` ```", "```````js``` ``````js```````", "``````js``````", "``````js``````", "``` ```", "```js```", "````js````"]