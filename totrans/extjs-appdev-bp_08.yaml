- en: Chapter 8. Practical – Questionnaire Component
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 实践 – 问卷组件
- en: We now have three practical applications under our belt. The objective has been
    to show the process of designing an application and think it through in a series
    of careful steps to create a clear picture of the project that's we're going to
    build. This time around, there's going to be a change of pace and rather than
    looking at how "we" would design and build an application, I'll be guiding you
    through my own process of creating a multiple-step, dynamic questionnaire component.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了三个实际的应用程序。目标是展示设计应用程序的过程，并通过一系列谨慎的步骤来思考它，以清晰地描绘出我们将要构建的项目。这一次，我们将有所改变，而不是查看“我们”如何设计和构建应用程序，而是我将引导你通过我创建多步骤、动态问卷组件的自身过程。
- en: 'Here are the features of the application that will be the subject of this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了本章将要讨论的应用程序的功能：
- en: A reusable package that can be included in any application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可重用的包，可以包含在任何应用程序中
- en: Theme variables and mixins to allow visual integration in other apps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题变量和混入，以允许在其他应用程序中进行视觉集成
- en: Splitting a questionnaire into multiple steps, each with multiple questions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问卷拆分为多个步骤，每个步骤包含多个问题
- en: Construct the UI dynamically from incoming server data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从传入的服务器数据动态构建UI
- en: A JSON object produced by the questionnaire, representing the steps, questions,
    and the answers that the user has provided
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由问卷生成的JSON对象，表示步骤、问题和用户提供的答案
- en: Use Ext JS Associations to help structure application data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ext JS关联来帮助结构化应用程序数据
- en: Why the step back from the all-inclusive "we" to a look at my own architecture
    process? I hope that it'll give you a more practical look at the thought processes
    that go into an application design. You can also see how there are always multiple
    correct paths that an architect can pursue. Sketching out these paths and investigating
    them before writing any code will avoid the "analysis paralysis" that hits many
    projects and causes them to grind to a halt when difficult questions need answers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么从包容性的“我们”转向审视我自己的架构过程？我希望这能让你更实际地了解应用程序设计中涉及的思想过程。你还可以看到建筑师总是有多个正确的路径可以选择。在编写任何代码之前绘制这些路径并调查它们，将避免许多项目遇到的“分析瘫痪”，当需要答案时，这会导致项目停滞不前。
- en: Application design – my way
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序设计 – 我的风格
- en: My first port of call when thinking about an application doesn't involve fancy
    tools or an IDE. Once the customer requirements are established, I take myself
    as far away from a computer as possible, wash all thoughts of JavaScript and Ext
    JS from my head, and remove as many distractions as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我思考一个应用程序时，我的第一步并不涉及花哨的工具或IDE。一旦确立了客户需求，我会尽可能地远离电脑，从我的脑海中清除JavaScript和Ext JS的所有想法，并尽可能地消除所有干扰。
- en: With that done, I grab a large notebook and a pencil and get scribbling. I've
    never found a better way to quickly draft ideas than a bit of manual labor, so
    while I'm designing in the same way as we've seen in the previous few chapters,
    I can avoid getting bogged down with drawing tools and UML diagrams.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我拿起一个大笔记本和一支铅笔开始涂鸦。我从未找到过比一点手工劳动更好的快速草拟想法的方法，所以当我以我们在前几章中看到的方式设计时，我可以避免陷入绘图工具和UML图中的困境。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: All of this needs to be formalized in documented design decisions later. The
    purpose is to quickly test out ideas and avoid dead ends.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都需要在后续的文档化设计决策中规范化。目的是快速测试想法并避免死胡同。
- en: How did I start?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我是如何开始的？
- en: '![Application design – my way](img/5308OT_08_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计 – 我的风格](img/5308OT_08_01.jpg)'
- en: 'Well, it''s not pretty, but you can see the relationship between this and the
    diagrams of UI views we saw in previous chapters. Note that the intention with
    these images is not to spell out the design in exacting detail, but simply to
    give an insight into the process I went through, warts and all! Eventually, I''ll
    use these sketches to build something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它并不漂亮，但你可以看到这与我们在前几章中看到的UI视图图之间的关系。请注意，这些图像的意图并不是详细说明设计，而是简单地提供我对过程的洞察，包括所有瑕疵！最终，我会用这些草图构建类似的东西：
- en: '![Application design – my way](img/5308OT_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计 – 我的风格](img/5308OT_08_02.jpg)'
- en: What are the features I picked out from this original sketch?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我从原始草图中挑选出了哪些功能？
- en: Questionnaire header, changing per step
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随步骤变化的问卷标题
- en: Panes containing an introduction and a conclusion to the questionnaire
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含问卷引言和结论的窗格
- en: Panes for each of the steps making up the application
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用中每个步骤的窗格
- en: A step can have introduction text
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个步骤可以有一个简介文本
- en: A question needs explanation text
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个问题需要解释文本
- en: Navigation buttons to move between steps
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航按钮，用于在步骤之间移动
- en: A progress bar to show the number of steps completed and numbers until the end
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进度条来显示已完成的步骤数量和剩余的数字
- en: In addition, this component needs to be able to validate the mandatory questions
    in a step that have been completed before the user can move to the next step.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个组件需要能够验证在用户可以移动到下一步之前已经完成的步骤中的必填问题。
- en: Rather than spending lots of time in front of a computer creating the perfect
    UI design, I was able to quickly flesh out an idea to see how it looked and this
    informed me about my design requirements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与其花大量时间在电脑前创建完美的UI设计，我能够快速地 flesh out 一个想法，看看它看起来如何，这让我对我的设计要求有了了解。
- en: Data structure
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: These initial sketches enabled me to quickly think about the underlying data
    powering the component. In previous chapters, we've stopped here to discuss whether
    the design requirements can be fulfilled by Ext JS. Instead, we're going to push
    ahead, put technology to one side, and just focus purely on architecture.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些初步的草图使我能够快速思考支撑组件的底层数据。在前几章中，我们在这里停下来讨论设计要求是否可以通过Ext JS来满足。相反，我们将继续前进，把技术放在一边，纯粹关注架构。
- en: In some ways—as we're going with MVVM—the architecture is technology agnostic.
    We can create the kind of application that we want to build without feeling constrained
    by the framework we're using. This can be dangerous; in that, we might lose sight
    of particular client requirements or start drafting something that might turn
    out to be impossible. To this end, we introduce new checks and balances that we'll
    discuss in a little while.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面——因为我们采用MVVM——架构是技术无关的。我们可以创建我们想要构建的应用，而不会受到我们使用的框架的限制。这可能会很危险；在那儿，我们可能会失去对特定客户需求的关注，或者开始草拟一些可能无法实现的东西。为此，我们引入了新的检查和平衡措施，我们稍后会讨论。
- en: 'For now, I continued with my pencil and paper to work out a data structure.
    As in previous cases, the UI design informs the underlying data requirements.
    Here''s a quick insight into my design doodles:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我继续用铅笔和纸来制定数据结构。和以前的情况一样，UI设计决定了底层的数据需求。以下是我设计涂鸦的快速洞察：
- en: '![Data structure](img/5308OT_08_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![数据结构](img/5308OT_08_03.jpg)'
- en: 'It''s the same as in previous chapters, just a bit messier! Again, don''t worry
    about the detail. Look at the rough notes and the scribbles and realize that the
    initial stages of an application design are an organic process and things can
    (and will) take a meandering path. Here''s what my doodles led to in terms of
    data structure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 和前几章一样，只是稍微乱一些！再次提醒，不要担心细节。看看粗略的笔记和涂鸦，你会意识到应用设计的初期是一个有机的过程，事情可能会（并且确实会）走一条蜿蜒的道路。以下是我涂鸦中关于数据结构的一些想法：
- en: Questionnaire
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问卷
- en: Title
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题
- en: Introduction
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简介
- en: Conclusion
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结论
- en: Steps[]
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤[]
- en: Title
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标题
- en: Introduction
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简介
- en: Questions[]
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题[]
- en: Name
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称
- en: Required?
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是否必需？
- en: Question text
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题文本
- en: Field type
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段类型
- en: I'm not yet worrying about what inherits from what at this stage. I just know
    that I'd like to have a single questionnaire that has many steps and these steps
    will each have many questions. From here, I just fleshed out the fields each class
    needs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我还没有担心什么继承什么的问题。我只知道我想有一个包含许多步骤的单个问卷，每个步骤都会有许多问题。从这里，我只是 fleshed out 每个类需要的字段。
- en: Consider carefully
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细考虑
- en: It's at this point I have to tell you that I lied to you. In the purest sense,
    it would be fantastic to think that you can sketch out the full application architecture
    on paper, but in reality, you will always do so with an eye on the real world.
    Look back to my last page of pencil doodles and you'll see a few notes like "associations"
    with a giant underline. That's there because I knew that the data structure I've
    described previously will be implemented using Ext JS associations, a feature
    we haven't yet used in this book, but one that can be very powerful.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我必须告诉你，我对你撒了谎。在纯粹的意义上，想象你可以在纸上绘制出完整的应用架构图是极好的，但现实中，你总是带着对现实世界的关注来做这件事。回顾我上一页的铅笔涂鸦，你会看到一些带有巨大下划线的笔记，比如“关联”。这是因为我知道之前描述的数据结构将使用Ext
    JS的关联来实现，这是我们在这本书中还没有使用过的功能，但它可以非常强大。
- en: As much as possible though, I've tried to push past any thoughts of detail,
    but trusted my knowledge of Ext JS to pop to the fore without any warning signs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我尽可能地抛开细节的思考，并信任我对 Ext JS 的了解，使其在没有任何警告的情况下浮现出来。
- en: Data flow
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流
- en: With the previous data structure in mind, I started to think more about how
    the information supplied from an API would flow through view models and allow
    me to build the user interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前的数据结构，我开始思考从 API 提供的信息如何通过视图模型流动，并允许我构建用户界面。
- en: I had a feeling that validation was going to complicate the application, so
    I started sketching out some ideas for the parts of the UI that would be affected.
    The user can't proceed to the next step until the current step is valid. In this,
    its mandatory questions have been answered so the "next" button needs to be disabled
    until this happens. I started drawing again, but quickly a degree of "analysis
    paralysis" kicked in. How should this work? There are several Ext JS features
    that could help; will model validation binding work here or will it have to be
    manual handling of validation events. Earlier, I mentioned "checks and balances"
    to avoid building something that Ext JS won't support; I decided to take some
    time out and investigate the best way to implement this in Ext JS.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一种感觉，验证将会使应用程序复杂化，所以我开始勾勒出受影响的 UI 部分的想法。用户必须完成当前步骤的验证才能继续到下一步。在这个过程中，其强制性问题已经回答，因此“下一步”按钮需要在此发生之前禁用。我开始再次绘图，但很快，就出现了一种“分析瘫痪”的程度。这应该如何工作？有几个
    Ext JS 特性可能有所帮助；模型验证绑定在这里是否适用，或者是否需要手动处理验证事件。早些时候，我提到了“制衡”以避免构建 Ext JS 不支持的东西；我决定抽出一些时间来调查在
    Ext JS 中实现这一点的最佳方式。
- en: 'Call this a "spike" as we did in [Chapter 5](ch05.html "Chapter 5. Practical
    – a CMS Application"), *Practical – a CMS Application*, or call it a prototype.
    It doesn''t really matter whether we write this code and then throw it away; if
    it helps the process, then it''s a valuable exercise. I built it standalone (outside
    of an MVC or MVVM structure) and it''s horrible. Look at this code snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第 5 章](ch05.html "第 5 章。实践 - 一个 CMS 应用程序")中做的那样，称之为“原型”，或者称之为“原型”。我们是否编写并丢弃这段代码并不重要；如果它有助于过程，那么它是一项有价值的练习。我是独立构建的（在
    MVC 或 MVVM 结构之外），而且很糟糕。看看这个代码片段：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I don''t wish this code to be my worst enemy. Shouldn''t every piece of code
    we write be pristine and well considered? In the real world, almost no one can
    see this code. It''s to test out my ideas and find out what feels right and it
    doesn''t have to be tidy or maintainable. It''s a one-off. Here''s what I wanted
    to test out:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我不希望这段代码成为我的最大敌人。我们写的每一行代码不应该是纯净和经过深思熟虑的吗？在现实世界中，几乎没有人能看到这段代码。它是为了测试我的想法并找出什么感觉是对的，它不需要整洁或可维护。它是一次性的。这是我想要测试的内容：
- en: Will the `modelValidation` feature be useful with auto-generated form fields?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modelValidation` 功能与自动生成的表单字段一起使用会有用吗？'
- en: Will I be able to bind to questions to get the validation state of the current
    step?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我能否绑定到问题以获取当前步骤的验证状态？
- en: Will it feel natural to use these features or is there an easier way?
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些功能会感觉自然吗？或者有更简单的方法吗？
- en: We've seen how view models can be used to create simple declarative applications
    and they can be extremely powerful when used correctly. In this application, fields
    are being generated from API data and each field had its own question model. Propagating
    the validity of this model up to the relevant parts of the user interface via
    view models seemed like it might be difficult. What did I discover?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到视图模型可以用来创建简单的声明性应用程序，并且当正确使用时它们可以非常强大。在这个应用程序中，字段是从 API 数据生成的，并且每个字段都有自己的问题模型。通过视图模型将这个模型的验证状态传播到用户界面的相关部分似乎可能很困难。我发现了什么？
- en: A view model binding trick
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个视图模型绑定的技巧
- en: A slight difference of opinion with the team at Sencha regarding the way `modelValidation`
    behaves
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Sencha 团队关于 `modelValidation` 行为的看法略有不同
- en: A way of binding a button state to the state of an association
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种将按钮状态绑定到关联状态的方法
- en: This seems like a great result for this grubby code. Let's look at each point
    in turn.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是对这段肮脏代码的一个很好的结果。让我们逐一查看每个要点。
- en: A binding trick
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个绑定技巧
- en: 'This snippet of code is from the view model of a question''s form field:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段来自一个问题表单视图模型：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The view model has a question model and inherits the step model from its parent
    view model. We tell Ext JS that we''d like to bind to changes in the question
    model, deep changes, so any of its property changes and then trigger the `isValid`
    method on the parent step. This is great because the `isValid` method can in turn
    trigger changes on the parent step, propagating the state of the questions up
    to the step. Here''s the `isValid` code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型有一个问题模型，并从其父视图模型继承步骤模型。我们告诉Ext JS我们希望绑定到问题模型的变化，深层次的变化，因此任何属性的变化都会触发父步骤上的`isValid`方法。这很好，因为`isValid`方法可以反过来触发父步骤上的变化，将问题的状态传播到步骤。下面是`isValid`的代码：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It checks the validity of all the child questions and sets the valid property
    of the step accordingly. We can then bind to this valid value and have it affect
    other things (such as the disabled state of the "next" button in the UI).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查所有子问题的有效性，并相应地设置步骤的有效属性。然后我们可以绑定到这个有效值，并让它影响其他事物（例如UI中“下一步”按钮的禁用状态）。
- en: This is slightly counterintuitive because we're not binding directly to the
    `isValid` formula. Instead, we're using it to watch for changes on the question
    and then trigger changes on the step model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点稍微有些反直觉，因为我们并不是直接绑定到`isValid`公式上。相反，我们使用它来监视问题上的变化，然后触发步骤模型上的变化。
- en: A difference of opinion
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的意见
- en: 'There was a change in the behavior between Ext JS 5.0 and 5.0.1\. The `modelValidation`
    feature matches validation in the model with validation in the form, reducing
    duplication of code. In Ext JS 5, when the form values change, these changes will
    be synchronized to the model via binding. In Ext JS 5.0.1, this synchronization
    will only happen when the form field is valid. The idea is that the model should
    never be left in an invalid state based on form changes, but the problem occurs
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 5.0和5.0.1之间有行为上的变化。`modelValidation`功能将模型中的验证与表单中的验证匹配，减少了代码的重复。在Ext JS 5中，当表单值改变时，这些变化将通过绑定同步到模型。在Ext
    JS 5.0.1中，这种同步只会发生在表单字段有效时。想法是模型不应该基于表单变化而处于无效状态，但问题发生如下：
- en: User completes the form field and it becomes valid
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户完成表单字段，它变为有效
- en: The form value is passed to the model's field, which in turn becomes valid
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单值传递到模型的字段，该字段随后变为有效
- en: User changes the form field to make it invalid again
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户更改表单字段使其再次无效
- en: The change is not passed to the model, which remains valid
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化没有传递到模型，模型仍然有效
- en: 'This means that when binding to model value, you''ll get something that doesn''t
    reflect the real state of the UI. The model will say everything is valid when
    in fact the UI says differently. In the case of this application, the plan is
    to bind the "next" button to the model state, which will enable the button incorrectly
    in the preceding situation. My solution was to override this and return to the
    Ext JS 5.0 behavior as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当绑定到模型值时，你得到的东西并不反映UI的真实状态。模型会说一切有效，而实际上UI却表示不同。在这个应用程序的情况下，计划是将“下一步”按钮绑定到模型状态，这样在先前的情境中按钮会被错误地启用。我的解决方案是覆盖这个行为，并返回到Ext
    JS 5.0的行为，如下所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An alternative workaround would be to bind the "next" button to the value of
    the form field rather than the model value, but in our case, we need to do further
    work on the model value, so it's not a great solution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案是将“下一步”按钮绑定到表单字段的值而不是模型值，但在我们的情况下，我们需要对模型值进行进一步的工作，所以这不是一个很好的解决方案。
- en: A means to an end
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种达到目的的手段
- en: All of this allows you to have a chain of configuration that goes all the way
    from each individual question field to the question model, then to the step model,
    and to higher-level places in the user interface that depend on it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些允许你有一个从每个单独的问题字段到问题模型，再到步骤模型，以及依赖于它的用户界面更高层次配置的链。
- en: When I was writing this chapter, there were other ideas kicking around in my
    head as to how to implement it. A solution that handles validation events and
    uses listeners to propagate state through the application was another approach,
    but it ended up being less elegant despite the final idea being a little more
    complicated than our previous binding code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写这一章时，我脑海中还有其他关于如何实现它的想法。一个处理验证事件并使用监听器通过应用程序传播状态的解决方案是另一种方法，但最终的想法虽然比我们之前的绑定代码稍微复杂一些，但最终并没有那么优雅。
- en: Ext JS allows you to watch for deep changes in associations en-masse that would
    help, but at the time of writing this book, this change is not documented. Hopefully,
    it's coming in a post-5.0.1 version!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 允许您监视关联的深度变化，这会有所帮助，但在撰写本书时，这一变化尚未记录。希望它将在5.0.1版本之后出现！
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can see this change documented in the 5.0.1 release notes as EXTJS-13933
    at [http://dev.sencha.com/extjs/5.0.1/release-notes.html](http://dev.sencha.com/extjs/5.0.1/release-notes.html).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在5.0.1版本说明中看到这一变化，作为EXTJS-13933在[http://dev.sencha.com/extjs/5.0.1/release-notes.html](http://dev.sencha.com/extjs/5.0.1/release-notes.html)的记录。
- en: Sketchy sketching
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 草图绘制
- en: My biggest concern of the application has been solved to my satisfaction; I
    won't go into any more detail on my code spike because I'll reuse some of this
    code later once it's been tidied up.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我对应用程序的最大担忧已经得到了满意的解决；我不会详细介绍我的代码激增，因为稍后我会重新使用其中的一些代码。
- en: I moved on to working out the role of controllers in this application. What
    user-initiated events will we need to handle?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我继续研究在这个应用程序中控制器的作用。我们需要处理哪些由用户发起的事件？
- en: '![Sketchy sketching](img/5308OT_08_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![草图绘制](img/5308OT_08_04.jpg)'
- en: Initial sketches for controllers; there are several things here that didn't
    make it into the final version
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的初始草图；这里有一些东西没有进入最终版本
- en: 'The user can perform two main actions: completing the questionnaire itself
    and navigating between pages. It''s the navigation that the controller will concern
    itself with.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以执行两个主要操作：完成问卷本身和在页面之间导航。控制器将关注的是导航。
- en: 'At this point, I felt fairly confident that I''d fleshed out most of the tricky
    parts of the application. In the role of an architect, each of the diagrams and
    interactions that I sketched need to be turned into formal documentation in order
    to provide a point of reference for developers. Here''s what I came up with for
    the UI:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我相当自信地认为我已经详细说明了应用程序的大部分难点。作为架构师，我绘制的每个图表和交互都需要转化为正式文档，以便为开发者提供参考点。以下是我为
    UI 提出的方案：
- en: '![Sketchy sketching](img/5308OT_08_05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![草图绘制](img/5308OT_08_05.jpg)'
- en: There's no point in duplicating the work I've already shown you, so I won't
    go through each of these formalized diagrams, but it should be stressed that this
    isn't a step that can be skipped. As a developer, it's essential that there's
    a solid design document to refer back to when writing code and also to keep the
    architect accountable. The next step in the process is to move from pencil and
    paper back to the computer and start to write the code for our questionnaire component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要重复我已经向您展示的工作，因此我不会逐一介绍这些正式化的图表，但应该强调的是，这不是一个可以跳过的步骤。作为开发者，在编写代码时有一个坚实的基础设计文档是必不可少的，同时也可以让架构师负责。下一步是从小纸条和笔回到电脑前，开始编写我们的问卷组件的代码。
- en: Get set
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The questionnaire component that we'll build in this chapter will be reusable
    in any application. To that end, we can use an Ext JS package to create a bundle
    of code that can be built in the same way as a normal Ext JS application, but
    it can be incorporated as a component in our future applications. We discussed
    packages in [Chapter 3](ch03.html "Chapter 3. Application Structure"), *Application
    Structure*, but now we'll see how they can be used in practice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将构建的问卷组件将在任何应用程序中可重用。为此，我们可以使用 Ext JS 包创建一个可以像正常 Ext JS 应用程序一样构建的代码包，但它可以作为一个组件纳入我们的未来应用程序中。我们已在[第3章](ch03.html
    "第3章。应用程序结构")中讨论了包，但现在我们将看到它们在实际中的应用。
- en: 'Here''s how I started up the project that I used as a basis for this component
    and its test application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是启动作为此组件及其测试应用程序基础的项目的方式：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Building a package requires us to first create a workspace, so after doing so
    using the latest version of the SDK that I downloaded, I moved on to the `workspace`
    directory and issued the command to create the package itself, which I called
    `wizard`. Then, I created a test application that would host the package during
    development; I called this `questions`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包需要我们首先创建一个工作区，因此在使用我下载的最新版本的 SDK 之后，我转向 `workspace` 目录并发布了创建包本身的命令，我将其命名为
    `wizard`。然后，我创建了一个测试应用程序，在开发期间将托管该包；我将其称为 `questions`。
- en: 'I then get the test application up and running with:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我随后启动了测试应用程序，并使用以下命令：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The web server is now up and running at `http://localhost:1841/`. The final
    step is telling the test application to include the new package. I edited `questions-package/questions/app.json`
    and amended the `requires` member:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Web服务器已经启动并运行在`http://localhost:1841/`。最后一步是告诉测试应用程序包含新的包。我编辑了`questions-package/questions/app.json`并修改了`requires`成员：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we gave the package the name `wizard`, just add this in the array and we're
    good to go.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们给包命名为`wizard`，只需将其添加到数组中，我们就可以开始了。
- en: The package we're going to build is contained at `questions-space/packages/wizard`
    and will start off containing most of the same directories as an Ext JS application.
    We can now move to this directory and start building it in just the same way as
    we have in the past few chapters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的包位于`questions-space/packages/wizard`，并且最初将包含与 Ext JS 应用程序相同的多数目录。我们现在可以移动到这个目录，并像过去几章中那样开始构建它。
- en: The data layer
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层
- en: 'When writing the prototype, I did partially build the data classes that were
    required, so now let''s fully flesh them out:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写原型时，我部分构建了所需的数据类，因此现在让我们完全实现它们：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Standard stuff here with one exception is that a `toJSON` method that consumes
    applications can override in order to obtain JSON in a format they can use for
    further processing. The default implementation returns the data of the questionnaire
    object along with its association data. Alternatively, they can override the proxy
    configuration to save the questionnaire data to their own server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是标准操作，只有一个例外，那就是一个`toJSON`方法，应用程序可以覆盖它以获取他们可以用于进一步处理的JSON格式。默认实现返回问卷对象的数据及其关联数据。或者，他们可以覆盖代理配置以将问卷数据保存到他们自己的服务器。
- en: 'Let''s take a look at the model I used to represent a step in the questionnaire:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我在问卷中表示步骤所使用的模型：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are a couple of things to note on the `Step` model; firstly, the use of
    associations, which I realized would provide a really easy way to load the nested
    data for the whole questionnaire in a single action.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Step`模型上有几点需要注意；首先，关联的使用，我意识到这将提供一种非常简单的方式来通过单个操作加载整个问卷的嵌套数据。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The association is created using the `reference` option on the field with the
    `type` option specifying the full class name of the parent model and the inverse
    is the name of the association store that will be created on this parent `Questionnaire`.
    Ext JS 5 associations are a little confusing at first as they're always defined
    on the child, not the parent.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关联是通过在具有`type`选项指定父模型完整类名和反向为在此父`Questionnaire`上创建的关联存储名称的字段上使用`reference`选项来创建的。Ext
    JS 5的关联一开始可能会有些令人困惑，因为它们总是在子模型上定义，而不是在父模型上。
- en: Secondly, the `isValid` method enumerates the questions belonging to this step
    and sets the step's own valid field according to the validity of its questions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`isValid`方法枚举属于此步骤的问题，并根据其问题的有效性设置步骤自己的有效字段。
- en: 'Finally, here''s the `Question` model I built:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我所构建的`Question`模型：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, I have `child-side` of the `Step -> Questions` association defined in
    the same way as `Questionnaire -> Steps`. Using the `validators` config, I specify
    that answer should always be present, but I stumbled on a catch here that I could
    never have known about when just sitting down with a pencil and paper.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我以与`Questionnaire -> Steps`相同的方式定义了`Step -> Questions`关联的`child-side`。使用`validators`配置，我指定答案始终存在，但我在这里遇到了一个我从未想过的问题。
- en: I really wanted to be able to add validators at runtime so that I could check
    the required field of the `Step` model and add the `presence` check to the answer.
    This enables the end user to toggle whether a particular question is required
    or not.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很想能够在运行时添加验证器，这样我就可以检查`Step`模型的必填字段，并将`presence`检查添加到答案中。这使得最终用户可以切换特定问题是否必填。
- en: Unfortunately, after some intimate time with the Ext JS source code, it turns
    out that validators can only be defined on model class instances when they're
    defined and not on each instance of that class. Hopefully, this will be allowed
    in a later version—which at time of writing this book was 5.0.1—but I managed
    to come up with workarounds that enable this functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在与 Ext JS 源代码一些亲密接触之后，发现验证器只能在模型类实例定义时定义，而不能在类的每个实例上定义。希望这将在稍后的版本中得到允许——在撰写本书时是5.0.1版本——但我设法找到了一些工作区，使得这个功能得以实现。
- en: We need to override the `Question` class's `getValidation` method. In the event
    that required is `true`, I call the `getValidation` on the superclass to proceed
    with validation normally. However, if it's `false`, I return a new `Ext.data.Validation`
    instance, but don't actually run its validation in effect, providing the same
    result as if the validation had passed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重写`Question`类的`getValidation`方法。如果`required`为`true`，我会调用超类的`getValidation`方法以正常进行验证。然而，如果它是`false`，我会返回一个新的`Ext.data.Validation`实例，但实际上并不运行其验证，提供与验证通过相同的结果。
- en: While this works, and it's simple, it's one of these things that should be revisited
    with each new Ext JS version to see whether there's a more elegant way of solving
    the issue. I recommend code like this should be commented to let others know exactly
    why the workaround is needed and which version it applies to.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做是有效的，而且很简单，但这是那种应该随着每个新的 Ext JS 版本重新审视的问题之一，看看是否有更优雅的解决方案。我建议这样的代码应该添加注释，以便让其他人知道为什么需要这种解决方案以及它适用于哪个版本。
- en: The payload
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效载荷
- en: 'An interesting feature of associations is that it allows for the use of nested
    data. By loading data for the questionnaire and its steps and questions as a single
    JSON object, the child''s steps and questions association will be populated too.
    For example, take a look at this JSON:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关联的一个有趣特性是它允许使用嵌套数据。通过将问卷及其步骤和问题作为单个 JSON 对象加载数据，子步骤和问题的关联也会被填充。例如，看看这个 JSON：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This object includes data for the questionnaire with an array of child steps.
    The steps have their own array of questions, as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象包含问卷的数据，以及子步骤的数组。步骤有自己的问题数组，如下所示：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we load this, we would see "round 1" logged to the console. Some might question
    why we bother using models at all; we could use `Ext.Ajax` to load the JSON object
    directly into a view model. Models allow us to use validation and let us augment
    each `Model` instance with utility methods. The stores that are auto created on
    parent models give us shortcut methods to enumerate the records within and find
    individual child records.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载这个，我们会在控制台看到“round 1”被记录下来。有些人可能会质疑为什么我们甚至要使用模型；我们可以使用`Ext.Ajax`直接将 JSON
    对象加载到视图模型中。模型允许我们使用验证，并让我们为每个`Model`实例添加实用方法。在父模型上自动创建的存储提供了枚举记录和查找单个子记录的快捷方法。
- en: There's a little bit of overhead in setting up and working with models here,
    but it's worth it in the long run.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置和操作模型方面有一些开销，但从长远来看是值得的。
- en: The wizard component
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向导组件
- en: 'I felt pretty good about the data layer I''d built. It was frustrating to have
    spent time trying to work around this limitation to validators that I found, but
    the final result works well. It was time to move on to the user interface, starting
    with the main container for the questionnaire wizard:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我对自己构建的数据层感到相当满意。花费时间试图绕过我发现的验证器限制是令人沮丧的，但最终结果工作得很好。现在是时候转向用户界面，从问卷向导的主容器开始：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I'll break down each of the important parts of this code and try and explain
    the design decisions behind them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我将分解这段代码的每个重要部分，并尝试解释其背后的设计决策。
- en: The `ui` and `bodyCls` options are set as a way of hooking into this component
    via theming and CSS later. In particular, the `ui` option is a great way of reusing
    parts of the Ext JS theming system with your own components. We'll revisit this
    towards the end of the chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui`和`bodyCls`选项被设置为一种方式，以便通过主题和 CSS 在以后将其与组件挂钩。特别是，`ui`选项是重用 Ext JS 主题系统部分的一个很好的方式。我们将在本章末尾重新审视这一点。'
- en: After configuring the `viewModel`, `controller`, and `layout` options, I use
    a tactic that we've seen before, which is to create a new custom configuration
    option that will be used to bind to. I created a `questionnaire` config for me
    to bind a view model value to and you can see that bound value is also called
    `questionnaire`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了`viewModel`、`controller`和`layout`选项之后，我使用了一种之前看到过的策略，即创建一个新的自定义配置选项，该选项将被用于绑定。我创建了一个`questionnaire`配置，以便将视图模型值绑定到它，并且你可以看到绑定的值也被称为`questionnaire`。
- en: The final piece of the configuration puzzle is to bind the title of the questionnaire
    to the title of the wizard panel itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 配置难题的最后一部分是将问卷的标题绑定到向导面板本身的标题。
- en: Do it yourself
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自己动手做
- en: One of my favorite things about creating custom configuration options is that
    you get an extra hook in the form of an `applyOptionName` method. It's created
    automatically for each config option and is called by Ext JS before setting the
    value. It lets us customize or validate the configuration option and if we've
    bound a view model value to it, it lets us perform actions when the bound value
    updates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢创建自定义配置选项的一个原因是，你得到一个额外的钩子，即`applyOptionName`方法。它为每个配置选项自动创建，并在设置值之前由Ext
    JS调用。这让我们可以自定义或验证配置选项，如果我们将其绑定到视图模型值，它还允许我们在绑定的值更新时执行操作。
- en: 'I used this with `applyQuestionnaire`, which is used to build the items for
    the wizard panel when the questionnaire is bound. It performs the following three
    actions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`applyQuestionnaire`与它一起使用，当问卷绑定时用于构建向导面板的项目。它执行以下三个操作：
- en: Adds a container for the questionnaire introduction.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为问卷介绍添加一个容器。
- en: Adds a container for the questionnaire conclusion.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为问卷结论添加一个容器。
- en: Adds a `wizard-step` component for each step in the questionnaire using the
    `addStepPane` method.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`addStepPane`方法为问卷中的每个步骤添加一个`wizard-step`组件。
- en: Within `addStepPane`, the new `wizard-step` component is supplied with a view
    model that contains the `Step` model itself and immediately binds this to a step
    config option. It will be simpler to just pass in the `Step` model as a configuration
    option rather than using view models, but this would mean that we can't use this
    step in further binding formulas and it will be more awkward to react to changes
    in `Step`, such as validation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addStepPane`中，新的`wizard-step`组件被提供一个包含`Step`模型本身的视图模型，并将其立即绑定到一个步骤配置选项。直接传递`Step`模型作为配置选项而不是使用视图模型会更简单，但这意味着我们无法在进一步的绑定公式中使用此步骤，并且对`Step`的变化（如验证）做出反应会更困难。
- en: The second use of apply is via `applyActiveItem`, which will be triggered every
    time the `currentPosition` value on the view model changes. It's used to update
    the panel's `currentPosition` to switch from card to card as the user progresses
    through questionnaire, but I added in a check to ensure the wizard's items have
    been initialized before doing this. Without this check, setting `currentPosition`
    can raise an error if `currentPosition` is changed before the items have been
    set up.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`的第二个用途是通过`applyActiveItem`，它将在视图模型的`currentPosition`值每次更改时触发。它用于更新面板的`currentPosition`，以便在用户通过问卷时从卡片切换到卡片。但我添加了一个检查，以确保在执行此操作之前向导的项目已被初始化。如果没有这个检查，在项目设置之前更改`currentPosition`可能会引发错误。'
- en: Wizardly tools
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具向导
- en: The last piece of configuration for the main wizard panel is to create the navigation
    buttons and the progress indicator. I added these as `dockedItems` with the dock
    set at the "bottom" in order to have them in the footer of the panel. The progress
    bar is bound to the questionnaire's steps from the view model in order to build
    its step icons.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 主向导面板的最后一块配置是创建导航按钮和进度指示器。我将这些作为`dockedItems`添加，并将停靠位置设置为“底部”，以便它们位于面板的页脚中。进度条绑定到视图模型中的问卷步骤，以构建其步骤图标。
- en: One step forward
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向前迈出一步
- en: The navigation bar allows the user not only to proceed through the questionnaire,
    but also return to previous steps to review them. There's a "restart" button that
    takes the user back to the introduction. The "finish" button will be the one we'll
    use to communicate back to the host application when all questions are complete.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏不仅允许用户通过问卷，还可以返回到前面的步骤以进行审查。有一个“重启”按钮，可以将用户带回到介绍部分。而“完成”按钮将在所有问题完成后用于与主机应用程序通信。
- en: 'Each of these buttons is enabled or disabled depending on the validation state
    of each step (and therefore each question) and the user''s position in the questionnaire.
    Here''s the code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些按钮的启用或禁用都取决于每个步骤（因此每个问题）的验证状态以及用户在问卷中的位置。以下是代码：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I've delegated the responsibility for enabling and disabling these buttons to
    a view model. As there are other components that will be interested in these values,
    they're going to rest at the top-level view model of the wizard. We'll take a
    look at this code later.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将启用和禁用这些按钮的责任委托给一个视图模型。由于还有其他组件会对这些值感兴趣，它们将位于向导的顶级视图模型中。我们稍后会查看此代码。
- en: Making progress
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在取得进展
- en: 'The progress bar is a series of buttons that allows the user to determine how
    far they are along the questionnaire process and skip back to an earlier step.
    Each button needs to be aware of the user''s position in the questionnaire in
    order to determine whether it should be enabled or disabled. The "start" and "end"
    buttons are fixed, wherein they are available on every questionnaire, but the
    numbered step buttons need to be automatically generated and bound to the steps
    for currently loaded questionnaire. Let''s take a look at the code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条是一系列按钮，允许用户确定他们在问卷过程中的进度并跳转到前面的步骤。每个按钮都需要了解用户在问卷中的位置，以便确定它是否应该启用或禁用。"开始"和"结束"按钮是固定的，在每次问卷中都是可用的，但编号步骤按钮需要自动生成并绑定到当前加载的问卷的步骤。让我们看看代码：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's a surprising amount going on in this component. Remember that in the
    wizard panel, I set the `bind` config on this progress component to the questionnaire
    steps, and in the preceding code, you can see the custom steps configuration option—as
    long with the `defaultBindProperty`—that enables this.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中有很多事情在进行。记住，在向导面板中，我将此进度组件的 `bind` 配置设置为问卷步骤，在前面的代码中，你可以看到自定义步骤配置选项——以及
    `defaultBindProperty`——它启用了这一点。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that `defaultBindProperty` allows you to avoid explicitly setting the
    property to bind to, and Ext JS will automatically use the default.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`defaultBindProperty` 允许您避免显式设置要绑定的属性，并且 Ext JS 将自动使用默认值。
- en: 'I''ll skip over the `layout`, `cls`, and `defaultType` options and move on
    to the way I implemented `applySteps`. It builds an array of the following buttons:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我会跳过 `layout`、`cls` 和 `defaultType` 选项，转到实现 `applySteps` 的方式。它构建了一个以下按钮的数组：
- en: The start button, which is always enabled
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终启用的开始按钮
- en: The number buttons for each step, which are only enabled if the user has advanced
    to that step
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个步骤的数字按钮，只有当用户已经进入该步骤时才启用
- en: The end button, which is only enabled when the user is on the questionnaire
    conclusion
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束按钮仅在用户处于问卷结论时启用
- en: The end button's disabled state is deferred to a binding on the parent view
    model. For the individual step icons, a simple view model with the `isEnabled`
    formula is used to toggle the disabled state based on the current active step
    pane.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 结束按钮的禁用状态被推迟到父视图模型上的绑定。对于单个步骤图标，使用一个简单的视图模型和 `isEnabled` 公式来根据当前活动步骤面板切换禁用状态。
- en: When I was researching [Chapter 2](ch02.html "Chapter 2. MVC and MVVM"), *MVC
    and MVVM*, I found a little snippet describing MVC in Smalltalk and the way that
    individual UI components would have their own controller right down to text fields
    and the like. While it's rare that we'd go that far in our Ext JS applications,
    the use of a small, one formula view model for the step icons reminded me of this
    concept.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我研究[第2章](ch02.html "第2章。MVC和MVVM") *MVC和MVVM* 时，我发现了一段关于 Smalltalk 中 MVC 的描述以及单个
    UI 组件将拥有自己的控制器，直到文本框等。虽然我们很少在我们的 Ext JS 应用程序中走那么远，但为步骤图标使用一个小型、单公式视图模型让我想起了这个概念。
- en: My only gripe as I was writing it was that while the functionality was great,
    the syntax to just bind one property like this felt a little verbose. On the other
    hand, introducing another shorthand syntax would mean a new feature for Ext JS
    developers to learn; I think we have enough already!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我在编写时唯一的抱怨是，虽然功能很棒，但仅绑定一个属性这样的语法感觉有点冗长。另一方面，引入另一种简写语法意味着 Ext JS 开发者需要学习新功能；我认为我们已经足够多了！
- en: A final point regarding this component is that I append `lineHtml` to the container
    and configure a couple of styling hooks. This allows for a thin line connecting
    the progress buttons; it's a minor visual element, but has a nice effect.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个组件的最后一个要点是，我在容器中附加了 `lineHtml` 并配置了几个样式钩子。这允许有一条细线连接进度按钮；这是一个微小的视觉元素，但效果很好。
- en: Step by step
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步进行
- en: 'The next component to examine is the one that represents a step in the questionnaire
    and shows the associated questions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要检查的组件是代表问卷步骤并显示相关问题的组件：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's the standard setup for `Ext.form.Panel` here, configuring labels, and
    so on. Once again, I created a custom step config that we bound to in the parent
    `Wizard` panel's `addStepPane` method and use the matching apply method to build
    out the contents of the form.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Ext.form.Panel` 的标准设置，配置标签等。再次，我创建了一个自定义步骤配置，并在父 `Wizard` 面板的 `addStepPane`
    方法中绑定，并使用匹配的 `apply` 方法构建表单的内容。
- en: Note how I have set the `modelValidation` config to `true`. As a result of my
    prototype earlier in the chapter, I know that this is great way to avoid code
    duplication by creating validation on a model and have it take effect in the form
    UI. When building the questions for the step in `applyStep`, I make sure and bind
    `question.answer` to the form field value. This means that any validation on the
    question model's answer field will be applied to the form field UI automatically.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何将`modelValidation`配置设置为`true`。由于我在本章前面的原型中创建的验证，我知道这是通过在模型上创建验证并在表单UI中生效来避免代码重复的绝佳方式。在构建`applyStep`步骤中的问题，我确保将`question.answer`绑定到表单字段值。这意味着对问题模型答案字段的任何验证都将自动应用于表单字段UI。
- en: 'All of the other attributes of the form field are built dynamically from the
    question data, such as the label and the field type. The final thing to note here
    is that I use a separate view model and immediately populate it with the question.
    Look at the code for this view model:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段的其余属性都是根据问题数据动态构建的，例如标签和字段类型。这里需要特别注意的一点是，我使用了一个单独的视图模型，并立即用问题填充它。看看这个视图模型的代码：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's nothing complicated; it's just a little bit long to define inline and so
    I moved it to a separate file. The code here should also look very familiar because
    it's the same as the code from my prototype that I showed earlier in the chapter
    under the heading "A Binding Trick". I knew this would come in useful!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不复杂；只是定义起来有点长，所以我将其移动到了一个单独的文件。这里的代码也应该看起来非常熟悉，因为它与我之前在本章标题为“一个绑定技巧”下展示的原型中的代码相同。我知道这会很有用！
- en: Questionnaire command and control
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问卷调查命令与控制
- en: 'Nearly all of the pieces are in place. Note that I used a lot of binding expressions
    in the `Wizard` component so far, but I haven''t shown either the top-level view
    model or how the wizard deals with user interactions. I always like to keep controllers
    slim and the view controller here is no exception:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的组件都已就绪。请注意，到目前为止，我在`Wizard`组件中使用了大量的绑定表达式，但我还没有展示顶层视图模型或向导如何处理用户交互。我总是喜欢保持控制器简洁，这里的视图控制器也不例外：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The view controller listens for clicks on the navigation buttons and any enabled
    buttons on the progress bar, and in every case apart from `onFinishClick`, it
    manipulates the value of `currentStepIndex` on the view model. It doesn't have
    to speak to any other components, just this one value. I really like the elegance
    of this solution. We'll see how `currentStepIndex` influences the application
    when we review the wizard's view model.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器监听导航按钮和进度条上任何启用的按钮的点击事件，在除了`onFinishClick`之外的所有情况下，它都会在视图模型上操作`currentStepIndex`的值。它不需要与其他任何组件通信，只需与这个值通信。我真的非常喜欢这个解决方案的优雅性。当我们回顾向导的视图模型时，我们将看到`currentStepIndex`如何影响应用程序。
- en: The `onFinishClick` method is called when the user clicks on the finish button
    and raises a `controller-level` event called `wizardcomplete` with the completed
    questionnaire as its only argument. The host application can handle this event
    and retrieve the completed question data and dispose of the wizard component as
    it sees fit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击完成按钮时，会调用`onFinishClick`方法，并引发一个名为`wizardcomplete`的`controller-level`事件，其唯一参数是完成的问卷调查。宿主应用程序可以处理此事件，检索完成的问卷数据，并根据需要处理向导组件。
- en: This is another good example of decoupling this component from its host; the
    wizard needs to know nothing about the application it's embedded inside. It just
    fires the event and forgets about it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将此组件与其宿主解耦的另一个很好的例子；向导不需要了解它嵌入的应用程序。它只需触发事件，然后忘记它。
- en: The wizard model
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向导模型
- en: 'The final, and in my opinion most important, part of the puzzle is the top-level
    view model. This is the one that the wizard panel uses directly and is available
    to all child components of the panel thanks to the view model inheritance. Here''s
    the code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分，也是我认为最重要的部分，是顶层视图模型。这是向导面板直接使用的模型，并且由于视图模型继承，它对所有面板的子组件都可用。以下是代码：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that `currentPosition` is initialized at `0`, which represents the questionnaire
    introduction page in the UI and the first card in the wizard panel.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`currentPosition`初始化为`0`，这代表UI中的问卷调查介绍页面和向导面板中的第一张卡片。
- en: This one value is probably the most important in the whole application because
    it not only drives what is displayed on the UI through its binding to `activeItem`
    on the wizard panel, but also the state of the navigation and progress buttons.
    This is both direct—the progress component inherits and consumes `currentPosition`
    to set the disabled state of its buttons—and indirect, as in the way `isNextEnabled`
    uses it to get the `currentStep` model's validity and in turn is bound to the
    "next" navigation button.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值可能是整个应用程序中最重要的，因为它不仅通过将其绑定到向导面板上的`activeItem`来驱动UI上显示的内容，而且还影响导航和进度按钮的状态。这既是直接的——进度组件继承并消耗`currentPosition`来设置其按钮的禁用状态——也是间接的，例如`isNextEnabled`使用它来获取`currentStep`模型的有效性，然后反过来绑定到“下一个”导航按钮。
- en: Building up a couple of dependent formulae and allowing them to cascade down
    to child components gives a clear picture of how data flows from a single source
    (`questionnaire` and `currentPosition` on the wizard view model).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建几个依赖公式并允许它们级联到子组件，可以清楚地了解数据是如何从单个源（向导视图模型上的`questionnaire`和`currentPosition`）流动的。
- en: A delightful host
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一位令人愉悦的主办人
- en: 'The wizard is functionally complete and it''s time to show how we can embed
    it in an application. Look back and you''ll see that the main wizard component
    had the following `load` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 向导在功能上已经完成，现在是时候展示我们如何将其嵌入到应用程序中。回顾一下，你会发现主要向导组件有以下`load`方法：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This uses the `links` feature of the view model to trigger the loading of a
    questionnaire using its preconfigured proxy. With this in mind, the calling code
    could look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用视图模型的`links`功能来触发使用其预配置代理加载问卷。考虑到这一点，调用代码可能看起来像这样：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When `onClickButton` handler fires, `Ext.Window` is created containing our wizard
    component, and we then call the `load` method on the wizard itself, passing the
    ID of the questionnaire to load.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当`onClickButton`处理程序触发时，会创建一个包含我们的向导组件的`Ext.Window`，然后我们在向导本身上调用`load`方法，传递要加载的问卷的ID。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to include the wizard package in your application's `app.json`, as
    discussed earlier in the chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在应用程序的`app.json`中包含向导包，正如本章前面所讨论的。
- en: 'The view controller also listens for the `wizardcomplete` event and can use
    this to get the completed questionnaire instance for further processing and could
    also close the wizard window. These two integration points are all that a developer
    needs to use the wizard in their own application, but there''s one last thing
    that I wanted to explore when building this component: `theming`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器还监听`wizardcomplete`事件，并可以使用此事件获取完成的问卷实例以进行进一步处理，也可以关闭向导窗口。这两个集成点是开发者在使用自己的应用程序中应用向导所需的所有内容，但我在构建此组件时还想要探索最后一件事：`主题化`。
- en: Mixin the night away
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合夜晚
- en: I wanted consumers of the wizard component to be able to customize it, but this
    turned out to be very simple in most cases. As the main container for the wizard
    is a subclass of `Ext.Panel`, all of the relevant SCSS variables for this class
    can be overridden and it'll take effect for the wizard's container too.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让向导组件的消费者能够自定义它，但这种情况在大多数情况下都非常简单。由于向导的主要容器是`Ext.Panel`的子类，因此可以覆盖这个类中所有相关的SCSS变量，并且它将对向导的容器也生效。
- en: 'However, I wanted to create a custom look for the progress bar and in turn
    allow end users to customize it. To this end, I wrote a custom mixin:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我想要为进度条创建一个自定义的外观，并允许最终用户进行自定义。为此，我编写了一个自定义mixin：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The mixin accepts four variables, each with a default value:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个mixin接受四个变量，每个都有一个默认值：
- en: '`$ui-border-color`: `#2163A3`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ui-border-color`: `#2163A3`'
- en: '`$ui-background-color`: `#ffffff`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ui-background-color`: `#ffffff`'
- en: '`$ui-button-border-width`: `4px`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ui-button-border-width`: `4px`'
- en: '`$ui-button-border-radius`: `20px`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ui-button-border-radius`: `20px`'
- en: 'With this, not only can I style the component, but developers can also call
    this mixin from their own code and override colors and borders. As the mixin bases
    a lot of its other styles on values calculated from these variables, the various
    colors and sizes should always stay in keeping with these variables. For example,
    the following customization would result in a progress bar with thinner and less
    round borders with a pink coloring:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我不仅可以样式化组件，开发者也可以从自己的代码中调用此mixin并覆盖颜色和边框。由于mixin的许多其他样式都基于这些变量的计算值，因此各种颜色和大小应始终与这些变量保持一致。例如，以下自定义将导致具有更细、更不圆的边框和粉红色的进度条：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In previous chapters, we walked through the design and creation of a series
    of applications in a formal manner, using a series of diagrams to illustrate the
    process. This time, I tried to give a glimpse of some of the ways I would build
    the system architecture and some of the techniques I use day-to-day.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们以正式的方式逐步介绍了系列应用程序的设计和创建，使用一系列图表来展示这个过程。这次，我尝试展示一些我构建系统架构的方法和一些我日常使用的技巧。
- en: In addition, we saw how a view model can become the primary point from which
    data flows through an application, cascading through child view models and child
    components, and triggering multiple UI updates via binding.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们看到了视图模型如何成为数据在应用程序中流动的主要点，通过子视图模型和子组件级联，并通过绑定触发多个UI更新。
- en: We revisited styling and showed how the Ext JS theming system allows you to
    build reusable mixins that give us the same modularity in our SASS code as we
    have in our JavaScript classes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新审视了样式设计，展示了Ext JS主题系统如何允许你构建可重用的混合，这使我们SASS代码中的模块化与JavaScript类中的模块化相同。
- en: In the next chapter, we'll be writing a shopping application for tablet device
    that allows users to browse and buy items from an online store. It'll be our most
    complicated application yet, which marries all of the different ideas and techniques
    we've discussed so far.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写一个平板设备上的购物应用程序，允许用户浏览和购买在线商店的商品。这将是我们迄今为止最复杂的应用程序，它结合了我们迄今为止讨论的所有不同想法和技术。
