- en: Chapter 8. Practical – Questionnaire Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have three practical applications under our belt. The objective has been
    to show the process of designing an application and think it through in a series
    of careful steps to create a clear picture of the project that's we're going to
    build. This time around, there's going to be a change of pace and rather than
    looking at how "we" would design and build an application, I'll be guiding you
    through my own process of creating a multiple-step, dynamic questionnaire component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the features of the application that will be the subject of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A reusable package that can be included in any application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theme variables and mixins to allow visual integration in other apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting a questionnaire into multiple steps, each with multiple questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct the UI dynamically from incoming server data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JSON object produced by the questionnaire, representing the steps, questions,
    and the answers that the user has provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Ext JS Associations to help structure application data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why the step back from the all-inclusive "we" to a look at my own architecture
    process? I hope that it'll give you a more practical look at the thought processes
    that go into an application design. You can also see how there are always multiple
    correct paths that an architect can pursue. Sketching out these paths and investigating
    them before writing any code will avoid the "analysis paralysis" that hits many
    projects and causes them to grind to a halt when difficult questions need answers.
  prefs: []
  type: TYPE_NORMAL
- en: Application design – my way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My first port of call when thinking about an application doesn't involve fancy
    tools or an IDE. Once the customer requirements are established, I take myself
    as far away from a computer as possible, wash all thoughts of JavaScript and Ext
    JS from my head, and remove as many distractions as possible.
  prefs: []
  type: TYPE_NORMAL
- en: With that done, I grab a large notebook and a pencil and get scribbling. I've
    never found a better way to quickly draft ideas than a bit of manual labor, so
    while I'm designing in the same way as we've seen in the previous few chapters,
    I can avoid getting bogged down with drawing tools and UML diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of this needs to be formalized in documented design decisions later. The
    purpose is to quickly test out ideas and avoid dead ends.
  prefs: []
  type: TYPE_NORMAL
- en: How did I start?
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design – my way](img/5308OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, it''s not pretty, but you can see the relationship between this and the
    diagrams of UI views we saw in previous chapters. Note that the intention with
    these images is not to spell out the design in exacting detail, but simply to
    give an insight into the process I went through, warts and all! Eventually, I''ll
    use these sketches to build something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design – my way](img/5308OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What are the features I picked out from this original sketch?
  prefs: []
  type: TYPE_NORMAL
- en: Questionnaire header, changing per step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panes containing an introduction and a conclusion to the questionnaire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panes for each of the steps making up the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A step can have introduction text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A question needs explanation text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation buttons to move between steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A progress bar to show the number of steps completed and numbers until the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, this component needs to be able to validate the mandatory questions
    in a step that have been completed before the user can move to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than spending lots of time in front of a computer creating the perfect
    UI design, I was able to quickly flesh out an idea to see how it looked and this
    informed me about my design requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These initial sketches enabled me to quickly think about the underlying data
    powering the component. In previous chapters, we've stopped here to discuss whether
    the design requirements can be fulfilled by Ext JS. Instead, we're going to push
    ahead, put technology to one side, and just focus purely on architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In some ways—as we're going with MVVM—the architecture is technology agnostic.
    We can create the kind of application that we want to build without feeling constrained
    by the framework we're using. This can be dangerous; in that, we might lose sight
    of particular client requirements or start drafting something that might turn
    out to be impossible. To this end, we introduce new checks and balances that we'll
    discuss in a little while.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, I continued with my pencil and paper to work out a data structure.
    As in previous cases, the UI design informs the underlying data requirements.
    Here''s a quick insight into my design doodles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data structure](img/5308OT_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s the same as in previous chapters, just a bit messier! Again, don''t worry
    about the detail. Look at the rough notes and the scribbles and realize that the
    initial stages of an application design are an organic process and things can
    (and will) take a meandering path. Here''s what my doodles led to in terms of
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Questionnaire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps[]
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Questions[]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Required?
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Question text
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Field type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'm not yet worrying about what inherits from what at this stage. I just know
    that I'd like to have a single questionnaire that has many steps and these steps
    will each have many questions. From here, I just fleshed out the fields each class
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Consider carefully
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's at this point I have to tell you that I lied to you. In the purest sense,
    it would be fantastic to think that you can sketch out the full application architecture
    on paper, but in reality, you will always do so with an eye on the real world.
    Look back to my last page of pencil doodles and you'll see a few notes like "associations"
    with a giant underline. That's there because I knew that the data structure I've
    described previously will be implemented using Ext JS associations, a feature
    we haven't yet used in this book, but one that can be very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: As much as possible though, I've tried to push past any thoughts of detail,
    but trusted my knowledge of Ext JS to pop to the fore without any warning signs.
  prefs: []
  type: TYPE_NORMAL
- en: Data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the previous data structure in mind, I started to think more about how
    the information supplied from an API would flow through view models and allow
    me to build the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: I had a feeling that validation was going to complicate the application, so
    I started sketching out some ideas for the parts of the UI that would be affected.
    The user can't proceed to the next step until the current step is valid. In this,
    its mandatory questions have been answered so the "next" button needs to be disabled
    until this happens. I started drawing again, but quickly a degree of "analysis
    paralysis" kicked in. How should this work? There are several Ext JS features
    that could help; will model validation binding work here or will it have to be
    manual handling of validation events. Earlier, I mentioned "checks and balances"
    to avoid building something that Ext JS won't support; I decided to take some
    time out and investigate the best way to implement this in Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call this a "spike" as we did in [Chapter 5](ch05.html "Chapter 5. Practical
    – a CMS Application"), *Practical – a CMS Application*, or call it a prototype.
    It doesn''t really matter whether we write this code and then throw it away; if
    it helps the process, then it''s a valuable exercise. I built it standalone (outside
    of an MVC or MVVM structure) and it''s horrible. Look at this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I don''t wish this code to be my worst enemy. Shouldn''t every piece of code
    we write be pristine and well considered? In the real world, almost no one can
    see this code. It''s to test out my ideas and find out what feels right and it
    doesn''t have to be tidy or maintainable. It''s a one-off. Here''s what I wanted
    to test out:'
  prefs: []
  type: TYPE_NORMAL
- en: Will the `modelValidation` feature be useful with auto-generated form fields?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will I be able to bind to questions to get the validation state of the current
    step?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will it feel natural to use these features or is there an easier way?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've seen how view models can be used to create simple declarative applications
    and they can be extremely powerful when used correctly. In this application, fields
    are being generated from API data and each field had its own question model. Propagating
    the validity of this model up to the relevant parts of the user interface via
    view models seemed like it might be difficult. What did I discover?
  prefs: []
  type: TYPE_NORMAL
- en: A view model binding trick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slight difference of opinion with the team at Sencha regarding the way `modelValidation`
    behaves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of binding a button state to the state of an association
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This seems like a great result for this grubby code. Let's look at each point
    in turn.
  prefs: []
  type: TYPE_NORMAL
- en: A binding trick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This snippet of code is from the view model of a question''s form field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The view model has a question model and inherits the step model from its parent
    view model. We tell Ext JS that we''d like to bind to changes in the question
    model, deep changes, so any of its property changes and then trigger the `isValid`
    method on the parent step. This is great because the `isValid` method can in turn
    trigger changes on the parent step, propagating the state of the questions up
    to the step. Here''s the `isValid` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It checks the validity of all the child questions and sets the valid property
    of the step accordingly. We can then bind to this valid value and have it affect
    other things (such as the disabled state of the "next" button in the UI).
  prefs: []
  type: TYPE_NORMAL
- en: This is slightly counterintuitive because we're not binding directly to the
    `isValid` formula. Instead, we're using it to watch for changes on the question
    and then trigger changes on the step model.
  prefs: []
  type: TYPE_NORMAL
- en: A difference of opinion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There was a change in the behavior between Ext JS 5.0 and 5.0.1\. The `modelValidation`
    feature matches validation in the model with validation in the form, reducing
    duplication of code. In Ext JS 5, when the form values change, these changes will
    be synchronized to the model via binding. In Ext JS 5.0.1, this synchronization
    will only happen when the form field is valid. The idea is that the model should
    never be left in an invalid state based on form changes, but the problem occurs
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: User completes the form field and it becomes valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form value is passed to the model's field, which in turn becomes valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User changes the form field to make it invalid again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change is not passed to the model, which remains valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that when binding to model value, you''ll get something that doesn''t
    reflect the real state of the UI. The model will say everything is valid when
    in fact the UI says differently. In the case of this application, the plan is
    to bind the "next" button to the model state, which will enable the button incorrectly
    in the preceding situation. My solution was to override this and return to the
    Ext JS 5.0 behavior as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An alternative workaround would be to bind the "next" button to the value of
    the form field rather than the model value, but in our case, we need to do further
    work on the model value, so it's not a great solution.
  prefs: []
  type: TYPE_NORMAL
- en: A means to an end
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of this allows you to have a chain of configuration that goes all the way
    from each individual question field to the question model, then to the step model,
    and to higher-level places in the user interface that depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: When I was writing this chapter, there were other ideas kicking around in my
    head as to how to implement it. A solution that handles validation events and
    uses listeners to propagate state through the application was another approach,
    but it ended up being less elegant despite the final idea being a little more
    complicated than our previous binding code.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS allows you to watch for deep changes in associations en-masse that would
    help, but at the time of writing this book, this change is not documented. Hopefully,
    it's coming in a post-5.0.1 version!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see this change documented in the 5.0.1 release notes as EXTJS-13933
    at [http://dev.sencha.com/extjs/5.0.1/release-notes.html](http://dev.sencha.com/extjs/5.0.1/release-notes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Sketchy sketching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My biggest concern of the application has been solved to my satisfaction; I
    won't go into any more detail on my code spike because I'll reuse some of this
    code later once it's been tidied up.
  prefs: []
  type: TYPE_NORMAL
- en: I moved on to working out the role of controllers in this application. What
    user-initiated events will we need to handle?
  prefs: []
  type: TYPE_NORMAL
- en: '![Sketchy sketching](img/5308OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initial sketches for controllers; there are several things here that didn't
    make it into the final version
  prefs: []
  type: TYPE_NORMAL
- en: 'The user can perform two main actions: completing the questionnaire itself
    and navigating between pages. It''s the navigation that the controller will concern
    itself with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, I felt fairly confident that I''d fleshed out most of the tricky
    parts of the application. In the role of an architect, each of the diagrams and
    interactions that I sketched need to be turned into formal documentation in order
    to provide a point of reference for developers. Here''s what I came up with for
    the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sketchy sketching](img/5308OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's no point in duplicating the work I've already shown you, so I won't
    go through each of these formalized diagrams, but it should be stressed that this
    isn't a step that can be skipped. As a developer, it's essential that there's
    a solid design document to refer back to when writing code and also to keep the
    architect accountable. The next step in the process is to move from pencil and
    paper back to the computer and start to write the code for our questionnaire component.
  prefs: []
  type: TYPE_NORMAL
- en: Get set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The questionnaire component that we'll build in this chapter will be reusable
    in any application. To that end, we can use an Ext JS package to create a bundle
    of code that can be built in the same way as a normal Ext JS application, but
    it can be incorporated as a component in our future applications. We discussed
    packages in [Chapter 3](ch03.html "Chapter 3. Application Structure"), *Application
    Structure*, but now we'll see how they can be used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how I started up the project that I used as a basis for this component
    and its test application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Building a package requires us to first create a workspace, so after doing so
    using the latest version of the SDK that I downloaded, I moved on to the `workspace`
    directory and issued the command to create the package itself, which I called
    `wizard`. Then, I created a test application that would host the package during
    development; I called this `questions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I then get the test application up and running with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The web server is now up and running at `http://localhost:1841/`. The final
    step is telling the test application to include the new package. I edited `questions-package/questions/app.json`
    and amended the `requires` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we gave the package the name `wizard`, just add this in the array and we're
    good to go.
  prefs: []
  type: TYPE_NORMAL
- en: The package we're going to build is contained at `questions-space/packages/wizard`
    and will start off containing most of the same directories as an Ext JS application.
    We can now move to this directory and start building it in just the same way as
    we have in the past few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The data layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing the prototype, I did partially build the data classes that were
    required, so now let''s fully flesh them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Standard stuff here with one exception is that a `toJSON` method that consumes
    applications can override in order to obtain JSON in a format they can use for
    further processing. The default implementation returns the data of the questionnaire
    object along with its association data. Alternatively, they can override the proxy
    configuration to save the questionnaire data to their own server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the model I used to represent a step in the questionnaire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things to note on the `Step` model; firstly, the use of
    associations, which I realized would provide a really easy way to load the nested
    data for the whole questionnaire in a single action.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The association is created using the `reference` option on the field with the
    `type` option specifying the full class name of the parent model and the inverse
    is the name of the association store that will be created on this parent `Questionnaire`.
    Ext JS 5 associations are a little confusing at first as they're always defined
    on the child, not the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the `isValid` method enumerates the questions belonging to this step
    and sets the step's own valid field according to the validity of its questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here''s the `Question` model I built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, I have `child-side` of the `Step -> Questions` association defined in
    the same way as `Questionnaire -> Steps`. Using the `validators` config, I specify
    that answer should always be present, but I stumbled on a catch here that I could
    never have known about when just sitting down with a pencil and paper.
  prefs: []
  type: TYPE_NORMAL
- en: I really wanted to be able to add validators at runtime so that I could check
    the required field of the `Step` model and add the `presence` check to the answer.
    This enables the end user to toggle whether a particular question is required
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, after some intimate time with the Ext JS source code, it turns
    out that validators can only be defined on model class instances when they're
    defined and not on each instance of that class. Hopefully, this will be allowed
    in a later version—which at time of writing this book was 5.0.1—but I managed
    to come up with workarounds that enable this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We need to override the `Question` class's `getValidation` method. In the event
    that required is `true`, I call the `getValidation` on the superclass to proceed
    with validation normally. However, if it's `false`, I return a new `Ext.data.Validation`
    instance, but don't actually run its validation in effect, providing the same
    result as if the validation had passed.
  prefs: []
  type: TYPE_NORMAL
- en: While this works, and it's simple, it's one of these things that should be revisited
    with each new Ext JS version to see whether there's a more elegant way of solving
    the issue. I recommend code like this should be commented to let others know exactly
    why the workaround is needed and which version it applies to.
  prefs: []
  type: TYPE_NORMAL
- en: The payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting feature of associations is that it allows for the use of nested
    data. By loading data for the questionnaire and its steps and questions as a single
    JSON object, the child''s steps and questions association will be populated too.
    For example, take a look at this JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This object includes data for the questionnaire with an array of child steps.
    The steps have their own array of questions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we load this, we would see "round 1" logged to the console. Some might question
    why we bother using models at all; we could use `Ext.Ajax` to load the JSON object
    directly into a view model. Models allow us to use validation and let us augment
    each `Model` instance with utility methods. The stores that are auto created on
    parent models give us shortcut methods to enumerate the records within and find
    individual child records.
  prefs: []
  type: TYPE_NORMAL
- en: There's a little bit of overhead in setting up and working with models here,
    but it's worth it in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I felt pretty good about the data layer I''d built. It was frustrating to have
    spent time trying to work around this limitation to validators that I found, but
    the final result works well. It was time to move on to the user interface, starting
    with the main container for the questionnaire wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I'll break down each of the important parts of this code and try and explain
    the design decisions behind them.
  prefs: []
  type: TYPE_NORMAL
- en: The `ui` and `bodyCls` options are set as a way of hooking into this component
    via theming and CSS later. In particular, the `ui` option is a great way of reusing
    parts of the Ext JS theming system with your own components. We'll revisit this
    towards the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the `viewModel`, `controller`, and `layout` options, I use
    a tactic that we've seen before, which is to create a new custom configuration
    option that will be used to bind to. I created a `questionnaire` config for me
    to bind a view model value to and you can see that bound value is also called
    `questionnaire`.
  prefs: []
  type: TYPE_NORMAL
- en: The final piece of the configuration puzzle is to bind the title of the questionnaire
    to the title of the wizard panel itself.
  prefs: []
  type: TYPE_NORMAL
- en: Do it yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of my favorite things about creating custom configuration options is that
    you get an extra hook in the form of an `applyOptionName` method. It's created
    automatically for each config option and is called by Ext JS before setting the
    value. It lets us customize or validate the configuration option and if we've
    bound a view model value to it, it lets us perform actions when the bound value
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used this with `applyQuestionnaire`, which is used to build the items for
    the wizard panel when the questionnaire is bound. It performs the following three
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a container for the questionnaire introduction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adds a container for the questionnaire conclusion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adds a `wizard-step` component for each step in the questionnaire using the
    `addStepPane` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `addStepPane`, the new `wizard-step` component is supplied with a view
    model that contains the `Step` model itself and immediately binds this to a step
    config option. It will be simpler to just pass in the `Step` model as a configuration
    option rather than using view models, but this would mean that we can't use this
    step in further binding formulas and it will be more awkward to react to changes
    in `Step`, such as validation.
  prefs: []
  type: TYPE_NORMAL
- en: The second use of apply is via `applyActiveItem`, which will be triggered every
    time the `currentPosition` value on the view model changes. It's used to update
    the panel's `currentPosition` to switch from card to card as the user progresses
    through questionnaire, but I added in a check to ensure the wizard's items have
    been initialized before doing this. Without this check, setting `currentPosition`
    can raise an error if `currentPosition` is changed before the items have been
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: Wizardly tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last piece of configuration for the main wizard panel is to create the navigation
    buttons and the progress indicator. I added these as `dockedItems` with the dock
    set at the "bottom" in order to have them in the footer of the panel. The progress
    bar is bound to the questionnaire's steps from the view model in order to build
    its step icons.
  prefs: []
  type: TYPE_NORMAL
- en: One step forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The navigation bar allows the user not only to proceed through the questionnaire,
    but also return to previous steps to review them. There's a "restart" button that
    takes the user back to the introduction. The "finish" button will be the one we'll
    use to communicate back to the host application when all questions are complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these buttons is enabled or disabled depending on the validation state
    of each step (and therefore each question) and the user''s position in the questionnaire.
    Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I've delegated the responsibility for enabling and disabling these buttons to
    a view model. As there are other components that will be interested in these values,
    they're going to rest at the top-level view model of the wizard. We'll take a
    look at this code later.
  prefs: []
  type: TYPE_NORMAL
- en: Making progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The progress bar is a series of buttons that allows the user to determine how
    far they are along the questionnaire process and skip back to an earlier step.
    Each button needs to be aware of the user''s position in the questionnaire in
    order to determine whether it should be enabled or disabled. The "start" and "end"
    buttons are fixed, wherein they are available on every questionnaire, but the
    numbered step buttons need to be automatically generated and bound to the steps
    for currently loaded questionnaire. Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's a surprising amount going on in this component. Remember that in the
    wizard panel, I set the `bind` config on this progress component to the questionnaire
    steps, and in the preceding code, you can see the custom steps configuration option—as
    long with the `defaultBindProperty`—that enables this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that `defaultBindProperty` allows you to avoid explicitly setting the
    property to bind to, and Ext JS will automatically use the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll skip over the `layout`, `cls`, and `defaultType` options and move on
    to the way I implemented `applySteps`. It builds an array of the following buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: The start button, which is always enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number buttons for each step, which are only enabled if the user has advanced
    to that step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end button, which is only enabled when the user is on the questionnaire
    conclusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end button's disabled state is deferred to a binding on the parent view
    model. For the individual step icons, a simple view model with the `isEnabled`
    formula is used to toggle the disabled state based on the current active step
    pane.
  prefs: []
  type: TYPE_NORMAL
- en: When I was researching [Chapter 2](ch02.html "Chapter 2. MVC and MVVM"), *MVC
    and MVVM*, I found a little snippet describing MVC in Smalltalk and the way that
    individual UI components would have their own controller right down to text fields
    and the like. While it's rare that we'd go that far in our Ext JS applications,
    the use of a small, one formula view model for the step icons reminded me of this
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: My only gripe as I was writing it was that while the functionality was great,
    the syntax to just bind one property like this felt a little verbose. On the other
    hand, introducing another shorthand syntax would mean a new feature for Ext JS
    developers to learn; I think we have enough already!
  prefs: []
  type: TYPE_NORMAL
- en: A final point regarding this component is that I append `lineHtml` to the container
    and configure a couple of styling hooks. This allows for a thin line connecting
    the progress buttons; it's a minor visual element, but has a nice effect.
  prefs: []
  type: TYPE_NORMAL
- en: Step by step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next component to examine is the one that represents a step in the questionnaire
    and shows the associated questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's the standard setup for `Ext.form.Panel` here, configuring labels, and
    so on. Once again, I created a custom step config that we bound to in the parent
    `Wizard` panel's `addStepPane` method and use the matching apply method to build
    out the contents of the form.
  prefs: []
  type: TYPE_NORMAL
- en: Note how I have set the `modelValidation` config to `true`. As a result of my
    prototype earlier in the chapter, I know that this is great way to avoid code
    duplication by creating validation on a model and have it take effect in the form
    UI. When building the questions for the step in `applyStep`, I make sure and bind
    `question.answer` to the form field value. This means that any validation on the
    question model's answer field will be applied to the form field UI automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the other attributes of the form field are built dynamically from the
    question data, such as the label and the field type. The final thing to note here
    is that I use a separate view model and immediately populate it with the question.
    Look at the code for this view model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's nothing complicated; it's just a little bit long to define inline and so
    I moved it to a separate file. The code here should also look very familiar because
    it's the same as the code from my prototype that I showed earlier in the chapter
    under the heading "A Binding Trick". I knew this would come in useful!
  prefs: []
  type: TYPE_NORMAL
- en: Questionnaire command and control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nearly all of the pieces are in place. Note that I used a lot of binding expressions
    in the `Wizard` component so far, but I haven''t shown either the top-level view
    model or how the wizard deals with user interactions. I always like to keep controllers
    slim and the view controller here is no exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The view controller listens for clicks on the navigation buttons and any enabled
    buttons on the progress bar, and in every case apart from `onFinishClick`, it
    manipulates the value of `currentStepIndex` on the view model. It doesn't have
    to speak to any other components, just this one value. I really like the elegance
    of this solution. We'll see how `currentStepIndex` influences the application
    when we review the wizard's view model.
  prefs: []
  type: TYPE_NORMAL
- en: The `onFinishClick` method is called when the user clicks on the finish button
    and raises a `controller-level` event called `wizardcomplete` with the completed
    questionnaire as its only argument. The host application can handle this event
    and retrieve the completed question data and dispose of the wizard component as
    it sees fit.
  prefs: []
  type: TYPE_NORMAL
- en: This is another good example of decoupling this component from its host; the
    wizard needs to know nothing about the application it's embedded inside. It just
    fires the event and forgets about it.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final, and in my opinion most important, part of the puzzle is the top-level
    view model. This is the one that the wizard panel uses directly and is available
    to all child components of the panel thanks to the view model inheritance. Here''s
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that `currentPosition` is initialized at `0`, which represents the questionnaire
    introduction page in the UI and the first card in the wizard panel.
  prefs: []
  type: TYPE_NORMAL
- en: This one value is probably the most important in the whole application because
    it not only drives what is displayed on the UI through its binding to `activeItem`
    on the wizard panel, but also the state of the navigation and progress buttons.
    This is both direct—the progress component inherits and consumes `currentPosition`
    to set the disabled state of its buttons—and indirect, as in the way `isNextEnabled`
    uses it to get the `currentStep` model's validity and in turn is bound to the
    "next" navigation button.
  prefs: []
  type: TYPE_NORMAL
- en: Building up a couple of dependent formulae and allowing them to cascade down
    to child components gives a clear picture of how data flows from a single source
    (`questionnaire` and `currentPosition` on the wizard view model).
  prefs: []
  type: TYPE_NORMAL
- en: A delightful host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The wizard is functionally complete and it''s time to show how we can embed
    it in an application. Look back and you''ll see that the main wizard component
    had the following `load` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `links` feature of the view model to trigger the loading of a
    questionnaire using its preconfigured proxy. With this in mind, the calling code
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When `onClickButton` handler fires, `Ext.Window` is created containing our wizard
    component, and we then call the `load` method on the wizard itself, passing the
    ID of the questionnaire to load.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to include the wizard package in your application's `app.json`, as
    discussed earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view controller also listens for the `wizardcomplete` event and can use
    this to get the completed questionnaire instance for further processing and could
    also close the wizard window. These two integration points are all that a developer
    needs to use the wizard in their own application, but there''s one last thing
    that I wanted to explore when building this component: `theming`.'
  prefs: []
  type: TYPE_NORMAL
- en: Mixin the night away
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I wanted consumers of the wizard component to be able to customize it, but this
    turned out to be very simple in most cases. As the main container for the wizard
    is a subclass of `Ext.Panel`, all of the relevant SCSS variables for this class
    can be overridden and it'll take effect for the wizard's container too.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I wanted to create a custom look for the progress bar and in turn
    allow end users to customize it. To this end, I wrote a custom mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The mixin accepts four variables, each with a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ui-border-color`: `#2163A3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ui-background-color`: `#ffffff`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ui-button-border-width`: `4px`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ui-button-border-radius`: `20px`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this, not only can I style the component, but developers can also call
    this mixin from their own code and override colors and borders. As the mixin bases
    a lot of its other styles on values calculated from these variables, the various
    colors and sizes should always stay in keeping with these variables. For example,
    the following customization would result in a progress bar with thinner and less
    round borders with a pink coloring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we walked through the design and creation of a series
    of applications in a formal manner, using a series of diagrams to illustrate the
    process. This time, I tried to give a glimpse of some of the ways I would build
    the system architecture and some of the techniques I use day-to-day.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we saw how a view model can become the primary point from which
    data flows through an application, cascading through child view models and child
    components, and triggering multiple UI updates via binding.
  prefs: []
  type: TYPE_NORMAL
- en: We revisited styling and showed how the Ext JS theming system allows you to
    build reusable mixins that give us the same modularity in our SASS code as we
    have in our JavaScript classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be writing a shopping application for tablet device
    that allows users to browse and buy items from an online store. It'll be our most
    complicated application yet, which marries all of the different ideas and techniques
    we've discussed so far.
  prefs: []
  type: TYPE_NORMAL
