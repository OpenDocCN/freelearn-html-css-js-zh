<html><head></head><body>
		<div><h1 id="_idParaDest-150" class="chapter-number"><a id="_idTextAnchor156"/>5</h1>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor157"/> Node.js Core Libraries</h1>
			<p>In this chapter, we delve into the core libraries of Node.js and explore the techniques for modularizing your code. JavaScript has come a long way from being limited to browsers, and Node.js has offered us new ways to structure our code. We’ll begin by understanding the historical limitations of organizing code in the browser and how they led to the development of various module systems. We’ll primarily focus on two module systems, <strong class="bold">CommonJS </strong>(<strong class="bold">CJS</strong>) and <strong class="bold">ECMAScript Modules</strong> (<strong class="bold">ESM</strong>), and discuss their usage, importation, and exportation. Achieving interoperability between these two systems is crucial, and we’ll explore strategies to make it work seamlessly.</p>
			<p>Understanding how core libraries in Node.js are structured is key. We’ll take a closer look at core libraries including <code>fs</code> and <code>http</code>, which deal with file operations, and explore the use of callbacks, synchronous functions, and promises for asynchronous I/O operations.</p>
			<p>Also, more advanced topics related to extending Node.js functionality with C++ addons and executing external commands using the <code>child_process</code> library will be discussed. We’ll also review various command-line options (including to enable experimental features and control memory allocation) and environmental variables that allow you to customize the Node.js behavior. We’ll provide examples of how to use these options to enable experimental features, control memory allocation, and fine-tune your Node.js applications.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>How to create and consume modules using the ESM and CJS approaches</li>
				<li>How to interoperate between ESM and CJS modules</li>
				<li>How the Node.js core libraries interfaces are structured</li>
				<li>What the most relevant Node.js core libraries are when starting with Node.js</li>
			</ul>
			<p>How to extend the Node.js functionality by using command-line options and the <code>NODE_OPTIONS</code> environment variable</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor158"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a>.</p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/WQzdXAFxdsc">https://youtu.be/WQzdXAFxdsc</a></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor159"/>Modularizing your code (ESM versus CJS)</h1>
			<p>For many years JavaScript was <a id="_idIndexMarker281"/>limited to the browser, and the only way to organize our code was using script files that were loaded in the correct order in a HTML page. This was done by including specific references in the HTML files, such as the following:</p>
			<pre class="source-code">
&lt;!-- External Sources --&gt;
&lt;script src="img/jquery-3.7.0.min.js"&gt;&lt;/script&gt;
&lt;!-- Other files --&gt;
&lt;script src="img/script1.js"&gt;&lt;/script&gt;
&lt;!-- Direct Scripts --&gt;
&lt;script&gt;
console.log("Hello world");
&lt;/script&gt;</pre>			<p>This approach was not scalable, and it was very easy to pollute the global scope. To solve this problem, historically we used the IIFE pattern and the module pattern. As the adoption of JavaScript started to grow and the amount of JavaScript required for a modern website was dramatically rising, the community began to create libraries and frameworks to solve these aforementioned problems. The<a id="_idIndexMarker282"/> outcome included results such as RequireJS (<a href="https://requirejs.org/">https://requirejs.org/</a>).</p>
			<p>For many years, we had four <a id="_idIndexMarker283"/>different ways to organize our code:</p>
			<ul>
				<li><strong class="bold">CommonJS (CJS)</strong></li>
				<li><strong class="bold">ECMAScript </strong><strong class="bold">Modules (ESM)</strong></li>
				<li><strong class="bold">Asynchronous Module </strong><strong class="bold">Definition (AMD)</strong></li>
				<li><strong class="bold">Universal Module </strong><strong class="bold">Definition (UMD)</strong></li>
			</ul>
			<p>In this book, we will focus on the first two<a id="_idIndexMarker284"/> approaches, CJS and ESM. Currently CJS is the default module system in Node.js, but since the release of Node.js 12, ESM is now available. In this<a id="_idIndexMarker285"/> section, we will explore how to create and consume modules using both approaches.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Today, in the browser environment is very common to consolidate our code using a module bundler such as webpack or Rollup. However, in Node.js we keep using CJS or ESM directly. In this section, we will explore how to create and consume modules using both approaches.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor160"/>CommonJS (CJS)</h2>
			<p>CommonJS is the module system that Node.js uses by default. This module system is synchronous, and is based on the <code>require</code> and <code>module.exports</code> functions. It is important to note that this<a id="_idIndexMarker286"/> module system is not part of the ECMAScript specification, but it is the most used module system in the Node.js ecosystem, especially if you are looking for documentation or tutorials.</p>
			<p>There are two aspects here of CJS use that we need to understand: the importation and the exportation. Let’s start with the importation.</p>
			<h3>Importation</h3>
			<p>So, we have two <a id="_idIndexMarker287"/>files in our project, <code>utils.js</code> and <code>index.js</code>. In this example, we are importing the <code>sayHello</code> function from the <code>utils.js</code> file in the <code> index.js</code> file, as follows:</p>
			<pre class="source-code">
const sayHello = require('./utils.js');
sayHello();</pre>			<p>The <code>require</code> function is a global function that is available in Node.js and is used to import modules. The <code>require</code> function receives a string as a parameter, and this string is the path to the module that we want to import. In this case, we are using a relative path, but we can also use absolute paths or even the name of a module that is installed in the <code>node_modules</code> folder.</p>
			<h3>Exportation</h3>
			<p>In this example, we are <a id="_idIndexMarker288"/>exporting the <code>sayHello</code> function in the <code>utils.js</code> file:</p>
			<pre class="source-code">
function sayHello() {
  console.log('Hello world');
}
module.exports = sayHello;</pre>			<p><code>module.exports</code> is a global object that is available in Node.js, and it is used to export modules. In this case, we are exporting the <code>sayHello</code> function, but we can export any type of value.</p>
			<p>If you execute the <code>index.js</code> file, you will see the following output:</p>
			<pre class="console">
$ node index.js
Hello world</pre>			<p>But if we execute the <code>utils.js</code> file, we will see nothing. Even if the file is executed, the <code>sayHello</code> function itself is not executed, just defined:</p>
			<pre class="console">
$ node utils.js</pre>			<h3>Export object structures</h3>
			<p>The most popular <a id="_idIndexMarker289"/>structure to use while exporting modules is the object structure, as it is very flexible and allows us to export multiple values. If we want to export multiple values, we can use the <code>exports</code> object:</p>
			<pre class="source-code">
// You can export directly
exports.sayHello = () =&gt; {
  console.log('Hello world');
}
function sayGoodbye() {
  console.log('Goodbye world');
}
// You can also export using references
exports.sayGoodbye = sayGoodbye;</pre>			<p>But we can also export <a id="_idIndexMarker290"/>an object directly using <code>module.exports = {}</code>:</p>
			<pre class="source-code">
const sayHello = () =&gt; {
  console.log('Hello world');
}
function sayGoodbye() {
  console.log('Goodbye world');
}
module.exports = {
  sayHello,
  sayGoodbye
}</pre>			<p>I recommend the preceding option as it is more readable when working with larger files. In order to import the exported values, we can use the destructuring syntax:</p>
			<pre class="source-code">
const { sayHello, sayGoodbye } = require('./utils.js');
sayHello();
sayGoodbye();</pre>			<h3>JSON support</h3>
			<p>Yep, you can add JSON files <a id="_idIndexMarker291"/>directly to your project in Node.js and you don’t need to use any external library or parse the content:</p>
			<pre class="source-code">
{
  "name": "John",
  "lastName": "Doe"
}</pre>			<p>Now we can require the file directly:</p>
			<pre class="source-code">
const user = require('./user.json');
console.log(user);
// { name: 'John', lastName: 'Doe' }</pre>			<p>The way that modules work in Node.js is very similar to the IIFE pattern. When we import a module, the code is executed and the module is cached. If we import the same module again, the code is not executed again, and the module is retrieved from the cache. Basically, the module is executed only once (singleton pattern).</p>
			<p>So, for example, if we make changes to the imported JSON file, the changes will not be reflected in the imported module once it has already been imported, because it is read once and the content is cached in the program memory.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor161"/>ECMAScript Modules (ESM)</h2>
			<p>Node.js 12 introduced the support for <code>import</code> and <code>export</code> keywords.</p>
			<p>In order to use modules with Node.js 20.11.0 you will need to create a <code>package.json</code> file and add the following configuration:</p>
			<pre class="source-code">
{
  "type": "module"
}</pre>			<p class="callout-heading">Important note</p>
			<p class="callout">In <a href="B21678_06.xhtml#_idTextAnchor171"><em class="italic">Chapter 6</em></a>, we will explore how to create a <code>package.json</code> file and how to configure it in depth.</p>
			<h3>Basic usage</h3>
			<p>In this example, we are <a id="_idIndexMarker293"/>exporting the <code>sayHello</code> function in the <code>utils.js</code> file:</p>
			<pre class="source-code">
export default function sayHello() {
  console.log('Hello world');
}</pre>			<p>The <code>export</code> keyword is used to export modules. In this case, we are exporting the <code>sayHello</code> function, but we can export any type of value. Note that we are using the <code>default</code> keyword, this is because we are exporting a single value. If we want to export multiple values, we can use the <code>export</code> keyword without the <code>default</code> keyword.</p>
			<p>In this example, we are importing the <code>sayHello</code> function from the <code>utils.js</code> file:</p>
			<pre class="source-code">
import sayHello from './utils.js';
sayHello();</pre>			<h3>Export object structures</h3>
			<p>The most popular structure to use <a id="_idIndexMarker294"/>while exporting modules is the object structure, as it is very flexible and allows us to export multiple values. If we want to export multiple values, we can use the <code>export</code> keyword:</p>
			<pre class="source-code">
const sayHello = () =&gt; {
  console.log('Hello world');
}
function sayGoodbye() {
  console.log('Goodbye world');
}
export { sayGoodbye, sayHello };</pre>			<p>In this example, we are<a id="_idIndexMarker295"/> importing the <code>sayHello</code> and <code>sayGoodbye</code> functions from the <code>utils.js</code> file in several ways:</p>
			<pre class="source-code">
// Import values directly
import { sayHello, sayGoodbye } from './utils.js';
// Use wildcards to import all the exported values
import * as utils from './utils.js';
sayHello();
utils.sayHello();</pre>			<h3>Support for JSON files</h3>
			<p>While using ESM, it is not possible to<a id="_idIndexMarker296"/> import JSON files directly as we did for CJS. If we try to import a JSON file, we will get the following error:</p>
			<pre class="source-code">
TypeError [ERR_IMPORT_ASSERTION_TYPE_MISSING]: Module "file:///{REDACTED}/user.json" needs an import assertion of type "json"</pre>			<p>In the future, it will be possible to import JSON files directly, there is a proposal (<a href="https://github.com/tc39/proposal-import-attributes">https://github.com/tc39/proposal-import-attributes</a>) that will allow us to use import attributes, such as <code>import json from "./foo.json" with { type: "json" };</code>. But for now, we need to use a workaround to import JSON files. We can fix this error by understanding <a id="_idIndexMarker297"/>how interoperability works between ESM and CJS.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor162"/>Understanding how interoperability works</h2>
			<p>While ESM is the future, there are<a id="_idIndexMarker298"/> many libraries and frameworks that still use CJS. The good news is that Node.js supports both module systems, and it is possible to use both in the same project without any problem, but there are some considerations that we need to take into account in order to make it work.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Interoperability has been a very controversial topic in the Node.js community, and there are many discussions about it. If you want to know more about it, I recommend you to read this article by Gil Tayar: <a href="https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71">https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71</a>.</p>
			<h3>JSON files in ESM</h3>
			<p>In the previous section, we saw that it is not<a id="_idIndexMarker299"/> possible to import JSON files directly in ESM today. But we can use the <code>module</code> library built into Node.js to import JSON files. The <code>module</code> library is a global object that is available in all the modules and contains the <code>createRequire</code> method that allows us to create a <code>require</code> function that can be used to import CJS modules:</p>
			<pre class="source-code">
import { createRequire } from "module";
const require = createRequire(import.meta.url);
const user = require("./user.json");
console.log(user);
// { name: 'John', lastName: 'Doe' }</pre>			<h3>File extensions (.cjs and .mjs)</h3>
			<p>In order to use both module systems in the same project, we need to use different file extensions in our files. The <code>.mjs</code> extension is <a id="_idIndexMarker300"/>used for ESM modules, and the <code>.cjs</code> extension is used for CJS modules.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you are using <code>.js</code> extension for your files, Node.js will try to use the CJS module system by default, like if you were using <code>.</code><code>cjs</code> extension.</p>
			<p>Here is the file structure of a project that uses both module systems:</p>
			<pre class="source-code">
├── index.cjs
├── index.mjs
├── utils.cjs
└── utils.mjs</pre>			<p>The <code>utils.cjs</code> file is a CJS module:</p>
			<pre class="source-code">
const sayGoodbye = () =&gt; {
  console.log('Goodbye world');
}
module.exports = { sayGoodbye }</pre>			<p>The <code>utils.mjs</code> file is an ESM module:</p>
			<pre class="source-code">
const sayHello = () =&gt; {
  console.log('Hello world');
}
export { sayHello }</pre>			<p>The <code>index.mjs</code> file is an ESM module. We can combine both module systems in the same file as long as we use different file extensions:</p>
			<pre class="source-code">
import { sayHello } from './utils.mjs';
import { sayGoodbye } from './utils.cjs';
sayHello();
sayGoodbye();</pre>			<p>The <code>index.cjs</code> file is a CJS module. In this case, ESM modules can not be imported directly because <code>require</code> was <a id="_idIndexMarker301"/>designed as a synchronous function, and ESM modules are asynchronous. But we can use the <code>import</code> function to import ESM modules asynchronously:</p>
			<pre class="source-code">
const { sayGoodbye } = require('./utils.cjs');
import("./utils.mjs").then(({ sayHello }) =&gt; {
    sayHello();
    sayGoodbye();
});</pre>			<p class="callout-heading">Important info</p>
			<p class="callout">This way of importing modules is part of the standard, and it is<a id="_idIndexMarker302"/> called dynamic import (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports</a>).</p>
			<p>In this book, we use ESM modules by default, but we will use CJS modules when we need to use interoperability with other libraries and frameworks.</p>
			<p>Now that we have a clearer idea of how to create modules in the different formats, let’s explore in the next section how the Node.js core APIs use a similar approach to expose tons of functionalities that we will use very often in our projects.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor163"/>Structuring core libraries</h1>
			<p>Over the years, Node.js has grown a lot, and the core libraries too. There are many libraries available for us to use, and it is important to know how they are structured to be able to use them properly.</p>
			<p>Most of the core libraries are quite simple and are structured in a similar way so you know what to expect in practical terms. Once you know how to use one of them, you will be able to use the rest of them without any problem.</p>
			<p>Furthermore, you will be <a id="_idIndexMarker303"/>able to create your own libraries and publish them in npm, and other developers will be able to use them easily, but we will talk about this in the nex<a id="_idTextAnchor164"/>t chapter.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor165"/>The library structure</h2>
			<p>Let’s look at the <code>fs</code> library as an example. The <code>fs</code> library is used to work with the file system, and it is one of the most used libraries in Node.js.</p>
			<p>Any library that performs I/O operations is asynchronous. Historically, Node.js has offered two ways to handle I/O operations: callbacks or synchronous functions. While callbacks are still supported, Node.js currently offers the same functionality providing a promise interface.</p>
			<p>In this example, we will use the <code>readFile</code> function to read a file asynchronously. This function receives the path of the file to read, and a callback function that will be called when the file is read. The callback function receives two arguments: an error object and the content of the file:</p>
			<pre class="source-code">
import { readFile } from 'node:fs';
readFile('hello.txt', (err, content) =&gt; {
  if (err)  {
    console.error("OMG, there is an error:", err);
    return;
  }
  console.log(`File content: ${content}`);
  // File content: Hello world
});</pre>			<p>When you run the previous <a id="_idIndexMarker304"/>example, it will throw an error, as the file does not exist. However, we manage the error using the error first pattern in the callback. You can see the <code>OMG, there... error message</code>. Now, if you create the <code>hello.txt</code> file with the content <code>Hello world</code> and you run again the script, you will see the content printed as expected.</p>
			<p>In the next example, we will use the<code> readFileSync</code> function to read a file synchronously. This function receives the path of the file to read, and it returns the content of the file:</p>
			<pre class="source-code">
import { readFileSync } from 'node:fs';
try {
  const content = readFileSync('hello.txt');
  console.log(`File content: ${content}`);
  // File content: Hello world
} catch (err) {
  console.error("OMG, there is an error:", err);
};</pre>			<p>And finally, in this example, we will use the <code>readFile</code> function to read a file asynchronously. This function receives the path of the file to read and returns a promise that will be resolved when the file is read. The promise will be resolved with the content of the file:</p>
			<pre class="source-code">
import { readFile } from 'node:fs/promises';
readFile('hello.txt')
  .then(content =&gt; console.log(`File content: ${content}`))
  .catch(err =&gt; console.error("OMG, there is an error:", err))</pre>			<h3>Core libraries without prefix</h3>
			<p>Historically, Node.js has provided the core libraries<a id="_idIndexMarker305"/> without the <code>node:*</code> prefix, such as <code>const { readFile } from 'fs'</code>. This is mainly for backward compatibility. But it is recommended to use the new syntax with the prefix <code>node:*</code>. You will find many examples on the internet that use the old syntax. More information can be found at <a href="https://nodejs.org/api/modules.html">https://nodejs.org/api/modules.html</a>.</p>
			<h3>CJS support</h3>
			<p>All the core libraries are available <a id="_idIndexMarker306"/>as CJS modules, so you can use them in your projects without any problem. You can use the <code>require</code> function to import them:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>CJS</p>
						</td>
						<td class="No-Table-Style">
							<p>ESM</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>const { readFile } = </code><code>require('node:fs')</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>import { readFile } </code><code>from 'node:fs'</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>const { readFileSync } = </code><code>require('node:fs')</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>import { readFileSync } </code><code>from 'node:fs'</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>const { readFile } = </code><code>require('node:fs/promises')</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>import { readFile } </code><code>from 'node:fs/promises'</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>const { readFile } = </code><code>require('node:fs')</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>import { readFile } </code><code>from 'node:fs'</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>const { readFileSync } = </code><code>require('node:fs')</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>import { readFileSync } </code><code>from 'node:fs'</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<h3>Additional interfaces</h3>
			<p>Other core libraries that you will use frequently, such as <code>http</code> or <code>https</code>, are structured similarly and provide an <a id="_idIndexMarker307"/>interface to work with events. We will cover this topic in depth in <a href="B21678_07.xhtml#_idTextAnchor206"><em class="italic">Chapter 7</em></a>.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor166"/>Stability index</h2>
			<p>The stability index is a number that indicates the stability of the core libraries. The stability index is a number <a id="_idIndexMarker308"/>between 0 and 3, where 0 means deprecated, 1 means experimental, 2 means stable, and 3 means legacy.</p>
			<p>You can find the stability index of each core library in the official documentation, along with more details about the stability index at <a href="https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#stability-index">https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#stability-index</a>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you are just starting with Node.js, you should use the core libraries with stability index 2 or 3. The core libraries with a stability index of 0 or 1 are not recommended for production environments.</p>
			<p>Let’s see some examples from Node.js 20:</p>
			<ul>
				<li>Permission Model (<a href="https://nodejs.org/docs/latest-v20.x/api/permissions.html#permission-model">https://nodejs.org/docs/latest-v20.x/api/permissions.html#permission-model</a>): This is an API that allows us to restrict access to system resources such as network or files. Currently, it is in active development (stability=1), so you can experiment with it, but it is not yet mature enough to use for building production systems as the API might change or have unexpected behavior.</li>
				<li>http (<a href="https://nodejs.org/docs/latest-v20.x/api/http.html#http">https://nodejs.org/docs/latest-v20.x/api/http.html#http</a>): This is the API used since the beginning of Node.js to build web server applications and make HTTP requests to external resources. Currently, it is stable (stability=2), but some methods are<a id="_idIndexMarker309"/> legacy (stability=3). This library is perfect for use in production systems.</li>
			</ul>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor167"/>Other core libraries</h2>
			<p>The <code>fs</code> library is just an example; in this book, we will cover the most important core libraries, but you can find the documentation of all the <a id="_idIndexMarker310"/>core libraries in the Node.js documentation at <a href="https://nodejs.org/docs/latest-v20.x/api/index.html">https://nodejs.org/docs/latest-v20.x/api/index.html</a>.</p>
			<p>In my humble opinion, the most important core libraries when you are starting with Node.js are the following, in alphabetical order:</p>
			<ul>
				<li><code>Buffer</code> handles binary <a id="_idIndexMarker311"/>data efficiently in memory, commonly used for tasks such as file operations and network communication.</li>
				<li><code>Crypto</code> provides cryptographic <a id="_idIndexMarker312"/>functionality, such as encryption, decryption, hashing, and digital signatures.</li>
				<li><code>Events</code> allows us to create, emit, and listen for events inside our applications.</li>
				<li><code>File System</code> provides a <a id="_idIndexMarker313"/>solid interface to deal with the file system (files, folders, creation, deletions, etc.).</li>
				<li><code>HTTP</code> allows us to <a id="_idIndexMarker314"/>create HTTP servers and perform HTTP requests.</li>
				<li><code>OS</code> offers various utilities to retrieve<a id="_idIndexMarker315"/> information about the system’s architecture, platform, CPU, memory, network interfaces, and much more.</li>
				<li><code>Path</code> provides utilities for <a id="_idIndexMarker316"/>working with file paths and directory paths.</li>
				<li><code>Process</code> provides information and control over aspects of the current Node.js process, including <a id="_idIndexMarker317"/>environmental variables, lifecycle events, and more.</li>
				<li><code>Stream</code> provides readable and <a id="_idIndexMarker318"/>writable streams, as well as transform streams for modifying data as it passes through. This module is essential for building scalable and memory-efficient applications that work with large volumes of data in Node.js.</li>
				<li><code>Timers</code> includes functions <a id="_idIndexMarker319"/>such as <code>setTimeout()</code>, <code>setInterval()</code>, and <code>setImmediate()</code>.</li>
			</ul>
			<p>There are other core libraries that are very important to extend the functionality of Node.js, but they are not so important when you are just starting out with Node.js.</p>
			<p>For example, the <code>child_process</code> library is essential to execute external commands such as <code>ls</code> and <code>cat</code> from Node.js, complex applications such as <code>ffmpeg</code> and <code>imagemagick</code>, and even directly execute Python scripts.</p>
			<p>The <code>C++ Addons</code> (<a href="https://nodejs.org/dist/latest-v20.x/docs/api/addons.html">https://nodejs.org/dist/latest-v20.x/docs/api/addons.html</a>) are very important to extend the functionality of Node.js with C++ code. This is very useful when you need to use a C++ library in your Node.js application.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor168"/>Command-line options</h2>
			<p>Node.js provides a lot of command-line options and environmental variables that you can use to customize the behavior of Node.js. You can find the complete list of command-line options in the Node.js <a id="_idIndexMarker320"/>documentation at <a href="https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options">https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options</a>.</p>
			<p>For example, you can use the <code>--experimental-json-modules</code> command-line option to enable the JSON modules in ESM, such as <code>node --</code><code>experimental-json-modules index.js</code>.</p>
			<p>The code of the <code>index.js</code> file is as follows:</p>
			<pre class="source-code">
import data from './data.json' assert { type: 'json' };
console.log(data);</pre>			<p>This does work, and the terminal output will remark that the JSON modules are experimental:</p>
			<pre class="console">
(node:21490) ExperimentalWarning: Import assertions are not a stable feature of the JavaScript language. Avoid relying on their current behavior and syntax as those might change in a future version of Node.js.
(Use `node --trace-warnings ...` to show where the warning was created)
(node:21490) ExperimentalWarning: Importing JSON modules is an experimental feature and might change at any time</pre>			<p>Aside from enabling experimental features, you can use the <code>--max-old-space-size</code> command-line option<a id="_idIndexMarker321"/> to increase the RAM usage limit of Node.js. This is very useful when you are working with large files, have a lot of data in memory, or are debugging a complicated memory leak.</p>
			<p>For example, you can use the <code>--max-old-space-size=4096</code> command-line option to increase the RAM limit to 4GB: <code>node --</code><code>max-old-space-size=4096 index.js</code>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can’t use all the RAM in your computer, because the operating system and other applications also need some RAM to work properly.</p>
			<h3>Environmental variables</h3>
			<p>You can use environmental variables to <a id="_idIndexMarker322"/>customize the behavior of Node.js. You can find the complete list of environmental variables in the Node.js documentation at <a href="https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables">https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables</a>.</p>
			<p>Sometimes it is more convenient to use environmental variables instead of command-line options directly, such as when using UNIX-based systems:</p>
			<pre class="source-code">
# Define the environmental variable
export NODE_OPTIONS='--experimental-json-modules,--max-old-space-size=4096'
# Run the Node.js application as usual
node index.js</pre>			<p>The preceding code lets<a id="_idIndexMarker323"/> you use the <code>NODE_OPTIONS</code> environmental variable to set the command-line options that you want to use. This is very useful when you are using a tool such as <code>nodemon</code> or <code>pm2</code> to run your Node.js application. We will use a lot of environmental variables from <a href="B21678_12.xhtml#_idTextAnchor320"><em class="italic">Chapter 12</em></a>.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor169"/>Summary</h1>
			<p>In this chapter, we have covered how modules work in Node.js, the differences between CJS and ESM, and how to interoperate between them.</p>
			<p>Additionally, we have covered the core libraries of Node.js, how to use them, their structure, and the stability index. We listed the most important core libraries when starting out with Node.js and other libraries that become essential in more advanced projects.</p>
			<p>Finally, we learned how to use the command-line options and environmental variables to modify the Node.js behavior.</p>
			<p>In the next chapter, we will learn how to use the <strong class="bold">node.js package manager</strong> (<strong class="bold">npm</strong>) in depth. We will publish our first package and we will see how we can integrate the huge module ecosystem available for us in our Node.js projects.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor170"/>Further reading</h1>
			<ul>
				<li>Node.js documentation: <a href="https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index&#13;">https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index</a></li>
				<li>Keeping the Node.js core small: <a href="https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152">https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152</a></li>
				<li>Moz://a Hacks | ES6 In Depth: Modules: <a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules">https://hacks.mozilla.org/2015/08/es6-in-depth-modules</a><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/&#13;"/></li>
				<li>Promises API in Node.js Core: Part “Do”, the Update! - Joe Sepi, IBM: <a href="https://www.youtube.com/watch?v=f7YSsYQmNSI">https://www.youtube.com/watch?v=f7YSsYQmNSI</a></li>
			</ul>
		</div>
	</body></html>