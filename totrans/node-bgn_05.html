<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-150" class="chapter-number"><a id="_idTextAnchor156"/>5</h1>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor157"/> Node.js Core Libraries</h1>
			<p>In this chapter, we delve into the core libraries of Node.js and explore the techniques for modularizing your code. JavaScript has come a long way from being limited to browsers, and Node.js has offered us new ways to structure our code. We’ll begin by understanding the historical limitations of organizing code in the browser and how they led to the development of various module systems. We’ll primarily focus on two module systems, <strong class="bold">CommonJS </strong>(<strong class="bold">CJS</strong>) and <strong class="bold">ECMAScript Modules</strong> (<strong class="bold">ESM</strong>), and discuss their usage, importation, and exportation. Achieving interoperability between these two systems is crucial, and we’ll explore strategies to make it <span class="No-Break">work seamlessly.</span></p>
			<p>Understanding how core libraries in Node.js are structured is key. We’ll take a closer look at core libraries including <strong class="source-inline">fs</strong> and <strong class="source-inline">http</strong>, which deal with file operations, and explore the use of callbacks, synchronous functions, and promises for asynchronous <span class="No-Break">I/O operations.</span></p>
			<p>Also, more advanced topics related to extending Node.js functionality with C++ addons and executing external commands using the <strong class="source-inline">child_process</strong> library will be discussed. We’ll also review various command-line options (including to enable experimental features and control memory allocation) and environmental variables that allow you to customize the Node.js behavior. We’ll provide examples of how to use these options to enable experimental features, control memory allocation, and fine-tune your <span class="No-Break">Node.js applications.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>How to create and consume modules using the ESM and <span class="No-Break">CJS approaches</span></li>
				<li>How to interoperate between ESM and <span class="No-Break">CJS modules</span></li>
				<li>How the Node.js core libraries interfaces <span class="No-Break">are structured</span></li>
				<li>What the most relevant Node.js core libraries are when starting <span class="No-Break">with Node.js</span></li>
			</ul>
			<p>How to extend the Node.js functionality by using command-line options and the <strong class="source-inline">NODE_OPTIONS</strong> <span class="No-Break">environment variable</span></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor158"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><span class="No-Break">.</span></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/WQzdXAFxdsc"><span class="No-Break">https://youtu.be/WQzdXAFxdsc</span></a></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor159"/>Modularizing your code (ESM versus CJS)</h1>
			<p>For many years JavaScript was <a id="_idIndexMarker281"/>limited to the browser, and the only way to organize our code was using script files that were loaded in the correct order in a HTML page. This was done by including specific references in the HTML files, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&lt;!-- External Sources --&gt;
&lt;script src="https://code.jquery.com/jquery-3.7.0.min.js"&gt;&lt;/script&gt;
&lt;!-- Other files --&gt;
&lt;script src="script1.js"&gt;&lt;/script&gt;
&lt;!-- Direct Scripts --&gt;
&lt;script&gt;
console.log("Hello world");
&lt;/script&gt;</pre>			<p>This approach was not scalable, and it was very easy to pollute the global scope. To solve this problem, historically we used the IIFE pattern and the module pattern. As the adoption of JavaScript started to grow and the amount of JavaScript required for a modern website was dramatically rising, the community began to create libraries and frameworks to solve these aforementioned problems. The<a id="_idIndexMarker282"/> outcome included results such as <span class="No-Break">RequireJS (</span><a href="https://requirejs.org/"><span class="No-Break">https://requirejs.org/</span></a><span class="No-Break">).</span></p>
			<p>For many years, we had four <a id="_idIndexMarker283"/>different ways to organize <span class="No-Break">our code:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">CommonJS (CJS)</strong></span></li>
				<li><strong class="bold">ECMAScript </strong><span class="No-Break"><strong class="bold">Modules (ESM)</strong></span></li>
				<li><strong class="bold">Asynchronous Module </strong><span class="No-Break"><strong class="bold">Definition (AMD)</strong></span></li>
				<li><strong class="bold">Universal Module </strong><span class="No-Break"><strong class="bold">Definition (UMD)</strong></span></li>
			</ul>
			<p>In this book, we will focus on the first two<a id="_idIndexMarker284"/> approaches, CJS and ESM. Currently CJS is the default module system in Node.js, but since the release of Node.js 12, ESM is now available. In this<a id="_idIndexMarker285"/> section, we will explore how to create and consume modules using <span class="No-Break">both approaches.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Today, in the browser environment is very common to consolidate our code using a module bundler such as webpack or Rollup. However, in Node.js we keep using CJS or ESM directly. In this section, we will explore how to create and consume modules using <span class="No-Break">both approaches.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor160"/>CommonJS (CJS)</h2>
			<p>CommonJS is the module system that Node.js uses by default. This module system is synchronous, and is based on the <strong class="source-inline">require</strong> and <strong class="source-inline">module.exports</strong> functions. It is important to note that this<a id="_idIndexMarker286"/> module system is not part of the ECMAScript specification, but it is the most used module system in the Node.js ecosystem, especially if you are looking for documentation <span class="No-Break">or tutorials.</span></p>
			<p>There are two aspects here of CJS use that we need to understand: the importation and the exportation. Let’s start with <span class="No-Break">the importation.</span></p>
			<h3>Importation</h3>
			<p>So, we have two <a id="_idIndexMarker287"/>files in our project, <strong class="source-inline">utils.js</strong> and <strong class="source-inline">index.js</strong>. In this example, we are importing the <strong class="source-inline">sayHello</strong> function from the <strong class="source-inline">utils.js</strong> file in the <strong class="source-inline"> index.js</strong> file, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const sayHello = require('./utils.js');
sayHello();</pre>			<p>The <strong class="source-inline">require</strong> function is a global function that is available in Node.js and is used to import modules. The <strong class="source-inline">require</strong> function receives a string as a parameter, and this string is the path to the module that we want to import. In this case, we are using a relative path, but we can also use absolute paths or even the name of a module that is installed in the <span class="No-Break"><strong class="source-inline">node_modules</strong></span><span class="No-Break"> folder.</span></p>
			<h3>Exportation</h3>
			<p>In this example, we are <a id="_idIndexMarker288"/>exporting the <strong class="source-inline">sayHello</strong> function in the <span class="No-Break"><strong class="source-inline">utils.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
function sayHello() {
  console.log('Hello world');
}
module.exports = sayHello;</pre>			<p><strong class="source-inline">module.exports</strong> is a global object that is available in Node.js, and it is used to export modules. In this case, we are exporting the <strong class="source-inline">sayHello</strong> function, but we can export any type <span class="No-Break">of value.</span></p>
			<p>If you execute the <strong class="source-inline">index.js</strong> file, you will see the <span class="No-Break">following output:</span></p>
			<pre class="console">
$ node index.js
Hello world</pre>			<p>But if we execute the <strong class="source-inline">utils.js</strong> file, we will see nothing. Even if the file is executed, the <strong class="source-inline">sayHello</strong> function itself is not executed, <span class="No-Break">just defined:</span></p>
			<pre class="console">
$ node utils.js</pre>			<h3>Export object structures</h3>
			<p>The most popular <a id="_idIndexMarker289"/>structure to use while exporting modules is the object structure, as it is very flexible and allows us to export multiple values. If we want to export multiple values, we can use the <span class="No-Break"><strong class="source-inline">exports</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
// You can export directly
exports.sayHello = () =&gt; {
  console.log('Hello world');
}
function sayGoodbye() {
  console.log('Goodbye world');
}
// You can also export using references
exports.sayGoodbye = sayGoodbye;</pre>			<p>But we can also export <a id="_idIndexMarker290"/>an object directly using <strong class="source-inline">module.exports = {}</strong>:</p>
			<pre class="source-code">
const sayHello = () =&gt; {
  console.log('Hello world');
}
function sayGoodbye() {
  console.log('Goodbye world');
}
module.exports = {
  sayHello,
  sayGoodbye
}</pre>			<p>I recommend the preceding option as it is more readable when working with larger files. In order to import the exported values, we can use the <span class="No-Break">destructuring syntax:</span></p>
			<pre class="source-code">
const { sayHello, sayGoodbye } = require('./utils.js');
sayHello();
sayGoodbye();</pre>			<h3>JSON support</h3>
			<p>Yep, you can add JSON files <a id="_idIndexMarker291"/>directly to your project in Node.js and you don’t need to use any external library or parse <span class="No-Break">the content:</span></p>
			<pre class="source-code">
{
  "name": "John",
  "lastName": "Doe"
}</pre>			<p>Now we can require the <span class="No-Break">file directly:</span></p>
			<pre class="source-code">
const user = require('./user.json');
console.log(user);
// { name: 'John', lastName: 'Doe' }</pre>			<p>The way that modules work in Node.js is very similar to the IIFE pattern. When we import a module, the code is executed and the module is cached. If we import the same module again, the code is not executed again, and the module is retrieved from the cache. Basically, the module is executed only once (<span class="No-Break">singleton pattern).</span></p>
			<p>So, for example, if we make changes to the imported JSON file, the changes will not be reflected in the imported module once it has already been imported, because it is read once and the content is cached in the <span class="No-Break">program memory.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor161"/>ECMAScript Modules (ESM)</h2>
			<p>Node.js 12 introduced the support for <strong class="bold">ECMAScript Modules</strong> (<strong class="bold">ESM</strong>). ESM is the module system that is part<a id="_idIndexMarker292"/> of the ECMAScript specification. This module system supports asynchronous (dynamic modules) and is based on the <strong class="source-inline">import</strong> and <span class="No-Break"><strong class="source-inline">export</strong></span><span class="No-Break"> keywords.</span></p>
			<p>In order to use modules with Node.js 20.11.0 you will need to create a <strong class="source-inline">package.json</strong> file and add the <span class="No-Break">following configuration:</span></p>
			<pre class="source-code">
{
  "type": "module"
}</pre>			<p class="callout-heading">Important note</p>
			<p class="callout">In <a href="B21678_06.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, we will explore how to create a <strong class="source-inline">package.json</strong> file and how to configure it <span class="No-Break">in depth.</span></p>
			<h3>Basic usage</h3>
			<p>In this example, we are <a id="_idIndexMarker293"/>exporting the <strong class="source-inline">sayHello</strong> function in the <span class="No-Break"><strong class="source-inline">utils.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
export default function sayHello() {
  console.log('Hello world');
}</pre>			<p>The <strong class="source-inline">export</strong> keyword is used to export modules. In this case, we are exporting the <strong class="source-inline">sayHello</strong> function, but we can export any type of value. Note that we are using the <strong class="source-inline">default</strong> keyword, this is because we are exporting a single value. If we want to export multiple values, we can use the <strong class="source-inline">export</strong> keyword without the <span class="No-Break"><strong class="source-inline">default</strong></span><span class="No-Break"> keyword.</span></p>
			<p>In this example, we are importing the <strong class="source-inline">sayHello</strong> function from the <span class="No-Break"><strong class="source-inline">utils.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
import sayHello from './utils.js';
sayHello();</pre>			<h3>Export object structures</h3>
			<p>The most popular structure to use <a id="_idIndexMarker294"/>while exporting modules is the object structure, as it is very flexible and allows us to export multiple values. If we want to export multiple values, we can use the <span class="No-Break"><strong class="source-inline">export</strong></span><span class="No-Break"> keyword:</span></p>
			<pre class="source-code">
const sayHello = () =&gt; {
  console.log('Hello world');
}
function sayGoodbye() {
  console.log('Goodbye world');
}
export { sayGoodbye, sayHello };</pre>			<p>In this example, we are<a id="_idIndexMarker295"/> importing the <strong class="source-inline">sayHello</strong> and <strong class="source-inline">sayGoodbye</strong> functions from the <strong class="source-inline">utils.js</strong> file in <span class="No-Break">several ways:</span></p>
			<pre class="source-code">
// Import values directly
import { sayHello, sayGoodbye } from './utils.js';
// Use wildcards to import all the exported values
import * as utils from './utils.js';
sayHello();
utils.sayHello();</pre>			<h3>Support for JSON files</h3>
			<p>While using ESM, it is not possible to<a id="_idIndexMarker296"/> import JSON files directly as we did for CJS. If we try to import a JSON file, we will get the <span class="No-Break">following error:</span></p>
			<pre class="source-code">
TypeError [ERR_IMPORT_ASSERTION_TYPE_MISSING]: Module "file:///{REDACTED}/user.json" needs an import assertion of type "json"</pre>			<p>In the future, it will be possible to import JSON files directly, there is a proposal (<a href="https://github.com/tc39/proposal-import-attributes">https://github.com/tc39/proposal-import-attributes</a>) that will allow us to use import attributes, such as <strong class="source-inline">import json from "./foo.json" with { type: "json" };</strong>. But for now, we need to use a workaround to import JSON files. We can fix this error by understanding <a id="_idIndexMarker297"/>how interoperability works between ESM <span class="No-Break">and CJS.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor162"/>Understanding how interoperability works</h2>
			<p>While ESM is the future, there are<a id="_idIndexMarker298"/> many libraries and frameworks that still use CJS. The good news is that Node.js supports both module systems, and it is possible to use both in the same project without any problem, but there are some considerations that we need to take into account in order to make <span class="No-Break">it work.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Interoperability has been a very controversial topic in the Node.js community, and there are many discussions about it. If you want to know more about it, I recommend you to read this article by Gil <span class="No-Break">Tayar: </span><a href="https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71"><span class="No-Break">https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71</span></a><span class="No-Break">.</span></p>
			<h3>JSON files in ESM</h3>
			<p>In the previous section, we saw that it is not<a id="_idIndexMarker299"/> possible to import JSON files directly in ESM today. But we can use the <strong class="source-inline">module</strong> library built into Node.js to import JSON files. The <strong class="source-inline">module</strong> library is a global object that is available in all the modules and contains the <strong class="source-inline">createRequire</strong> method that allows us to create a <strong class="source-inline">require</strong> function that can be used to import <span class="No-Break">CJS modules:</span></p>
			<pre class="source-code">
import { createRequire } from "module";
const require = createRequire(import.meta.url);
const user = require("./user.json");
console.log(user);
// { name: 'John', lastName: 'Doe' }</pre>			<h3>File extensions (.cjs and .mjs)</h3>
			<p>In order to use both module systems in the same project, we need to use different file extensions in our files. The <strong class="source-inline">.mjs</strong> extension is <a id="_idIndexMarker300"/>used for ESM modules, and the <strong class="source-inline">.cjs</strong> extension is used for <span class="No-Break">CJS modules.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you are using <strong class="source-inline">.js</strong> extension for your files, Node.js will try to use the CJS module system by default, like if you were using <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">cjs</strong></span><span class="No-Break"> extension.</span></p>
			<p>Here is the file structure of a project that uses both <span class="No-Break">module systems:</span></p>
			<pre class="source-code">
├── index.cjs
├── index.mjs
├── utils.cjs
└── utils.mjs</pre>			<p>The <strong class="source-inline">utils.cjs</strong> file is a <span class="No-Break">CJS module:</span></p>
			<pre class="source-code">
const sayGoodbye = () =&gt; {
  console.log('Goodbye world');
}
module.exports = { sayGoodbye }</pre>			<p>The <strong class="source-inline">utils.mjs</strong> file is an <span class="No-Break">ESM module:</span></p>
			<pre class="source-code">
const sayHello = () =&gt; {
  console.log('Hello world');
}
export { sayHello }</pre>			<p>The <strong class="source-inline">index.mjs</strong> file is an ESM module. We can combine both module systems in the same file as long as we use different <span class="No-Break">file extensions:</span></p>
			<pre class="source-code">
import { sayHello } from './utils.mjs';
import { sayGoodbye } from './utils.cjs';
sayHello();
sayGoodbye();</pre>			<p>The <strong class="source-inline">index.cjs</strong> file is a CJS module. In this case, ESM modules can not be imported directly because <strong class="source-inline">require</strong> was <a id="_idIndexMarker301"/>designed as a synchronous function, and ESM modules are asynchronous. But we can use the <strong class="source-inline">import</strong> function to import ESM <span class="No-Break">modules asynchronously:</span></p>
			<pre class="source-code">
const { sayGoodbye } = require('./utils.cjs');
import("./utils.mjs").then(({ sayHello }) =&gt; {
    sayHello();
    sayGoodbye();
});</pre>			<p class="callout-heading">Important info</p>
			<p class="callout">This way of importing modules is part of the standard, and it is<a id="_idIndexMarker302"/> called dynamic <span class="No-Break">import (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports</span></a><span class="No-Break">).</span></p>
			<p>In this book, we use ESM modules by default, but we will use CJS modules when we need to use interoperability with other libraries <span class="No-Break">and frameworks.</span></p>
			<p>Now that we have a clearer idea of how to create modules in the different formats, let’s explore in the next section how the Node.js core APIs use a similar approach to expose tons of functionalities that we will use very often in <span class="No-Break">our projects.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor163"/>Structuring core libraries</h1>
			<p>Over the years, Node.js has grown a lot, and the core libraries too. There are many libraries available for us to use, and it is important to know how they are structured to be able to use <span class="No-Break">them properly.</span></p>
			<p>Most of the core libraries are quite simple and are structured in a similar way so you know what to expect in practical terms. Once you know how to use one of them, you will be able to use the rest of them without <span class="No-Break">any problem.</span></p>
			<p>Furthermore, you will be <a id="_idIndexMarker303"/>able to create your own libraries and publish them in npm, and other developers will be able to use them easily, but we will talk about this in the <span class="No-Break">nex<a id="_idTextAnchor164"/>t chapter.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor165"/>The library structure</h2>
			<p>Let’s look at the <strong class="source-inline">fs</strong> library as an example. The <strong class="source-inline">fs</strong> library is used to work with the file system, and it is one of the most used libraries <span class="No-Break">in Node.js.</span></p>
			<p>Any library that performs I/O operations is asynchronous. Historically, Node.js has offered two ways to handle I/O operations: callbacks or synchronous functions. While callbacks are still supported, Node.js currently offers the same functionality providing a <span class="No-Break">promise interface.</span></p>
			<p>In this example, we will use the <strong class="source-inline">readFile</strong> function to read a file asynchronously. This function receives the path of the file to read, and a callback function that will be called when the file is read. The callback function receives two arguments: an error object and the content of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
import { readFile } from 'node:fs';
readFile('hello.txt', (err, content) =&gt; {
  if (err)  {
    console.error("OMG, there is an error:", err);
    return;
  }
  console.log(`File content: ${content}`);
  // File content: Hello world
});</pre>			<p>When you run the previous <a id="_idIndexMarker304"/>example, it will throw an error, as the file does not exist. However, we manage the error using the error first pattern in the callback. You can see the <strong class="source-inline">OMG, there... error message</strong>. Now, if you create the <strong class="source-inline">hello.txt</strong> file with the content <strong class="source-inline">Hello world</strong> and you run again the script, you will see the content printed <span class="No-Break">as expected.</span></p>
			<p>In the next example, we will use the<strong class="source-inline"> readFileSync</strong> function to read a file synchronously. This function receives the path of the file to read, and it returns the content of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
import { readFileSync } from 'node:fs';
try {
  const content = readFileSync('hello.txt');
  console.log(`File content: ${content}`);
  // File content: Hello world
} catch (err) {
  console.error("OMG, there is an error:", err);
};</pre>			<p>And finally, in this example, we will use the <strong class="source-inline">readFile</strong> function to read a file asynchronously. This function receives the path of the file to read and returns a promise that will be resolved when the file is read. The promise will be resolved with the content of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
import { readFile } from 'node:fs/promises';
readFile('hello.txt')
  .then(content =&gt; console.log(`File content: ${content}`))
  .catch(err =&gt; console.error("OMG, there is an error:", err))</pre>			<h3>Core libraries without prefix</h3>
			<p>Historically, Node.js has provided the core libraries<a id="_idIndexMarker305"/> without the <strong class="source-inline">node:*</strong> prefix, such as <strong class="source-inline">const { readFile } from 'fs'</strong>. This is mainly for backward compatibility. But it is recommended to use the new syntax with the prefix <strong class="source-inline">node:*</strong>. You will find many examples on the internet that use the old syntax. More information can be found <span class="No-Break">at </span><a href="https://nodejs.org/api/modules.html"><span class="No-Break">https://nodejs.org/api/modules.html</span></a><span class="No-Break">.</span></p>
			<h3>CJS support</h3>
			<p>All the core libraries are available <a id="_idIndexMarker306"/>as CJS modules, so you can use them in your projects without any problem. You can use the <strong class="source-inline">require</strong> function to <span class="No-Break">import them:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">CJS</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">ESM</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">const { readFile } = </strong><span class="No-Break"><strong class="source-inline">require('node:fs')</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">import { readFile } </strong><span class="No-Break"><strong class="source-inline">from 'node:fs'</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">const { readFileSync } = </strong><span class="No-Break"><strong class="source-inline">require('node:fs')</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">import { readFileSync } </strong><span class="No-Break"><strong class="source-inline">from 'node:fs'</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">const { readFile } = </strong><span class="No-Break"><strong class="source-inline">require('node:fs/promises')</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">import { readFile } </strong><span class="No-Break"><strong class="source-inline">from 'node:fs/promises'</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">const { readFile } = </strong><span class="No-Break"><strong class="source-inline">require('node:fs')</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">import { readFile } </strong><span class="No-Break"><strong class="source-inline">from 'node:fs'</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">const { readFileSync } = </strong><span class="No-Break"><strong class="source-inline">require('node:fs')</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">import { readFileSync } </strong><span class="No-Break"><strong class="source-inline">from 'node:fs'</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<h3>Additional interfaces</h3>
			<p>Other core libraries that you will use frequently, such as <strong class="source-inline">http</strong> or <strong class="source-inline">https</strong>, are structured similarly and provide an <a id="_idIndexMarker307"/>interface to work with events. We will cover this topic in depth in <a href="B21678_07.xhtml#_idTextAnchor206"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor166"/>Stability index</h2>
			<p>The stability index is a number that indicates the stability of the core libraries. The stability index is a number <a id="_idIndexMarker308"/>between 0 and 3, where 0 means deprecated, 1 means experimental, 2 means stable, and 3 <span class="No-Break">means legacy.</span></p>
			<p>You can find the stability index of each core library in the official documentation, along with more details about the stability index <span class="No-Break">at </span><a href="https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#stability-index"><span class="No-Break">https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#stability-index</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you are just starting with Node.js, you should use the core libraries with stability index 2 or 3. The core libraries with a stability index of 0 or 1 are not recommended for <span class="No-Break">production environments.</span></p>
			<p>Let’s see some examples from <span class="No-Break">Node.js 20:</span></p>
			<ul>
				<li>Permission Model (<a href="https://nodejs.org/docs/latest-v20.x/api/permissions.html#permission-model">https://nodejs.org/docs/latest-v20.x/api/permissions.html#permission-model</a>): This is an API that allows us to restrict access to system resources such as network or files. Currently, it is in active development (stability=1), so you can experiment with it, but it is not yet mature enough to use for building production systems as the API might change or have <span class="No-Break">unexpected behavior.</span></li>
				<li>http (<a href="https://nodejs.org/docs/latest-v20.x/api/http.html#http">https://nodejs.org/docs/latest-v20.x/api/http.html#http</a>): This is the API used since the beginning of Node.js to build web server applications and make HTTP requests to external resources. Currently, it is stable (stability=2), but some methods are<a id="_idIndexMarker309"/> legacy (stability=3). This library is perfect for use in <span class="No-Break">production systems.</span></li>
			</ul>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor167"/>Other core libraries</h2>
			<p>The <strong class="source-inline">fs</strong> library is just an example; in this book, we will cover the most important core libraries, but you can find the documentation of all the <a id="_idIndexMarker310"/>core libraries in the Node.js documentation <span class="No-Break">at </span><a href="https://nodejs.org/docs/latest-v20.x/api/index.html"><span class="No-Break">https://nodejs.org/docs/latest-v20.x/api/index.html</span></a><span class="No-Break">.</span></p>
			<p>In my humble opinion, the most important core libraries when you are starting with Node.js are the following, in <span class="No-Break">alphabetical order:</span></p>
			<ul>
				<li><strong class="source-inline">Buffer</strong> handles binary <a id="_idIndexMarker311"/>data efficiently in memory, commonly used for tasks such as file operations and <span class="No-Break">network communication.</span></li>
				<li><strong class="source-inline">Crypto</strong> provides cryptographic <a id="_idIndexMarker312"/>functionality, such as encryption, decryption, hashing, and <span class="No-Break">digital signatures.</span></li>
				<li><strong class="source-inline">Events</strong> allows us to create, emit, and listen for events inside <span class="No-Break">our applications.</span></li>
				<li><strong class="source-inline">File System</strong> provides a <a id="_idIndexMarker313"/>solid interface to deal with the file system (files, folders, creation, <span class="No-Break">deletions, etc.).</span></li>
				<li><strong class="source-inline">HTTP</strong> allows us to <a id="_idIndexMarker314"/>create HTTP servers and perform <span class="No-Break">HTTP requests.</span></li>
				<li><strong class="source-inline">OS</strong> offers various utilities to retrieve<a id="_idIndexMarker315"/> information about the system’s architecture, platform, CPU, memory, network interfaces, and <span class="No-Break">much more.</span></li>
				<li><strong class="source-inline">Path</strong> provides utilities for <a id="_idIndexMarker316"/>working with file paths and <span class="No-Break">directory paths.</span></li>
				<li><strong class="source-inline">Process</strong> provides information and control over aspects of the current Node.js process, including <a id="_idIndexMarker317"/>environmental variables, lifecycle events, <span class="No-Break">and more.</span></li>
				<li><strong class="source-inline">Stream</strong> provides readable and <a id="_idIndexMarker318"/>writable streams, as well as transform streams for modifying data as it passes through. This module is essential for building scalable and memory-efficient applications that work with large volumes of data <span class="No-Break">in Node.js.</span></li>
				<li><strong class="source-inline">Timers</strong> includes functions <a id="_idIndexMarker319"/>such as <strong class="source-inline">setTimeout()</strong>, <strong class="source-inline">setInterval()</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">setImmediate()</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>There are other core libraries that are very important to extend the functionality of Node.js, but they are not so important when you are just starting out <span class="No-Break">with Node.js.</span></p>
			<p>For example, the <strong class="source-inline">child_process</strong> library is essential to execute external commands such as <strong class="source-inline">ls</strong> and <strong class="source-inline">cat</strong> from Node.js, complex applications such as <strong class="source-inline">ffmpeg</strong> and <strong class="source-inline">imagemagick</strong>, and even directly execute <span class="No-Break">Python scripts.</span></p>
			<p>The <strong class="source-inline">C++ Addons</strong> (<a href="https://nodejs.org/dist/latest-v20.x/docs/api/addons.html">https://nodejs.org/dist/latest-v20.x/docs/api/addons.html</a>) are very important to extend the functionality of Node.js with C++ code. This is very useful when you need to use a C++ library in your <span class="No-Break">Node.js application.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor168"/>Command-line options</h2>
			<p>Node.js provides a lot of command-line options and environmental variables that you can use to customize the behavior of Node.js. You can find the complete list of command-line options in the Node.js <a id="_idIndexMarker320"/>documentation <span class="No-Break">at </span><a href="https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options"><span class="No-Break">https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_command_line_options</span></a><span class="No-Break">.</span></p>
			<p>For example, you can use the <strong class="source-inline">--experimental-json-modules</strong> command-line option to enable the JSON modules in ESM, such as <strong class="source-inline">node --</strong><span class="No-Break"><strong class="source-inline">experimental-json-modules index.js</strong></span><span class="No-Break">.</span></p>
			<p>The code of the <strong class="source-inline">index.js</strong> file is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import data from './data.json' assert { type: 'json' };
console.log(data);</pre>			<p>This does work, and the terminal output will remark that the JSON modules <span class="No-Break">are experimental:</span></p>
			<pre class="console">
(node:21490) ExperimentalWarning: Import assertions are not a stable feature of the JavaScript language. Avoid relying on their current behavior and syntax as those might change in a future version of Node.js.
(Use `node --trace-warnings ...` to show where the warning was created)
(node:21490) ExperimentalWarning: Importing JSON modules is an experimental feature and might change at any time</pre>			<p>Aside from enabling experimental features, you can use the <strong class="source-inline">--max-old-space-size</strong> command-line option<a id="_idIndexMarker321"/> to increase the RAM usage limit of Node.js. This is very useful when you are working with large files, have a lot of data in memory, or are debugging a complicated <span class="No-Break">memory leak.</span></p>
			<p>For example, you can use the <strong class="source-inline">--max-old-space-size=4096</strong> command-line option to increase the RAM limit to 4GB: <strong class="source-inline">node --</strong><span class="No-Break"><strong class="source-inline">max-old-space-size=4096 index.js</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can’t use all the RAM in your computer, because the operating system and other applications also need some RAM to <span class="No-Break">work properly.</span></p>
			<h3>Environmental variables</h3>
			<p>You can use environmental variables to <a id="_idIndexMarker322"/>customize the behavior of Node.js. You can find the complete list of environmental variables in the Node.js documentation <span class="No-Break">at </span><a href="https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables"><span class="No-Break">https://nodejs.org/dist/latest-v20.x/docs/api/cli.html#cli_environmental_variables</span></a><span class="No-Break">.</span></p>
			<p>Sometimes it is more convenient to use environmental variables instead of command-line options directly, such as when using <span class="No-Break">UNIX-based systems:</span></p>
			<pre class="source-code">
# Define the environmental variable
export NODE_OPTIONS='--experimental-json-modules,--max-old-space-size=4096'
# Run the Node.js application as usual
node index.js</pre>			<p>The preceding code lets<a id="_idIndexMarker323"/> you use the <strong class="source-inline">NODE_OPTIONS</strong> environmental variable to set the command-line options that you want to use. This is very useful when you are using a tool such as <strong class="source-inline">nodemon</strong> or <strong class="source-inline">pm2</strong> to run your Node.js application. We will use a lot of environmental variables from <a href="B21678_12.xhtml#_idTextAnchor320"><span class="No-Break"><em class="italic">Chapter 12</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor169"/>Summary</h1>
			<p>In this chapter, we have covered how modules work in Node.js, the differences between CJS and ESM, and how to interoperate <span class="No-Break">between them.</span></p>
			<p>Additionally, we have covered the core libraries of Node.js, how to use them, their structure, and the stability index. We listed the most important core libraries when starting out with Node.js and other libraries that become essential in more <span class="No-Break">advanced projects.</span></p>
			<p>Finally, we learned how to use the command-line options and environmental variables to modify the <span class="No-Break">Node.js behavior.</span></p>
			<p>In the next chapter, we will learn how to use the <strong class="bold">node.js package manager</strong> (<strong class="bold">npm</strong>) in depth. We will publish our first package and we will see how we can integrate the huge module ecosystem available for us in our <span class="No-Break">Node.js projects.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor170"/>Further reading</h1>
			<ul>
				<li>Node.js <span class="No-Break">documentation: </span><a href="https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index&#13;"><span class="No-Break">https://nodejs.org/dist/latest-v20.x/docs/api/documentation.html#documentation_stability_index</span></a></li>
				<li>Keeping the Node.js core <span class="No-Break">small: </span><a href="https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152"><span class="No-Break">https://medium.com/the-node-js-collection/keeping-the-node-js-core-small-137f83d18152</span></a></li>
				<li>Moz://a Hacks | ES6 In Depth: <span class="No-Break">Modules: </span><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules"><span class="No-Break">https://hacks.mozilla.org/2015/08/es6-in-depth-modules</span></a><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/&#13;"/></li>
				<li>Promises API in Node.js Core: Part “Do”, the Update! - Joe Sepi, <span class="No-Break">IBM: </span><a href="https://www.youtube.com/watch?v=f7YSsYQmNSI"><span class="No-Break">https://www.youtube.com/watch?v=f7YSsYQmNSI</span></a></li>
			</ul>
		</div>
	</body></html>