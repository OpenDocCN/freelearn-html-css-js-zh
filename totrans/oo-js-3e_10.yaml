- en: Chapter 10. The Browser Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。浏览器环境
- en: 'You know that JavaScript programs need a host environment. Most of what you
    learned so far in this book was related to core ECMAScript/JavaScript and can
    be used in many different host environments. Now, let''s shift the focus to the
    browser as this is the most popular and natural host environment for JavaScript
    programs. In this chapter, you will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道 JavaScript 程序需要一个宿主环境。到目前为止，你在本书中学到的很多东西都与核心 ECMAScript/JavaScript 有关，并且可以在许多不同的宿主环境中使用。现在，让我们将重点转向浏览器，因为这是
    JavaScript 程序最流行和最自然的宿主环境。在本章中，你将学习以下主题：
- en: The **Browser Object Model** (**BOM**)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器对象模型**（**BOM**）'
- en: The **Document Object Model** (**DOM**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）'
- en: Browser events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器事件
- en: The `XMLHttpRequest` object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 对象'
- en: Including JavaScript in an HTML page
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 HTML 页面中包含 JavaScript
- en: 'To include JavaScript in an HTML page, you will need to use the `<script>`
    tag as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 HTML 页面中包含 JavaScript，你需要使用以下 `<script>` 标签：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the first `<script>` tag includes an external file, `somefile.js`,
    which contains JavaScript code. The second `<script>` tag includes the JavaScript
    code directly in the HTML code of the page. The browser executes the JavaScript
    code in the sequence it finds it on the page and all the code in all tags share
    the same global namespace. This means that when you define a variable in `somefile.js`,
    it also exists in the second `<script>` block.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一个 `<script>` 标签包含一个外部文件 `somefile.js`，其中包含 JavaScript 代码。第二个 `<script>`
    标签直接在页面的 HTML 代码中包含 JavaScript 代码。浏览器按照在页面上找到的顺序执行 JavaScript 代码，并且所有标签中的所有代码共享相同的全局命名空间。这意味着当你定义
    `somefile.js` 中的变量时，它也存在于第二个 `<script>` 块中。
- en: BOM and DOM - an overview
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BOM 和 DOM - 概览
- en: 'The JavaScript code in a page has access to a number of objects. These objects
    can be divided into the following types:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 页面中的 JavaScript 代码可以访问许多对象。这些对象可以分为以下类型：
- en: '**Core ECMAScript objects**: This consists of all the objects mentioned in
    the previous chapters'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心 ECMAScript 对象**: 这包括前几章中提到的所有对象'
- en: '**DOM**: This consists of objects that have to do with the currently loaded
    page, which is also called the document'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOM**: 这包括与当前加载的页面（也称为文档）相关的对象'
- en: '**BOM**: This consists of objects that deal with everything outside the page-the
    browser window and the desktop screen'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BOM**: 这包括处理页面外部所有内容的对象——浏览器窗口和桌面屏幕'
- en: DOM stands for Document Object Model and BOM for Browser Object Model.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 代表文档对象模型，BOM 代表浏览器对象模型。
- en: The DOM is a standard governed by the **World Wide Web Consortium** (**W3C**)
    and has different versions, called levels, such as DOM Level 1, DOM Level 2, and
    so on. Browsers in use today have different degrees of compliance with the standard,
    but in general, they almost all completely implement DOM Level 1\. The DOM was
    standardized post factum after the browser vendors had each implemented their
    own ways to access the document. The legacy part from before the W3C took over
    is still around and is referred to as DOM 0, although, no real DOM Level 0 standard
    exists. Some parts of DOM 0 have become de facto standards as all major browsers
    support them; some of these were added to the DOM Level 1 standard. The rest of
    DOM 0 that didn't find its way to DOM 1 is too browser specific and won't be discussed
    here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 是由 **万维网联盟**（**W3C**）管理的标准，有不同的版本，称为级别，例如 DOM Level 1、DOM Level 2 等。当前使用的浏览器对标准的遵守程度不同，但总的来说，它们几乎都完全实现了
    DOM Level 1。DOM 是在浏览器供应商各自实现了自己的文档访问方式之后标准化的。W3C 接管之前的遗留部分仍然存在，被称为 DOM 0，尽管，并没有真正的
    DOM Level 0 标准。DOM 0 的一些部分已经成为事实上的标准，因为所有主流浏览器都支持它们；其中一些被添加到 DOM Level 1 标准。DOM
    0 中其余没有进入 DOM 1 的部分过于特定于浏览器，这里不予讨论。
- en: Historically, BOM was not a part of any standard. Similar to DOM 0, it has a
    subset of objects that is supported by all major browsers, and another subset
    that is browser-specific. The HTML5 standard codifies common behavior among browsers,
    and it includes common BOM objects. Additionally, mobile devices come with their
    specific objects (and HTML5 aims to standardize those as well), which traditionally
    were not necessary for desktop computers, but make sense in a mobile world, for
    example, geolocation, camera access, vibration, touch events, telephony, and SMS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，BOM不是任何标准的一部分。类似于DOM 0，它有一组所有主要浏览器都支持的子对象，以及一组特定于浏览器的子对象。HTML5标准将浏览器之间的常见行为规范化，并包括常见的BOM对象。此外，移动设备带有它们自己的特定对象（HTML5的目标是标准化这些对象），这些对象在传统上对桌面计算机不是必需的，但在移动世界中是有意义的，例如地理位置、相机访问、振动、触摸事件、电话和短信。
- en: 'This chapter discusses only cross-browser subsets of BOM and DOM Level 1, unless
    noted otherwise in the text. Even these safe subsets constitute a large topic,
    and a full reference is beyond the scope of this book. You can also consult the
    following references:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅讨论BOM和DOM Level 1的跨浏览器子集，除非文本中另有说明。即使这些安全的子集也是一个很大的主题，完整的参考超出了本书的范围。您还可以参考以下参考资料：
- en: Mozilla DOM reference ([http://developer.mozilla.org/en/docs/Gecko_DOM_Reference](http://developer.mozilla.org/en/docs/Gecko_DOM_Reference))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla DOM参考([http://developer.mozilla.org/en/docs/Gecko_DOM_Reference](http://developer.mozilla.org/en/docs/Gecko_DOM_Reference))
- en: Mozilla's HTML5 wiki ([https://developer.mozilla.org/en-US/docs/HTML/HTML5](https://developer.mozilla.org/en-US/docs/HTML/HTML5))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla的HTML5维基([https://developer.mozilla.org/en-US/docs/HTML/HTML5](https://developer.mozilla.org/en-US/docs/HTML/HTML5))
- en: Microsoft's documentation for Internet Explorer ([http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx](http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft的Internet Explorer文档([http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx](http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx))
- en: W3C's DOM specifications ([http://www.w3.org/DOM/DOMTR](http://www.w3.org/DOM/DOMTR))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3C的DOM规范([http://www.w3.org/DOM/DOMTR](http://www.w3.org/DOM/DOMTR))
- en: BOM
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BOM
- en: The BOM is a collection of objects that give you access to the browser and the
    computer screen. These objects are accessible through the global object `window`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: BOM是一组对象，它为您提供了访问浏览器和计算机屏幕的权限。这些对象可以通过全局对象`window`访问。
- en: The window object revisited
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次审视window对象
- en: 'As you already know, in JavaScript, there''s a global object provided by the
    host environment. In the browser environment, this global object is accessible
    using `window`. All global variables are also accessible as properties of the
    `window` object. For example, take a look at the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，在JavaScript中，宿主环境提供了一个全局对象。在浏览器环境中，这个全局对象可以通过`window`访问。所有全局变量也可以作为`window`对象属性的访问。例如，看看以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, all the core JavaScript functions, discussed in [Chapter 2](ch02.html
    "Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions"), *Primitive
    Data Types, Arrays, Loops, and Conditions*, are methods of the global object.
    Consider the following piece of code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有在[第2章](ch02.html "第2章。原始数据类型、数组、循环和条件")中讨论的核心JavaScript函数，*原始数据类型、数组、循环和条件*，都是全局对象的方法。考虑以下代码片段：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In addition to being a reference to the global object, the `window` object also
    serves a second purpose-providing information about the browser environment. There's
    a `window` object for every frame, iframe, pop up, or browser tab.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为全局对象的引用之外，`window`对象还承担第二个作用——提供有关浏览器环境的信息。每个框架、iframe、弹出窗口或浏览器标签页都有一个`window`对象。
- en: Let's see some of the browser-related properties of the `window` object. Again,
    these can vary from one browser to another, so let's only consider the properties
    that are implemented consistently and reliably across all major browsers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`window`对象的一些与浏览器相关的属性。同样，这些属性可能因浏览器而异，所以我们只考虑在所有主要浏览器中一致且可靠实现的属性。
- en: Using window.navigator property
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用window.navigator属性
- en: 'The `navigator` is an object that has some information about the browser and
    its capabilities. One property is `navigator.userAgent`, which is a long string
    of browser identification. In Firefox, you''ll get the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigator`是一个包含有关浏览器及其功能信息的对象。其中一个属性是`navigator.userAgent`，它是一个浏览器标识的长字符串。在Firefox中，您将得到以下输出：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `userAgent` string in Microsoft Internet Explorer is something as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Internet Explorer中，`userAgent`字符串如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As the browsers have different capabilities, developers are using the `userAgent`
    string to identify the browser and provide different versions of the code. For
    example, the following code snippet searches for the presence of the `MSIE` string
    to identify Internet Explorer:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器具有不同的功能，开发者使用`userAgent`字符串来识别浏览器并提供不同版本的代码。例如，以下代码片段搜索`MSIE`字符串以识别Internet
    Explorer：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s better not to rely on the `userAgent` string, but to use feature sniffing
    (also called capability detection) instead. The reason for this is that it''s
    hard to keep track of all browsers and their different versions. It''s much easier
    to simply check if the feature you intend to use is indeed available in the user''s
    browser. For example, take a look at the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要依赖于`userAgent`字符串，而是使用特性嗅探（也称为能力检测）代替。原因是跟踪所有浏览器及其不同版本很困难。简单地检查您打算使用的功能是否确实可用在用户的浏览器中要容易得多。例如，看看以下代码片段：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another reason to avoid `userAgent` sniffing is that some browsers allow users
    to modify the string and pretend they are using a different browser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`userAgent`嗅探的另一个原因是，一些浏览器允许用户修改字符串，并假装他们正在使用不同的浏览器。
- en: Your console is a cheat sheet
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的控制台是一个速查表
- en: 'The console lets you inspect what''s in an object and this includes all the
    BOM and DOM properties. Just type the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台允许您检查对象中的内容，这包括所有BOM和DOM属性。只需输入以下代码：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then click on the result. The result is a list of properties and their values,
    as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击结果。结果是属性及其值的列表，如下面的截图所示：
- en: '![Your console is a cheat sheet](img/image_10_001-e1482822786978.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![您的控制台是一个速查表](img/image_10_001-e1482822786978.jpg)'
- en: Using window.location property
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`window.location`属性
- en: The `location` property points to an object that contains information about
    the URL of the currently loaded page. For example, `location.href` is the full
    URL and `location.hostname` is only the domain. With a simple loop, you can see
    the full list of properties of the `location` object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`属性指向一个包含当前加载页面URL信息的对象。例如，`location.href`是完整的URL，而`location.hostname`仅是域名。通过简单的循环，您可以看到`location`对象的完整属性列表。'
- en: 'Imagine you''re on a page with the following URL:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想象您正在一个具有以下URL的页面上：
- en: '[http://search.phpied.com:8080/search?q=java&what=script#results](http://search.phpied.com:8080/search?q=java&what=script#results).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://search.phpied.com:8080/search?q=java&what=script#results](http://search.phpied.com:8080/search?q=java&what=script#results).'
- en: 'Consider the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are also three methods that `location` property provides, namely `reload()`,
    `assign()`, and `replace()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`属性还提供了三种方法，即`reload()`、`assign()`和`replace()`。'
- en: 'It''s interesting how many different ways exist for you to navigate to another
    page. The following are a few ways:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，存在许多不同的方式可以导航到另一个页面。以下是一些方法：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `replace()` method is almost the same as `assign()`. The difference is
    that it doesn''t create an entry in the browser''s history list as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()`方法几乎与`assign()`相同。区别在于它不会在浏览器的历史记录列表中创建条目，如下所示：'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To reload a page, you can use the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新加载页面，您可以使用以下代码：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, you can use `location.href` to point it to itself, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`location.href`将其指向自身，如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or, simply use the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，简单地使用以下代码：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using window.history property
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`window.history`属性
- en: 'The `window.history` property allows limited access to the previously visited
    pages in the same browser session. For example, you can see how many pages the
    user has visited before coming to your page, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.history`属性允许对同一浏览器会话中之前访问的页面进行有限访问。例如，您可以看到用户在到达您的页面之前访问了多少页面，如下所示：'
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You cannot see the actual URLs though. For privacy reasons, this doesn''t work.
    See the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法看到实际的URL。出于隐私原因，这不起作用。请看以下代码：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can, however, navigate back and forth through the user''s session as if
    the user had clicked on the back/forward browser buttons, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以导航回用户会话的前后，就像用户点击了后退/前进浏览器按钮一样，如下所示：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also skip pages back and forth with `history.go()`. This is the same
    as calling `history.back()`. The code for `history.go()` is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`history.go()`来回跳转页面。这与调用`history.back()`相同。`history.go()`的代码如下：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To go two pages back, use the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要后退两页，请使用以下代码：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Reload the current page using the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码重新加载当前页面：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'More recent browsers also support HTML5 history API, which lets you change
    the URL without reloading the page. This is perfect for dynamic pages because
    they can allow users to bookmark a specific URL, which represents the state of
    the application, and when they come back, or share with their friends, the page
    can restore the application state based on the URL. To get a sense of the history
    API, go to any page and write the following lines of code in the console:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的浏览器也支持HTML5历史API，这允许你在不重新加载页面的情况下更改URL。这对于动态页面来说非常完美，因为它们可以允许用户将特定的URL作为应用程序状态的表示进行书签，当他们回来或与朋友分享时，页面可以根据URL恢复应用程序状态。为了了解历史API，请访问任何页面并在控制台中写下以下代码行：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how the URL changes, but the page is the same. Now, experiment with back
    and forward buttons in the browser and inspect the `history.state` object again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意URL是如何变化的，但页面保持不变。现在，在浏览器中尝试使用后退和前进按钮，并再次检查`history.state`对象。
- en: using window.frames property
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`window.frames`属性
- en: 'The `window.frames` property is a collection of all of the frames in the current
    page. It doesn''t distinguish between frames and iframes (inline frames). Regardless
    of whether there are frames on the page or not, `window.frames` always exists
    and points to `window`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.frames`属性是当前页面中所有框架的集合。它不区分框架和iframe（内联框架）。无论页面上是否有框架，`window.frames`始终存在并指向`window`，如下所示：'
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s consider an example where you have a page with one iframe, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，你有一个包含一个iframe的页面，如下所示：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to tell if there are any frames on the page, you can check the `length`
    property. In case of one iframe, you''ll see the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断页面上是否有框架，你可以检查`length`属性。如果只有一个iframe，你会看到以下输出：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each frame contains another page, which has its own global `window` object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框架都包含另一个页面，该页面有自己的全局`window`对象。
- en: 'To get access to the iframe''s `window`, you can execute any of the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问iframe的`window`，你可以执行以下任何一个：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'From the parent page, you can access properties of the child frame as well.
    For example, you can reload the frame as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从父页面，你也可以访问子框架的属性。例如，你可以按照以下方式重新加载框架：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From inside the child, you can access the parent as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从子页面内部，你可以按照以下方式访问父页面：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using a property called `top`, you can access the top-most page-the one that
    contains all the other frames-from within any frame, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个名为`top`的属性，你可以从任何框架中访问最顶层的页面——包含所有其他框架的那个页面，如下所示：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In addition, `self` is the same as `window`, as you can see in the following
    code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`self`与`window`相同，正如以下代码片段所示：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If a frame has a `name` attribute, you cannot only access the frame by name,
    but also by index, as shown in the following piece of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个框架有`name`属性，你不仅可以按名称访问框架，还可以按索引访问，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or, alternatively, you can use the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下代码：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using window.screen property
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`window.screen`属性
- en: 'The `screen` property provides information about the environment outside the
    browser. For example, the `screen.colorDepth` property contains the color bit
    depth (the color quality) of the monitor. This is mostly used for statistical
    purposes. Take a look at the following line of code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`screen`属性提供了关于浏览器外部环境的信息。例如，`screen.colorDepth`属性包含监视器的颜色位深度（颜色质量）。这主要用于统计目的。请查看以下代码行：'
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also check the available screen real estate (the resolution), as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查可用的屏幕空间（分辨率），如下所示：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The difference between `height` and `availHeight` is that `height` is the whole
    screen, while `availHeight` subtracts any operating system menus, such as the
    Windows task bar. The same is the case for `width` and `availWidth`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`height`和`availHeight`之间的区别在于`height`是整个屏幕，而`availHeight`减去了任何操作系统菜单，例如Windows任务栏。对于`width`和`availWidth`也是同样的情况。'
- en: 'Somewhat related is the property mentioned in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下代码中提到的属性有些相关：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It tells you the difference (ratio) between physical pixels and device pixels
    in the retina displays in mobile devices, for example, value 2 in iPhone.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你物理像素和设备像素在移动设备上的视网膜显示屏中的差异（比率），例如，iPhone中的值为2。
- en: window.open()/close() method
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`window.open()/close()`方法'
- en: Having explored some of the most common cross-browser properties of the `window`
    object, let's move to some of the methods. One such method is `open()`, which
    allows you to open new browser windows (pop ups). Various browser policies and
    user settings may prevent you from opening a pop up (due to abuse of the technique
    for marketing purposes), but generally, you should be able to open a new window
    if it was initiated by the user. Otherwise, if you try to open a pop up as the
    page loads, it will most likely be blocked, because the user didn't initiate it
    explicitly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了 `window` 对象的一些最常用的跨浏览器属性之后，让我们转向一些方法。其中一种方法是 `open()`，它允许你打开新的浏览器窗口（弹出窗口）。各种浏览器策略和用户设置可能会阻止你打开弹出窗口（由于营销目的对该技术的滥用），但通常，如果你是由用户发起的，你应该能够打开一个新窗口。否则，如果你在页面加载时尝试打开一个弹出窗口，它很可能会被阻止，因为用户没有明确发起。
- en: 'The `window.open()` method accepts the following parameters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.open()` 方法接受以下参数：'
- en: URL to load in the new window
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新窗口中要加载的 URL
- en: Name of the new window that can be used as the value of a form's `target` attribute
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用作表单 `target` 属性值的新窗口名称
- en: 'Comma-separated list of features, which is as follows:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以逗号分隔的功能列表，如下所示：
- en: '`resizable`: Should the user be able to resize the new window'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resizable`: 用户是否能够调整新窗口的大小'
- en: '`width`, `height`: Width and height of the pop up'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`、`height`: 弹出窗口的宽度和高度'
- en: '`status`: Should the status bar be visible'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 是否应显示状态栏'
- en: 'The `window.open()` method returns a reference to the `window` object of the
    newly created browser instance. The following is an example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.open()` 方法返回对新创建浏览器实例的 `window` 对象的引用。以下是一个示例：'
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `win` variable points to the `window` object of the pop up. You can check
    if `win` has a falsy value, which means that the pop up was blocked.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`win` 变量指向弹出窗口的 `window` 对象。你可以检查 `win` 是否具有假值，这意味着弹出窗口被阻止了。'
- en: The `win.close()` method closes the new window.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`win.close()` 方法关闭新窗口。'
- en: It's best to stay away from opening new windows for accessibility and usability
    reasons. If you don't like sites popping up windows to you, why do it to your
    users? There are legitimate purposes, such as providing help information while
    filling out a form, but often, the same can be achieved with alternative solutions,
    such as using a floating `<div>` inside the page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可访问性和可用性，最好避免打开新窗口。如果你不喜欢网站弹出窗口，为什么还要对你的用户这样做呢？有合法的目的，例如在填写表单时提供帮助信息，但通常，可以通过替代方案实现相同的效果，例如在页面内使用浮动
    `<div>`。
- en: window.moveTo() and window.resizeTo() methods
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`window.moveTo()` 和 `window.resizeTo()` 方法'
- en: 'Continuing with the shady practices from the past, the following are more methods
    to irritate your users, provided their browser and personal settings allow you
    to do so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用过去的可疑做法，以下是一些可能激怒用户的方法，前提是他们的浏览器和个人设置允许你这样做：
- en: '`window.moveTo(100, 100)`: This moves the browser window to screen location
    `x = 100` and `y = 100`, which is counted from the top-left corner'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.moveTo(100, 100)`: 这将浏览器窗口移动到屏幕位置 `x = 100` 和 `y = 100`，从左上角开始计算。'
- en: '`window.moveBy(10, -10)`: This moves the window 10 pixels to the right and
    10 pixels up from its current location'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.moveBy(10, -10)`: 这将窗口从当前位置向右移动 10 像素，向上移动 10 像素。'
- en: '`window.resizeTo(x, y)` and `window.resizeBy(x, y)`: These accept the same
    parameters as the move methods, but they resize the window as opposed to moving
    it'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.resizeTo(x, y)` 和 `window.resizeBy(x, y)`: 它们接受与移动方法相同的参数，但它们调整窗口大小而不是移动它。'
- en: Again, try to solve the problem you're facing without resorting to these methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽量在不使用这些方法的情况下解决问题。
- en: window.alert(), window.prompt(), and window.confirm() methods
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`window.alert()`、`window.prompt()` 和 `window.confirm()` 方法'
- en: In [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops, and
    Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*, we talked
    about the `alert()` function. Now you know that global functions are accessible
    as methods of the global object, so `alert('Watch` `out!')` and `window.alert('Watch`
    `out!')` are exactly the same.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions")
    中，我们讨论了 `alert()` 函数。现在你知道全局函数可以作为全局对象的方法访问，所以 `alert('Watch out!')` 和 `window.alert('Watch
    out!')` 完全相同。
- en: 'The `alert()` function is not an ECMAScript function but a BOM method. In addition
    to it, two other BOM methods allow you to interact with the user through system
    messages. The following are the methods:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert()` 函数不是一个 ECMAScript 函数，而是一个 BOM 方法。除此之外，还有另外两种 BOM 方法允许你通过系统消息与用户交互。以下是一些方法：'
- en: '`confirm()`: This gives the user two options, **OK** and **Cancel**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`confirm()`: 这为用户提供了两个选项，**确定**和**取消**'
- en: '`prompt()`: This collects textual input'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prompt()`: 这收集文本输入'
- en: 'This is how it works:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作方式：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It presents you with a window similar to the following screenshot (the exact
    look depends on the browser and the operating system):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它会显示一个类似于以下截图的窗口（具体外观取决于浏览器和操作系统）：
- en: '![window.alert(), window.prompt(), and window.confirm() methods](img/image_10_002.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![window.alert(), window.prompt(), 和 window.confirm() 方法](img/image_10_002.jpg)'
- en: 'You''ll notice the following things:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到以下事项：
- en: Nothing gets written to the console until you close this message, which means
    that any JavaScript code execution freezes, waiting for the user's answer
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在您关闭此消息之前，控制台才会写入任何内容，这意味着任何JavaScript代码执行都会冻结，等待用户的回答
- en: Clicking on **OK** returns `true`, clicking on **Cancel** or closing the message
    using the **X** icon, or the **ESC** key, returns `false`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**确定**返回`true`，点击**取消**或使用**X**图标、**ESC**键关闭消息，返回`false`
- en: 'This is handy to confirm user actions, as shown in the following piece of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于确认用户操作很有用，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Make sure you provide an alternative way to confirm user actions for people
    who have disabled JavaScript, or for search engine spiders.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为禁用JavaScript的用户或搜索引擎蜘蛛提供另一种确认用户操作的方式。
- en: 'The `window.prompt()` method presents the user with a dialog to enter text,
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.prompt()`方法向用户显示一个对话框以输入文本，如下所示：'
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This results in the following dialog box (Chrome, MacOS):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下对话框（Chrome，MacOS）：
- en: '![window.alert(), window.prompt(), and window.confirm() methods](img/image_10_003-e1482823176627.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![window.alert(), window.prompt(), 和 window.confirm() 方法](img/image_10_003-e1482823176627.jpg)'
- en: 'The value of `answer` is one of the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`answer`的值是以下之一：'
- en: '`null`: This happens if you click on **Cancel**, the **X** icon, or press **ESC**
    key'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`: 如果您点击**取消**、**X**图标或按**ESC**键，就会发生这种情况'
- en: '`""` (empty string): This happens if you click on OK or press Enter without
    typing anything'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`（空字符串）：如果您点击**确定**或按Enter键而没有输入任何内容，就会发生这种情况'
- en: 'A text string: This is if you type something and then click on **OK** or press
    **Enter**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字符串：这是如果你输入一些内容然后点击**确定**或按**Enter**键的情况
- en: The function also takes a string as a second parameter and displays it as a
    default value prefilled into the input field.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还接受一个字符串作为第二个参数，并将其显示为默认值，预先填充到输入字段中。
- en: Using window.setTimeout() and window.setInterval() methods
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 window.setTimeout() 和 window.setInterval() 方法
- en: The `setTimeout()`and `setInterval()` methods allow scheduling the execution
    of a piece of code. The `setTimeout()` method attempts to execute the given code
    once, after a specified number of milliseconds. The `setInterval()` method attempts
    to execute it repeatedly after a specified number of milliseconds has passed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`和`setInterval()`方法允许安排代码的执行。`setTimeout()`方法尝试在指定数量的毫秒后执行给定的代码一次。`setInterval()`方法尝试在指定数量的毫秒后重复执行。'
- en: 'This shows an alert after approximately 2 seconds (2000 milliseconds). Consider
    the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在大约2秒（2000毫秒）后显示一个警告框。考虑以下代码：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, the function returned an integer (in this case, `4`) representing
    the ID of the timeout. You can use this ID to cancel the timeout using `clearTimeout()`.
    In the following example, if you''re quick enough, and clear the timeout before
    2 seconds have passed, the alert will never be shown, as you can see in the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该函数返回一个整数（在这种情况下，`4`），表示超时的ID。您可以使用此ID使用`clearTimeout()`取消超时。在以下示例中，如果您足够快，并且在2秒之前清除超时，警告框将不会显示，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s change `boo()`to something less intrusive, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`boo()`改为不那么侵扰性的内容，如下所示：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, using `setInterval()`, you can schedule `boo()` to execute every 2 seconds,
    until you cancel the scheduled execution with `clearInterval()`. Consider the
    following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`setInterval()`，你可以安排`boo()`每2秒执行一次，直到你使用`clearInterval()`取消计划的执行。考虑以下代码：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that both functions accept a pointer to a callback function as a first
    parameter. They can also accept a string, which is evaluated with `eval();` however,
    as you know, `eval()` is evil, so it should be avoided. Moreover, what if you
    want to pass arguments to the function? In such cases, you can just wrap the function
    call inside another function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个函数都接受一个回调函数的指针作为第一个参数。它们也可以接受一个字符串，该字符串通过`eval();`进行评估；然而，正如您所知，`eval()`是邪恶的，因此应该避免。此外，如果您想向函数传递参数怎么办？在这种情况下，您只需将函数调用包装在另一个函数中即可。
- en: 'The following code is valid, but not recommended:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是有效的，但不推荐使用：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This alternative is preferred:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个替代方案更受欢迎：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Be aware that scheduling a function in some amount of milliseconds is not a
    guarantee that it will execute exactly at that time. One reason is that most browsers
    don't have millisecond resolution time. If you schedule something in 3 milliseconds,
    it will execute after a minimum of 15 in older IEs and sooner in more modern browsers,
    but most likely, not in 1 millisecond. The other reason is that the browsers maintain
    a queue of what you request them to do. 100 milliseconds timeout means add to
    the queue after 100 milliseconds. However, if the queue is delayed by something
    slow happening, your function will have to wait and execute after, say, 120 milliseconds.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以一定量的毫秒数安排一个函数并不能保证它将正好在那个时间执行。一个原因是大多数浏览器没有毫秒级的时间分辨率。如果您在3毫秒内安排某事，它将在较旧的IE浏览器中至少延迟15毫秒执行，在更现代的浏览器中则更早执行，但最可能的情况是，不会在1毫秒内执行。另一个原因是浏览器维护了一个您请求它们执行的任务队列。100毫秒的超时意味着在100毫秒后添加到队列中。然而，如果队列因为某些缓慢发生的事情而延迟，您的函数将不得不等待，并在例如120毫秒后执行。
- en: 'More recent browsers implement the `requestAnimationFrame()` function. It''s
    preferable to the timeout functions because you''re asking the browser to call
    your function whenever it has available resources, not after a predefined time
    in milliseconds. Try executing the following code snippet in your console:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的浏览器实现了`requestAnimationFrame()`函数。它比超时函数更可取，因为您要求浏览器在可用资源时调用您的函数，而不是在预定义的毫秒数后。请尝试在您的控制台执行以下代码片段：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: window.document property
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: window.document属性
- en: The `window.document` property is a BOM object that refers to the currently
    loaded document (page). Its methods and properties fall into the DOM category
    of objects. Take a deep breath (and maybe first look at the BOM exercises at the
    end of the chapter) and let's dive into the DOM.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.document`属性是一个BOM对象，它指向当前加载的文档（页面）。它的方法和属性属于DOM对象类别。深呼吸（也许首先看看本章末尾的BOM练习）然后让我们深入DOM。'
- en: DOM
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM
- en: The DOM represents an XML or an HTML document as a tree of nodes. Using DOM
    methods and properties, you can access any element on the page, modify or remove
    elements, or add new ones. The DOM is a language-independent API and can be implemented
    not only in JavaScript, but also in any other language. For example, you can generate
    pages on the server-side with PHP's DOM implementation ([http://php.net/dom](http://php.net/dom)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: DOM将XML或HTML文档表示为节点树。使用DOM方法和属性，您可以访问页面上的任何元素，修改或删除元素，或添加新的元素。DOM是一个与语言无关的API，不仅可以在JavaScript中实现，也可以在任何其他语言中实现。例如，您可以使用PHP的DOM实现生成服务器端的页面([http://php.net/dom](http://php.net/dom))。
- en: 'Take a look at this example HTML page:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个示例HTML页面：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Consider the second paragraph `(<p><em>second</em> paragraph</p>`). You will
    see that it''s a `<p>` tag, and it''s contained in the `<body>` tag. If you think
    in terms of family relationships, you can say that `<body>` is the parent of `<p>`
    and `<p>` is the child. The first and the third paragraphs would also be children
    of the `<body>` tag, and at the same time, siblings of the second paragraph. The
    `<em>` tag is a child of the second `<p>`, so `<p>` is its parent. The parent-child
    relationships can be represented graphically in an ancestry tree, called the DOM
    tree:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第二个段落`(<p><em>second</em> paragraph</p>)`。您会看到它是一个`<p>`标签，并且它包含在`<body>`标签中。如果您从家庭关系的角度思考，可以说`<body>`是`<p>`的父级，而`<p>`是子级。第一段和第三段也会是`<body>`标签的子级，同时与第二个段落是兄弟关系。`<em>`标签是第二个`<p>`的子级，所以`<p>`是它的父级。父级-子级关系可以用图形化的家谱树表示，称为DOM树：
- en: '![DOM](img/image_10_004.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![DOM](img/image_10_004.jpg)'
- en: The previous screenshot shows what you'll see in the WebKit console's **Elements**
    tab after you expand each node.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了您在展开每个节点后将在WebKit控制台的**元素**选项卡中看到的内容。
- en: You can see how all of the tags are shown as expandable nodes on the tree. Although
    not shown, there exists the so-called text nodes, for example, the text inside
    the `<em>` tag (the word second) is a text node. Whitespace is also considered
    a text node. Comments inside the HTML code are also nodes in the tree, the `<!-
    and that's about it ->` comment in the HTML source is a comment node in the tree.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到所有标签都显示为树上的可展开节点。虽然未显示，但存在所谓的文本节点，例如，`<em>`标签内的文本（单词second）是一个文本节点。空白也被视为文本节点。HTML代码中的注释也是树中的节点，HTML源中的`<!-
    and that's about it ->`注释在树中是一个注释节点。
- en: 'Every node in the DOM tree is an object and the **Properties** section on the
    right lists all of the properties and methods you can use to work with these objects,
    following the inheritance chain of how this object was created:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: DOM树中的每个节点都是一个对象，右侧的 **属性** 部分列出了你可以用来操作这些对象的全部属性和方法，按照对象创建时的继承链进行排列：
- en: '![DOM](img/image_10_005.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![DOM](img/image_10_005.jpg)'
- en: You can also see the constructor function that was used behind the scenes to
    create each of these objects. Although, this is not too practical for day-to-day
    tasks, it may be interesting to know that, for example, `<p>` is created by the
    `HTMLParagraphElement()` constructor, the object that represents the `head` tag
    is created by `HTMLHeadElement()`, and so on. You cannot create objects using
    these constructors directly, though.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到在幕后用于创建每个这些对象的构造函数。尽管这在日常任务中并不太实用，但了解例如 `<p>` 是由 `HTMLParagraphElement()`
    构造函数创建的，表示 `head` 标签的对象是由 `HTMLHeadElement()` 创建的，等等，可能是有趣的。尽管如此，你不能直接使用这些构造函数来创建对象。
- en: Core DOM and HTML DOM
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心DOM和HTML DOM
- en: 'One last diversion before moving on to more practical examples. As you now
    know, the DOM represents both XML documents and HTML documents. In fact, HTML
    documents are XML documents, but a little more specific. Therefore, as part of
    DOM Level 1, there is a Core DOM specification that is applicable to all XML documents,
    and there is also an HTML DOM specification, which extends and builds upon the
    core DOM. Of course, the HTML DOM doesn''t apply to all XML documents, but only
    to HTML documents. Let''s see some examples of Core DOM and HTML DOM constructors:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向更多实际示例之前，还有一个最后的分岔。正如你所知，DOM 代表了 XML 文档和 HTML 文档。实际上，HTML 文档是 XML 文档，但更具体一些。因此，作为
    DOM Level 1 的一部分，有一个适用于所有 XML 文档的核心 DOM 规范，还有一个 HTML DOM 规范，它扩展并建立在核心 DOM 的基础上。当然，HTML
    DOM 不适用于所有 XML 文档，而只适用于 HTML 文档。让我们看看核心 DOM 和 HTML DOM 构造函数的一些示例：
- en: '| **Constructor** | **Inherits from** | **Core or HTML** | **Comment** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **构造函数** | **继承自** | **核心或HTML** | **注释** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `Node` |  | Core | Any node on the tree |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `Node` |  | 核心功能 | 树上的任何节点 |'
- en: '| `Document` | `Node` | Core | The document object, the main entry point to
    any XML document |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `Document` | `Node` | 核心功能 | 文档对象，任何 XML 文档的主要入口点 |'
- en: '| `HTMLDocument` | `Document` | HTML | This is window.document or simply document,
    the HTML-specific version of the previous object, which you''ll use extensively
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLDocument` | `Document` | HTML | 这是 window.document 或简单地 document，是前一个对象的
    HTML 特定版本，你将广泛使用它 |'
- en: '| `Element` | `Node` | Core | Every tag in the source is represented by an
    element. That''s why you say-the `P` element meaning the `<p></p>` tag |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `Element` | `Node` | 核心功能 | 源代码中的每个标签都由一个元素表示。这就是为什么你说 `P` 元素意味着 `<p></p>`
    标签 |'
- en: '| `HTMLElement` | `Element` | HTML | General-purpose constructor, all constructors
    for HTML elements inherit from it |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLElement` | `Element` | HTML | 通用构造函数，所有 HTML 元素的构造函数都继承自它 |'
- en: '| `HTMLBodyElement` | `HTMLElement` | HTML | Element representing the `<body>`
    tag |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLBodyElement` | `HTMLElement` | HTML | 表示 `<body>` 标签的元素 |'
- en: '| `HTMLLinkElement` | `HTMLElement` | HTML | An A element: an `<a href="..."></a>`
    tag |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLLinkElement` | `HTMLElement` | HTML | A 元素：一个 `<a href="..."></a>` 标签
    |'
- en: '| And other such constructors | `HTMLElement` | HTML | All the rest of the
    HTML elements |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 其他此类构造函数 | `HTMLElement` | HTML | 所有其他 HTML 元素 |'
- en: '| `CharacterData` | `Node` | Core | General-purpose constructor for dealing
    with texts |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `CharacterData` | `Node` | 核心功能 | 处理文本的通用构造函数 |'
- en: '| `Text` | `CharacterData` | Core | Text node inside a tag; in `<em>`second`</em>`,
    you have the element node `EM` and the text node with value second |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `Text` | `CharacterData` | 核心功能 | 标签内的文本节点；在 `<em>second</em>` 中，你有元素节点 `EM`
    和值为 "second" 的文本节点 |'
- en: '| `Comment` | `CharacterData` | Core | `<!-- any comment -->` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `Comment` | `CharacterData` | 核心功能 | `<!-- any comment -->` |'
- en: '| `Attr` | `Node` | Core | Represents an attribute of a tag; in `<p id="closer">`,
    the `id` attribute is a DOM object created by the `Attr()` constructor |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `Attr` | `Node` | 核心功能 | 表示标签的一个属性；在 `<p id="closer">` 中，`id` 属性是由 `Attr()`
    构造函数创建的 DOM 对象 |'
- en: '| `NodeList` |  | Core | A list of nodes, an array-like object that has a `length`
    property |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `NodeList` |  | 核心功能 | 节点列表，一个具有 `length` 属性的类似数组的对象 |'
- en: '| `NamedNodeMap` |  | Core | Same as `NodeList`, but the nodes can be accessed
    by name, not only by numeric index. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `NamedNodeMap` |  | 核心功能 | 与 `NodeList` 相同，但节点可以通过名称访问，而不仅仅是通过数字索引。 |'
- en: '| `HTMLCollection` |  | HTML | Similar to `NamedNodeMap` but specific for HTML.
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLCollection` |  | HTML | 与 `NamedNodeMap` 类似，但特定于 HTML。 |'
- en: These are, by no means, all of the Core DOM and HTML DOM objects. For the full
    list, consult [http://www.w3.org/TR/DOM-Level-1/](http://www.w3.org/TR/DOM-Level-1/).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝不是所有核心DOM和HTML DOM对象。要获取完整列表，请参考[http://www.w3.org/TR/DOM-Level-1/](http://www.w3.org/TR/DOM-Level-1/)。
- en: 'Now that this bit of the DOM theory is behind you, let''s focus on the practical
    side of working with the DOM. In the following sections, you''ll learn how to
    do the following topics:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了DOM理论的一部分，让我们关注一下使用DOM的实践方面。在接下来的几节中，你将学习以下主题：
- en: Access DOM nodes
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问DOM节点
- en: Modify nodes
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改节点
- en: Create new nodes
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新节点
- en: Remove nodes
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除节点
- en: Accessing DOM nodes
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问DOM节点
- en: Before you can validate the user input in a form on a page or swap an image,
    you need to get access to the element you want to inspect or modify. Luckily,
    there are many ways to get to any element, either by navigating around traversing
    the DOM tree or by using a shortcut.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以在页面上验证用户输入或在页面上交换图片之前，你需要获取你想要检查或修改的元素。幸运的是，有很多方法可以到达任何元素，无论是通过在DOM树中导航遍历，还是使用快捷方式。
- en: It's best if you start experimenting with all of the new objects and methods.
    The examples you'll see use the same simple document that you saw at the beginning
    of the DOM section, and which you can access at [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html).
    Open your console, and let's get started.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是尝试所有新的对象和方法。你将看到的示例使用的是你在DOM部分开始时看到的相同简单的文档，并且你可以通过[http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)访问它。打开你的控制台，让我们开始吧。
- en: The document node
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档节点
- en: 'The `document` node gives you access to the current document. To explore this
    object, you can use your console as a cheat sheet. Type `console.dir`(document)
    and click on the result:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`document`节点提供了访问当前文档的途径。要探索这个对象，你可以使用你的控制台作为速查表。输入`console.dir(document)`并点击结果：'
- en: '![The document node](img/image_10_006.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![文档节点](img/image_10_006.jpg)'
- en: 'Alternatively, you can browse all of the properties and methods of the `document`
    object DOM properties in the **Elements** panel:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在**元素**面板中浏览`document`对象DOM属性的所有属性和方法：
- en: '![The document node](img/image_10_007.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![文档节点](img/image_10_007.jpg)'
- en: 'All nodes, including the document node, text nodes, element nodes, and attribute
    nodes have `nodeType`, `nodeName` and `nodeValue` properties:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点，包括文档节点、文本节点、元素节点和属性节点都有`nodeType`、`nodeName`和`nodeValue`属性：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There are 12 node types, represented by integers. As you can see, the document
    node type is `9`. The most commonly used are `1` (element), `2` (attribute), and
    `3` (text).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有12种节点类型，由整数表示。正如你所看到的，文档节点类型是`9`。最常用的类型是`1`（元素）、`2`（属性）和`3`（文本）。
- en: 'Nodes also have names. For HTML tags, the node name is the tag name (`tagName`
    property). For text nodes, it''s `#text`, and for document nodes, the name is
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 节点也有名称。对于HTML标签，节点名称是标签名称（`tagName`属性）。对于文本节点，它是`#text`，对于文档节点，名称如下：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Nodes can also have node values. For example, for text nodes, the value is
    the actual text. The document node doesn''t have a value, which can be seen as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 节点也可以有节点值。例如，对于文本节点，值是实际的文本。文档节点没有值，如下所示：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: documentElement
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: documentElement
- en: Now, let's move around the tree. XML documents always have one root node that
    wraps the rest of the document. For HTML documents, the root is the `<html>` tag.
    To access the root, you will use the `documentElement` property of the `document`
    object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在树中移动。XML文档总是有一个根节点，它包含文档的其余部分。对于HTML文档，根是`<html>`标签。要访问根节点，你将使用`document`对象的`documentElement`属性。
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`nodeType` is `1` (an element node) which can be seen as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodeType`为`1`（一个元素节点），如下所示：'
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For element nodes, both `nodeName` and `tagName` properties contain the name
    of the tag, as seen in the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于元素节点，`nodeName`和`tagName`属性都包含标签的名称，如下面的输出所示：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Child nodes
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子节点
- en: 'In order to tell if a node has any children, you will use `hasChildNodes()`,
    as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断一个节点是否有子节点，你可以使用`hasChildNodes()`，如下所示：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The HTML element has three children, the `head` and the `body` elements and
    the whitespace between them (whitespace is counted in most, but not all browsers).
    You can access them using the `childNodes` array-like collection, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: HTML元素有三个子节点，即`head`和`body`元素以及它们之间的空白（在大多数浏览器中，空白也被计算在内）。你可以使用类似数组的`childNodes`集合来访问它们，如下所示：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Any child has access to its parent through the `parentNode` property, as seen
    in the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 任何子节点都可以通过`parentNode`属性访问其父节点，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s assign a reference to body to a variable, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`body`的引用分配给一个变量，如下所示：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How many children does the `body` element have? Consider the following piece
    of code
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`元素有多少个子元素？考虑以下代码片段'
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As a refresher, here, again, is the body of the document:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，这里再次列出文档的主体：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How come body has `9` children? Well, three paragraphs plus one comment makes
    four nodes. The whitespace between these four nodes makes three more text nodes.
    This makes a total of seven so far. The whitespace between `<body>` and the first
    `<p>` is the eighth node. The whitespace between the comment and the closing `</body>`
    is another text node. This makes a total of nine child nodes. Just type `bd.childNodes`
    in the console to inspect them all.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`body`有`9`个子元素？好吧，三个段落加上一个注释构成四个节点。这四个节点之间的空白产生了另外三个文本节点。这已经有七个了。`<body>`和第一个`<p>`之间的空白是第八个节点。注释和关闭的`</body>`之间的空白是另一个文本节点。这使得总共有九个子节点。只需在控制台中输入`bd.childNodes`来检查它们。
- en: Attributes
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'As the first child of the body is a whitespace, the second child (index 1)
    is the first paragraph. Refer to the following piece of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`body`的第一个子元素是空白，第二个子元素（索引1）是第一段。参考以下代码：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can check whether an element has attributes using `hasAttributes()`, as
    follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`hasAttributes()`方法检查一个元素是否有属性，如下所示：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'How many attributes? In this example, one is the `class` attribute, which can
    be seen as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少属性？在这个例子中，一个是`class`属性，如下所示：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can access the attributes by index and name. You can also get the value
    using the `getAttribute()` method, which is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过索引和名称访问属性。你还可以使用`getAttribute()`方法获取值，如下所示：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Accessing the content inside a tag
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问标签内的内容
- en: 'Let''s take a look at the first paragraph:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一段：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can get the text contained in the paragraph using the `textContent` property.
    It doesn''t exist in older IEs, but another property called `innerText` returns
    the same value, as seen in the following output:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`textContent`属性获取段落中包含的文本。它不在旧版的IE中存在，但另一个名为`innerText`的属性返回相同的值，如下面的输出所示：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There is also the `innerHTML` property. It''s a relatively new addition to
    the DOM standard, despite the fact that it previously existed in all major browsers.
    It returns (or sets) HTML code contained in a node. You can see how this is a
    little inconsistent as DOM treats the document as a tree of nodes, not as a string
    of tags. However, `innerHTML` is so convenient to use that you''ll see it everywhere.
    Refer to the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`innerHTML`属性。尽管它在所有主流浏览器中之前都存在，但作为DOM标准的相对较新添加项，它返回（或设置）节点中包含的HTML代码。你可以看到这有点不一致，因为DOM将文档视为节点树，而不是标签字符串。然而，`innerHTML`的使用非常方便，所以你会在各个地方看到它。参考以下代码：
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The first paragraph contains only text, so `innerHTML` is the same as `textContent`
    (or `innerText` in IE). However, the second paragraph does contain an `em` node,
    so you can see the difference as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段只包含文本，所以`innerHTML`与`textContent`（或在IE中的`innerText`）相同。然而，第二段确实包含一个`em`节点，所以你可以看到以下差异：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Another way to get the text contained in the first paragraph is by using the
    `nodeValue` method of the text node contained inside the `p` node, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取第一段中包含的文本的方法是使用`p`节点内包含的文本节点的`nodeValue`方法，如下所示：
- en: '[PRE66]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: DOM access shortcuts
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM访问快捷方式
- en: Using `childNodes`, `parentNode`, `nodeName`, `nodeValue`, and `attributes`,
    you can navigate up and down the tree and do anything with the document. However,
    the fact that whitespace is a text node makes this a fragile way of working with
    the DOM. If the page changes, your script may no longer work correctly. Also,
    if you want to get to a node deeper in the tree, it could take a bit of code before
    you get there. That's why you have shortcut methods, namely, `getElementsByTagName()`,
    `getElementsByName()`, and `getElementById()`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`childNodes`、`parentNode`、`nodeName`、`nodeValue`和`attributes`，你可以上下导航树并对文档进行任何操作。然而，空白是一个文本节点的事实使得这种方式与DOM一起工作变得脆弱。如果页面发生变化，你的脚本可能不再正确工作。此外，如果你想到达树中的更深层次的节点，可能需要一些代码才能到达那里。这就是为什么你有快捷方法，即`getElementsByTagName()`、`getElementsByName()`和`getElementById()`。
- en: 'The `getElementsByTagName()` method takes a tag name (the name of an element
    node) and returns an HTML collection (array-like object) of nodes with the matching
    tag name. For example, the following example asks-give me a count of all paragraphs,
    which is given as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElementsByTagName()`方法接受一个标签名（元素节点的名称）并返回一个匹配该标签名的HTML集合（类似数组的对象）。例如，以下示例请求给出所有段落的数量，如下所示：'
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can access an item in the list using the brackets notation, or the `item()`method,
    and passing the index (0 for the first element). Using `item()` is discouraged,
    as array brackets are more consistent and also shorter to type. Refer to the following
    piece of code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用方括号表示法或`item()`方法来访问列表中的项目，并传递索引（第一个元素的索引为0）。不建议使用`item()`，因为数组方括号更一致，也更短。请参考以下代码片段：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Getting the contents of the first `p` can be done as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 获取第一个`p`元素的内容可以按照以下方式完成：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Accessing the last `p` can be done as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 访问最后一个`p`元素可以按照以下方式完成：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To access the attributes of an element, you can use the `attributes` collection
    or `getAttribute()`, as shown previously. However, a shorter way is to use the
    attribute name as a property of the element you''re working with. So, to get the
    value of the `id` attribute, you will just use `id` as a property, which is as
    follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问元素的属性，你可以使用`attributes`集合或`getAttribute()`，如前所述。然而，有一个更短的方法是使用属性名作为你正在处理的元素的属性。因此，要获取`id`属性的值，你只需使用`id`作为属性，如下所示：
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Getting the `class` attribute of the first paragraph won''t work though. It''s
    an exception because it just happens so that class is a reserved word in ECMAScript.
    You can use `className` instead, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 获取第一个段落的`class`属性将不起作用。这是一个例外，因为class恰好是ECMAScript中的一个保留字。你可以使用`className`代替，如下所示：
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Using `getElementsByTagName()`, you can get all of the elements on the page,
    as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getElementsByTagName()`，你可以获取页面上的所有元素，如下所示：
- en: '[PRE73]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In earlier versions of IE before IE7, `*` is not acceptable as a tag name. To
    get all elements, you can use IE's proprietary `document.all` collection, although,
    selecting every element is rarely needed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在IE7之前的早期版本IE中，`*`不是一个有效的标签名。要获取所有元素，可以使用IE的专有`document.all`集合，尽管通常不需要选择每个元素。
- en: 'The other shortcut mentioned is `getElementById()`. This is probably the most
    common way of accessing an element. You just assign IDs to the elements you plan
    to play with and they''ll be easy to access later on, as seen in the following
    code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提到的快捷方法是`getElementById()`。这可能是访问元素最常见的方式。你只需为打算操作的元素分配ID，稍后就可以轻松访问它们，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Additional shortcut methods in more recent browsers include the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的浏览器中，还有以下额外的快捷方法：
- en: '`getElementByClassName()`:This method finds elements using their class attribute'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElementByClassName()`：此方法通过元素的class属性查找元素'
- en: '`querySelector()`: This method finds an element using a CSS selector string'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querySelector()`：此方法使用CSS选择器字符串查找元素'
- en: '`querySelectorAll()`: This method is the same as the previous one but returns
    all matching elements, not just the first'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querySelectorAll()`：此方法与上一个方法相同，但返回所有匹配的元素，而不仅仅是第一个'
- en: Siblings, body, first, and last child
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 兄弟、body、第一个和最后一个子元素
- en: 'The `nextSibling` and `previousSibling` are two other convenient properties
    to navigate the DOM tree once you have a reference to one element. Consider the
    following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextSibling`和`previousSibling`是另外两个方便的属性，一旦你有一个元素的引用，就可以用来导航DOM树。考虑以下代码：'
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `body` element is used so often that it has its own shortcut, which is
    as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`元素使用得非常频繁，因此它有自己的快捷方式，如下所示：'
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `firstChild` and `lastChild` properties are also convenient. The `firstChild`
    property is the same as `childNodes[0]` and `lastChild` is the same as `childNodes[childNodes.length
    - 1]` properties:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstChild`和`lastChild`属性也非常方便。`firstChild`属性等同于`childNodes[0]`，而`lastChild`等同于`childNodes[childNodes.length
    - 1]`属性：'
- en: '[PRE77]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following screenshot shows the family relationships between the body and
    the three paragraphs in it. For simplicity, all the whitespace text nodes are
    removed from the screenshot:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了文档中body元素与其中三个段落之间的家族关系。为了简化，截图已从所有空白文本节点中删除：
- en: '![Siblings, body, first, and last child](img/image_10_008.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![兄弟、body、第一个和最后一个子元素](img/image_10_008.jpg)'
- en: Walk the DOM
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历DOM
- en: 'To wrap up, here''s a function that takes any node and walks through the DOM
    tree recursively, starting from the given node, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是一个函数，它接受任何节点，并递归地遍历DOM树，从给定的节点开始，如下所示：
- en: '[PRE78]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You can test the function as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样测试这个函数：
- en: '[PRE79]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Modifying DOM nodes
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 DOM 节点
- en: 'Now that you know a whole lot of methods to access any node of the DOM tree
    and its properties, let''s see how you can modify these nodes:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了访问 DOM 树中任何节点及其属性的所有方法，让我们看看你如何修改这些节点：
- en: 'Let''s assign a pointer to the last paragraph to the variable `my`, as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将最后一个段落到变量 `my` 中，如下所示：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, changing the text of the paragraph can be as easy as changing the `innerHTML`
    value, which is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更改段落的文本可以像更改 `innerHTML` 值一样简单，如下所示：
- en: '[PRE81]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As `innerHTML` accepts a string of HTML source code, you can also create a
    new `em` node in the DOM tree as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `innerHTML` 接受 HTML 源代码的字符串，你还可以在 DOM 树中创建一个新的 `em` 节点，如下所示：
- en: '[PRE82]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The new `em` node becomes a part of the tree. Lets take a look at the following
    code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `em` 节点成为树的一部分。让我们看看以下代码：
- en: '[PRE83]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Another way to change text is to get the actual text node and change its `nodeValue`,
    as shown in the following piece of code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更改文本的方法是获取实际的文本节点并更改它的 `nodeValue`，如下面的代码片段所示：
- en: '[PRE84]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Modifying styles
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改样式
- en: 'Often you don''t change the content of a node, but its presentation. The elements
    have a `style` property, which in turn has a property mapped to each CSS property.
    For example, changing the style of the paragraph to add a red border, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不会改变节点的内容，而是它的呈现方式。元素有一个 `style` 属性，它将每个 CSS 属性映射到一个属性。例如，将段落的样式更改为添加红色边框，如下所示：
- en: '[PRE85]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'CSS properties often have dashes, but dashes are not acceptable in JavaScript
    identifiers. In such cases, you skip the dash and uppercase the next letter. So,
    `padding-top` becomes `paddingTop`, `margin-left` becomes `marginLeft`, and so
    on. Take a look at the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 属性通常包含破折号，但破折号在 JavaScript 标识符中是不可接受的。在这种情况下，你跳过破折号并将下一个字母转换为大写。所以，`padding-top`
    变成了 `paddingTop`，`margin-left` 变成了 `marginLeft`，依此类推。看看下面的代码：
- en: '[PRE86]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You also have access to the `cssText` property of `style`, which lets you work
    with styles as strings, as you can see in the following code snippet:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以访问 `style` 的 `cssText` 属性，这让你可以像字符串一样处理样式，如下面的代码片段所示：
- en: '[PRE87]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Moreover, modifying styles is a string manipulation:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，修改样式是一种字符串操作：
- en: '[PRE88]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Fun with forms
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与表单的乐趣
- en: 'As mentioned earlier, JavaScript is great for client-side input validation
    and can save a few round-trip to the server. Let''s practice form manipulations
    and play a little bit with a form located on a popular page, [www.google.com](http://www.google.com):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JavaScript 在客户端输入验证方面非常出色，可以节省几次往返服务器的请求。让我们练习表单操作，并在一个流行的页面上稍作玩耍，[www.google.com](http://www.google.com)：
- en: '![Fun with forms](img/image_10_009.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![与表单的乐趣](img/image_10_009.jpg)'
- en: 'Finding the first text input using the `querySelector()` method and a CSS selector
    string is as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `querySelector()` 方法和 CSS 选择器字符串查找第一个文本输入，如下所示：
- en: '[PRE89]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Accessing the search box. Consider the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 访问搜索框。考虑以下代码：
- en: '[PRE90]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Changing the search query by setting the text contained in the `value` attribute
    is done as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置 `value` 属性中包含的文本来更改搜索查询，如下所示：
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, let''s have some fun and change the word **Lucky** with **Tricky** in
    the button:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来点乐趣，将按钮中的单词 **Lucky** 更改为 **Tricky**：
- en: '[PRE92]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '![Fun with forms](img/image_10_010.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![与表单的乐趣](img/image_10_010.jpg)'
- en: 'Now, let''s implement the tricky part and make that button show and hide for
    one second. You can do this with a simple function. Let''s call it `toggle()`.
    Every time you call the function, it checks the value of the CSS property `visibility`,
    and sets it to visible if it''s hidden and vice versa using the following code
    snippet:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来实现这个棘手的部分，让按钮在一秒内显示和隐藏。你可以用一个简单的函数来完成这个任务。让我们称它为 `toggle()`。每次调用这个函数时，它会检查
    CSS 属性 `visibility` 的值，如果它被隐藏，就将其设置为可见，反之亦然，如下面的代码片段所示：
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Instead of calling the function manually, let''s set an interval and call it
    every second:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不手动调用函数，而是设置一个间隔并在每秒调用它：
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The result? The button starts blinking, making it trickier to click. When you''re
    tired of chasing it, just remove the timeout interval by writing the following
    line of code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 结果？按钮开始闪烁，使其更难点击。当你厌倦了追逐它时，只需编写以下代码行来删除超时间隔：
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Creating new nodes
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新节点
- en: To create new nodes, you can use the `createElement()` and `createTextNode()`
    methods. Once you have the new nodes, you can add them to the DOM tree using `appendChild()`,
    `insertBefore()`, or `replaceChild()`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新节点，你可以使用 `createElement()` 和 `createTextNode()` 方法。一旦你有新节点，你可以使用 `appendChild()`、`insertBefore()`
    或 `replaceChild()` 将它们添加到 DOM 树中。
- en: Reload [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)
    and let's play.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载[http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)并让我们来玩。
- en: 'Create a new `p` element and set its `innerHTML`, as shown in the following
    code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`p`元素并设置其`innerHTML`，如下面的代码所示：
- en: '[PRE96]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The new element automatically gets all the default properties, such as `style`,
    which you can modify as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 新元素会自动获得所有默认属性，例如`style`，你可以按照以下方式修改：
- en: '[PRE97]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Using `appendChild()`, you can add the new node to the DOM tree. Calling this
    method on the `document.body` node means creating one more child node right after
    the last child, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`appendChild()`，你可以将新节点添加到DOM树中。在`document.body`节点上调用此方法意味着在最后一个子节点之后创建一个额外的子节点，如下所示：
- en: '[PRE98]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Here''s an illustration of how the page looks like after the new node is appended:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是新节点附加后页面外观的示例：
- en: '![Creating new nodes](img/image_10_011.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![创建新节点](img/image_10_011.jpg)'
- en: DOM-only method
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅DOM方法
- en: 'The `innerHTML` property gets things done a little more quickly than using
    pure DOM. In pure DOM, you will need to perform the following steps:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`innerHTML`属性比使用纯DOM更快地完成任务。在纯DOM中，你需要执行以下步骤：'
- en: Create a new text node containing yet another text.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含更多文本的新文本节点。
- en: Create a new paragraph node.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的段落节点。
- en: Append the text node as a child to the paragraph.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本节点作为子节点附加到段落上。
- en: Append the paragraph as a child to the body.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将段落作为子节点附加到`body`上。
- en: 'This way, you can create any number of text nodes and elements and nest them,
    however you like. Let''s say, you want to add the following HTML to the end of
    the body:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以创建任意数量的文本节点和元素，并以你喜欢的任何方式嵌套它们。比如说，你想要将以下HTML添加到body的末尾：
- en: '[PRE99]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Presenting the preceding code as a hierarchy would be something like the following
    code snippet:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码呈现为层次结构将类似于以下代码片段：
- en: '[PRE100]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The code that accomplishes this is as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的代码如下：
- en: '[PRE101]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Using cloneNode() method
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`cloneNode()`方法
- en: Another way to create nodes is by copying or cloning existing ones. The `cloneNode()`
    method does this and accepts a Boolean parameter (`true` = deep copy with all
    the children, `false` = shallow copy, only this node). Let's test the method.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 创建节点另一种方式是通过复制或克隆现有的节点。`cloneNode()`方法就是这样做的，并接受一个布尔参数（`true` = 深拷贝包含所有子节点，`false`
    = 浅拷贝，只包含此节点）。让我们测试一下这个方法。
- en: 'Getting a reference to the element you want to clone can be done as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 获取你想要克隆的元素的引用可以按照以下方式完成：
- en: '[PRE102]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, `el` refers to the second paragraph on the page that looks like the following
    code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`el`指向页面的第二段，看起来如下所示：
- en: '[PRE103]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let''s create a shallow clone of `el` and append it to the `body` as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`el`的一个浅克隆并将其按照以下方式附加到`body`上：
- en: '[PRE104]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You won''t see a difference on the page because the shallow copy only copied
    the `P` node without any children. This means that the text inside the paragraph,
    which is a text node child, was not cloned. The preceding line will be equivalent
    to the following code line:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你在页面上不会看到任何区别，因为浅拷贝只复制了`P`节点而没有子节点。这意味着段落内的文本，作为一个文本节点子节点，没有被克隆。前面的行将与以下代码行等价：
- en: '[PRE105]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'However, if you create a deep copy, the whole DOM subtree starting from `P`
    is copied, and this includes text nodes and the `EM` element. This line copies
    (visually too) the second paragraph to the end of the document. Consider the following
    line of code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你创建了一个深拷贝，从`P`开始的整个DOM子树都会被复制，这包括文本节点和`EM`元素。这一行将（在视觉上）将第二段复制到文档的末尾。考虑以下代码行：
- en: '[PRE106]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You can also copy only the `EM` if you want, as shown in the following lines
    of code:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以只复制`EM`，如下面的代码行所示：
- en: '[PRE107]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Or, you can copy only the text node with value `second`, as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以只复制值为`second`的文本节点，如下所示：
- en: '[PRE108]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Using insertBefore() method
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`insertBefore()`方法
- en: 'Using `appendChild()`, you can only add new children at the end of the selected
    element. For more control over the exact location, there is `insertBefore()`.
    This is the same as `appendChild()`, but accepts an extra parameter specifying
    where (before which element) to insert the new node. For example, the following
    code inserts a text node at the end of the `body` element:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`appendChild()`，你只能将新子节点添加到所选元素的末尾。为了更精确地控制位置，有`insertBefore()`方法。这与`appendChild()`相同，但接受一个额外的参数，指定插入位置（在哪个元素之前）插入新节点。例如，以下代码在`body`元素的末尾插入一个文本节点：
- en: '[PRE109]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Moreover, this creates another text node and adds it as the first child of
    the `body` element:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这还会创建另一个文本节点并将其作为`body`元素的第一个子节点添加：
- en: '[PRE110]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Removing nodes
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除节点
- en: 'To remove nodes from the DOM tree, you can use the `removeChild()` method.
    Again, let''s start fresh with the same page with the body:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 DOM 树中移除节点，你可以使用 `removeChild()` 方法。再次，让我们从相同的页面和 `body` 开始：
- en: '[PRE111]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Here''s how you can remove the second paragraph:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何移除第二个段落的：
- en: '[PRE112]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The method returns the removed node if you want to use it later. You can still
    use all the DOM methods even though the element is no longer in the tree. Lets
    take a look on the following code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想稍后使用它，该方法会返回被移除的节点。即使元素不再在树中，你仍然可以使用所有 DOM 方法。让我们看看以下代码：
- en: '[PRE113]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: There's also the `replaceChild()`method that removes a node and puts another
    one in its place.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `replaceChild()` 方法，它可以移除一个节点并替换另一个节点。
- en: 'After removing the node, the tree looks as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 移除节点后，树看起来如下所示：
- en: '[PRE114]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now, the second paragraph is the one with the ID `"closer"`, which is as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第二个段落是具有 ID `"closer"` 的段落，如下所示：
- en: '[PRE115]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Let''s replace this paragraph with the one in the `removed` variable. Consider
    the following code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `removed` 变量中的段落替换这个段落。考虑以下代码：
- en: '[PRE116]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Just like `removeChild()`, `replaceChild()` returns a reference to the node
    that is now out of the tree:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `removeChild()` 一样，`replaceChild()` 返回一个引用，该引用现在已不在树中：
- en: '[PRE117]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, the body looks like the following piece of code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，身体看起来像以下这段代码：
- en: '[PRE118]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'A quick way to wipe out all of the content of a subtree is to set `innerHTML`
    to a blank string. This removes all the children of the `body` element:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速清除子树的所有内容，可以将 `innerHTML` 设置为空字符串。这将移除 `body` 元素的所有子元素：
- en: '[PRE119]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Testing is done as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 测试如下进行：
- en: '[PRE120]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Removing with `innerHTML` is fast and easy. The DOM-only way will be to go
    over all of the child nodes and remove each one individually. Here''s a little
    function that removes all nodes from a given start node:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `innerHTML` 移除非常快且简单。仅使用 DOM 的方法将是遍历所有子节点并逐个移除它们。以下是一个从给定起始节点移除所有节点的简单函数：
- en: '[PRE121]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'If you want to delete all the children from the `body` element and leave the
    page with an empty `<body></body>`, use the following code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从 `body` 元素中删除所有子元素，并使页面保留空的 `<body></body>`，请使用以下代码：
- en: '[PRE122]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: HTML - only DOM objects
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 仅有的 DOM 对象
- en: As you already know, the DOM applies to both XML and HTML documents. What you've
    learned earlier about traversing the tree and then adding, removing, or modifying
    nodes, applies to any XML document. There are, however, some HTML-only objects
    and properties.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，DOM 适用于 XML 和 HTML 文档。你之前学到的关于遍历树、添加、删除或修改节点的内容，适用于任何 XML 文档。然而，有一些仅适用于
    HTML 的对象和属性。
- en: The `document.body` is one such HTML-only object. It's so common to have a `<body>`
    tag in HTML documents, and it's accessed so often, that it makes sense to have
    an object that's shorter and friendlier than the equivalent `document.getElementsByTagName('body')[0]`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.body` 是这样一个仅包含 HTML 的对象。在 HTML 文档中，`<body>` 标签非常常见，而且经常被访问，因此有一个比等效的
    `document.getElementsByTagName(''body'')[0]` 更短、更友好的对象是有意义的。'
- en: The `document.body` element is one example of a `legacy` object inherited from
    the prehistoric DOM Level 0 and moved to the HTML extension of the DOM specification.
    There are other objects similar to `document.body` element. For some of them,
    there is no core DOM equivalent, for others, there is an equivalent; however,
    the DOM 0 original was anyway ported for simplicity and legacy purposes. Let's
    see some of those objects.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.body` 元素是继承自史前 DOM Level 0 并移动到 DOM 规范 HTML 扩展的一个 `legacy` 对象的例子。还有其他与
    `document.body` 元素类似的对象。对于其中一些，没有核心 DOM 等价物；对于其他一些，有等价物；然而，DOM 0 原始版本无论如何都被移植以简化并保留历史。'
- en: Primitive ways to access the document
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问文档的原始方法
- en: 'to the elements of an HTML document. This was done mainly through a number
    of collections, which are as follows: Unlike the DOM, which gives you access to
    any element, and even comments and whitespace, initially, JavaScript had only
    limited access to the elements of an HTML document. This was done mainly through
    a number of collections, which are as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 到 HTML 文档的元素。这主要是通过以下一些集合完成的：与 DOM 不同，DOM 可以让你访问任何元素，甚至注释和空白，最初 JavaScript 对
    HTML 文档的元素只有有限的访问权限。这主要是通过以下一些集合完成的：
- en: '`document.images`: This is a collection of all of the images on the page. The
    Core DOM equivalent is `document.getElementsByTagName(''img'')`.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.images`：这是页面上所有图像的集合。其核心 DOM 等价物是 `document.getElementsByTagName(''img'')`。'
- en: '`document.applets`: This is the same as `document.getElementsByTagName(''applet'')`.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.applets`：这与 `document.getElementsByTagName(''applet'')` 相同。'
- en: '`document.links`: The document.links collection contains a list of all `<a
    href="..."></a>` tags on the page, meaning the `<a>` tags that have an `href`
    attribute.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.links`：该`document.links`集合包含页面上的所有`<a href="..."></a>`标签的列表，即具有`href`属性的`<a>`标签。'
- en: '`document.anchors`: The document.anchors collection contains all links with
    a name attribute (`<a name="..."></a>`).'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.anchors`：`document.anchors`集合包含所有具有名称属性（`<a name="..."></a>`）的链接。'
- en: '`document.forms`: One of the most widely used collections is `document.forms`,
    which contains a list of `<form>` elements.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.forms`：最广泛使用的集合之一是`document.forms`，它包含`<form>`元素的列表。'
- en: 'Let''s play with a page that contains a form and an input ([http://www.phpied.com/files/jsoop/ch7-form.html](http://www.phpied.com/files/jsoop/ch7-form.html)).
    The following line of code gives you access to the first form on the page:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一个包含表单和输入字段的页面（[http://www.phpied.com/files/jsoop/ch7-form.html](http://www.phpied.com/files/jsoop/ch7-form.html)）。以下代码行提供了访问页面第一个表单的方法：
- en: '[PRE123]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'It''s the same as the following line of code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下代码行相同：
- en: '[PRE124]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The `document.forms` collection contains collections of input fields and buttons,
    accessible through the `elements` property. Here''s how to access the first input
    of the first form on the page:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.forms`集合包含输入字段和按钮的集合，可通过`elements`属性访问。以下是如何访问页面上的第一个表单的第一个输入字段的方法：'
- en: '[PRE125]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Once you have access to an element, you can access its attributes as object
    properties. The first field of the first form in the test page is as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您访问到某个元素，您就可以将其属性作为对象属性访问。测试页面中第一个表单的第一个字段如下：
- en: '[PRE126]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'You can change the text in the field (the value of the `value` attribute) using
    the following code:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码更改字段中的文本（`value`属性的值）：
- en: '[PRE127]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'If you want to disable the field dynamically, use the following code:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想动态禁用该字段，请使用以下代码：
- en: '[PRE128]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'When forms or `form` elements have a `name` attribute, you can access them
    by name too, as shown in the following code:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单或`form`元素具有`name`属性时，您也可以通过名称访问它们，如下所示：
- en: '[PRE129]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Using document.write() method
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`document.write()`方法
- en: 'The `document.write()` method allows you to insert HTML into the page while
    the page is being loaded. You can have something like the following code:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.write()`方法允许您在页面加载时将HTML插入页面。以下是一个类似代码的示例：'
- en: '[PRE130]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This is the same as if you had the date directly in the source of the HTML
    document, as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您直接在HTML文档的源中拥有日期相同，如下所示：
- en: '[PRE131]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Note that you can only use `document.write()` method while the page is being
    loaded. If you try it after page load, it will replace the content of the whole
    page.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您只能在页面加载时使用`document.write()`方法。如果在页面加载后尝试使用，它将替换整个页面的内容。
- en: It's rare that you would need `document.write()` method, and if you think you
    do, try an alternative approach. The ways to modify the contents of the page provided
    by DOM Level 1 are preferred and are much more flexible.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 很少需要使用`document.write()`方法，如果您认为需要，请尝试其他方法。DOM Level 1提供的修改页面内容的方法更受欢迎，并且更加灵活。
- en: Cookies, title, referrer, and domain
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cookies、标题、引用者和域名
- en: The four additional properties of `document` you'll see in this section are
    also ported from DOM Level 0 to the HTML extension of DOM Level 1\. Unlike the
    previous ones, for these properties, there are no core DOM equivalents.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中您将看到的`document`的四个附加属性也是从DOM Level 0迁移到DOM Level 1的HTML扩展。与之前的属性不同，对于这些属性，没有核心DOM等价物。
- en: 'The `document.cookie` is a property that contains a string. This string is
    the content of the cookies exchanged between the server and the client. When the
    server sends a page to the browser, it may include the `Set-Cookie` HTTP header.
    When the client sends a request to the server, it sends the cookie information
    back with the `Cookie` header. Using `document.cookie`, you can alter the cookies
    the browser sends to the server. For example, visiting `cnn.com` and typing `document.cookie`
    in the console gives you the following output:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.cookie`是一个包含字符串的属性。这个字符串是服务器和客户端之间交换的cookie内容。当服务器向浏览器发送页面时，它可能包括`Set-Cookie`
    HTTP头。当客户端向服务器发送请求时，它通过`Cookie`头将cookie信息发送回服务器。使用`document.cookie`，您可以更改浏览器发送给服务器的cookie。例如，访问`cnn.com`并在控制台中输入`document.cookie`会得到以下输出：'
- en: '[PRE132]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `document.title` property allows you to change the title of the page displayed
    in the browser window. For example, see the following code:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.title`属性允许您更改浏览器窗口中显示的页面标题。例如，查看以下代码：'
- en: '[PRE133]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note that this doesn't change the value of the `<title>` element, but only the
    display in the browser window, so it's not equivalent to `document.querySelector('title')`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不会改变`<title>`元素的价值，但只会改变浏览器窗口中的显示，所以它不等于`document.querySelector('title')`。
- en: 'The `document.referrer` property tells you the URL of the previously visited
    page. This is the same value the browser sends in the `Referer` HTTP header when
    requesting the page. (Note that `Referer` is misspelled in the HTTP headers, but
    is correct in JavaScript''s `document.referrer`). If you''ve visited the CNN page
    by searching on Yahoo first, you can see something like the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.referrer`属性告诉你之前访问的页面的URL。这是浏览器在请求页面时在`Referer` HTTP头中发送的相同值。（注意，`Referer`在HTTP头中拼写错误，但在JavaScript的`document.referrer`中是正确的）。如果你是通过Yahoo搜索访问了CNN页面，你可以看到以下内容：'
- en: '[PRE134]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The `document.domain` property gives you access to the domain name of the currently
    loaded page. This is commonly used when you need to perform so-called domain relaxation.
    Imagine your page is `www.yahoo.com`, and inside it, you have an iframe hosted
    on `music.yahoo.com` subdomain. These are two separate domains, so the browser's
    security restrictions won't allow the page and the iframe to communicate. To resolve
    this, you can set `document.domain` property on both pages to `yahoo.com` and
    they'll be able to talk to each other.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.domain`属性让你可以访问当前加载页面的域名。这通常在需要执行所谓的域名放松时使用。想象你的页面是`www.yahoo.com`，在其中，你有一个在`music.yahoo.com`子域名上托管的内联框架。这些是两个不同的域名，所以浏览器的安全限制不会允许页面和内联框架进行通信。为了解决这个问题，你可以在两个页面上设置`document.domain`属性为`yahoo.com`，这样它们就能互相通信。'
- en: 'Note that you can only set the domain to a less specific one, for example,
    you can change `www.yahoo.com` to `yahoo.com`, but you cannot change `yahoo.com`
    to `www.yahoo.com`, or any other non-yahoo domain. Consider the following code:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你只能将域名设置为更不具体的一个，例如，你可以将`www.yahoo.com`改为`yahoo.com`，但不能将`yahoo.com`改为`www.yahoo.com`，或任何其他非yahoo域名。考虑以下代码：
- en: '[PRE135]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Previously, in this chapter, you saw the `window.location` object. Well, the
    same functionality is also available as `document.location` object:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前，你看到了`window.location`对象。嗯，同样的功能也作为`document.location`对象可用：
- en: '[PRE136]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Events
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'Imagine you are listening to a radio program and they announce, "Big event!
    Huge! Aliens have landed on Earth!" You might think, "Yeah, whatever"; some other
    listeners might think "They come in peace"; and some might think, "We''re all
    gonna die!". Similarly, the browser broadcasts events, and your code can be notified
    should it decide to tune in and listen to the events as they happen. Some example
    events are as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在收听一个广播节目，他们宣布，“重大事件！巨大！外星人已登陆地球！”你可能想，“嗯，随便吧”；一些其他听众可能会想“他们是来和平的”；还有一些人可能会想，“我们都要死了！”同样，浏览器会广播事件，如果你的代码决定调谐并监听这些事件，它会被通知。以下是一些示例事件：
- en: The user clicks a button
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击一个按钮
- en: The user types a character in a form field
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在表单字段中输入一个字符
- en: The page finishes loading
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面加载完成
- en: You can attach a JavaScript function called event listener or event handler
    to a specific event and the browser will invoke your function as soon as the event
    occurs. Let's see how this is done.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个名为事件监听器或事件处理器的JavaScript函数附加到特定事件上，浏览器将在事件发生时立即调用你的函数。让我们看看这是如何完成的。
- en: Inline HTML attributes
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联HTML属性
- en: 'Adding specific attributes to a tag is the laziest but the least maintainable
    way; take the following line of code as an example:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 将特定属性添加到标签中是最懒惰但最不可维护的方法；以下代码行为例：
- en: '[PRE137]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In this case, when the user clicks on `<div>`, the click event fires and the
    string of JavaScript code contained in the `onclick` attribute is executed. There's
    no explicit function that listens to the click event; however, behind the scenes,
    a function is still created, and it contains the code you specified as a value
    of the `onclick` attribute.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当用户点击`<div>`时，点击事件被触发，并且包含在`onclick`属性中的JavaScript代码字符串被执行。没有明确监听点击事件的函数；然而，幕后仍然创建了一个函数，它包含了你指定的`onclick`属性的值。
- en: Element Properties
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素属性
- en: 'Another way to have some code executed when a click event fires is to assign
    a function to the `onclick` property of a DOM node element. For example, take
    a look at the following piece of code:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在点击事件触发时执行一些代码的方法是将函数分配给DOM节点元素的`onclick`属性。例如，看看以下代码片段：
- en: '[PRE138]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This way is better because it helps you keep your `<div>` tag clean of any JavaScript
    code. Always keep in mind that HTML is for content, JavaScript for behavior, and
    CSS for formatting, and you should keep these three separate as much as possible.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式更好，因为它可以帮助你保持`<div>`标签不包含任何JavaScript代码。始终记住，HTML是用于内容的，JavaScript是用于行为的，CSS是用于格式的，你应该尽可能地将这三者分开。
- en: This method has the drawback that you can attach only one function to the event,
    as if the radio program has only one listener. It's true that you can have a lot
    happening inside the same function, but this is not always convenient, as if all
    the radio listeners are in the same room.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是你只能将一个函数附加到事件上，就像广播节目只有一个听众一样。确实，你可以在同一个函数内部做很多事情，但这并不总是方便的，就像所有的广播听众都在同一个房间里一样。
- en: DOM event listeners
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM事件监听器
- en: The best way to work with browser events is to use the event listener approach
    outlined in DOM Level 2, where you can have many functions listening to an event.
    When an event fires, all the functions are executed. All of the listeners don't
    need to know about each other and can work independently. They can tune in and
    out at any time, without affecting the other listeners.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器事件交互的最佳方式是使用DOM Level 2中概述的事件监听器方法，其中可以有多个函数监听一个事件。当事件发生时，所有函数都会执行。所有的监听器不需要相互了解，可以独立工作。它们可以在任何时候加入或退出，而不会影响其他监听器。
- en: 'Let''s use the same simple markup from the previous section, which is available
    for you to play with at [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html).
    It has this piece of markup, which is as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用上一节中相同的简单标记，您可以在[http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)上尝试使用它。它包含以下标记，具体如下：
- en: '[PRE139]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Your JavaScript code can assign listeners to the click event using the `addEventListener()`
    method. Let''s attach two listeners as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`addEventListener()`方法将监听器分配给点击事件。以下是如何附加两个监听器的示例：
- en: '[PRE140]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: As you can see, `addEventListeners`
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`addEventListener`
- en: Capturing and bubbling
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获和冒泡
- en: In the calls to `addEventListener()`, there was a third parameter-`false`. Let's
    see what it is for.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addEventListener()`的调用中，有一个第三个参数`false`。让我们看看它是用来做什么的。
- en: 'Let''s say you have a link inside an unordered list, which is as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个链接在无序列表中，如下所示：
- en: '[PRE141]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'When you click on the link, you''re actually also clicking on the list item,
    `<li>`, the `<ul>` list, the `<body>` tag, and eventually, the document as a whole.
    This is called event propagation. A click on a link can also be seen as a click
    on the document. The process of propagating an event can be implemented in the
    two following ways:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击链接时，你实际上也在点击列表项`<li>`、`<ul>`列表、`<body>`标签，最终是整个文档。这被称为事件传播。点击链接也可以看作是点击文档。事件传播的过程可以通过以下两种方式实现：
- en: '**Event capturing**: This click happens in the document first, then it propagates
    down to the body, the list, the list item, and finally, to the link'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件捕获**：这个点击事件首先发生在文档上，然后传播到body、列表、列表项，最后到链接'
- en: '**Event bubbling**: This click happens on the link and then bubbles up to the
    document'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件冒泡**：这个点击事件发生在链接上，然后冒泡到文档'
- en: 'DOM level 2 events specification suggests that the events propagate in three
    phases, namely, capturing, at target, and bubbling. This means that the event
    propagates from the document to the link (target) and then bubbles back up to
    the document. The event objects have an `eventPhase` property, which reflects
    the current phase:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: DOM Level 2事件规范建议事件在三个阶段传播，即捕获阶段、目标阶段和冒泡阶段。这意味着事件从文档传播到链接（目标），然后冒泡回文档。事件对象有一个`eventPhase`属性，它反映了当前阶段：
- en: '![Capturing and bubbling](img/image_10_012.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![捕获和冒泡](img/image_10_012.jpg)'
- en: Historically, IE and Netscape (working on their own and without a standard to
    follow) implemented the exact opposites. IE implemented only bubbling and Netscape
    only capturing. Today, long after the DOM specification, modern browsers implement
    all three phases.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，IE和Netscape（各自独立工作，没有遵循标准）实现了完全相反的方法。IE只实现了冒泡，而Netscape只实现了捕获。今天，在DOM规范之后很久，现代浏览器实现了所有三个阶段。
- en: 'The practical implications related to the event propagation are as follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件传播相关的实际影响如下：
- en: The third parameter to `addEventListener()` specifies whether or not capturing
    should be used. In order to have your code more portable across browsers, it's
    better to always set this parameter to `false` and use bubbling only.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addEventListener()`的第三个参数指定是否使用捕获。为了使你的代码在浏览器之间更具可移植性，最好始终将此参数设置为`false`并仅使用冒泡。'
- en: You can stop the propagation of the event in your listeners so that it stops
    bubbling up and never reaches the document. To do this, you can call the `stopPropagation()`
    method of the event object; there is an example in the next section.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在你的监听器中停止事件的传播，这样它就不会冒泡并永远不会到达文档。为此，你可以调用事件对象的`stopPropagation()`方法；下一个部分有一个示例。
- en: You can also use event delegation. If you have ten buttons inside `<div>`, you
    can always attach ten event listeners, one for each button. However, a smarter
    thing to do is to attach only one listener to the wrapping `<div>` and once the
    event happens, check which button was the target of the click.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用事件委托。如果你在`<div>`内部有十个按钮，你总是可以为每个按钮附加十个事件监听器。然而，更聪明的事情是只将一个监听器附加到包装的`<div>`上，一旦事件发生，检查哪个按钮是点击的目标。
- en: As a side note, there is a way to use event capturing in old IEs too (using
    `setCapture()` and `releaseCapture()` methods) but only for mouse events. Capturing
    any other events (keystroke events for example) is not supported.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在旧版IE中也有一种使用事件捕获的方法（使用`setCapture()`和`releaseCapture()`方法），但仅限于鼠标事件。捕获任何其他事件（例如按键事件）是不支持的。
- en: Stop propagation
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止传播
- en: 'Let''s see an example of how you can stop the event from bubbling up. Going
    back to the test document, there is this piece of code:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何停止事件冒泡的示例。回到测试文档，这里有这段代码：
- en: '[PRE142]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Let''s define a function that handles clicks on the paragraph, as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个处理段落点击的函数，如下所示：
- en: '[PRE143]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Now, let''s attach this function as a listener to the click event:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此函数作为监听器附加到点击事件：
- en: '[PRE144]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Let''s also attach listeners to the click event on the body, the document,
    and the browser window:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将监听器附加到body、文档和浏览器窗口上的点击事件：
- en: '[PRE145]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note that the DOM specifications don't say anything about events on the window.
    And why would they, as DOM deals with the document and not the browser. So browsers
    implement window events inconsistently.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，DOM规范没有提及窗口上的事件。为什么会有，因为DOM处理的是文档而不是浏览器。因此，浏览器对窗口事件的处理不一致。
- en: 'Now, if you click on the paragraph, you''ll see four alerts saying:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你点击段落，你会看到四个警告说：
- en: clicked paragraph
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击段落
- en: clicked body
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击body
- en: clicked doc
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击文档
- en: clicked window
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击窗口
- en: This illustrates how the same single click event propagates (bubbles up) from
    the target all the way up to the window.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了同一个点击事件是如何从目标向上传播（冒泡）到窗口的。
- en: 'The opposite of `addEventLister()` is `removeEventListener()`, and it accepts
    exactly the same parameters. Let''s remove the listener attached to the paragraph
    by writing the following line of code:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener()`的反义词是`removeEventListener()`，它接受完全相同的参数。让我们通过编写以下代码行来移除附加到段落的监听器：'
- en: '[PRE146]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: If you try now, you'll see alerts only for the click event on the body, document,
    and window, but not on the paragraph.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试，你只会看到body、文档和窗口上的点击事件的警告，而不会在段落上。
- en: 'Now, let''s stop the propagation of the event. The function you add as a listener
    receives the event object as a parameter, and you can call the `stopPropagation()`
    method of that event object as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们停止事件的传播。你添加为监听器的函数接收事件对象作为参数，你可以按照以下方式调用该事件对象的`stopPropagation()`方法：
- en: '[PRE147]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Adding the modified listener is done as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 添加修改后的监听器如下所示：
- en: '[PRE148]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Now, when you click on the paragraph, you will see only one alert because the
    event doesn't bubble up to the body, the document, or the window.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你点击段落时，你将只看到一个警告，因为事件不会冒泡到body、文档或窗口。
- en: 'Note that when you remove a listener, you have to pass a pointer to the same
    function you previously attached. Otherwise, doing the following does not work
    because the second argument is a new function, not the same you passed when adding
    the event listener, even if the body is exactly the same. Consider the following
    code:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你移除监听器时，你必须传递一个指向你之前附加的相同函数的指针。否则，执行以下操作不会起作用，因为第二个参数是一个新函数，而不是添加事件监听器时传递的相同函数，即使主体完全相同。考虑以下代码：
- en: '[PRE149]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Prevent default behavior
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻止默认行为
- en: Some browser events have a predefined behavior. For example, clicking a link
    causes the browser to navigate to another page. You can attach listeners to clicks
    on a link, and you can also disable the default behavior by calling the `preventDefault()`
    method on the event object.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器事件具有预定义的行为。例如，点击链接会导致浏览器导航到另一个页面。你可以为链接的点击事件附加监听器，并且你也可以通过在事件对象上调用`preventDefault()`方法来禁用默认行为。
- en: 'Let''s see how you can annoy your visitors by asking "Are you sure you want
    to follow this link?" every time they click a link? If the user clicks on **Cancel**
    (causing `confirm()` to return `false`), the `preventDefault()` method is called,
    which is shown as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你如何通过每次点击链接时都询问“你确定要跟随这个链接吗？”来烦扰你的访客？如果用户点击**取消**（导致`confirm()`返回`false`），则会调用`preventDefault()`方法，如下所示：
- en: '[PRE150]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that not all events allow you to prevent the default behavior. Most do,
    but if you want to be sure, you can check the `cancellable` property of the event
    object.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有事件都允许你阻止默认行为。大多数都允许，但如果你想确保，你可以检查事件对象的`cancellable`属性。
- en: Cross-browser event listeners
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨浏览器事件监听器
- en: As you already know, most modern browsers almost fully implement the DOM Level
    1 specification. However, the events were not standardized until DOM 2\. As a
    result, there are quite a few differences in how IE, before version 9, implements
    this functionality compared to modern browsers.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，大多数现代浏览器几乎完全实现了DOM Level 1规范。然而，事件直到DOM 2才被标准化。因此，IE在版本9之前与现代浏览器在实现此功能方面存在相当多的差异。
- en: 'Check out an example that causes `nodeName` of a clicked element (the target
    element) to be written to the console:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一个示例，该示例将点击元素（目标元素）的`nodeName`写入控制台：
- en: '[PRE151]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now, let''s take a look at how IE is different:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看IE的不同之处：
- en: In IE, there's no `addEventListener()` method; although, since IE Version 5,
    there is an equivalent `attachEvent()` method. For earlier versions, your only
    choice is accessing the property directly, such as `onclick`.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IE中，没有`addEventListener()`方法；尽管自IE版本5以来，有一个等效的`attachEvent()`方法。对于更早的版本，你唯一的选择是直接访问属性，例如`onclick`。
- en: The `click` event becomes `onclick` when using `attachEvent()`.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`attachEvent()`时，`click`事件变为`onclick`。
- en: If you listen to events the old fashioned way (for example, by setting a function
    value to the `onclick` property), when the callback function is invoked, it doesn't
    get an event object passed as a parameter. However, regardless of how you attach
    the listener in IE, there is always a global object `window.event` that points
    to the latest event.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你以传统方式监听事件（例如，通过将函数值设置为`onclick`属性），当回调函数被调用时，它不会接收到作为参数传递的事件对象。然而，无论你在IE中如何附加监听器，总有一个全局对象`window.event`指向最新的事件。
- en: In IE, the event object doesn't get a target attribute telling you the element
    on which the event fired, but it does have an equivalent property called `srcElement`.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IE中，事件对象没有提供目标属性来告诉你事件是在哪个元素上触发的，但它确实有一个等效的属性称为`srcElement`。
- en: As mentioned earlier, event capturing doesn't apply to all events, so only bubbling
    should be used.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，事件捕获不适用于所有事件，因此应该只使用冒泡。
- en: There's no `stopPropagation()` method, but you can set the IE-only `cancelBubble`
    property to `true`.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有提供`stopPropagation()`方法，但你可以将IE特有的`cancelBubble`属性设置为`true`。
- en: There's no `preventDefault()` method, but you can set the IE-only `returnValue`
    property to `false`.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有提供`preventDefault()`方法，但你可以将IE特有的`returnValue`属性设置为`false`。
- en: To stop listening to an event, instead of `removeEventListener()` in IE, you'll
    need `detachEvent()`.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要停止监听事件，而不是在IE中使用`removeEventListener()`，你需要使用`detachEvent()`。
- en: 'So, here''s the revised version of the previous code that works across browsers:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是之前代码的修订版，它可以在所有浏览器中工作：
- en: '[PRE152]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Types of events
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件类型
- en: 'Now you know how to handle cross-browser events. However, all of the preceding
    examples used only click events. What other events are happening out there? As
    you can probably guess, different browsers provide different events. There is
    a subset of cross-browser events, and some browser-specific ones. For a full list
    of events, you should consult the browser''s documentation, but here''s a selection
    of cross-browser events:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何处理跨浏览器事件。然而，所有前面的例子都只使用了点击事件。还有哪些事件正在发生呢？正如你可能猜到的，不同的浏览器提供了不同的事件。存在一组跨浏览器事件，还有一些特定于浏览器的。要获取事件的完整列表，你应该查阅浏览器的文档，但这里有一些跨浏览器事件的示例：
- en: Mouse events
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: '`mouseup`, `mousedown`, `click` (the sequence is mousedown-up-click), `dblclick`'
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseup`, `mousedown`, `click` (顺序是 mousedown-up-click), `dblclick`'
- en: '`mouseover` (mouse is over an element), `mouseout` (mouse was over an element
    but left it), `mousemove`'
  id: totrans-546
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseover` (鼠标悬停在元素上), `mouseout` (鼠标曾经悬停在元素上但已离开), `mousemove`'
- en: Keyboard events
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘事件
- en: '`keydown`, `keypress`, `keyup` (occur in this sequence)'
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keydown`, `keypress`, `keyup` (按顺序发生)'
- en: Loading/window events
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载/窗口事件
- en: '`load` (an image or a page and all of its components are done loading), `unload`
    (user leaves the page), `beforeunload` (the script can provide the user with an
    option to stop the unload)'
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load` (图像或页面及其所有组件加载完成), `unload` (用户离开页面), `beforeunload` (脚本可以提供给用户一个停止卸载的选项)'
- en: '`abort` (user stops loading the page or an image in IE), `error` (a JavaScript
    error, also when an image cannot be loaded in IE)'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abort` (用户停止加载页面或图像在 IE 中), `error` (JavaScript 错误，当图像在 IE 中无法加载时)'
- en: '`resize` (the browser window is resized), `scroll` (the page is scrolled),
    `contextmenu` (the right-click menu appears)'
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize` (浏览器窗口大小改变), `scroll` (页面滚动), `contextmenu` (右键菜单出现)'
- en: Form events
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单事件
- en: '`focus` (enter a form field), `blur` (leave the form field)'
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus` (进入表单字段), `blur` (离开表单字段)'
- en: '`change` (leave a field after the value has changed), `select` (select text
    in a text field)'
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change` (值改变后离开字段), `select` (在文本字段中选择文本)'
- en: '`reset` (wipe out all user input), `submit` (send the form)'
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset` (清除所有用户输入), `submit` (提交表单)'
- en: Additionally, modern browsers provide drag events (`dragstart`, `dragend`, `drop`,
    and among others) and touch devices provide `touchstart`, `touchmove`, and `touchend`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现代浏览器提供了拖拽事件（`dragstart`, `dragend`, `drop` 等）和触摸设备提供了 `touchstart`, `touchmove`,
    和 `touchend`。
- en: This concludes the discussion of events. Refer to the exercise section at the
    end of this chapter for a little challenge of creating your own event utility
    to handle cross-browser events.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了事件讨论。请参考本章末尾的练习部分，以创建自己的事件实用工具来处理跨浏览器事件。
- en: XMLHttpRequest
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XMLHttpRequest
- en: '`XMLHttpRequest()` is an object (a constructor function) that allows you to
    send HTTP requests from JavaScript. Historically, XHR (`XMLHttpRequest`) was introduced
    in IE and was implemented as an ActiveX object. Starting with IE7, it''s a native
    browser object, the same way as it''s in the other browsers. The common implementation
    of this object across browsers gave birth to the so-called Ajax applications,
    where it''s no longer necessary to refresh the whole page every time you need
    new content. With JavaScript, you can make an HTTP request to the server, get
    the response, and update only a part of the page. This way, you can build much
    more responsive and desktop-like web pages.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest()` 是一个对象（一个构造函数），允许你从 JavaScript 发送 HTTP 请求。历史上，XHR (`XMLHttpRequest`)
    是在 IE 中引入的，并作为 ActiveX 对象实现。从 IE7 开始，它是一个原生浏览器对象，就像在其他浏览器中一样。跨浏览器对此对象的常见实现催生了所谓的
    Ajax 应用程序，其中不再需要在需要新内容时每次都刷新整个页面。使用 JavaScript，你可以向服务器发送 HTTP 请求，获取响应，并仅更新页面的一部分。这样，你可以构建更响应式、更类似桌面应用程序的网页。'
- en: '**Ajax** stands for **Asynchronous JavaScript and XML**:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ajax** 代表 **Asynchronous JavaScript and XML**：'
- en: Asynchronous because, after sending an HTTP request, your code doesn't need
    to wait for the response; however, it can do other stuff and be notified, through
    an event, when the response arrives.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步的，因为发送 HTTP 请求后，你的代码不需要等待响应；然而，它可以执行其他操作，并通过事件在响应到达时得到通知。
- en: JavaScript because it's obvious that XHR objects are created with JavaScript.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 因为很明显 XHR 对象是用 JavaScript 创建的。
- en: XML because initially developers were making HTTP requests for XML documents
    and were using the data contained in them to update the page. This is no longer
    a common practice, though, as you can request data in plain text, in the much
    more convenient JSON format, or simply as HTML ready to be inserted into the page.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 因为最初开发者是向 XML 文档发送 HTTP 请求，并使用其中包含的数据来更新页面。然而，这已经不再是一种常见的做法，因为你可以以纯文本、更方便的
    JSON 格式或简单地作为准备插入页面的 HTML 格式请求数据。
- en: 'There are two steps to using the `XMLHttpRequest` object, which are as follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `XMLHttpRequest` 对象有两个步骤，如下所示：
- en: '**Send the request**: This includes creating an `XMLHttpRequest` object and
    attaching an event listener'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送请求**：这包括创建一个 `XMLHttpRequest` 对象并附加一个事件监听器'
- en: '**Process the response**: This happens when your event listener gets notified
    that the response has arrived, and your code gets busy doing something amazing
    with the response'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理响应**：这发生在你的事件监听器通知你响应已到达时，你的代码开始忙于使用响应做一些令人惊叹的事情'
- en: Sending the request
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送请求
- en: 'In order to create an object, you will simply use the following code (let''s
    deal with browser inconsistencies in just a bit):'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个对象，你将简单地使用以下代码（让我们稍后处理浏览器不一致性）：
- en: '[PRE153]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The next thing is to attach an event listener to the `readystatechange` event
    fired by the object:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要将事件监听器附加到由对象触发的`readystatechange`事件：
- en: '[PRE154]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Then, you will need to call the `open()` method, as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要调用`open()`方法，如下所示：
- en: '[PRE155]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The first parameter specifies the type of HTTP request, such as `GET`, `POST`,
    `HEAD`, and so on. `GET` and `POST` are the most common ones. Use `GET` when you
    don't need to send much data with the request and your request doesn't modify
    (write) data on the server, otherwise, use `POST`. The second parameter is the
    URL you are requesting. In this example, it's the text file `somefile.txt` located
    in the same directory as the page. The last parameter is a Boolean specifying
    whether the request is asynchronous (`true`, always prefer this) or not (`false`,
    blocks all the JavaScript execution and waits until the response arrives).
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定了HTTP请求的类型，例如`GET`、`POST`、`HEAD`等。`GET`和`POST`是最常见的两种。当你不需要在请求中发送大量数据，且你的请求不会修改（写入）服务器上的数据时，使用`GET`；否则，使用`POST`。第二个参数是你请求的URL。在这个例子中，它是位于页面同一目录下的文本文件`somefile.txt`。最后一个参数是一个布尔值，指定请求是否为异步（`true`，始终推荐这样做）或不是（`false`，阻止所有JavaScript执行并等待响应到达）。
- en: 'The last step is to fire off the request, which is done as follows:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是触发请求，如下所示：
- en: '[PRE156]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The `send()` method accepts any data you want to send with the request. For
    `GET` requests, this is an empty string because the data is in the URL. For `POST`
    request, it's a query string in the `key=value&key2=value2` form.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`方法接受你想要与请求一起发送的任何数据。对于`GET`请求，这是一个空字符串，因为数据在URL中。对于`POST`请求，它是一个`key=value&key2=value2`形式的查询字符串。'
- en: At this point, the request is sent and your code and the user can move on to
    other tasks. The callback function, `myCallback`, will be invoked when the response
    comes back from the server.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，请求已发送，你的代码和用户可以继续进行其他任务。当从服务器返回响应时，回调函数`myCallback`将被调用。
- en: Processing the response
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理响应
- en: A listener is attached to the `readystatechange` event. So, what exactly is
    the ready state and how does it change?
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 一个监听器被附加到`readystatechange`事件。那么，究竟什么是就绪状态，它是如何变化的？
- en: 'There is a property of the XHR object called `readyState`. Every time it changes,
    the `readystatechange` event fires. The possible values of the `readyState` property
    are as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: XHR对象有一个名为`readyState`的属性。每次它改变时，`readystatechange`事件都会触发。`readyState`属性的可能的值如下：
- en: 0-uninitialized
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-未初始化
- en: 1-loading
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-加载中
- en: 2-loaded
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2-加载中
- en: 3-interactive
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3-交互
- en: 4-complete
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4-完成
- en: When `readyState` gets the value of `4`, it means the response is back and ready
    to be processed. In `myCallback`, after you make sure `readyState` is `4`, the
    other thing to check is the status code of the HTTP request. You might have requested
    a non-existing URL, for example, and got a `404` (File not found) status code.
    The interesting code is the `200` (`OK`) code, so `myCallback` should check for
    this value. The status code is available in the `status` property of the XHR object.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 当`readyState`的值为`4`时，意味着响应已返回并准备好被处理。在`myCallback`中，确保`readyState`为`4`之后，还需要检查的是HTTP请求的状态码。你可能请求了一个不存在的URL，例如，并得到了`404`（文件未找到）状态码。有趣的状态码是`200`（OK），所以`myCallback`应该检查这个值。状态码在XHR对象的`status`属性中可用。
- en: 'Once `xhr.readyState` is `4` and `xhr.status` is `200`, you can access the
    contents of the requested URL using the `xhr.responseText` property. Let''s see
    how `myCallback` can be implemented to simply `alert()` the contents of the requested
    URL:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`xhr.readyState`为`4`且`xhr.status`为`200`，你可以使用`xhr.responseText`属性访问请求的URL的内容。让我们看看如何实现`myCallback`来简单地`alert()`请求URL的内容：
- en: '[PRE157]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Once you've received the new content you requested, you can add it to the page,
    use it for some calculations, or for any other purpose you find suitable.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你收到了请求的新内容，你可以将其添加到页面中，用于某些计算，或者用于你找到的任何其他合适的目的。
- en: Overall, this two-step process (send request and process response) is the core
    of the whole XHR/Ajax functionality. Now that you know the basics, you can move
    on to building the next Gmail. Oh yes, let's take a look at some minor browser
    inconsistencies.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这个两步过程（发送请求和处理响应）是整个XHR/Ajax功能的核心。现在你已经了解了基础知识，你可以继续构建下一个Gmail。哦，是的，让我们看看一些浏览器的不一致性。
- en: Creating XMLHttpRequest objects in IE prior to Version 7
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在版本7之前的IE中创建XMLHttpRequest对象
- en: 'In Internet Explorer, prior to version 7, the `XMLHttpRequest` object was an
    ActiveX object, so creating an XHR instance is a little different. It goes as
    follows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在Internet Explorer中，版本7之前，`XMLHttpRequest`对象是一个ActiveX对象，所以创建XHR实例略有不同。它如下所示：
- en: '[PRE158]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '`MSXML2.XMLHTTP.3.0` is the identifier of the object you want to create. There
    are several versions of the `XMLHttpRequest` object, and if your page visitor
    doesn''t have the latest one installed, you can try two older ones before you
    give up.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSXML2.XMLHTTP.3.0`是你想要创建的对象的标识符。`XMLHttpRequest`对象有几个版本，如果你的页面访问者没有安装最新版本，你可以在放弃之前尝试两个较旧的版本。'
- en: 'For a fully-cross-browser solution, you should first test to see if the user''s
    browser supports `XMLHttpRequest` as a native object, and if not, try the IE way.
    Therefore, the whole process of creating an XHR instance could be like the following:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个完全跨浏览器的解决方案，你应该首先测试用户的浏览器是否支持`XMLHttpRequest`作为原生对象，如果不支持，则尝试IE的方式。因此，创建XHR实例的整个过程可能如下所示：
- en: '[PRE159]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: What is this doing? The `ids` array contains a list of ActiveX program IDs to
    try. The `xhr` variable points to the new XHR object. The code first checks to
    see if `XMLHttpRequest` exists. If so, this means that the browser supports `XMLHttpRequest()`
    natively, so the browser is relatively modern. If it is not, the code loops through
    ids trying to create an object. The `catch(e)` block quietly ignores failures
    and the loop continues. As soon as an `xhr` object is created, you break out of
    the loop.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在做什么？`ids`数组包含要尝试的ActiveX程序ID列表。`xhr`变量指向新的XHR对象。代码首先检查`XMLHttpRequest`是否存在。如果存在，这意味着浏览器原生支持`XMLHttpRequest()`，所以浏览器相对较新。如果不存在，代码会遍历`ids`尝试创建对象。`catch(e)`块会静默地忽略失败并继续循环。一旦创建了一个`xhr`对象，你就会退出循环。
- en: As you can see, this is quite a bit of code, so it's best to abstract it into
    a function. Actually, one of the exercises at the end of the chapter prompts you
    to create your own Ajax utility.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一段相当多的代码，所以最好将其抽象成一个函数。实际上，章节末尾的一个练习要求你创建自己的Ajax实用工具。
- en: A is for Asynchronous
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A代表异步
- en: Now you know how to create an XHR object, give it a URL and handle the response
    to the request. What happens when you send two requests asynchronously? What if
    the response to the second request comes before the first?
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建XHR对象，给它一个URL并处理请求的响应。当你异步发送两个请求时会发生什么？如果第二个请求的响应先于第一个到达怎么办？
- en: 'In the preceding example, the XHR object was global and `myCallback` was relying
    on the presence of this global object in order to access its `readyState`, `status`,
    and `responseText` properties. Another way, which prevents you from relying on
    global variables, is to wrap the callback in a closure. Let''s see how:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，XHR对象是全局的，`myCallback`依赖于这个全局对象的存在来访问其`readyState`、`status`和`responseText`属性。另一种方法，可以防止你依赖于全局变量，就是将回调包装在闭包中。让我们看看如何做：
- en: '[PRE160]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In this case, `myCallback()` receives the XHR object as a parameter and will
    not go looking for it in the global space. This also means that at the time the
    response is received, the original `xhr` might be reused for a second request.
    The closure keeps pointing to the original object.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`myCallback()`接收XHR对象作为参数，并且不会在全局空间中寻找它。这也意味着在收到响应时，原始的`xhr`可能会被用于第二个请求。闭包始终指向原始对象。
- en: X is for XML
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X代表XML
- en: Although these days JSON (discussed in the next chapter) is preferred over XML
    as a data transfer format, XML is still an option. In addition to the `responseText`
    property, the XHR objects also have another property called `responseXML`. When
    you send an HTTP request for an XML document, `responseXML` points to an XML DOM
    document object. To work with this document, you can use all of the core DOM methods
    discussed previously in this chapter, such as `getElementsByTagName()`, `getElementById()`,
    and so on.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在 JSON（将在下一章中讨论）作为数据传输格式比 XML 更受欢迎，但 XML 仍然是一个选项。除了 `responseText` 属性外，XHR
    对象还有一个名为 `responseXML` 的属性。当您发送一个针对 XML 文档的 HTTP 请求时，`responseXML` 指向一个 XML DOM
    文档对象。要处理此文档，您可以使用本章前面讨论的所有核心 DOM 方法，例如 `getElementsByTagName()`、`getElementById()`
    等。
- en: An example
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以下是一个示例
- en: Let's wrap up the different XHR topics with an example. You can visit the page
    located at [http://www.phpied.com/files/jsoop/xhr.html](http://www.phpied.com/files/jsoop/xhr.html)
    to work on the example yourself.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个示例来总结不同的 XHR 主题。您可以访问位于 [http://www.phpied.com/files/jsoop/xhr.html](http://www.phpied.com/files/jsoop/xhr.html)
    的页面，亲自尝试这个示例。
- en: 'The main page, `xhr.html`, is a simple static page that contains nothing but
    three `<div>` tags, which are as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 主页面 `xhr.html` 是一个简单的静态页面，它只包含三个 `<div>` 标签，如下所示：
- en: '[PRE161]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Using the console, you can write code that requests three files and loads their
    respective contents into each `<div>`.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台，您可以编写代码请求三个文件，并将它们各自的内容加载到每个 `<div>` 中。
- en: 'The three files to load are as follows:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 需要加载的三个文件如下：
- en: '`content.txt`: This is a simple text file containing the text `I am a text
    file`'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content.txt`：这是一个包含文本 `I am a text file` 的简单文本文件'
- en: '`content.html`: This is a file containing HTML code `I am <strong>formatted</strong>
    <em>HTML</em>`'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content.html`：这是一个包含 HTML 代码 `I am <strong>formatted</strong> <em>HTML</em>`
    的文件'
- en: '`content.xml`: This is an XML file containing the following code:'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content.xml`：这是一个包含以下代码的 XML 文件：'
- en: '[PRE162]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: All of the files are stored in the same directory as `xhr.html`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文件都存储在 `xhr.html` 所在的同一目录中。
- en: Note
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For security reasons, you can only use the original `XMLHttpRequest` to request
    files that are on the same domain. However, modern browsers support XHR2, which
    lets you make cross-domain requests, provided that the appropriate Access-Control-Allow-Origin
    HTTP header is in place.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，您只能使用原始的 `XMLHttpRequest` 来请求同一域上的文件。然而，现代浏览器支持 XHR2，这使得您可以在适当设置 `Access-Control-Allow-Origin`
    HTTP 头的情况下进行跨域请求。
- en: 'First, let''s create a function to abstract the request/response part:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个函数来抽象请求/响应部分：
- en: '[PRE163]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'This function accepts a URL to request and a callback function to call once
    the response arrives. Let''s call the function three times, once for each file,
    as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个请求的 URL 和一个回调函数，一旦响应到达就调用该函数。让我们将此函数调用三次，每次为一个文件，如下所示：
- en: '[PRE164]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The callback functions are defined inline. The first two are identical. They
    just replace the HTML of the corresponding `<div>` with the contents of the requested
    file. The third one is a little different as it deals with the XML document. First,
    you will access the XML DOM object as `o.responseXML`. Then, using `getElementsByTagName()`,
    you will get a list of all the `<root>` tags (there is only one). The `firstChild`
    of `<root>` is a text node and `nodeValue` is the text contained in it (`I''m
    XML data)`. Then, just replace the HTML of `<div id="xml">` with the new content.
    The result is shown in the following screenshot:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数是直接定义的。前两个是相同的。它们只是用请求文件的相应内容替换对应的 `<div>` 的 HTML。第三个稍微不同，因为它处理 XML 文档。首先，您将作为
    `o.responseXML` 访问 XML DOM 对象。然后，使用 `getElementsByTagName()`，您将获取所有 `<root>` 标签的列表（只有一个）。`<root>`
    的 `firstChild` 是一个文本节点，`nodeValue` 是其中包含的文本（`I'm XML data`）。然后，只需将 `<div id="xml">`
    的 HTML 替换为新的内容。结果如下面的截图所示：
- en: '![An example](img/image_10_013.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/image_10_013.jpg)'
- en: When working with the XML document, you can also use `o.responseXML.documentElement`
    to get to the `<root>` element instead of `o.responseXML.getElementsByTagName('root')[0]`.
    Remember that `documentElement` gives you the root node of an XML document. The
    root in HTML documents is always the `<html>` tag.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 XML 文档时，您也可以使用 `o.responseXML.documentElement` 来获取 `<root>` 元素，而不是使用 `o.responseXML.getElementsByTagName('root')[0]`。请记住，`documentElement`
    给您 XML 文档的根节点。HTML 文档中的根始终是 `<html>` 标签。
- en: Exercises
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In the previous chapters, the solutions to the exercises could be found in the
    text of the chapter. This time, some of the exercises require you to do some more
    reading, or experimentation, outside this book.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，练习题的答案可以在章节文本中找到。这次，一些练习需要你在本书之外进行更多阅读或实验。
- en: 'BOM: As a BOM exercise, try coding something wrong, obtrusive, user-unfriendly,
    and all in all, very Web 1.0, the shaking browser window. Try implementing code
    that opens a 200 x 200 pop up window and then resizes it slowly and gradually
    to 400 x 400\. Next, move the window around as if there''s an earthquake. All
    you''ll need is one of the move`*()` functions, one or more calls to `setInterval()`,
    and maybe one to `setTimeout()`/`clearInterval()` to stop the whole thing. Or,
    here''s an easier one-print the current date/time in `document.title` and update
    it every second, like a clock.'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BOM：作为一个 BOM 练习，尝试编写一些错误、侵入性、用户不友好的代码，总体来说，非常 Web 1.0，摇动的浏览器窗口。尝试实现代码，打开一个 200
    x 200 的弹出窗口，然后缓慢逐渐地将其调整为 400 x 400。然后，像有地震一样移动窗口。你只需要一个 `move*()` 函数，一个或多个 `setInterval()`
    调用，可能还需要一个 `setTimeout()`/`clearInterval()` 来停止整个过程。或者，这里有一个更简单的：在 `document.title`
    中打印当前日期/时间，并每秒更新一次，就像一个时钟。
- en: 'DOM:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DOM：
- en: Implement `walkDOM()` differently. Also, make it accept a callback function
    instead of hard coding `console.log()`.
  id: totrans-632
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的实现 `walkDOM()`。同时，使其接受一个回调函数而不是硬编码 `console.log()`。
- en: Removing content with `innerHTML` is easy (`document.body.innerHTML = ''`),
    but not always best. The problem will be when there are event listeners attached
    to the removed elements; they won't be removed in IE, causing the browser to leak
    memory because it stores references to something that doesn't exist. Implement
    a general-purpose function that deletes DOM nodes, but removes any event listeners
    first. You can loop through the attributes of a node and check if the value is
    a function. If it is, it's most likely an attribute like `onclick`. You need to
    set it to `null` before removing the element from the tree.
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `innerHTML` 移除内容很容易（`document.body.innerHTML = ''`），但并不总是最佳选择。问题在于当有事件监听器附加到被移除的元素时；在
    IE 中，它们不会被移除，导致浏览器泄漏内存，因为它存储了对不存在的对象的引用。实现一个通用函数，用于删除 DOM 节点，但首先删除任何事件监听器。你可以遍历一个节点的属性，并检查其值是否为函数。如果是，它很可能是像
    `onclick` 这样的属性。在从树中删除元素之前，需要将其设置为 `null`。
- en: 'Create a function called `include()` that includes external scripts on demand.
    This means you need to create a new `<script>` tag dynamically, set its `src`
    attribute, and append to the document''s `<head>`. Test it by using the following
    code:'
  id: totrans-634
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `include()` 的函数，按需包含外部脚本。这意味着你需要动态创建一个新的 `<script>` 标签，设置其 `src` 属性，并将其附加到文档的
    `<head>` 中。通过以下代码进行测试：
- en: '[PRE165]'
  id: totrans-635
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Events:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件：
- en: 'Create an event utility (object) called `myevent`, which has the following
    methods working cross-browser:'
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `myevent` 的事件工具（对象），它具有以下跨浏览器的方法：
- en: The `addListener``(element`, `event_name`, `callback)`, where `element` can
    also be an array of elements
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addListener(element, event_name, callback)`，其中 `element` 也可以是一个元素数组'
- en: '`removeListener``(element`, `event_name`, `callback)`'
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeListener(element, event_name, callback)`'
- en: '`getEvent(event)` just to check for a `window.event` for older versions of
    IE'
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEvent(event)` 仅用于检查旧版 IE 的 `window.event`'
- en: getTarget(event)
  id: totrans-641
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: getTarget(event)
- en: stopPropagation(event)
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: stopPropagation(event)
- en: preventDefault(event)
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preventDefault(event)`'
- en: 'Usage example is as follows:'
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例如下：
- en: '[PRE166]'
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The result of the example code should be that all of the links in the document
    lead nowhere, but only alert the `href` attribute.
  id: totrans-646
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码的结果应该是文档中的所有链接都无处可去，但只弹出一个 `href` 属性。
- en: Create an absolutely positioned `<div>`, say at `x = 100px`, `y = 100px`. Write
    the code to be able to move div around the page using the arrow keys or the *J*
    (left), *K* (right), *M* (down), and *I* (up) keys. Reuse your own event utility
    from 3.1.
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个绝对定位的 `<div>`，比如在 `x = 100px`，`y = 100px`。编写代码，使用箭头键或 *J*（左）、*K*（右）、*M*（下）和
    *I*（上）键在页面上移动 div。重用 3.1 中的自己的事件工具。
- en: 'XMLHttpRequest:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XMLHttpRequest：
- en: 'Create your own XHR utility (object) called `ajax`. For example, take a look
    at the following code:'
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的 XHR 工具（对象）名为 `ajax`。例如，看看以下代码：
- en: '[PRE167]'
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Summary
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'You learned quite a bit in this chapter. You learned the following cross-browser
    BOM objects:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中学到了很多。你学习了以下跨浏览器的 BOM 对象：
- en: Properties of the global `window` object, such as `navigator`, `location`, `history`,
    `frames`, `screen`
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局 `window` 对象的属性，如 `navigator`、`location`、`history`、`frames`、`screen`
- en: Methods such as `setInterval()` and `setTimeout()`; `alert()`, `confirm()` and
    `prompt()`; `moveTo/By()` and `resizeTo/By()`
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setInterval()`和`setTimeout()`方法；`alert()`、`confirm()`和`prompt()`；`moveTo/By()`和`resizeTo/By()`'
- en: 'Then, you learned about the DOM, an API to represent an HTML or XML document
    as a tree structure, where each tag or text is a node on the tree. You also learned
    how to perform the following actions:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了DOM，这是一个API，可以将HTML或XML文档表示为树结构，其中每个标签或文本都是树上的一个节点。你还学习了如何执行以下操作：
- en: 'Accessing nodes:'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问节点：
- en: Using parent/child relationship properties, such as `parentNode`, `childNodes`,
    `firstChild`, `lastChild`, `nextSibling`, and `previousSibling`
  id: totrans-657
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用父/子关系属性，如`parentNode`、`childNodes`、`firstChild`、`lastChild`、`nextSibling`和`previousSibling`
- en: Using `getElementsById()`, `getElementsByTagName()`, `getElementsByName()`,
    and `querySelectorAll()`
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getElementsById()`、`getElementsByTagName()`、`getElementsByName()`和`querySelectorAll()`
- en: 'Modifying nodes:'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改节点：
- en: Using `innerHTML` or `innerText/textContent`
  id: totrans-660
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`innerHTML`或`innerText/textContent`
- en: Using `nodeValue` or `setAttribute()`, or just using attributes as object properties
  id: totrans-661
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nodeValue`或`setAttribute()`，或者直接使用属性作为对象属性
- en: Removing nodes with `removeChild()` or `replaceChild()`
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`removeChild()`或`replaceChild()`移除节点
- en: Adding new ones with `appendChild()`, `cloneNode()`, and `insertBefore()`
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`appendChild()`、`cloneNode()`和`insertBefore()`添加新节点
- en: 'You also learned the following DOM 0 (pre-standardization) properties, ported
    to DOM Level 1:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了以下DOM 0（标准化前）属性，已移植到DOM Level 1：
- en: Collections, such as `document.forms`, `images`, `links`, `anchors`, `applets`.
    Using these are discouraged as DOM1 has the much more flexible `getElementsByTagName()`
    method.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合，如`document.forms`、`images`、`links`、`anchors`、`applets`。使用这些是不推荐的，因为DOM1有更灵活的`getElementsByTagName()`方法。
- en: The `document.body` element, which gives you convenient access to `<body>`.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.body`元素，它为你提供了方便访问`<body>`的方式。'
- en: The `document.title`, `cookie`, `referrer`, and `domain`.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.title`、`cookie`、`referrer`和`domain`。'
- en: Next, you learned how the browser broadcasts events that you can listen to.
    It's not straightforward to do this in a cross-browser manner, but it's possible.
    Events bubble up, so you can use event delegation to listen to events more globally.
    You can also stop the propagation of events and interfere with the default browser
    behavior.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了浏览器如何广播你可以监听的事件。在跨浏览器环境中这样做并不简单，但这是可能的。事件会冒泡，因此你可以使用事件委托来更全局地监听事件。你还可以阻止事件的传播并干扰默认的浏览器行为。
- en: 'Finally, you learned about the `XMLHttpRequest` object that allows you to build
    responsive web pages that do the following tasks:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了`XMLHttpRequest`对象，它允许你构建响应式网页，执行以下任务：
- en: Make HTTP requests to the server to get pieces of data
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向服务器发送HTTP请求以获取数据片段
- en: Process the response to update portions of the page
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理响应以更新页面部分
