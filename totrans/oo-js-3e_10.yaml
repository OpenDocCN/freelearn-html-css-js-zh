- en: Chapter 10. The Browser Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You know that JavaScript programs need a host environment. Most of what you
    learned so far in this book was related to core ECMAScript/JavaScript and can
    be used in many different host environments. Now, let''s shift the focus to the
    browser as this is the most popular and natural host environment for JavaScript
    programs. In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Browser Object Model** (**BOM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Document Object Model** (**DOM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `XMLHttpRequest` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including JavaScript in an HTML page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To include JavaScript in an HTML page, you will need to use the `<script>`
    tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the first `<script>` tag includes an external file, `somefile.js`,
    which contains JavaScript code. The second `<script>` tag includes the JavaScript
    code directly in the HTML code of the page. The browser executes the JavaScript
    code in the sequence it finds it on the page and all the code in all tags share
    the same global namespace. This means that when you define a variable in `somefile.js`,
    it also exists in the second `<script>` block.
  prefs: []
  type: TYPE_NORMAL
- en: BOM and DOM - an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JavaScript code in a page has access to a number of objects. These objects
    can be divided into the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core ECMAScript objects**: This consists of all the objects mentioned in
    the previous chapters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOM**: This consists of objects that have to do with the currently loaded
    page, which is also called the document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BOM**: This consists of objects that deal with everything outside the page-the
    browser window and the desktop screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM stands for Document Object Model and BOM for Browser Object Model.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM is a standard governed by the **World Wide Web Consortium** (**W3C**)
    and has different versions, called levels, such as DOM Level 1, DOM Level 2, and
    so on. Browsers in use today have different degrees of compliance with the standard,
    but in general, they almost all completely implement DOM Level 1\. The DOM was
    standardized post factum after the browser vendors had each implemented their
    own ways to access the document. The legacy part from before the W3C took over
    is still around and is referred to as DOM 0, although, no real DOM Level 0 standard
    exists. Some parts of DOM 0 have become de facto standards as all major browsers
    support them; some of these were added to the DOM Level 1 standard. The rest of
    DOM 0 that didn't find its way to DOM 1 is too browser specific and won't be discussed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, BOM was not a part of any standard. Similar to DOM 0, it has a
    subset of objects that is supported by all major browsers, and another subset
    that is browser-specific. The HTML5 standard codifies common behavior among browsers,
    and it includes common BOM objects. Additionally, mobile devices come with their
    specific objects (and HTML5 aims to standardize those as well), which traditionally
    were not necessary for desktop computers, but make sense in a mobile world, for
    example, geolocation, camera access, vibration, touch events, telephony, and SMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter discusses only cross-browser subsets of BOM and DOM Level 1, unless
    noted otherwise in the text. Even these safe subsets constitute a large topic,
    and a full reference is beyond the scope of this book. You can also consult the
    following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla DOM reference ([http://developer.mozilla.org/en/docs/Gecko_DOM_Reference](http://developer.mozilla.org/en/docs/Gecko_DOM_Reference))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mozilla's HTML5 wiki ([https://developer.mozilla.org/en-US/docs/HTML/HTML5](https://developer.mozilla.org/en-US/docs/HTML/HTML5))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft's documentation for Internet Explorer ([http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx](http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W3C's DOM specifications ([http://www.w3.org/DOM/DOMTR](http://www.w3.org/DOM/DOMTR))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BOM is a collection of objects that give you access to the browser and the
    computer screen. These objects are accessible through the global object `window`.
  prefs: []
  type: TYPE_NORMAL
- en: The window object revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you already know, in JavaScript, there''s a global object provided by the
    host environment. In the browser environment, this global object is accessible
    using `window`. All global variables are also accessible as properties of the
    `window` object. For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, all the core JavaScript functions, discussed in [Chapter 2](ch02.html
    "Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions"), *Primitive
    Data Types, Arrays, Loops, and Conditions*, are methods of the global object.
    Consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In addition to being a reference to the global object, the `window` object also
    serves a second purpose-providing information about the browser environment. There's
    a `window` object for every frame, iframe, pop up, or browser tab.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some of the browser-related properties of the `window` object. Again,
    these can vary from one browser to another, so let's only consider the properties
    that are implemented consistently and reliably across all major browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Using window.navigator property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `navigator` is an object that has some information about the browser and
    its capabilities. One property is `navigator.userAgent`, which is a long string
    of browser identification. In Firefox, you''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `userAgent` string in Microsoft Internet Explorer is something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As the browsers have different capabilities, developers are using the `userAgent`
    string to identify the browser and provide different versions of the code. For
    example, the following code snippet searches for the presence of the `MSIE` string
    to identify Internet Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s better not to rely on the `userAgent` string, but to use feature sniffing
    (also called capability detection) instead. The reason for this is that it''s
    hard to keep track of all browsers and their different versions. It''s much easier
    to simply check if the feature you intend to use is indeed available in the user''s
    browser. For example, take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another reason to avoid `userAgent` sniffing is that some browsers allow users
    to modify the string and pretend they are using a different browser.
  prefs: []
  type: TYPE_NORMAL
- en: Your console is a cheat sheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The console lets you inspect what''s in an object and this includes all the
    BOM and DOM properties. Just type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then click on the result. The result is a list of properties and their values,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your console is a cheat sheet](img/image_10_001-e1482822786978.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using window.location property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `location` property points to an object that contains information about
    the URL of the currently loaded page. For example, `location.href` is the full
    URL and `location.hostname` is only the domain. With a simple loop, you can see
    the full list of properties of the `location` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you''re on a page with the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://search.phpied.com:8080/search?q=java&what=script#results](http://search.phpied.com:8080/search?q=java&what=script#results).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are also three methods that `location` property provides, namely `reload()`,
    `assign()`, and `replace()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s interesting how many different ways exist for you to navigate to another
    page. The following are a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `replace()` method is almost the same as `assign()`. The difference is
    that it doesn''t create an entry in the browser''s history list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To reload a page, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `location.href` to point it to itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, simply use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using window.history property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `window.history` property allows limited access to the previously visited
    pages in the same browser session. For example, you can see how many pages the
    user has visited before coming to your page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot see the actual URLs though. For privacy reasons, this doesn''t work.
    See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, however, navigate back and forth through the user''s session as if
    the user had clicked on the back/forward browser buttons, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also skip pages back and forth with `history.go()`. This is the same
    as calling `history.back()`. The code for `history.go()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To go two pages back, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the current page using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'More recent browsers also support HTML5 history API, which lets you change
    the URL without reloading the page. This is perfect for dynamic pages because
    they can allow users to bookmark a specific URL, which represents the state of
    the application, and when they come back, or share with their friends, the page
    can restore the application state based on the URL. To get a sense of the history
    API, go to any page and write the following lines of code in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the URL changes, but the page is the same. Now, experiment with back
    and forward buttons in the browser and inspect the `history.state` object again.
  prefs: []
  type: TYPE_NORMAL
- en: using window.frames property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `window.frames` property is a collection of all of the frames in the current
    page. It doesn''t distinguish between frames and iframes (inline frames). Regardless
    of whether there are frames on the page or not, `window.frames` always exists
    and points to `window`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider an example where you have a page with one iframe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to tell if there are any frames on the page, you can check the `length`
    property. In case of one iframe, you''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each frame contains another page, which has its own global `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get access to the iframe''s `window`, you can execute any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'From the parent page, you can access properties of the child frame as well.
    For example, you can reload the frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'From inside the child, you can access the parent as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a property called `top`, you can access the top-most page-the one that
    contains all the other frames-from within any frame, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, `self` is the same as `window`, as you can see in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If a frame has a `name` attribute, you cannot only access the frame by name,
    but also by index, as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternatively, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using window.screen property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `screen` property provides information about the environment outside the
    browser. For example, the `screen.colorDepth` property contains the color bit
    depth (the color quality) of the monitor. This is mostly used for statistical
    purposes. Take a look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check the available screen real estate (the resolution), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The difference between `height` and `availHeight` is that `height` is the whole
    screen, while `availHeight` subtracts any operating system menus, such as the
    Windows task bar. The same is the case for `width` and `availWidth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhat related is the property mentioned in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It tells you the difference (ratio) between physical pixels and device pixels
    in the retina displays in mobile devices, for example, value 2 in iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: window.open()/close() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having explored some of the most common cross-browser properties of the `window`
    object, let's move to some of the methods. One such method is `open()`, which
    allows you to open new browser windows (pop ups). Various browser policies and
    user settings may prevent you from opening a pop up (due to abuse of the technique
    for marketing purposes), but generally, you should be able to open a new window
    if it was initiated by the user. Otherwise, if you try to open a pop up as the
    page loads, it will most likely be blocked, because the user didn't initiate it
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `window.open()` method accepts the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: URL to load in the new window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name of the new window that can be used as the value of a form's `target` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comma-separated list of features, which is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resizable`: Should the user be able to resize the new window'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`, `height`: Width and height of the pop up'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: Should the status bar be visible'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `window.open()` method returns a reference to the `window` object of the
    newly created browser instance. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `win` variable points to the `window` object of the pop up. You can check
    if `win` has a falsy value, which means that the pop up was blocked.
  prefs: []
  type: TYPE_NORMAL
- en: The `win.close()` method closes the new window.
  prefs: []
  type: TYPE_NORMAL
- en: It's best to stay away from opening new windows for accessibility and usability
    reasons. If you don't like sites popping up windows to you, why do it to your
    users? There are legitimate purposes, such as providing help information while
    filling out a form, but often, the same can be achieved with alternative solutions,
    such as using a floating `<div>` inside the page.
  prefs: []
  type: TYPE_NORMAL
- en: window.moveTo() and window.resizeTo() methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing with the shady practices from the past, the following are more methods
    to irritate your users, provided their browser and personal settings allow you
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`window.moveTo(100, 100)`: This moves the browser window to screen location
    `x = 100` and `y = 100`, which is counted from the top-left corner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.moveBy(10, -10)`: This moves the window 10 pixels to the right and
    10 pixels up from its current location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.resizeTo(x, y)` and `window.resizeBy(x, y)`: These accept the same
    parameters as the move methods, but they resize the window as opposed to moving
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, try to solve the problem you're facing without resorting to these methods.
  prefs: []
  type: TYPE_NORMAL
- en: window.alert(), window.prompt(), and window.confirm() methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops, and
    Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*, we talked
    about the `alert()` function. Now you know that global functions are accessible
    as methods of the global object, so `alert('Watch` `out!')` and `window.alert('Watch`
    `out!')` are exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `alert()` function is not an ECMAScript function but a BOM method. In addition
    to it, two other BOM methods allow you to interact with the user through system
    messages. The following are the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`confirm()`: This gives the user two options, **OK** and **Cancel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prompt()`: This collects textual input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It presents you with a window similar to the following screenshot (the exact
    look depends on the browser and the operating system):'
  prefs: []
  type: TYPE_NORMAL
- en: '![window.alert(), window.prompt(), and window.confirm() methods](img/image_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll notice the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing gets written to the console until you close this message, which means
    that any JavaScript code execution freezes, waiting for the user's answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking on **OK** returns `true`, clicking on **Cancel** or closing the message
    using the **X** icon, or the **ESC** key, returns `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is handy to confirm user actions, as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you provide an alternative way to confirm user actions for people
    who have disabled JavaScript, or for search engine spiders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `window.prompt()` method presents the user with a dialog to enter text,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following dialog box (Chrome, MacOS):'
  prefs: []
  type: TYPE_NORMAL
- en: '![window.alert(), window.prompt(), and window.confirm() methods](img/image_10_003-e1482823176627.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The value of `answer` is one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`null`: This happens if you click on **Cancel**, the **X** icon, or press **ESC**
    key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""` (empty string): This happens if you click on OK or press Enter without
    typing anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A text string: This is if you type something and then click on **OK** or press
    **Enter**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function also takes a string as a second parameter and displays it as a
    default value prefilled into the input field.
  prefs: []
  type: TYPE_NORMAL
- en: Using window.setTimeout() and window.setInterval() methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setTimeout()`and `setInterval()` methods allow scheduling the execution
    of a piece of code. The `setTimeout()` method attempts to execute the given code
    once, after a specified number of milliseconds. The `setInterval()` method attempts
    to execute it repeatedly after a specified number of milliseconds has passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows an alert after approximately 2 seconds (2000 milliseconds). Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the function returned an integer (in this case, `4`) representing
    the ID of the timeout. You can use this ID to cancel the timeout using `clearTimeout()`.
    In the following example, if you''re quick enough, and clear the timeout before
    2 seconds have passed, the alert will never be shown, as you can see in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change `boo()`to something less intrusive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using `setInterval()`, you can schedule `boo()` to execute every 2 seconds,
    until you cancel the scheduled execution with `clearInterval()`. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that both functions accept a pointer to a callback function as a first
    parameter. They can also accept a string, which is evaluated with `eval();` however,
    as you know, `eval()` is evil, so it should be avoided. Moreover, what if you
    want to pass arguments to the function? In such cases, you can just wrap the function
    call inside another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is valid, but not recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This alternative is preferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that scheduling a function in some amount of milliseconds is not a
    guarantee that it will execute exactly at that time. One reason is that most browsers
    don't have millisecond resolution time. If you schedule something in 3 milliseconds,
    it will execute after a minimum of 15 in older IEs and sooner in more modern browsers,
    but most likely, not in 1 millisecond. The other reason is that the browsers maintain
    a queue of what you request them to do. 100 milliseconds timeout means add to
    the queue after 100 milliseconds. However, if the queue is delayed by something
    slow happening, your function will have to wait and execute after, say, 120 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'More recent browsers implement the `requestAnimationFrame()` function. It''s
    preferable to the timeout functions because you''re asking the browser to call
    your function whenever it has available resources, not after a predefined time
    in milliseconds. Try executing the following code snippet in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: window.document property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `window.document` property is a BOM object that refers to the currently
    loaded document (page). Its methods and properties fall into the DOM category
    of objects. Take a deep breath (and maybe first look at the BOM exercises at the
    end of the chapter) and let's dive into the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DOM represents an XML or an HTML document as a tree of nodes. Using DOM
    methods and properties, you can access any element on the page, modify or remove
    elements, or add new ones. The DOM is a language-independent API and can be implemented
    not only in JavaScript, but also in any other language. For example, you can generate
    pages on the server-side with PHP's DOM implementation ([http://php.net/dom](http://php.net/dom)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this example HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the second paragraph `(<p><em>second</em> paragraph</p>`). You will
    see that it''s a `<p>` tag, and it''s contained in the `<body>` tag. If you think
    in terms of family relationships, you can say that `<body>` is the parent of `<p>`
    and `<p>` is the child. The first and the third paragraphs would also be children
    of the `<body>` tag, and at the same time, siblings of the second paragraph. The
    `<em>` tag is a child of the second `<p>`, so `<p>` is its parent. The parent-child
    relationships can be represented graphically in an ancestry tree, called the DOM
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DOM](img/image_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows what you'll see in the WebKit console's **Elements**
    tab after you expand each node.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how all of the tags are shown as expandable nodes on the tree. Although
    not shown, there exists the so-called text nodes, for example, the text inside
    the `<em>` tag (the word second) is a text node. Whitespace is also considered
    a text node. Comments inside the HTML code are also nodes in the tree, the `<!-
    and that's about it ->` comment in the HTML source is a comment node in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every node in the DOM tree is an object and the **Properties** section on the
    right lists all of the properties and methods you can use to work with these objects,
    following the inheritance chain of how this object was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DOM](img/image_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also see the constructor function that was used behind the scenes to
    create each of these objects. Although, this is not too practical for day-to-day
    tasks, it may be interesting to know that, for example, `<p>` is created by the
    `HTMLParagraphElement()` constructor, the object that represents the `head` tag
    is created by `HTMLHeadElement()`, and so on. You cannot create objects using
    these constructors directly, though.
  prefs: []
  type: TYPE_NORMAL
- en: Core DOM and HTML DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One last diversion before moving on to more practical examples. As you now
    know, the DOM represents both XML documents and HTML documents. In fact, HTML
    documents are XML documents, but a little more specific. Therefore, as part of
    DOM Level 1, there is a Core DOM specification that is applicable to all XML documents,
    and there is also an HTML DOM specification, which extends and builds upon the
    core DOM. Of course, the HTML DOM doesn''t apply to all XML documents, but only
    to HTML documents. Let''s see some examples of Core DOM and HTML DOM constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Constructor** | **Inherits from** | **Core or HTML** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Node` |  | Core | Any node on the tree |'
  prefs: []
  type: TYPE_TB
- en: '| `Document` | `Node` | Core | The document object, the main entry point to
    any XML document |'
  prefs: []
  type: TYPE_TB
- en: '| `HTMLDocument` | `Document` | HTML | This is window.document or simply document,
    the HTML-specific version of the previous object, which you''ll use extensively
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Element` | `Node` | Core | Every tag in the source is represented by an
    element. That''s why you say-the `P` element meaning the `<p></p>` tag |'
  prefs: []
  type: TYPE_TB
- en: '| `HTMLElement` | `Element` | HTML | General-purpose constructor, all constructors
    for HTML elements inherit from it |'
  prefs: []
  type: TYPE_TB
- en: '| `HTMLBodyElement` | `HTMLElement` | HTML | Element representing the `<body>`
    tag |'
  prefs: []
  type: TYPE_TB
- en: '| `HTMLLinkElement` | `HTMLElement` | HTML | An A element: an `<a href="..."></a>`
    tag |'
  prefs: []
  type: TYPE_TB
- en: '| And other such constructors | `HTMLElement` | HTML | All the rest of the
    HTML elements |'
  prefs: []
  type: TYPE_TB
- en: '| `CharacterData` | `Node` | Core | General-purpose constructor for dealing
    with texts |'
  prefs: []
  type: TYPE_TB
- en: '| `Text` | `CharacterData` | Core | Text node inside a tag; in `<em>`second`</em>`,
    you have the element node `EM` and the text node with value second |'
  prefs: []
  type: TYPE_TB
- en: '| `Comment` | `CharacterData` | Core | `<!-- any comment -->` |'
  prefs: []
  type: TYPE_TB
- en: '| `Attr` | `Node` | Core | Represents an attribute of a tag; in `<p id="closer">`,
    the `id` attribute is a DOM object created by the `Attr()` constructor |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeList` |  | Core | A list of nodes, an array-like object that has a `length`
    property |'
  prefs: []
  type: TYPE_TB
- en: '| `NamedNodeMap` |  | Core | Same as `NodeList`, but the nodes can be accessed
    by name, not only by numeric index. |'
  prefs: []
  type: TYPE_TB
- en: '| `HTMLCollection` |  | HTML | Similar to `NamedNodeMap` but specific for HTML.
    |'
  prefs: []
  type: TYPE_TB
- en: These are, by no means, all of the Core DOM and HTML DOM objects. For the full
    list, consult [http://www.w3.org/TR/DOM-Level-1/](http://www.w3.org/TR/DOM-Level-1/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that this bit of the DOM theory is behind you, let''s focus on the practical
    side of working with the DOM. In the following sections, you''ll learn how to
    do the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Access DOM nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing DOM nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can validate the user input in a form on a page or swap an image,
    you need to get access to the element you want to inspect or modify. Luckily,
    there are many ways to get to any element, either by navigating around traversing
    the DOM tree or by using a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: It's best if you start experimenting with all of the new objects and methods.
    The examples you'll see use the same simple document that you saw at the beginning
    of the DOM section, and which you can access at [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html).
    Open your console, and let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: The document node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `document` node gives you access to the current document. To explore this
    object, you can use your console as a cheat sheet. Type `console.dir`(document)
    and click on the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The document node](img/image_10_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can browse all of the properties and methods of the `document`
    object DOM properties in the **Elements** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The document node](img/image_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All nodes, including the document node, text nodes, element nodes, and attribute
    nodes have `nodeType`, `nodeName` and `nodeValue` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There are 12 node types, represented by integers. As you can see, the document
    node type is `9`. The most commonly used are `1` (element), `2` (attribute), and
    `3` (text).
  prefs: []
  type: TYPE_NORMAL
- en: 'Nodes also have names. For HTML tags, the node name is the tag name (`tagName`
    property). For text nodes, it''s `#text`, and for document nodes, the name is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Nodes can also have node values. For example, for text nodes, the value is
    the actual text. The document node doesn''t have a value, which can be seen as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: documentElement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's move around the tree. XML documents always have one root node that
    wraps the rest of the document. For HTML documents, the root is the `<html>` tag.
    To access the root, you will use the `documentElement` property of the `document`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`nodeType` is `1` (an element node) which can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For element nodes, both `nodeName` and `tagName` properties contain the name
    of the tag, as seen in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Child nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to tell if a node has any children, you will use `hasChildNodes()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML element has three children, the `head` and the `body` elements and
    the whitespace between them (whitespace is counted in most, but not all browsers).
    You can access them using the `childNodes` array-like collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Any child has access to its parent through the `parentNode` property, as seen
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assign a reference to body to a variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How many children does the `body` element have? Consider the following piece
    of code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As a refresher, here, again, is the body of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How come body has `9` children? Well, three paragraphs plus one comment makes
    four nodes. The whitespace between these four nodes makes three more text nodes.
    This makes a total of seven so far. The whitespace between `<body>` and the first
    `<p>` is the eighth node. The whitespace between the comment and the closing `</body>`
    is another text node. This makes a total of nine child nodes. Just type `bd.childNodes`
    in the console to inspect them all.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the first child of the body is a whitespace, the second child (index 1)
    is the first paragraph. Refer to the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check whether an element has attributes using `hasAttributes()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'How many attributes? In this example, one is the `class` attribute, which can
    be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access the attributes by index and name. You can also get the value
    using the `getAttribute()` method, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the content inside a tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the first paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get the text contained in the paragraph using the `textContent` property.
    It doesn''t exist in older IEs, but another property called `innerText` returns
    the same value, as seen in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also the `innerHTML` property. It''s a relatively new addition to
    the DOM standard, despite the fact that it previously existed in all major browsers.
    It returns (or sets) HTML code contained in a node. You can see how this is a
    little inconsistent as DOM treats the document as a tree of nodes, not as a string
    of tags. However, `innerHTML` is so convenient to use that you''ll see it everywhere.
    Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The first paragraph contains only text, so `innerHTML` is the same as `textContent`
    (or `innerText` in IE). However, the second paragraph does contain an `em` node,
    so you can see the difference as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to get the text contained in the first paragraph is by using the
    `nodeValue` method of the text node contained inside the `p` node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: DOM access shortcuts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `childNodes`, `parentNode`, `nodeName`, `nodeValue`, and `attributes`,
    you can navigate up and down the tree and do anything with the document. However,
    the fact that whitespace is a text node makes this a fragile way of working with
    the DOM. If the page changes, your script may no longer work correctly. Also,
    if you want to get to a node deeper in the tree, it could take a bit of code before
    you get there. That's why you have shortcut methods, namely, `getElementsByTagName()`,
    `getElementsByName()`, and `getElementById()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getElementsByTagName()` method takes a tag name (the name of an element
    node) and returns an HTML collection (array-like object) of nodes with the matching
    tag name. For example, the following example asks-give me a count of all paragraphs,
    which is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access an item in the list using the brackets notation, or the `item()`method,
    and passing the index (0 for the first element). Using `item()` is discouraged,
    as array brackets are more consistent and also shorter to type. Refer to the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the contents of the first `p` can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the last `p` can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the attributes of an element, you can use the `attributes` collection
    or `getAttribute()`, as shown previously. However, a shorter way is to use the
    attribute name as a property of the element you''re working with. So, to get the
    value of the `id` attribute, you will just use `id` as a property, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the `class` attribute of the first paragraph won''t work though. It''s
    an exception because it just happens so that class is a reserved word in ECMAScript.
    You can use `className` instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `getElementsByTagName()`, you can get all of the elements on the page,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In earlier versions of IE before IE7, `*` is not acceptable as a tag name. To
    get all elements, you can use IE's proprietary `document.all` collection, although,
    selecting every element is rarely needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other shortcut mentioned is `getElementById()`. This is probably the most
    common way of accessing an element. You just assign IDs to the elements you plan
    to play with and they''ll be easy to access later on, as seen in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional shortcut methods in more recent browsers include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getElementByClassName()`:This method finds elements using their class attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`querySelector()`: This method finds an element using a CSS selector string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`querySelectorAll()`: This method is the same as the previous one but returns
    all matching elements, not just the first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Siblings, body, first, and last child
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `nextSibling` and `previousSibling` are two other convenient properties
    to navigate the DOM tree once you have a reference to one element. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `body` element is used so often that it has its own shortcut, which is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `firstChild` and `lastChild` properties are also convenient. The `firstChild`
    property is the same as `childNodes[0]` and `lastChild` is the same as `childNodes[childNodes.length
    - 1]` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the family relationships between the body and
    the three paragraphs in it. For simplicity, all the whitespace text nodes are
    removed from the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Siblings, body, first, and last child](img/image_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Walk the DOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To wrap up, here''s a function that takes any node and walks through the DOM
    tree recursively, starting from the given node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Modifying DOM nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know a whole lot of methods to access any node of the DOM tree
    and its properties, let''s see how you can modify these nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assign a pointer to the last paragraph to the variable `my`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, changing the text of the paragraph can be as easy as changing the `innerHTML`
    value, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As `innerHTML` accepts a string of HTML source code, you can also create a
    new `em` node in the DOM tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `em` node becomes a part of the tree. Lets take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to change text is to get the actual text node and change its `nodeValue`,
    as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Modifying styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often you don''t change the content of a node, but its presentation. The elements
    have a `style` property, which in turn has a property mapped to each CSS property.
    For example, changing the style of the paragraph to add a red border, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'CSS properties often have dashes, but dashes are not acceptable in JavaScript
    identifiers. In such cases, you skip the dash and uppercase the next letter. So,
    `padding-top` becomes `paddingTop`, `margin-left` becomes `marginLeft`, and so
    on. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You also have access to the `cssText` property of `style`, which lets you work
    with styles as strings, as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, modifying styles is a string manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Fun with forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned earlier, JavaScript is great for client-side input validation
    and can save a few round-trip to the server. Let''s practice form manipulations
    and play a little bit with a form located on a popular page, [www.google.com](http://www.google.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fun with forms](img/image_10_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding the first text input using the `querySelector()` method and a CSS selector
    string is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the search box. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the search query by setting the text contained in the `value` attribute
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have some fun and change the word **Lucky** with **Tricky** in
    the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '![Fun with forms](img/image_10_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s implement the tricky part and make that button show and hide for
    one second. You can do this with a simple function. Let''s call it `toggle()`.
    Every time you call the function, it checks the value of the CSS property `visibility`,
    and sets it to visible if it''s hidden and vice versa using the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of calling the function manually, let''s set an interval and call it
    every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The result? The button starts blinking, making it trickier to click. When you''re
    tired of chasing it, just remove the timeout interval by writing the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Creating new nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create new nodes, you can use the `createElement()` and `createTextNode()`
    methods. Once you have the new nodes, you can add them to the DOM tree using `appendChild()`,
    `insertBefore()`, or `replaceChild()`.
  prefs: []
  type: TYPE_NORMAL
- en: Reload [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)
    and let's play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `p` element and set its `innerHTML`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The new element automatically gets all the default properties, such as `style`,
    which you can modify as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `appendChild()`, you can add the new node to the DOM tree. Calling this
    method on the `document.body` node means creating one more child node right after
    the last child, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an illustration of how the page looks like after the new node is appended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating new nodes](img/image_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DOM-only method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `innerHTML` property gets things done a little more quickly than using
    pure DOM. In pure DOM, you will need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new text node containing yet another text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new paragraph node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the text node as a child to the paragraph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the paragraph as a child to the body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This way, you can create any number of text nodes and elements and nest them,
    however you like. Let''s say, you want to add the following HTML to the end of
    the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Presenting the preceding code as a hierarchy would be something like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that accomplishes this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Using cloneNode() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to create nodes is by copying or cloning existing ones. The `cloneNode()`
    method does this and accepts a Boolean parameter (`true` = deep copy with all
    the children, `false` = shallow copy, only this node). Let's test the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting a reference to the element you want to clone can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `el` refers to the second paragraph on the page that looks like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a shallow clone of `el` and append it to the `body` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'You won''t see a difference on the page because the shallow copy only copied
    the `P` node without any children. This means that the text inside the paragraph,
    which is a text node child, was not cloned. The preceding line will be equivalent
    to the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you create a deep copy, the whole DOM subtree starting from `P`
    is copied, and this includes text nodes and the `EM` element. This line copies
    (visually too) the second paragraph to the end of the document. Consider the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also copy only the `EM` if you want, as shown in the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can copy only the text node with value `second`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Using insertBefore() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `appendChild()`, you can only add new children at the end of the selected
    element. For more control over the exact location, there is `insertBefore()`.
    This is the same as `appendChild()`, but accepts an extra parameter specifying
    where (before which element) to insert the new node. For example, the following
    code inserts a text node at the end of the `body` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, this creates another text node and adds it as the first child of
    the `body` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Removing nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove nodes from the DOM tree, you can use the `removeChild()` method.
    Again, let''s start fresh with the same page with the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how you can remove the second paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The method returns the removed node if you want to use it later. You can still
    use all the DOM methods even though the element is no longer in the tree. Lets
    take a look on the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: There's also the `replaceChild()`method that removes a node and puts another
    one in its place.
  prefs: []
  type: TYPE_NORMAL
- en: 'After removing the node, the tree looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the second paragraph is the one with the ID `"closer"`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s replace this paragraph with the one in the `removed` variable. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like `removeChild()`, `replaceChild()` returns a reference to the node
    that is now out of the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the body looks like the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick way to wipe out all of the content of a subtree is to set `innerHTML`
    to a blank string. This removes all the children of the `body` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing with `innerHTML` is fast and easy. The DOM-only way will be to go
    over all of the child nodes and remove each one individually. Here''s a little
    function that removes all nodes from a given start node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to delete all the children from the `body` element and leave the
    page with an empty `<body></body>`, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: HTML - only DOM objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you already know, the DOM applies to both XML and HTML documents. What you've
    learned earlier about traversing the tree and then adding, removing, or modifying
    nodes, applies to any XML document. There are, however, some HTML-only objects
    and properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `document.body` is one such HTML-only object. It's so common to have a `<body>`
    tag in HTML documents, and it's accessed so often, that it makes sense to have
    an object that's shorter and friendlier than the equivalent `document.getElementsByTagName('body')[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `document.body` element is one example of a `legacy` object inherited from
    the prehistoric DOM Level 0 and moved to the HTML extension of the DOM specification.
    There are other objects similar to `document.body` element. For some of them,
    there is no core DOM equivalent, for others, there is an equivalent; however,
    the DOM 0 original was anyway ported for simplicity and legacy purposes. Let's
    see some of those objects.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive ways to access the document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'to the elements of an HTML document. This was done mainly through a number
    of collections, which are as follows: Unlike the DOM, which gives you access to
    any element, and even comments and whitespace, initially, JavaScript had only
    limited access to the elements of an HTML document. This was done mainly through
    a number of collections, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`document.images`: This is a collection of all of the images on the page. The
    Core DOM equivalent is `document.getElementsByTagName(''img'')`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document.applets`: This is the same as `document.getElementsByTagName(''applet'')`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document.links`: The document.links collection contains a list of all `<a
    href="..."></a>` tags on the page, meaning the `<a>` tags that have an `href`
    attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document.anchors`: The document.anchors collection contains all links with
    a name attribute (`<a name="..."></a>`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document.forms`: One of the most widely used collections is `document.forms`,
    which contains a list of `<form>` elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s play with a page that contains a form and an input ([http://www.phpied.com/files/jsoop/ch7-form.html](http://www.phpied.com/files/jsoop/ch7-form.html)).
    The following line of code gives you access to the first form on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s the same as the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The `document.forms` collection contains collections of input fields and buttons,
    accessible through the `elements` property. Here''s how to access the first input
    of the first form on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have access to an element, you can access its attributes as object
    properties. The first field of the first form in the test page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change the text in the field (the value of the `value` attribute) using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to disable the field dynamically, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'When forms or `form` elements have a `name` attribute, you can access them
    by name too, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Using document.write() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `document.write()` method allows you to insert HTML into the page while
    the page is being loaded. You can have something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as if you had the date directly in the source of the HTML
    document, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can only use `document.write()` method while the page is being
    loaded. If you try it after page load, it will replace the content of the whole
    page.
  prefs: []
  type: TYPE_NORMAL
- en: It's rare that you would need `document.write()` method, and if you think you
    do, try an alternative approach. The ways to modify the contents of the page provided
    by DOM Level 1 are preferred and are much more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies, title, referrer, and domain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The four additional properties of `document` you'll see in this section are
    also ported from DOM Level 0 to the HTML extension of DOM Level 1\. Unlike the
    previous ones, for these properties, there are no core DOM equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `document.cookie` is a property that contains a string. This string is
    the content of the cookies exchanged between the server and the client. When the
    server sends a page to the browser, it may include the `Set-Cookie` HTTP header.
    When the client sends a request to the server, it sends the cookie information
    back with the `Cookie` header. Using `document.cookie`, you can alter the cookies
    the browser sends to the server. For example, visiting `cnn.com` and typing `document.cookie`
    in the console gives you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The `document.title` property allows you to change the title of the page displayed
    in the browser window. For example, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Note that this doesn't change the value of the `<title>` element, but only the
    display in the browser window, so it's not equivalent to `document.querySelector('title')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `document.referrer` property tells you the URL of the previously visited
    page. This is the same value the browser sends in the `Referer` HTTP header when
    requesting the page. (Note that `Referer` is misspelled in the HTTP headers, but
    is correct in JavaScript''s `document.referrer`). If you''ve visited the CNN page
    by searching on Yahoo first, you can see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The `document.domain` property gives you access to the domain name of the currently
    loaded page. This is commonly used when you need to perform so-called domain relaxation.
    Imagine your page is `www.yahoo.com`, and inside it, you have an iframe hosted
    on `music.yahoo.com` subdomain. These are two separate domains, so the browser's
    security restrictions won't allow the page and the iframe to communicate. To resolve
    this, you can set `document.domain` property on both pages to `yahoo.com` and
    they'll be able to talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can only set the domain to a less specific one, for example,
    you can change `www.yahoo.com` to `yahoo.com`, but you cannot change `yahoo.com`
    to `www.yahoo.com`, or any other non-yahoo domain. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, in this chapter, you saw the `window.location` object. Well, the
    same functionality is also available as `document.location` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you are listening to a radio program and they announce, "Big event!
    Huge! Aliens have landed on Earth!" You might think, "Yeah, whatever"; some other
    listeners might think "They come in peace"; and some might think, "We''re all
    gonna die!". Similarly, the browser broadcasts events, and your code can be notified
    should it decide to tune in and listen to the events as they happen. Some example
    events are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user clicks a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user types a character in a form field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The page finishes loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can attach a JavaScript function called event listener or event handler
    to a specific event and the browser will invoke your function as soon as the event
    occurs. Let's see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Inline HTML attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding specific attributes to a tag is the laziest but the least maintainable
    way; take the following line of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: In this case, when the user clicks on `<div>`, the click event fires and the
    string of JavaScript code contained in the `onclick` attribute is executed. There's
    no explicit function that listens to the click event; however, behind the scenes,
    a function is still created, and it contains the code you specified as a value
    of the `onclick` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Element Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to have some code executed when a click event fires is to assign
    a function to the `onclick` property of a DOM node element. For example, take
    a look at the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: This way is better because it helps you keep your `<div>` tag clean of any JavaScript
    code. Always keep in mind that HTML is for content, JavaScript for behavior, and
    CSS for formatting, and you should keep these three separate as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: This method has the drawback that you can attach only one function to the event,
    as if the radio program has only one listener. It's true that you can have a lot
    happening inside the same function, but this is not always convenient, as if all
    the radio listeners are in the same room.
  prefs: []
  type: TYPE_NORMAL
- en: DOM event listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to work with browser events is to use the event listener approach
    outlined in DOM Level 2, where you can have many functions listening to an event.
    When an event fires, all the functions are executed. All of the listeners don't
    need to know about each other and can work independently. They can tune in and
    out at any time, without affecting the other listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same simple markup from the previous section, which is available
    for you to play with at [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html).
    It has this piece of markup, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Your JavaScript code can assign listeners to the click event using the `addEventListener()`
    method. Let''s attach two listeners as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `addEventListeners`
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and bubbling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the calls to `addEventListener()`, there was a third parameter-`false`. Let's
    see what it is for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a link inside an unordered list, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click on the link, you''re actually also clicking on the list item,
    `<li>`, the `<ul>` list, the `<body>` tag, and eventually, the document as a whole.
    This is called event propagation. A click on a link can also be seen as a click
    on the document. The process of propagating an event can be implemented in the
    two following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event capturing**: This click happens in the document first, then it propagates
    down to the body, the list, the list item, and finally, to the link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event bubbling**: This click happens on the link and then bubbles up to the
    document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DOM level 2 events specification suggests that the events propagate in three
    phases, namely, capturing, at target, and bubbling. This means that the event
    propagates from the document to the link (target) and then bubbles back up to
    the document. The event objects have an `eventPhase` property, which reflects
    the current phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing and bubbling](img/image_10_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Historically, IE and Netscape (working on their own and without a standard to
    follow) implemented the exact opposites. IE implemented only bubbling and Netscape
    only capturing. Today, long after the DOM specification, modern browsers implement
    all three phases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The practical implications related to the event propagation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter to `addEventListener()` specifies whether or not capturing
    should be used. In order to have your code more portable across browsers, it's
    better to always set this parameter to `false` and use bubbling only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can stop the propagation of the event in your listeners so that it stops
    bubbling up and never reaches the document. To do this, you can call the `stopPropagation()`
    method of the event object; there is an example in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use event delegation. If you have ten buttons inside `<div>`, you
    can always attach ten event listeners, one for each button. However, a smarter
    thing to do is to attach only one listener to the wrapping `<div>` and once the
    event happens, check which button was the target of the click.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a side note, there is a way to use event capturing in old IEs too (using
    `setCapture()` and `releaseCapture()` methods) but only for mouse events. Capturing
    any other events (keystroke events for example) is not supported.
  prefs: []
  type: TYPE_NORMAL
- en: Stop propagation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see an example of how you can stop the event from bubbling up. Going
    back to the test document, there is this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a function that handles clicks on the paragraph, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s attach this function as a listener to the click event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also attach listeners to the click event on the body, the document,
    and the browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Note that the DOM specifications don't say anything about events on the window.
    And why would they, as DOM deals with the document and not the browser. So browsers
    implement window events inconsistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you click on the paragraph, you''ll see four alerts saying:'
  prefs: []
  type: TYPE_NORMAL
- en: clicked paragraph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: clicked body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: clicked doc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: clicked window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This illustrates how the same single click event propagates (bubbles up) from
    the target all the way up to the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of `addEventLister()` is `removeEventListener()`, and it accepts
    exactly the same parameters. Let''s remove the listener attached to the paragraph
    by writing the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: If you try now, you'll see alerts only for the click event on the body, document,
    and window, but not on the paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s stop the propagation of the event. The function you add as a listener
    receives the event object as a parameter, and you can call the `stopPropagation()`
    method of that event object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the modified listener is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you click on the paragraph, you will see only one alert because the
    event doesn't bubble up to the body, the document, or the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when you remove a listener, you have to pass a pointer to the same
    function you previously attached. Otherwise, doing the following does not work
    because the second argument is a new function, not the same you passed when adding
    the event listener, even if the body is exactly the same. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Prevent default behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some browser events have a predefined behavior. For example, clicking a link
    causes the browser to navigate to another page. You can attach listeners to clicks
    on a link, and you can also disable the default behavior by calling the `preventDefault()`
    method on the event object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how you can annoy your visitors by asking "Are you sure you want
    to follow this link?" every time they click a link? If the user clicks on **Cancel**
    (causing `confirm()` to return `false`), the `preventDefault()` method is called,
    which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Note that not all events allow you to prevent the default behavior. Most do,
    but if you want to be sure, you can check the `cancellable` property of the event
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-browser event listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you already know, most modern browsers almost fully implement the DOM Level
    1 specification. However, the events were not standardized until DOM 2\. As a
    result, there are quite a few differences in how IE, before version 9, implements
    this functionality compared to modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out an example that causes `nodeName` of a clicked element (the target
    element) to be written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at how IE is different:'
  prefs: []
  type: TYPE_NORMAL
- en: In IE, there's no `addEventListener()` method; although, since IE Version 5,
    there is an equivalent `attachEvent()` method. For earlier versions, your only
    choice is accessing the property directly, such as `onclick`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `click` event becomes `onclick` when using `attachEvent()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you listen to events the old fashioned way (for example, by setting a function
    value to the `onclick` property), when the callback function is invoked, it doesn't
    get an event object passed as a parameter. However, regardless of how you attach
    the listener in IE, there is always a global object `window.event` that points
    to the latest event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In IE, the event object doesn't get a target attribute telling you the element
    on which the event fired, but it does have an equivalent property called `srcElement`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned earlier, event capturing doesn't apply to all events, so only bubbling
    should be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no `stopPropagation()` method, but you can set the IE-only `cancelBubble`
    property to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no `preventDefault()` method, but you can set the IE-only `returnValue`
    property to `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To stop listening to an event, instead of `removeEventListener()` in IE, you'll
    need `detachEvent()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, here''s the revised version of the previous code that works across browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Types of events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you know how to handle cross-browser events. However, all of the preceding
    examples used only click events. What other events are happening out there? As
    you can probably guess, different browsers provide different events. There is
    a subset of cross-browser events, and some browser-specific ones. For a full list
    of events, you should consult the browser''s documentation, but here''s a selection
    of cross-browser events:'
  prefs: []
  type: TYPE_NORMAL
- en: Mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseup`, `mousedown`, `click` (the sequence is mousedown-up-click), `dblclick`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseover` (mouse is over an element), `mouseout` (mouse was over an element
    but left it), `mousemove`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keydown`, `keypress`, `keyup` (occur in this sequence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading/window events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load` (an image or a page and all of its components are done loading), `unload`
    (user leaves the page), `beforeunload` (the script can provide the user with an
    option to stop the unload)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abort` (user stops loading the page or an image in IE), `error` (a JavaScript
    error, also when an image cannot be loaded in IE)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize` (the browser window is resized), `scroll` (the page is scrolled),
    `contextmenu` (the right-click menu appears)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Form events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`focus` (enter a form field), `blur` (leave the form field)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`change` (leave a field after the value has changed), `select` (select text
    in a text field)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset` (wipe out all user input), `submit` (send the form)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, modern browsers provide drag events (`dragstart`, `dragend`, `drop`,
    and among others) and touch devices provide `touchstart`, `touchmove`, and `touchend`.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the discussion of events. Refer to the exercise section at the
    end of this chapter for a little challenge of creating your own event utility
    to handle cross-browser events.
  prefs: []
  type: TYPE_NORMAL
- en: XMLHttpRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`XMLHttpRequest()` is an object (a constructor function) that allows you to
    send HTTP requests from JavaScript. Historically, XHR (`XMLHttpRequest`) was introduced
    in IE and was implemented as an ActiveX object. Starting with IE7, it''s a native
    browser object, the same way as it''s in the other browsers. The common implementation
    of this object across browsers gave birth to the so-called Ajax applications,
    where it''s no longer necessary to refresh the whole page every time you need
    new content. With JavaScript, you can make an HTTP request to the server, get
    the response, and update only a part of the page. This way, you can build much
    more responsive and desktop-like web pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ajax** stands for **Asynchronous JavaScript and XML**:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous because, after sending an HTTP request, your code doesn't need
    to wait for the response; however, it can do other stuff and be notified, through
    an event, when the response arrives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript because it's obvious that XHR objects are created with JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML because initially developers were making HTTP requests for XML documents
    and were using the data contained in them to update the page. This is no longer
    a common practice, though, as you can request data in plain text, in the much
    more convenient JSON format, or simply as HTML ready to be inserted into the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two steps to using the `XMLHttpRequest` object, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Send the request**: This includes creating an `XMLHttpRequest` object and
    attaching an event listener'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process the response**: This happens when your event listener gets notified
    that the response has arrived, and your code gets busy doing something amazing
    with the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending the request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create an object, you will simply use the following code (let''s
    deal with browser inconsistencies in just a bit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing is to attach an event listener to the `readystatechange` event
    fired by the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will need to call the `open()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter specifies the type of HTTP request, such as `GET`, `POST`,
    `HEAD`, and so on. `GET` and `POST` are the most common ones. Use `GET` when you
    don't need to send much data with the request and your request doesn't modify
    (write) data on the server, otherwise, use `POST`. The second parameter is the
    URL you are requesting. In this example, it's the text file `somefile.txt` located
    in the same directory as the page. The last parameter is a Boolean specifying
    whether the request is asynchronous (`true`, always prefer this) or not (`false`,
    blocks all the JavaScript execution and waits until the response arrives).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to fire off the request, which is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The `send()` method accepts any data you want to send with the request. For
    `GET` requests, this is an empty string because the data is in the URL. For `POST`
    request, it's a query string in the `key=value&key2=value2` form.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the request is sent and your code and the user can move on to
    other tasks. The callback function, `myCallback`, will be invoked when the response
    comes back from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A listener is attached to the `readystatechange` event. So, what exactly is
    the ready state and how does it change?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a property of the XHR object called `readyState`. Every time it changes,
    the `readystatechange` event fires. The possible values of the `readyState` property
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 0-uninitialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2-loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3-interactive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4-complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `readyState` gets the value of `4`, it means the response is back and ready
    to be processed. In `myCallback`, after you make sure `readyState` is `4`, the
    other thing to check is the status code of the HTTP request. You might have requested
    a non-existing URL, for example, and got a `404` (File not found) status code.
    The interesting code is the `200` (`OK`) code, so `myCallback` should check for
    this value. The status code is available in the `status` property of the XHR object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `xhr.readyState` is `4` and `xhr.status` is `200`, you can access the
    contents of the requested URL using the `xhr.responseText` property. Let''s see
    how `myCallback` can be implemented to simply `alert()` the contents of the requested
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Once you've received the new content you requested, you can add it to the page,
    use it for some calculations, or for any other purpose you find suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this two-step process (send request and process response) is the core
    of the whole XHR/Ajax functionality. Now that you know the basics, you can move
    on to building the next Gmail. Oh yes, let's take a look at some minor browser
    inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating XMLHttpRequest objects in IE prior to Version 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Internet Explorer, prior to version 7, the `XMLHttpRequest` object was an
    ActiveX object, so creating an XHR instance is a little different. It goes as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '`MSXML2.XMLHTTP.3.0` is the identifier of the object you want to create. There
    are several versions of the `XMLHttpRequest` object, and if your page visitor
    doesn''t have the latest one installed, you can try two older ones before you
    give up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a fully-cross-browser solution, you should first test to see if the user''s
    browser supports `XMLHttpRequest` as a native object, and if not, try the IE way.
    Therefore, the whole process of creating an XHR instance could be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: What is this doing? The `ids` array contains a list of ActiveX program IDs to
    try. The `xhr` variable points to the new XHR object. The code first checks to
    see if `XMLHttpRequest` exists. If so, this means that the browser supports `XMLHttpRequest()`
    natively, so the browser is relatively modern. If it is not, the code loops through
    ids trying to create an object. The `catch(e)` block quietly ignores failures
    and the loop continues. As soon as an `xhr` object is created, you break out of
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is quite a bit of code, so it's best to abstract it into
    a function. Actually, one of the exercises at the end of the chapter prompts you
    to create your own Ajax utility.
  prefs: []
  type: TYPE_NORMAL
- en: A is for Asynchronous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you know how to create an XHR object, give it a URL and handle the response
    to the request. What happens when you send two requests asynchronously? What if
    the response to the second request comes before the first?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the XHR object was global and `myCallback` was relying
    on the presence of this global object in order to access its `readyState`, `status`,
    and `responseText` properties. Another way, which prevents you from relying on
    global variables, is to wrap the callback in a closure. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `myCallback()` receives the XHR object as a parameter and will
    not go looking for it in the global space. This also means that at the time the
    response is received, the original `xhr` might be reused for a second request.
    The closure keeps pointing to the original object.
  prefs: []
  type: TYPE_NORMAL
- en: X is for XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although these days JSON (discussed in the next chapter) is preferred over XML
    as a data transfer format, XML is still an option. In addition to the `responseText`
    property, the XHR objects also have another property called `responseXML`. When
    you send an HTTP request for an XML document, `responseXML` points to an XML DOM
    document object. To work with this document, you can use all of the core DOM methods
    discussed previously in this chapter, such as `getElementsByTagName()`, `getElementById()`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's wrap up the different XHR topics with an example. You can visit the page
    located at [http://www.phpied.com/files/jsoop/xhr.html](http://www.phpied.com/files/jsoop/xhr.html)
    to work on the example yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main page, `xhr.html`, is a simple static page that contains nothing but
    three `<div>` tags, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Using the console, you can write code that requests three files and loads their
    respective contents into each `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three files to load are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`content.txt`: This is a simple text file containing the text `I am a text
    file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content.html`: This is a file containing HTML code `I am <strong>formatted</strong>
    <em>HTML</em>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content.xml`: This is an XML file containing the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All of the files are stored in the same directory as `xhr.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For security reasons, you can only use the original `XMLHttpRequest` to request
    files that are on the same domain. However, modern browsers support XHR2, which
    lets you make cross-domain requests, provided that the appropriate Access-Control-Allow-Origin
    HTTP header is in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a function to abstract the request/response part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts a URL to request and a callback function to call once
    the response arrives. Let''s call the function three times, once for each file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback functions are defined inline. The first two are identical. They
    just replace the HTML of the corresponding `<div>` with the contents of the requested
    file. The third one is a little different as it deals with the XML document. First,
    you will access the XML DOM object as `o.responseXML`. Then, using `getElementsByTagName()`,
    you will get a list of all the `<root>` tags (there is only one). The `firstChild`
    of `<root>` is a text node and `nodeValue` is the text contained in it (`I''m
    XML data)`. Then, just replace the HTML of `<div id="xml">` with the new content.
    The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example](img/image_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When working with the XML document, you can also use `o.responseXML.documentElement`
    to get to the `<root>` element instead of `o.responseXML.getElementsByTagName('root')[0]`.
    Remember that `documentElement` gives you the root node of an XML document. The
    root in HTML documents is always the `<html>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, the solutions to the exercises could be found in the
    text of the chapter. This time, some of the exercises require you to do some more
    reading, or experimentation, outside this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'BOM: As a BOM exercise, try coding something wrong, obtrusive, user-unfriendly,
    and all in all, very Web 1.0, the shaking browser window. Try implementing code
    that opens a 200 x 200 pop up window and then resizes it slowly and gradually
    to 400 x 400\. Next, move the window around as if there''s an earthquake. All
    you''ll need is one of the move`*()` functions, one or more calls to `setInterval()`,
    and maybe one to `setTimeout()`/`clearInterval()` to stop the whole thing. Or,
    here''s an easier one-print the current date/time in `document.title` and update
    it every second, like a clock.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DOM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `walkDOM()` differently. Also, make it accept a callback function
    instead of hard coding `console.log()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing content with `innerHTML` is easy (`document.body.innerHTML = ''`),
    but not always best. The problem will be when there are event listeners attached
    to the removed elements; they won't be removed in IE, causing the browser to leak
    memory because it stores references to something that doesn't exist. Implement
    a general-purpose function that deletes DOM nodes, but removes any event listeners
    first. You can loop through the attributes of a node and check if the value is
    a function. If it is, it's most likely an attribute like `onclick`. You need to
    set it to `null` before removing the element from the tree.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a function called `include()` that includes external scripts on demand.
    This means you need to create a new `<script>` tag dynamically, set its `src`
    attribute, and append to the document''s `<head>`. Test it by using the following
    code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an event utility (object) called `myevent`, which has the following
    methods working cross-browser:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addListener``(element`, `event_name`, `callback)`, where `element` can
    also be an array of elements
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeListener``(element`, `event_name`, `callback)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getEvent(event)` just to check for a `window.event` for older versions of
    IE'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: getTarget(event)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: stopPropagation(event)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: preventDefault(event)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage example is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The result of the example code should be that all of the links in the document
    lead nowhere, but only alert the `href` attribute.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an absolutely positioned `<div>`, say at `x = 100px`, `y = 100px`. Write
    the code to be able to move div around the page using the arrow keys or the *J*
    (left), *K* (right), *M* (down), and *I* (up) keys. Reuse your own event utility
    from 3.1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XMLHttpRequest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create your own XHR utility (object) called `ajax`. For example, take a look
    at the following code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You learned quite a bit in this chapter. You learned the following cross-browser
    BOM objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Properties of the global `window` object, such as `navigator`, `location`, `history`,
    `frames`, `screen`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods such as `setInterval()` and `setTimeout()`; `alert()`, `confirm()` and
    `prompt()`; `moveTo/By()` and `resizeTo/By()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, you learned about the DOM, an API to represent an HTML or XML document
    as a tree structure, where each tag or text is a node on the tree. You also learned
    how to perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parent/child relationship properties, such as `parentNode`, `childNodes`,
    `firstChild`, `lastChild`, `nextSibling`, and `previousSibling`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `getElementsById()`, `getElementsByTagName()`, `getElementsByName()`,
    and `querySelectorAll()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modifying nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `innerHTML` or `innerText/textContent`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `nodeValue` or `setAttribute()`, or just using attributes as object properties
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing nodes with `removeChild()` or `replaceChild()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new ones with `appendChild()`, `cloneNode()`, and `insertBefore()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You also learned the following DOM 0 (pre-standardization) properties, ported
    to DOM Level 1:'
  prefs: []
  type: TYPE_NORMAL
- en: Collections, such as `document.forms`, `images`, `links`, `anchors`, `applets`.
    Using these are discouraged as DOM1 has the much more flexible `getElementsByTagName()`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `document.body` element, which gives you convenient access to `<body>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `document.title`, `cookie`, `referrer`, and `domain`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you learned how the browser broadcasts events that you can listen to.
    It's not straightforward to do this in a cross-browser manner, but it's possible.
    Events bubble up, so you can use event delegation to listen to events more globally.
    You can also stop the propagation of events and interfere with the default browser
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you learned about the `XMLHttpRequest` object that allows you to build
    responsive web pages that do the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Make HTTP requests to the server to get pieces of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the response to update portions of the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
