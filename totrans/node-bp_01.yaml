- en: Chapter 1. Common Programming Paradigms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 常见编程范式
- en: Node.js is a JavaScript-driven technology. The language has been in development
    for more than 15 years, and it was first used in Netscape. Over the years, they've
    found interesting and useful design patterns, which will be of use to us in this
    book. All this knowledge is now available to Node.js coders. Of course, there
    are some differences because we are running the code in different environments,
    but we are still able to apply all these good practices, techniques, and paradigms.
    I always say that it is important to have a good basis to your applications. No
    matter how big your application is, it should rely on flexible and well-tested
    code. The chapter contains proven solutions that guarantee you a good starting
    point. Knowing design patterns doesn't make you a better developer because in
    some cases, applying the principles strictly won't work. What you actually get
    is ideas, which will help you in thinking out of the box. Sometimes, programming
    is all about managing complexity. We all meet problems, and the key to a well-written
    application is to find the best suitable solutions. The more paradigms we know,
    the easier our work is because we have proven concepts that are ready to be applied.
    That's why this book starts with an introduction to the most common programming
    paradigms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一种由JavaScript驱动的技术。这种语言已经发展了超过15年，最初用于Netscape。多年来，他们发现了有趣和有用的设计模式，这些模式将有助于我们在本书中。所有这些知识现在都可供Node.js程序员使用。当然，由于我们在不同的环境中运行代码，所以存在一些差异，但我们仍然能够应用所有这些良好的实践、技术和范式。我总是说，为您的应用程序建立一个良好的基础是很重要的。无论您的应用程序有多大，它都应该依赖于灵活且经过良好测试的代码。本章包含经过验证的解决方案，保证您有一个良好的起点。了解设计模式并不一定使您成为更好的开发者，因为在某些情况下，严格应用原则可能不起作用。您实际上得到的是想法，这些想法将帮助您跳出思维定式。有时，编程就是管理复杂性。我们都会遇到问题，而编写良好应用程序的关键是找到最佳合适的解决方案。我们了解的范式越多，我们的工作就越容易，因为我们有现成的、可以应用的概念。这就是为什么本书从介绍最常见的编程范式开始。
- en: Node.js fundamentals
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js基础知识
- en: 'Node.js is a single-threaded technology. This means that every request is processed
    in only one thread. In other languages, for example, Java, the web server instantiates
    a new thread for every request. However, Node.js is meant to use asynchronous
    processing, and there is a theory that doing this in a single thread could bring
    good performance. The problem of the single-threaded applications is the blocking
    I/O operations; for example, when we need to read a file from the hard disk to
    respond to the client. Once a new request lands on our server, we open the file
    and start reading from it. The problem occurs when another request is generated,
    and the application is still processing the first one. Let''s elucidate the issue
    with the following example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一种单线程技术。这意味着每个请求都只在一个线程中处理。在其他语言中，例如Java，Web服务器为每个请求实例化一个新的线程。然而，Node.js旨在使用异步处理，有一种理论认为在单个线程中这样做可能会带来良好的性能。单线程应用程序的问题在于阻塞I/O操作；例如，当我们需要从硬盘读取文件以响应用户时。一旦新的请求到达我们的服务器，我们就打开文件并开始读取。问题发生在当另一个请求生成，而应用程序仍在处理第一个请求时。让我们通过以下示例来阐明这个问题：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'The `http` module, which we initialize on the first line, is needed for running
    the web server. The `getTime` function returns the current time as a string, and
    the `respond` function sends a simple text to the browser of the client and reports
    that the incoming request is processed. The most interesting function is `handleRequest`,
    which is the entry point of our logic. To simulate the reading of a large file,
    we will create a `while` cycle for 5 seconds. Once we run the server, we will
    be able to make an HTTP request to `http://localhost:9000`. In order to demonstrate
    the single-thread behavior we will send two requests at the same time. These requests
    are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一行初始化的`http`模块是运行Web服务器所需的。`getTime`函数返回当前时间作为字符串，`respond`函数向客户端的浏览器发送一个简单的文本，并报告收到的请求已被处理。最有趣的功能是`handleRequest`，它是我们逻辑的入口点。为了模拟读取大文件，我们将创建一个持续5秒的`while`循环。一旦我们运行服务器，我们就可以向`http://localhost:9000`发送HTTP请求。为了演示单线程行为，我们将同时发送两个请求。这些请求如下：
- en: One request will be sent to `http://localhost:9000`, where the server will perform
    a synchronous operation that takes 5 seconds
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个请求将被发送到`http://localhost:9000`，服务器将执行一个需要5秒的同步操作
- en: The other request will be sent to `http://localhost:9000/immediately`, where
    the server should respond immediately
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个请求将被发送到`http://localhost:9000/immediately`，服务器应该立即响应
- en: 'The following screenshot is the output printed from the server, after pinging
    both the URLs:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是服务器打印出的输出，在ping了两个URL之后：
- en: '![Node.js fundamentals](img/00002.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js基础知识](img/00002.jpeg)'
- en: As we can see, the first request came at `16:58:30:434`, and its response was
    sent at `16:58:35:440`, that is, 5 seconds later. However, the problem is that
    the second request is registered when the first one finishes. That's because the
    thread belonging to Node.js was busy processing the `while` loop.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，第一个请求在`16:58:30:434`到达，其响应在`16:58:35:440`发送，即5秒后。然而，问题是第二个请求在第一个请求完成后被注册。这是因为属于Node.js的线程正忙于处理`while`循环。
- en: Of course, Node.js has a solution for the blocking I/O operations. They are
    transformed to asynchronous functions that accept callback. Once the operation
    finishes, Node.js fires the callback, notifying that the job is done. A huge benefit
    of this approach is that while it waits to get the result of the I/O, the server
    can process another request. The entity that handles the external events and converts
    them into callback invocations is called the `event` loop. The `event` loop acts
    as a really good manager and delegates tasks to various workers. It never blocks
    and just waits for something to happen; for example, a notification that the file
    is written successfully.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Node.js有针对阻塞I/O操作的解决方案。它们被转换为接受回调的异步函数。一旦操作完成，Node.js就会触发回调，通知任务已完成。这种方法的一个巨大好处是，在等待I/O结果的同时，服务器可以处理另一个请求。处理外部事件并将它们转换为回调调用的实体被称为`event`循环。`event`循环充当一个非常好的管理者，并将任务委托给各种工作者。它从不阻塞，只是等待事情发生；例如，文件成功写入的通知。
- en: 'Now, instead of reading a file synchronously, we will transform our brief example
    to use asynchronous code. The modified example looks like the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再同步读取文件，而是将我们的简短示例转换为使用异步代码。修改后的示例看起来如下代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `while` loop is replaced with the `setTimeout` invocation. The result of
    this change is clearly visible in the server''s output, which can be seen in the
    following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将`while`循环替换为`setTimeout`调用。这种更改的结果在服务器输出中非常明显，如下面的截图所示：
- en: '![Node.js fundamentals](img/00003.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js基础知识](img/00003.jpeg)'
- en: The first request still gets its response after 5 seconds. However, the second
    one is processed immediately.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个请求仍然在5秒后收到响应。然而，第二个请求立即被处理。
- en: Organizing your code logic in modules
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模块中组织你的代码逻辑
- en: If we write a lot of code, sooner or later, we will start realizing that our
    logic should be split into different modules. In most languages, this is done
    through classes, packages, or some other language-specific syntax. However, in
    JavaScript, we don't have classes natively. Everything is an object, and in practice,
    objects inherit other objects. There are several ways to achieve object-oriented
    programming within JavaScript. You can use prototype inheritance, object literals,
    or play with function calls. Thankfully, Node.js has a standardized way of defining
    modules. This is approached by implementing **CommonJS**, which is a project that
    specifies an ecosystem for JavaScript.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写了大量的代码，迟早我们会开始意识到我们的逻辑应该被分割成不同的模块。在大多数语言中，这是通过类、包或其他语言特定的语法来实现的。然而，在 JavaScript
    中，我们并没有原生的类。一切都是对象，在实践中，对象继承其他对象。在 JavaScript 中实现面向对象编程有几种方法。你可以使用原型继承、对象字面量或玩转函数调用。幸运的是，Node.js
    有一个标准化的模块定义方式。这是通过实现 **CommonJS** 来实现的，这是一个指定 JavaScript 生态系统项目的项目。
- en: So, you have some logic, and you want to encapsulate it by providing useful
    API methods. If you reach that moment, you are definitely in the right direction.
    This is really important, and maybe it is one of the most challenging aspects
    of programming nowadays. The ability to split our applications into different
    parts and delegate functions to them is not always an easy task. Very often, this
    is undervalued, but it's the key to good architecture. If a module contains a
    lot of dependencies, operates with different data storages, or has several responsibilities,
    then we are doing something wrong. Such code cannot be tested and is difficult
    to maintain. Even if we take care about these two things, it is still difficult
    to extend the code and continue working with it. That's why it's good to define
    different modules for different functionalities. In the context of Node.js, this
    is done via the `exports` keyword, which is a reference to `module.exports`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你有一些逻辑，并且你希望通过提供有用的 API 方法来封装它。如果你达到了那个时刻，你肯定是在正确的方向上。这真的很重要，也许它是当今编程中最具挑战性的方面之一。将我们的应用程序分割成不同的部分并将函数委托给它们的能力并不总是容易的任务。很多时候，这被低估了，但它却是良好架构的关键。如果一个模块包含大量的依赖项、操作不同的数据存储或具有多个职责，那么我们就是在做错事。这样的代码无法被测试，并且难以维护。即使我们注意到了这两件事，扩展代码并继续与之工作仍然很困难。这就是为什么为不同的功能定义不同的模块是很好的。在
    Node.js 的上下文中，这是通过 `exports` 关键字来实现的，它是 `module.exports` 的引用。
- en: Building a car construction application
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建汽车构造应用
- en: 'Let''s elucidate the process with a simple example. Assume that we are building
    an application that constructs a car. We need one main module (`car`) and a few
    other modules, which are responsible for the different parts of the car (`wheels`,
    `windows`, `doors`, and so on). Let''s start with the definition of a module representing
    the wheels of the car, with the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来阐明这个过程。假设我们正在构建一个构建汽车的应用程序。我们需要一个主模块（`car`）和几个其他模块，这些模块负责汽车的不同部分（`wheels`、`windows`、`doors`
    等）。让我们从定义一个代表汽车轮子的模块开始，以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code could be the content of `wheels.js`. It contains two methods.
    The first method, `init`, should be called first and accepts one setting, that
    is, the type of the wheels'' tires. The second method simply outputs some information.
    In our main file, `car.js`, we have to get an instance of the wheels and use the
    provided API methods. This can be done as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可能是 `wheels.js` 的内容。它包含两个方法。第一个方法 `init` 应该首先被调用，接受一个设置，即轮子轮胎的类型。第二个方法简单地输出一些信息。在我们的主文件
    `car.js` 中，我们必须获取轮子的实例并使用提供的 API 方法。这可以按照以下方式完成：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you run the application with `node car.js`, you will get the following
    output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `node car.js` 运行应用时，你会得到以下输出：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, everything that you want to expose to the outside world should be attached
    to the `export` object. Note that `typeOfTires` is a local variable for the module.
    It is available only in `wheels.js` and not in `car.js`. It''s also a common practice
    to apply an object or a function to the `exports` object directly, as shown in
    the following code for example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你希望暴露给外部世界的所有内容都应该附加到 `export` 对象上。请注意，`typeOfTires` 是模块的局部变量。它仅在 `wheels.js`
    中可用，而在 `car.js` 中不可用。将对象或函数直接应用于 `exports` 对象也是常见的做法，以下代码示例展示了这一点：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In JavaScript, everything is an object and that object has a `prototype` property.
    It's like a storage that keeps the available variables and methods. The `prototype`
    property is heavily used during inheritance in JavaScript, because it provides
    a mechanism for transferring logic.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，一切都是对象，并且这个对象有一个`prototype`属性。它就像一个存储可用变量和方法的地方。`prototype`属性在JavaScript的继承中得到了广泛的使用，因为它提供了一种传递逻辑的机制。
- en: 'We will also clear the difference between `module.exports` and `exports`. As
    you can see, in `wheels.js`, we assigned two functions, `init` and `info`, directly
    to the `exports` global object. In fact, that object is a reference to `module.exports`,
    and every function or variable attached to it is available to the outside world.
    However, if we assign a new object or function directly to the `export` object,
    we should not expect to get an access to it after requiring the file. This should
    be done with `module.exports`. Let''s take the following code as an example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将澄清`module.exports`和`exports`之间的区别。正如你所见，在`wheels.js`中，我们直接将两个函数`init`和`info`赋值给了`exports`全局对象。实际上，这个对象是`module.exports`的引用，并且任何附加到它的函数或变量都可以对外部世界可用。然而，如果我们直接将一个新的对象或函数赋值给`export`对象，我们不应该期望在文件导入后能够访问它。这应该使用`module.exports`来完成。以下代码将作为一个例子：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s say that both the files, `app.js` and `file.js`, are in the same directory.
    If we run `node app.js`, we will get `10 20` as the result. However, consider
    what would happen if we changed the code of `file.js` to the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`app.js`和`file.js`两个文件都在同一个目录下。如果我们运行`node app.js`，我们将得到`10 20`作为结果。然而，考虑如果我们把`file.js`的代码改为以下代码会发生什么：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, in this case, we would get `10 undefined` as the result. That's because
    `module.exports` has a new object assigned and `exports` still points to the old
    one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会得到`10 undefined`作为结果。这是因为`module.exports`被分配了一个新的对象，而`exports`仍然指向旧的。
- en: Using the car's engine
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用汽车的引擎
- en: 'Let''s say that the module in `engine.js` controls the car. It has methods
    for moving the car forward and backward. It is a little different because the
    logic is defined in a separate class and that class is directly passed as a value
    of `module.exports`. In addition, as we are exporting a function, and not just
    an object, our instance should be created with the `new` keyword. We will see
    how the car''s engine works with the `new` keyword as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`engine.js`中的模块控制着汽车。它有使汽车前进和后退的方法。它有一点不同，因为逻辑是在一个单独的类中定义的，并且这个类直接作为`module.exports`的值传递。此外，因为我们正在导出一个函数，而不是一个对象，所以我们的实例应该使用`new`关键字来创建。我们将在以下代码中看到如何使用`new`关键字来使汽车引擎工作：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is a significant difference between using JavaScript functions as constructors
    and calling them directly. When we call the function as a constructor, we get
    a new object with its own prototype. If we miss the `new` keyword, the value which
    we get at the end is the result of the function's invocation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript函数作为构造函数和直接调用它们之间存在显著差异。当我们以构造函数的方式调用函数时，我们会得到一个具有自己原型的新的对象。如果我们遗漏了`new`关键字，最终得到的值就是函数调用的结果。
- en: Node.js caches the modules returned by the `require` method. It's done to prevent
    the blocking of the `event` loop and increase the performance. It's a synchronous
    operation, and if there is no cache, Node.js will have to do the same job repeatedly.
    It's also good to know that we can call the method with just a folder name, but
    there should be a `package.json` or an `index.js` file inside the directory. All
    these mechanisms are described well in the official documentation of Node.js at
    [http://nodejs.org/](http://nodejs.org/). What is important to note here is that
    the environment encourages modular programming. All we need is native implementation
    into the system, and we don't have to use a third-party solution that provides
    modularity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js缓存了`require`方法返回的模块。这样做是为了防止阻塞`event`循环并提高性能。这是一个同步操作，如果没有缓存，Node.js将不得不重复做同样的工作。还应该知道，我们可以仅使用文件夹名称来调用该方法，但目录内应该有一个`package.json`或`index.js`文件。所有这些机制都在Node.js的官方文档[http://nodejs.org/](http://nodejs.org/)中得到了很好的描述。这里需要注意的是，环境鼓励模块化编程。我们需要的只是将原生实现集成到系统中，我们不需要使用提供模块化的第三方解决方案。
- en: 'Like in the client-side code, every Node.js module can be extended. Again,
    as we are writing the code in plain JavaScript, we can use the well-known approaches
    for inheritance. For example, take a look at the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像客户端代码一样，每个Node.js模块都可以被扩展。再次强调，由于我们正在用纯JavaScript编写代码，我们可以使用众所周知的继承方法。例如，看看以下代码：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Node.js even offers a helper method for this purpose. Let''s say that we want
    to extend our `engine.js` class and add API methods to move the car in the left
    and right directions. We can do this with the following piece of code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js甚至为此提供了一个辅助方法。假设我们想要扩展我们的`engine.js`类，并添加API方法来控制汽车向左和向右移动。我们可以用以下代码片段来实现：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first line gets a reference to the Node.js native `utils` module. It''s
    full of useful functions. The fourth line is where the magic happens. By calling
    the `inherits` method, we have actually set a new prototype of our `Class` object.
    Keep in mind that every new method should use the already applied prototype. That''s
    why the `left` and `right` methods are defined after the inheritance. At the end,
    our car will move in four directions, as shown in the following code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行获取Node.js原生`utils`模块的引用。它包含许多有用的函数。第四行是魔法发生的地方。通过调用`inherits`方法，我们实际上为我们的`Class`对象设置了一个新的原型。请记住，每个新方法都应该使用已经应用的原型。这就是为什么`left`和`right`方法在继承之后定义。最后，我们的汽车将能够向四个方向移动，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Understanding inter-module communication
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块间通信
- en: 'We''ve found out how to put our code logic into modules. Now, we need to know
    how to make them communicate with each other. Very often, people describe Node.js
    as an event-driven system. It''s also called non-blocking because as we have seen
    earlier in the chapter, it can accept a new request even before the previous request
    is fully complete. That''s very efficient and highly scalable. The events are
    very powerful and are good means to inform the other modules of what is going
    on. They bring about encapsulation, which is very important in modular programming.
    Let''s add some events to the car example we discussed earlier. Let''s say that
    we have air conditioning, and we need to know when it is started. The implementation
    of such logic consists of two parts. The first one is the air conditioning module.
    It should dispatch an event that indicates the start of the action. The second
    part is the other code that listens for that event. We will create a new file
    called `air.js` containing the logic responsible for the air conditioning, as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了如何将我们的代码逻辑放入模块中的方法。现在，我们需要知道如何使它们相互通信。人们经常将Node.js描述为一个事件驱动系统。它也被称作非阻塞的，因为我们之前在章节中看到，它可以在上一个请求完全完成之前接受新的请求。这非常高效且具有高度的可扩展性。事件非常强大，是通知其他模块正在发生什么的良好手段。它们带来了封装，这在模块化编程中非常重要。让我们给之前讨论的汽车示例添加一些事件。假设我们有空调，我们需要知道它何时启动。这种逻辑的实现包括两个部分。第一个是空调模块。它应该派发一个表示动作开始的事件。第二个部分是其他监听该事件的代码。我们将创建一个名为`air.js`的新文件，其中包含负责空调的逻辑，如下所示：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our class extends a Node.js module called `EventEmitter`. It contains methods
    such as `emit` or `on`, which help us to establish event-based communication.
    There is only one custom method defined: `start`. It simply dispatches an event
    that indicates that the air conditioning is turned on. The following code shows
    how we can attach a listener:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的这个类扩展了名为`EventEmitter`的Node.js模块。它包含`emit`或`on`等方法，这些方法帮助我们建立基于事件的通信。定义了一个自定义方法：`start`。它简单地派发一个表示空调已开启的事件。以下代码展示了我们如何附加一个监听器：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A new instance of the `AirConditioning` class is created. We attached an event
    listener and fired the `start` method. The handler is called, and the message
    is printed to the console. The example is a simple one but shows how two modules
    communicate. It's a really powerful approach because it offers encapsulation.
    The module knows its responsibilities and is not interested in the operations
    in the other parts of the system. It simply does its job and dispatches notifications
    (events). For example, in the previous code, the `AirConditioning` class doesn't
    know that we will output a message when it is started. It only knows that one
    particular event should be dispatched.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个 `AirConditioning` 类的新实例。我们附加了一个事件监听器并调用了 `start` 方法。处理程序被调用，并将消息打印到控制台。这个例子很简单，但展示了两个模块如何通信。这是一个非常强大的方法，因为它提供了封装。模块知道自己的职责，并且对系统其他部分的操作不感兴趣。它只是完成自己的工作并派发通知（事件）。例如，在前面的代码中，`AirConditioning`
    类不知道我们在它启动时会输出一条消息。它只知道应该派发一个特定的事件。
- en: 'Very often, we need to send data during the emitting of an event. This is really
    easy. We just have to pass another parameter along with the name of the event.
    Here is how we send a `status` property:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的情况是在事件发射期间发送数据。这非常简单。我们只需在事件名称旁边传递另一个参数即可。以下是如何发送 `status` 属性的示例：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The object attached to the event contains some information about the air conditioning
    module. The same object will be available in the listener of the event. The following
    code shows us how to get the value of the `status` variable mentioned previously:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到事件的对象包含有关空调模块的一些信息。相同的对象将在事件监听器中可用。以下代码展示了如何获取之前提到的 `status` 变量的值：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is a design pattern that illustrates the preceding process. It's called
    the **Observer**. In the context of that pattern, our air conditioning module
    is called **subject**, and the car module is called the observer. The subject
    broadcasts messages or events to its observers, notifying them that something
    has changed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个设计模式可以说明上述过程。它被称为 **观察者**。在该模式的上下文中，我们的空调模块被称为 **主题**，而汽车模块被称为观察者。主题向其观察者广播消息或事件，通知他们有变化发生。
- en: If we need to remove a listener, Node.js has a method for that called `removeListener`.
    We can even allow a specific number of observers using `setMaxListeners`. Overall,
    the events are one of the best ways to wire your logical parts. The main benefit
    is that you isolate the module, but it is still highly communicative with the
    rest of your application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要移除一个监听器，Node.js 提供了一个名为 `removeListener` 的方法。我们甚至可以使用 `setMaxListeners`
    允许特定数量的观察者。总的来说，事件是连接你的逻辑部分的最佳方式之一。主要好处是你可以隔离模块，但仍然与你的应用程序的其他部分保持高度通信。
- en: Asynchronous programming
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: 'As we already learned, in nonblockingenvironments, such as Node.js, most of
    the processes are asynchronous. A request comes to our code, and our server starts
    processing it but at the same time continues to accept new requests. For example,
    the following is a simple file reading:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，在非阻塞环境中，例如 Node.js，大多数过程都是异步的。一个请求到达我们的代码，我们的服务器开始处理它，但与此同时继续接受新的请求。例如，以下是一个简单的文件读取操作：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `readFile` method accepts two parameters. The first one is a path to the
    file we want to read, and the second one is a function that will be called when
    the operation finishes. The callback is fired even if the reading fails. Additionally,
    as everything can be done via that asynchronous matter, we may end up with a very
    long callback chain. There is a term for that—callback hell. To elucidate the
    problem, we will extend the previous example and do some operations with the file''s
    content. In the following code, we are nesting several asynchronous operations:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile` 方法接受两个参数。第一个参数是我们想要读取的文件的路径，第二个参数是在操作完成时将被调用的函数。即使读取失败，回调也会被触发。此外，由于所有操作都可以通过异步方式完成，我们可能会遇到一个非常长的回调链。这有一个术语，称为回调地狱。为了阐明这个问题，我们将扩展前面的示例并执行一些文件内容操作。在下面的代码中，我们嵌套了几个异步操作：'
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, our code looks bad. It''s difficult to read and follow. There
    are a dozen instruments that can help us to avoid such situations. However, we
    can fix the problem ourselves. The very first step to do is to spot the issue.
    If we have more than four or five nested callbacks, then we definitely should
    refactor our code. There is something very simple, which normally helps, that
    makes the code **shallow**. The previous code could be translated to a more friendly
    and readable format. For example, see the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的代码看起来很糟糕。它难以阅读和跟踪。有十几种工具可以帮助我们避免这种情况。然而，我们可以自己解决这个问题。首先要做的是发现问题。如果我们有四个或五个以上的嵌套回调，那么我们绝对应该重构我们的代码。有一种非常简单的方法，通常很有帮助，可以使代码**扁平化**。前面的代码可以转换为一个更友好、更易读的格式。例如，请看以下代码：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Most of the callbacks are just defined separately. It is clear what is going
    on because the functions have descriptive names. However, in more complex situations,
    this technique may not work because you will need to define a lot of methods.
    If that''s the case, then it is good to combine the functions in an external module.
    The previous example can be transformed to a module that accepts the name of a
    file and the callback function. The module is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数回调函数都是单独定义的。由于函数具有描述性的名称，因此可以清楚地了解正在发生的事情。然而，在更复杂的情况下，这种技术可能不起作用，因为你需要定义很多方法。如果是这样的话，那么将函数组合在外部模块中会更好。前面的例子可以转换为一个接受文件名和回调函数的模块。该模块如下所示：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You still have a callback, but it looks like the helper methods are hidden and
    only the main functionality is visible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然有一个回调，但它看起来像辅助方法被隐藏了，只有主要功能是可见的。
- en: 'Another popular instrument for dealing with asynchronous code is the **promises**
    paradigm. We already talked about events in JavaScript, and the promises are something
    similar to them. We are still waiting for something to happen and pass a callback.
    We can say that the promises represent a value that is not available at the moment
    but will be available in the future. The syntax of promises makes the asynchronous
    code look synchronous. Let''s see an example where we have a simple module that
    loads a Twitter feed. The example is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步代码的另一种流行方法是 **promises** 模式。我们已经讨论了 JavaScript 中的事件，而 promises 与它们类似。我们仍然在等待某个事件发生并传递一个回调。我们可以说，promises
    代表一个目前不可用但将来会可用的值。promises 的语法使异步代码看起来像是同步的。让我们看看一个例子，其中有一个简单的模块加载 Twitter 推文。例子如下：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We attached a listener for the `loaded` event and called the `getData` method,
    which connects to Twitter and fetches the information. The following code is what
    the same example will look like if the `TwitterFeed` class supports promises:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `loaded` 事件附加了一个监听器，并调用了 `getData` 方法，该方法连接到 Twitter 并获取信息。以下代码是如果 `TwitterFeed`
    类支持 promises 的相同示例：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `promise` object represents our data. The first function, which is sent
    to the `then` method, is called when the `promise` object succeeds. Note that
    the callbacks are registered after calling the `getData` method. This means that
    we are not rigid to actual process of getting the data. We are not interested
    in when the action occurs. We only care when it finishes and what its result is.
    We can spot a few differences from the event-based implementation. They are as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`promise` 对象代表我们的数据。第一个函数，它被发送到 `then` 方法，当 `promise` 对象成功时被调用。请注意，回调是在调用 `getData`
    方法之后注册的。这意味着我们不是严格绑定到获取数据的过程。我们不关心动作何时发生。我们只关心它何时完成以及它的结果是什么。我们可以从基于事件的实现中看到一些差异。如下所示：'
- en: There is a separate function for error handling.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个单独的函数用于错误处理。
- en: The `getData` method can be called before calling the `then` method. However,
    the same thing is not possible with events. We need to attach the listeners before
    running the logic. Otherwise, if our task is synchronous, the event may be dispatched
    before our listener attachment.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getData` 方法可以在调用 `then` 方法之前调用。然而，对于事件来说，这种情况是不可能的。我们需要在运行逻辑之前附加监听器。否则，如果我们的任务是同步的，事件可能会在我们附加监听器之前被分发。'
- en: The **promise** method can only succeed or fail once, while one specific event
    may be fired multiple times and its handlers can be called multiple times.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**promise** 方法只能成功或失败一次，而一个特定的事件可能会被触发多次，并且其处理程序可以被多次调用。'
- en: 'The promises get really handy when we chain them. To elucidate this, we will
    use the same example and save the tweets to a database with the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将承诺链在一起时，它们变得非常有用。为了阐明这一点，我们将使用相同的例子，并使用以下代码将推文保存到数据库中：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, if our successful callback returns a new promise, we can use `then` for
    the second time. Also, we have the possibility to set only one error handler.
    The `catch` method at the end is fired if some of the promises are rejected.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们的成功回调返回一个新的承诺，我们可以再次使用 `then`。此外，我们还可以只设置一个错误处理器。如果某些承诺被拒绝，最后的 `catch`
    方法会被触发。
- en: 'There are four states of every promise, and we should mention them here because
    it''s a terminology that is widely used. A promise could be in any of the following
    states:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个承诺都有四种状态，我们应该在这里提及它们，因为这是一个广泛使用的术语。一个承诺可能处于以下任何一种状态：
- en: '**Fulfilled**: A promise is in the fulfilled state when the action related
    to the promise succeeds'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现（Fulfilled）**：当与承诺相关的操作成功时，承诺处于实现状态'
- en: '**Rejected**: A promise is in the rejected state when the action related to
    the promise fails'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝（Rejected）**：当与承诺相关的操作失败时，承诺处于拒绝状态'
- en: '**Pending**: A promise is in the pending state if it hasn''t been fulfilled
    or rejected yet'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起（Pending）**：如果承诺尚未被实现或拒绝，它就处于挂起状态'
- en: '**Settled**: A promise is in a settled state when it has been fulfilled or
    rejected'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已解决（Settled）**：当承诺被实现或拒绝时，承诺处于已解决状态'
- en: 'The asynchronous nature of JavaScript makes our coding really interesting.
    However, it could sometimes lead to a lot of problems. Here is a wrap up of the
    discussed ideas to deal with the issues:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的异步特性使得我们的编码变得非常有趣。然而，它有时也可能导致很多问题。以下是对讨论的思路的总结，以处理这些问题：
- en: Try to use more functions instead of closures
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使用更多函数而不是闭包
- en: Avoid the pyramid-looking code by removing the closures and defining top-level
    functions
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移除闭包并定义顶层函数来避免金字塔状代码
- en: Use events
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件
- en: Use promises
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺
- en: Exploring middleware architecture
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索中间件架构
- en: 'The Node.js framework is based on the middleware architecture. That''s because
    this architecture brings modularity. It''s really easy to add or remove functionalities
    from the system without breaking the application because the different modules
    do not depend on each other. Imagine that we have several modules that are all
    stored in an array, and our application starts using them one by one. We are controlling
    the whole process, that is, the execution continues only if we want it to. The
    concept is demonstrated in the following diagram:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 框架基于中间件架构。这是因为这种架构带来了模块化。添加或删除系统功能非常容易，而不会破坏应用程序，因为不同的模块之间不相互依赖。想象一下，我们有几个模块都存储在一个数组中，我们的应用程序逐个使用它们。我们正在控制整个过程，也就是说，只有当我们想要时，执行才会继续。这个概念在以下图中得到了演示：
- en: '![Exploring middleware architecture](img/00004.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![探索中间件架构](img/00004.jpeg)'
- en: '**Connect** ([https://github.com/senchalabs/connect](https://github.com/senchalabs/connect))
    is one of the first frameworks that implements this pattern. In the context of
    Node.js, the middleware is a function that accepts the request, response, and
    the next callbacks. The first two parameters represent the input and output of
    the middleware. The last one is a way to pass the flow to the next middleware
    in the list. The following is a short example of this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Connect** ([https://github.com/senchalabs/connect](https://github.com/senchalabs/connect))
    是最早实现这种模式的框架之一。在 Node.js 的上下文中，中间件是一个接受请求、响应和下一个回调函数的函数。前两个参数代表中间件的输入和输出。最后一个参数是一种将流程传递给列表中下一个中间件的方式。以下是一个简短的例子：'
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The request and response objects are identical in every function. Thus, the
    middleware share the same scope. At the same time, they are completely independent.
    This pattern provides a really flexible development environment. We can combine
    modules that do different tasks written by different developers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应对象在每一个函数中都是相同的。因此，中间件共享相同的范围。同时，它们是完全独立的。这种模式提供了一个非常灵活的开发环境。我们可以组合由不同开发者编写的执行不同任务的模块。
- en: Composition versus inheritance
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合与继承
- en: 'In the previous section, we learned how to create modules, how to make them
    communicate, and how to use them. Let''s talk a bit about how to architect modules.
    There are dozens of ways to build a good application. There are also some great
    books written only on this subject, but we will focus on two of the most commonly
    used techniques: composition and inheritance. It''s really important to understand
    the difference between the two. They both have pros and cons. In most of the cases,
    their usage depends on the current project.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何创建模块，如何使它们相互通信，以及如何使用它们。让我们谈谈如何设计模块。构建一个优秀应用程序的方法有数十种。也有一些关于这个主题的杰出书籍，但我们将关注两种最常用的技术：组合和继承。理解这两者之间的区别非常重要。它们都有优点和缺点。在大多数情况下，它们的用法取决于当前项目。
- en: 'The `car` class from the previous sections is a perfect example of composition.
    The functionalities of the `car` object are built by other small objects. So,
    the main module actually delegates its jobs to other classes. For example, the
    wheels or the air conditioning of the car are controlled by externally defined
    modules:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的`car`类是组合的完美例子。`car`对象的功能是由其他小对象构建的。因此，主模块实际上是将任务委托给其他类。例如，汽车的车轮或空调是由外部定义的模块控制的：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For the outside world, the car has only one method: `run`. However, what happens
    is that we perform three different operations, and they are defined in other modules.
    Often, the composition is preferred over the inheritance because while using this
    approach, we can easily add as many modules as we want. It''s also interesting
    that we cannot only include modules but also other compositions.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外界来说，汽车只有一个方法：`run`。然而，实际上我们执行了三种不同的操作，它们定义在其他模块中。通常，组合比继承更受欢迎，因为在使用这种方法时，我们可以轻松地添加我们想要的任何数量的模块。而且，我们不仅可以包含模块，还可以包含其他组合。
- en: 'On the other side is the inheritance. The following code is a typical example
    of inheritance:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面是继承。以下代码是继承的典型示例：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code implies that our class needs to be an event emitter, so it simply
    inherits that functionality from another class. Of course, in this case, we can
    still use composition and create an instance of the `EventEmitter` class, define
    methods such as `on` and `dispatch`, and delegate the real work. However, here
    it is much better to use inheritance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着我们的类需要是一个事件发射器，因此它简单地从另一个类继承该功能。当然，在这种情况下，我们仍然可以使用组合并创建`EventEmitter`类的实例，定义如`on`和`dispatch`等方法，并将实际工作委托出去。然而，在这种情况下使用继承会更好。
- en: 'The truth is somewhere in between—the composition and the inheritance should
    play together. They are really great tools, but each of them has its own place.
    It''s not only black and white, and sometimes it is difficult to find the right
    direction. There are three ways to add behavior to our objects. They are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 事实真相介于两者之间——组合和继承应该协同工作。它们确实是伟大的工具，但每个都有其合适的位置。这不仅仅是黑白分明，有时很难找到正确的方向。有三种方法可以向我们的对象添加行为。如下所示：
- en: Writing the functionality into the objects directly
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将功能写入对象
- en: Inheriting the functionality from a class that already has the desired behavior
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从已经具有所需行为的类继承功能
- en: Creating a local instance of an object that does the job
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个执行工作的对象本地实例
- en: The second one is related to inheritance and the last one is actually a composition.
    By using composition, we are adding a few more abstraction layers, which is not
    a bad thing, but it could lead to unnecessary complexity.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种与继承相关，最后一种实际上是组合。通过使用组合，我们添加了更多的抽象层，这本身并不是坏事，但它可能导致不必要的复杂性。
- en: Managing dependencies
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖
- en: Dependency management is one of the biggest problems in complex software. Often,
    we build our applications around third-party libraries or custom-made modules
    written for other projects. We do this because we don't want to reinvent the wheel
    every time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理是复杂软件中最大的问题之一。我们经常围绕第三方库或为其他项目编写的自定义模块构建我们的应用程序。我们这样做是因为我们不希望每次都重新发明轮子。
- en: 'In the previous sections of this chapter, we used the `require` global function.
    That''s how Node.js adds dependencies to the current module. A functionality written
    in one JavaScript file is included in another file. The good thing is that the
    logic in the imported file lives in its own scope, and only the publicly exported
    functions and variables are visible to the host. With this behavior, we are able
    to separate our logic modules into Node.js packages. There is an instrument that
    controls such packages. It''s called **Node Package Manager** (**npm**) and is
    available as a command-line instrument. Node.js has become so popular mainly because
    of the existence of its package manager. Every developer can publish their own
    package and share it with the community. The good versioning helps us to bind
    our applications to specific versions of the dependencies, which means that we
    can use a module that depends on other modules. The main rule to make this work
    is to add a `package.json` file to our project. We will add this file with the
    following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们使用了 `require` 全局函数。这就是 Node.js 将依赖项添加到当前模块的方式。一个 JavaScript 文件中编写的功能被包含在另一个文件中。好事是导入文件中的逻辑存在于自己的作用域中，并且只有公开导出的函数和变量对宿主可见。通过这种行为，我们能够将我们的逻辑模块分离成
    Node.js 包。有一个工具可以控制这样的包。它被称为 **Node 包管理器** (**npm**)，它作为一个命令行工具提供。Node.js 的流行主要归功于其包管理器的存在。每个开发者都可以发布自己的包并与社区分享。良好的版本控制帮助我们绑定我们的应用程序到特定版本的依赖项，这意味着我们可以使用依赖于其他模块的模块。使这一切工作的主要规则是在我们的项目中添加一个
    `package.json` 文件。我们将使用以下代码添加此文件：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The content of the file should be valid JSON and should contain at least the
    `name` and `version` fields. The `name` property should also be unique, and there
    should not be any other module with the same name. The `dependencies` property
    contains all the modules and versions that we depend on. To the same file, we
    can add a lot of other properties. For example, information about the author,
    a description of the package, the license of the project, or even keywords. Once
    the module is registered in the registry, we can use it as a dependency. We just
    need to add it in our `package.json` file, and after we run `npm install`, we
    will be able to use it as a dependency. Since Node.js adopts the module pattern,
    we don't need instruments such as the dependency injection container or service
    locater.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容应该是有效的 JSON 格式，并且至少包含 `name` 和 `version` 字段。`name` 属性应该是唯一的，并且不应该有其他具有相同名称的模块。`dependencies`
    属性包含我们所依赖的所有模块和版本。对于同一个文件，我们可以添加很多其他属性。例如，关于作者的信息、包的描述、项目的许可证，甚至是关键词。一旦模块在注册表中注册，我们就可以将其用作依赖项。我们只需将其添加到我们的
    `package.json` 文件中，然后运行 `npm install`，我们就能将其用作依赖项。由于 Node.js 采用了模块模式，我们不需要像依赖注入容器或服务定位器这样的工具。
- en: 'Let''s write a `package.json` file for the car example used in the previous
    sections, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为之前章节中使用的汽车示例编写一个 `package.json` 文件，如下所示：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the most common programming paradigms in Node.js.
    We learned how Node.js handles parallel requests. We understood how to write modules
    and make them communicative. We saw the problems of the asynchronous code and
    their most popular solutions. At the end of the chapter, we talked about how to
    construct our application. With all this as a basis, we can start thinking about
    better programs. Software writing is not an easy task and requires strong knowledge
    and experience. The experience usually comes after years of coding; however, knowledge
    is something that we can get instantly. Node.js is a young technology; nonetheless,
    we are able to apply paradigms and concepts from client-side JavaScript and even
    other languages.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 Node.js 中最常用的编程范式。我们学习了 Node.js 如何处理并行请求。我们了解了如何编写模块并使它们具有通信能力。我们看到了异步代码的问题及其最流行的解决方案。在本章的结尾，我们讨论了如何构建我们的应用程序。有了所有这些作为基础，我们可以开始思考更好的程序。编写软件并不是一件容易的任务，需要强大的知识和经验。经验通常是在多年的编码之后获得的；然而，知识是我们可以立即获得的东西。Node.js
    是一种年轻的技术；尽管如此，我们能够应用来自客户端 JavaScript 以及其他语言的范式和概念。
- en: In the next chapter, we will see how to use one of the most popular frameworks
    for Node.js, that is, Express.js, and we will build a simple website.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用 Node.js 中最受欢迎的框架之一，即 Express.js，并构建一个简单的网站。
