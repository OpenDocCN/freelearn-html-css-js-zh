<html><head></head><body>
		<div><h1 id="_idParaDest-70" class="chapter-number"><a id="_idTextAnchor069"/>4</h1>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Behaving Properly – Pure Functions</h1>
			<p>In <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>, we considered functions as the critical elements in <strong class="bold">functional programming</strong> (<strong class="bold">FP</strong>), went into detail about arrow functions, and introduced some concepts, such as injection, callbacks, polyfilling, and stubbing. In this chapter, we’ll have the opportunity to revisit or apply some of those ideas.</p>
			<p>In this chapter, we will do the following:</p>
			<ul>
				<li>Consider the notion of <strong class="bold">purity</strong> and why we should care about <strong class="bold">pure functions</strong>—and <strong class="bold">impure functions</strong> as well!</li>
				<li>Examine the concept of <strong class="bold">referential transparency</strong></li>
				<li>Recognize the problems implied by side effects</li>
				<li>Show some advantages of pure functions</li>
				<li>Describe the main reasons behind impure functions</li>
				<li>Discover ways to minimize the number of impure functions</li>
				<li>Focus on ways of testing both pure and impure functions</li>
			</ul>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Pure functions</h1>
			<p>Pure functions<a id="_idIndexMarker202"/> behave the same way as mathematical functions and provide various benefits. A function is pure if it satisfies two conditions:</p>
			<ul>
				<li><strong class="bold">Given the same arguments, the function always calculates and returns the same result</strong>: This should be true no matter how many times it’s invoked or under which conditions you call it. This result cannot depend on any outside information or state, which could change during the program execution and cause it to return a different value. Nor can the function result depend on I/O results, random numbers, some other external variable, or a value that is not directly controllable.</li>
				<li><strong class="bold">When calculating its result, the function doesn’t cause any observable side effects</strong>: This includes output to I/O devices, the mutation of objects, changes to a<a id="_idIndexMarker203"/> program’s state outside of the function, and so on.</li>
			</ul>
			<p>You can simply say that pure functions don’t depend on (and don’t modify) anything outside their scope and always return the same result for the same input arguments.</p>
			<p>Another word used in this context is <strong class="bold">idempotency</strong>, but it’s not exactly the same. An idempotent function can be called as <a id="_idIndexMarker204"/>many times as desired and will always produce the same result. However, this doesn’t imply that the function is free from side effects.</p>
			<p>Idempotency is usually mentioned in the context of RESTful services. Let’s see a simple example showing the difference between purity and idempotency. A <code>PUT</code> call would cause a database record to be updated (a side effect), but if you repeat the call, the element will not be further modified, so the global state of the database won’t change any further.</p>
			<p>We might also invoke a software design principle and remind ourselves that a function should <em class="italic">do one thing, only one thing, and nothing but that thing</em>. If a function does something else and has some hidden functionality, then that dependency on the state will mean that we won’t be able to predict the function’s output and will make things harder for us as developers.</p>
			<p>Let’s look into these conditions in more detail.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Referential transparency</h2>
			<p>In mathematics, referential transparency<a id="_idIndexMarker205"/> is the property that lets you replace an expression with its value without changing the results of whatever you are doing. The counterpart of referential transparency is, appropriately<a id="_idIndexMarker206"/> enough, <strong class="bold">referential opacity</strong>. A referentially opaque function cannot guarantee that it will always produce the same result, even when called with the same arguments.</p>
			<p>To give a simple example, let’s consider what <a id="_idIndexMarker207"/>happens with an optimizing compiler that performs <strong class="bold">constant folding</strong>. Suppose you have a sentence like this:</p>
			<pre class="source-code">
const x = 1 + 2 * 3;</pre>
			<p>The compiler might optimize the code to the following by noting that <code>2*3</code> is a constant value:</p>
			<pre class="source-code">
const x = 1 + 6;</pre>
			<p>Even better, a new round of optimization could avoid the sum altogether:</p>
			<pre class="source-code">
const x = 7;</pre>
			<p>To save execution time, the compiler is taking advantage of the fact that all mathematical expressions and functions are (by definition) referentially transparent.</p>
			<p>On the other hand, if the compiler cannot predict the output of a given expression, it won’t be able to optimize the code in any fashion, and the calculation will have to be done at runtime.</p>
			<p>(TypeScript does a similar type analysis, and given the original <code>const x = 1 + 2 * 3</code> line, it would correctly decide that <code>x</code> is of type <code>number</code>.)</p>
			<p class="callout-heading">Of lambdas and betas</p>
			<p class="callout">In lambda calculus, if you replace the value of an expression involving a function with the calculated value for the function, then that <a id="_idIndexMarker208"/>operation is called a <strong class="bold">β (beta) reduction</strong>. Note that you can only do this safely with referentially transparent functions.</p>
			<p>All arithmetical expressions (involving both mathematical operators and functions) are referentially transparent: <code>22*9</code> can always be replaced by <code>198</code>. Expressions involving I/O are not transparent, given that their results cannot be known until executed. For the same reason, expressions involving date- and time-related functions or random numbers are also not transparent.</p>
			<p>Concerning JavaScript functions you can produce, it’s pretty easy to write some that won’t fulfill the referential transparency condition. In fact, a function is not even required to return a value, though the JavaScript interpreter will return <code>undefined</code> in that situation.</p>
			<p class="callout-heading">A matter of distinction</p>
			<p class="callout">Some languages distinguish between functions, which are expected to return a value, and procedures, which do not return anything, but that’s not the case with JavaScript. Some languages even provide the means to ensure that functions are referentially transparent.</p>
			<p>If you wanted to, you could classify functions as follows:</p>
			<ul>
				<li><strong class="bold">Pure functions</strong>: These return a <a id="_idIndexMarker209"/>value that depends only on its arguments and have no side effects whatsoever.</li>
				<li><code>undefined</code>, but that’s not relevant here) but do produce some side effects.</li>
				<li><strong class="bold">Functions with side effects</strong>: This<a id="_idIndexMarker211"/> means that they return a value that may not only depend on the function arguments but also involve side effects.</li>
			</ul>
			<p>In FP, much emphasis is put on the first group: referentially transparent pure functions. A compiler can reason about the program behavior (and thus be able to optimize the generated code), and the programmer can more easily reason about the program and the relationship between its components. This, in turn, can help prove the correctness of an algorithm or optimize the code by replacing a function with an equivalent one.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Side effects</h2>
			<p>What are side effects? We can<a id="_idIndexMarker212"/> define these as a change in state or an interaction with outside elements (the user, a web service, another computer—whatever) that occurs during the execution of some calculations or a process.</p>
			<p>There’s a possible misunderstanding as to the scope of this meaning. In everyday speech, when you speak of side effects, it’s a bit like talking about collateral damage—some unintended consequences for a given action; however, in computing, we include every possible effect or change outside the function. If you write a function meant to perform a <code>console.log()</code> call to display a result, that would be considered a side effect, even if it’s exactly what you intended the function to do in the first place!</p>
			<p>In this section, we will look at the following:</p>
			<ul>
				<li>Common side effects in JavaScript programming</li>
				<li>The problems that global and inner states cause</li>
				<li>The possibility of functions mutating their arguments</li>
				<li>Some functions that are always troublesome</li>
			</ul>
			<h3>Usual side effects</h3>
			<p>In programming, there <a id="_idIndexMarker213"/>are (too many!) things that are considered side effects. In JavaScript programming, including both front- and backend coding, the more common ones you may find include the following:</p>
			<ul>
				<li>Changing global variables.</li>
				<li>Mutating objects received as arguments.</li>
				<li>Performing any I/O, such as showing an alert message or logging some text.</li>
				<li>Working with, or changing, the filesystem.</li>
				<li>Querying or updating a database.</li>
				<li>Calling a web service.</li>
				<li>Querying or modifying the DOM.</li>
				<li>Triggering any external process.</li>
				<li>Just calling another function that produces a side effect of its own. You could say that impurity is contagious: a function that calls an impure function automatically becomes impure on its own!</li>
			</ul>
			<p>With this definition, let’s start looking at what can cause functional impurity (or referential opaqueness).</p>
			<h3>Global state</h3>
			<p>Of all the preceding points, the <a id="_idIndexMarker214"/>most common reason for side effects is the usage of nonlocal variables that share a global state with other parts of the program. Since pure functions, by definition, always return the same output value given the same input arguments, if a function refers to anything outside its internal state, it automatically becomes impure. Furthermore—and this is a hindrance to debugging—to understand what a function has done, you must understand how the state got its current values, which means understanding all of the past history from your program: not easy!</p>
			<p>Let’s write a function to detect<a id="_idIndexMarker215"/> whether a person is a legal adult by checking whether they were born at least 18 years ago. (OK—that’s not precise enough because we are not considering the day and month of birth, but bear with me; the problem is elsewhere.) A version of an <code>isOldEnough()</code> function could be as follows:</p>
			<pre class="source-code">
// isOldEnough.ts
const <strong class="bold">limitYear = 2004</strong>; // only good for 2022!
const isOldEnough = (birthYear: number) =&gt;
  <strong class="bold">birthYear &lt;= limitYear</strong>;
console.log(isOldEnough(1960)); // true
console.log(isOldEnough(2010)); // false</pre>
			<p>The <code>isOldEnough()</code> function correctly detects whether a person is at least 18 years old, but it depends on an external variable—a variable good for 2022 only! Even though the function works, the implementation isn’t the best that it could possibly be. You cannot tell what the function does unless you know about the external variable and how it got its value. Testing is also hard; you must remember to create the global <code>limitYear</code> variable, or all your tests will fail.</p>
			<p>There is an exception to this rule. Check out the following case: is the following <code>circleArea()</code> function, which calculates the area of a circle given its radius, pure or not?</p>
			<pre class="source-code">
// area.ts
const PI = 3.14159265358979;
const circleArea = (r: number) =&gt; PI * r ** 2;</pre>
			<p>Even though the function is accessing an external state, the fact that <code>PI</code> is a constant (and thus cannot be modified) would allow us to substitute it inside <code>circleArea</code> with no functional change, and so we should accept that the function is pure. The function will always return the same value for the same argument and thus fulfills our purity requirements.</p>
			<p>If you were to use <code>Math.PI</code> instead of a constant as we defined in the code (a better idea, by the way) the constant cannot <a id="_idIndexMarker216"/>be changed, so the function would remain pure.</p>
			<p>Here, we have dealt with problems caused by the global state; let’s move on to the inner state.</p>
			<h3>Inner state</h3>
			<p>The notion is also <a id="_idIndexMarker217"/>extended to internal variables, in which a local state is stored and used for future calls. The external state is unchanged, but internal side effects imply future differences regarding what the function will return. Let’s imagine a <code>roundFix()</code> rounding function that considers whether it has been rounding up or down too much so that the next time, it will round the other way, bringing the accumulated difference closer to zero. Our function will have to accumulate the effects of previous roundings to decide how to proceed next. The implementation could be as follows:</p>
			<pre class="source-code">
// roundFix.ts
const roundFix = (function () {
  let accum = 0;
  return (n: number): number =&gt; {
    // reals get rounded up or down
    // depending on the sign of accum
    const nRounded =
      accum &gt; 0 ? Math.ceil(n) : Math.floor(n);
    console.log(
      "accum",
      accum.toFixed(5),
      " result",
      nRounded
    );
    accum += n - nRounded;
    return nRounded;
  };
})();</pre>
			<p>Some comments <a id="_idIndexMarker218"/>regarding this function:</p>
			<ul>
				<li>The <code>console.log()</code> call is just for the sake of this example; it wouldn’t be included in the real-world function. It lists the accumulated difference up to the point and the result it will return: the given number rounded up or down.</li>
				<li>We are using the IIFE pattern from the <code>myCounter()</code> example in the <em class="italic">Immediate invocation </em>section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Starting Out with Functions,</em> to get a hidden internal variable.</li>
				<li>The <code>nRounded</code> calculation could also be written as <code>Math[accum &gt; 0 ? "ceil": "floor"](n)</code>—we test <code>accum</code> to see which method to invoke (<code>"ceil"</code> or <code>"floor"</code>) and then use the <code>Object["method"]</code> notation to indirectly invoke <code>Object.method()</code>. The way we used it, I think, is more clear, but I just wanted to give you a heads-up in case you happen to find this other coding style.</li>
			</ul>
			<p>Running this function with just two values (recognize them?) shows that results are not always the same for a given input. The <code>result</code> part of the console log shows how the value got rounded, up or down:</p>
			<pre class="source-code">
roundFix(3.14159); // accum  0.00000  result 3
roundFix(2.71828); // accum  0.14159  result 3
roundFix(2.71828); // accum -0.14013  result 2
roundFix(3.14159); // accum  0.57815  result 4
roundFix(2.71828); // accum -0.28026  result 2
roundFix(2.71828); // accum  0.43802  result 3
roundFix(2.71828); // accum  0.15630  result 3</pre>
			<p>The first time around, <code>accum</code> is zero, so 3.14159 gets rounded down, and <code>accum</code> becomes 0.14159 in our favor. The second time, since <code>accum</code> is positive (meaning that we have been rounding in our favor), 2.71828 gets rounded up to 3, and now <code>accum</code> becomes negative. The third time, the same 2.71828 value gets rounded down to 2 because the accumulated difference was negative—we got different values for the same input! The rest of the example is similar; you can get the same value rounded up or down, depending on the accumulated differences, because the function’s result depends on its inner state.</p>
			<p class="callout-heading">Why not OOP?</p>
			<p class="callout">This usage of the internal state is why many FP programmers think that using objects is potentially flawed. In OOP, we developers are used to storing information (attributes) and using them for future calculations; however, this usage is considered impure insofar as repeated method calls may return different values, although the same arguments are being passed.</p>
			<p>We have now dealt <a id="_idIndexMarker219"/>with the problems caused by both global and inner states, but there are still more possible side effects. For example, what happens if a function changes the values of its arguments? Let’s consider this next.</p>
			<h3>Argument mutation</h3>
			<p>You also need<a id="_idIndexMarker220"/> to be aware of the possibility that an impure function will modify its arguments. In JavaScript, arguments are passed by value, except for arrays and objects, which are passed by reference. This implies that any modification to the function’s parameters will affect an actual modification of the original object or array. This can be further obscured by the fact that several <code>Math.max()</code> with no further ado). A short implementation could be as follows:</p>
			<pre class="source-code">
// maxStrings.ts
const maxStrings = (a: string[]) =&gt; <strong class="bold">a.sort().pop()</strong>;
const countries = [
  "Argentina",
  "Uruguay",
  "Brasil",
  "Paraguay",
];
console.log(maxStrings(countries)); // <strong class="bold">"Uruguay"</strong></pre>
			<p>The function<a id="_idIndexMarker222"/> does provide the correct result (and if you worry about foreign languages, we already saw a way around that in the <em class="italic">Injection – sorting it out</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Starting Out with Functions</em>), but it has a defect. Let’s see what happened with the original array:</p>
			<pre class="source-code">
console.log(countries);
// [<strong class="bold">"Argentina", "Brasil", "Paraguay"</strong>]</pre>
			<p>Oops—the original array was modified; this is a side effect by definition! (TypeScript would have helped detect this error if we had only written a complete type definition for <code>maxStrings()</code>; see <em class="italic">Question 4.2</em> for details.) If you were to call <code>maxStrings(countries)</code> again, then instead of returning the same result as before, it would produce another value; clearly, this is not a pure function.</p>
			<p>In this case, a quick solution is to work on a copy of the array, and we can use the spread operator to help. Still, we’ll be dealing with more ways of avoiding these sorts of problems in <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>:</p>
			<pre class="source-code">
// continued...
const maxStrings2 = (a: string[]) =&gt; <strong class="bold">[...a].sort().pop()</strong>;
let countries = [
  "Argentina",
  "Uruguay",
  "Brasil",
  "Paraguay",
];
console.log(maxStrings2(countries));
// "Uruguay"
console.log(countries);
// ["Argentina", "Uruguay", "Brasil", "Paraguay"]</pre>
			<p>So now, we have found <a id="_idIndexMarker223"/>yet another cause for side effects: functions that modify their arguments. A final case to consider is functions that just have to be impure!</p>
			<h3>Troublesome functions</h3>
			<p>Finally, some <a id="_idIndexMarker224"/>functions also cause problems. For instance, <code>Math.random()</code> is impure: it doesn’t always return the same value, and it would defeat its purpose if it did! Furthermore, each call to the function modifies a global seed value, from which the next random value will be calculated.</p>
			<p class="callout-heading">Not really random</p>
			<p class="callout">The fact that random numbers are actually calculated by an internal function makes them not random at all; <em class="italic">pseudorandom</em> would be a better name for them. If you knew the used formula and the seed’s initial value, you’d be able to predict the following numbers, in a totally non-random way.</p>
			<p>For instance, consider the following function that generates random letters from <code>"A"</code> to <code>"Z"</code>:</p>
			<pre class="source-code">
// random.ts
const getRandomLetter = (): string =&gt; {
  const min = "A".charCodeAt(0);
  const max = "Z".charCodeAt(0);
  return String.fromCharCode(
    Math.floor(Math.random() * (1 + max - min)) + min
  );
};</pre>
			<p>The fact that it receives no arguments, but is expected to produce different results upon each call, clearly points out that this function is impure.</p>
			<p class="callout-heading">Random explanations</p>
			<p class="callout">Go to <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random</a> for an explanation of our <code>getRandomLetter()</code> function, and to <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt</a> for the <code>.</code><code>charCodeAt()</code> method.</p>
			<p>Impurity can be <a id="_idIndexMarker225"/>inherited by calling functions. If a function uses an impure function, it immediately becomes impure itself. We might want to use <code>getRandomLetter()</code> to generate random filenames with an optional given extension; our <code>getRandomFileName()</code> function could then be as follows:</p>
			<pre class="source-code">
// continued...
const getRandomFileName = (fileExtension = ""): string =&gt; {
  const NAME_LENGTH = 12;
  const namePart = new Array(NAME_LENGTH);
  for (let i = 0; i &lt; NAME_LENGTH; i++) {
    namePart[i] = getRandomLetter();
  }
  return namePart.join("") + fileExtension;
};</pre>
			<p>Because of its usage of <code>getRandomLetter()</code>, <code>getRandomFileName()</code> is also impure, though it performs as expected, correctly producing totally random filenames:</p>
			<pre class="source-code">
getRandomFileName(".pdf"); // "SVHSSKHXPQKG.pdf"
getRandomFileName(".pdf"); // "DCHKTMNWFHYZ.pdf"
getRandomFileName(".pdf"); // "GBTEFTVVHADO.pdf"
getRandomFileName(".pdf"); // "ATCBVUOSXLXW.pdf"
getRandomFileName(".pdf"); // "OIFADZKKNVAH.pdf"</pre>
			<p>Keep this function in mind; we’ll see some ways around the unit testing problem later in this chapter, and we’ll rewrite it a bit to help with that.</p>
			<p>The concern about impurity also extends to functions that access the current time or date because their results will depend on an external condition (namely, the time of day) that is part of the application’s <em class="italic">global</em> state. We could rewrite our <code>isOldEnough()</code> function to remove the dependency upon a global variable, but it wouldn’t help much. One attempt is as follows:</p>
			<pre class="source-code">
// isOldEnough.js
const isOldEnough2 = (birthYear: number): boolean =&gt;
  birthYear &lt;= <strong class="bold">new Date().getFullYear() - 18</strong>;
console.log(isOldEnough2(1960)); // true
console.log(isOldEnough2(2010)); // false</pre>
			<p>A problem has been removed—the new <code>isOldEnough2()</code> function is now safer. Also, as long as you don’t use it near midnight just before New Year’s Day, it will consistently return the same results, so you could say—paraphrasing the <em class="italic">Ivory Soap</em> slogan from the 19th century—that it’s about <em class="italic">99.44% pure</em>; however, an inconvenience remains: how would you test it? If you were to write some tests that worked fine today, they’d start to fail next year. We’ll have to work a bit to solve this, and we’ll see how later.</p>
			<p>Several other functions that are also impure are those that cause I/O. If a function gets input from a source (a web service, the user themself, a file, or some other source), then the result may obviously vary. You should also consider the possibility of an I/O error, so the very same function, calling the same service or reading the same file, might at some point fail for reasons outside its control (you should assume that your filesystem, database, socket, and so on could be unavailable, and thus a given function call might produce an error instead of the expected constant, unvarying, answer).</p>
			<p>Even having <a id="_idIndexMarker226"/>a pure output and a generally safe statement (such as a <code>console.log()</code>) that doesn’t change anything internally (at least in a visible way) causes some side effects because the user does see a change: namely, the produced output.</p>
			<p>Does this imply that we won’t ever be able to write a program that requires random numbers, handles dates, performs I/O, and also uses pure functions? Not at all—but it does mean that some functions won’t be pure, and they will have some disadvantages that we will have to consider; we’ll return to this in a bit.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Advantages of pure functions</h2>
			<p>The main advantage of using <a id="_idIndexMarker227"/>pure functions is that they don’t have any side effects. When you call a pure function, you don’t need to worry about anything other than which arguments you are passing to it. Also, more to the point, you can be sure that you will not cause any problems or break anything else because the function will only work with whatever you give it and not with outside sources. But this is not their only advantage. Let’s learn more in the following sections.</p>
			<h3>Order of execution</h3>
			<p>Another way of looking at what <a id="_idIndexMarker228"/>we have been saying in this chapter is to see pure functions as robust. You know that their execution—in whichever order—won’t ever impact the system. This idea can be extended further: you could evaluate pure functions in parallel, with the assurance that results wouldn’t vary from what you would get in a single-threaded execution. (JavaScript doesn’t provide Java-like threads, but we can make do, more or less, with workers. We’ll cover this topic in <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>.)</p>
			<p>Another consideration to keep in mind when you work with pure functions is that there’s no explicit need to specify the order in which they should be called. If you work with mathematics, an expression such as <code>f(2)+f(5)</code> is always the same as <code>f(5)+f(2)</code>; this is called the <em class="italic">commutative property</em>.</p>
			<p>However, when you deal with impure functions, that can be false, as shown in the following purposefully written tricky function:</p>
			<pre class="source-code">
// tricky.ts
let mult = 1;
const f = (x: number): number =&gt; {
  mult = -mult;
  return x * mult;
};
console.log(f(2) + f(5)); <strong class="bold">//  3</strong>
console.log(f(5) + f(2)); <strong class="bold">// -3</strong></pre>
			<p>With impure functions such as the previous one, you cannot assume that calculating <code>f(3)+f(3)</code> would produce the same result as <code>2*f(3)</code> or that <code>f(4)-f(4)</code> would actually be zero; check it out for yourself... Common mathematical properties, down the drain!</p>
			<p>Why should you care? When <a id="_idIndexMarker229"/>writing code, willingly or not, you always keep in mind those properties you learned about, such as the commutative property. So, while you might think that both expressions should produce the same result and code accordingly, you may be in for a surprise when using impure functions, with hard-to-find bugs that are difficult to fix.</p>
			<h3>Memoization</h3>
			<p>Since the output of a pure function<a id="_idIndexMarker230"/> for a given input is always the same, you can cache the function results and avoid a possibly costly recalculation. This process, which implies evaluating an expression only the first time and caching the result for later calls, is<a id="_idIndexMarker231"/> called <strong class="bold">memoization</strong>.</p>
			<p>We will return to this idea in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, but let’s look at an example done by hand. The Fibonacci sequence is always used for this example because of its simplicity and hidden calculation costs. This sequence is defined as follows:</p>
			<ul>
				<li>For <em class="italic">n</em>=0, fib(<em class="italic">n</em>)=0</li>
				<li>For <em class="italic">n</em>=1, fib(<em class="italic">n</em>)=1</li>
				<li>For <em class="italic">n</em>&gt;1, fib(<em class="italic">n</em>)=fib(<em class="italic">n</em>-2)+fib(<em class="italic">n</em>-1)</li>
			</ul>
			<p class="callout-heading">Fibonacci who?</p>
			<p class="callout">Fibonacci’s name actually comes from <em class="italic">filius Bonacci</em> or <em class="italic">son of Bonacci</em>. He is best known for having introduced the usage of digits 0-9 as we know them today, instead of the cumbersome Roman numbers. He derived the sequence named after him as the answer to a puzzle involving<a id="_idIndexMarker232"/> rabbits! You can read more about it, and Fibonacci’s life in general, at en.wikipedia.org/wiki/Fibonacci_number#History or <a href="http://plus.maths.org/content/life-and-numbers-fibonacci">plus.maths.org/content/life-and-numbers-fibonacci</a>.</p>
			<p>If you run the<a id="_idIndexMarker233"/> numbers, the sequence starts with 0, then 1, and from that point onward, each term is the sum of the two previous ones: 1 again, then 2, 3, 5, 8, 13, 21, 34, 55, and so on. Programming this series using recursion is simple; we’ll revisit this example in <a href="B19301_09.xhtml#_idTextAnchor172"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Functions</em>. The following code, a direct translation of the definition, will do—and see <em class="italic">Question 4.4</em> for an alternative:</p>
			<pre class="source-code">
// fibonacci.ts
const fib = (n: number): number =&gt; {
  if (n == 0) {
    return 0;
  } else if (n == 1) {
    return 1;
  } else {
    return fib(n - 2) + fib(n - 1);
  }
};
console.log(fib(10)); // 55, a bit slowly</pre>
			<p>If you try out this <a id="_idIndexMarker234"/>function for growing values of <code>n</code>, you’ll soon realize that there is a problem, and computation starts taking too much time. For example, I took timings (measured in milliseconds) at my machine and plotted them on a graph. Since the function is quite speedy, I had to run calculations 100 times for values of <code>n</code> between 0 and 40. Even then, the times for small values of <code>n</code> were really tiny; it was only from 25 onward that I got interesting numbers.</p>
			<p>The chart (see <em class="italic">Figure 4</em><em class="italic">.1</em>) shows exponential growth, which bodes ill:</p>
			<div><div><img src="img/Figure_4.1_B19301.jpg" alt="Figure 4.1 – Calculation times for the ﬁb() recursive function go up exponentially"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Calculation times for the ﬁb() recursive function go up exponentially</p>
			<p>If we draw a diagram of all the calls required to calculate <code>fib(6)</code>, you’ll notice the problem:</p>
			<div><div><img src="img/Figure_4.2_B19301.jpg" alt="Figure 4.2 – The calculations needed for ﬁb(6) show lots of duplication"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The calculations needed for ﬁb(6) show lots of duplication</p>
			<p>Each node represents a call to compute <code>fib(n)</code>. We note the value of <code>n</code> in the node. Every call, except those for <code>n</code>=0 or <code>n</code>=1, requires further calls, as you can see in <em class="italic">Figure 4</em><em class="italic">.2</em>.</p>
			<p>The reason for the <a id="_idIndexMarker235"/>increasing delays becomes obvious: for example, the calculation for <code>fib(2)</code> was repeated on four different occasions, and <code>fib(3)</code> was itself calculated three times. Given that our function is pure, we could have stored the calculated values to avoid running the numbers over and over again. A possible version, using a cache array for previously calculated values, would be as follows:</p>
			<pre class="source-code">
// continued...
<strong class="bold">const cache: number[] = []</strong>;
const fib2 = (n: number): number =&gt; {
  if (<strong class="bold">cache[n] === undefined</strong>) {
    if (n === 0) {
      cache[0] = 0;
    } else if (n === 1) {
      cache[1] = 1;
    } else {
      cache[n] = fib2(n - 2) + fib2(n - 1);
    }
  }
  <strong class="bold">return cache[n]</strong>;
};
console.log(fib2(10)); // 55, as before, but more quickly!</pre>
			<p>Initially, the <code>cache</code> array is empty. Whenever we need to calculate the value of <code>fib2(n)</code>, we check whether it was already calculated beforehand. If that’s not true, we do the calculation, but with a twist: instead of immediately returning the value, we first store it in the cache and then return it. This means that no calculation will be done twice: after we have calculated <code>fib2(n)</code> for a particular <code>n</code> value, future calls will not repeat the procedure and will return the earlier evaluated result.</p>
			<p>A few short notes:</p>
			<ul>
				<li>We memoized the function by hand, but we can do it with a higher-order function. We’ll see this later in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>. It is perfectly possible to memoize a function without having to change or rewrite it.</li>
				<li>Using a global <code>cache</code> variable isn’t a very good practice; we could have used an IIFE and a closure to hide <code>cache</code> from sight—do you see how? (Also, see <em class="italic">Question 4.3</em> at the end of this chapter.) The <code>myCounter()</code> example in the <em class="italic">Immediate invocation</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Starting Out with Functions,</em> shows how.</li>
				<li>Of course, you will be constrained by the available cache space, and it’s possible you could eventually crash your application by eating up all available RAM. Resorting to external memory (a database, a file, or a cloud solution) would probably eat up all the performance advantages of caching. There are some standard solutions (involving eventually deleting items from the cache), but they are beyond the scope of this book.</li>
			</ul>
			<p>Of course, you don’t <a id="_idIndexMarker236"/>need to do this for every pure function in your program. You’d do this sort of optimization only for frequently called functions that take a significant amount of time; otherwise, the added cache management time would cost more than what you expected to save!</p>
			<h3>Self-documentation</h3>
			<p>Pure<a id="_idIndexMarker237"/> functions have another advantage. Since everything the function needs to work with is given to it through its parameters, with no hidden dependency whatsoever, when you read its source code, you have all you need to understand its objective.</p>
			<p>An extra advantage: knowing that a function doesn’t access anything beyond its parameters makes you more confident in using it since you won’t be accidentally producing a side effect; the only thing the function will accomplish is what you already learned through its documentation.</p>
			<p>Unit tests (which we’ll cover in the next section) also work as documentation because they provide examples of what the function returns when given certain arguments. Most programmers will agree that the best kind of documentation is full of examples, and each unit <a id="_idIndexMarker238"/>test can be considered such a sample case.</p>
			<h3>Testing</h3>
			<p>Yet another advantage of<a id="_idIndexMarker239"/> pure functions—and one of the most important ones—has to do with unit testing. Pure functions have a single responsibility: producing their output in terms of their input. So, when you write tests for pure functions, your work is greatly simplified because there is no context to consider and no state to simulate.</p>
			<p>You can focus on providing inputs and checking outputs because all function calls can be reproduced in isolation, independently from the rest of the world.</p>
			<p>We have seen several aspects of pure functions. Let’s move on, learn about impure functions a bit, and finish by testing both pure and impure functions.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Impure functions</h1>
			<p>If you decided to entirely forgo all kinds of <a id="_idIndexMarker240"/>side effects, then your programs would only be able to work with hardcoded inputs and wouldn’t be able to show you the calculated results! Similarly, most web pages would be useless: you wouldn’t be able to make web service calls or update the DOM; you’d only have static pages. And your Node code would be really useless for server-side work, as it wouldn’t be able to perform any I/O.</p>
			<p>Reducing side effects is a good goal in FP, but we shouldn’t go overboard! So, let’s think of how to avoid using impure functions, if possible, and how to deal with them if not, looking for the best way to contain or limit their scope.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Avoiding impure functions</h2>
			<p>Earlier in this chapter, we saw the more <a id="_idIndexMarker241"/>common reasons for using impure functions. Let’s now consider how we can reduce the number of impure functions, even if doing away with all of them isn’t really feasible. Basically, we’ll have two methods for this:</p>
			<ul>
				<li>Avoiding the usage of state</li>
				<li>Using a programming pattern, <strong class="bold">injection</strong>, to control impurities</li>
			</ul>
			<h3>Avoiding the usage of state</h3>
			<p>With regard to the <a id="_idIndexMarker242"/>usage of the global state—both getting and setting it—the solution is well known. The key points to this are as follows:</p>
			<ul>
				<li>Provide whatever is needed of the global state to the function as arguments</li>
				<li>If the function needs to update the state, it shouldn’t do it directly, but instead produce a new version of the state and return it</li>
				<li>It should be the caller’s responsibility to take the returned state, if any, and update the global state</li>
			</ul>
			<p>This is the technique that Redux uses for its reducers. (We saw this in the <em class="italic">What FP is not</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Becoming Functional</em>, and the <em class="italic">Functions as objects</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Starting Out with Functions</em>.) The signature for a reducer is <code>(previousState, action) =&gt; newState</code>, meaning that it takes a state and an action as parameters and returns a new state as the result. Most specifically, the reducer is not supposed to change the <code>previousState</code> argument, which must remain untouched (we’ll learn more about this in <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>).</p>
			<p>For our first version of the <code>isOldEnough()</code> function, which used a global <code>limitYear</code> variable, the change is simple enough: we have to provide <code>limitYear</code> as a parameter for the function. With this change, it will become pure since it will produce its result by only using its parameters.</p>
			<p>Even better, we should provide the current year and let the function do the math instead of forcing the caller to do so. Our newer version of the adult age test could then be as follows:</p>
			<pre class="source-code">
// isOldEnough.ts
const isOldEnough3 = (
  birthYear: number,
  <strong class="bold">currentYear</strong>: number
): boolean =&gt; birthYear &lt;= <strong class="bold">currentYear - 18</strong>;</pre>
			<p>Obviously, we’ll have to<a id="_idIndexMarker243"/> change all the calls to provide the required <code>currentYear</code> argument (we could also use partial application, as we will see in <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>). The responsibility for the value of <code>currentYear</code> remains outside of the function, as before, but we have managed to avoid a defect:</p>
			<pre class="source-code">
console.log(isOldEnough3(1960, 2022)); // true
console.log(isOldEnough3(2010, 2022)); // false</pre>
			<p>We can also apply this solution to our peculiar <code>roundFix()</code> function. As you will recall, the function worked by accumulating the differences caused by rounding and deciding whether to round up or down depending on the sign of that accumulator. We cannot avoid using that state, but we can split off the rounding part from the accumulating part. Our original code (with fewer comments, no logging, and using arrow functions throughout) would be as follows:</p>
			<pre class="source-code">
// roundFix.ts
const roundFix1 = (() =&gt; {
  let accum = 0;
  return (n: number): number =&gt; {
    const nRounded =
      accum &gt; 0 ? Math.ceil(n) : Math.floor(n);
    accum += n - nRounded;
    return nRounded;
  };
})();</pre>
			<p>The newer version (see <em class="italic">Question 4.6</em> for more about this) would have two parameters:</p>
			<pre class="source-code">
// continued...
const roundFix2 = (<strong class="bold">accum: number, n: number</strong>) =&gt; {
  const nRounded = accum &gt; 0 ? Math.ceil(n) : Math.floor(n);
  accum += n - nRounded;
  <strong class="bold">return { accum, nRounded }</strong>;
};</pre>
			<p>How would you use this function? Initializing the accumulator, passing it to the function, and updating it afterward are now the responsibility of the caller code. You would have something like the following:</p>
			<pre class="source-code">
let accum = 0;
// ...some other code...
let { a, r } = roundFix2(accum, 3.1415);
accum = a;
console.log(accum, r); // 0.1415 3</pre>
			<p>Note the <a id="_idIndexMarker244"/>following:</p>
			<ul>
				<li>The <code>accum</code> value is now part of the global state of the application</li>
				<li>Since <code>roundFix2()</code> needs it, its value is provided in each call</li>
				<li>The caller is responsible for updating the global state, not <code>roundFix2()</code></li>
			</ul>
			<p class="callout-heading">Spreading, once more</p>
			<p class="callout">Note the usage of the destructuring assignment to allow a function to return more than a value and easily store each one in a different variable. For more on this, go to <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a>. For an alternative see <em class="italic">Question 4.7</em>.</p>
			<p>This new <code>roundFix2()</code> function is totally pure and can be easily tested. If you want to hide the accumulator from the rest of the application, you could still use a closure, as we have seen in other examples, but that would again introduce impurity in your code—your call!</p>
			<h3>Injecting impure functions</h3>
			<p>If a function becomes<a id="_idIndexMarker245"/> impure because it needs to call another function that is itself impure, a way around this problem is to inject the required function in the call. This technique provides more flexibility in your code and allows for easier future changes and less complex unit testing.</p>
			<p>Let’s consider the random filename generator function that we saw earlier. The problematic part of this function is its usage of <code>getRandomLetter()</code> to produce the filename:</p>
			<pre class="source-code">
// random.ts
const getRandomFileNae = (fileExtension = ""): string =&gt; {
  … 
    <strong class="bold">namePart[i] = getRandomLetter()</strong>;
  …

};</pre>
			<p>A way to solve this<a id="_idIndexMarker246"/> is to replace the impure function with an injected external one; we must now provide a <code>randomLetterFunc()</code> argument for our random filename function to use:</p>
			<pre class="source-code">
// continued...
const getRandomFileName2 = (
  fileExtension = "",
  <strong class="bold">randomLetterFunc: () =&gt; string</strong>
): string =&gt; {
  const NAME_LENGTH = 12;
  const namePart = new Array(NAME_LENGTH);
  for (let i = 0; i &lt; NAME_LENGTH; i++) {
    namePart[i] = <strong class="bold">randomLetterFunc()</strong>;
  }
  return namePart.join("") + fileExtension;
};</pre>
			<p>Now, we have removed the inherent impurity from this function. If we want to provide a predefined pseudorandom function that returns fixed, known values, we can easily unit-test this function; we’ll see how in the following examples. The usage of the function will change, and we would have to write the following:</p>
			<pre class="source-code">
let fn = getRandomFileName2(".pdf", getRandomLetter);</pre>
			<p>If this bothers you, you may want to provide a default value for the <code>randomLetterFunc</code> parameter as follows:</p>
			<pre class="source-code">
// continued...
const getRandomFileName3 = (
  fileExtension = "",
  randomLetterFunc: () =&gt; string <strong class="bold">= getRandomLetter</strong>
): string =&gt; {
  const NAME_LENGTH = 12;
  const namePart = new Array(NAME_LENGTH);
  for (let i = 0; i &lt; NAME_LENGTH; i++) {
    namePart[i] = randomLetterFunc();
  }
  return namePart.join("") + fileExtension;
};</pre>
			<p>You can also solve this using <strong class="bold">partial application</strong>, as we’ll see in <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>.</p>
			<p>This hasn’t actually<a id="_idIndexMarker247"/> avoided the usage of impure functions. Normally, you’ll call <code>getRandomFileName()</code> by providing it with the random letter generator we wrote, so it will behave as an impure function. However, if for testing purposes you provide a function that returns predefined (that is, not random) letters, you’ll be able to test it as if it were pure much more easily.</p>
			<p>But what about the original problem function, <code>getRandomLetter()</code>? We can apply the same trick and write a new version, such as the following, which will have an argument that will produce random numbers:</p>
			<pre class="source-code">
// random.ts
const getRandomLetter2 = (
  getRandomNum: () =&gt; number <strong class="bold">= Math.random.bind(Math)</strong>
): string =&gt; {
  const min = "A".charCodeAt(0);
  const max = "Z".charCodeAt(0);
  return String.fromCharCode(
    Math.floor(getRandomNum() * (1 + max - min)) + min
  );
};</pre>
			<p>We should change <code>getRandomFileName3()</code> to call <code>getRandomLetter2()</code>. If it calls it without providing any parameters, <code>getRandomLetter2()</code> will behave in its expected random ways. But if we want to test whether <code>getRandomFileName3()</code> does what we wanted, we can run it with an injected function that will return whatever we decide, letting us test it thoroughly.</p>
			<p class="callout-heading">Bind them all</p>
			<p class="callout">For the default of <code>getRandomNum</code>, we wrote <code>Math.random.bind(Math)</code>, as explained in the <em class="italic">Working with methods</em> section of the previous chapter. The alternative (arguably clearer for some people) is <code>() =&gt; Math.random()</code>; we’ll use it in the <em class="italic">Is your function pure?</em> section later in this chapter, just for variety.</p>
			<p>Let’s finish this section with a <a id="_idIndexMarker248"/>more complex case: what happens with a function with multiple impurities? For instance, we could be working on a backend <code>calculateDebt()</code> service that calculates a person’s debt, given their <code>id</code>. To do that, we could access a database, get the list of the person’s invoices, and then call some service to get the amount owed in each invoice; the sum of those amounts would be the calculated debt. A skeleton of such a function could be as follows—and I’m using plain JavaScript to omit unnecessary details:</p>
			<pre class="source-code">
// calculateDebt.js
const calculateDebt = async (id) =&gt; {
  // access a database to get a list of invoices
  const listOfInvoices =
    <strong class="bold">await mySqlConn.query(/* SQL query to get invoices */)</strong>;
  // call a remote service to learn what's owed for each
  const owedAmounts =
    <strong class="bold">await axios.get(/* API call to get owed amounts */)</strong>;
  const calculatedDebt = owedAmounts.reduce(
    (x, y) =&gt; x + y,
    0
  );
  return calculatedDebt;
};</pre>
			<p>(If <code>calculatedDebt = wedAmounts.reduce(…)</code> is foreign to you, see the <em class="italic">Summing an array</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a><em class="italic">, </em><em class="italic">Programming Declaratively</em>.)</p>
			<p>We cannot easily test such a function because it depends on the availability of a database and another service. To <em class="italic">purify</em> it, we need to inject two functions: one to get data from a database and <a id="_idIndexMarker249"/>another to query a service. The purified function would become this:</p>
			<pre class="source-code">
// continued...
const calculateDebt2 = async (
  id,
<strong class="bold">  { getInvoices, getOwedAmounts } =</strong>
<strong class="bold">    { getInvoicesFromDb, getOwedAmountFromAPI }</strong>
) =&gt; {
  const listOfInvoices = await getInvoices(id);
  const owedAmounts = await getOwedAmounts(listOfInvoices);
  const calculatedDebt = owedAmounts.reduce(
    (x, y) =&gt; x + y,
    0
  );
  return calculatedDebt;
};</pre>
			<p>In this code, <code>getInvoicesFromDb()</code> and <code>getOwedAmountFromAPI()</code> would be the functions that do the DB access and API call. Our <code>calculateDebt2()</code> function now doesn’t know (or need to know) the details of how to access and work with the DB or the other service; that’s a better software design.</p>
			<p>Now, the function has two parameters: <code>id</code> (as before) and an optional object with the two functions to be injected. In regular use, we wouldn’t supply the second parameter, and the function accesses the DB and calls the API as needed. But here’s the point: for testing purposes, we inject an object with two mock functions and are then able to write simple tests. (If you are wondering why we injected an object, see <em class="italic">Question 4.8</em>.)</p>
			<p>An extra detail: thorough real-world testing of functions is usually hard to achieve. For instance, how do you simulate a dropped connection or a failed service call? With injection, that’s no problem; we can easily provide a mock that will return wrong values, throw an exception, and do anything else you need for your complete testing.</p>
			<p>Using injection to avoid<a id="_idIndexMarker250"/> impurities is very important and has a broad spectrum of applications for other problems. For example, instead of having a function directly access the DOM, we can provide it with injected functions that would do this. For testing purposes, it would be simple to verify that the tested function does what it needs to do without really interacting with the DOM (of course, we’d have to find another way to test those DOM-related functions). This can also apply to functions that need to update the DOM, generate new elements, and do all sorts of manipulations—you use some intermediary functions. We’ll even apply injection in <a href="B19301_11.xhtml#_idTextAnchor204"><em class="italic">Chapter 11</em></a><em class="italic">, Implementing Design Patterns,</em> to derive a better system architecture, so it’s a powerful, key concept.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Is your function pure?</h2>
			<p>Let’s end this <a id="_idIndexMarker251"/>section by considering an important question: can you ensure that a function is truly pure? To show the difficulties of this task, we’ll go back to the simple <code>sum3()</code> function that we saw in the <em class="italic">Spread</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Becoming Functional </em>, just rewritten to use arrow functions for brevity. Would you say that this function is pure? It certainly looks like it!</p>
			<pre class="source-code">
// sum3.ts (in chapter 3)
const sum3 = (x: number, y: number, z: number): number =&gt;
  x + y + z;</pre>
			<p>Let’s see: the function doesn’t access anything but its parameters, doesn’t even try to modify them (not that it could (or could it?)), doesn’t perform any I/O, or work with any of the impure functions or methods that we mentioned earlier. What could go wrong?</p>
			<p>The answer has to do with checking your assumptions. For example, who says the arguments for this function should be numbers? In plain JavaScript, we could call it with, say, strings, but we’re now using TypeScript, and it’s supposed to check that, right? And even if passing strings to the function, you might ask yourself: <em class="italic">OK, they could be strings, but the function would still be pure, wouldn’t it?</em> For an (assuredly evil!) answer to that, see the following code:</p>
			<pre class="source-code">
// sum3.trick.ts
<strong class="bold">const x = {} as number;</strong>
<strong class="bold">x.valueOf = () =&gt; Math.random();</strong>
const y = 1;
const z = 2;
console.log(sum3(x, y, z)); // 3.2034400919849431
console.log(sum3(x, y, z)); // 3.8537045249277906
console.log(sum3(x, y, z)); // 3.0833258308458734</pre>
			<p class="callout-heading">Evil coding!</p>
			<p class="callout">We assigned a new function to the <code>x.valueOf()</code> method to make an object look like a number. We also lied when saying  <code>x = {} as number</code>; otherwise, TypeScript would have objected that you were passing an object where a number was expected.</p>
			<p>Well, <code>sum3()</code> ought to<a id="_idIndexMarker252"/> be pure, but that actually depends on whichever parameters you pass to it; you can make a pure function behave impurely! You might console yourself by thinking that surely no one would pass such arguments, but edge cases are usually where bugs reside. But you need not resign yourself to abandoning the idea of pure functions. As we see, you can even con TypeScript into accepting wrong data types, so you can never be totally sure that your code is always pure!</p>
			<p>Throughout these sections, we have gone through the characteristics of pure and impure functions. Let’s finish the chapter by looking at how we can test these sorts of functions.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Testing – pure versus impure</h1>
			<p>We have seen how pure functions are conceptually better than impure ones, but we cannot set out on a crusade to vanquish all impurities from our code. First, no one can deny that side effects can be useful, or at least unavoidable: you will need to interact with the DOM or call a web service, and there are no ways to do this in a pure way. So, rather than bemoaning the fact that you have to allow for impurity, try to structure your code to isolate the impure functions and let the rest of your code be the best it can possibly be.</p>
			<p>With this in mind, you’ll have to be able to write unit tests for all kinds of functions, pure or impure. Writing unit tests is different, in terms of difficulty and complexity, for pure and impure functions. While coding tests for the former is usually quite simple and follows a basic pattern, the latter usually requires scaffolding and complex setups. So, let’s finish this chapter by seeing how to go about testing both types of functions.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Testing pure functions</h2>
			<p>Given the characteristics of pure <a id="_idIndexMarker253"/>functions that we have already described, most of your unit tests could be the following:</p>
			<ul>
				<li>Calling the function with a given set of arguments</li>
				<li>Verifying that the results match what you expected</li>
			</ul>
			<p>Let’s start with a couple of simple examples. Testing the <code>isOldEnough()</code> function would have been more complex than we needed for the version that required access to a global variable. On the other hand, the last version, <code>isOldEnough3()</code>, which didn’t require anything because it received two parameters, is simple to test:</p>
			<pre class="source-code">
// isOldEnough.test.ts
describe("isOldEnough", function () {
  it("is false for people younger than 18", () =&gt; {
    expect(isOldEnough3(2010, 2022)).toBe(false);
  });
  it("is true for people older than 18", () =&gt; {
    expect(isOldEnough3(1960, 2022)).toBe(true);
  });
  it("is true for people exactly 18", () =&gt; {
    expect(isOldEnough3(2004, 2022)).toBe(true);
  });
});</pre>
			<p>Testing another of the pure functions we wrote is equally simple, but we must be careful because of precision considerations. If we test the <code>circleArea</code> function, we must use the Jest <code>toBeCloseTo()</code> matcher, which allows for approximate equality when dealing with floating-point numbers. (See <em class="italic">Question 4.9</em> for more on math in JavaScript.) Other than this, the tests are just about the same—call the function with known arguments and check the expected results:</p>
			<pre class="source-code">
// area.test.ts
describe("circle area", function () {
  it("is zero for radius 0", () =&gt; {
    const area = circleArea(0);
    expect(area).toBe(0);
  });
  it("is PI for radius 1", () =&gt; {
    expect(circleArea(1)).toBeCloseTo(Math.PI);
  });
  it("is approximately 12.5664 for radius 2", () =&gt;
    expect(circleArea(2)).toBeCloseTo(12.5664));
});</pre>
			<p>No difficulty<a id="_idIndexMarker254"/> whatsoever! (I wrote the three tests in different styles on purpose, just for variety.) The test run reports success for both suites (see <em class="italic">Figure 4</em><em class="italic">.3</em>):</p>
			<div><div><img src="img/Figure_4.3_B19301.jpg" alt="Figure 4.3 – A successful test run for a pair of pure functions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – A successful test run for a pair of pure functions</p>
			<p>We don’t have to <a id="_idIndexMarker255"/>worry about pure functions; let’s move on to the impure ones we dealt with by transforming them into pure equivalents.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Testing purified functions</h2>
			<p>When we considered the<a id="_idIndexMarker256"/> following <code>roundFix()</code> special function that required us to use the state to accumulate the differences due to rounding, we produced a new version by providing the current state as an added parameter and by having the function return two values—the rounded one and the updated state:</p>
			<pre class="source-code">
// roundFix.ts
const roundFix2 = (accum: number, n: number) =&gt; {
  const nRounded = accum &gt; 0 ? Math.ceil(n) :
    Math.floor(n);
  accum += n - nRounded;
  return { accum, nRounded };
};</pre>
			<p>This function is now pure, but testing it requires validating not only the returned values but also the updated states. We can base our tests on the experiments we did previously. Once again, we have to use <code>toBeCloseTo()</code> for dealing with floating-point numbers (and see <em class="italic">Question 4.10</em> for more on this), but we can use <code>toBe()</code> with integers, which <a id="_idIndexMarker257"/>produces no rounding errors. We could write our tests as follows:</p>
			<pre class="source-code">
// roundFix.test.ts
describe("roundFix2", function () {
  it("rounds 3.14159-&gt;3 if differences are 0", () =&gt; {
    const { accum, nRounded } = roundFix2(0.0, 3.14159);
    expect(accum).toBeCloseTo(0.14159);
    expect(nRounded).toBe(3);
  });
  it("rounds 2.71828-&gt;3 if differences are 0.14159", () =&gt; {
    const { accum, nRounded } = roundFix2(0.14159,
      2.71828);
    expect(accum).toBeCloseTo(-0.14013);
    expect(nRounded).toBe(3);
  });
  it("rounds 2.71828-&gt;2 if differences are -0.14013", () =&gt; {
    const { accum, nRounded } = roundFix2(
      -0.14013,
      2.71828
    );
    expect(accum).toBeCloseTo(0.57815);
    expect(nRounded).toBe(2);
  });
  it("rounds 3.14159-&gt;4 if differences are 0.57815", () =&gt; {
    const { accum, nRounded } = roundFix2(0.57815,
      3.14159);
    expect(accum).toBeCloseTo(-0.28026);
    expect(nRounded).toBe(4);
  });
});</pre>
			<p>We included <a id="_idIndexMarker258"/>several cases, with positive, zero, or negative accumulated differences, and checked whether they rounded up or down on each occasion. We could certainly go further by rounding negative numbers, but the idea is clear: if your function takes the current state as a parameter and updates it, the only difference with the pure functions’ tests is that you will also have to test whether the returned state matches your expectations.</p>
			<p>Let’s now consider an alternative way of testing for our <em class="italic">purified</em> <code>getRandomLetter2()</code> function. This is simple: you have to provide a function that produces random numbers. (This kind of function, in testing parlance, is called a stub.) There’s no limit to the complexity of a stub, but you’ll want to keep it simple.</p>
			<p>Based on our knowledge of the workings of the function, we can then do some tests to verify that low values produce an <code>"A"</code> output and values close to 1 produce a <code>"Z"</code> output so that we can have a little confidence that no extra values are produced. We should also test that a middle value (around 0.5) should generate a letter around the middle of the alphabet. However, this kind of test is not very good—if we implemented <code>getRandomLetter2()</code> in another way, it might work perfectly well but not pass this test! Our tests could be written as follows:</p>
			<pre class="source-code">
// random.test.ts
describe("getRandomLetter2", function () {
  it("returns A for values close to 0", () =&gt; {
    const letterSmall = getRandomLetter2(() =&gt; 0.0001);
    expect(letterSmall).toBe("A");
  });
  it("returns Z for values close to 1", () =&gt; {
    const letterBig = getRandomLetter2(() =&gt; 0.99999);
    expect(letterBig).toBe("Z");
  });
  it("returns middle letter for values around 0.5", () =&gt; {
    const letterMiddle = getRandomLetter2(() =&gt;
      0.49384712);
    expect(letterMiddle &gt; "G").toBeTruthy();
    expect(letterMiddle &lt; "S").toBeTruthy();
  });
  it("returns ascending letters for ascending #s", () =&gt; {
    const letter1 = getRandomLetter2(() =&gt; 0.09);
    const letter2 = getRandomLetter2(() =&gt; 0.22);
    const letter3 = getRandomLetter2(() =&gt; 0.60);
    expect(letter1 &lt; letter2).toBeTruthy();
    expect(letter2 &lt; letter3).toBeTruthy();
  });
});</pre>
			<p>Testing our filename<a id="_idIndexMarker259"/> generator can be done similarly, by using stubs. We can provide a simple stub, <code>f()</code>, that will return the letters of <code>"SORTOFRANDOM"</code> in sequence (this function is quite impure; can you see why?). So, we can verify that the returned filename matches the expected name and a couple more properties of the returned filename, such as its length and extension. Our test could then be written as follows:</p>
			<pre class="source-code">
// continued...
describe("getRandomFileName3", function () {
  let a: string[] = [];
  const f = () =&gt; a.shift() as string;
  beforeEach(() =&gt; {
    a = "SORTOFRANDOM".split("");
  });
  it("uses the given letters for the file name", () =&gt; {
    const fileName = getRandomFileName3("", f);
    expect(fileName.startsWith("SORTOFRANDOM")).toBe(true);
  });
  it("includes right extension, has right length", () =&gt; {
    const fileName = getRandomFileName3(".pdf", f);
    expect(fileName.endsWith(".pdf")).toBe(true);
    expect(fileName.length).toBe(16);
  });
});</pre>
			<p>Testing <em class="italic">purified</em> impure <a id="_idIndexMarker260"/>functions is the same as testing originally pure functions. Now, we need to consider some cases of truly impure functions because, as we said, it’s quite certain that at some time or another, you’ll have to use such functions.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Testing impure functions</h2>
			<p>For starters, we’ll return to our<a id="_idIndexMarker261"/> original <code>getRandomLetter()</code> function. With insider knowledge about its implementation (this is <a id="_idIndexMarker262"/>called <code>Math.random()</code> method and set a mock function that will return whichever values we desire.</p>
			<p>We can revisit some of the test cases we went through in the previous section. In the first case, we set <code>Math.random()</code> to return 0.0001 (and test that it was actually called) and we also check that the final return is <code>"A"</code>. In the second case, just for variety, we set things up so that <code>Math.random()</code> will be called twice, returning two different values. We also verify that both results are <code>"Z"</code>. Our revisited tests could look as follows:</p>
			<pre class="source-code">
// continued...
describe("getRandomLetter", function () {
  afterEach(() =&gt; {
    // so count of calls to Math.random will be OK
    jest.restoreAllMocks();
  });
  it("returns A for values ~ 0", () =&gt; {
    jest.spyOn(Math, "random").mockReturnValue(0.00001);
    const letterSmall = getRandomLetter();
    expect(Math.random).toHaveBeenCalled();
    expect(letterSmall).toBe("A");
  });
  it("returns Z for values ~ 1", () =&gt; {
    jest
      .spyOn(Math, "random")
      .mockReturnValueOnce(0.988)
      .mockReturnValueOnce(0.999);
    const letterBig1 = getRandomLetter();
    const letterBig2 = getRandomLetter();
    expect(Math.random).toHaveBeenCalledTimes(2);
    expect(letterBig1).toBe("Z");
    expect(letterBig2).toBe("Z");
  });
  it("returns middle letter for values ~ 0.5", () =&gt; {
    jest.spyOn(Math, "random").mockReturnValue(0.49384712);
    const letterMiddle = getRandomLetter();
    expect(Math.random).toHaveBeenCalledTimes(1);
    expect(letterMiddle &gt; "G").toBeTruthy();
    expect(letterMiddle &lt; "S").toBeTruthy();
  });
});</pre>
			<p>(Of course, you wouldn’t go around inventing whatever tests came into your head. In all likelihood, you’ll work from the description of the desired <code>getRandomLetter()</code> function, which was written before you started to code or test it. In our case, I’m making do as if that specification did exist, and it pointedly said—for example—that values close to 0 should produce an <code>"A"</code> output, values close to 1 should return <code>"Z"</code>, and the function should return ascending letters for ascending random values.)</p>
			<p>Now, how <a id="_idIndexMarker264"/>would you test the original <code>getRandomFileName()</code> function, the one that called the impure <code>getRandomLetter()</code> function? That’s a much more complicated problem.</p>
			<p>What kind of expectations do you have? You cannot know the results it will give, so you won’t be able to write any <code>.toBe()</code> type of tests. What you can do is test for some properties of the expected results, and also, if your function implies randomness of some kind, you can repeat the tests as many times as you want so that you have a bigger chance of catching a bug. We could do some tests along the lines of the following code:</p>
			<pre class="source-code">
// continued...
describe("getRandomFileName+impure getRandomLetter", () =&gt; {
  it("generates 12 letter long names", () =&gt; {
    for (let i = 0; i &lt; 100; i++) {
      expect(getRandomFileName().length).toBe(12);
    }
  });
  it("generates names with letters A to Z, only", () =&gt; {
    for (let i = 0; i &lt; 100; i++) {
      const name = getRandomFileName();
      for (let j = 0; j &lt; name.length; j++) {
        expect(name[j] &gt;= "A" &amp;&amp; name[j] &lt;=
          "Z").toBe(true);
      }
    }
  });
  it("includes right extension if provided", () =&gt; {
    const fileName1 = getRandomFileName(".pdf");
    expect(fileName1.length).toBe(16);
    expect(fileName1.endsWith(".pdf")).toBe(true);
  });
  it("doesn't include extension if not provided", () =&gt; {
    const fileName2 = getRandomFileName();
    expect(fileName2.length).toBe(12);
    expect(fileName2.includes(".")).toBe(false);
  });
});</pre>
			<p>We are not <a id="_idIndexMarker265"/>passing any random letter generator function to <code>getFileName()</code>, so it will use the original, impure one. We ran some of the tests a hundred times, as extra insurance. Our tests check for the following:</p>
			<ul>
				<li>Filenames are 12 letters long</li>
				<li>Names only include letters “<code>A</code>” to “<code>Z</code>”</li>
				<li>Filenames include the provided extension</li>
				<li>If no extension is provided, none is included</li>
			</ul>
			<p class="callout-heading">Need for evidence</p>
			<p class="callout">When testing code, always remember that <em class="italic">absence of evidence isn’t evidence of absence</em>. Even if our repeated tests succeed, there is no guarantee that they won’t produce an unexpected, hitherto undetected, error with some other random input.</p>
			<p>Let’s do another property test. Suppose we want to test a shuffling algorithm; we might decide to implement the Fisher–Yates version along the lines of the following code. (For more on this algorithm—including some pitfalls for the unwary programmer—see <a href="http://en.wikipedia.org/wiki/Fisher-Yates_shuffle">en.wikipedia.org/wiki/Fisher-Yates_shuffle</a>.) As implemented, the algorithm is doubly impure: it doesn’t always produce the same result (obviously!) and it modifies its input parameter:</p>
			<pre class="source-code">
// shuffle.test.ts
const shuffle = &lt;T&gt;(arr: T[]): T[] =&gt; {
  const len = arr.length;
  for (let i = 0; i &lt; len - 1; i++) {
    let r = Math.floor(Math.random() * (len - i));
    [arr[i], arr[i + r]] = [arr[i + r], arr[i]];
  }
  return arr;
};
const xxx = [11, 22, 33, 44, 55, 66, 77, 88];
console.log(shuffle(xxx));
// [55, 77, 88, 44, 33, 11, 66, 22]</pre>
			<p>How could you test<a id="_idIndexMarker266"/> this algorithm? Given that the result won’t be predictable, we can check for the properties of its output. We can call it with a known array and then test some properties—but see <em class="italic">Question 4.13</em> for an important detail:</p>
			<pre class="source-code">
// continued...
describe("shuffleTest", function () {
  it("shouldn't change the array length", () =&gt; {
    const a = [22, 9, 60, 12, 4, 56];
    shuffle(a);
    expect(a.length).toBe(6);
  });
  it("shouldn't change the values", () =&gt; {
    const a = [22, 9, 60, 12, 4, 56];
    shuffle(a);
    expect(a.includes(22)).toBe(true);
    expect(a.includes(9)).toBe(true);
    expect(a.includes(60)).toBe(true);
    expect(a.includes(12)).toBe(true);
    expect(a.includes(4)).toBe(true);
    expect(a.includes(56)).toBe(true);
  });
});</pre>
			<p>We had to write the <a id="_idIndexMarker267"/>second part of the unit tests in that way because, as we saw, <code>shuffle()</code> modifies the input parameter. For tests for a different (and bad!) shuffling function, see <em class="italic">Question 4.14</em>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Summary</h1>
			<p>In this chapter, we introduced the concept of pure functions and studied why they matter. We also saw the problems caused by side effects—one of the causes of impure functions—looked at some ways of purifying such impure functions, and finally, we saw several ways of performing unit tests for both pure and impure functions. With these techniques, you’ll be able to favor using pure functions in your programming, and when impure functions are needed, you’ll have some ways of using them in a controlled manner.</p>
			<p>In <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, we’ll show other advantages of FP: how you can program in a declarative fashion at a higher level for more straightforward and robust code.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Questions</h1>
			<p>4.1 <strong class="bold">Must return?</strong>A simple, almost philosophical question: must pure functions always return something? Could you have a pure function that doesn’t return anything?</p>
			<p>4.2 <code>maxStrings()</code>?</p>
			<pre class="source-code">
const maxStrings = (a: string[])<strong class="bold">: string</strong> =&gt; a.sort().pop();</pre>
			<p>4.3 <code>cache</code> array for the optimized <code>fib2()</code> function.</p>
			<p>4.4 <strong class="bold">Minimalistic function</strong>: Functional programmers sometimes write code in a minimalistic way. Can you examine the following version of the Fibonacci function and explain whether it works, and if so, how?</p>
			<pre class="source-code">
// fibonacci.ts
const fib3 = (n: number): number =&gt;
  n &lt; 2 ? n : fib2(n - 2) + fib2(n - 1);</pre>
			<p>4.5 <code>fib4(6)</code> by hand and compare it with the example given earlier in the book:</p>
			<pre class="source-code">
// fibonacci.ts
const fib4 = (n: number, a = 0, b = 1): number =&gt;
  n === 0 ? a : fib4(n - 1, b, a + b);</pre>
			<p>4.6 <code>roundFix2()</code> function? Even when TypeScript can work it out by itself (as in this case), I prefer spelling it out for extra checks.</p>
			<p>4.7 <code>roundFix2()</code> so that it will return a tuple instead of a record. The input to this rewritten function could be two separate arguments or a single tuple argument.</p>
			<p>4.8 <strong class="bold">One injection or two?</strong> Why is it better to inject an object with two functions rather than two separate functions? In other words, why not write something like the following?</p>
			<pre class="source-code">
const calculateDebt2 = async (
  id,
<strong class="bold">  getInvoices = getInvoicesFromDb,</strong>
<strong class="bold">  getOwedAmounts = getOwedAmountFromAPI</strong>
) =&gt; … ;</pre>
			<p>4.9 <code>toBeCloseTo()</code> because of precision problems. A related question, often asked in job interviews, is <em class="italic">what will the following code output, </em><em class="italic">and why?</em></p>
			<pre class="source-code">
const a = 0.1;
const b = 0.2;
const c = 0.3;
if (a + b === c) {
  console.log("Math works!");
} else {
  console.log("Math failure?");
}</pre>
			<p>4.10 <code>toBeCloseTo()</code> is practical but can cause problems. Some basic mathematics properties are as follows:</p>
			<ul>
				<li>A number should equal itself: for all numbers <em class="italic">a</em>, <em class="italic">a</em> should equal <em class="italic">a</em></li>
				<li>If <em class="italic">a</em> equals <em class="italic">b</em>, then <em class="italic">b</em> should equal <em class="italic">a</em></li>
				<li>If <em class="italic">a</em> equals <em class="italic">b</em>, and <em class="italic">b</em> equals <em class="italic">c</em>, then <em class="italic">a</em> should equal <em class="italic">c</em></li>
				<li>If <em class="italic">a</em> equals <em class="italic">b</em>, and <em class="italic">c</em> equals <em class="italic">d</em>, then <em class="italic">a</em>+<em class="italic">c</em> should equal <em class="italic">b</em>+<em class="italic">d</em>, <em class="italic">a</em>-<em class="italic">c</em> should equal <em class="italic">b</em>-<em class="italic">d</em>, <em class="italic">a</em>*<em class="italic">c</em> should equal <em class="italic">b</em>*<em class="italic">d</em>, and <em class="italic">a</em>/<em class="italic">c</em> should equal <em class="italic">b</em>/<em class="italic">d</em></li>
			</ul>
			<p>Does <code>toBeCloseTo()</code> satisfy all these properties?</p>
			<p>4.11 <code>&lt;T&gt;</code> in the definition of <code>shuffle()</code>?</p>
			<p>4.12 <code>shuffle()</code> modifies the input array in place (a side effect!) we don’t really need the final <code>return arr</code> line and could remove it. What would be the type definition of <code>shuffle()</code> then?</p>
			<p>4.13. <code>shuffle()</code> to test whether it works correctly with arrays with repeated values? The tests we wrote are only valid for arrays with distinct values; can you see why?</p>
			<p>4.14 <strong class="bold">Popular, but wrong!</strong> Many online articles suggest the following code as a way of shuffling. The idea is to sort the array, but, instead of using a correct comparison function to randomly return positive or negative values, these random comparisons should get the array in disorder. However, the idea is wrong and the algorithm is bad because it doesn’t produce all possible outputs with equal probability. How can you check that?</p>
			<pre class="source-code">
const poorShuffle = (arr) =&gt;
  arr.sort(<strong class="bold">() =&gt; Math.random() - 0.5</strong>);</pre>
			<p>4.15 <strong class="bold">Shuffling by sorting</strong>: Sorting and shuffling can be seen as opposite functions; one brings order, and the other produces disorder. However, there’s a way to shuffle an array by sorting; can you figure out how? (And no, the answer is <em class="italic">not</em> the lousy algorithm shown in the previous question!) We are looking for an algorithm that can produce every possible output with the same probability, not favoring some outputs over others.</p>
		</div>
	</body></html>