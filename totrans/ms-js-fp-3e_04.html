<html><head></head><body>
		<div id="_idContainer021">
			<h1 id="_idParaDest-70" class="chapter-number"><a id="_idTextAnchor069"/>4</h1>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Behaving Properly – Pure Functions</h1>
			<p>In <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Starting Out with Functions</em>, we considered functions as the critical elements in <strong class="bold">functional programming</strong> (<strong class="bold">FP</strong>), went into detail about arrow functions, and introduced some concepts, such as injection, callbacks, polyfilling, and stubbing. In this chapter, we’ll have the opportunity to revisit or apply some of <span class="No-Break">those ideas.</span></p>
			<p>In this chapter, we will do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Consider the notion of <strong class="bold">purity</strong> and why we should care about <strong class="bold">pure functions</strong>—and <strong class="bold">impure functions</strong> <span class="No-Break">as well!</span></li>
				<li>Examine the concept of <span class="No-Break"><strong class="bold">referential transparency</strong></span></li>
				<li>Recognize the problems implied by <span class="No-Break">side effects</span></li>
				<li>Show some advantages of <span class="No-Break">pure functions</span></li>
				<li>Describe the main reasons behind <span class="No-Break">impure functions</span></li>
				<li>Discover ways to minimize the number of <span class="No-Break">impure functions</span></li>
				<li>Focus on ways of testing both pure and <span class="No-Break">impure functions</span></li>
			</ul>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Pure functions</h1>
			<p>Pure functions<a id="_idIndexMarker202"/> behave the same way as mathematical functions and provide various benefits. A function is pure if it satisfies <span class="No-Break">two conditions:</span></p>
			<ul>
				<li><strong class="bold">Given the same arguments, the function always calculates and returns the same result</strong>: This should be true no matter how many times it’s invoked or under which conditions you call it. This result cannot depend on any outside information or state, which could change during the program execution and cause it to return a different value. Nor can the function result depend on I/O results, random numbers, some other external variable, or a value that is not <span class="No-Break">directly controllable.</span></li>
				<li><strong class="bold">When calculating its result, the function doesn’t cause any observable side effects</strong>: This includes output to I/O devices, the mutation of objects, changes to a<a id="_idIndexMarker203"/> program’s state outside of the function, and <span class="No-Break">so on.</span></li>
			</ul>
			<p>You can simply say that pure functions don’t depend on (and don’t modify) anything outside their scope and always return the same result for the same <span class="No-Break">input arguments.</span></p>
			<p>Another word used in this context is <strong class="bold">idempotency</strong>, but it’s not exactly the same. An idempotent function can be called as <a id="_idIndexMarker204"/>many times as desired and will always produce the same result. However, this doesn’t imply that the function is free from <span class="No-Break">side effects.</span></p>
			<p>Idempotency is usually mentioned in the context of RESTful services. Let’s see a simple example showing the difference between purity and idempotency. A <strong class="source-inline">PUT</strong> call would cause a database record to be updated (a side effect), but if you repeat the call, the element will not be further modified, so the global state of the database won’t change <span class="No-Break">any further.</span></p>
			<p>We might also invoke a software design principle and remind ourselves that a function should <em class="italic">do one thing, only one thing, and nothing but that thing</em>. If a function does something else and has some hidden functionality, then that dependency on the state will mean that we won’t be able to predict the function’s output and will make things harder for us <span class="No-Break">as developers.</span></p>
			<p>Let’s look into these conditions in <span class="No-Break">more detail.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Referential transparency</h2>
			<p>In mathematics, referential transparency<a id="_idIndexMarker205"/> is the property that lets you replace an expression with its value without changing the results of whatever you are doing. The counterpart of referential transparency is, appropriately<a id="_idIndexMarker206"/> enough, <strong class="bold">referential opacity</strong>. A referentially opaque function cannot guarantee that it will always produce the same result, even when called with the <span class="No-Break">same arguments.</span></p>
			<p>To give a simple example, let’s consider what <a id="_idIndexMarker207"/>happens with an optimizing compiler that performs <strong class="bold">constant folding</strong>. Suppose you have a sentence <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const x = 1 + 2 * 3;</pre>
			<p>The compiler might optimize the code to the following by noting that <strong class="source-inline">2*3</strong> is a <span class="No-Break">constant value:</span></p>
			<pre class="source-code">
const x = 1 + 6;</pre>
			<p>Even better, a new round of optimization could avoid the <span class="No-Break">sum altogether:</span></p>
			<pre class="source-code">
const x = 7;</pre>
			<p>To save execution time, the compiler is taking advantage of the fact that all mathematical expressions and functions are (by definition) <span class="No-Break">referentially transparent.</span></p>
			<p>On the other hand, if the compiler cannot predict the output of a given expression, it won’t be able to optimize the code in any fashion, and the calculation will have to be done <span class="No-Break">at runtime.</span></p>
			<p>(TypeScript does a similar type analysis, and given the original <strong class="source-inline">const x = 1 + 2 * 3</strong> line, it would correctly decide that <strong class="source-inline">x</strong> is of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">number</strong></span><span class="No-Break">.)</span></p>
			<p class="callout-heading">Of lambdas and betas</p>
			<p class="callout">In lambda calculus, if you replace the value of an expression involving a function with the calculated value for the function, then that <a id="_idIndexMarker208"/>operation is called a <strong class="bold">β (beta) reduction</strong>. Note that you can only do this safely with referentially <span class="No-Break">transparent functions.</span></p>
			<p>All arithmetical expressions (involving both mathematical operators and functions) are referentially transparent: <strong class="source-inline">22*9</strong> can always be replaced by <strong class="source-inline">198</strong>. Expressions involving I/O are not transparent, given that their results cannot be known until executed. For the same reason, expressions involving date- and time-related functions or random numbers are also <span class="No-Break">not transparent.</span></p>
			<p>Concerning JavaScript functions you can produce, it’s pretty easy to write some that won’t fulfill the referential transparency condition. In fact, a function is not even required to return a value, though the JavaScript interpreter will return <strong class="source-inline">undefined</strong> in <span class="No-Break">that situation.</span></p>
			<p class="callout-heading">A matter of distinction</p>
			<p class="callout">Some languages distinguish between functions, which are expected to return a value, and procedures, which do not return anything, but that’s not the case with JavaScript. Some languages even provide the means to ensure that functions are <span class="No-Break">referentially transparent.</span></p>
			<p>If you wanted to, you could classify functions <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Pure functions</strong>: These return a <a id="_idIndexMarker209"/>value that depends only on its arguments and have no side <span class="No-Break">effects whatsoever.</span></li>
				<li><strong class="bold">Side effects only</strong>: These don’t <a id="_idIndexMarker210"/>return anything (actually, in JavaScript, these functions return <strong class="source-inline">undefined</strong>, but that’s not relevant here) but do produce some <span class="No-Break">side effects.</span></li>
				<li><strong class="bold">Functions with side effects</strong>: This<a id="_idIndexMarker211"/> means that they return a value that may not only depend on the function arguments but also involve <span class="No-Break">side effects.</span></li>
			</ul>
			<p>In FP, much emphasis is put on the first group: referentially transparent pure functions. A compiler can reason about the program behavior (and thus be able to optimize the generated code), and the programmer can more easily reason about the program and the relationship between its components. This, in turn, can help prove the correctness of an algorithm or optimize the code by replacing a function with an <span class="No-Break">equivalent one.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Side effects</h2>
			<p>What are side effects? We can<a id="_idIndexMarker212"/> define these as a change in state or an interaction with outside elements (the user, a web service, another computer—whatever) that occurs during the execution of some calculations or <span class="No-Break">a process.</span></p>
			<p>There’s a possible misunderstanding as to the scope of this meaning. In everyday speech, when you speak of side effects, it’s a bit like talking about collateral damage—some unintended consequences for a given action; however, in computing, we include every possible effect or change outside the function. If you write a function meant to perform a <strong class="source-inline">console.log()</strong> call to display a result, that would be considered a side effect, even if it’s exactly what you intended the function to do in the <span class="No-Break">first place!</span></p>
			<p>In this section, we will look at <span class="No-Break">the following:</span></p>
			<ul>
				<li>Common side effects in <span class="No-Break">JavaScript programming</span></li>
				<li>The problems that global and inner <span class="No-Break">states cause</span></li>
				<li>The possibility of functions mutating <span class="No-Break">their arguments</span></li>
				<li>Some functions that are <span class="No-Break">always troublesome</span></li>
			</ul>
			<h3>Usual side effects</h3>
			<p>In programming, there <a id="_idIndexMarker213"/>are (too many!) things that are considered side effects. In JavaScript programming, including both front- and backend coding, the more common ones you may find include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Changing <span class="No-Break">global variables.</span></li>
				<li>Mutating objects received <span class="No-Break">as arguments.</span></li>
				<li>Performing any I/O, such as showing an alert message or logging <span class="No-Break">some text.</span></li>
				<li>Working with, or changing, <span class="No-Break">the filesystem.</span></li>
				<li>Querying or updating <span class="No-Break">a database.</span></li>
				<li>Calling a <span class="No-Break">web service.</span></li>
				<li>Querying or modifying <span class="No-Break">the DOM.</span></li>
				<li>Triggering any <span class="No-Break">external process.</span></li>
				<li>Just calling another function that produces a side effect of its own. You could say that impurity is contagious: a function that calls an impure function automatically becomes impure on <span class="No-Break">its own!</span></li>
			</ul>
			<p>With this definition, let’s start looking at what can cause functional impurity (or <span class="No-Break">referential opaqueness).</span></p>
			<h3>Global state</h3>
			<p>Of all the preceding points, the <a id="_idIndexMarker214"/>most common reason for side effects is the usage of nonlocal variables that share a global state with other parts of the program. Since pure functions, by definition, always return the same output value given the same input arguments, if a function refers to anything outside its internal state, it automatically becomes impure. Furthermore—and this is a hindrance to debugging—to understand what a function has done, you must understand how the state got its current values, which means understanding all of the past history from your program: <span class="No-Break">not easy!</span></p>
			<p>Let’s write a function to detect<a id="_idIndexMarker215"/> whether a person is a legal adult by checking whether they were born at least 18 years ago. (OK—that’s not precise enough because we are not considering the day and month of birth, but bear with me; the problem is elsewhere.) A version of an <strong class="source-inline">isOldEnough()</strong> function could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// isOldEnough.ts
const <strong class="bold">limitYear = 2004</strong>; // only good for 2022!
const isOldEnough = (birthYear: number) =&gt;
  <strong class="bold">birthYear &lt;= limitYear</strong>;
console.log(isOldEnough(1960)); // true
console.log(isOldEnough(2010)); // false</pre>
			<p>The <strong class="source-inline">isOldEnough()</strong> function correctly detects whether a person is at least 18 years old, but it depends on an external variable—a variable good for 2022 only! Even though the function works, the implementation isn’t the best that it could possibly be. You cannot tell what the function does unless you know about the external variable and how it got its value. Testing is also hard; you must remember to create the global <strong class="source-inline">limitYear</strong> variable, or all your tests <span class="No-Break">will fail.</span></p>
			<p>There is an exception to this rule. Check out the following case: is the following <strong class="source-inline">circleArea()</strong> function, which calculates the area of a circle given its radius, pure <span class="No-Break">or not?</span></p>
			<pre class="source-code">
// area.ts
const PI = 3.14159265358979;
const circleArea = (r: number) =&gt; PI * r ** 2;</pre>
			<p>Even though the function is accessing an external state, the fact that <strong class="source-inline">PI</strong> is a constant (and thus cannot be modified) would allow us to substitute it inside <strong class="source-inline">circleArea</strong> with no functional change, and so we should accept that the function is pure. The function will always return the same value for the same argument and thus fulfills our <span class="No-Break">purity requirements.</span></p>
			<p>If you were to use <strong class="source-inline">Math.PI</strong> instead of a constant as we defined in the code (a better idea, by the way) the constant cannot <a id="_idIndexMarker216"/>be changed, so the function would <span class="No-Break">remain pure.</span></p>
			<p>Here, we have dealt with problems caused by the global state; let’s move on to the <span class="No-Break">inner state.</span></p>
			<h3>Inner state</h3>
			<p>The notion is also <a id="_idIndexMarker217"/>extended to internal variables, in which a local state is stored and used for future calls. The external state is unchanged, but internal side effects imply future differences regarding what the function will return. Let’s imagine a <strong class="source-inline">roundFix()</strong> rounding function that considers whether it has been rounding up or down too much so that the next time, it will round the other way, bringing the accumulated difference closer to zero. Our function will have to accumulate the effects of previous roundings to decide how to proceed next. The implementation could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// roundFix.ts
const roundFix = (function () {
  let accum = 0;
  return (n: number): number =&gt; {
    // reals get rounded up or down
    // depending on the sign of accum
    const nRounded =
      accum &gt; 0 ? Math.ceil(n) : Math.floor(n);
    console.log(
      "accum",
      accum.toFixed(5),
      " result",
      nRounded
    );
    accum += n - nRounded;
    return nRounded;
  };
})();</pre>
			<p>Some comments <a id="_idIndexMarker218"/>regarding <span class="No-Break">this function:</span></p>
			<ul>
				<li>The <strong class="source-inline">console.log()</strong> call is just for the sake of this example; it wouldn’t be included in the real-world function. It lists the accumulated difference up to the point and the result it will return: the given number rounded up <span class="No-Break">or down.</span></li>
				<li>We are using the IIFE pattern from the <strong class="source-inline">myCounter()</strong> example in the <em class="italic">Immediate invocation </em>section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Starting Out with Functions,</em> to get a hidden <span class="No-Break">internal variable.</span></li>
				<li>The <strong class="source-inline">nRounded</strong> calculation could also be written as <strong class="source-inline">Math[accum &gt; 0 ? "ceil": "floor"](n)</strong>—we test <strong class="source-inline">accum</strong> to see which method to invoke (<strong class="source-inline">"ceil"</strong> or <strong class="source-inline">"floor"</strong>) and then use the <strong class="source-inline">Object["method"]</strong> notation to indirectly invoke <strong class="source-inline">Object.method()</strong>. The way we used it, I think, is more clear, but I just wanted to give you a heads-up in case you happen to find this other <span class="No-Break">coding style.</span></li>
			</ul>
			<p>Running this function with just two values (recognize them?) shows that results are not always the same for a given input. The <strong class="source-inline">result</strong> part of the console log shows how the value got rounded, up <span class="No-Break">or down:</span></p>
			<pre class="source-code">
roundFix(3.14159); // accum  0.00000  result 3
roundFix(2.71828); // accum  0.14159  result 3
roundFix(2.71828); // accum -0.14013  result 2
roundFix(3.14159); // accum  0.57815  result 4
roundFix(2.71828); // accum -0.28026  result 2
roundFix(2.71828); // accum  0.43802  result 3
roundFix(2.71828); // accum  0.15630  result 3</pre>
			<p>The first time around, <strong class="source-inline">accum</strong> is zero, so 3.14159 gets rounded down, and <strong class="source-inline">accum</strong> becomes 0.14159 in our favor. The second time, since <strong class="source-inline">accum</strong> is positive (meaning that we have been rounding in our favor), 2.71828 gets rounded up to 3, and now <strong class="source-inline">accum</strong> becomes negative. The third time, the same 2.71828 value gets rounded down to 2 because the accumulated difference was negative—we got different values for the same input! The rest of the example is similar; you can get the same value rounded up or down, depending on the accumulated differences, because the function’s result depends on its <span class="No-Break">inner state.</span></p>
			<p class="callout-heading">Why not OOP?</p>
			<p class="callout">This usage of the internal state is why many FP programmers think that using objects is potentially flawed. In OOP, we developers are used to storing information (attributes) and using them for future calculations; however, this usage is considered impure insofar as repeated method calls may return different values, although the same arguments are <span class="No-Break">being passed.</span></p>
			<p>We have now dealt <a id="_idIndexMarker219"/>with the problems caused by both global and inner states, but there are still more possible side effects. For example, what happens if a function changes the values of its arguments? Let’s consider <span class="No-Break">this next.</span></p>
			<h3>Argument mutation</h3>
			<p>You also need<a id="_idIndexMarker220"/> to be aware of the possibility that an impure function will modify its arguments. In JavaScript, arguments are passed by value, except for arrays and objects, which are passed by reference. This implies that any modification to the function’s parameters will affect an actual modification of the original object or array. This can be further obscured by the fact that several <strong class="bold">mutator</strong> methods<a id="_idIndexMarker221"/> change the underlying objects by definition. For example, say you wanted a function that would find the maximum element of an array of strings (of course, if it were an array of numbers, you could use <strong class="source-inline">Math.max()</strong> with no further ado). A short implementation could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// maxStrings.ts
const maxStrings = (a: string[]) =&gt; <strong class="bold">a.sort().pop()</strong>;
const countries = [
  "Argentina",
  "Uruguay",
  "Brasil",
  "Paraguay",
];
console.log(maxStrings(countries)); // <strong class="bold">"Uruguay"</strong></pre>
			<p>The function<a id="_idIndexMarker222"/> does provide the correct result (and if you worry about foreign languages, we already saw a way around that in the <em class="italic">Injection – sorting it out</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Starting Out with Functions</em>), but it has a defect. Let’s see what happened with the <span class="No-Break">original array:</span></p>
			<pre class="source-code">
console.log(countries);
// [<strong class="bold">"Argentina", "Brasil", "Paraguay"</strong>]</pre>
			<p>Oops—the original array was modified; this is a side effect by definition! (TypeScript would have helped detect this error if we had only written a complete type definition for <strong class="source-inline">maxStrings()</strong>; see <em class="italic">Question 4.2</em> for details.) If you were to call <strong class="source-inline">maxStrings(countries)</strong> again, then instead of returning the same result as before, it would produce another value; clearly, this is not a <span class="No-Break">pure function.</span></p>
			<p>In this case, a quick solution is to work on a copy of the array, and we can use the spread operator to help. Still, we’ll be dealing with more ways of avoiding these sorts of problems in <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <span class="No-Break"><em class="italic">Ensuring Purity</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
const maxStrings2 = (a: string[]) =&gt; <strong class="bold">[...a].sort().pop()</strong>;
let countries = [
  "Argentina",
  "Uruguay",
  "Brasil",
  "Paraguay",
];
console.log(maxStrings2(countries));
// "Uruguay"
console.log(countries);
// ["Argentina", "Uruguay", "Brasil", "Paraguay"]</pre>
			<p>So now, we have found <a id="_idIndexMarker223"/>yet another cause for side effects: functions that modify their arguments. A final case to consider is functions that just have to <span class="No-Break">be impure!</span></p>
			<h3>Troublesome functions</h3>
			<p>Finally, some <a id="_idIndexMarker224"/>functions also cause problems. For instance, <strong class="source-inline">Math.random()</strong> is impure: it doesn’t always return the same value, and it would defeat its purpose if it did! Furthermore, each call to the function modifies a global seed value, from which the next random value will <span class="No-Break">be calculated.</span></p>
			<p class="callout-heading">Not really random</p>
			<p class="callout">The fact that random numbers are actually calculated by an internal function makes them not random at all; <em class="italic">pseudorandom</em> would be a better name for them. If you knew the used formula and the seed’s initial value, you’d be able to predict the following numbers, in a totally <span class="No-Break">non-random way.</span></p>
			<p>For instance, consider the following function that generates random letters from <strong class="source-inline">"A"</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"Z"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// random.ts
const getRandomLetter = (): string =&gt; {
  const min = "A".charCodeAt(0);
  const max = "Z".charCodeAt(0);
  return String.fromCharCode(
    Math.floor(Math.random() * (1 + max - min)) + min
  );
};</pre>
			<p>The fact that it receives no arguments, but is expected to produce different results upon each call, clearly points out that this function <span class="No-Break">is impure.</span></p>
			<p class="callout-heading">Random explanations</p>
			<p class="callout">Go to <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random</a> for an explanation of our <strong class="source-inline">getRandomLetter()</strong> function, and to <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt</a> for the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">charCodeAt()</strong></span><span class="No-Break"> method.</span></p>
			<p>Impurity can be <a id="_idIndexMarker225"/>inherited by calling functions. If a function uses an impure function, it immediately becomes impure itself. We might want to use <strong class="source-inline">getRandomLetter()</strong> to generate random filenames with an optional given extension; our <strong class="source-inline">getRandomFileName()</strong> function could then be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const getRandomFileName = (fileExtension = ""): string =&gt; {
  const NAME_LENGTH = 12;
  const namePart = new Array(NAME_LENGTH);
  for (let i = 0; i &lt; NAME_LENGTH; i++) {
    namePart[i] = getRandomLetter();
  }
  return namePart.join("") + fileExtension;
};</pre>
			<p>Because of its usage of <strong class="source-inline">getRandomLetter()</strong>, <strong class="source-inline">getRandomFileName()</strong> is also impure, though it performs as expected, correctly producing totally <span class="No-Break">random filenames:</span></p>
			<pre class="source-code">
getRandomFileName(".pdf"); // "SVHSSKHXPQKG.pdf"
getRandomFileName(".pdf"); // "DCHKTMNWFHYZ.pdf"
getRandomFileName(".pdf"); // "GBTEFTVVHADO.pdf"
getRandomFileName(".pdf"); // "ATCBVUOSXLXW.pdf"
getRandomFileName(".pdf"); // "OIFADZKKNVAH.pdf"</pre>
			<p>Keep this function in mind; we’ll see some ways around the unit testing problem later in this chapter, and we’ll rewrite it a bit to help <span class="No-Break">with that.</span></p>
			<p>The concern about impurity also extends to functions that access the current time or date because their results will depend on an external condition (namely, the time of day) that is part of the application’s <em class="italic">global</em> state. We could rewrite our <strong class="source-inline">isOldEnough()</strong> function to remove the dependency upon a global variable, but it wouldn’t help much. One attempt is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// isOldEnough.js
const isOldEnough2 = (birthYear: number): boolean =&gt;
  birthYear &lt;= <strong class="bold">new Date().getFullYear() - 18</strong>;
console.log(isOldEnough2(1960)); // true
console.log(isOldEnough2(2010)); // false</pre>
			<p>A problem has been removed—the new <strong class="source-inline">isOldEnough2()</strong> function is now safer. Also, as long as you don’t use it near midnight just before New Year’s Day, it will consistently return the same results, so you could say—paraphrasing the <em class="italic">Ivory Soap</em> slogan from the 19<span class="superscript">th</span> century—that it’s about <em class="italic">99.44% pure</em>; however, an inconvenience remains: how would you test it? If you were to write some tests that worked fine today, they’d start to fail next year. We’ll have to work a bit to solve this, and we’ll see <span class="No-Break">how later.</span></p>
			<p>Several other functions that are also impure are those that cause I/O. If a function gets input from a source (a web service, the user themself, a file, or some other source), then the result may obviously vary. You should also consider the possibility of an I/O error, so the very same function, calling the same service or reading the same file, might at some point fail for reasons outside its control (you should assume that your filesystem, database, socket, and so on could be unavailable, and thus a given function call might produce an error instead of the expected constant, <span class="No-Break">unvarying, answer).</span></p>
			<p>Even having <a id="_idIndexMarker226"/>a pure output and a generally safe statement (such as a <strong class="source-inline">console.log()</strong>) that doesn’t change anything internally (at least in a visible way) causes some side effects because the user does see a change: namely, the <span class="No-Break">produced output.</span></p>
			<p>Does this imply that we won’t ever be able to write a program that requires random numbers, handles dates, performs I/O, and also uses pure functions? Not at all—but it does mean that some functions won’t be pure, and they will have some disadvantages that we will have to consider; we’ll return to this in <span class="No-Break">a bit.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Advantages of pure functions</h2>
			<p>The main advantage of using <a id="_idIndexMarker227"/>pure functions is that they don’t have any side effects. When you call a pure function, you don’t need to worry about anything other than which arguments you are passing to it. Also, more to the point, you can be sure that you will not cause any problems or break anything else because the function will only work with whatever you give it and not with outside sources. But this is not their only advantage. Let’s learn more in the <span class="No-Break">following sections.</span></p>
			<h3>Order of execution</h3>
			<p>Another way of looking at what <a id="_idIndexMarker228"/>we have been saying in this chapter is to see pure functions as robust. You know that their execution—in whichever order—won’t ever impact the system. This idea can be extended further: you could evaluate pure functions in parallel, with the assurance that results wouldn’t vary from what you would get in a single-threaded execution. (JavaScript doesn’t provide Java-like threads, but we can make do, more or less, with workers. We’ll cover this topic in <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <span class="No-Break"><em class="italic">Programming Declaratively</em></span><span class="No-Break">.)</span></p>
			<p>Another consideration to keep in mind when you work with pure functions is that there’s no explicit need to specify the order in which they should be called. If you work with mathematics, an expression such as <strong class="source-inline">f(2)+f(5)</strong> is always the same as <strong class="source-inline">f(5)+f(2)</strong>; this is called the <span class="No-Break"><em class="italic">commutative property</em></span><span class="No-Break">.</span></p>
			<p>However, when you deal with impure functions, that can be false, as shown in the following purposefully written <span class="No-Break">tricky function:</span></p>
			<pre class="source-code">
// tricky.ts
let mult = 1;
const f = (x: number): number =&gt; {
  mult = -mult;
  return x * mult;
};
console.log(f(2) + f(5)); <strong class="bold">//  3</strong>
console.log(f(5) + f(2)); <strong class="bold">// -3</strong></pre>
			<p>With impure functions such as the previous one, you cannot assume that calculating <strong class="source-inline">f(3)+f(3)</strong> would produce the same result as <strong class="source-inline">2*f(3)</strong> or that <strong class="source-inline">f(4)-f(4)</strong> would actually be zero; check it out for yourself... Common mathematical properties, down <span class="No-Break">the drain!</span></p>
			<p>Why should you care? When <a id="_idIndexMarker229"/>writing code, willingly or not, you always keep in mind those properties you learned about, such as the commutative property. So, while you might think that both expressions should produce the same result and code accordingly, you may be in for a surprise when using impure functions, with hard-to-find bugs that are difficult <span class="No-Break">to fix.</span></p>
			<h3>Memoization</h3>
			<p>Since the output of a pure function<a id="_idIndexMarker230"/> for a given input is always the same, you can cache the function results and avoid a possibly costly recalculation. This process, which implies evaluating an expression only the first time and caching the result for later calls, is<a id="_idIndexMarker231"/> <span class="No-Break">called </span><span class="No-Break"><strong class="bold">memoization</strong></span><span class="No-Break">.</span></p>
			<p>We will return to this idea in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, but let’s look at an example done by hand. The Fibonacci sequence is always used for this example because of its simplicity and hidden calculation costs. This sequence is defined <span class="No-Break">as follows:</span></p>
			<ul>
				<li>For <span class="No-Break"><em class="italic">n</em></span><span class="No-Break">=0, fib(</span><span class="No-Break"><em class="italic">n</em></span><span class="No-Break">)=0</span></li>
				<li>For <span class="No-Break"><em class="italic">n</em></span><span class="No-Break">=1, fib(</span><span class="No-Break"><em class="italic">n</em></span><span class="No-Break">)=1</span></li>
				<li>For <span class="No-Break"><em class="italic">n</em></span><span class="No-Break">&gt;1, fib(</span><span class="No-Break"><em class="italic">n</em></span><span class="No-Break">)=fib(</span><span class="No-Break"><em class="italic">n</em></span><span class="No-Break">-2)+fib(</span><span class="No-Break"><em class="italic">n</em></span><span class="No-Break">-1)</span></li>
			</ul>
			<p class="callout-heading">Fibonacci who?</p>
			<p class="callout">Fibonacci’s name actually comes from <em class="italic">filius Bonacci</em> or <em class="italic">son of Bonacci</em>. He is best known for having introduced the usage of digits 0-9 as we know them today, instead of the cumbersome Roman numbers. He derived the sequence named after him as the answer to a puzzle involving<a id="_idIndexMarker232"/> rabbits! You can read more about it, and Fibonacci’s life in general, at en.wikipedia.org/wiki/Fibonacci_number#History <span class="No-Break">or </span><a href="http://plus.maths.org/content/life-and-numbers-fibonacci"><span class="No-Break">plus.maths.org/content/life-and-numbers-fibonacci</span></a><span class="No-Break">.</span></p>
			<p>If you run the<a id="_idIndexMarker233"/> numbers, the sequence starts with 0, then 1, and from that point onward, each term is the sum of the two previous ones: 1 again, then 2, 3, 5, 8, 13, 21, 34, 55, and so on. Programming this series using recursion is simple; we’ll revisit this example in <a href="B19301_09.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Designing Functions</em>. The following code, a direct translation of the definition, will do—and see <em class="italic">Question 4.4</em> for <span class="No-Break">an alternative:</span></p>
			<pre class="source-code">
// fibonacci.ts
const fib = (n: number): number =&gt; {
  if (n == 0) {
    return 0;
  } else if (n == 1) {
    return 1;
  } else {
    return fib(n - 2) + fib(n - 1);
  }
};
console.log(fib(10)); // 55, a bit slowly</pre>
			<p>If you try out this <a id="_idIndexMarker234"/>function for growing values of <strong class="source-inline">n</strong>, you’ll soon realize that there is a problem, and computation starts taking too much time. For example, I took timings (measured in milliseconds) at my machine and plotted them on a graph. Since the function is quite speedy, I had to run calculations 100 times for values of <strong class="source-inline">n</strong> between 0 and 40. Even then, the times for small values of <strong class="source-inline">n</strong> were really tiny; it was only from 25 onward that I got <span class="No-Break">interesting numbers.</span></p>
			<p>The chart (see <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>) shows exponential growth, which <span class="No-Break">bodes ill:</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_4.1_B19301.jpg" alt="Figure 4.1 – Calculation times for the ﬁb() recursive function go up exponentially"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Calculation times for the ﬁb() recursive function go up exponentially</p>
			<p>If we draw a diagram of all the calls required to calculate <strong class="source-inline">fib(6)</strong>, you’ll notice <span class="No-Break">the problem:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_4.2_B19301.jpg" alt="Figure 4.2 – The calculations needed for ﬁb(6) show lots of duplication"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The calculations needed for ﬁb(6) show lots of duplication</p>
			<p>Each node represents a call to compute <strong class="source-inline">fib(n)</strong>. We note the value of <strong class="source-inline">n</strong> in the node. Every call, except those for <strong class="source-inline">n</strong>=0 or <strong class="source-inline">n</strong>=1, requires further calls, as you can see in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
			<p>The reason for the <a id="_idIndexMarker235"/>increasing delays becomes obvious: for example, the calculation for <strong class="source-inline">fib(2)</strong> was repeated on four different occasions, and <strong class="source-inline">fib(3)</strong> was itself calculated three times. Given that our function is pure, we could have stored the calculated values to avoid running the numbers over and over again. A possible version, using a cache array for previously calculated values, would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
<strong class="bold">const cache: number[] = []</strong>;
const fib2 = (n: number): number =&gt; {
  if (<strong class="bold">cache[n] === undefined</strong>) {
    if (n === 0) {
      cache[0] = 0;
    } else if (n === 1) {
      cache[1] = 1;
    } else {
      cache[n] = fib2(n - 2) + fib2(n - 1);
    }
  }
  <strong class="bold">return cache[n]</strong>;
};
console.log(fib2(10)); // 55, as before, but more quickly!</pre>
			<p>Initially, the <strong class="source-inline">cache</strong> array is empty. Whenever we need to calculate the value of <strong class="source-inline">fib2(n)</strong>, we check whether it was already calculated beforehand. If that’s not true, we do the calculation, but with a twist: instead of immediately returning the value, we first store it in the cache and then return it. This means that no calculation will be done twice: after we have calculated <strong class="source-inline">fib2(n)</strong> for a particular <strong class="source-inline">n</strong> value, future calls will not repeat the procedure and will return the earlier <span class="No-Break">evaluated result.</span></p>
			<p>A few <span class="No-Break">short notes:</span></p>
			<ul>
				<li>We memoized the function by hand, but we can do it with a higher-order function. We’ll see this later in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>. It is perfectly possible to memoize a function without having to change or <span class="No-Break">rewrite it.</span></li>
				<li>Using a global <strong class="source-inline">cache</strong> variable isn’t a very good practice; we could have used an IIFE and a closure to hide <strong class="source-inline">cache</strong> from sight—do you see how? (Also, see <em class="italic">Question 4.3</em> at the end of this chapter.) The <strong class="source-inline">myCounter()</strong> example in the <em class="italic">Immediate invocation</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Starting Out with Functions,</em> <span class="No-Break">shows how.</span></li>
				<li>Of course, you will be constrained by the available cache space, and it’s possible you could eventually crash your application by eating up all available RAM. Resorting to external memory (a database, a file, or a cloud solution) would probably eat up all the performance advantages of caching. There are some standard solutions (involving eventually deleting items from the cache), but they are beyond the scope of <span class="No-Break">this book.</span></li>
			</ul>
			<p>Of course, you don’t <a id="_idIndexMarker236"/>need to do this for every pure function in your program. You’d do this sort of optimization only for frequently called functions that take a significant amount of time; otherwise, the added cache management time would cost more than what you expected <span class="No-Break">to save!</span></p>
			<h3>Self-documentation</h3>
			<p>Pure<a id="_idIndexMarker237"/> functions have another advantage. Since everything the function needs to work with is given to it through its parameters, with no hidden dependency whatsoever, when you read its source code, you have all you need to understand <span class="No-Break">its objective.</span></p>
			<p>An extra advantage: knowing that a function doesn’t access anything beyond its parameters makes you more confident in using it since you won’t be accidentally producing a side effect; the only thing the function will accomplish is what you already learned through <span class="No-Break">its documentation.</span></p>
			<p>Unit tests (which we’ll cover in the next section) also work as documentation because they provide examples of what the function returns when given certain arguments. Most programmers will agree that the best kind of documentation is full of examples, and each unit <a id="_idIndexMarker238"/>test can be considered such a <span class="No-Break">sample case.</span></p>
			<h3>Testing</h3>
			<p>Yet another advantage of<a id="_idIndexMarker239"/> pure functions—and one of the most important ones—has to do with unit testing. Pure functions have a single responsibility: producing their output in terms of their input. So, when you write tests for pure functions, your work is greatly simplified because there is no context to consider and no state <span class="No-Break">to simulate.</span></p>
			<p>You can focus on providing inputs and checking outputs because all function calls can be reproduced in isolation, independently from the rest of <span class="No-Break">the world.</span></p>
			<p>We have seen several aspects of pure functions. Let’s move on, learn about impure functions a bit, and finish by testing both pure and <span class="No-Break">impure functions.</span></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Impure functions</h1>
			<p>If you decided to entirely forgo all kinds of <a id="_idIndexMarker240"/>side effects, then your programs would only be able to work with hardcoded inputs and wouldn’t be able to show you the calculated results! Similarly, most web pages would be useless: you wouldn’t be able to make web service calls or update the DOM; you’d only have static pages. And your Node code would be really useless for server-side work, as it wouldn’t be able to perform <span class="No-Break">any I/O.</span></p>
			<p>Reducing side effects is a good goal in FP, but we shouldn’t go overboard! So, let’s think of how to avoid using impure functions, if possible, and how to deal with them if not, looking for the best way to contain or limit <span class="No-Break">their scope.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Avoiding impure functions</h2>
			<p>Earlier in this chapter, we saw the more <a id="_idIndexMarker241"/>common reasons for using impure functions. Let’s now consider how we can reduce the number of impure functions, even if doing away with all of them isn’t really feasible. Basically, we’ll have two methods <span class="No-Break">for this:</span></p>
			<ul>
				<li>Avoiding the usage <span class="No-Break">of state</span></li>
				<li>Using a programming pattern, <strong class="bold">injection</strong>, to <span class="No-Break">control impurities</span></li>
			</ul>
			<h3>Avoiding the usage of state</h3>
			<p>With regard to the <a id="_idIndexMarker242"/>usage of the global state—both getting and setting it—the solution is well known. The key points to this are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Provide whatever is needed of the global state to the function <span class="No-Break">as arguments</span></li>
				<li>If the function needs to update the state, it shouldn’t do it directly, but instead produce a new version of the state and <span class="No-Break">return it</span></li>
				<li>It should be the caller’s responsibility to take the returned state, if any, and update the <span class="No-Break">global state</span></li>
			</ul>
			<p>This is the technique that Redux uses for its reducers. (We saw this in the <em class="italic">What FP is not</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><em class="italic">, Becoming Functional</em>, and the <em class="italic">Functions as objects</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Starting Out with Functions</em>.) The signature for a reducer is <strong class="source-inline">(previousState, action) =&gt; newState</strong>, meaning that it takes a state and an action as parameters and returns a new state as the result. Most specifically, the reducer is not supposed to change the <strong class="source-inline">previousState</strong> argument, which must remain untouched (we’ll learn more about this in <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <span class="No-Break"><em class="italic">Ensuring Purity</em></span><span class="No-Break">).</span></p>
			<p>For our first version of the <strong class="source-inline">isOldEnough()</strong> function, which used a global <strong class="source-inline">limitYear</strong> variable, the change is simple enough: we have to provide <strong class="source-inline">limitYear</strong> as a parameter for the function. With this change, it will become pure since it will produce its result by only using <span class="No-Break">its parameters.</span></p>
			<p>Even better, we should provide the current year and let the function do the math instead of forcing the caller to do so. Our newer version of the adult age test could then be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// isOldEnough.ts
const isOldEnough3 = (
  birthYear: number,
  <strong class="bold">currentYear</strong>: number
): boolean =&gt; birthYear &lt;= <strong class="bold">currentYear - 18</strong>;</pre>
			<p>Obviously, we’ll have to<a id="_idIndexMarker243"/> change all the calls to provide the required <strong class="source-inline">currentYear</strong> argument (we could also use partial application, as we will see in <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Transforming Functions</em>). The responsibility for the value of <strong class="source-inline">currentYear</strong> remains outside of the function, as before, but we have managed to avoid <span class="No-Break">a defect:</span></p>
			<pre class="source-code">
console.log(isOldEnough3(1960, 2022)); // true
console.log(isOldEnough3(2010, 2022)); // false</pre>
			<p>We can also apply this solution to our peculiar <strong class="source-inline">roundFix()</strong> function. As you will recall, the function worked by accumulating the differences caused by rounding and deciding whether to round up or down depending on the sign of that accumulator. We cannot avoid using that state, but we can split off the rounding part from the accumulating part. Our original code (with fewer comments, no logging, and using arrow functions throughout) would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// roundFix.ts
const roundFix1 = (() =&gt; {
  let accum = 0;
  return (n: number): number =&gt; {
    const nRounded =
      accum &gt; 0 ? Math.ceil(n) : Math.floor(n);
    accum += n - nRounded;
    return nRounded;
  };
})();</pre>
			<p>The newer version (see <em class="italic">Question 4.6</em> for more about this) would have <span class="No-Break">two parameters:</span></p>
			<pre class="source-code">
// continued...
const roundFix2 = (<strong class="bold">accum: number, n: number</strong>) =&gt; {
  const nRounded = accum &gt; 0 ? Math.ceil(n) : Math.floor(n);
  accum += n - nRounded;
  <strong class="bold">return { accum, nRounded }</strong>;
};</pre>
			<p>How would you use this function? Initializing the accumulator, passing it to the function, and updating it afterward are now the responsibility of the caller code. You would have something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
let accum = 0;
// ...some other code...
let { a, r } = roundFix2(accum, 3.1415);
accum = a;
console.log(accum, r); // 0.1415 3</pre>
			<p>Note <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker244"/></span><span class="No-Break">following:</span></p>
			<ul>
				<li>The <strong class="source-inline">accum</strong> value is now part of the global state of <span class="No-Break">the application</span></li>
				<li>Since <strong class="source-inline">roundFix2()</strong> needs it, its value is provided in <span class="No-Break">each call</span></li>
				<li>The caller is responsible for updating the global state, <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">roundFix2()</strong></span></li>
			</ul>
			<p class="callout-heading">Spreading, once more</p>
			<p class="callout">Note the usage of the destructuring assignment to allow a function to return more than a value and easily store each one in a different variable. For more on this, go to <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a>. For an alternative see <span class="No-Break"><em class="italic">Question 4.7</em></span><span class="No-Break">.</span></p>
			<p>This new <strong class="source-inline">roundFix2()</strong> function is totally pure and can be easily tested. If you want to hide the accumulator from the rest of the application, you could still use a closure, as we have seen in other examples, but that would again introduce impurity in your <span class="No-Break">code—your call!</span></p>
			<h3>Injecting impure functions</h3>
			<p>If a function becomes<a id="_idIndexMarker245"/> impure because it needs to call another function that is itself impure, a way around this problem is to inject the required function in the call. This technique provides more flexibility in your code and allows for easier future changes and less complex <span class="No-Break">unit testing.</span></p>
			<p>Let’s consider the random filename generator function that we saw earlier. The problematic part of this function is its usage of <strong class="source-inline">getRandomLetter()</strong> to produce <span class="No-Break">the filename:</span></p>
			<pre class="source-code">
// random.ts
const getRandomFileNae = (fileExtension = ""): string =&gt; {
  … 
    <strong class="bold">namePart[i] = getRandomLetter()</strong>;
  …

};</pre>
			<p>A way to solve this<a id="_idIndexMarker246"/> is to replace the impure function with an injected external one; we must now provide a <strong class="source-inline">randomLetterFunc()</strong> argument for our random filename function <span class="No-Break">to use:</span></p>
			<pre class="source-code">
// continued...
const getRandomFileName2 = (
  fileExtension = "",
  <strong class="bold">randomLetterFunc: () =&gt; string</strong>
): string =&gt; {
  const NAME_LENGTH = 12;
  const namePart = new Array(NAME_LENGTH);
  for (let i = 0; i &lt; NAME_LENGTH; i++) {
    namePart[i] = <strong class="bold">randomLetterFunc()</strong>;
  }
  return namePart.join("") + fileExtension;
};</pre>
			<p>Now, we have removed the inherent impurity from this function. If we want to provide a predefined pseudorandom function that returns fixed, known values, we can easily unit-test this function; we’ll see how in the following examples. The usage of the function will change, and we would have to write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
let fn = getRandomFileName2(".pdf", getRandomLetter);</pre>
			<p>If this bothers you, you may want to provide a default value for the <strong class="source-inline">randomLetterFunc</strong> parameter <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
const getRandomFileName3 = (
  fileExtension = "",
  randomLetterFunc: () =&gt; string <strong class="bold">= getRandomLetter</strong>
): string =&gt; {
  const NAME_LENGTH = 12;
  const namePart = new Array(NAME_LENGTH);
  for (let i = 0; i &lt; NAME_LENGTH; i++) {
    namePart[i] = randomLetterFunc();
  }
  return namePart.join("") + fileExtension;
};</pre>
			<p>You can also solve this using <strong class="bold">partial application</strong>, as we’ll see in <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <span class="No-Break"><em class="italic">Transforming Functions</em></span><span class="No-Break">.</span></p>
			<p>This hasn’t actually<a id="_idIndexMarker247"/> avoided the usage of impure functions. Normally, you’ll call <strong class="source-inline">getRandomFileName()</strong> by providing it with the random letter generator we wrote, so it will behave as an impure function. However, if for testing purposes you provide a function that returns predefined (that is, not random) letters, you’ll be able to test it as if it were pure much <span class="No-Break">more easily.</span></p>
			<p>But what about the original problem function, <strong class="source-inline">getRandomLetter()</strong>? We can apply the same trick and write a new version, such as the following, which will have an argument that will produce <span class="No-Break">random numbers:</span></p>
			<pre class="source-code">
// random.ts
const getRandomLetter2 = (
  getRandomNum: () =&gt; number <strong class="bold">= Math.random.bind(Math)</strong>
): string =&gt; {
  const min = "A".charCodeAt(0);
  const max = "Z".charCodeAt(0);
  return String.fromCharCode(
    Math.floor(getRandomNum() * (1 + max - min)) + min
  );
};</pre>
			<p>We should change <strong class="source-inline">getRandomFileName3()</strong> to call <strong class="source-inline">getRandomLetter2()</strong>. If it calls it without providing any parameters, <strong class="source-inline">getRandomLetter2()</strong> will behave in its expected random ways. But if we want to test whether <strong class="source-inline">getRandomFileName3()</strong> does what we wanted, we can run it with an injected function that will return whatever we decide, letting us test <span class="No-Break">it thoroughly.</span></p>
			<p class="callout-heading">Bind them all</p>
			<p class="callout">For the default of <strong class="source-inline">getRandomNum</strong>, we wrote <strong class="source-inline">Math.random.bind(Math)</strong>, as explained in the <em class="italic">Working with methods</em> section of the previous chapter. The alternative (arguably clearer for some people) is <strong class="source-inline">() =&gt; Math.random()</strong>; we’ll use it in the <em class="italic">Is your function pure?</em> section later in this chapter, just <span class="No-Break">for variety.</span></p>
			<p>Let’s finish this section with a <a id="_idIndexMarker248"/>more complex case: what happens with a function with multiple impurities? For instance, we could be working on a backend <strong class="source-inline">calculateDebt()</strong> service that calculates a person’s debt, given their <strong class="source-inline">id</strong>. To do that, we could access a database, get the list of the person’s invoices, and then call some service to get the amount owed in each invoice; the sum of those amounts would be the calculated debt. A skeleton of such a function could be as follows—and I’m using plain JavaScript to omit <span class="No-Break">unnecessary details:</span></p>
			<pre class="source-code">
// calculateDebt.js
const calculateDebt = async (id) =&gt; {
  // access a database to get a list of invoices
  const listOfInvoices =
    <strong class="bold">await mySqlConn.query(/* SQL query to get invoices */)</strong>;
  // call a remote service to learn what's owed for each
  const owedAmounts =
    <strong class="bold">await axios.get(/* API call to get owed amounts */)</strong>;
  const calculatedDebt = owedAmounts.reduce(
    (x, y) =&gt; x + y,
    0
  );
  return calculatedDebt;
};</pre>
			<p>(If <strong class="source-inline">calculatedDebt = wedAmounts.reduce(…)</strong> is foreign to you, see the <em class="italic">Summing an array</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Programming Declaratively</em></span><span class="No-Break">.)</span></p>
			<p>We cannot easily test such a function because it depends on the availability of a database and another service. To <em class="italic">purify</em> it, we need to inject two functions: one to get data from a database and <a id="_idIndexMarker249"/>another to query a service. The purified function would <span class="No-Break">become this:</span></p>
			<pre class="source-code">
// continued...
const calculateDebt2 = async (
  id,
<strong class="bold">  { getInvoices, getOwedAmounts } =</strong>
<strong class="bold">    { getInvoicesFromDb, getOwedAmountFromAPI }</strong>
) =&gt; {
  const listOfInvoices = await getInvoices(id);
  const owedAmounts = await getOwedAmounts(listOfInvoices);
  const calculatedDebt = owedAmounts.reduce(
    (x, y) =&gt; x + y,
    0
  );
  return calculatedDebt;
};</pre>
			<p>In this code, <strong class="source-inline">getInvoicesFromDb()</strong> and <strong class="source-inline">getOwedAmountFromAPI()</strong> would be the functions that do the DB access and API call. Our <strong class="source-inline">calculateDebt2()</strong> function now doesn’t know (or need to know) the details of how to access and work with the DB or the other service; that’s a better <span class="No-Break">software design.</span></p>
			<p>Now, the function has two parameters: <strong class="source-inline">id</strong> (as before) and an optional object with the two functions to be injected. In regular use, we wouldn’t supply the second parameter, and the function accesses the DB and calls the API as needed. But here’s the point: for testing purposes, we inject an object with two mock functions and are then able to write simple tests. (If you are wondering why we injected an object, see <span class="No-Break"><em class="italic">Question 4.8</em></span><span class="No-Break">.)</span></p>
			<p>An extra detail: thorough real-world testing of functions is usually hard to achieve. For instance, how do you simulate a dropped connection or a failed service call? With injection, that’s no problem; we can easily provide a mock that will return wrong values, throw an exception, and do anything else you need for your <span class="No-Break">complete testing.</span></p>
			<p>Using injection to avoid<a id="_idIndexMarker250"/> impurities is very important and has a broad spectrum of applications for other problems. For example, instead of having a function directly access the DOM, we can provide it with injected functions that would do this. For testing purposes, it would be simple to verify that the tested function does what it needs to do without really interacting with the DOM (of course, we’d have to find another way to test those DOM-related functions). This can also apply to functions that need to update the DOM, generate new elements, and do all sorts of manipulations—you use some intermediary functions. We’ll even apply injection in <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><em class="italic">, Implementing Design Patterns,</em> to derive a better system architecture, so it’s a powerful, <span class="No-Break">key concept.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Is your function pure?</h2>
			<p>Let’s end this <a id="_idIndexMarker251"/>section by considering an important question: can you ensure that a function is truly pure? To show the difficulties of this task, we’ll go back to the simple <strong class="source-inline">sum3()</strong> function that we saw in the <em class="italic">Spread</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional </em>, just rewritten to use arrow functions for brevity. Would you say that this function is pure? It certainly looks <span class="No-Break">like it!</span></p>
			<pre class="source-code">
// sum3.ts (in chapter 3)
const sum3 = (x: number, y: number, z: number): number =&gt;
  x + y + z;</pre>
			<p>Let’s see: the function doesn’t access anything but its parameters, doesn’t even try to modify them (not that it could (or could it?)), doesn’t perform any I/O, or work with any of the impure functions or methods that we mentioned earlier. What could <span class="No-Break">go wrong?</span></p>
			<p>The answer has to do with checking your assumptions. For example, who says the arguments for this function should be numbers? In plain JavaScript, we could call it with, say, strings, but we’re now using TypeScript, and it’s supposed to check that, right? And even if passing strings to the function, you might ask yourself: <em class="italic">OK, they could be strings, but the function would still be pure, wouldn’t it?</em> For an (assuredly evil!) answer to that, see the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// sum3.trick.ts
<strong class="bold">const x = {} as number;</strong>
<strong class="bold">x.valueOf = () =&gt; Math.random();</strong>
const y = 1;
const z = 2;
console.log(sum3(x, y, z)); // 3.2034400919849431
console.log(sum3(x, y, z)); // 3.8537045249277906
console.log(sum3(x, y, z)); // 3.0833258308458734</pre>
			<p class="callout-heading">Evil coding!</p>
			<p class="callout">We assigned a new function to the <strong class="source-inline">x.valueOf()</strong> method to make an object look like a number. We also lied when saying  <strong class="source-inline">x = {} as number</strong>; otherwise, TypeScript would have objected that you were passing an object where a number <span class="No-Break">was expected.</span></p>
			<p>Well, <strong class="source-inline">sum3()</strong> ought to<a id="_idIndexMarker252"/> be pure, but that actually depends on whichever parameters you pass to it; you can make a pure function behave impurely! You might console yourself by thinking that surely no one would pass such arguments, but edge cases are usually where bugs reside. But you need not resign yourself to abandoning the idea of pure functions. As we see, you can even con TypeScript into accepting wrong data types, so you can never be totally sure that your code is <span class="No-Break">always pure!</span></p>
			<p>Throughout these sections, we have gone through the characteristics of pure and impure functions. Let’s finish the chapter by looking at how we can test these sorts <span class="No-Break">of functions.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Testing – pure versus impure</h1>
			<p>We have seen how pure functions are conceptually better than impure ones, but we cannot set out on a crusade to vanquish all impurities from our code. First, no one can deny that side effects can be useful, or at least unavoidable: you will need to interact with the DOM or call a web service, and there are no ways to do this in a pure way. So, rather than bemoaning the fact that you have to allow for impurity, try to structure your code to isolate the impure functions and let the rest of your code be the best it can <span class="No-Break">possibly be.</span></p>
			<p>With this in mind, you’ll have to be able to write unit tests for all kinds of functions, pure or impure. Writing unit tests is different, in terms of difficulty and complexity, for pure and impure functions. While coding tests for the former is usually quite simple and follows a basic pattern, the latter usually requires scaffolding and complex setups. So, let’s finish this chapter by seeing how to go about testing both types <span class="No-Break">of functions.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Testing pure functions</h2>
			<p>Given the characteristics of pure <a id="_idIndexMarker253"/>functions that we have already described, most of your unit tests could be <span class="No-Break">the following:</span></p>
			<ul>
				<li>Calling the function with a given set <span class="No-Break">of arguments</span></li>
				<li>Verifying that the results match what <span class="No-Break">you expected</span></li>
			</ul>
			<p>Let’s start with a couple of simple examples. Testing the <strong class="source-inline">isOldEnough()</strong> function would have been more complex than we needed for the version that required access to a global variable. On the other hand, the last version, <strong class="source-inline">isOldEnough3()</strong>, which didn’t require anything because it received two parameters, is simple <span class="No-Break">to test:</span></p>
			<pre class="source-code">
// isOldEnough.test.ts
describe("isOldEnough", function () {
  it("is false for people younger than 18", () =&gt; {
    expect(isOldEnough3(2010, 2022)).toBe(false);
  });
  it("is true for people older than 18", () =&gt; {
    expect(isOldEnough3(1960, 2022)).toBe(true);
  });
  it("is true for people exactly 18", () =&gt; {
    expect(isOldEnough3(2004, 2022)).toBe(true);
  });
});</pre>
			<p>Testing another of the pure functions we wrote is equally simple, but we must be careful because of precision considerations. If we test the <strong class="source-inline">circleArea</strong> function, we must use the Jest <strong class="source-inline">toBeCloseTo()</strong> matcher, which allows for approximate equality when dealing with floating-point numbers. (See <em class="italic">Question 4.9</em> for more on math in JavaScript.) Other than this, the tests are just about the same—call the function with known arguments and check the <span class="No-Break">expected results:</span></p>
			<pre class="source-code">
// area.test.ts
describe("circle area", function () {
  it("is zero for radius 0", () =&gt; {
    const area = circleArea(0);
    expect(area).toBe(0);
  });
  it("is PI for radius 1", () =&gt; {
    expect(circleArea(1)).toBeCloseTo(Math.PI);
  });
  it("is approximately 12.5664 for radius 2", () =&gt;
    expect(circleArea(2)).toBeCloseTo(12.5664));
});</pre>
			<p>No difficulty<a id="_idIndexMarker254"/> whatsoever! (I wrote the three tests in different styles on purpose, just for variety.) The test run reports success for both suites (see <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_4.3_B19301.jpg" alt="Figure 4.3 – A successful test run for a pair of pure functions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – A successful test run for a pair of pure functions</p>
			<p>We don’t have to <a id="_idIndexMarker255"/>worry about pure functions; let’s move on to the impure ones we dealt with by transforming them into <span class="No-Break">pure equivalents.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Testing purified functions</h2>
			<p>When we considered the<a id="_idIndexMarker256"/> following <strong class="source-inline">roundFix()</strong> special function that required us to use the state to accumulate the differences due to rounding, we produced a new version by providing the current state as an added parameter and by having the function return two values—the rounded one and the <span class="No-Break">updated state:</span></p>
			<pre class="source-code">
// roundFix.ts
const roundFix2 = (accum: number, n: number) =&gt; {
  const nRounded = accum &gt; 0 ? Math.ceil(n) :
    Math.floor(n);
  accum += n - nRounded;
  return { accum, nRounded };
};</pre>
			<p>This function is now pure, but testing it requires validating not only the returned values but also the updated states. We can base our tests on the experiments we did previously. Once again, we have to use <strong class="source-inline">toBeCloseTo()</strong> for dealing with floating-point numbers (and see <em class="italic">Question 4.10</em> for more on this), but we can use <strong class="source-inline">toBe()</strong> with integers, which <a id="_idIndexMarker257"/>produces no rounding errors. We could write our tests <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// roundFix.test.ts
describe("roundFix2", function () {
  it("rounds 3.14159-&gt;3 if differences are 0", () =&gt; {
    const { accum, nRounded } = roundFix2(0.0, 3.14159);
    expect(accum).toBeCloseTo(0.14159);
    expect(nRounded).toBe(3);
  });
  it("rounds 2.71828-&gt;3 if differences are 0.14159", () =&gt; {
    const { accum, nRounded } = roundFix2(0.14159,
      2.71828);
    expect(accum).toBeCloseTo(-0.14013);
    expect(nRounded).toBe(3);
  });
  it("rounds 2.71828-&gt;2 if differences are -0.14013", () =&gt; {
    const { accum, nRounded } = roundFix2(
      -0.14013,
      2.71828
    );
    expect(accum).toBeCloseTo(0.57815);
    expect(nRounded).toBe(2);
  });
  it("rounds 3.14159-&gt;4 if differences are 0.57815", () =&gt; {
    const { accum, nRounded } = roundFix2(0.57815,
      3.14159);
    expect(accum).toBeCloseTo(-0.28026);
    expect(nRounded).toBe(4);
  });
});</pre>
			<p>We included <a id="_idIndexMarker258"/>several cases, with positive, zero, or negative accumulated differences, and checked whether they rounded up or down on each occasion. We could certainly go further by rounding negative numbers, but the idea is clear: if your function takes the current state as a parameter and updates it, the only difference with the pure functions’ tests is that you will also have to test whether the returned state matches <span class="No-Break">your expectations.</span></p>
			<p>Let’s now consider an alternative way of testing for our <em class="italic">purified</em> <strong class="source-inline">getRandomLetter2()</strong> function. This is simple: you have to provide a function that produces random numbers. (This kind of function, in testing parlance, is called a stub.) There’s no limit to the complexity of a stub, but you’ll want to keep <span class="No-Break">it simple.</span></p>
			<p>Based on our knowledge of the workings of the function, we can then do some tests to verify that low values produce an <strong class="source-inline">"A"</strong> output and values close to 1 produce a <strong class="source-inline">"Z"</strong> output so that we can have a little confidence that no extra values are produced. We should also test that a middle value (around 0.5) should generate a letter around the middle of the alphabet. However, this kind of test is not very good—if we implemented <strong class="source-inline">getRandomLetter2()</strong> in another way, it might work perfectly well but not pass this test! Our tests could be written <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// random.test.ts
describe("getRandomLetter2", function () {
  it("returns A for values close to 0", () =&gt; {
    const letterSmall = getRandomLetter2(() =&gt; 0.0001);
    expect(letterSmall).toBe("A");
  });
  it("returns Z for values close to 1", () =&gt; {
    const letterBig = getRandomLetter2(() =&gt; 0.99999);
    expect(letterBig).toBe("Z");
  });
  it("returns middle letter for values around 0.5", () =&gt; {
    const letterMiddle = getRandomLetter2(() =&gt;
      0.49384712);
    expect(letterMiddle &gt; "G").toBeTruthy();
    expect(letterMiddle &lt; "S").toBeTruthy();
  });
  it("returns ascending letters for ascending #s", () =&gt; {
    const letter1 = getRandomLetter2(() =&gt; 0.09);
    const letter2 = getRandomLetter2(() =&gt; 0.22);
    const letter3 = getRandomLetter2(() =&gt; 0.60);
    expect(letter1 &lt; letter2).toBeTruthy();
    expect(letter2 &lt; letter3).toBeTruthy();
  });
});</pre>
			<p>Testing our filename<a id="_idIndexMarker259"/> generator can be done similarly, by using stubs. We can provide a simple stub, <strong class="source-inline">f()</strong>, that will return the letters of <strong class="source-inline">"SORTOFRANDOM"</strong> in sequence (this function is quite impure; can you see why?). So, we can verify that the returned filename matches the expected name and a couple more properties of the returned filename, such as its length and extension. Our test could then be written <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
describe("getRandomFileName3", function () {
  let a: string[] = [];
  const f = () =&gt; a.shift() as string;
  beforeEach(() =&gt; {
    a = "SORTOFRANDOM".split("");
  });
  it("uses the given letters for the file name", () =&gt; {
    const fileName = getRandomFileName3("", f);
    expect(fileName.startsWith("SORTOFRANDOM")).toBe(true);
  });
  it("includes right extension, has right length", () =&gt; {
    const fileName = getRandomFileName3(".pdf", f);
    expect(fileName.endsWith(".pdf")).toBe(true);
    expect(fileName.length).toBe(16);
  });
});</pre>
			<p>Testing <em class="italic">purified</em> impure <a id="_idIndexMarker260"/>functions is the same as testing originally pure functions. Now, we need to consider some cases of truly impure functions because, as we said, it’s quite certain that at some time or another, you’ll have to use <span class="No-Break">such functions.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Testing impure functions</h2>
			<p>For starters, we’ll return to our<a id="_idIndexMarker261"/> original <strong class="source-inline">getRandomLetter()</strong> function. With insider knowledge about its implementation (this is <a id="_idIndexMarker262"/>called <strong class="bold">white-box testing</strong>, as opposed <a id="_idIndexMarker263"/>to <strong class="bold">black-box testing</strong>, where we know nothing about the function’s code itself), we can <em class="italic">spy on</em> (a Jest expression) on the <strong class="source-inline">Math.random()</strong> method and set a mock function that will return whichever values <span class="No-Break">we desire.</span></p>
			<p>We can revisit some of the test cases we went through in the previous section. In the first case, we set <strong class="source-inline">Math.random()</strong> to return 0.0001 (and test that it was actually called) and we also check that the final return is <strong class="source-inline">"A"</strong>. In the second case, just for variety, we set things up so that <strong class="source-inline">Math.random()</strong> will be called twice, returning two different values. We also verify that both results are <strong class="source-inline">"Z"</strong>. Our revisited tests could look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
describe("getRandomLetter", function () {
  afterEach(() =&gt; {
    // so count of calls to Math.random will be OK
    jest.restoreAllMocks();
  });
  it("returns A for values ~ 0", () =&gt; {
    jest.spyOn(Math, "random").mockReturnValue(0.00001);
    const letterSmall = getRandomLetter();
    expect(Math.random).toHaveBeenCalled();
    expect(letterSmall).toBe("A");
  });
  it("returns Z for values ~ 1", () =&gt; {
    jest
      .spyOn(Math, "random")
      .mockReturnValueOnce(0.988)
      .mockReturnValueOnce(0.999);
    const letterBig1 = getRandomLetter();
    const letterBig2 = getRandomLetter();
    expect(Math.random).toHaveBeenCalledTimes(2);
    expect(letterBig1).toBe("Z");
    expect(letterBig2).toBe("Z");
  });
  it("returns middle letter for values ~ 0.5", () =&gt; {
    jest.spyOn(Math, "random").mockReturnValue(0.49384712);
    const letterMiddle = getRandomLetter();
    expect(Math.random).toHaveBeenCalledTimes(1);
    expect(letterMiddle &gt; "G").toBeTruthy();
    expect(letterMiddle &lt; "S").toBeTruthy();
  });
});</pre>
			<p>(Of course, you wouldn’t go around inventing whatever tests came into your head. In all likelihood, you’ll work from the description of the desired <strong class="source-inline">getRandomLetter()</strong> function, which was written before you started to code or test it. In our case, I’m making do as if that specification did exist, and it pointedly said—for example—that values close to 0 should produce an <strong class="source-inline">"A"</strong> output, values close to 1 should return <strong class="source-inline">"Z"</strong>, and the function should return ascending letters for ascending <span class="No-Break">random values.)</span></p>
			<p>Now, how <a id="_idIndexMarker264"/>would you test the original <strong class="source-inline">getRandomFileName()</strong> function, the one that called the impure <strong class="source-inline">getRandomLetter()</strong> function? That’s a much more <span class="No-Break">complicated problem.</span></p>
			<p>What kind of expectations do you have? You cannot know the results it will give, so you won’t be able to write any <strong class="source-inline">.toBe()</strong> type of tests. What you can do is test for some properties of the expected results, and also, if your function implies randomness of some kind, you can repeat the tests as many times as you want so that you have a bigger chance of catching a bug. We could do some tests along the lines of the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
describe("getRandomFileName+impure getRandomLetter", () =&gt; {
  it("generates 12 letter long names", () =&gt; {
    for (let i = 0; i &lt; 100; i++) {
      expect(getRandomFileName().length).toBe(12);
    }
  });
  it("generates names with letters A to Z, only", () =&gt; {
    for (let i = 0; i &lt; 100; i++) {
      const name = getRandomFileName();
      for (let j = 0; j &lt; name.length; j++) {
        expect(name[j] &gt;= "A" &amp;&amp; name[j] &lt;=
          "Z").toBe(true);
      }
    }
  });
  it("includes right extension if provided", () =&gt; {
    const fileName1 = getRandomFileName(".pdf");
    expect(fileName1.length).toBe(16);
    expect(fileName1.endsWith(".pdf")).toBe(true);
  });
  it("doesn't include extension if not provided", () =&gt; {
    const fileName2 = getRandomFileName();
    expect(fileName2.length).toBe(12);
    expect(fileName2.includes(".")).toBe(false);
  });
});</pre>
			<p>We are not <a id="_idIndexMarker265"/>passing any random letter generator function to <strong class="source-inline">getFileName()</strong>, so it will use the original, impure one. We ran some of the tests a hundred times, as extra insurance. Our tests check for <span class="No-Break">the following:</span></p>
			<ul>
				<li>Filenames are 12 <span class="No-Break">letters long</span></li>
				<li>Names only include letters “<strong class="source-inline">A</strong>” <span class="No-Break">to “</span><span class="No-Break"><strong class="source-inline">Z</strong></span><span class="No-Break">”</span></li>
				<li>Filenames include the <span class="No-Break">provided extension</span></li>
				<li>If no extension is provided, none <span class="No-Break">is included</span></li>
			</ul>
			<p class="callout-heading">Need for evidence</p>
			<p class="callout">When testing code, always remember that <em class="italic">absence of evidence isn’t evidence of absence</em>. Even if our repeated tests succeed, there is no guarantee that they won’t produce an unexpected, hitherto undetected, error with some other <span class="No-Break">random input.</span></p>
			<p>Let’s do another property test. Suppose we want to test a shuffling algorithm; we might decide to implement the Fisher–Yates version along the lines of the following code. (For more on this algorithm—including some pitfalls for the unwary programmer—see <a href="http://en.wikipedia.org/wiki/Fisher-Yates_shuffle">en.wikipedia.org/wiki/Fisher-Yates_shuffle</a>.) As implemented, the algorithm is doubly impure: it doesn’t always produce the same result (obviously!) and it modifies its <span class="No-Break">input parameter:</span></p>
			<pre class="source-code">
// shuffle.test.ts
const shuffle = &lt;T&gt;(arr: T[]): T[] =&gt; {
  const len = arr.length;
  for (let i = 0; i &lt; len - 1; i++) {
    let r = Math.floor(Math.random() * (len - i));
    [arr[i], arr[i + r]] = [arr[i + r], arr[i]];
  }
  return arr;
};
const xxx = [11, 22, 33, 44, 55, 66, 77, 88];
console.log(shuffle(xxx));
// [55, 77, 88, 44, 33, 11, 66, 22]</pre>
			<p>How could you test<a id="_idIndexMarker266"/> this algorithm? Given that the result won’t be predictable, we can check for the properties of its output. We can call it with a known array and then test some properties—but see <em class="italic">Question 4.13</em> for an <span class="No-Break">important detail:</span></p>
			<pre class="source-code">
// continued...
describe("shuffleTest", function () {
  it("shouldn't change the array length", () =&gt; {
    const a = [22, 9, 60, 12, 4, 56];
    shuffle(a);
    expect(a.length).toBe(6);
  });
  it("shouldn't change the values", () =&gt; {
    const a = [22, 9, 60, 12, 4, 56];
    shuffle(a);
    expect(a.includes(22)).toBe(true);
    expect(a.includes(9)).toBe(true);
    expect(a.includes(60)).toBe(true);
    expect(a.includes(12)).toBe(true);
    expect(a.includes(4)).toBe(true);
    expect(a.includes(56)).toBe(true);
  });
});</pre>
			<p>We had to write the <a id="_idIndexMarker267"/>second part of the unit tests in that way because, as we saw, <strong class="source-inline">shuffle()</strong> modifies the input parameter. For tests for a different (and bad!) shuffling function, see <span class="No-Break"><em class="italic">Question 4.14</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Summary</h1>
			<p>In this chapter, we introduced the concept of pure functions and studied why they matter. We also saw the problems caused by side effects—one of the causes of impure functions—looked at some ways of purifying such impure functions, and finally, we saw several ways of performing unit tests for both pure and impure functions. With these techniques, you’ll be able to favor using pure functions in your programming, and when impure functions are needed, you’ll have some ways of using them in a <span class="No-Break">controlled manner.</span></p>
			<p>In <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, we’ll show other advantages of FP: how you can program in a declarative fashion at a higher level for more straightforward and <span class="No-Break">robust code.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Questions</h1>
			<p>4.1 <strong class="bold">Must return?</strong>A simple, almost philosophical question: must pure functions always return something? Could you have a pure function that doesn’t <span class="No-Break">return anything?</span></p>
			<p>4.2 <strong class="bold">Well-specified return</strong>: What would have happened if we had added the return type definition <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">maxStrings()</strong></span><span class="No-Break">?</span></p>
			<pre class="source-code">
const maxStrings = (a: string[])<strong class="bold">: string</strong> =&gt; a.sort().pop();</pre>
			<p>4.3 <strong class="bold">Go for a closure</strong>: As suggested in the <em class="italic">Memoization</em> section, use a closure to avoid needing a global <strong class="source-inline">cache</strong> array for the optimized <span class="No-Break"><strong class="source-inline">fib2()</strong></span><span class="No-Break"> function.</span></p>
			<p>4.4 <strong class="bold">Minimalistic function</strong>: Functional programmers sometimes write code in a minimalistic way. Can you examine the following version of the Fibonacci function and explain whether it works, and if <span class="No-Break">so, how?</span></p>
			<pre class="source-code">
// fibonacci.ts
const fib3 = (n: number): number =&gt;
  n &lt; 2 ? n : fib2(n - 2) + fib2(n - 1);</pre>
			<p>4.5 <strong class="bold">A cheaper way</strong>: The following version of the Fibonacci function is quite efficient, doesn’t require memoization or caching, and doesn’t require unnecessary or repeated computations. Can you see how? Here’s a suggestion: try to calculate <strong class="source-inline">fib4(6)</strong> by hand and compare it with the example given earlier in <span class="No-Break">the book:</span></p>
			<pre class="source-code">
// fibonacci.ts
const fib4 = (n: number, a = 0, b = 1): number =&gt;
  n === 0 ? a : fib4(n - 1, b, a + b);</pre>
			<p>4.6 <strong class="bold">Rounding type</strong>: What’s the type of the <strong class="source-inline">roundFix2()</strong> function? Even when TypeScript can work it out by itself (as in this case), I prefer spelling it out for <span class="No-Break">extra checks.</span></p>
			<p>4.7 <strong class="bold">Tuples to go</strong>: If we need to return more than one value from a function, we can return an array instead of an object. For better clarity, TypeScript allows using <em class="italic">tuples</em>, which are arrays of known length and data types. (See <a href="http://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types">www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types</a> for more on this.) Rewrite <strong class="source-inline">roundFix2()</strong> so that it will return a tuple instead of a record. The input to this rewritten function could be two separate arguments or a single <span class="No-Break">tuple argument.</span></p>
			<p>4.8 <strong class="bold">One injection or two?</strong> Why is it better to inject an object with two functions rather than two separate functions? In other words, why not write something like <span class="No-Break">the following?</span></p>
			<pre class="source-code">
const calculateDebt2 = async (
  id,
<strong class="bold">  getInvoices = getInvoicesFromDb,</strong>
<strong class="bold">  getOwedAmounts = getOwedAmountFromAPI</strong>
) =&gt; … ;</pre>
			<p>4.9 <strong class="bold">JavaScript does math?</strong> In the <em class="italic">Testing purified functions</em> section, we mentioned the need for <strong class="source-inline">toBeCloseTo()</strong> because of precision problems. A related question, often asked in job interviews, is <em class="italic">what will the following code output, </em><span class="No-Break"><em class="italic">and why?</em></span></p>
			<pre class="source-code">
const a = 0.1;
const b = 0.2;
const c = 0.3;
if (a + b === c) {
  console.log("Math works!");
} else {
  console.log("Math failure?");
}</pre>
			<p>4.10 <strong class="bold">Breaking laws</strong>: Using <strong class="source-inline">toBeCloseTo()</strong> is practical but can cause problems. Some basic mathematics properties are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>A number should equal itself: for all numbers <em class="italic">a</em>, <em class="italic">a</em> should <span class="No-Break">equal </span><span class="No-Break"><em class="italic">a</em></span></li>
				<li>If <em class="italic">a</em> equals <em class="italic">b</em>, then <em class="italic">b</em> should <span class="No-Break">equal </span><span class="No-Break"><em class="italic">a</em></span></li>
				<li>If <em class="italic">a</em> equals <em class="italic">b</em>, and <em class="italic">b</em> equals <em class="italic">c</em>, then <em class="italic">a</em> should <span class="No-Break">equal </span><span class="No-Break"><em class="italic">c</em></span></li>
				<li>If <em class="italic">a</em> equals <em class="italic">b</em>, and <em class="italic">c</em> equals <em class="italic">d</em>, then <em class="italic">a</em>+<em class="italic">c</em> should equal <em class="italic">b</em>+<em class="italic">d</em>, <em class="italic">a</em>-<em class="italic">c</em> should equal <em class="italic">b</em>-<em class="italic">d</em>, <em class="italic">a</em>*<em class="italic">c</em> should equal <em class="italic">b</em>*<em class="italic">d</em>, and <em class="italic">a</em>/<em class="italic">c</em> should <span class="No-Break">equal </span><span class="No-Break"><em class="italic">b</em></span><span class="No-Break">/</span><span class="No-Break"><em class="italic">d</em></span></li>
			</ul>
			<p>Does <strong class="source-inline">toBeCloseTo()</strong> satisfy all <span class="No-Break">these properties?</span></p>
			<p>4.11 <strong class="bold">Shuffling kinds</strong>: Why did we need to use a generic type <strong class="source-inline">&lt;T&gt;</strong> in the definition <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">shuffle()</strong></span><span class="No-Break">?</span></p>
			<p>4.12 <strong class="bold">No return needed</strong>: Given that <strong class="source-inline">shuffle()</strong> modifies the input array in place (a side effect!) we don’t really need the final <strong class="source-inline">return arr</strong> line and could remove it. What would be the type definition of <span class="No-Break"><strong class="source-inline">shuffle()</strong></span><span class="No-Break"> then?</span></p>
			<p>4.13. <strong class="bold">A shuffle test</strong>: How would you write unit tests for <strong class="source-inline">shuffle()</strong> to test whether it works correctly with arrays with repeated values? The tests we wrote are only valid for arrays with distinct values; can you <span class="No-Break">see why?</span></p>
			<p>4.14 <strong class="bold">Popular, but wrong!</strong> Many online articles suggest the following code as a way of shuffling. The idea is to sort the array, but, instead of using a correct comparison function to randomly return positive or negative values, these random comparisons should get the array in disorder. However, the idea is wrong and the algorithm is bad because it doesn’t produce all possible outputs with equal probability. How can you <span class="No-Break">check that?</span></p>
			<pre class="source-code">
const poorShuffle = (arr) =&gt;
  arr.sort(<strong class="bold">() =&gt; Math.random() - 0.5</strong>);</pre>
			<p>4.15 <strong class="bold">Shuffling by sorting</strong>: Sorting and shuffling can be seen as opposite functions; one brings order, and the other produces disorder. However, there’s a way to shuffle an array by sorting; can you figure out how? (And no, the answer is <em class="italic">not</em> the lousy algorithm shown in the previous question!) We are looking for an algorithm that can produce every possible output with the same probability, not favoring some outputs <span class="No-Break">over others.</span></p>
		</div>
	</body></html>