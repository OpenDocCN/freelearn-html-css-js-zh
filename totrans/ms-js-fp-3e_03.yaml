- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting Out with Functions – A Core Concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*,
    we discussed an example of FP thinking, but now, let’s look at the basics and
    review functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss functions in JavaScript, including how to define them, with a particular
    focus on arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about currying and functions as first-class objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore several ways of using functions in an FP way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After going through all this content, you’ll be up to date with the generic
    and specific concepts relating to functions, which are, after all, at the core
    of FP!
  prefs: []
  type: TYPE_NORMAL
- en: All about functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with a short review of functions in JavaScript and their relationship
    to FP concepts. We will begin with something that we mainly mentioned in the *Functions
    as first-class objects* section of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*,
    Becoming Functional,* and again in a couple of places in [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037),
    *Thinking Functionally*, and then go on to several considerations about their
    usage in actual coding. In particular, we’ll be looking at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Some basic concepts about lambda calculus, which is the theoretical basis for
    FP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions, which are the most direct translation of lambda calculus into
    JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functions as first-class objects, a key concept in FP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of lambdas and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In lambda calculus terms, a function can look like λ*x*.2**x*. The understanding
    is that the variable after the λ character (the Greek letter *lambda* in lowercase)
    is the parameter for the function, and the expression after the dot is where you
    would replace whatever value is passed as an argument. Later in this chapter,
    we will see that this particular example could be written as `(x) => 2*x` in JavaScript
    in arrow function form, which, as you can see, is very similar.
  prefs: []
  type: TYPE_NORMAL
- en: An alliterative aid
  prefs: []
  type: TYPE_NORMAL
- en: 'If you sometimes wonder about the difference between arguments and parameters,
    a mnemonic with some alliteration may help: *Parameters are Potential, Arguments
    are Actual*. Parameters are placeholders for potential values that will be passed,
    and arguments are the actual values passed to the function. In other words, when
    you define the function, you list its parameters, and when you call it, you provide
    arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying a function means you provide an actual argument to it, which is written
    in the usual way, using parentheses. For example, (λ*x*.2**x*)(3) would be calculated
    as 6\. What’s the equivalent of these lambda functions in JavaScript? That’s an
    interesting question! There are several ways of defining functions, and not all
    have the same meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'In how many ways can you define a function in JavaScript? The answer is probably
    in more ways than you thought! (A good article that shows the many ways of defining
    functions, methods, and more is *The Many Faces of Functions in JavaScript*, by
    Leo Balter and Rick Waldron, at [bocoup.com/blog/the-many-faces-of-functions-in-javascript](http://bocoup.com/blog/the-many-faces-of-functions-in-javascript)
    – give it a look!) At the very least, you could write the following – and I’ll
    use vanilla JavaScript because here types aren’t a concern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A named function declaration: `function` `first(...) {...};`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An anonymous function expression: `var second =` `function(...) {...};`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A named function expression: `var third = function` `someName(…) {...};`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An immediately-invoked expression: `var fourth = (function() { ...; return
    function(...) {...}; })();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function constructor: `var fifth =` `new Function(...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An arrow function: `var sixth = (...) => {...};`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you wanted, you could add object method declarations since they also imply
    functions, but the preceding list should be enough.
  prefs: []
  type: TYPE_NORMAL
- en: More function types
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript also allows us to define `function*(...) {...}`) that return a `Generator`
    object and `async` functions that are a mix of generators and promises. You can
    read more about them at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s the difference between all these ways of defining functions, and why
    should we care? Let’s go over them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: The first definition, `function first(...) {...}`, a standalone declaration
    starting with the `function` keyword, is probably the most used in JavaScript
    and defines a function named `first` (that is, `first.name==="first"`). Because
    of `var` definition; with `let` or `const`, hoisting doesn’t apply. You can read
    more about hoisting at [developer.mozilla.org/en-US/docs/Glossary/Hoisting](http://developer.mozilla.org/en-US/docs/Glossary/Hoisting).
    Remember that it applies only to declarations, not to initializations.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `second = function(...) {...}` definition, which assigns a function to
    a variable, also produces a function, but an *anonymous* (that is, not named)
    one. However, many JavaScript engines can deduce what the name should be and will
    then set `second.name === "second"`. (Look at the following code, which shows
    a case where the anonymous function has no name assigned.) Since the assignment
    isn’t hoisted, the function will only be accessible after the assignment has been
    executed. Also, you’d probably prefer defining the variable with `const` rather
    than `var`, because you wouldn’t (shouldn’t) be changing the function – take a
    look at the ESLint `no-var` and `prefer-const` rules to enforce this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third definition, `third = function someName(…) {...}`, is the same as
    the second, except that the function now has its own name: `third.name === "someName"`.
    The name of a function is relevant when you want to call it and is needed for
    recursive calls; we’ll return to this in [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172),
    *Designing Functions*. If you just want a function for, say, a callback, you can
    use one without a name. However, note that named functions are more easily recognized
    in an error traceback, the kind of listing you use when trying to understand what
    happened, and which function called what.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fourth definition, `fourth = (function() { ...; return function(...) {...};
    })()`, with an immediately-invoked expression, lets you use a closure. Going back
    to the counter-making function that we saw in the *Closures* section of [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, we could write something
    like the following. An inner function can use variables or other functions, defined
    in its outer function, in a private, encapsulated way. The outer function receives
    an argument (`77`, in this case) that is used as the initial value of `count`
    (if no initial value is provided, we start at `0`). The inner function can access
    `count` (because of the closure), but the variable cannot be accessed anywhere
    else. In all aspects, the returned function is common – the only difference is
    its access to private elements. This is also the basis of the **module** pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The fifth definition, `fifth = new Function(...)`, isn’t safe and you shouldn’t
    use it! You pass the names of the arguments first, then the actual function body
    as a string, and the equivalent of `eval()` is used to create the function – this
    allows many dangerous hacks, so don’t do this! (Also, TypeScript cannot deduce
    the type of the produced function; it just assumes the generic `Function` type.)
    Just to whet your curiosity, let’s look at an example of rewriting the very simple
    `sum3()` function we saw back in the *Spread* section of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*,*
    *Becoming Functional*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Quirks of eval()
  prefs: []
  type: TYPE_NORMAL
- en: This definition is not only unsafe but has some other quirks – they don’t create
    closures with their creation contexts, so they are always global. See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    for more on this, but remember that this way of creating functions isn’t a good
    idea!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last definition, `sixth = (...) => {...}`, which uses an arrow,
    `=>`, is the most compact way to define a function and the one we’ll try to use
    whenever possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we have seen several ways of defining a function, so let’s focus
    on arrow functions, a style we’ll favor in our coding for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions – the modern way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even if arrow functions work in pretty much the same way as the other functions,
    there are some crucial differences (see [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions))
    between them and the usual ones: arrow functions can implicitly return a value
    even with no return statement present; the value of `this` (the context for the
    function) is not bound; there is no `arguments` object; they cannot be used as
    constructors; they do not have a prototype property; and they cannot be used as
    generators because they don’t allow the `yield` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll go into several JavaScript function-related topics,
    including these:'
  prefs: []
  type: TYPE_NORMAL
- en: How to return different values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle problems with the value of `this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with varying numbers of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important concept, currying, for which we’ll find many usages in the rest
    of this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the lambda coding style, functions only consist of a result. For the sake
    of brevity, the new arrow functions provide a syntax for this. When you write
    something such as `(x,y,z) =>` followed by an expression, a `return` is implied.
    For instance, the following two functions do the same as the `sum3()` function
    that we showed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you want to return an object, you must use parentheses; otherwise, JavaScript
    will assume that code follows. Lest you think this is a wildly improbable case,
    check out *Question 3.1* in the *Questions* section later in this chapter for
    a very common scenario!
  prefs: []
  type: TYPE_NORMAL
- en: A matter of style
  prefs: []
  type: TYPE_NORMAL
- en: When you define an arrow function with only one parameter, you can omit the
    parentheses around it. For consistency, I prefer to always include them. Prettier,
    the formatting tool I use (we mentioned it in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015),
    *Becoming Functional*), originally didn’t approve, but in version 2.0, it changed
    the default of its `arrow-parens` configuration item from `avoid` (meaning, try
    to do without parentheses) to `always`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the `this` value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A classic problem with JavaScript is handling `this`, whose value isn’t always
    what you expect it to be. ES2015 solved this with arrow functions, which inherit
    the proper `this` value so that problems are avoided. Look at the following code
    for an example of the possible problems: by the time the timeout function is called,
    `this` will point to the global (`window`) variable instead of the new object,
    so you’ll get `undefined` in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are traditional ways of solving this with old-fashioned JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: One solution uses a closure and defines a local variable (usually named `that`
    or sometimes `self`) that will get the original value of `this`, so it won’t be
    undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way uses `bind()`, so the timeout function will be bound to the correct
    value of this (we used `bind()` for a similar purpose in the *Of lambdas and*
    *functions* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third, more modern way just uses an arrow function, so `this` gets the correct
    value (pointing to the object) without further ado
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see the three solutions in actual code. We use a closure for the first
    timeout, binding for the second, and an arrow function for the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you’ll get `JavaScript` after 1 second, then again after
    another second, and a third time after another second. All three methods worked
    correctly, so whichever you pick just depends on which you like better.
  prefs: []
  type: TYPE_NORMAL
- en: Working with arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, and
    [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*, we saw
    some uses of the spread (`...`) operator. However, the most practical usage we’ll
    be making of it has to do with working with arguments; we’ll see some cases of
    this in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review our `once()` function from [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037)*,*
    *Thinking Functionally*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Why are we writing `return (...args) =>` and then afterward `func(...args)`?
    The answer has to do with the more modern way of handling a variable number (possibly
    zero) of arguments. How did you manage such kinds of code in older versions of
    JavaScript? The answer is the `arguments` object (not an array; read [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments))
    that lets you access the actual arguments passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It happens that `arguments` is an *array-like* object, not really an array
    – the only array property it has is `length`. You cannot use methods such as `map()`,
    `forEach()`, and others on `arguments`. To convert `arguments` into a real array,
    you have to use `slice()`; you would also have to use `apply()` to call another
    function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In modern JavaScript, you don’t need to use arguments, slicing, or applying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should bear in mind the following points when looking at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: By writing `useArguments2(...args)`, we immediately and clearly express that
    our new function receives several (possibly zero) arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t need to do anything to get an array; `args` is a genuine array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing `somethingElse(...args)` is much clearer than using `apply()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the way, the `arguments` object is still available in the current version
    of JavaScript. If you want to create an array from it, you have two alternative
    ways of doing so without having to resort to the `Array.prototype.slice.call`
    trick:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `from()` method and write `myArray=Array.from(arguments)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write `myArray=[...arguments]`, which shows yet another type of usage of the
    spread operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we get to the topic of higher-order functions, writing functions that deal
    with other functions, with a possibly unknown number of parameters, will be commonplace.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript provides a much shorter way of doing this, so you’ll have to get
    accustomed to this usage. It’s worth it!
  prefs: []
  type: TYPE_NORMAL
- en: One argument or many?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s also possible to write functions that return functions, and in [*Chapter
    6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, we will see more
    of this. For instance, in lambda calculus, you don’t write functions with several
    parameters, but only one; you do this using a technique called **currying**. (But
    why would you do this? Hold that thought; we’ll come to this later.)
  prefs: []
  type: TYPE_NORMAL
- en: Twice recognized
  prefs: []
  type: TYPE_NORMAL
- en: Currying gets its name from Haskell Curry, who developed the concept. A functional
    language, *Haskell*, is also named after him – double recognition!
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the function that we saw previously that sums three numbers would
    be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Why did I change the function’s name? Simply put, this is *not* the same function
    we saw previously. The type of `sum3()` is `(x: number, y: number, z: number)
    => number`, while that of `altSum3()` is `(x: number) => (y: number) => (z: number)
    => number`, which is different. (See *Question 3.3* for more on this.) As-is,
    though, it can be used to produce the very same results as our earlier function.
    Let’s look at how you would use it, say, to sum the numbers 1, 2, and 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Test yourself before reading on, and think about this: what would have been
    returned if you had written `altSum3(1,2,3)` instead? Tip: it would not be a number!
    For the full answer, keep reading.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this work? Separating it into many calls can help; this would be the
    way the previous expression is calculated by the JavaScript interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Think functionally! The result of calling `altSum3(1)` is, according to the
    definition, a function, which, in virtue of a closure, resolves to be equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `altSum3()` function is meant to receive a single argument, not three!
    The result of this call, `fn1`, is also a single-argument function. When you use
    `fn1(2)`, the result is again a function, also with a single parameter, which
    is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And when you calculate `fn2(3)`, a value is finally returned – great! As we
    said, the function performs the same kind of calculations as we saw earlier, but
    in an intrinsically different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that currying is a peculiar trick: who would want to use only
    single-argument functions? You’ll see the reasons for this when we consider how
    to join functions together in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*, and [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, where it won’t be feasible to pass more than one
    parameter from one step to the next.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The concept of first-class objects means that functions can be created, assigned,
    changed, passed as parameters, and returned as a result of other functions in
    the same way you can with, say, numbers or strings. Let’s start with its definition.
    Let’s look at how you usually define a function – and do you recognize the function’s
    name? (Hint: google “Colossal Cave Adventure”!)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is (almost) equivalent to writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not true for hoisting, as we explained in the *Of lambdas and
    functions* section. JavaScript moves all definitions to the top of the current
    scope but does *not* move the assignments. With the first definition, you can
    invoke `xyzzy(...)` from any place in your code, but with the second, you cannot
    invoke the function until the assignment has been executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point that we want to make is that a function can be assigned to a variable
    and can also be reassigned if desired. In a similar vein, we can define functions
    on the spot where they are needed. We can even do this without naming them: as
    with common expressions, if they are used only once, you don’t need to name them
    or store them in a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: A colossal parallel
  prefs: []
  type: TYPE_NORMAL
- en: See the parallel with the *Colossal Cave Adventure* game from the 70s? Invoking
    `xyzzy()` anywhere won’t always work! If you have never played that famous interactive
    fiction game, try it online – for example, at [www.web-adventures.org/cgi-bin/webfrotz?s=Adventure](http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure)
    or [www.amc.com/blogs/play-the-colossal-cave-adventure-game-just-like-halt-and-catch-fires-cameron-howe--1009966](http://www.amc.com/blogs/play-the-colossal-cave-adventure-game-just-like-halt-and-catch-fires-cameron-howe--1009966).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an actual code example that involves assigning functions.
  prefs: []
  type: TYPE_NORMAL
- en: A React-Redux reducer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned in [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming
    Functional*, React-Redux works by dispatching actions that a *reducer* processes.
    (Read more about this at [redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers](http://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers).)
    Usually, the reducer includes code with a switch. An example follows – and I’m
    using JavaScript (not TypeScript) to focus on logic aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Initial state
  prefs: []
  type: TYPE_NORMAL
- en: Providing `initialState` as a default value for the state is a simple way of
    initializing the global state. Pay no attention to that `default`; it’s irrelevant
    to our example, and I included it just for completeness. I’m also assuming the
    existence of `State`, `Action`, and others as types – see *Question 3.5*!
  prefs: []
  type: TYPE_NORMAL
- en: 'By taking advantage of the possibility of storing functions, we can build a
    **dispatch** **table** and simplify the preceding code. First, we initialize an
    object with the code for the functions for each action type. We are just taking
    the preceding code and creating separate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We store the different functions that process each type of action as attributes
    in an object that will work as a dispatcher table. This object is created only
    once and is constant during the execution of the application. With it, we can
    now rewrite the action-processing code in a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze it: given the action, if `action.type` matches an attribute in
    the dispatching object, we execute the corresponding function taken from the object
    where it was stored. If there isn’t a match, we just return the current state
    as Redux requires. This kind of code wouldn’t be possible if we couldn’t handle
    functions (storing and recalling them) as first-class objects.'
  prefs: []
  type: TYPE_NORMAL
- en: An unnecessary mistake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is, however, a common (though, in fact, harmless) mistake that is usually
    made. You often see code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What does this code do? The idea is that a remote URL is fetched, and when the
    data arrives, a function is called – and this function calls `processResult` with
    `data` as an argument. That is to say, in the `then()` part, we want a function
    that, given data, calculates `processResult(data)`. But don’t we already have
    such a function?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a rule that you can apply whenever you see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule states that you can replace code resembling the preceding code with
    just `someOtherFunction`. So, in our example, we can directly write what follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code is equivalent to the previous method that we looked at (although it
    is infinitesimally quicker since you avoid one function call), but is it simpler
    to understand?
  prefs: []
  type: TYPE_NORMAL
- en: Some terminology
  prefs: []
  type: TYPE_NORMAL
- en: In lambda calculus terms, we are replacing λ*x*.*func* *x* with simply *func*
    – this is called an **η (eta) conversion**, or more specifically, an **η** **reduction**.
    (If you were to do it the other way round, it would be an **η** **abstraction**.)
    In our case, it could be considered a (very, very small!) optimization, but its
    main advantage is shorter, more compact code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This programming style is called **pointfree** (also **point-free**) or **tacit**
    style, and its defining characteristic is that you never specify the arguments
    for each function application. An advantage of this way of coding is that it helps
    the writer (and the future readers of the code) think about the functions and
    their meanings instead of working at a low level, passing data around, and working
    with it. In the shorter version of the code, there are no extraneous or irrelevant
    details: if you know what the called function does, you understand the meaning
    of the complete piece of code. We’ll often (but not necessarily always) work this
    way in our text.'
  prefs: []
  type: TYPE_NORMAL
- en: Old Unix style
  prefs: []
  type: TYPE_NORMAL
- en: Unix/Linux users are already accustomed to this style because they work in a
    similar way when they use pipes to pass the result of a command as input to another.
    When you write something as `ls|grep doc|sort`, the output of `ls` is the input
    to `grep`, and the latter’s output is the input to `sort` – but input arguments
    aren’t written out anywhere; they are implied. We’ll come back to this in the
    *Pointfree style* section of [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148)*,*
    *Connecting Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'However, there is a case that you should be aware of: what happens if you call
    an object’s method? Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If your original code had been something along the lines of the preceding code,
    then the seemingly obvious transformed code would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Why? The reason is that in the original code, the called method is bound to
    an object (`myObject`), but in the modified code, it isn’t bound and is just a
    free function. We can fix it by using `bind()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a general solution. When dealing with a method, you cannot just assign
    it; you must use `bind()` so that the correct context will be available. Look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this rule, such code should be converted into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Read more on `bind()` at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind).
  prefs: []
  type: TYPE_NORMAL
- en: This looks rather awkward and not too elegant, but it’s required so that the
    method will be associated with the correct object. We will see one application
    of this when we *promisify* functions in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*. Even if this code isn’t so nice to look at, whenever you
    have to work with objects (and remember, we didn’t say that we would be trying
    to aim for fully FP code, and did say that we would accept other constructs if
    they made things easier), you’ll have to remember to bind methods before passing
    them as first-class objects in pointfree style.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been discussing many aspects of functions; now, let’s get more
    into functions in FP, and see how we’ll use them.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions in FP ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several common coding patterns take advantage of the FP style, even if you aren’t
    aware of it. In this section, we will go through them and look at the functional
    aspects of the code so that you can get more accustomed to this coding style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we’ll look in detail at using functions in an FP way by considering several
    FP techniques, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Injection**, which is needed for sorting different strategies, as well as
    other uses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callbacks** and **promises**, introducing the **continuation-passing** style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polyfilling** and **stubbing**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immediate** **invocation** schemes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injection – sorting it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Array.prototype.sort()` method provides the first example of passing functions
    as parameters. If you have an array of strings and you want to sort it, you can
    just use the `sort()` method. For example, to alphabetically sort an array with
    the colors of the rainbow, we would write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we didn’t have to provide any parameters to the `sort()` call, but
    the array got sorted perfectly well. By default, this method sorts strings according
    to their ASCII internal representation. So, if you use this method to sort an
    array of numbers, it will fail because it will decide that 20 must be between
    100 and 3, as 100 precedes 20 (taken as strings!) and the latter precedes 3, so
    this needs fixing! The following code shows the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But let’s forget numbers for a while and stick to sorting strings. What would
    happen if we wanted to sort some Spanish words (*palabras*) while following the
    appropriate locale rules? We would be sorting strings, but the results wouldn’t
    be correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: What’s in a word?
  prefs: []
  type: TYPE_NORMAL
- en: For language or biology buffs, *ñandú* in English is *rhea*, a running bird
    similar to an ostrich. There aren’t many Spanish words beginning with *ñ*, and
    we happen to have these birds in my country, Uruguay, so that’s the reason for
    the odd word!
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops! In Spanish, *ñ* comes between *n* and *o*, but `"ñandú"` got sorted at
    the end. Also, `"mítico"` (in English, mythical; note the accented *í*) should
    appear between `"mano"` and `"musical"` because the tilde should be ignored. The
    appropriate way of solving this is by providing a comparison function to `sort()`.
    In this case, we can use the `localeCompare()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `a.localeCompare(b,"es")` call compares the `a` and `b` strings and returns
    a negative value should `a` precede `b`, a positive value should `a` follow `b`,
    and 0 if `a` and `b` are the same – but according to Spanish (`"es"`) ordering
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, things are right! And the code could be made clearer by introducing a
    new function, `spanishComparison()`, to perform the required strings comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: International sorting
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on the `localeCompare()` possibilities, see [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
    You can specify which locale rules to apply, in which order to place upper/lowercase
    letters, whether to ignore punctuation, and much more. But be careful: not all
    browsers may support the required extra parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: In upcoming chapters, we will discuss how FP lets you write code in a more declarative
    fashion, producing more understandable code, and how this sort of minor change
    helps. When readers of the code get to the `sort` function, they will immediately
    deduce what is being done, even if the comment wasn’t present.
  prefs: []
  type: TYPE_NORMAL
- en: Of strategies and patterns
  prefs: []
  type: TYPE_NORMAL
- en: This way of changing how the `sort()` function works by injecting different
    comparison functions is a case of the strategy **design pattern**. We’ll learn
    more about this in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing*
    *Design Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Providing a `sort` function as a parameter (in a very FP way!) can also help
    with several other problems, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sort()` only works with strings by default. If you want to sort numbers (as
    we tried to do previously), you have to provide a function that will compare numerically.
    For example, you would write something like `myNumbers.sort((a:number, b:number)
    => a – b)`. (Why? See *Question 3.7*.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to sort objects by a given attribute, you will use a function that
    compares to it. For example, you could sort people by age with something like
    `myPeople.sort((a:Person, b:Person) => a.age -` `b.age)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a simple example you have probably used before, but it’s an FP pattern,
    after all. Let’s move on to even more common usage of functions as parameters
    when you perform Ajax calls.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks and promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably the most used example of functions passed as first-class objects has
    to do with callbacks and promises. In Node.js, reading a file is accomplished
    asynchronously with something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `readFile()` function requires a callback – in this example, an anonymous
    function – that will get called when the file-reading operation is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better, more modern way is using promises; read more at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
    With this, when performing an Ajax web service call using the `fetch()` function,
    you could write something along the lines of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you should also look into using `async`/`await`; read more about them
    at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Continuation-passing style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding code, in which you call a function but also pass another function
    to be executed when the input/output operation is finished, can be considered
    something called **continuation-passing style** (**CPS**). What is this technique
    of coding? One way of looking at it is by thinking about the question: *how would
    you program if using the return statement* *was forbidden?*'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this may appear to be an impossible situation. However, we
    can get out of our fix by passing a callback to the called function so that when
    that procedure is ready to return to the caller, instead of returning, it invokes
    the given callback. By doing this, the callback provides the called function with
    the way to continue the process, hence the word *continuation*. We won’t get into
    this now, but in [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*,
    we will study it in depth. In particular, CPS will help us to avoid an important
    recursion restriction, as we’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: Working out how to use continuations is sometimes challenging, but always possible.
    An exciting advantage of this way of coding is that by specifying how the process
    will continue, you can go beyond all the usual structures (`if`, `while`, `return`,
    and so on) and implement whatever mechanisms you want. This can be very useful
    in problems where the process isn’t necessarily linear. Of course, this can also
    lead to you inventing a kind of control structure far worse than the possible
    usage of GOTO statements that you might imagine! *Figure 3**.1* shows the dangers
    of that practice!
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.1 – What’s the \uFEFFworst that could happen if you start messing\
    \ with the program ﬂow? (This XKCD comic is available online at xkcd.com/292/)](img/Figure_3.1_B19301.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – What’s the worst that could happen if you start messing with the
    program ﬂow? (This XKCD comic is available online at [xkcd.com/292/](http://xkcd.com/292/))
  prefs: []
  type: TYPE_NORMAL
- en: 'You are not limited to passing a single continuation. As with promises, you
    can provide two or more alternative callbacks. And this, by the way, can provide
    a solution to the problem of how you would work with exceptions. If we simply
    allowed a function to throw an error, it would be an implied return to the caller,
    and we don’t want this. The way out of this is to provide an alternative callback
    (that is, a different continuation) to be used whenever an exception is thrown
    (in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*,
    we’ll find another solution using monads):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using CPS can even allow you to go beyond the control structures that JavaScript
    provides, but that would be beyond the objectives of this book, so I’ll let you
    research that on your own!
  prefs: []
  type: TYPE_NORMAL
- en: Polyfills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to assign functions dynamically (in the same way that you can assign
    different values to a variable) also allows you to work more efficiently when
    defining polyfills.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Ajax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s go back a bit in time to when Ajax started to appear. Given that different
    browsers implemented Ajax calls in distinct fashions, you would always have to
    code around these differences. The following code shows how you would go about
    implementing an Ajax call by testing several different conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This worked but implied that you would redo the Ajax check for every call,
    even though the test results wouldn’t ever change. There’s a more efficient way
    to do this, and it has to do with using functions as first-class objects. We could
    define *two* different functions, test for the condition only once, and then assign
    the correct function to be used later; study the following code for such an alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code shows two important concepts. First, we can dynamically
    assign a function: when this code runs, `window.getAjax` (the global `getAjax`
    variable) will get one of three possible values according to the current browser.
    When you later call `getAjax()` in your code, the correct function will execute
    without you needing to do any further browser-detection tests.'
  prefs: []
  type: TYPE_NORMAL
- en: The second interesting idea is that we define the `initializeGetAjax()` function
    and immediately run it – this pattern is called the **immediately invoked function
    expression** (**IIFE**), and we already saw it in the *Solution 7 – using a local
    flag* section in [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037)*, Thinking Functionally*.
    The function runs but cleans up after itself because all its variables are local
    and won’t even exist after the function runs. We’ll learn more about this later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, you would use a module instead of an IIFE, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The code in the module is guaranteed to run only once. Wherever you need to
    do an Ajax call, you would just `import { getAjax } from "/path/to/ajax.module"`
    and you could use `getAjax()` at will.
  prefs: []
  type: TYPE_NORMAL
- en: Adding missing functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This idea of defining a function on the run also allows us to write polyfills
    that provide otherwise missing functions. For example, let’s say that we had some
    code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of this, you might very much prefer using the newer `includes()` method
    and just write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if your browser doesn’t provide `includes()`? Once again, we can
    define the appropriate function on the fly, but only if needed. If `includes()`
    is available, you don’t need to do anything, but if it is missing, you need to
    define a polyfill that will provide the same workings. (You can find links to
    polyfills on Mozilla’s developer site.) The following code shows an example of
    such a polyfill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code runs, it checks whether the `String` prototype already has the
    `includes()` method. If not, it assigns a function to it that does the same job,
    so from that point onward, you’ll be able to use `includes()` without further
    worries. By the way, there are other ways of defining a polyfill: check the answer
    to *Question 3.7* for an alternative. Yet another solution is the `core-js` package
    ([github.com/zloirock/core-js](http://github.com/zloirock/core-js)), which provides
    polyfills for ECMAScript up to the latest version, and even some proposals that
    haven’t made it into the language yet.'
  prefs: []
  type: TYPE_NORMAL
- en: Good or bad?
  prefs: []
  type: TYPE_NORMAL
- en: Directly modifying a standard type’s prototype object is usually frowned upon
    because, in essence, it’s equivalent to using a global variable, and thus it’s
    prone to errors; however, in this case (writing a polyfill for a well-established,
    known function) is quite unlikely to provoke any conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you happened to think that the Ajax example shown previously was
    old hat, consider this: if you want to use the more modern `fetch()` way of calling
    services, you will also find that not all modern browsers support it (check [caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)
    to verify this), so you’d have to use a polyfill, such as the one at [github.com/github/fetch](http://github.com/github/fetch).
    Study the code, and you’ll see that it uses the same method described previously
    to see whether a polyfill is needed and create it.'
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will look at a use case similar to using a polyfill: having a function
    do different work depending on the environment. The idea is to perform stubbing,
    an idea that comes from testing and involves replacing a function with another
    that does a simpler job instead of the actual work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stubbing is commonly used with logging functions. You may want the application
    to perform detailed logging when in development but not to say a peep when in
    production. A common solution would be to write something along the lines of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This works, but as in the example of Ajax detection, it does more work than
    it needs to because it checks whether the application is in development every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could simplify the code (and get a really, really tiny performance gain!)
    if we stub out the logging function so that it won’t log anything; an easy implementation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do even better with the ternary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit more cryptic, but I prefer it because it uses `const`, which cannot
    be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s yet another possibility: you could modify the original method like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are directly changing how `console.log()` works, so it won’t
    log anything.
  prefs: []
  type: TYPE_NORMAL
- en: Useless arguments – ignore or exclude?
  prefs: []
  type: TYPE_NORMAL
- en: Given that JavaScript allows us to call functions with more arguments than parameters,
    and given that we aren’t doing anything in `myLog()` when we are not in development,
    we could also have written `() => {}` and it would have worked fine. However,
    I do prefer keeping the same signature, and that’s why I specified the `someText`
    argument, even if it wouldn’t be used. But, if you use ESLint’s `no-unused-vars`
    rule to detect unused variables, you may have to tweak its configuration to allow
    unused arguments.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that we are using the concept of functions as first-class objects
    over and over again; look through all the code samples and you’ll see!
  prefs: []
  type: TYPE_NORMAL
- en: Immediate invocation (IIFE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s yet another common usage of functions, usually seen in popular libraries
    and frameworks, that lets you bring some modularity advantages from other languages
    into JavaScript (even the older versions!). The usual way of writing this is something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you may find `(function(){ ... }())` – note the different placement
    of the parentheses for the function call. Both styles have their fans; pick whichever
    suits you, and follow it consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass some arguments to the function that will be used as the initial
    values for its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you could also return something from the function – usually, an object
    (with several methods) or a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note the parentheses around the function. These help the parser understand that
    we are writing an expression. If you were to omit the first set of parentheses,
    JavaScript would think you were writing a function declaration instead of an invocation.
    The parentheses also serve as a visual note, so readers of your code will immediately
    recognize the IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously mentioned, the pattern is called IIFE (pronounced *iffy*). The
    name is easy to understand: you define a function and call it right away so that
    it gets executed on the spot. Why would you do this, instead of simply writing
    the code inline? The reason has to do with scopes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define any variables or functions within IIFE, then because of how JavaScript
    defines the scope of functions, those definitions will be internal, and no other
    part of your code will be able to access them. Imagine that you wanted to write
    some complicated initialization, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'What could go wrong? The problem hinges on the fact that you could (by accident)
    have a function with the same name as any of the three here, and hoisting would
    imply that the last function would be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! If you had used IIFE, the problem wouldn’t have happened. (Using ESLint’s
    `no-func-assign` rule would have prevented this, too.) Also, the three inner functions
    wouldn’t even be visible to the rest of the code, which helps to keep the global
    namespace less polluted. The following code shows a widespread pattern for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To see an example involving returned values, we could revisit the example from
    [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, and write
    the following, which would create a single counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Then, every call to `myCounter()` would return an incremented count, but there
    is no chance that any other part of your code will overwrite the inner `count`
    variable because it’s only accessible within the returned function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over several ways of defining functions in JavaScript,
    focusing mainly on arrow functions, which have several advantages over standard
    functions, including being terser. We learned about the concept of currying (which
    we’ll be revisiting later), considered some aspects of functions as first-class
    objects, and reviewed several techniques that happen to be fully FP in concept.
    Rest assured that we’ll be using everything in this chapter as the building blocks
    for more advanced techniques in the rest of this book; just wait and see!
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, we
    will delve even more deeply into functions and learn about the concept of pure
    functions, leading us to an even better programming style.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3.1 `type` attribute, used to determine what kind of action you are creating.
    The following code supposedly produces an action, but can you explain the unexpected
    results?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 3.2 `useArguments()` and `useArguments2()` from the *Working with arguments*
    section by using arrow functions instead of the way we did, with the `function`
    keyword?
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 `sum3()` and `altsum3()`, but we didn’t do that for `fn1`, `fn2`, and `fn3`.
    What are the types of those functions?
  prefs: []
  type: TYPE_NORMAL
- en: '3.4 `doAction2()` as a one-liner, even though you can’t tell this from the
    formatting! What do you think: is it correct or isn’t it?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 3.5 `doAction()`, `dispatchTable`, and `doAction2()`? Be sure to describe all
    needed types, too.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 `set()` method. After creating the new store object, he wrote the following
    so that the arguments to `store.set()` would be logged before being processed.
    Unfortunately, the code didn’t work as expected. What’s the problem? Can you spot
    the mistake?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 3.7 `bind()` was not available; how could you do a polyfill for it?
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 `myNumbers.sort((a:number, b:number) => a-b)` – why/how does this work?
  prefs: []
  type: TYPE_NORMAL
- en: '3.9 **Negative sort**: Earlier, in the *Injection – sorting it out* section,
    we saw that sorting numbers as strings produces unexpected results. What would
    the result be if the array included both negative and positive numbers?'
  prefs: []
  type: TYPE_NORMAL
- en: '3.10 **Lexicographic sorting**: When sorting, say, book titles or personal
    names, special collation rules are applied. For instance, “THE SHINING” would
    be sorted as “SHINING, THE,” and “Stephen King” would be sorted as “King, Stephen.”
    How could you (efficiently) implement such sorting?'
  prefs: []
  type: TYPE_NORMAL
- en: 3.11 `console.log()` method doesn’t have the correct data type – for instance,
    our version just allows a single argument. Can you provide the right data type
    definition?
  prefs: []
  type: TYPE_NORMAL
