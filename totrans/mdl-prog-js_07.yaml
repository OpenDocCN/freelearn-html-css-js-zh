- en: Chapter 7. Base, Sandbox, and Core Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have mostly looked at different techniques for creating
    and enhancing modules. However, our focus has been on the smaller pieces of the
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a holistic view of our application as
    a complete functioning body. We will see how its various pieces can be put together
    to create a robust and flexible ecosystem to deliver our ultimate goal, which
    is a working **Single-Page Application** (**SPA**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: As you read through different sections of this chapter, keep in mind that all
    the pieces of the application are designed to work together in concert, while
    still adhering to the principles of maintainability and extensibility of a modular
    design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Base module and its design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandbox and the principles behind sandboxing of our components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core and its related modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components and how they are added to the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plug-and-play, progressive enhancement, and graceful degradation in our application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we will not get too deep into the coding aspect of things here, since
    I would really like you to focus on the architecture of the application, as opposed
    to being distracted with the details of the implementation. As such, there is
    no project code associated with this chapter of the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: I should also mention that the architectural design concepts discussed in this
    chapter, and the next, are based on the design principles that I was originally
    introduced to by *Nicholas C. Zakas*, after watching one of his talks on the subject.
    He is one of my favorite authors and speakers. While our implementation will slightly
    deviate from his, the essence of our architecture will remain similar to his proposed
    architectural design.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Application architecture overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a truly modular design for our application, we need to break it down
    into smaller functional pieces, in such a way that each piece will specialize
    in and be responsible for very specific tasks. This enables us to achieve the
    principle of separation of concerns and responsibilities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides a depiction of our overall application design:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Application architecture overview](img/B04910_07_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, our application consists of four main pieces:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Base
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandbox
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, each main piece may consist of other smaller pieces which
    are packaged together to create the main piece.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by exploring each main piece of the application and looking at the
    specific functionality that each piece provides.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes in this book, from this point forward, when I talk about **components**,
    I'll be referring to modules that have user interface pieces (views) which the
    user is able to interact with, such as the header component. However, when I refer
    to **modules** I will be referring to functional modules that each main piece
    may consist of, which do not have any views associated with them directly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The definitions will become more clear as we move along but you may decide to
    refer to such pieces differently in your own projects. This is fine, as long as
    the architectural concepts behind them remain the same.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Also, from time to time, I will be referring to our modular design architecture
    as a **framework,** which should be interpreted as all the various pieces of the
    application together as a whole.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**About the term framework**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: While I will be using the term framework at times, our application is not meant
    to create what is generally known as a framework. At least not in the same capacity
    that the term is used to refer to frameworks in the likes of **AngularJS** or
    **React**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, I think sometimes third-party frameworks are overused and
    while they all provide some pros, there are also cons associated with using any
    type of third party framework.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this book is to show you how you can create your own architectural
    design which allows you to easily create, organize, and maintain your application's
    code base without the need for a third party framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: As such, I would like you to look at our implementation as an architectural
    design concept as opposed to a framework. But if you insist, you can call what
    we design and create here an **ironic framework**. I say ironic, because it is
    really not a framework in the traditional sense, as it does not impose a special
    syntax or a slew of rules and regulations!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The best way to describe our implementation is perhaps by using the term **Client-side
    Modular Design** (**CMD**), since the goal of this architectural approach is to
    create a solid foundation and a flexible ecosystem for our applications, as opposed
    to it being a framework.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Base module
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start our exploration of the design with the base module. As the name
    implies, the base module provides the lowest level of functionality for our application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: This is where we import and leverage the functionality of third party libraries
    and utilities. These libraries can consist of jQuery, Dojo, MooTools, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The main idea is that we can easily use the functionality provided by such libraries
    without the need to create a tight dependency between our application and the
    libraries used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider how we need to detect browser compatibility to attach
    events to our elements on the page, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Whereras we could easily let jQuery take care of such intricacies by doing
    the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are letting jQuery take care of the browser compatibility issues and
    we can focus on other, more important things in our application. Another example
    is adding animations to our elements only when jQuery is present. This approach
    allows us to implement **progressive enhancement** and **graceful degradation**
    techniques in our code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: We can also have both of such implementations in our code. This allows us to
    have a fallback if jQuery has not been loaded properly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the preceding code can be written as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most of the time, it is best to leave low-level functionality such as browser
    compatibility issues to third party libraries and focus on providing customized
    functionality for our application in our own code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we are talking about third party libraries and utility packages
    here and not third party frameworks, as one of the goals of our architecture is
    to eliminate, or at least minimize, the need for third party frameworks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Adding general-purpose libraries to the base module
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, our base module loads and provides general-purpose libraries to
    the core module of our application. This means that only the core is aware of
    what base libraries are used in the code, as well as which particular functionality
    of such libraries is being leveraged.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the design of our base module, the libraries are either loaded
    at application start-up time or dynamically at a later time. The base module passes
    a reference for each loaded and initialized library to the core module.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Since it is only the core module that is aware of what libraries are used in
    the application and to what extend, if we ever decide to change our third party
    libraries or how they are used in the application, it is only the core module
    that is affected and no other pieces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: This means that all the other pieces and components of our application will
    continue to work as they did before, regardless of the change in the third party
    libraries. Implementing our application as such minimizes the impact of replacing
    or removing the third party libraries on the application as a whole.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: This also holds true when we import and use new libraries in order to add more
    functionality to our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a closer look at how the base module is used
    to add jQuery to our application's core module.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a depiction of how third party libraries are provided to the
    core module by our application''s base module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding general-purpose libraries to the base module](img/B04910_07_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Sandbox module
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about a sandbox in our daily lives, we usually have a picture of
    a box full of sand in our minds, where we allow the kids to play and make all
    the mess they like - and hopefully only in that box.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In our modular architecture, we capitalize on the same concept and create spaces
    for our components to play in and to be isolated from other pieces of the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: By sandboxing our modules in such a way, we eliminate tight coupling among our
    application components and the core module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The sandbox is essentially a layer of abstraction as well as a thin interface
    between our components and the other pieces of our application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: As the sandbox module is designed to be an interface and to provide communication
    among our components and the rest of the application, it is considered a contract
    and, as such, it should never change. This is so our components can be sure that
    they can always count on a consistent layer of communication with the application
    as well as a certain level of functionality provided by the core module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: That is not to say, we cannot add new methods or functionality to the sandbox;
    it is only that we cannot change what is already there and that our components
    have come to rely on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox module functionality
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our components are loaded in the application, either at application start-up
    time or dynamically any time after, they are all given an instance of the sandbox
    module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The sandbox module provides the following for our components:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: A consistent interface
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of the services provided by the sandbox module is crucial to the modular
    aspect of our implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore each aspect in more detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox as a consistent interface
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, when every registered component is given an instance of the sandbox
    module by the core module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: This instance of the sandbox then acts as an interface to the rest of the application,
    which provides application-level functionality for the component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: When a component needs a particular functionality, it does not necessarily need
    to implement it itself. This is true when the implementation of that functionality
    is already available in the application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to bind event handlers to elements, each component does not need
    to provide its own implementation. Components can simply ask the sandbox module,
    which in turn, asks the core module to bind a certain event handler to a particular
    element on the page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the components also do not have to worry about browser compatibility
    issues related to event binding, as it is the job of the core module to take care
    of such issues.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Since the sandbox instance is identical for every registered component, we can
    be sure that any changes in the sandbox code is provided to all the components
    at the same time. This means that the addition of new functionality, bug fixes,
    and modifications in the sandbox module are done once and then propagated to all
    the components that use the sandbox module, in a uniform and cohesive manner.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Note that any changes to the sandbox module should still honor the previous
    contract between this module and the application's components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox as a security layer
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The components in our application only know about the sandbox module and are
    not allowed (or able) to directly communicate with any other pieces of the application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: This means that the sandbox makes sure that protected areas of the framework
    are not accessible by the components through its interface. This enables us to
    control the type of operations that the components are permitted to perform, within
    the context of the core and other modules of the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox as a communication layer
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the sandbox module is a thin layer of interface which provides the exposed
    interface of the core module to the components, it is the only route of communication
    between the components and the rest of the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: It is also through the sandbox module that components can subscribe to and publish
    custom events in the application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is important for the components to only have one route of communication
    with the rest of the application so we can preserve the integrity of our modular
    design. If a component is able to directly communicate with another component
    or other parts of the application, then it could be tightly coupled to such pieces,
    and we certainly would like to avoid this type of tight coupling.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox as a filter
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The design of the sandbox should be done in a way that not only will it provide
    the functionality of the core module that we want to expose to the components,
    but it can also do simple error checking for the calls made by the components
    to the core.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding method has been provided to our components through the sandbox
    module. This method does a simple parameter check to make sure that the parameter,
    as well as the correct type of the parameter, has been passed to it by the component
    before the sandbox module asks the core to do the work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: While the core module might have its own error checking, it is always a good
    idea to do some error checking at the sandbox level before getting the core module
    involved.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multiple instances of the sandbox module
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering at this point, why is it a better idea to use multiple
    instances of the sandbox module (one for each component) as opposed to having
    all the components use the same sandbox object as a singleton?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer is: better isolation and performance. We need to explore that
    answer a little further in the upcoming sections.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of multiple instances of the sandbox
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, a module provides its exposed functionality to the outside world through
    a single common interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: However, our implementation of the sandbox module is different. As mentioned
    previously, we create multiple instances of the sandbox module and, to be more
    precise, one instance per component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The following summarizes the goals behind this design:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Isolating sandbox instances from each other
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a code execution context for each component
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance improvements
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolating the sandbox instances from each other
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In our analogy of a kid playing in a sandbox, I mentioned that this type of
    isolation contains the possible mess created in the box. In just the same way,
    we would like any possible damage to a sandbox module instance to be contained
    and isolated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: This would mean that, if one of our components does something undesirable which
    could cause issues in its sandbox instance, such a mess would be contained within
    that sandbox module instance. The adverse effects will only impact the functionality
    of that component but no other sandbox instances, or any other components for
    that matter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: It is very important for us to design our architecture in such a way which minimizes
    the chances of complete application failure caused by an issue in one of the components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: This allows for at least partial functionality of our application, which is
    probably a much more acceptable outcome than a complete application failure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the footer component in our application may stop working but the
    user can still view the catalog of our images and add them to the favorites list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Creating a code execution context
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a sandbox module is created, it sets a context object for its component.
    Components can use this context object to easily refer to the correct execution
    context when needed. This is probably better understood if we look at an example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet from our application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function above is implemented in the content component of our application.
    Inside this function, which is the click event handler for some of the elements
    on the page, we need to call other related functions in the content component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: We can easily do that by using the execution context that we set on the sandbox
    instance for this component when we first initialize the component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the code snippet, `this` refers to the content component of our application.
    Thus, when we need to execute any functions in the context of our content component,
    we can just refer to the correct context, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this does not make a lot of sense to you right now, do not be alarmed. I
    will explain this further in the next chapter where we'll have a chance to look
    at it's full implementation in the code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: For now, the only thing that you need to keep in mind is that we can use each
    instance of the sandbox module to preserve a reference to the component that the
    sandbox instance belongs to. This allows us to easily access the execution context
    of that component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we create an instance of the sandbox for each component, we also assign
    a reference on the sandbox instance to the DOM element in which the component's
    view resides. This allows us to make our DOM manipulation within that container
    a lot more efficiently, since we do not need to traverse the whole DOM tree to
    find the DOM element of interest within the container of the component's view.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this snippet, we are trying to find a child element of the container element
    where the component's view has been rendered.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: When the component was registered with the core, the core created an instance
    of the sandbox and returned a reference to the component's container element with
    the sandbox instance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: For instance, after the header component of our application is created, all
    the header-related DOM elements reside inside a main div element container that
    hosts them. The header component's sandbox instance holds a reference to this
    div container.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: When the header component needs access to any DOM elements related to its view,
    it will only need to look for the desired element inside of its container div
    element as opposed to traversing the whole DOM tree to find the element.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: This makes finding the desired element much quicker as we don't need to search
    the entire DOM looking for it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: If you are not completely clear on how this works, we will cover it again in
    the next chapter when we examine the code in more depth.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: For now, just be mindful of the fact that the sandbox instance allows us to
    have quick and direct access to the DOM element that the component renders in,
    which in turn allows for much more optimized DOM manipulation tasks related to
    the component.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Core module
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core module is really the brain of our application. It is where the application's
    heavy lifting is done and the real magic happens.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The core module is responsible for implementing application-level business logic
    as well as providing bridges among components when there is a need for components
    to communicate with each other. Of course, while still preserving the loose coupling
    nature of the application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The core module also leverages the functionality provided by the third party
    libraries, which are loaded by the base module, to create a cohesive functional
    application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with the architectural design pattern known as **Module-View-Controller**
    (**MVC**), the core module is the controller piece of this design pattern in our
    application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the role of core module as the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Acting as the controller for the application
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing communication bridges among modularized components
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing and destroying components
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing plug-and-play capability for the components
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a centralized method of handling errors
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing application-level extensibility
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging third party libraries' functionality
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will examine all these aspects very shortly but before doing so, let's talk
    about how the core is constructed in our application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Core module construction approach
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different approaches to building the core module, but one of the best
    approaches is to build it in a modularized fashion.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: We can start the implementation by building a main core module and then augment
    it using techniques such as loose and tight augmentation, which we have already
    covered in this book. However, adding most of the functionality to the core module
    using sub-modules allows for a better separation of the logic in the code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of our main application for this book, we will be using
    all the above techniques to build our core module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will examine the implementation of the core in depth, but for
    now, we'll look at a couple of things related to its implementation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we are using tight augmentation to add DOM-related functionality
    to the core module. We can also add functionality to the core by attaching a sub-module
    to it, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we are augmenting the core module by attaching a self-contained
    sub-module, which is added as a new property to the core module object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting the core module using sub-modules, is similar to building a play
    house using Lego blocks as separate pieces are attached together to create the
    whole structure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: This would mean that not only the application main pieces (such as components
    and sandbox) are built as modules, but also the core module itself is built based
    on smaller modules.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to easily extend our core module while providing us with the
    ability to remove or replace each sub-module without affecting the other pieces
    of the core module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We will examine this modular implementation of the core module quite a bit
    further, when we''ll have a look under the hood in the next chapter. Have a look
    at the following image to see all the pieces of the core module in our final application.
    This image depicts how the core module consists of separate self-contained sub-modules:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Core module construction approach](img/B04910_07_03.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Of course, at the time of deployment, we can combine and minify all of these
    files (sub-modules) into one file but during development, this separation of sub-modules
    provides a good visual representation of all the pieces of the core module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have had a good overview of how the core module is built, let's
    examine the functionality that this module provides for us.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Core module functionality
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Core module plays different vital roles in our application, and provides essential
    services for all the other modules. It is important to note that while the core
    module consists of many pieces itself, it acts as a uniform and cohesive piece
    while providing the following functionality for the application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Acting as the controller
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core module provides application-level functionality for all the components
    in the application. For instance, event binding and unbinding happen in the core
    module and the components only need to ask the core to take care of this task
    for them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is implemented in the core module and all the components in the application
    call this method (through their instance of the sandbox module) to bind an event
    handler to an element.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Another example can be when a component would need to make an **AJAX** call
    to the server. It is the core module that would make the call instead to the server
    and would return the result to the component and/or would take an action based
    on the result returned, such as logging an error when the AJAX call fails.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We can also mention **cookie** and **local storage**-related functionality in
    the application as some of the other application-level functionality the core
    provides to all the registered components.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the implementation should be designed in a way that component-specific
    functionality that only the component cares about should happen at the component
    level and that the application-level functionality should take place at the core
    module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Each component, in a sense, implements its own MVC or MV* design at the component
    level, which is separate from the application-level implementation. This point
    will become more clear to you when we look at implementation code in the next
    chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Providing communication bridges
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may recall, one of the main goals of our modular architecture was to
    provide loose coupling among our components. This means that none of the components
    in our application knows about any other component, nor are they dependent on
    any other component.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: However, there are times when components need to communicate with each other,
    or an event or action in one component should cause a change in another component,
    while the components have no knowledge of each other.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: To provide such functionality the core implements a variation to the observer
    pattern called the **mediator pattern**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Using the mediator pattern, our application's components can register for and
    publish events. However, this is done through an abstraction layer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a depiction of how the mediator pattern is implemented:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing communication bridges](img/B04910_07_08.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: The core module in our application acts as the mediator, which enables the components
    (modules) for subscribe to and publish events without knowing about each other,
    thus still adhering to the principle of loose coupling among our components and
    modules.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the footer component in our application is publishing a custom event,
    `support-Clicked,` through its instance of the sandbox module. Beyond that, it
    has no idea what other pieces of the application could be listening for this event
    and what actions they would take based on this event.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the following snippet shows that our `NotificationHandler`
    module is listening to this event and will take action when this event is published,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The core module is responsible for notifying all the registered components and
    modules that a certain event has taken place if they have registered for that
    particular event.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and destroying components
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our architectural design, we can load and unload components (modules) both
    at the start-up phase of the application as well as any time after.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty robust, since it allows us to load what we need when we need
    it, which helps to keep the consumption of the resources on the device to a minimum,
    as well as keeping the application very light and responsive. This could be particularly
    important for mobile devices.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: When a component is loaded (either at application start-up or any other time),
    it first registers itself with the core module and then the core module calls
    the `init` method of the component when it needs to be initialized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet and see how this is done:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see in the preceding code, each component upon loading calls the
    `registerComponent` method of the core module. Note that the core module is known
    as `ImagesInc_Core` to other application pieces.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The component sends the ID of its container (`footerContainer` for instance)
    as well as its own ID (shown as `footer` in the preceding code) as parameters
    to the `registerComponent` method of the core module.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: It also sends a reference to the function that the core module needs to call
    to create an instance of the component. This function is then called by the core
    module with an instance of the sandbox module, which is an interface for the component
    to use for interacting with the application from this point forward.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how registration of the component is done in the core module:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the core module first checks to see if the component has the
    required methods, `init` and `destroy`, and if so, the creator function (`createFunc`)
    on the component is called to create an instance of the component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this phase as the hand-shake phase between the component and
    the core module specifically, as well as the hand-shake of the component with
    the application as a whole.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the component is also required to have a destroy method, which
    allows the core module to either disable the component for event handling and/or
    to completely remove the component from the application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start-up phase of application, the core module goes through all the
    registered components and calls the `init` method on all of them, as shown:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We use a similar approach to destroy (remove) all the registered components
    from the application, as shown:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will look at the details of these operations in the next chapter and will
    examine the code more closely then. The takeaway here is that the core module
    handles the initialization and destruction of all the components in the application,
    either as a collection or on individual basis.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Providing plug-and-play capability
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, components can be loaded and added to the application
    at any time while the application is loaded in the browser.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how a component is loaded dynamically and how it becomes
    part of the application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic loading of the components is done by leveraging a mechanism which first
    checks to see if the component is already loaded in the cache, and if not, finding
    its object definition in either the local storage or in the `PageDefinitions.js`
    file and then subsequently loading it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The `PageDefinitions.js` is the file that holds object definitions (as JavaScript
    objects) for all the components that can be loaded dynamically in the application,
    at any time other than the start-up phase.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We can also keep resource (asset) information related to any component in this
    file if we desire to do so. Generally speaking, this file is mostly used to find
    the location of our dynamic assets.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in our application, we will be keeping information related to
    the `Favorites` page and the location of its `CSS` file in `PageDefinitions.js`.
    This information will be consumed by the content component when the user navigates
    to this page.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram to see an overview of the dynamic component-loading
    mechanism in our application:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing plug-and-play capability](img/B04910_07_04.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: As the flow diagram shows, when there is a need for a component to be rendered
    dynamically in the application, the core module checks to see if the component
    object is already present in the cache.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: If the component object is already present in the cache, then there is no need
    to do anything else but to render its view.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the component object is not present, the core module looks
    for the component's object definition in the local storage first. This object
    definition has a property that holds the location (path) of the component's JavaScript
    file on the server.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using the local storage as the primary storage facility for
    such object definitions as opposed to keeping them in the cache. This is purely
    to keep the footprint of the application as small as possible in the browser.
    Usage of the local storage is especially important if we have quite a few object
    definitions for the components, since such, definitions could get quite large
    and consume a considerable amount of memory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, in our application there is no real need to use local storage, since
    we have only one dynamically loading component. But I'm using the local storage
    to show you how it can be leveraged if you decide to use this mechanism in your
    future applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The important point is that when the core finds the location of the component's
    file, it will make a request to the server for the `.js` (and possibly `.css`)
    file(s) of the component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Once the required `.js` file for the component is loaded and parsed, then the
    component registers itself with the core and, as with any other component in the
    application, it is given an instance of the sandbox module.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, this approach provides us with a very robust way to dynamically
    load and activate our application's components, which essentially encompasses
    the plug-and-play capabilities of the application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism is a bit more involved than what is explained here, but this brief
    description should provide a good overview of how things work behind the scenes.
    In the next chapter, we will have a closer look at the implementation of this
    mechanism and I'm sure all the details will become more clear to you in that chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Providing a centralized approach to handling errors
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core module implements a centralized approach to logging all types of messages.
    This frees the application modules and components from implementing such functionality
    themselves. It also provides enhanced capabilities for the logging mechanism that
    all components can leverage in a uniform way.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Note that any future enhancements that we may make to our logging mechanism
    will be done in one place and will be available to all the modules at the same
    time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine that we would like all the error messages in the application
    to be logged on the server. This could mean that for each error, an AJAX call
    needs to be made from the client to the server with the related information.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: If each module wanted to do that task itself, we would have to implement such
    functionality for each module separately. Of course, it makes more sense to implement
    this functionality once and then provide it to all of the application modules
    in a cohesive manner.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following screenshot, which displays our application messages
    being logged in the Chrome debugger tool when the application is in the debug
    mode:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing a centralized approach to handling errors](img/B04910_07_05.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: As you can see, when the application is loaded, all the modules as well as all
    the components in the application are initialized and the related messages are
    displayed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: All that the components need to do is call the sandbox module with the message,
    and the sandbox module in turn will send the message to the core module. In the
    case of other core modules, they can directly use the core module's logging mechanism.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code snippet which shows how the footer component logs its initialization
    message using the core module''s logging mechanism:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To log an error message, the footer component only needs to do the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a much simpler and better approach than the footer component implementing
    its own error-handling mechanism.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: If we decide to send all the error messages to the server, the module, will
    still make the same call to the sandbox module and in turn to the core module.
    It will be the core module that will be responsible for sending the error message
    to the server.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows how one of the core sub-modules sends its initialization
    message to the core module. This is similar to how the components log their message
    but with one difference.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The difference is that the sub-module directly sends its message to the core
    module and not through a sandbox module instance. This is, of course, because
    the sub-module is part of the core module and does not have an instance of the
    sandbox module.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the sandbox module itself uses the same logging facility provided by
    the core module to log its errors, as shown:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following image shows how the error message is displayed in the debugger:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing a centralized approach to handling errors](img/B04910_07_06.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: We will have a more in-depth look at how the logging mechanism has been implemented
    in our application, and how it is designed to be a sub-module of the core module,
    in the next chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Providing application-level extensibility
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the beginning, we designed our application based on modular architecture.
    One of the advantages that our modular architecture provides is the ability to
    easily extend our application's functionality and capabilities when needed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: As you saw, the functionality of our application was enhanced using various
    techniques, such as loose augmentation, tight augmentation, and sub-modules.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: While our application might provide quite a bit of functionality, it is a reasonable
    to assume that more features and capabilities will be needed in the future.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine that one or more of our future components need to do form
    field validation. This functionality can be easily added to our application by
    extending the core module and then providing the functionality to our components.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The core module can provide form field validation by either importing a validation
    library through the base module or by implementing the functionality itself. This
    new functionality will then be provided to all the registered components through
    the sandbox module and all the components can use it as needed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In fact, our components would not even know who has provided this new functionality
    and how it works behind the scenes. All they need to know is that the functionality
    is available to them and they can use it to accomplish their validation tasks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Being able to provide application-level extensibility is one of the key features
    of our modular design and one of the most important tasks that the core module
    is responsible for.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging third party libraries
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly talked about this responsibility of the core module before. As mentioned,
    the core module is designed to ask for third party libraries from the base module.
    These libraries are used by the core module to provide application-level functionality
    for other pieces of the application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The import of such libraries usually happens at the application start-up time,
    but it does not have to.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: As you saw previously in this chapter, our application does have the capability
    to load files dynamically from the server. It is quite possible that while the
    application is running, based on certain application needs or certain user interactions
    with the application, we need to load a third party library dynamically.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we would use the dynamic loading of a third party library
    when the library is not needed for most of the functionality of our application.
    This allows us to keep the foot print of our application small, which is an important
    consideration on mobile devices.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: In the application for this book, we do not use such dynamic loading of third
    party libraries. However, if at any point in the future you decide to leverage
    this capability, all the hooks are available for it in the code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how the core module uses the base module to import the
    jQuery library into our application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code snippet, during the start-up phase of the application,
    our core module (`MainCore` module of the core module) asks the base module for
    jQuery.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done as shown here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we have wrapped this call in a try/catch statement to capture any
    errors that could happen during this operation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Let's also have a look at how the base module provides a reference for jQuery
    to the core module.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, since jQuery loads as a global object in the application, the
    base module simply returns a reference to this global object to the core module.
    From that point forward, jQuery is used by the core module as a sub-module to
    deliver application-level functionality.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows an example of how jQuery is used in the application
    to provide the required functionality:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just in the same way, other third party libraries can be loaded into the application
    at the start-up phase to enhance our application's functionality.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Note that none of the other modules or components are aware of the third party
    libraries or how they are leveraged. It is only the core module that is aware
    of such libraries, and it is the only module to provide the third party library
    functionality to other application modules and components.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows how third party libraries can be placed in our application''s
    folder structure:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging third party libraries](img/B04910_07_07.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: Components
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last main piece of our application design is related to components. In this
    section, we will cover how components are built and plugged into our application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we considered components as pieces of the application that have
    views. By views, I am referring to the pieces that have HTML elements associated
    with them which are rendered in the browser and the users can interact with them
    directly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Components can be as simple as a layover box. Such simple components can be
    rendered as part of another component or as a stand-alone component on their own.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, our components are independent modules with their own MVC
    or MV* architecture, which are attached to the application and use the facilities
    and functionality that the rest of the application provides for them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In our design, we have created three main components and a widget named `NotificationWidget`.
    This widget is also a component but it is loaded and viewed based on the user's
    interaction with another component. In our application, `NotificationWidget` is
    launched when the user clicks on the **Support** link in the footer component.
    Since this widget can potentially be launched by other components too, I am tagging
    it as a widget but for all practical intents and purposes, it is also a component
    with its own MV* implementation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Components can have very sophisticated business logic implemented in their controller,
    or have a very simple controller with very little functionality.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In our application, the content component is an example of a component with
    a fairly involved controller logic, and the footer stands as a component with
    a relatively simple controller.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Also remember that the only bridge or point of connection between a component
    and the rest of the application is via an instance of the sandbox which was passed
    to it when the component registered itself with the core.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We previously talked about how, in our architecture, components can be loaded
    either at the start-up phase of the application or dynamically at any time after
    that. In our implementation, header, footer, and the content components are loaded
    at the start-up phase and `NotificationWidget` is loaded dynamically, when required.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at one of our simpler components, the footer, and see how
    it is implemented.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Components required methods
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our design, there are two required methods that every component needs to
    implement in order to register and connect with the core module and the rest of
    the application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: These two required methods are called `init` and the `destroy` methods. The
    `init` method is called by the core module to start the initialization of the
    component. On the other hand, the `destroy` method is called by the core module
    to either disable or completely remove the component from the application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the implementation below:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, in the `init` method of the footer component, the required HTML
    string for the view is fetched from the `GlobalData` object. This object is an
    application-level object (the application model) which holds application-level
    data. The HTML string is then passed to the core module via the sandbox module
    instance.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Note that the core module is responsible for rendering HTML elements, in this
    case the footer's view, on the page.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in the following lines of code in the `init` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For this particular component, we call for the rendering of the view in this
    method. However, the rendering does not always have to be done in the `init` method
    of a component. For instance, for `NotificationWidget` component, the rendering
    is done in a different method which is called at some later time by the application.
    Consequently, the `init` method of `NotificationWidget` is kept very simple, as
    follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Binding events to the components elements
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `init` method of the footer component, we also register the HTML elements
    related to its view for handling events. This is done by calling `registerForEvents`
    method of the component. In `registerForEvents` method, the related event handler
    is bound to the `support` link, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the actual binding for the event is done in the core module.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: I previously mentioned that our components are loosely coupled with the other
    pieces of the application by custom events using the mediator pattern. Let's have
    a quick look at that.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the footer component publishes a custom event when the **Support**
    link is clicked. Then, all the other pieces of the application that have registered
    for this custom event will be notified by the core module that this event has
    occurred. We will talk about this mechanism more in the next chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Component design considerations
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we did not examine the implementation details of the components
    too closely, as we will have a more in-depth look at them in the next chapter.
    However, I would like you to consider a few conceptual aspects of the components.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: First of all, all the components are loosely coupled with the application. The
    only connection between them and the rest of the application is through an instance
    of the Sandbox, which was passed to them during the registration phase.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Second, all the components are responsible for implementing their own controllers.
    The other application pieces do not get involved with the functionality, which
    is specific to an individual component.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The job of the application as a whole, and the core module in particular, is
    to create a robust ecosystem in which the components can leverage the application-level
    functionality that has been implemented. Therefore, the components do not need
    to implement such functionality themselves. This approach allows us to create
    a cohesive and loosely coupled application that can be easily maintained and extended
    as the need arises.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Note that each Component is a self-contained piece of the application and the
    core or any other pieces of the application are not aware of nor are dependent
    on the internal implementation of the Component. This means that components are
    free to decide on their own implementation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, we can create a good level of separation of concerns and responsibilities
    throughout all the application pieces.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: When a component needs to modify the DOM, it should do so by leveraging the
    functionality that the core module provides. Therefore the component does not
    have to implement this functionality itself. Also, by using the core module, we
    are able to prevent other pieces of the application from accidentally causing
    any conflicts at the same DOM element level, thus preventing collisions and application-level
    issues.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The proper approach in most cases is that components only modify the DOM elements
    (through the core module) in their own container and not beyond that.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Application architectural considerations
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s review the important points that we have discussed about our modular
    architecture in this chapter and see how they relate to various pieces of our
    application, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: All third party libraries are imported into the application through the base
    module
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core module and the base module are the only pieces of the application that
    know about the loaded third party libraries
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All browser compatibility issues are dealt with in the core module by leveraging
    the functionality of the third party libraries
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every component in the application gets an instance of the sandbox module
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sandbox only knows about the core and no other pieces of the application
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No pieces of the application know about the internal implementation of other
    pieces
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components can be added, modified, or removed from the application without affecting
    the application as a whole
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components can only call their own methods and the methods provided to them
    through their instance of the sandbox module
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components cannot access DOM elements outside of their own container
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components should not create global objects
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each module and component only does limited tasks and only things which are
    directly related to its own functionality
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the components in the application are loosely coupled with the rest of the
    application
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components can only communicate with other components and other pieces of the
    application using a publish-subscribe model (the mediator pattern) and their sandbox
    instance, thus preserving the loose coupling architecture
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component has a very limited understanding of the application, and that
    is through the instance of the sandbox module which was assigned to it during
    the registration phase of the component with the application
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件对应用的理解非常有限，这是通过在组件注册阶段分配给它的沙盒模块实例实现的
- en: 'The following can be considered as the advantages that modular architecture
    provides for us:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下可以被认为是模块化架构为我们提供的优势：
- en: Once the modular architecture ecosystem has been developed, it can be used for
    many applications; therefore, we can code once and use many times
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦模块化架构生态系统被开发出来，它可以用于许多应用；因此，我们可以一次编码，多次使用
- en: Each piece of the application can be tested separately
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用中的每一部分都可以单独进行测试
- en: Each piece of the application can be implemented by different people in a modularized
    fashion
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用中的每一部分都可以由不同的人以模块化的方式实现
- en: Third party external dependencies can be controlled and managed by the core
    module
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方外部依赖可以通过核心模块进行控制和管理工作
- en: Modules and components can be replaced, modified, or removed without affecting
    the application as a whole
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和组件可以被替换、修改或删除，而不会影响整个应用
- en: Components and modules can be loaded dynamically and as needed after the application
    start-up phase
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和模块可以在应用启动阶段之后根据需要动态加载
- en: I hope you view the points above as important takeaways from this chapter and
    will keep them in mind as we move forward to a more in-depth look at the application's
    implementation in the next chapter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您将上述观点视为本章的重要收获，并在我们深入探讨下一章中应用实现时牢记在心。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As was noted in the beginning of this chapter, we had a good overview of the
    architectural concepts related to the modular implementation of our application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所提到的，我们对与我们的应用模块化实现相关的架构概念有了很好的概述。
- en: We discussed the main pieces of the application and saw how they come together
    to create a cohesive ecosystem.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了应用的主要组成部分，并看到了它们如何组合在一起形成一个统一的生态系统。
- en: We also examined the specific roles that the pieces play in the overall application
    design and looked at how we can create a good separation of responsibilities and
    concerns among our modules and components.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考察了各个组件在整体应用设计中的具体角色，并研究了我们如何在模块和组件之间创建良好的职责和关注点分离。
- en: One of the important aspects that we focused on was to loosely couple our various
    application pieces together, which allows for ease of maintainability as well
    as future extensibility.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的一个重要方面是将我们的各种应用组件松散地耦合在一起，这既便于维护，也便于未来的扩展。
- en: While some application code was shown in the chapter, we did not get deeply
    involved in analyzing the code and the application implementation. This is exactly
    what we will cover in the next chapter, where we will have a closer look at how
    things are done under the hood.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章展示了部分应用代码，但我们并没有深入分析代码和应用实现。这正是我们将在下一章中涵盖的内容，我们将更详细地了解幕后是如何操作的。
