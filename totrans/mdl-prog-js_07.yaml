- en: Chapter 7. Base, Sandbox, and Core Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：基础、沙盒和核心模块
- en: So far in this book, we have mostly looked at different techniques for creating
    and enhancing modules. However, our focus has been on the smaller pieces of the
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们主要探讨了创建和增强模块的不同技术。然而，我们的焦点一直在于应用程序的较小部分。
- en: In this chapter, we are going to take a holistic view of our application as
    a complete functioning body. We will see how its various pieces can be put together
    to create a robust and flexible ecosystem to deliver our ultimate goal, which
    is a working **Single-Page Application** (**SPA**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从整体的角度审视我们的应用程序作为一个完整的运行体。我们将看到其各个部分如何组合在一起，以创建一个强大且灵活的生态系统，从而实现我们的最终目标，即一个可工作的**单页应用程序**（SPA）。
- en: As you read through different sections of this chapter, keep in mind that all
    the pieces of the application are designed to work together in concert, while
    still adhering to the principles of maintainability and extensibility of a modular
    design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章的不同部分时，请记住，应用程序的所有部分都旨在协同工作，同时仍然遵守模块化设计的可维护性和可扩展性原则。
- en: 'In this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Base module and its design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础模块及其设计
- en: Sandbox and the principles behind sandboxing of our components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙盒及其组件沙盒化的原则
- en: Core and its related modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心和相关的模块
- en: Components and how they are added to the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件以及它们如何添加到应用程序中
- en: Plug-and-play, progressive enhancement, and graceful degradation in our application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，即插即用、渐进增强和优雅降级
- en: Note that we will not get too deep into the coding aspect of things here, since
    I would really like you to focus on the architecture of the application, as opposed
    to being distracted with the details of the implementation. As such, there is
    no project code associated with this chapter of the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不会深入到事物的编码方面，因为我真的希望您专注于应用程序的架构，而不是被实现的细节所分散注意力。因此，与本章相关的书籍没有项目代码。
- en: I should also mention that the architectural design concepts discussed in this
    chapter, and the next, are based on the design principles that I was originally
    introduced to by *Nicholas C. Zakas*, after watching one of his talks on the subject.
    He is one of my favorite authors and speakers. While our implementation will slightly
    deviate from his, the essence of our architecture will remain similar to his proposed
    architectural design.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提到，本章和下一章中讨论的架构设计概念是基于我在观看关于该主题的一次演讲后，由*Nicholas C. Zakas*最初介绍给我的设计原则。他是我的最爱作者和演讲者。虽然我们的实现将略有偏离他的，但我们的架构的精髓将保持与他提出的架构设计相似。
- en: Application architecture overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构概述
- en: To create a truly modular design for our application, we need to break it down
    into smaller functional pieces, in such a way that each piece will specialize
    in and be responsible for very specific tasks. This enables us to achieve the
    principle of separation of concerns and responsibilities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的应用程序创建一个真正模块化的设计，我们需要将其分解成更小的功能部分，这样每个部分都将专门负责非常具体的工作。这使我们能够实现关注点和责任分离的原则。
- en: 'The following diagram provides a depiction of our overall application design:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了我们整体的应用程序设计：
- en: '![Application architecture overview](img/B04910_07_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序架构概述](img/B04910_07_01.jpg)'
- en: 'As you can see, our application consists of four main pieces:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的应用程序由四个主要部分组成：
- en: Base
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础
- en: Sandbox
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙盒
- en: Core
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心
- en: Component
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: At the same time, each main piece may consist of other smaller pieces which
    are packaged together to create the main piece.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，每个主要部分可能由其他更小的部分组成，这些部分被打包在一起以创建主要部分。
- en: Let's start by exploring each main piece of the application and looking at the
    specific functionality that each piece provides.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索应用程序的每个主要部分并查看每个部分提供的具体功能开始。
- en: For our purposes in this book, from this point forward, when I talk about **components**,
    I'll be referring to modules that have user interface pieces (views) which the
    user is able to interact with, such as the header component. However, when I refer
    to **modules** I will be referring to functional modules that each main piece
    may consist of, which do not have any views associated with them directly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的用途中，从现在开始，当我提到**组件**时，我将指的是具有用户界面部分（视图）的模块，用户可以与之交互，例如头部组件。然而，当我提到**模块**时，我将指的是每个主要部分可能由其组成的具有功能性的模块，这些模块没有直接关联的视图。
- en: The definitions will become more clear as we move along but you may decide to
    refer to such pieces differently in your own projects. This is fine, as long as
    the architectural concepts behind them remain the same.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，定义将变得更加清晰，但你可能决定在自己的项目中以不同的方式引用这些部分。这是可以的，只要它们背后的架构概念保持一致。
- en: Also, from time to time, I will be referring to our modular design architecture
    as a **framework,** which should be interpreted as all the various pieces of the
    application together as a whole.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，时不时地，我会将我们的模块化设计架构称为**框架**，这应该被理解为将应用的所有各个部分作为一个整体一起考虑。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**About the term framework**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于框架这个术语**'
- en: While I will be using the term framework at times, our application is not meant
    to create what is generally known as a framework. At least not in the same capacity
    that the term is used to refer to frameworks in the likes of **AngularJS** or
    **React**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我有时会使用框架这个术语，但我们的应用程序并不是为了创建通常所说的框架。至少不是在像**AngularJS**或**React**这样的框架中使用的意义上。
- en: Generally speaking, I think sometimes third-party frameworks are overused and
    while they all provide some pros, there are also cons associated with using any
    type of third party framework.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，我认为有时第三方框架被过度使用，虽然它们都提供了一些优点，但使用任何类型的第三方框架也都有一些缺点。
- en: The purpose of this book is to show you how you can create your own architectural
    design which allows you to easily create, organize, and maintain your application's
    code base without the need for a third party framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是向您展示您如何创建自己的架构设计，这样您就可以轻松地创建、组织和维护您的应用程序代码库，而无需第三方框架。
- en: As such, I would like you to look at our implementation as an architectural
    design concept as opposed to a framework. But if you insist, you can call what
    we design and create here an **ironic framework**. I say ironic, because it is
    really not a framework in the traditional sense, as it does not impose a special
    syntax or a slew of rules and regulations!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我希望您将我们的实现视为一个架构设计概念，而不是一个框架。但如果您坚持，您可以将我们在这里设计和创建的内容称为**讽刺框架**。我说讽刺，因为它实际上并不是一个传统意义上的框架，因为它不强制使用特殊的语法或一系列规则和条例！
- en: The best way to describe our implementation is perhaps by using the term **Client-side
    Modular Design** (**CMD**), since the goal of this architectural approach is to
    create a solid foundation and a flexible ecosystem for our applications, as opposed
    to it being a framework.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 描述我们的实现的最佳方式可能是使用术语**客户端模块化设计**（**CMD**），因为这种架构方法的目标是为我们的应用程序创建一个坚实的基础和灵活的生态系统，而不是作为一个框架。
- en: Base module
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础模块
- en: We will start our exploration of the design with the base module. As the name
    implies, the base module provides the lowest level of functionality for our application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始探索设计的基础模块。正如其名所示，基础模块为我们应用程序提供最低级别的功能。
- en: This is where we import and leverage the functionality of third party libraries
    and utilities. These libraries can consist of jQuery, Dojo, MooTools, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们导入并利用第三方库和工具的功能的地方。这些库可以包括jQuery、Dojo、MooTools等等。
- en: The main idea is that we can easily use the functionality provided by such libraries
    without the need to create a tight dependency between our application and the
    libraries used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是我们可以轻松使用这些库提供的功能，而无需在我们的应用程序和使用的库之间创建紧密的依赖关系。
- en: 'For instance, consider how we need to detect browser compatibility to attach
    events to our elements on the page, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下我们需要如何检测浏览器兼容性，以便将事件附加到页面上的元素，如下所示：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Whereras we could easily let jQuery take care of such intricacies by doing
    the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们本可以轻松地通过以下方式让jQuery处理这些复杂性：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are letting jQuery take care of the browser compatibility issues and
    we can focus on other, more important things in our application. Another example
    is adding animations to our elements only when jQuery is present. This approach
    allows us to implement **progressive enhancement** and **graceful degradation**
    techniques in our code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们让jQuery处理浏览器兼容性问题，我们可以专注于应用程序中其他更重要的事情。另一个例子是在jQuery存在时才给我们的元素添加动画。这种方法允许我们在代码中实现**渐进增强**和**优雅降级**技术。
- en: We can also have both of such implementations in our code. This allows us to
    have a fallback if jQuery has not been loaded properly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在我们的代码中同时使用这两种实现。这允许我们在jQuery没有正确加载时有一个回退方案。
- en: 'Therefore, the preceding code can be written as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的代码可以写成以下形式：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most of the time, it is best to leave low-level functionality such as browser
    compatibility issues to third party libraries and focus on providing customized
    functionality for our application in our own code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，最好将低级功能，例如浏览器兼容性问题，留给第三方库，并专注于在我们自己的代码中提供针对我们应用程序的定制功能。
- en: Keep in mind that we are talking about third party libraries and utility packages
    here and not third party frameworks, as one of the goals of our architecture is
    to eliminate, or at least minimize, the need for third party frameworks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们在这里讨论的是第三方库和实用程序包，而不是第三方框架，因为我们的架构目标之一是消除或至少最小化对第三方框架的需求。
- en: Adding general-purpose libraries to the base module
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将通用库添加到基础模块
- en: As mentioned, our base module loads and provides general-purpose libraries to
    the core module of our application. This means that only the core is aware of
    what base libraries are used in the code, as well as which particular functionality
    of such libraries is being leveraged.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，我们的基础模块加载并提供通用库给我们的应用程序核心模块。这意味着只有核心模块知道代码中使用了哪些基础库，以及这些库的哪些特定功能被利用。
- en: Depending on the design of our base module, the libraries are either loaded
    at application start-up time or dynamically at a later time. The base module passes
    a reference for each loaded and initialized library to the core module.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基础模块的设计，库要么在应用程序启动时加载，要么在稍后的时间动态加载。基础模块将每个加载和初始化的库的引用传递给核心模块。
- en: Since it is only the core module that is aware of what libraries are used in
    the application and to what extend, if we ever decide to change our third party
    libraries or how they are used in the application, it is only the core module
    that is affected and no other pieces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有核心模块知道应用程序中使用了哪些库以及使用程度，如果我们决定更改第三方库或它们在应用程序中的使用方式，那么只有核心模块受到影响，其他部分不受影响。
- en: This means that all the other pieces and components of our application will
    continue to work as they did before, regardless of the change in the third party
    libraries. Implementing our application as such minimizes the impact of replacing
    or removing the third party libraries on the application as a whole.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应用程序的其他所有部分将继续按原样工作，无论第三方库的变化如何。以这种方式实现我们的应用程序最小化了替换或删除第三方库对整个应用程序的影响。
- en: This also holds true when we import and use new libraries in order to add more
    functionality to our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入和使用新库以添加更多功能到我们的应用程序时，这也同样适用。
- en: In the next chapter, we will have a closer look at how the base module is used
    to add jQuery to our application's core module.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨如何使用基础模块将jQuery添加到我们应用程序的核心模块。
- en: 'The following is a depiction of how third party libraries are provided to the
    core module by our application''s base module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应用程序的基础模块如何向核心模块提供第三方库的描述：
- en: '![Adding general-purpose libraries to the base module](img/B04910_07_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![将通用库添加到基础模块](img/B04910_07_02.jpg)'
- en: Sandbox module
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沙盒模块
- en: When we talk about a sandbox in our daily lives, we usually have a picture of
    a box full of sand in our minds, where we allow the kids to play and make all
    the mess they like - and hopefully only in that box.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在日常生活中谈论沙盒时，我们通常脑海中浮现的是一个装满沙子的盒子，我们允许孩子们在那里玩耍，做他们喜欢的一切混乱——并且希望只是在那个盒子里。
- en: In our modular architecture, we capitalize on the same concept and create spaces
    for our components to play in and to be isolated from other pieces of the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块化架构中，我们利用同样的概念，为我们的组件创造可以玩耍的空间，并使其与其他应用程序的其他部分隔离。
- en: By sandboxing our modules in such a way, we eliminate tight coupling among our
    application components and the core module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式沙盒化我们的模块，我们消除了应用程序组件与核心模块之间的紧密耦合。
- en: The sandbox is essentially a layer of abstraction as well as a thin interface
    between our components and the other pieces of our application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒本质上是一个抽象层，也是我们组件与其他应用程序其他部分之间的一层薄薄的接口。
- en: As the sandbox module is designed to be an interface and to provide communication
    among our components and the rest of the application, it is considered a contract
    and, as such, it should never change. This is so our components can be sure that
    they can always count on a consistent layer of communication with the application
    as well as a certain level of functionality provided by the core module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于沙盒模块被设计为接口，并提供组件与其他应用程序之间的通信，它被视为合同，因此它不应改变。这样，我们的组件可以确信它们始终可以依赖与应用程序的一致通信层以及核心模块提供的一定功能级别。
- en: That is not to say, we cannot add new methods or functionality to the sandbox;
    it is only that we cannot change what is already there and that our components
    have come to rely on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说我们不能向沙盒添加新方法或功能；只是我们不能改变已经存在的内容，并且我们的组件已经依赖于此。
- en: Sandbox module functionality
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沙盒模块功能
- en: When our components are loaded in the application, either at application start-up
    time or dynamically any time after, they are all given an instance of the sandbox
    module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的组件在应用程序中加载时，无论是启动时还是动态加载的任何时间，它们都会获得沙盒模块的一个实例。
- en: 'The sandbox module provides the following for our components:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒模块为我们组件提供以下功能：
- en: A consistent interface
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致接口
- en: Security
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Communication
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信
- en: Filtering
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤
- en: Each one of the services provided by the sandbox module is crucial to the modular
    aspect of our implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒模块提供的每个服务对我们实现的模块化方面都至关重要。
- en: Let's explore each aspect in more detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨每个方面。
- en: Sandbox as a consistent interface
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沙盒作为一致的接口
- en: As mentioned, when every registered component is given an instance of the sandbox
    module by the core module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，当核心模块为每个注册的组件提供一个沙盒模块实例时。
- en: This instance of the sandbox then acts as an interface to the rest of the application,
    which provides application-level functionality for the component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此沙盒实例随后充当应用程序其余部分的接口，为组件提供应用程序级别的功能。
- en: When a component needs a particular functionality, it does not necessarily need
    to implement it itself. This is true when the implementation of that functionality
    is already available in the application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件需要特定功能时，它不一定需要自己实现。当该功能的实现已经在应用程序中可用时，这一点是正确的。
- en: For instance, to bind event handlers to elements, each component does not need
    to provide its own implementation. Components can simply ask the sandbox module,
    which in turn, asks the core module to bind a certain event handler to a particular
    element on the page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了将事件处理器绑定到元素上，每个组件不需要提供自己的实现。组件可以直接请求沙盒模块，然后沙盒模块会请求核心模块将特定的事件处理器绑定到页面上特定的元素。
- en: Of course, the components also do not have to worry about browser compatibility
    issues related to event binding, as it is the job of the core module to take care
    of such issues.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，组件也不必担心与事件绑定相关的浏览器兼容性问题，因为处理这些问题是核心模块的工作。
- en: Since the sandbox instance is identical for every registered component, we can
    be sure that any changes in the sandbox code is provided to all the components
    at the same time. This means that the addition of new functionality, bug fixes,
    and modifications in the sandbox module are done once and then propagated to all
    the components that use the sandbox module, in a uniform and cohesive manner.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于沙盒实例对每个注册的组件都是相同的，我们可以确信沙盒代码中的任何更改都是同时提供给所有组件的。这意味着新功能的添加、错误修复和沙盒模块中的修改只进行一次，然后以统一和一致的方式传播到所有使用沙盒模块的组件。
- en: Note that any changes to the sandbox module should still honor the previous
    contract between this module and the application's components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对沙盒模块的任何更改仍应遵守此模块与应用程序组件之间的先前合同。
- en: Sandbox as a security layer
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沙盒作为安全层
- en: The components in our application only know about the sandbox module and are
    not allowed (or able) to directly communicate with any other pieces of the application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的组件只知道沙盒模块，并且不允许（或无法）直接与其他应用程序部分通信。
- en: This means that the sandbox makes sure that protected areas of the framework
    are not accessible by the components through its interface. This enables us to
    control the type of operations that the components are permitted to perform, within
    the context of the core and other modules of the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着沙盒确保框架的保护区域不能通过其接口被组件访问。这使得我们能够在核心和其他应用模块的上下文中控制组件被允许执行的操作类型。
- en: Sandbox as a communication layer
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沙盒作为通信层
- en: As the sandbox module is a thin layer of interface which provides the exposed
    interface of the core module to the components, it is the only route of communication
    between the components and the rest of the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于沙盒模块是一个薄薄的接口层，它为组件提供了核心模块的公开接口，因此它是组件与整个应用之间唯一的通信路径。
- en: It is also through the sandbox module that components can subscribe to and publish
    custom events in the application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 也是通过沙盒模块，组件可以在应用中订阅和发布自定义事件。
- en: Note that it is important for the components to only have one route of communication
    with the rest of the application so we can preserve the integrity of our modular
    design. If a component is able to directly communicate with another component
    or other parts of the application, then it could be tightly coupled to such pieces,
    and we certainly would like to avoid this type of tight coupling.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于组件来说，只与整个应用的其他部分保持一条通信路径是很重要的，这样我们才能保持模块化设计的完整性。如果一个组件能够直接与其他组件或应用的其它部分通信，那么它可能会与这些部分紧密耦合，而我们当然希望避免这种紧密耦合。
- en: Sandbox as a filter
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沙盒作为过滤器
- en: The design of the sandbox should be done in a way that not only will it provide
    the functionality of the core module that we want to expose to the components,
    but it can also do simple error checking for the calls made by the components
    to the core.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒的设计应该以这种方式进行，不仅能够提供我们想要向组件公开的核心模块的功能，而且还能对组件对核心模块的调用进行简单的错误检查。
- en: 'For instance, consider the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下情况：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding method has been provided to our components through the sandbox
    module. This method does a simple parameter check to make sure that the parameter,
    as well as the correct type of the parameter, has been passed to it by the component
    before the sandbox module asks the core to do the work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法已经通过沙盒模块提供给了我们的组件。这个方法进行简单的参数检查，以确保在沙盒模块请求核心模块执行工作之前，参数以及参数的正确类型已经被组件传递给它。
- en: While the core module might have its own error checking, it is always a good
    idea to do some error checking at the sandbox level before getting the core module
    involved.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然核心模块可能有自己的错误检查，但在将核心模块卷入之前进行一些错误检查总是一个好主意。
- en: Implementing multiple instances of the sandbox module
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现多个沙盒模块实例
- en: You may be wondering at this point, why is it a better idea to use multiple
    instances of the sandbox module (one for each component) as opposed to having
    all the components use the same sandbox object as a singleton?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道，为什么使用多个沙盒模块实例（每个组件一个）比所有组件使用同一个沙盒对象作为单例更好？
- en: 'The short answer is: better isolation and performance. We need to explore that
    answer a little further in the upcoming sections.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是：更好的隔离和性能。我们将在接下来的章节中进一步探讨这个答案。
- en: Advantages of multiple instances of the sandbox
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个沙盒实例的优势
- en: Usually, a module provides its exposed functionality to the outside world through
    a single common interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个模块通过一个单一的公共接口向外界提供其公开的功能。
- en: However, our implementation of the sandbox module is different. As mentioned
    previously, we create multiple instances of the sandbox module and, to be more
    precise, one instance per component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们实现的沙盒模块是不同的。如前所述，我们创建了多个沙盒模块实例，更准确地说，每个组件一个实例。
- en: 'The following summarizes the goals behind this design:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下总结了此设计背后的目标：
- en: Isolating sandbox instances from each other
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将沙盒实例相互隔离
- en: Creating a code execution context for each component
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个组件创建代码执行上下文
- en: Performance improvements
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能提升
- en: Isolating the sandbox instances from each other
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将沙盒实例相互隔离
- en: In our analogy of a kid playing in a sandbox, I mentioned that this type of
    isolation contains the possible mess created in the box. In just the same way,
    we would like any possible damage to a sandbox module instance to be contained
    and isolated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关于孩子在沙坑里玩耍的类比中，我提到这种隔离可以包含在盒子中可能产生的混乱。同样，我们希望任何沙盒模块实例可能造成的损害都被包含和隔离。
- en: This would mean that, if one of our components does something undesirable which
    could cause issues in its sandbox instance, such a mess would be contained within
    that sandbox module instance. The adverse effects will only impact the functionality
    of that component but no other sandbox instances, or any other components for
    that matter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们的组件中有一个做了不希望做的事情，可能会在其沙盒实例中引起问题，这种混乱将被包含在该沙盒模块实例中。不利影响只会影响该组件的功能，而不会影响其他沙盒实例，或任何其他组件。
- en: It is very important for us to design our architecture in such a way which minimizes
    the chances of complete application failure caused by an issue in one of the components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，设计我们的架构以最大限度地减少由组件问题引起的完全应用程序失败的可能性非常重要。
- en: This allows for at least partial functionality of our application, which is
    probably a much more acceptable outcome than a complete application failure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这至少允许我们的应用程序保持部分功能，这可能是比完全应用程序失败更可接受的结局。
- en: For instance, the footer component in our application may stop working but the
    user can still view the catalog of our images and add them to the favorites list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们应用程序的页脚组件可能停止工作，但用户仍然可以查看我们的图像目录并将它们添加到收藏夹列表中。
- en: Creating a code execution context
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建代码执行上下文
- en: When a sandbox module is created, it sets a context object for its component.
    Components can use this context object to easily refer to the correct execution
    context when needed. This is probably better understood if we look at an example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建沙盒模块时，它为它的组件设置一个上下文对象。组件可以在需要时使用这个上下文对象来轻松引用正确的执行上下文。如果我们看一个例子，这可能会更容易理解。
- en: 'Consider the following code snippet from our application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自我们应用程序的代码片段：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function above is implemented in the content component of our application.
    Inside this function, which is the click event handler for some of the elements
    on the page, we need to call other related functions in the content component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的函数是在我们应用程序的内容组件中实现的。在这个函数内部，它是页面某些元素点击事件的处理程序，我们需要在内容组件中调用其他相关函数。
- en: We can easily do that by using the execution context that we set on the sandbox
    instance for this component when we first initialize the component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用在组件首次初始化时设置在沙盒实例上的执行上下文来轻松做到这一点。
- en: 'This is done as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这样做的：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the code snippet, `this` refers to the content component of our application.
    Thus, when we need to execute any functions in the context of our content component,
    we can just refer to the correct context, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，`this` 指的是我们应用程序的内容组件。因此，当我们需要在内容组件的上下文中执行任何函数时，我们只需引用正确的上下文，如下所示：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this does not make a lot of sense to you right now, do not be alarmed. I
    will explain this further in the next chapter where we'll have a chance to look
    at it's full implementation in the code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在觉得这不太明白，不要担心。我将在下一章中进一步解释，届时我们将有机会查看它在代码中的完整实现。
- en: For now, the only thing that you need to keep in mind is that we can use each
    instance of the sandbox module to preserve a reference to the component that the
    sandbox instance belongs to. This allows us to easily access the execution context
    of that component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你需要记住的唯一一点是，我们可以使用每个沙盒模块的实例来保留它所属组件的引用。这使我们能够轻松访问该组件的执行上下文。
- en: Performance improvements
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 性能改进
- en: When we create an instance of the sandbox for each component, we also assign
    a reference on the sandbox instance to the DOM element in which the component's
    view resides. This allows us to make our DOM manipulation within that container
    a lot more efficiently, since we do not need to traverse the whole DOM tree to
    find the DOM element of interest within the container of the component's view.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为每个组件创建沙盒实例时，我们也把沙盒实例的引用分配给组件视图所在的DOM元素。这使得我们在该容器内进行DOM操作变得更加高效，因为我们不需要遍历整个DOM树来找到组件视图容器内的目标DOM元素。
- en: 'Have a look at the following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码片段：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this snippet, we are trying to find a child element of the container element
    where the component's view has been rendered.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们正在尝试找到容器元素中的一个子元素，其中组件的视图已经被渲染。
- en: When the component was registered with the core, the core created an instance
    of the sandbox and returned a reference to the component's container element with
    the sandbox instance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件在核心中注册时，核心创建了一个沙盒实例，并返回一个包含沙盒实例的组件容器元素的引用。
- en: For instance, after the header component of our application is created, all
    the header-related DOM elements reside inside a main div element container that
    hosts them. The header component's sandbox instance holds a reference to this
    div container.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们应用的头部组件创建后，所有与头部相关的DOM元素都位于一个承载它们的main div元素容器内。头部组件的沙盒实例持有这个div容器的引用。
- en: When the header component needs access to any DOM elements related to its view,
    it will only need to look for the desired element inside of its container div
    element as opposed to traversing the whole DOM tree to find the element.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当头部组件需要访问与其视图相关的任何DOM元素时，它只需在其容器div元素内部查找所需的元素，而不是遍历整个DOM树来找到该元素。
- en: This makes finding the desired element much quicker as we don't need to search
    the entire DOM looking for it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得查找所需元素变得更快，因为我们不需要在整个DOM中搜索它。
- en: If you are not completely clear on how this works, we will cover it again in
    the next chapter when we examine the code in more depth.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此不完全清楚，我们将在下一章中再次介绍，当我们更深入地检查代码时。
- en: For now, just be mindful of the fact that the sandbox instance allows us to
    have quick and direct access to the DOM element that the component renders in,
    which in turn allows for much more optimized DOM manipulation tasks related to
    the component.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需注意沙盒实例使我们能够快速直接地访问组件渲染的DOM元素，这反过来又允许进行与组件相关的更多优化的DOM操作任务。
- en: Core module
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心模块
- en: The core module is really the brain of our application. It is where the application's
    heavy lifting is done and the real magic happens.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块实际上是我们的应用程序的大脑。它是应用程序的重负载工作发生的地方，真正的魔法在这里发生。
- en: The core module is responsible for implementing application-level business logic
    as well as providing bridges among components when there is a need for components
    to communicate with each other. Of course, while still preserving the loose coupling
    nature of the application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块负责实现应用级别的业务逻辑，并在组件需要相互通信时提供组件之间的桥梁。当然，同时保持应用的松耦合特性。
- en: The core module also leverages the functionality provided by the third party
    libraries, which are loaded by the base module, to create a cohesive functional
    application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块还利用了由基础模块加载的第三方库提供的功能，以创建一个功能一致的应用程序。
- en: If you are familiar with the architectural design pattern known as **Module-View-Controller**
    (**MVC**), the core module is the controller piece of this design pattern in our
    application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉名为**模块-视图-控制器**（**MVC**）的架构设计模式，那么在我们应用中的核心模块就是这个设计模式中的控制器部分。
- en: 'We can summarize the role of core module as the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将核心模块的作用总结如下：
- en: Acting as the controller for the application
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为应用程序的控制器
- en: Providing communication bridges among modularized components
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块化组件之间提供通信桥梁
- en: Initializing and destroying components
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化和销毁组件
- en: Implementing plug-and-play capability for the components
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现组件的即插即用能力
- en: Providing a centralized method of handling errors
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供集中处理错误的方法
- en: Providing application-level extensibility
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供应用级别的可扩展性
- en: Leveraging third party libraries' functionality
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用第三方库的功能
- en: We will examine all these aspects very shortly but before doing so, let's talk
    about how the core is constructed in our application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快检查所有这些方面，但在这样做之前，让我们谈谈在我们的应用中核心是如何构建的。
- en: Core module construction approach
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心模块构建方法
- en: There are different approaches to building the core module, but one of the best
    approaches is to build it in a modularized fashion.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 建设核心模块有不同的方法，但其中最好的方法之一是以模块化的方式构建它。
- en: We can start the implementation by building a main core module and then augment
    it using techniques such as loose and tight augmentation, which we have already
    covered in this book. However, adding most of the functionality to the core module
    using sub-modules allows for a better separation of the logic in the code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构建一个主要的核心模块并使用诸如松散和紧密增强等技术来增强它来开始实现，这些技术我们已经在本书中介绍过。然而，通过子模块将大部分功能添加到核心模块中，可以更好地分离代码中的逻辑。
- en: In the implementation of our main application for this book, we will be using
    all the above techniques to build our core module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书主要应用的实现中，我们将使用上述所有技术来构建我们的核心模块。
- en: The next chapter will examine the implementation of the core in depth, but for
    now, we'll look at a couple of things related to its implementation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将深入探讨核心模块的实现，但到目前为止，我们将看看与其实现相关的一些事情。
- en: 'Consider the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we are using tight augmentation to add DOM-related functionality
    to the core module. We can also add functionality to the core by attaching a sub-module
    to it, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用紧密增强向核心模块添加与DOM相关的功能。我们也可以通过附加一个子模块来向核心模块添加功能，如下所示：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we are augmenting the core module by attaching a self-contained
    sub-module, which is added as a new property to the core module object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们通过附加一个自包含的子模块来增强核心模块，这个子模块被添加为核心模块对象的新属性。
- en: Augmenting the core module using sub-modules, is similar to building a play
    house using Lego blocks as separate pieces are attached together to create the
    whole structure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子模块增强核心模块，类似于使用乐高积木构建一个玩具屋，因为单独的积木被连接在一起以创建整个结构。
- en: This would mean that not only the application main pieces (such as components
    and sandbox) are built as modules, but also the core module itself is built based
    on smaller modules.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着不仅应用程序的主要部分（如组件和沙盒）作为模块构建，而且核心模块本身也是基于较小的模块构建的。
- en: This allows us to easily extend our core module while providing us with the
    ability to remove or replace each sub-module without affecting the other pieces
    of the core module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够轻松扩展我们的核心模块，同时提供移除或替换每个子模块的能力，而不会影响核心模块的其他部分。
- en: 'We will examine this modular implementation of the core module quite a bit
    further, when we''ll have a look under the hood in the next chapter. Have a look
    at the following image to see all the pieces of the core module in our final application.
    This image depicts how the core module consists of separate self-contained sub-modules:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在下一章深入查看内部结构时，我们将更详细地检查核心模块的这种模块化实现。看看以下图片，以了解我们最终应用程序中核心模块的所有部分。这张图片描述了核心模块由独立的自包含子模块组成：
- en: '![Core module construction approach](img/B04910_07_03.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![核心模块构建方法](img/B04910_07_03.jpg)'
- en: Of course, at the time of deployment, we can combine and minify all of these
    files (sub-modules) into one file but during development, this separation of sub-modules
    provides a good visual representation of all the pieces of the core module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在部署时，我们可以将这些文件（子模块）合并并压缩成一个文件，但在开发过程中，这种子模块的分离提供了一个很好的核心模块各个部分的视觉表示。
- en: Now that we have had a good overview of how the core module is built, let's
    examine the functionality that this module provides for us.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对核心模块的构建有了很好的概述，让我们来检查这个模块为我们提供的功能。
- en: Core module functionality
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心模块功能
- en: Core module plays different vital roles in our application, and provides essential
    services for all the other modules. It is important to note that while the core
    module consists of many pieces itself, it acts as a uniform and cohesive piece
    while providing the following functionality for the application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块在我们的应用程序中扮演着不同的关键角色，并为所有其他模块提供基本服务。重要的是要注意，尽管核心模块本身由许多部分组成，但在提供以下功能时，它作为一个统一和紧密的整体发挥作用。
- en: Acting as the controller
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为控制器
- en: The core module provides application-level functionality for all the components
    in the application. For instance, event binding and unbinding happen in the core
    module and the components only need to ask the core to take care of this task
    for them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块为应用中的所有组件提供应用级别的功能。例如，事件绑定和解除绑定发生在核心模块中，组件只需要请求核心处理这些任务即可。
- en: 'Consider the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is implemented in the core module and all the components in the application
    call this method (through their instance of the sandbox module) to bind an event
    handler to an element.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在核心模块中实现，应用程序中的所有组件都通过其沙盒模块的实例调用此方法来将事件处理器绑定到元素上。
- en: Another example can be when a component would need to make an **AJAX** call
    to the server. It is the core module that would make the call instead to the server
    and would return the result to the component and/or would take an action based
    on the result returned, such as logging an error when the AJAX call fails.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可以是当组件需要向服务器发起一个**AJAX**调用时。这是核心模块，它会代替组件向服务器发起调用，并将结果返回给组件，或者根据返回的结果采取行动，例如在AJAX调用失败时记录错误。
- en: We can also mention **cookie** and **local storage**-related functionality in
    the application as some of the other application-level functionality the core
    provides to all the registered components.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以提及与应用程序相关的**cookie**和**本地存储**功能，作为核心提供给所有注册组件的其他应用程序级功能之一。
- en: Keep in mind that the implementation should be designed in a way that component-specific
    functionality that only the component cares about should happen at the component
    level and that the application-level functionality should take place at the core
    module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，实现应该设计成组件特定的功能，只有组件关心，应该在组件级别发生，而应用程序级的功能应该在核心模块中实现。
- en: Each component, in a sense, implements its own MVC or MV* design at the component
    level, which is separate from the application-level implementation. This point
    will become more clear to you when we look at implementation code in the next
    chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，每个组件在其组件级别实现了自己的MVC或MV*设计，这与应用程序级实现是分开的。这一点将在我们查看下一章的实现代码时变得更加清晰。
- en: Providing communication bridges
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供通信桥梁
- en: As you may recall, one of the main goals of our modular architecture was to
    provide loose coupling among our components. This means that none of the components
    in our application knows about any other component, nor are they dependent on
    any other component.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所忆，我们模块化架构的主要目标之一是提供组件之间的松散耦合。这意味着我们应用程序中的任何组件都不知道任何其他组件，也不依赖于任何其他组件。
- en: However, there are times when components need to communicate with each other,
    or an event or action in one component should cause a change in another component,
    while the components have no knowledge of each other.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时组件需要相互通信，或者一个组件中的事件或动作应该导致另一个组件发生变化，而组件之间却没有任何了解。
- en: To provide such functionality the core implements a variation to the observer
    pattern called the **mediator pattern**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这样的功能，核心实现了一个观察者模式的变体，称为**中介者模式**。
- en: Using the mediator pattern, our application's components can register for and
    publish events. However, this is done through an abstraction layer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中介者模式，我们应用程序的组件可以通过抽象层注册和发布事件。
- en: 'The following is a depiction of how the mediator pattern is implemented:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何实现中介者模式的描述：
- en: '![Providing communication bridges](img/B04910_07_08.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![提供通信桥梁](img/B04910_07_08.jpg)'
- en: The core module in our application acts as the mediator, which enables the components
    (modules) for subscribe to and publish events without knowing about each other,
    thus still adhering to the principle of loose coupling among our components and
    modules.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的核心模块充当中介者，它使组件（模块）能够订阅和发布事件，而无需了解彼此，从而仍然遵循组件和模块之间松散耦合的原则。
- en: 'Consider the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the footer component in our application is publishing a custom event,
    `support-Clicked,` through its instance of the sandbox module. Beyond that, it
    has no idea what other pieces of the application could be listening for this event
    and what actions they would take based on this event.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应用程序的页脚组件通过其沙盒模块的实例发布了一个自定义事件，`support-Clicked`。除此之外，它并不知道应用程序的其他部分可能正在监听此事件，以及它们将根据此事件采取什么行动。
- en: 'On the other hand, the following snippet shows that our `NotificationHandler`
    module is listening to this event and will take action when this event is published,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下代码片段显示我们的`NotificationHandler`模块正在监听此事件，并在事件发布时采取行动，如下所示：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The core module is responsible for notifying all the registered components and
    modules that a certain event has taken place if they have registered for that
    particular event.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件已注册特定事件，核心模块负责通知所有已注册的组件和模块已发生某个事件。
- en: Initializing and destroying components
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化和销毁组件
- en: In our architectural design, we can load and unload components (modules) both
    at the start-up phase of the application as well as any time after.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的架构设计中，我们可以在应用程序的启动阶段以及任何时间之后加载和卸载组件（模块）。
- en: This is pretty robust, since it allows us to load what we need when we need
    it, which helps to keep the consumption of the resources on the device to a minimum,
    as well as keeping the application very light and responsive. This could be particularly
    important for mobile devices.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当稳健，因为它允许我们在需要时加载所需的内容，这有助于将设备上的资源消耗保持在最低，同时保持应用程序非常轻便和响应。这对于移动设备尤为重要。
- en: When a component is loaded (either at application start-up or any other time),
    it first registers itself with the core module and then the core module calls
    the `init` method of the component when it needs to be initialized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被加载（无论是应用程序启动还是其他任何时间）时，它首先将自己注册到核心模块，然后核心模块在需要初始化时调用组件的`init`方法。
- en: 'Consider the following code snippet and see how this is done:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码片段，看看这是如何完成的：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see in the preceding code, each component upon loading calls the
    `registerComponent` method of the core module. Note that the core module is known
    as `ImagesInc_Core` to other application pieces.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述代码所示，每个组件在加载时都会调用核心模块的`registerComponent`方法。请注意，核心模块对其他应用程序组件被称为`ImagesInc_Core`。
- en: The component sends the ID of its container (`footerContainer` for instance)
    as well as its own ID (shown as `footer` in the preceding code) as parameters
    to the `registerComponent` method of the core module.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将其容器（例如`footerContainer`）的ID以及它自己的ID（在前面代码中显示为`footer`）作为参数发送到核心模块的`registerComponent`方法。
- en: It also sends a reference to the function that the core module needs to call
    to create an instance of the component. This function is then called by the core
    module with an instance of the sandbox module, which is an interface for the component
    to use for interacting with the application from this point forward.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它还发送一个引用到核心模块需要调用的函数，以创建组件的实例。然后，核心模块使用沙盒模块的实例调用此函数，沙盒模块是组件用于从此点开始与应用程序交互的接口。
- en: 'Here is how registration of the component is done in the core module:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是核心模块中组件注册的方式：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the core module first checks to see if the component has the
    required methods, `init` and `destroy`, and if so, the creator function (`createFunc`)
    on the component is called to create an instance of the component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，核心模块首先检查组件是否具有所需的方法，即`init`和`destroy`，如果是这样，则调用组件上的创建函数（`createFunc`）以创建组件的实例。
- en: You can think of this phase as the hand-shake phase between the component and
    the core module specifically, as well as the hand-shake of the component with
    the application as a whole.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个阶段视为组件与核心模块之间的握手阶段，以及组件与应用程序整体的握手。
- en: As mentioned, the component is also required to have a destroy method, which
    allows the core module to either disable the component for event handling and/or
    to completely remove the component from the application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，组件还需要有一个销毁方法，这允许核心模块禁用组件以处理事件，或者完全从应用程序中移除组件。
- en: 'At the start-up phase of application, the core module goes through all the
    registered components and calls the `init` method on all of them, as shown:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的启动阶段，核心模块遍历所有已注册的组件，并在它们上调用`init`方法，如下所示：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We use a similar approach to destroy (remove) all the registered components
    from the application, as shown:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类似的方法来销毁（移除）应用程序中注册的所有组件，如下所示：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will look at the details of these operations in the next chapter and will
    examine the code more closely then. The takeaway here is that the core module
    handles the initialization and destruction of all the components in the application,
    either as a collection or on individual basis.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中查看这些操作的细节，并将更详细地检查代码。这里的要点是核心模块处理应用程序中所有组件的初始化和销毁，无论是作为一个集合还是个别处理。
- en: Providing plug-and-play capability
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供即插即用功能
- en: As we mentioned previously, components can be loaded and added to the application
    at any time while the application is loaded in the browser.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，组件可以在浏览器加载应用程序的任何时候被加载和添加到应用程序中。
- en: Let's have a look at how a component is loaded dynamically and how it becomes
    part of the application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看组件是如何动态加载的，以及它是如何成为应用程序的一部分的。
- en: Dynamic loading of the components is done by leveraging a mechanism which first
    checks to see if the component is already loaded in the cache, and if not, finding
    its object definition in either the local storage or in the `PageDefinitions.js`
    file and then subsequently loading it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的动态加载是通过利用一种机制来完成的，该机制首先检查组件是否已经加载到缓存中，如果没有，则在本地存储或`PageDefinitions.js`文件中查找其对象定义，然后随后加载它。
- en: The `PageDefinitions.js` is the file that holds object definitions (as JavaScript
    objects) for all the components that can be loaded dynamically in the application,
    at any time other than the start-up phase.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageDefinitions.js` 是一个文件，它保存了所有可以在应用程序中动态加载的组件的对象定义（作为JavaScript对象），除了启动阶段以外的任何时间。'
- en: We can also keep resource (asset) information related to any component in this
    file if we desire to do so. Generally speaking, this file is mostly used to find
    the location of our dynamic assets.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们也可以在这个文件中保存与任何组件相关的资源（资产）信息。一般来说，这个文件主要用于查找我们的动态资产的位置。
- en: For instance, in our application, we will be keeping information related to
    the `Favorites` page and the location of its `CSS` file in `PageDefinitions.js`.
    This information will be consumed by the content component when the user navigates
    to this page.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的应用程序中，我们将保留与“收藏”页面及其`CSS`文件位置相关的信息在`PageDefinitions.js`中。当用户导航到该页面时，内容组件将使用这些信息。
- en: 'Have a look at the following diagram to see an overview of the dynamic component-loading
    mechanism in our application:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下图表，以了解我们应用程序中动态组件加载机制的概述：
- en: '![Providing plug-and-play capability](img/B04910_07_04.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![提供即插即用功能](img/B04910_07_04.jpg)'
- en: As the flow diagram shows, when there is a need for a component to be rendered
    dynamically in the application, the core module checks to see if the component
    object is already present in the cache.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如流程图所示，当需要将组件动态渲染到应用程序中时，核心模块会检查组件对象是否已经存在于缓存中。
- en: If the component object is already present in the cache, then there is no need
    to do anything else but to render its view.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件对象已经存在于缓存中，那么除了渲染其视图之外，就没有其他需要做的事情了。
- en: On the other hand, if the component object is not present, the core module looks
    for the component's object definition in the local storage first. This object
    definition has a property that holds the location (path) of the component's JavaScript
    file on the server.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果组件对象不存在，核心模块首先会在本地存储中查找组件的对象定义。这个对象定义有一个属性，它保存了组件的JavaScript文件在服务器上的位置（路径）。
- en: Note that we are using the local storage as the primary storage facility for
    such object definitions as opposed to keeping them in the cache. This is purely
    to keep the footprint of the application as small as possible in the browser.
    Usage of the local storage is especially important if we have quite a few object
    definitions for the components, since such, definitions could get quite large
    and consume a considerable amount of memory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用本地存储作为此类对象定义的主要存储设施，而不是将它们保存在缓存中。这纯粹是为了使应用程序在浏览器中的占用空间尽可能小。如果有很多对象定义，使用本地存储尤为重要，因为这些定义可能会变得相当大，并消耗相当多的内存。
- en: Admittedly, in our application there is no real need to use local storage, since
    we have only one dynamically loading component. But I'm using the local storage
    to show you how it can be leveraged if you decide to use this mechanism in your
    future applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，在我们的应用程序中，我们没有真正使用本地存储的需要，因为我们只有一个动态加载的组件。但我使用本地存储来向您展示，如果您决定在未来应用程序中使用这种机制，它将如何被利用。
- en: The important point is that when the core finds the location of the component's
    file, it will make a request to the server for the `.js` (and possibly `.css`)
    file(s) of the component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当核心找到组件文件的地址时，它将向服务器请求组件的`.js`（以及可能的`.css`）文件。
- en: Once the required `.js` file for the component is loaded and parsed, then the
    component registers itself with the core and, as with any other component in the
    application, it is given an instance of the sandbox module.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载并解析了组件所需的`.js`文件，组件就会将自己注册到核心模块，并且，就像应用程序中的任何其他组件一样，它会被赋予一个沙盒模块的实例。
- en: As you can imagine, this approach provides us with a very robust way to dynamically
    load and activate our application's components, which essentially encompasses
    the plug-and-play capabilities of the application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这种方法为我们提供了一种非常稳健的方式来动态加载和激活应用程序的组件，这本质上包括了应用程序的即插即用功能。
- en: The mechanism is a bit more involved than what is explained here, but this brief
    description should provide a good overview of how things work behind the scenes.
    In the next chapter, we will have a closer look at the implementation of this
    mechanism and I'm sure all the details will become more clear to you in that chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制比这里所解释的要复杂一些，但这个简短的描述应该能提供一个关于幕后工作原理的良好概述。在下一章中，我们将更详细地探讨这个机制的实现，我相信在那个章节中所有细节都会对您更加清晰。
- en: Providing a centralized approach to handling errors
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供集中处理错误的方法
- en: The core module implements a centralized approach to logging all types of messages.
    This frees the application modules and components from implementing such functionality
    themselves. It also provides enhanced capabilities for the logging mechanism that
    all components can leverage in a uniform way.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块实现了一种集中记录所有类型消息的方法。这使应用程序模块和组件免于自己实现此类功能。它还提供了所有组件都可以以统一方式利用的日志记录机制增强功能。
- en: Note that any future enhancements that we may make to our logging mechanism
    will be done in one place and will be available to all the modules at the same
    time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可能对日志记录机制进行的任何未来增强都将在一个地方完成，并且将同时提供给所有模块。
- en: For instance, imagine that we would like all the error messages in the application
    to be logged on the server. This could mean that for each error, an AJAX call
    needs to be made from the client to the server with the related information.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们希望将应用程序中的所有错误消息都记录在服务器上。这可能意味着对于每个错误，客户端都需要向服务器发起一个带有相关信息的AJAX调用。
- en: If each module wanted to do that task itself, we would have to implement such
    functionality for each module separately. Of course, it makes more sense to implement
    this functionality once and then provide it to all of the application modules
    in a cohesive manner.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个模块都想自己完成这项任务，我们就必须为每个模块单独实现这样的功能。当然，一次性实现这种功能，然后以统一的方式提供给所有应用程序模块，这样做更有意义。
- en: 'Have a look at the following screenshot, which displays our application messages
    being logged in the Chrome debugger tool when the application is in the debug
    mode:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下截图，它显示了在调试模式下应用程序消息在Chrome调试工具中的记录情况：
- en: '![Providing a centralized approach to handling errors](img/B04910_07_05.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![提供集中处理错误的方法](img/B04910_07_05.jpg)'
- en: As you can see, when the application is loaded, all the modules as well as all
    the components in the application are initialized and the related messages are
    displayed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当应用程序加载时，所有模块以及应用程序中的所有组件都会被初始化，并且会显示相关的消息。
- en: All that the components need to do is call the sandbox module with the message,
    and the sandbox module in turn will send the message to the core module. In the
    case of other core modules, they can directly use the core module's logging mechanism.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件需要做的只是调用沙盒模块并传递消息，然后沙盒模块会依次将消息发送到核心模块。对于其他核心模块，它们可以直接使用核心模块的日志记录机制。
- en: 'Here is a code snippet which shows how the footer component logs its initialization
    message using the core module''s logging mechanism:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码片段，展示了页脚组件如何使用核心模块的日志记录机制记录其初始化消息：
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To log an error message, the footer component only needs to do the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要记录错误消息，页脚组件只需执行以下操作：
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a much simpler and better approach than the footer component implementing
    its own error-handling mechanism.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这比页脚组件实现自己的错误处理机制要简单得多。
- en: If we decide to send all the error messages to the server, the module, will
    still make the same call to the sandbox module and in turn to the core module.
    It will be the core module that will be responsible for sending the error message
    to the server.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定将所有错误消息发送到服务器，模块仍然会调用沙盒模块，然后是核心模块。将负责将错误消息发送到服务器的将是核心模块。
- en: The following code snippet shows how one of the core sub-modules sends its initialization
    message to the core module. This is similar to how the components log their message
    but with one difference.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何一个核心子模块向核心模块发送其初始化消息。这与组件记录消息的方式类似，但有一个区别。
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The difference is that the sub-module directly sends its message to the core
    module and not through a sandbox module instance. This is, of course, because
    the sub-module is part of the core module and does not have an instance of the
    sandbox module.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于子模块直接将其消息发送到核心模块，而不是通过沙盒模块实例。这当然是因为子模块是核心模块的一部分，并且没有沙盒模块的实例。
- en: 'Also, the sandbox module itself uses the same logging facility provided by
    the core module to log its errors, as shown:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，沙盒模块本身也使用核心模块提供的相同日志设施来记录其错误，如下所示：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following image shows how the error message is displayed in the debugger:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了错误消息在调试器中的显示方式：
- en: '![Providing a centralized approach to handling errors](img/B04910_07_06.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![提供处理错误的集中方法](img/B04910_07_06.jpg)'
- en: We will have a more in-depth look at how the logging mechanism has been implemented
    in our application, and how it is designed to be a sub-module of the core module,
    in the next chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨我们的应用程序中日志机制是如何实现的，以及它是如何设计成核心模块的子模块的。
- en: Providing application-level extensibility
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供应用程序级别的可扩展性
- en: From the beginning, we designed our application based on modular architecture.
    One of the advantages that our modular architecture provides is the ability to
    easily extend our application's functionality and capabilities when needed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就基于模块化架构设计我们的应用程序。我们的模块化架构提供的一个优点是，在需要时可以轻松扩展我们应用程序的功能和能力。
- en: As you saw, the functionality of our application was enhanced using various
    techniques, such as loose augmentation, tight augmentation, and sub-modules.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用各种技术增强了应用程序的功能，例如松散增强、紧密增强和子模块。
- en: While our application might provide quite a bit of functionality, it is a reasonable
    to assume that more features and capabilities will be needed in the future.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的应用程序可能提供了相当多的功能，但合理地假设未来还需要更多的功能和能力。
- en: For instance, imagine that one or more of our future components need to do form
    field validation. This functionality can be easily added to our application by
    extending the core module and then providing the functionality to our components.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的一个或多个未来组件需要进行表单字段验证。通过扩展核心模块并提供功能给我们的组件，可以轻松地将此功能添加到我们的应用程序中。
- en: The core module can provide form field validation by either importing a validation
    library through the base module or by implementing the functionality itself. This
    new functionality will then be provided to all the registered components through
    the sandbox module and all the components can use it as needed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块可以通过导入基础模块中的验证库或自行实现功能来提供表单字段验证。然后，通过沙盒模块将此新功能提供给所有已注册的组件，所有组件都可以根据需要使用它。
- en: In fact, our components would not even know who has provided this new functionality
    and how it works behind the scenes. All they need to know is that the functionality
    is available to them and they can use it to accomplish their validation tasks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们的组件甚至不知道谁提供了这项新功能以及它是如何幕后工作的。他们需要知道的是，这项功能对他们来说是可用的，并且他们可以使用它来完成他们的验证任务。
- en: Being able to provide application-level extensibility is one of the key features
    of our modular design and one of the most important tasks that the core module
    is responsible for.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 能够提供应用程序级别的可扩展性是我们模块化设计的关键特性之一，也是核心模块负责的最重要任务之一。
- en: Leveraging third party libraries
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用第三方库
- en: We briefly talked about this responsibility of the core module before. As mentioned,
    the core module is designed to ask for third party libraries from the base module.
    These libraries are used by the core module to provide application-level functionality
    for other pieces of the application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前简要地讨论了核心模块的这项职责。正如所述，核心模块被设计成从基础模块请求第三方库。这些库被核心模块用于为应用程序的其他部分提供应用程序级别的功能。
- en: The import of such libraries usually happens at the application start-up time,
    but it does not have to.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的库导入通常发生在应用程序启动时间，但并不一定如此。
- en: As you saw previously in this chapter, our application does have the capability
    to load files dynamically from the server. It is quite possible that while the
    application is running, based on certain application needs or certain user interactions
    with the application, we need to load a third party library dynamically.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章前面所看到的，我们的应用程序确实具有从服务器动态加载文件的能力。完全有可能在应用程序运行期间，基于某些应用程序需求或用户与应用程序的交互，我们需要动态地加载第三方库。
- en: Most of the time, we would use the dynamic loading of a third party library
    when the library is not needed for most of the functionality of our application.
    This allows us to keep the foot print of our application small, which is an important
    consideration on mobile devices.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当第三方库对于应用程序的大部分功能不是必需的时候，我们会使用第三方库的动态加载。这允许我们保持应用程序的足迹小，这在移动设备上是一个重要的考虑因素。
- en: In the application for this book, we do not use such dynamic loading of third
    party libraries. However, if at any point in the future you decide to leverage
    this capability, all the hooks are available for it in the code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的应用程序中，我们并不使用这种第三方库的动态加载。然而，如果在未来的某个时刻你决定利用这一功能，代码中已经提供了所有相关的钩子。
- en: Let's have a look at how the core module uses the base module to import the
    jQuery library into our application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看核心模块是如何使用基础模块将 jQuery 库导入到我们的应用程序中的。
- en: 'Consider the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code snippet, during the start-up phase of the application,
    our core module (`MainCore` module of the core module) asks the base module for
    jQuery.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，在应用程序的启动阶段，我们的核心模块（核心模块的`MainCore`模块）向基础模块请求 jQuery。
- en: 'This is done as shown here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像下面这样：
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we have wrapped this call in a try/catch statement to capture any
    errors that could happen during this operation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经在这个调用中包裹了 try/catch 语句，以捕获在此操作过程中可能发生的任何错误。
- en: Let's also have a look at how the base module provides a reference for jQuery
    to the core module.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看基础模块是如何为 jQuery 提供对核心模块的引用的。
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, since jQuery loads as a global object in the application, the
    base module simply returns a reference to this global object to the core module.
    From that point forward, jQuery is used by the core module as a sub-module to
    deliver application-level functionality.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于 jQuery 在应用程序中以全局对象的形式加载，基础模块只是将这个全局对象的引用返回给核心模块。从那时起，jQuery 就被核心模块作为子模块来提供应用程序级别的功能。
- en: 'The following code snippet shows an example of how jQuery is used in the application
    to provide the required functionality:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何在应用程序中使用 jQuery 来提供所需的功能：
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just in the same way, other third party libraries can be loaded into the application
    at the start-up phase to enhance our application's functionality.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，其他第三方库也可以在启动阶段加载到应用程序中，以增强我们的应用程序功能。
- en: Note that none of the other modules or components are aware of the third party
    libraries or how they are leveraged. It is only the core module that is aware
    of such libraries, and it is the only module to provide the third party library
    functionality to other application modules and components.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其他模块或组件都不了解第三方库或它们是如何被利用的。只有核心模块了解这些库，并且它是唯一一个向其他应用程序模块和组件提供第三方库功能的模块。
- en: 'The following image shows how third party libraries can be placed in our application''s
    folder structure:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了第三方库可以放置在我们的应用程序文件夹结构中的位置：
- en: '![Leveraging third party libraries](img/B04910_07_07.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![利用第三方库](img/B04910_07_07.jpg)'
- en: Components
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: The last main piece of our application design is related to components. In this
    section, we will cover how components are built and plugged into our application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序设计的最后一部分与组件相关。在本节中，我们将介绍组件是如何构建并集成到我们的应用程序中的。
- en: Remember that we considered components as pieces of the application that have
    views. By views, I am referring to the pieces that have HTML elements associated
    with them which are rendered in the browser and the users can interact with them
    directly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将组件视为具有视图的应用程序的一部分。通过视图，我指的是与 HTML 元素相关联的部分，这些元素在浏览器中渲染，并且用户可以直接与之交互。
- en: Components can be as simple as a layover box. Such simple components can be
    rendered as part of another component or as a stand-alone component on their own.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以像覆盖框那样简单。这样的简单组件可以作为另一个组件的一部分渲染，或者作为独立的组件本身渲染。
- en: Most of the time, our components are independent modules with their own MVC
    or MV* architecture, which are attached to the application and use the facilities
    and functionality that the rest of the application provides for them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们的组件是具有自己的 MVC 或 MV* 架构的独立模块，它们附加到应用程序上，并使用应用程序为它们提供的设施和功能。
- en: In our design, we have created three main components and a widget named `NotificationWidget`.
    This widget is also a component but it is loaded and viewed based on the user's
    interaction with another component. In our application, `NotificationWidget` is
    launched when the user clicks on the **Support** link in the footer component.
    Since this widget can potentially be launched by other components too, I am tagging
    it as a widget but for all practical intents and purposes, it is also a component
    with its own MV* implementation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中，我们创建了三个主要组件和一个名为 `NotificationWidget` 的小部件。这个小部件也是一个组件，但它根据用户与另一个组件的交互来加载和查看。在我们的应用程序中，当用户点击页脚组件中的
    **支持** 链接时，`NotificationWidget` 被启动。由于这个小部件也可能由其他组件启动，因此我将其标记为小部件，但实际上，它也是一个具有自己的
    MV* 实现的组件。
- en: Components can have very sophisticated business logic implemented in their controller,
    or have a very simple controller with very little functionality.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以在其控制器中实现非常复杂的业务逻辑，或者具有非常简单的控制器，功能非常有限。
- en: In our application, the content component is an example of a component with
    a fairly involved controller logic, and the footer stands as a component with
    a relatively simple controller.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，内容组件是一个具有相当复杂的控制器逻辑的组件的例子，而页脚则是一个相对简单的控制器组件。
- en: Also remember that the only bridge or point of connection between a component
    and the rest of the application is via an instance of the sandbox which was passed
    to it when the component registered itself with the core.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，组件与应用程序其余部分之间的唯一桥梁或连接点是通过当组件将自己注册到核心时传递给它的一个沙盒实例。
- en: We previously talked about how, in our architecture, components can be loaded
    either at the start-up phase of the application or dynamically at any time after
    that. In our implementation, header, footer, and the content components are loaded
    at the start-up phase and `NotificationWidget` is loaded dynamically, when required.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了在我们的架构中，组件可以在应用程序启动阶段加载，或者在任何时候动态加载。在我们的实现中，页眉、页脚和内容组件在启动阶段加载，而 `NotificationWidget`
    在需要时动态加载。
- en: Let's have a look at one of our simpler components, the footer, and see how
    it is implemented.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的一些较简单的组件之一，即页脚，看看它是如何实现的。
- en: Components required methods
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件所需的方法
- en: In our design, there are two required methods that every component needs to
    implement in order to register and connect with the core module and the rest of
    the application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中，每个组件都需要实现两个必需的方法，以便注册并连接到核心模块和应用程序的其余部分。
- en: These two required methods are called `init` and the `destroy` methods. The
    `init` method is called by the core module to start the initialization of the
    component. On the other hand, the `destroy` method is called by the core module
    to either disable or completely remove the component from the application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个必需的方法被称为 `init` 和 `destroy` 方法。`init` 方法由核心模块调用以启动组件的初始化。另一方面，`destroy` 方法由核心模块调用，以禁用或完全从应用程序中移除组件。
- en: 'Consider the implementation below:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下实现：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, in the `init` method of the footer component, the required HTML
    string for the view is fetched from the `GlobalData` object. This object is an
    application-level object (the application model) which holds application-level
    data. The HTML string is then passed to the core module via the sandbox module
    instance.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在页脚组件的`init`方法中，用于视图的必需HTML字符串是从`GlobalData`对象中获取的。这个对象是一个应用级对象（应用模型），它包含应用级数据。然后，HTML字符串通过沙盒模块实例传递给核心模块。
- en: Note that the core module is responsible for rendering HTML elements, in this
    case the footer's view, on the page.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，核心模块负责在页面上渲染HTML元素，在这种情况下是页脚的视图。
- en: 'This is done in the following lines of code in the `init` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`init`方法的以下代码行中完成的：
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For this particular component, we call for the rendering of the view in this
    method. However, the rendering does not always have to be done in the `init` method
    of a component. For instance, for `NotificationWidget` component, the rendering
    is done in a different method which is called at some later time by the application.
    Consequently, the `init` method of `NotificationWidget` is kept very simple, as
    follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的组件，我们在该方法中调用视图的渲染。然而，渲染并不总是需要在组件的`init`方法中完成。例如，对于`NotificationWidget`组件，渲染是在稍后的时间由应用调用另一个方法来完成的。因此，`NotificationWidget`的`init`方法保持非常简单，如下所示：
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Binding events to the components elements
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将事件绑定到组件元素
- en: 'In `init` method of the footer component, we also register the HTML elements
    related to its view for handling events. This is done by calling `registerForEvents`
    method of the component. In `registerForEvents` method, the related event handler
    is bound to the `support` link, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在页脚组件的`init`方法中，我们还为其视图相关的HTML元素注册了事件处理。这是通过调用组件的`registerForEvents`方法来完成的。在`registerForEvents`方法中，相关的事件处理程序被绑定到`support`链接上，如下所示：
- en: '[PRE28]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the actual binding for the event is done in the core module.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，实际的事件绑定是在核心模块中完成的。
- en: I previously mentioned that our components are loosely coupled with the other
    pieces of the application by custom events using the mediator pattern. Let's have
    a quick look at that.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，我们的组件通过使用中介者模式通过自定义事件与应用的其他部分松散耦合。让我们快速看一下这一点。
- en: 'Consider the following code snippet:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE29]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the footer component publishes a custom event when the **Support**
    link is clicked. Then, all the other pieces of the application that have registered
    for this custom event will be notified by the core module that this event has
    occurred. We will talk about this mechanism more in the next chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当点击**支持**链接时，页脚组件会发布一个自定义事件。然后，所有注册了这个自定义事件的、应用中的其他部分将通过核心模块被通知这个事件已经发生。我们将在下一章中更详细地讨论这个机制。
- en: Component design considerations
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件设计考虑因素
- en: In this chapter, we did not examine the implementation details of the components
    too closely, as we will have a more in-depth look at them in the next chapter.
    However, I would like you to consider a few conceptual aspects of the components.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们没有对组件的实现细节进行过于深入的考察，因为我们在下一章将更详细地探讨它们。然而，我希望你考虑一下组件的一些概念性方面。
- en: First of all, all the components are loosely coupled with the application. The
    only connection between them and the rest of the application is through an instance
    of the Sandbox, which was passed to them during the registration phase.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有组件与应用都是松散耦合的。它们与整个应用之间的唯一联系是通过在注册阶段传递给它们的沙盒实例。
- en: Second, all the components are responsible for implementing their own controllers.
    The other application pieces do not get involved with the functionality, which
    is specific to an individual component.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，所有组件都负责实现它们自己的控制器。其他应用部分不涉及特定于单个组件的功能。
- en: The job of the application as a whole, and the core module in particular, is
    to create a robust ecosystem in which the components can leverage the application-level
    functionality that has been implemented. Therefore, the components do not need
    to implement such functionality themselves. This approach allows us to create
    a cohesive and loosely coupled application that can be easily maintained and extended
    as the need arises.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序整体的任务，特别是核心模块的任务，是创建一个健壮的生态系统，其中组件可以利用已经实现的应用程序级别的功能。因此，组件不需要自己实现此类功能。这种方法使我们能够创建一个统一且松散耦合的应用程序，可以轻松维护和扩展以满足需求。
- en: Note that each Component is a self-contained piece of the application and the
    core or any other pieces of the application are not aware of nor are dependent
    on the internal implementation of the Component. This means that components are
    free to decide on their own implementation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个组件都是应用程序的一个自包含部分，核心或应用程序的任何其他部分都不会意识到，也不依赖于组件的内部实现。这意味着组件可以自由决定自己的实现。
- en: In this manner, we can create a good level of separation of concerns and responsibilities
    throughout all the application pieces.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以在整个应用程序的各个部分之间创建一个良好的关注点和责任分离级别。
- en: When a component needs to modify the DOM, it should do so by leveraging the
    functionality that the core module provides. Therefore the component does not
    have to implement this functionality itself. Also, by using the core module, we
    are able to prevent other pieces of the application from accidentally causing
    any conflicts at the same DOM element level, thus preventing collisions and application-level
    issues.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件需要修改 DOM 时，它应该通过利用核心模块提供的功能来完成。因此，组件不需要自己实现此功能。此外，通过使用核心模块，我们能够防止应用程序的其他部分意外地在同一
    DOM 元素级别上造成冲突，从而防止碰撞和应用级别问题。
- en: The proper approach in most cases is that components only modify the DOM elements
    (through the core module) in their own container and not beyond that.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，合适的做法是组件只通过核心模块修改它们自己的容器中的 DOM 元素（而不是超出那个范围）。
- en: Application architectural considerations
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构考虑事项
- en: 'Let''s review the important points that we have discussed about our modular
    architecture in this chapter and see how they relate to various pieces of our
    application, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章中关于我们模块化架构的重要观点，并看看它们如何与我们的应用程序的各个部分相关，如下所示：
- en: All third party libraries are imported into the application through the base
    module
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有第三方库都通过基础模块导入到应用程序中
- en: The core module and the base module are the only pieces of the application that
    know about the loaded third party libraries
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心模块和基础模块是唯一知道已加载第三方库的应用程序部分
- en: All browser compatibility issues are dealt with in the core module by leveraging
    the functionality of the third party libraries
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有浏览器兼容性问题都通过利用第三方库的功能在核心模块中处理
- en: Every component in the application gets an instance of the sandbox module
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的每个组件都会获得一个沙盒模块的实例
- en: The sandbox only knows about the core and no other pieces of the application
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙盒只知道核心，不知道应用程序的其他部分
- en: No pieces of the application know about the internal implementation of other
    pieces
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的各个部分之间不知道其他部分的内部实现
- en: Components can be added, modified, or removed from the application without affecting
    the application as a whole
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在不影响整个应用程序的情况下向应用程序中添加、修改或删除组件
- en: Components can only call their own methods and the methods provided to them
    through their instance of the sandbox module
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件只能调用它们自己的方法和通过它们的沙盒模块实例提供的它们的方法
- en: Components cannot access DOM elements outside of their own container
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件无法访问其自身容器之外的 DOM 元素
- en: Components should not create global objects
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件不应创建全局对象
- en: Each module and component only does limited tasks and only things which are
    directly related to its own functionality
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块和组件只执行有限的任务，并且只与其自身功能直接相关的事情
- en: All the components in the application are loosely coupled with the rest of the
    application
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的所有组件都与应用程序的其他部分松散耦合
- en: Components can only communicate with other components and other pieces of the
    application using a publish-subscribe model (the mediator pattern) and their sandbox
    instance, thus preserving the loose coupling architecture
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件只能通过发布-订阅模型（中介者模式）和它们的沙盒实例与其他组件和应用程序的其他部分进行通信，从而保持松散耦合架构
- en: Each component has a very limited understanding of the application, and that
    is through the instance of the sandbox module which was assigned to it during
    the registration phase of the component with the application
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件对应用的理解非常有限，这是通过在组件注册阶段分配给它的沙盒模块实例实现的
- en: 'The following can be considered as the advantages that modular architecture
    provides for us:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下可以被认为是模块化架构为我们提供的优势：
- en: Once the modular architecture ecosystem has been developed, it can be used for
    many applications; therefore, we can code once and use many times
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦模块化架构生态系统被开发出来，它可以用于许多应用；因此，我们可以一次编码，多次使用
- en: Each piece of the application can be tested separately
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用中的每一部分都可以单独进行测试
- en: Each piece of the application can be implemented by different people in a modularized
    fashion
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用中的每一部分都可以由不同的人以模块化的方式实现
- en: Third party external dependencies can be controlled and managed by the core
    module
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方外部依赖可以通过核心模块进行控制和管理工作
- en: Modules and components can be replaced, modified, or removed without affecting
    the application as a whole
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和组件可以被替换、修改或删除，而不会影响整个应用
- en: Components and modules can be loaded dynamically and as needed after the application
    start-up phase
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和模块可以在应用启动阶段之后根据需要动态加载
- en: I hope you view the points above as important takeaways from this chapter and
    will keep them in mind as we move forward to a more in-depth look at the application's
    implementation in the next chapter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您将上述观点视为本章的重要收获，并在我们深入探讨下一章中应用实现时牢记在心。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As was noted in the beginning of this chapter, we had a good overview of the
    architectural concepts related to the modular implementation of our application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所提到的，我们对与我们的应用模块化实现相关的架构概念有了很好的概述。
- en: We discussed the main pieces of the application and saw how they come together
    to create a cohesive ecosystem.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了应用的主要组成部分，并看到了它们如何组合在一起形成一个统一的生态系统。
- en: We also examined the specific roles that the pieces play in the overall application
    design and looked at how we can create a good separation of responsibilities and
    concerns among our modules and components.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考察了各个组件在整体应用设计中的具体角色，并研究了我们如何在模块和组件之间创建良好的职责和关注点分离。
- en: One of the important aspects that we focused on was to loosely couple our various
    application pieces together, which allows for ease of maintainability as well
    as future extensibility.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的一个重要方面是将我们的各种应用组件松散地耦合在一起，这既便于维护，也便于未来的扩展。
- en: While some application code was shown in the chapter, we did not get deeply
    involved in analyzing the code and the application implementation. This is exactly
    what we will cover in the next chapter, where we will have a closer look at how
    things are done under the hood.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章展示了部分应用代码，但我们并没有深入分析代码和应用实现。这正是我们将在下一章中涵盖的内容，我们将更详细地了解幕后是如何操作的。
