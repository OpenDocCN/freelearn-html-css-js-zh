- en: Chapter 7. Base, Sandbox, and Core Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have mostly looked at different techniques for creating
    and enhancing modules. However, our focus has been on the smaller pieces of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a holistic view of our application as
    a complete functioning body. We will see how its various pieces can be put together
    to create a robust and flexible ecosystem to deliver our ultimate goal, which
    is a working **Single-Page Application** (**SPA**).
  prefs: []
  type: TYPE_NORMAL
- en: As you read through different sections of this chapter, keep in mind that all
    the pieces of the application are designed to work together in concert, while
    still adhering to the principles of maintainability and extensibility of a modular
    design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Base module and its design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandbox and the principles behind sandboxing of our components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core and its related modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components and how they are added to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plug-and-play, progressive enhancement, and graceful degradation in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we will not get too deep into the coding aspect of things here, since
    I would really like you to focus on the architecture of the application, as opposed
    to being distracted with the details of the implementation. As such, there is
    no project code associated with this chapter of the book.
  prefs: []
  type: TYPE_NORMAL
- en: I should also mention that the architectural design concepts discussed in this
    chapter, and the next, are based on the design principles that I was originally
    introduced to by *Nicholas C. Zakas*, after watching one of his talks on the subject.
    He is one of my favorite authors and speakers. While our implementation will slightly
    deviate from his, the essence of our architecture will remain similar to his proposed
    architectural design.
  prefs: []
  type: TYPE_NORMAL
- en: Application architecture overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a truly modular design for our application, we need to break it down
    into smaller functional pieces, in such a way that each piece will specialize
    in and be responsible for very specific tasks. This enables us to achieve the
    principle of separation of concerns and responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides a depiction of our overall application design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application architecture overview](img/B04910_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, our application consists of four main pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: Base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, each main piece may consist of other smaller pieces which
    are packaged together to create the main piece.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by exploring each main piece of the application and looking at the
    specific functionality that each piece provides.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes in this book, from this point forward, when I talk about **components**,
    I'll be referring to modules that have user interface pieces (views) which the
    user is able to interact with, such as the header component. However, when I refer
    to **modules** I will be referring to functional modules that each main piece
    may consist of, which do not have any views associated with them directly.
  prefs: []
  type: TYPE_NORMAL
- en: The definitions will become more clear as we move along but you may decide to
    refer to such pieces differently in your own projects. This is fine, as long as
    the architectural concepts behind them remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Also, from time to time, I will be referring to our modular design architecture
    as a **framework,** which should be interpreted as all the various pieces of the
    application together as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**About the term framework**'
  prefs: []
  type: TYPE_NORMAL
- en: While I will be using the term framework at times, our application is not meant
    to create what is generally known as a framework. At least not in the same capacity
    that the term is used to refer to frameworks in the likes of **AngularJS** or
    **React**.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, I think sometimes third-party frameworks are overused and
    while they all provide some pros, there are also cons associated with using any
    type of third party framework.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this book is to show you how you can create your own architectural
    design which allows you to easily create, organize, and maintain your application's
    code base without the need for a third party framework.
  prefs: []
  type: TYPE_NORMAL
- en: As such, I would like you to look at our implementation as an architectural
    design concept as opposed to a framework. But if you insist, you can call what
    we design and create here an **ironic framework**. I say ironic, because it is
    really not a framework in the traditional sense, as it does not impose a special
    syntax or a slew of rules and regulations!
  prefs: []
  type: TYPE_NORMAL
- en: The best way to describe our implementation is perhaps by using the term **Client-side
    Modular Design** (**CMD**), since the goal of this architectural approach is to
    create a solid foundation and a flexible ecosystem for our applications, as opposed
    to it being a framework.
  prefs: []
  type: TYPE_NORMAL
- en: Base module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start our exploration of the design with the base module. As the name
    implies, the base module provides the lowest level of functionality for our application.
  prefs: []
  type: TYPE_NORMAL
- en: This is where we import and leverage the functionality of third party libraries
    and utilities. These libraries can consist of jQuery, Dojo, MooTools, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea is that we can easily use the functionality provided by such libraries
    without the need to create a tight dependency between our application and the
    libraries used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider how we need to detect browser compatibility to attach
    events to our elements on the page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereras we could easily let jQuery take care of such intricacies by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are letting jQuery take care of the browser compatibility issues and
    we can focus on other, more important things in our application. Another example
    is adding animations to our elements only when jQuery is present. This approach
    allows us to implement **progressive enhancement** and **graceful degradation**
    techniques in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We can also have both of such implementations in our code. This allows us to
    have a fallback if jQuery has not been loaded properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the preceding code can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, it is best to leave low-level functionality such as browser
    compatibility issues to third party libraries and focus on providing customized
    functionality for our application in our own code.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we are talking about third party libraries and utility packages
    here and not third party frameworks, as one of the goals of our architecture is
    to eliminate, or at least minimize, the need for third party frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding general-purpose libraries to the base module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, our base module loads and provides general-purpose libraries to
    the core module of our application. This means that only the core is aware of
    what base libraries are used in the code, as well as which particular functionality
    of such libraries is being leveraged.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the design of our base module, the libraries are either loaded
    at application start-up time or dynamically at a later time. The base module passes
    a reference for each loaded and initialized library to the core module.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is only the core module that is aware of what libraries are used in
    the application and to what extend, if we ever decide to change our third party
    libraries or how they are used in the application, it is only the core module
    that is affected and no other pieces.
  prefs: []
  type: TYPE_NORMAL
- en: This means that all the other pieces and components of our application will
    continue to work as they did before, regardless of the change in the third party
    libraries. Implementing our application as such minimizes the impact of replacing
    or removing the third party libraries on the application as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: This also holds true when we import and use new libraries in order to add more
    functionality to our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a closer look at how the base module is used
    to add jQuery to our application's core module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a depiction of how third party libraries are provided to the
    core module by our application''s base module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding general-purpose libraries to the base module](img/B04910_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sandbox module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about a sandbox in our daily lives, we usually have a picture of
    a box full of sand in our minds, where we allow the kids to play and make all
    the mess they like - and hopefully only in that box.
  prefs: []
  type: TYPE_NORMAL
- en: In our modular architecture, we capitalize on the same concept and create spaces
    for our components to play in and to be isolated from other pieces of the application.
  prefs: []
  type: TYPE_NORMAL
- en: By sandboxing our modules in such a way, we eliminate tight coupling among our
    application components and the core module.
  prefs: []
  type: TYPE_NORMAL
- en: The sandbox is essentially a layer of abstraction as well as a thin interface
    between our components and the other pieces of our application.
  prefs: []
  type: TYPE_NORMAL
- en: As the sandbox module is designed to be an interface and to provide communication
    among our components and the rest of the application, it is considered a contract
    and, as such, it should never change. This is so our components can be sure that
    they can always count on a consistent layer of communication with the application
    as well as a certain level of functionality provided by the core module.
  prefs: []
  type: TYPE_NORMAL
- en: That is not to say, we cannot add new methods or functionality to the sandbox;
    it is only that we cannot change what is already there and that our components
    have come to rely on.
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox module functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our components are loaded in the application, either at application start-up
    time or dynamically any time after, they are all given an instance of the sandbox
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sandbox module provides the following for our components:'
  prefs: []
  type: TYPE_NORMAL
- en: A consistent interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of the services provided by the sandbox module is crucial to the modular
    aspect of our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore each aspect in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox as a consistent interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, when every registered component is given an instance of the sandbox
    module by the core module.
  prefs: []
  type: TYPE_NORMAL
- en: This instance of the sandbox then acts as an interface to the rest of the application,
    which provides application-level functionality for the component.
  prefs: []
  type: TYPE_NORMAL
- en: When a component needs a particular functionality, it does not necessarily need
    to implement it itself. This is true when the implementation of that functionality
    is already available in the application.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to bind event handlers to elements, each component does not need
    to provide its own implementation. Components can simply ask the sandbox module,
    which in turn, asks the core module to bind a certain event handler to a particular
    element on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the components also do not have to worry about browser compatibility
    issues related to event binding, as it is the job of the core module to take care
    of such issues.
  prefs: []
  type: TYPE_NORMAL
- en: Since the sandbox instance is identical for every registered component, we can
    be sure that any changes in the sandbox code is provided to all the components
    at the same time. This means that the addition of new functionality, bug fixes,
    and modifications in the sandbox module are done once and then propagated to all
    the components that use the sandbox module, in a uniform and cohesive manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note that any changes to the sandbox module should still honor the previous
    contract between this module and the application's components.
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox as a security layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The components in our application only know about the sandbox module and are
    not allowed (or able) to directly communicate with any other pieces of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the sandbox makes sure that protected areas of the framework
    are not accessible by the components through its interface. This enables us to
    control the type of operations that the components are permitted to perform, within
    the context of the core and other modules of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox as a communication layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the sandbox module is a thin layer of interface which provides the exposed
    interface of the core module to the components, it is the only route of communication
    between the components and the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: It is also through the sandbox module that components can subscribe to and publish
    custom events in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is important for the components to only have one route of communication
    with the rest of the application so we can preserve the integrity of our modular
    design. If a component is able to directly communicate with another component
    or other parts of the application, then it could be tightly coupled to such pieces,
    and we certainly would like to avoid this type of tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox as a filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The design of the sandbox should be done in a way that not only will it provide
    the functionality of the core module that we want to expose to the components,
    but it can also do simple error checking for the calls made by the components
    to the core.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method has been provided to our components through the sandbox
    module. This method does a simple parameter check to make sure that the parameter,
    as well as the correct type of the parameter, has been passed to it by the component
    before the sandbox module asks the core to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: While the core module might have its own error checking, it is always a good
    idea to do some error checking at the sandbox level before getting the core module
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multiple instances of the sandbox module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering at this point, why is it a better idea to use multiple
    instances of the sandbox module (one for each component) as opposed to having
    all the components use the same sandbox object as a singleton?
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer is: better isolation and performance. We need to explore that
    answer a little further in the upcoming sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of multiple instances of the sandbox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, a module provides its exposed functionality to the outside world through
    a single common interface.
  prefs: []
  type: TYPE_NORMAL
- en: However, our implementation of the sandbox module is different. As mentioned
    previously, we create multiple instances of the sandbox module and, to be more
    precise, one instance per component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following summarizes the goals behind this design:'
  prefs: []
  type: TYPE_NORMAL
- en: Isolating sandbox instances from each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a code execution context for each component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolating the sandbox instances from each other
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In our analogy of a kid playing in a sandbox, I mentioned that this type of
    isolation contains the possible mess created in the box. In just the same way,
    we would like any possible damage to a sandbox module instance to be contained
    and isolated.
  prefs: []
  type: TYPE_NORMAL
- en: This would mean that, if one of our components does something undesirable which
    could cause issues in its sandbox instance, such a mess would be contained within
    that sandbox module instance. The adverse effects will only impact the functionality
    of that component but no other sandbox instances, or any other components for
    that matter.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important for us to design our architecture in such a way which minimizes
    the chances of complete application failure caused by an issue in one of the components.
  prefs: []
  type: TYPE_NORMAL
- en: This allows for at least partial functionality of our application, which is
    probably a much more acceptable outcome than a complete application failure.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the footer component in our application may stop working but the
    user can still view the catalog of our images and add them to the favorites list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a code execution context
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a sandbox module is created, it sets a context object for its component.
    Components can use this context object to easily refer to the correct execution
    context when needed. This is probably better understood if we look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet from our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The function above is implemented in the content component of our application.
    Inside this function, which is the click event handler for some of the elements
    on the page, we need to call other related functions in the content component.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily do that by using the execution context that we set on the sandbox
    instance for this component when we first initialize the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code snippet, `this` refers to the content component of our application.
    Thus, when we need to execute any functions in the context of our content component,
    we can just refer to the correct context, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If this does not make a lot of sense to you right now, do not be alarmed. I
    will explain this further in the next chapter where we'll have a chance to look
    at it's full implementation in the code.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the only thing that you need to keep in mind is that we can use each
    instance of the sandbox module to preserve a reference to the component that the
    sandbox instance belongs to. This allows us to easily access the execution context
    of that component.
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we create an instance of the sandbox for each component, we also assign
    a reference on the sandbox instance to the DOM element in which the component's
    view resides. This allows us to make our DOM manipulation within that container
    a lot more efficiently, since we do not need to traverse the whole DOM tree to
    find the DOM element of interest within the container of the component's view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we are trying to find a child element of the container element
    where the component's view has been rendered.
  prefs: []
  type: TYPE_NORMAL
- en: When the component was registered with the core, the core created an instance
    of the sandbox and returned a reference to the component's container element with
    the sandbox instance.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, after the header component of our application is created, all
    the header-related DOM elements reside inside a main div element container that
    hosts them. The header component's sandbox instance holds a reference to this
    div container.
  prefs: []
  type: TYPE_NORMAL
- en: When the header component needs access to any DOM elements related to its view,
    it will only need to look for the desired element inside of its container div
    element as opposed to traversing the whole DOM tree to find the element.
  prefs: []
  type: TYPE_NORMAL
- en: This makes finding the desired element much quicker as we don't need to search
    the entire DOM looking for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not completely clear on how this works, we will cover it again in
    the next chapter when we examine the code in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: For now, just be mindful of the fact that the sandbox instance allows us to
    have quick and direct access to the DOM element that the component renders in,
    which in turn allows for much more optimized DOM manipulation tasks related to
    the component.
  prefs: []
  type: TYPE_NORMAL
- en: Core module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core module is really the brain of our application. It is where the application's
    heavy lifting is done and the real magic happens.
  prefs: []
  type: TYPE_NORMAL
- en: The core module is responsible for implementing application-level business logic
    as well as providing bridges among components when there is a need for components
    to communicate with each other. Of course, while still preserving the loose coupling
    nature of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The core module also leverages the functionality provided by the third party
    libraries, which are loaded by the base module, to create a cohesive functional
    application.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with the architectural design pattern known as **Module-View-Controller**
    (**MVC**), the core module is the controller piece of this design pattern in our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the role of core module as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Acting as the controller for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing communication bridges among modularized components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing and destroying components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing plug-and-play capability for the components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a centralized method of handling errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing application-level extensibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging third party libraries' functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will examine all these aspects very shortly but before doing so, let's talk
    about how the core is constructed in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Core module construction approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different approaches to building the core module, but one of the best
    approaches is to build it in a modularized fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We can start the implementation by building a main core module and then augment
    it using techniques such as loose and tight augmentation, which we have already
    covered in this book. However, adding most of the functionality to the core module
    using sub-modules allows for a better separation of the logic in the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of our main application for this book, we will be using
    all the above techniques to build our core module.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will examine the implementation of the core in depth, but for
    now, we'll look at a couple of things related to its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are using tight augmentation to add DOM-related functionality
    to the core module. We can also add functionality to the core by attaching a sub-module
    to it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are augmenting the core module by attaching a self-contained
    sub-module, which is added as a new property to the core module object.
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting the core module using sub-modules, is similar to building a play
    house using Lego blocks as separate pieces are attached together to create the
    whole structure.
  prefs: []
  type: TYPE_NORMAL
- en: This would mean that not only the application main pieces (such as components
    and sandbox) are built as modules, but also the core module itself is built based
    on smaller modules.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to easily extend our core module while providing us with the
    ability to remove or replace each sub-module without affecting the other pieces
    of the core module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will examine this modular implementation of the core module quite a bit
    further, when we''ll have a look under the hood in the next chapter. Have a look
    at the following image to see all the pieces of the core module in our final application.
    This image depicts how the core module consists of separate self-contained sub-modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Core module construction approach](img/B04910_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, at the time of deployment, we can combine and minify all of these
    files (sub-modules) into one file but during development, this separation of sub-modules
    provides a good visual representation of all the pieces of the core module.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have had a good overview of how the core module is built, let's
    examine the functionality that this module provides for us.
  prefs: []
  type: TYPE_NORMAL
- en: Core module functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Core module plays different vital roles in our application, and provides essential
    services for all the other modules. It is important to note that while the core
    module consists of many pieces itself, it acts as a uniform and cohesive piece
    while providing the following functionality for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Acting as the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core module provides application-level functionality for all the components
    in the application. For instance, event binding and unbinding happen in the core
    module and the components only need to ask the core to take care of this task
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code is implemented in the core module and all the components in the application
    call this method (through their instance of the sandbox module) to bind an event
    handler to an element.
  prefs: []
  type: TYPE_NORMAL
- en: Another example can be when a component would need to make an **AJAX** call
    to the server. It is the core module that would make the call instead to the server
    and would return the result to the component and/or would take an action based
    on the result returned, such as logging an error when the AJAX call fails.
  prefs: []
  type: TYPE_NORMAL
- en: We can also mention **cookie** and **local storage**-related functionality in
    the application as some of the other application-level functionality the core
    provides to all the registered components.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the implementation should be designed in a way that component-specific
    functionality that only the component cares about should happen at the component
    level and that the application-level functionality should take place at the core
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Each component, in a sense, implements its own MVC or MV* design at the component
    level, which is separate from the application-level implementation. This point
    will become more clear to you when we look at implementation code in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Providing communication bridges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may recall, one of the main goals of our modular architecture was to
    provide loose coupling among our components. This means that none of the components
    in our application knows about any other component, nor are they dependent on
    any other component.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are times when components need to communicate with each other,
    or an event or action in one component should cause a change in another component,
    while the components have no knowledge of each other.
  prefs: []
  type: TYPE_NORMAL
- en: To provide such functionality the core implements a variation to the observer
    pattern called the **mediator pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: Using the mediator pattern, our application's components can register for and
    publish events. However, this is done through an abstraction layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a depiction of how the mediator pattern is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing communication bridges](img/B04910_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The core module in our application acts as the mediator, which enables the components
    (modules) for subscribe to and publish events without knowing about each other,
    thus still adhering to the principle of loose coupling among our components and
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the footer component in our application is publishing a custom event,
    `support-Clicked,` through its instance of the sandbox module. Beyond that, it
    has no idea what other pieces of the application could be listening for this event
    and what actions they would take based on this event.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the following snippet shows that our `NotificationHandler`
    module is listening to this event and will take action when this event is published,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The core module is responsible for notifying all the registered components and
    modules that a certain event has taken place if they have registered for that
    particular event.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and destroying components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our architectural design, we can load and unload components (modules) both
    at the start-up phase of the application as well as any time after.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty robust, since it allows us to load what we need when we need
    it, which helps to keep the consumption of the resources on the device to a minimum,
    as well as keeping the application very light and responsive. This could be particularly
    important for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: When a component is loaded (either at application start-up or any other time),
    it first registers itself with the core module and then the core module calls
    the `init` method of the component when it needs to be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet and see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, each component upon loading calls the
    `registerComponent` method of the core module. Note that the core module is known
    as `ImagesInc_Core` to other application pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The component sends the ID of its container (`footerContainer` for instance)
    as well as its own ID (shown as `footer` in the preceding code) as parameters
    to the `registerComponent` method of the core module.
  prefs: []
  type: TYPE_NORMAL
- en: It also sends a reference to the function that the core module needs to call
    to create an instance of the component. This function is then called by the core
    module with an instance of the sandbox module, which is an interface for the component
    to use for interacting with the application from this point forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how registration of the component is done in the core module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the core module first checks to see if the component has the
    required methods, `init` and `destroy`, and if so, the creator function (`createFunc`)
    on the component is called to create an instance of the component.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this phase as the hand-shake phase between the component and
    the core module specifically, as well as the hand-shake of the component with
    the application as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the component is also required to have a destroy method, which
    allows the core module to either disable the component for event handling and/or
    to completely remove the component from the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start-up phase of application, the core module goes through all the
    registered components and calls the `init` method on all of them, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a similar approach to destroy (remove) all the registered components
    from the application, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will look at the details of these operations in the next chapter and will
    examine the code more closely then. The takeaway here is that the core module
    handles the initialization and destruction of all the components in the application,
    either as a collection or on individual basis.
  prefs: []
  type: TYPE_NORMAL
- en: Providing plug-and-play capability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, components can be loaded and added to the application
    at any time while the application is loaded in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how a component is loaded dynamically and how it becomes
    part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic loading of the components is done by leveraging a mechanism which first
    checks to see if the component is already loaded in the cache, and if not, finding
    its object definition in either the local storage or in the `PageDefinitions.js`
    file and then subsequently loading it.
  prefs: []
  type: TYPE_NORMAL
- en: The `PageDefinitions.js` is the file that holds object definitions (as JavaScript
    objects) for all the components that can be loaded dynamically in the application,
    at any time other than the start-up phase.
  prefs: []
  type: TYPE_NORMAL
- en: We can also keep resource (asset) information related to any component in this
    file if we desire to do so. Generally speaking, this file is mostly used to find
    the location of our dynamic assets.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in our application, we will be keeping information related to
    the `Favorites` page and the location of its `CSS` file in `PageDefinitions.js`.
    This information will be consumed by the content component when the user navigates
    to this page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram to see an overview of the dynamic component-loading
    mechanism in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing plug-and-play capability](img/B04910_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the flow diagram shows, when there is a need for a component to be rendered
    dynamically in the application, the core module checks to see if the component
    object is already present in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: If the component object is already present in the cache, then there is no need
    to do anything else but to render its view.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the component object is not present, the core module looks
    for the component's object definition in the local storage first. This object
    definition has a property that holds the location (path) of the component's JavaScript
    file on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using the local storage as the primary storage facility for
    such object definitions as opposed to keeping them in the cache. This is purely
    to keep the footprint of the application as small as possible in the browser.
    Usage of the local storage is especially important if we have quite a few object
    definitions for the components, since such, definitions could get quite large
    and consume a considerable amount of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, in our application there is no real need to use local storage, since
    we have only one dynamically loading component. But I'm using the local storage
    to show you how it can be leveraged if you decide to use this mechanism in your
    future applications.
  prefs: []
  type: TYPE_NORMAL
- en: The important point is that when the core finds the location of the component's
    file, it will make a request to the server for the `.js` (and possibly `.css`)
    file(s) of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Once the required `.js` file for the component is loaded and parsed, then the
    component registers itself with the core and, as with any other component in the
    application, it is given an instance of the sandbox module.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, this approach provides us with a very robust way to dynamically
    load and activate our application's components, which essentially encompasses
    the plug-and-play capabilities of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism is a bit more involved than what is explained here, but this brief
    description should provide a good overview of how things work behind the scenes.
    In the next chapter, we will have a closer look at the implementation of this
    mechanism and I'm sure all the details will become more clear to you in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a centralized approach to handling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core module implements a centralized approach to logging all types of messages.
    This frees the application modules and components from implementing such functionality
    themselves. It also provides enhanced capabilities for the logging mechanism that
    all components can leverage in a uniform way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that any future enhancements that we may make to our logging mechanism
    will be done in one place and will be available to all the modules at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine that we would like all the error messages in the application
    to be logged on the server. This could mean that for each error, an AJAX call
    needs to be made from the client to the server with the related information.
  prefs: []
  type: TYPE_NORMAL
- en: If each module wanted to do that task itself, we would have to implement such
    functionality for each module separately. Of course, it makes more sense to implement
    this functionality once and then provide it to all of the application modules
    in a cohesive manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following screenshot, which displays our application messages
    being logged in the Chrome debugger tool when the application is in the debug
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing a centralized approach to handling errors](img/B04910_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when the application is loaded, all the modules as well as all
    the components in the application are initialized and the related messages are
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: All that the components need to do is call the sandbox module with the message,
    and the sandbox module in turn will send the message to the core module. In the
    case of other core modules, they can directly use the core module's logging mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code snippet which shows how the footer component logs its initialization
    message using the core module''s logging mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To log an error message, the footer component only needs to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a much simpler and better approach than the footer component implementing
    its own error-handling mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: If we decide to send all the error messages to the server, the module, will
    still make the same call to the sandbox module and in turn to the core module.
    It will be the core module that will be responsible for sending the error message
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows how one of the core sub-modules sends its initialization
    message to the core module. This is similar to how the components log their message
    but with one difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that the sub-module directly sends its message to the core
    module and not through a sandbox module instance. This is, of course, because
    the sub-module is part of the core module and does not have an instance of the
    sandbox module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the sandbox module itself uses the same logging facility provided by
    the core module to log its errors, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows how the error message is displayed in the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing a centralized approach to handling errors](img/B04910_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will have a more in-depth look at how the logging mechanism has been implemented
    in our application, and how it is designed to be a sub-module of the core module,
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Providing application-level extensibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the beginning, we designed our application based on modular architecture.
    One of the advantages that our modular architecture provides is the ability to
    easily extend our application's functionality and capabilities when needed.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw, the functionality of our application was enhanced using various
    techniques, such as loose augmentation, tight augmentation, and sub-modules.
  prefs: []
  type: TYPE_NORMAL
- en: While our application might provide quite a bit of functionality, it is a reasonable
    to assume that more features and capabilities will be needed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine that one or more of our future components need to do form
    field validation. This functionality can be easily added to our application by
    extending the core module and then providing the functionality to our components.
  prefs: []
  type: TYPE_NORMAL
- en: The core module can provide form field validation by either importing a validation
    library through the base module or by implementing the functionality itself. This
    new functionality will then be provided to all the registered components through
    the sandbox module and all the components can use it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, our components would not even know who has provided this new functionality
    and how it works behind the scenes. All they need to know is that the functionality
    is available to them and they can use it to accomplish their validation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to provide application-level extensibility is one of the key features
    of our modular design and one of the most important tasks that the core module
    is responsible for.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging third party libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly talked about this responsibility of the core module before. As mentioned,
    the core module is designed to ask for third party libraries from the base module.
    These libraries are used by the core module to provide application-level functionality
    for other pieces of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The import of such libraries usually happens at the application start-up time,
    but it does not have to.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw previously in this chapter, our application does have the capability
    to load files dynamically from the server. It is quite possible that while the
    application is running, based on certain application needs or certain user interactions
    with the application, we need to load a third party library dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we would use the dynamic loading of a third party library
    when the library is not needed for most of the functionality of our application.
    This allows us to keep the foot print of our application small, which is an important
    consideration on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the application for this book, we do not use such dynamic loading of third
    party libraries. However, if at any point in the future you decide to leverage
    this capability, all the hooks are available for it in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how the core module uses the base module to import the
    jQuery library into our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, during the start-up phase of the application,
    our core module (`MainCore` module of the core module) asks the base module for
    jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have wrapped this call in a try/catch statement to capture any
    errors that could happen during this operation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also have a look at how the base module provides a reference for jQuery
    to the core module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, since jQuery loads as a global object in the application, the
    base module simply returns a reference to this global object to the core module.
    From that point forward, jQuery is used by the core module as a sub-module to
    deliver application-level functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows an example of how jQuery is used in the application
    to provide the required functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Just in the same way, other third party libraries can be loaded into the application
    at the start-up phase to enhance our application's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note that none of the other modules or components are aware of the third party
    libraries or how they are leveraged. It is only the core module that is aware
    of such libraries, and it is the only module to provide the third party library
    functionality to other application modules and components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows how third party libraries can be placed in our application''s
    folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging third party libraries](img/B04910_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last main piece of our application design is related to components. In this
    section, we will cover how components are built and plugged into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we considered components as pieces of the application that have
    views. By views, I am referring to the pieces that have HTML elements associated
    with them which are rendered in the browser and the users can interact with them
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Components can be as simple as a layover box. Such simple components can be
    rendered as part of another component or as a stand-alone component on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, our components are independent modules with their own MVC
    or MV* architecture, which are attached to the application and use the facilities
    and functionality that the rest of the application provides for them.
  prefs: []
  type: TYPE_NORMAL
- en: In our design, we have created three main components and a widget named `NotificationWidget`.
    This widget is also a component but it is loaded and viewed based on the user's
    interaction with another component. In our application, `NotificationWidget` is
    launched when the user clicks on the **Support** link in the footer component.
    Since this widget can potentially be launched by other components too, I am tagging
    it as a widget but for all practical intents and purposes, it is also a component
    with its own MV* implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Components can have very sophisticated business logic implemented in their controller,
    or have a very simple controller with very little functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, the content component is an example of a component with
    a fairly involved controller logic, and the footer stands as a component with
    a relatively simple controller.
  prefs: []
  type: TYPE_NORMAL
- en: Also remember that the only bridge or point of connection between a component
    and the rest of the application is via an instance of the sandbox which was passed
    to it when the component registered itself with the core.
  prefs: []
  type: TYPE_NORMAL
- en: We previously talked about how, in our architecture, components can be loaded
    either at the start-up phase of the application or dynamically at any time after
    that. In our implementation, header, footer, and the content components are loaded
    at the start-up phase and `NotificationWidget` is loaded dynamically, when required.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at one of our simpler components, the footer, and see how
    it is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Components required methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our design, there are two required methods that every component needs to
    implement in order to register and connect with the core module and the rest of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: These two required methods are called `init` and the `destroy` methods. The
    `init` method is called by the core module to start the initialization of the
    component. On the other hand, the `destroy` method is called by the core module
    to either disable or completely remove the component from the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the implementation below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the `init` method of the footer component, the required HTML
    string for the view is fetched from the `GlobalData` object. This object is an
    application-level object (the application model) which holds application-level
    data. The HTML string is then passed to the core module via the sandbox module
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the core module is responsible for rendering HTML elements, in this
    case the footer's view, on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in the following lines of code in the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For this particular component, we call for the rendering of the view in this
    method. However, the rendering does not always have to be done in the `init` method
    of a component. For instance, for `NotificationWidget` component, the rendering
    is done in a different method which is called at some later time by the application.
    Consequently, the `init` method of `NotificationWidget` is kept very simple, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Binding events to the components elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `init` method of the footer component, we also register the HTML elements
    related to its view for handling events. This is done by calling `registerForEvents`
    method of the component. In `registerForEvents` method, the related event handler
    is bound to the `support` link, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the actual binding for the event is done in the core module.
  prefs: []
  type: TYPE_NORMAL
- en: I previously mentioned that our components are loosely coupled with the other
    pieces of the application by custom events using the mediator pattern. Let's have
    a quick look at that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the footer component publishes a custom event when the **Support**
    link is clicked. Then, all the other pieces of the application that have registered
    for this custom event will be notified by the core module that this event has
    occurred. We will talk about this mechanism more in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Component design considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we did not examine the implementation details of the components
    too closely, as we will have a more in-depth look at them in the next chapter.
    However, I would like you to consider a few conceptual aspects of the components.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, all the components are loosely coupled with the application. The
    only connection between them and the rest of the application is through an instance
    of the Sandbox, which was passed to them during the registration phase.
  prefs: []
  type: TYPE_NORMAL
- en: Second, all the components are responsible for implementing their own controllers.
    The other application pieces do not get involved with the functionality, which
    is specific to an individual component.
  prefs: []
  type: TYPE_NORMAL
- en: The job of the application as a whole, and the core module in particular, is
    to create a robust ecosystem in which the components can leverage the application-level
    functionality that has been implemented. Therefore, the components do not need
    to implement such functionality themselves. This approach allows us to create
    a cohesive and loosely coupled application that can be easily maintained and extended
    as the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Note that each Component is a self-contained piece of the application and the
    core or any other pieces of the application are not aware of nor are dependent
    on the internal implementation of the Component. This means that components are
    free to decide on their own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, we can create a good level of separation of concerns and responsibilities
    throughout all the application pieces.
  prefs: []
  type: TYPE_NORMAL
- en: When a component needs to modify the DOM, it should do so by leveraging the
    functionality that the core module provides. Therefore the component does not
    have to implement this functionality itself. Also, by using the core module, we
    are able to prevent other pieces of the application from accidentally causing
    any conflicts at the same DOM element level, thus preventing collisions and application-level
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: The proper approach in most cases is that components only modify the DOM elements
    (through the core module) in their own container and not beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: Application architectural considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s review the important points that we have discussed about our modular
    architecture in this chapter and see how they relate to various pieces of our
    application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All third party libraries are imported into the application through the base
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core module and the base module are the only pieces of the application that
    know about the loaded third party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All browser compatibility issues are dealt with in the core module by leveraging
    the functionality of the third party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every component in the application gets an instance of the sandbox module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sandbox only knows about the core and no other pieces of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No pieces of the application know about the internal implementation of other
    pieces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components can be added, modified, or removed from the application without affecting
    the application as a whole
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components can only call their own methods and the methods provided to them
    through their instance of the sandbox module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components cannot access DOM elements outside of their own container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components should not create global objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each module and component only does limited tasks and only things which are
    directly related to its own functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the components in the application are loosely coupled with the rest of the
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components can only communicate with other components and other pieces of the
    application using a publish-subscribe model (the mediator pattern) and their sandbox
    instance, thus preserving the loose coupling architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component has a very limited understanding of the application, and that
    is through the instance of the sandbox module which was assigned to it during
    the registration phase of the component with the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following can be considered as the advantages that modular architecture
    provides for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the modular architecture ecosystem has been developed, it can be used for
    many applications; therefore, we can code once and use many times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each piece of the application can be tested separately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each piece of the application can be implemented by different people in a modularized
    fashion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party external dependencies can be controlled and managed by the core
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and components can be replaced, modified, or removed without affecting
    the application as a whole
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components and modules can be loaded dynamically and as needed after the application
    start-up phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you view the points above as important takeaways from this chapter and
    will keep them in mind as we move forward to a more in-depth look at the application's
    implementation in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As was noted in the beginning of this chapter, we had a good overview of the
    architectural concepts related to the modular implementation of our application.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the main pieces of the application and saw how they come together
    to create a cohesive ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined the specific roles that the pieces play in the overall application
    design and looked at how we can create a good separation of responsibilities and
    concerns among our modules and components.
  prefs: []
  type: TYPE_NORMAL
- en: One of the important aspects that we focused on was to loosely couple our various
    application pieces together, which allows for ease of maintainability as well
    as future extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: While some application code was shown in the chapter, we did not get deeply
    involved in analyzing the code and the application implementation. This is exactly
    what we will cover in the next chapter, where we will have a closer look at how
    things are done under the hood.
  prefs: []
  type: TYPE_NORMAL
