["```js\n    git remote remove origin\n\n    ```", "```js\n    cd mean-blueprints-chatapp\n\n    ```", "```js\n    npm install\n\n    ```", "```js\n    cp config/environments/example.js config/environments/development.js\n\n    ```", "```js\nmodule.exports = {\n  port: 3000,\n  hostname: '127.0.0.1',\n  baseUrl: 'http://localhost:3000',\n  mongodb: {\n    uri: 'mongodb://localhost/chatapp_dev_db'\n  },\n  app: {\n    name: 'MEAN Blueprints - chat application'\n  },\n  serveStatic: true,\n  session: {\n    type: 'mongo',                     \n    secret: 'someVeRyN1c3S#cr3tHer34U',\n    resave: false,                          \n    saveUninitialized: true            \n  },\n  proxy: {\n    trust: true\n  },\n  logRequests: false  \n};\n```", "```js\nconst UserSchema = new Schema({\n  email:  {\n    type: String,\n    required: true,\n    unique: true\n  },\n  name: {\n    type: String\n  },\n  password: {\n    type: String,\n    required: true,\n    select: false\n  },\n  passwordSalt: {\n    type: String,\n    required: true,\n    select: false\n  },\n  profile: {\n    type: Mixed\n  },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n```", "```js\n'use strict';\n\nconst mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst ObjectId = Schema.ObjectId;\n\nconst ThreadSchema = new Schema({\n  participants: {\n    type: [\n      {\n        type: ObjectId,\n        ref: 'User'\n      }\n    ]\n  },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nmodule.exports = mongoose.model('Thread', ThreadSchema);\n```", "```js\n'use strict';\n\nconst mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst ObjectId = Schema.ObjectId;\n\nconst MessageSchema = new Schema({\n  sender: {\n    type: ObjectId,\n    required: true,\n    ref: 'User'\n  },\n  thread: {\n    type: ObjectId,\n    required: true,\n    ref: 'Thread'\n  },\n  body: {\n    type: String,\n    required: true\n  },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nmodule.exports = mongoose.model('Message', MessageSchema);\n```", "```js\n    'use strict';\n\n    const mongoose = require('mongoose');\n    const Thread = mongoose.model('Thread');\n    ```", "```js\n    module.exports.allByUser = allThreadsByUser;\n    module.exports.find = findThread;\n    module.exports.open = openThread;\n    module.exports.findById = findThreadById;\n    ```", "```js\n    function allThreadsByUser(req, res, next) {\n      Thread\n      .find({\n        participants: req.user._id\n      })\n      .populate('participants')\n      .exec((err, threads) => {\n        if (err) {\n          return next(err);\n        }\n\n        req.resources.threads = threads;\n        next();\n      });\n    }\n    ```", "```js\n    function findThread(req, res, next) {\n      let query = {};\n      if (req.body.userId) {\n        query.$and = [\n          { participants: req.body.userId },\n          { participants: req.user._id.toString() }\n        ];\n      }\n\n      if (req.body.participants) {\n        query.$and = req.body.participants.map(participant => {\n          return { participants: participant };\n        });\n      }\n\n      Thread\n      .findOne(query)\n      .populate('participants')\n      .exec((err, thread) => {\n        if (err) {\n          return next(err);\n        }\n\n        req.resources.thread = thread;\n        next();\n      });\n    }\n    ```", "```js\n    function openThread(req, res, next) {\n      var data = {};\n\n      //  If we have already found the thread \n      //  we don't need to create a new one\n      if (req.resources.thread) {\n        return next();\n      }\n\n      data.participants = req.body.participants || [req.user._id, req.body.user];\n\n      Thread\n      .create(data, (err, thread) => {\n        if (err) {\n          return next(err);\n        }\n\n        thread.populate('participants', (err, popThread) => {\n          if (err) {\n            return next(err);\n          }\n\n          req.resources.thread = popThread;\n          next();\n        });\n      });\n    }\n    ```", "```js\n    function findThreadById(req, res, next) {\n      Thread\n      .findById(req.params.threadId, (err, thread) => {\n        if (err) {\n          return next(err);\n        }\n\n        req.resources.thread = thread;\n        next();\n      });\n    }\n    ```", "```js\nconst express = require('express');\nconst router = express.Router();\nconst threadCtrl = require('../controllers/thread');\nconst messageCtrl = require('../controllers/message');\nconst auth = require('../middlewares/authentication');\nconst authorize = require('../middlewares/authorization');\nconst response = require('../helpers/response');\n\nmodule.exports = router;\n```", "```js\n    router.get(\n      '/threads',\n      auth.ensured,\n      threadCtrl.allByUser,\n      response.toJSON('threads')\n    );\n    ```", "```js\n    router.post(\n      '/thread/open',\n      auth.ensured,\n      threadCtrl.find,\n      threadCtrl.open,\n      response.toJSON('thread')\n    );\n    ```", "```js\n    router.get(\n      '/threads/:threadId',\n      auth.ensured,\n      threadCtrl.findById,\n      authorize.onlyParticipants('thread'),\n      response.toJSON('thread')\n    )\n    ```", "```js\n    router.get(\n      '/threads/:threadId/messages',\n      auth.ensured,\n      threadCtrl.findById,\n      authorize.onlyParticipants('thread'),\n      messageCtrl.findByThread,\n      response.toJSON('messages')\n    );\n    ```", "```js\n'use strict';\n\nconst mongoose = require('mongoose');\nconst Thread = mongoose.model('Thread');\nconst Message = mongoose.model('Message');\nconst ObjectId = mongoose.Types.ObjectId;\n\nmodule.exports.findByThread = findMessagesByThread;\n\nfunction findMessagesByThread(req, res, next) {\n  let query = {\n    thread: req.resources.thread._id\n  };\n\n  if (req.query.beforeId) {\n    query._id = { $lt: new ObjectId(req.query.sinceId) };\n  }\n\n  Message\n  .find(query)\n  .populate('sender')\n  .exec(function(err, messages) {\n    if (err) {\n      return next(err);\n    }\n\n    req.resources.messages = messages;\n    next();\n  });\n}\n```", "```js\n'use strict';\n\nconst socketIO = require('socket.io');\nconst InstantMessagingModule = require('./instant-messaging.module');\n\nmodule.exports = build;\n\nclass ChatService {\n}\n\nfunction build(app, server) {\n  return new ChatService(app, server);\n}\n```", "```js\n  constructor(app, server) {\n    this.connectedClients = {};\n    this.io = socketIO(server);\n    this.sessionMiddleware = app.get('sessionMiddleware');\n    this.initMiddlewares();\n    this.bindHandlers();\n  }\n```", "```js\n  var sessionOpts = {\n    secret: config.session.secret,\n    key: 'skey.sid',\n    resave: config.session.resave,\n    saveUninitialized: config.session.saveUninitialized\n  };\n\n  if (config.session.type === 'mongodb') {\n    sessionOpts.store = new MongoStore({\n      url: config.mongodb.uri\n    });\n  }\n\n  var sessionMiddleware = session(sessionOpts);\n  app.set('sessionMiddleware', sessionMiddleware);\n```", "```js\n  initMiddlewares() {\n    this.io.use((socket, next) => {\n      this.sessionMiddleware(socket.request, socket.request.res, next);\n    });\n\n    this.io.use((socket, next) => {\n      let user = socket.request.session.passport.user;\n\n      //  authorize user\n      if (!user) {\n        let err = new Error('Unauthorized');\n        err.type = 'unauthorized';\n        return next(err);\n      }\n\n      // attach user to the socket, like req.user\n      socket.user = {\n        _id: socket.request.session.passport.user\n      };\n      next();\n    });\n  }\n```", "```js\n  bindHandlers() {\n    this.io.on('connection', socket => {\n      // add client to the socket list to get the session later\n      this.connectedClients[socket.request.session.passport.user] = socket;\n      InstantMessagingModule.init(socket, this.connectedClients, this.io);\n    });\n  }\n```", "```js\n'use strict';\n\nconst mongoose = require('mongoose');\nconst Message = mongoose.model('Message');\nconst Thread = mongoose.model('Thread');\n\nmodule.exports.init = initInstantMessagingModule;\n\nclass InstantMessagingModule {\n}\n\nfunction initInstantMessagingModule(socket, clients) {\n  return new InstantMessagingModule(socket, clients);\n}\n```", "```js\n  constructor(socket, clients) {\n    this.socket = socket;\n    this.clients = clients;\n    this.threads = {};\n    this.bindHandlers();\n  }\n```", "```js\n  bindHandlers() {\n    this.socket.on('send:im', data => {\n      data.sender = this.socket.user._id;\n\n      if (!data.thread) {\n        let err = new Error('You must be participating in a conversation.')\n        err.type = 'no_active_thread';\n        return this.handleError(err);\n      }\n\n      this.storeIM(data, (err, message, thread) => {\n        if (err) {\n          return this.handleError(err);\n        }\n\n        this.socket.emit('send:im:success', message);\n\n        this.deliverIM(message, thread);\n      });\n    });\n  }\n```", "```js\n  storeIM(data, callback) {\n    this.findThreadById(data.thread, (err, thread) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let user = thread.participants.find((participant) => {\n        return participant.toString() === data.sender.toString();\n      });\n\n      if (!user) {\n        let err = new Error('Not a participant.')\n        err.type = 'unauthorized_thread';\n        return callback(err);\n      }\n\n      this.createMessage(data, (err, message) => {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(err, message, thread);\n      });\n    });\n  }\n```", "```js\n  findThreadById(id, callback) {\n    if (this.threads[id]) {\n      return callback(null, this.threads[id]);\n    }\n\n    Thread.findById(id, (err, thread) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.threads[id] = thread;\n      callback(null, thread);\n    });\n  }\n\n  createMessage(data, callback) {\n    Message.create(data, (err, newMessage) => {\n      if (err) {\n        return callback(err);\n      }\n\n      newMessage.populate('sender', callback);\n    });\n  }\n```", "```js\n  deliverIM(message, thread) {\n    for (let i = 0; i < thread.participants.length; i++) {\n      if (thread.participants[i].toString() === message.sender.toString()) {\n        continue;\n      }\n\n      if (this.clients[thread.participants[i]]) {\n        this.clients[thread.participants[i]].emit('receive:im', message);\n      }\n    }\n  }\n```", "```js\nboot.ts file will be the final version, with all the necessary data added to it:\n```", "```js\nimport { bootstrap } from 'angular2/platform/browser';\nimport { provide } from 'angular2/core';\nimport { HTTP_PROVIDERS } from 'angular2/http';\nimport { ROUTER_PROVIDERS, LocationStrategy, HashLocationStrategy } from 'angular2/router';\nimport { AppComponent } from './app.component';\nimport { ChatService }  from './services/chat.service';\nimport { ThreadService }  from './services/thread.service';\nimport { MessageService }  from './services/message.service';\nimport { UserService } from './services/user.service';\n\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/combineLatest';\nimport 'rxjs/add/operator/distinctUntilChanged';\nimport 'rxjs/add/operator/debounceTime';\n\nbootstrap(AppComponent, [\n  HTTP_PROVIDERS, ROUTER_PROVIDERS,\n  ChatService,\n  ThreadService,\n  MessageService,\n  UserService,\n  provide(LocationStrategy, {useClass: HashLocationStrategy})\n]); \n```", "```js\nimport { Component } from 'angular2/core';\nimport { RouteConfig, RouterOutlet } from 'angular2/router';\nimport { Router } from 'angular2/router';\nimport { ChatComponent } from './chat/chat.component';\n\n@RouteConfig([\n  { path: '/messages/...', as: 'Chat', component: ChatComponent, useAsDefault: true }\n])\n@Component({\n    selector: 'chat-app',\n    directives: [\n      RouterOutlet\n    ],\n    template: `\n      <div class=\"chat-wrapper row card whiteframe-z2\">\n        <div class=\"chat-header col\">\n          <h3>Chat application</h3>\n        </div>\n        <router-outlet></router-outlet>\n      </div>\n    `\n})\nexport class AppComponent {\n  constructor() {\n  }\n}\n```", "```js\nexport class User {\n  _id: string;\n  email: string;\n  name: string;\n  avatar: string;\n  createdAt: string;\n\n  constructor(_id?: string, email?: string, name?: string, createdAt?: string) {\n    this._id = _id;\n    this.email = email;\n    this.name = name;\n    this.avatar = 'http://www.gravatar.com/avatar/{{hash}}?s=50&r=g&d=retro'.replace('{{hash}}', _id);     this.createdAt = createdAt;\n  }\n}\n```", "```js\nimport { User } from './user';\n\nexport class Thread {\n  _id: string;\n  name: string;\n  participants: Array<User>;\n  createdAt: string;\n\n  constructor(_id?: string, name?: string, participants?: Array<User>, createdAt?: string) {\n    this._id = _id;\n    this.name = name || '';\n    this.participants = participants || [];\n    this.createdAt = createdAt;\n  }\n\n  generateName(omittedUser) {\n    let names = [];\n    this.participants.map(participant => {\n      if (omittedUser._id !== participant._id) {\n        names.push(participant.name);\n      }\n    });\n\n    return (names[1]) ? names.join(', ') : names[0];\n  }\n}\n```", "```js\nexport class Message {\n  _id: string;\n  sender: any;\n  thread: string;\n  body: string;\n  createdAt: string;\n  time: string;\n  fulltime: string;\n\n  constructor(_id?: string, sender?: any, thread?: string, body?: string, createdAt?: string) {\n    this._id = _id;\n    this.sender = sender;\n    this.body = body;\n    this.createdAt = createdAt;\n    this.time = this._generateTime(new Date(createdAt));\n    this.fulltime = this._generateDateTime(new Date(createdAt));\n  }\n\n  private _generateTime(date) {\n    return  date.getHours() + \":\"\n          + date.getMinutes() + \":\"\n          + date.getSeconds();\n  }\n\n  private _generateDateTime(date) {\n    return date.getDate() + \"/\"\n          + (date.getMonth()+1)  + \"/\"\n          + date.getFullYear() + \" @ \"\n          + this._generateTime(date);\n  }\n}\n```", "```js\nimport { Injectable } from 'angular2/core';\nimport { Http, Response, Headers } from 'angular2/http';\nimport { Observable } from 'rxjs/Observable';\nimport { contentHeaders } from '../common/headers';\nimport { User } from '../datatypes/user';\n\ntype ObservableUsers = Observable<Array<User>>;\n\n@Injectable()\nexport class UserService {\n  public users: ObservableUsers;\n  public user: User;\n  private _http: Http;\n  private _userObservers: any;\n  private _dataStore: { users: Array<User> };\n\n  constructor(http: Http) {\n    this._http = http;\n    this.users = new Observable(observer => this._userObservers = observer).share();\n    this._dataStore = { users: [] };\n    this.getAll();\n  }\n}\n```", "```js\n  getAll() {\n    return this._http\n    .get('/api/users', { headers: contentHeaders })\n    .map((res: Response) => res.json())\n    .subscribe(users => this.storeUsers(users));\n  }\n```", "```js\n  storeUsers(users: Array<User>) {\n    this._dataStore.users = users;\n    this._userObservers.next(this._dataStore.users);\n  }\n```", "```js\n    import { Injectable } from 'angular2/core';\n    import { Http, Response, Headers } from 'angular2/http';\n    import { Subject } from 'rxjs/Subject';\n    import { BehaviorSubject } from 'rxjs/Subject/BehaviorSubject';\n    import { Observable } from 'rxjs/Observable';\n    import { contentHeaders } from '../common/headers';\n    import { Thread } from '../datatypes/thread';\n    import { User } from '../datatypes/user';\n    ```", "```js\n    type ObservableThreads = Observable<Array<Thread>>;\n    type SubjectThread = Subject<Thread>;\n    ```", "```js\n    @Injectable()\n    export class ThreadService {\n      public threads: ObservableThreads;\n      public currentThread: SubjectThread = new BehaviorSubject<Thread>(new Thread());\n      private _http: Http;\n      private _threadObservers: any;\n      private _dataStore: { threads: Array<Thread> };\n      private _currentUser: any;\n    }\n    ```", "```js\n      constructor(http: Http) {\n        this._http = http;\n        this._dataStore = { threads: [] };\n        this.threads = new Observable(\n          observer => this._threadObservers = observer\n        ).share();\n      }\n    ```", "```js\n      getAll() {\n        return this._http\n        .get('/api/threads', { headers: contentHeaders })\n        .map((res: Response) => res.json())\n        .map(data => {\n          return data.map(thread => {\n            return new Thread(thread._id, thread._id, thread.participants, thread.createdAt)\n          });\n        })\n        .subscribe(threads => {\n          this._dataStore.threads = threads;\n          this._threadObservers.next(this._dataStore.threads);\n        });\n    ```", "```js\n      open(data: any) {\n        return this._http\n        .post('/api/thread/open', JSON.stringify(data), { headers: contentHeaders })\n        .map((res: Response) => res.json())\n        .map(data => {\n          return new Thread(data._id, data.name, data.participants, data.createdAt);\n        });\n      }\n    ```", "```js\n      setCurrentThread(newThread: Thread) {\n        this.currentThread.next(newThread);\n      }\n    ```", "```js\n      storeThread(thread: Thread) {\n        var found = this._dataStore.threads.find(t => {\n          return t._id === thread._id;\n        });\n\n        if (!found) {\n          this._dataStore.threads.push(thread);\n          this._threadObservers.next(this._dataStore.threads);\n        }\n      }\n    ```", "```js\nimport { Injectable } from 'angular2/core';\nimport { Http, Response, Headers } from 'angular2/http';\nimport { Observable } from 'rxjs/Observable';\nimport { ThreadService } from './thread.service';\nimport { contentHeaders } from '../common/headers';\nimport { Message } from '../datatypes/message';\nimport { User } from '../datatypes/user';\nimport * as io from 'socket.io-client';\n```", "```js\ntype ObservableMessages = Observable<Array<Message>>;\n\n@Injectable()\nexport class MessageService {\n  public messages: ObservableMessages;\n\n  private _http: Http;\n  private _threadService: ThreadService;\n  private _io: any;\n  private _messagesObservers: any;\n  private _dataStore: { messages: Array<Message> };\n\n  constructor(http: Http, threadService: ThreadService) {\n    this._io = io.connect();\n    this._http = http;\n    this._threadService = threadService;\n    this.messages = new Observable(observer => this._messagesObservers = observer).share();\n    this._dataStore = { messages: [] };\n    this._socketOn();\n  }\n}\n```", "```js\n  private _socketOn() {\n    this._io.on('receive:im', message => this._storeMessage(message));\n    this._io.on('send:im:success', message => this._storeMessage(message));\n  }\n```", "```js\n  private _storeMessage(message: Message) {\n    let sender = new User(\n      message.sender._id,\n      message.sender.email,\n      message.sender.name,\n      message.sender.createdAt\n    );\n    let m = new Message(\n      message._id,\n      new User(sender._id, sender.email, sender.name, sender.createdAt),\n      message.thread,\n      message.body,\n      message.createdAt\n    );\n    this._dataStore.messages.push(m);\n    this._messagesObservers.next(this._dataStore.messages);\n  }\n```", "```js\n  sendMessage(message: Message) {\n    this._io.emit('send:im', message);\n  }\n```", "```js\n  getByThread(threadId) {\n    this._http\n    .get('/api/threads/'+threadId+'/messages', { headers: contentHeaders })\n    .map((res: Response) => res.json())\n    .map(res => {\n      return res.map(data => {\n        let sender = new User(\n          data.sender._id,\n          data.sender.email,\n          data.sender.name,\n          data.sender.createdAt\n        );\n        return new Message(\n          data._id,\n          sender,\n          data.thread,\n          data.body,\n          data.createdAt\n        );\n      });\n    })\n    .subscribe(messages => {\n      this._dataStore.messages = messages;\n      this._messagesObservers.next(this._dataStore.messages);\n    });\n  }\n```", "```js\nimport { Component } from 'angular2/core';\nimport { RouteConfig, RouterOutlet } from 'angular2/router';\nimport { ChatService } from '../services/chat.service';\nimport { ThreadListComponent } from '../thread/thread-list.component';\nimport { MessageListComponent } from '../message/message-list.component';\nimport { MessageFormComponent } from '../message/message-form.component';\nimport { UserListComponent } from '../user/user-list.component';\nimport { ChatHelpComponent } from './chat-help.component';\n```", "```js\n@RouteConfig([\n  { path: '/',            as: 'ThreadMessagesDefault', component: ChatHelpComponent, useAsDefault: true },\n  { path: '/:identifier', as: 'ThreadMessages', component: MessageListComponent }\n])\n@Component({\n  selector: 'chat',\n  directives: [\n    ThreadListComponent,\n    MessageFormComponent,\n    UserListComponent,\n    RouterOutlet\n  ],\n  template: `\n    <div class=\"threads-container col sidebar\">\n      <user-list></user-list>\n      <thread-list></thread-list>\n    </div>\n\n    <div class=\"messages-container col content\">\n      <router-outlet></router-outlet>\n\n      <div class=\"message-form-container\">\n        <message-form></message-form>\n      </div>\n    </div>\n  `\n})\nexport class ChatComponent {\n  private _chatService: ChatService;\n\n  constructor(chatService: ChatService) {\n    this._chatService = chatService;\n  }\n}\n```", "```js\nimport { Component } from 'angular2/core';\n\n@Component({\n  selector: 'chat-help',\n  template: `\n    <h2>Start a new conversation with someone</h2>\n  `\n})\nexport class ChatHelpComponent {\n  constructor() {\n  }\n}\n```", "```js\nimport { Component } from 'angular2/core';\nimport { Router } from 'angular2/router'\nimport { Subject } from 'rxjs/Subject';\nimport { ReplaySubject } from 'rxjs/Subject/ReplaySubject';\nimport { UserService } from '../services/user.service';\nimport { ThreadService } from '../services/thread.service';\nimport { User } from '../datatypes/user';\n\n@Component({\n    selector: 'user-list',\n    template: ``\n})\nexport class UserListComponent {\n  public users: Array<User>;\n  public filteredUsers: Array<User>;\n  public selected: boolean = false;\n  public search: Subject<String> = new ReplaySubject(1);\n  public searchValue: string = '';\n  private _threadService: ThreadService;\n  private _userService: UserService;\n  private _router: Router;\n\n  constructor(userService: UserService, threadService: ThreadService, router: Router) {\n    this._userService = userService;\n    this._threadService = threadService;\n    this._router = router;\n  }\n}\n```", "```js\n      <div class=\"user-search-container\">\n        <input\n          type=\"text\"\n          class=\"form-control block\"\n          placeholder=\"start a conversation\"\n          [(ngModel)]=\"searchValue\"\n          (focus)=\"onFocus($event)\"\n          (input)=\"onInput($event)\"\n          (keydown.esc)=\"onEsc($event)\"\n        />\n      </div>\n      <div class=\"user-list-container\">\n        <div class=\"users-container\" [ngClass]=\"{active: selected }\">\n          <div class=\"user-list-toobar\">\n            <a href=\"#\" (click)=\"onClose($event)\" class=\"close-button\">\n              <span>×</span>\n              <span class=\"close-text\">esc</span>\n            </a>\n          </div>\n          <div *ngFor=\"#user of filteredUsers\">\n            <a href=\"javascript:void(0);\" (click)=\"openThread($event, user)\">{{user.name}}</a>\n          </div>\n        </div>\n      </div>\n```", "```js\n    this._userService.users.subscribe(users => {\n      this.filteredUsers = this.users = users;\n    });\n```", "```js\n    this.search\n      .debounceTime(200)\n      .distinctUntilChanged()\n      .subscribe((value: string) => {\n        this.filteredUsers = this.users.filter(user => {\n          return user.name.toLowerCase().startsWith(value);\n        });\n      });\n```", "```js\n  onInput(event) {\n    this.search.next(event.target.value);\n  }\n```", "```js\n  openThread(event, user: User) {\n    this._threadService.open({ userId: user._id }).subscribe(thread => {\n      this._threadService.storeThread(thread);\n      this._router.navigate(['./ThreadMessages', { identifier: thread._id}]);\n      this.cleanUp();\n    });\n  }\n```", "```js\n  onFocus() {\n    this.selected = true;\n  }\n\n  onClose(event) {\n    this.cleanUp();\n    event.preventDefault();\n  }\n\n  onEsc(event) {\n    this.cleanUp();\n    let target: HTMLElement = <HTMLElement>event.target;\n    target.blur();\n    event.preventDefault();\n  }\n  cleanUp() {\n    this.searchValue = '';\n    this.selected = false;\n    this.search.next('');\n  }\n```", "```js\n    import { Component, OnInit } from 'angular2/core';\n    import { RouterLink } from 'angular2/router';\n    import { ThreadService } from '../services/thread.service';\n    import { Thread } from '../datatypes/thread';\n    ```", "```js\n    @Component({\n        inputs: ['thread'],\n        selector: 'thread',\n        directives: [ RouterLink ],\n        template: `\n          <div class=\"thread-item\">\n            <a href=\"#\" [routerLink]=\"['./ThreadMessages', { identifier: thread._id }]\" data-id=\"{{thread._id}}\">\n              {{thread.name}}\n              <span *ngIf=\"selected\"> &bull; </span>\n            </a>\n          </div>\n        `\n    })\n    ```", "```js\n    export class ThreadComponent implements OnInit {\n      public thread: Thread;\n      public selected: boolean = false;\n      private _threadService: ThreadService;\n\n      constructor(threadService: ThreadService) {\n        this._threadService = threadService;\n      }\n\n      ngOnInit() {\n        this._threadService.currentThread.subscribe( (thread: Thread) => {\n          this.selected = thread && this.thread && (thread._id === this.thread._id);\n        });\n      }\n    }\n    ```", "```js\n    import { Component, ChangeDetectionStrategy } from 'angular2/core';\n    import { Observable } from 'rxjs/Observable';\n    import { ThreadService } from '../services/thread.service';\n    import { Thread } from '../datatypes/thread';\n    import { ThreadComponent } from './thread.component';\n    ```", "```js\n    @Component({\n        selector: 'thread-list',\n        directives: [ThreadComponent],\n        // changeDetection: ChangeDetectionStrategy.OnPushObserve,\n        // changeDetection: ChangeDetectionStrategy.OnPush,\n        template: `\n          <h4>Recent <span class=\"muted\">({{threads.length}})</span></h4>\n          <thread\n            *ngFor=\"#thread of threads\"\n            [thread]=\"thread\">\n          </thread>\n        `\n    })\n    ```", "```js\n    export class ThreadListComponent {\n      public threads: Array<Thread> = [];\n      private _threadService: ThreadService;\n\n      constructor(threadService: ThreadService) {\n        this._threadService = threadService;\n        this._threadService.threads.subscribe(threads => {\n          this.threads = threads;\n        });\n        this._threadService.getAll();\n      }\n    }\n    ```", "```js\nimport { Component, OnInit } from 'angular2/core';\nimport { ThreadService } from '../services/thread.service';\nimport { MessageService } from '../services/message.service';\nimport { Message } from '../datatypes/message';\nimport { User } from '../datatypes/user';\nimport { Thread } from '../datatypes/thread';\n```", "```js\n@Component({\n    selector: 'message-form',\n    // changeDetection: ChangeDetectionStrategy.OnPush,\n    template: `\n      <input\n        class=\"message-form form-control\"\n        autocorrect=\"off\" autocomplete=\"off\" spellcheck=\"true\"\n        (keydown.enter)=\"onEnter($event)\"\n        [(ngModel)]=\"draftMessage.body\"\n      >\n    `\n})\nexport class MessageFormComponent implements OnInit {\n\n  constructor() {\n  }\n\n  ngOnInit() {\n  }\n}\n```", "```js\n      public draftMessage: Message;\n      private _messageService: MessageService;\n      private _threadService: ThreadService;\n      private _thread: Thread;\n    ```", "```js\n      constructor(messageService: MessageService, threadService: ThreadService) {\n        this._messageService = messageService;\n        this._threadService = threadService;\n        this._threadService.currentThread.subscribe(thread => this._thread = thread);\n      }\n    ```", "```js\n      ngOnInit() {\n        this.draftMessage = new Message();\n      }\n    ```", "```js\n      sendMessage() {\n        let message: Message = this.draftMessage;\n        message.thread = this._thread._id;\n        this._messageService.sendMessage(message);\n        this.draftMessage = new Message();\n      }\n    ```", "```js\n      onEnter(event: any) {\n        this.sendMessage();\n        event.preventDefault();\n      }\n    ```", "```js\nimport { Component, AfterViewInit } from 'angular2/core';\n\n@Component({\n    inputs: ['message'],\n    selector: 'message',\n    template: `\n      <div class=\"message-item\">\n        <div class=\"message-identifier\">\n          <img src=\"img/{{message.sender.avatar}}\" width=\"36\" height=\"36\"/>\n        </div>\n        <div class=\"message-content\">\n          <div class=\"message-sender\">\n            <span class=\"user-name\">{{message.sender.name}}</span>\n            <span class=\"message-timestamp\" title={{message.fulltime}}>{{message.time}}</span>\n          </div>\n          <div class=\"message-body\">\n            {{message.body}}\n          </div>\n        </div>\n      </div>\n    `\n})\nexport class MessageComponent implements AfterViewInit {\n  constructor() {\n  }\n\n  ngAfterViewInit() {\n    var ml = document.querySelector('message-list .message-list');\n    ml.scrollTop = ml.scrollHeight;\n  }\n}\n```", "```js\n    import { Component } from 'angular2/core';\n    import { RouteParams } from 'angular2/router';\n    import { MessageService } from '../services/message.service';\n    import { ThreadService } from '../services/thread.service';\n    import { Thread } from '../datatypes/thread';\n    import { Message } from '../datatypes/message';\n    import { MessageComponent } from './message.component';\n    ```", "```js\n    @Component({\n        selector: 'message-list',\n        directives: [MessageComponent],\n        template: `\n          <div class=\"message-list\">\n            <div *ngIf=\"messages.length === 0\" class=\"empty-message-list\">\n              <h3>No messages so far :)</h3>\n            </div>\n            <message\n              *ngFor=\"#message of messages\"\n              [message]=\"message\"\n              ></message>\n          </div>\n        `\n    })\n    ```", "```js\n    export class MessageListComponent {\n      public messages: Array<Message> = [];\n      private _messageService: MessageService;\n      private _threadService: ThreadService;\n      private _routeParams:RouteParams;\n    }\n    Add the constructor:\n      constructor(\n        messageService: MessageService,\n        threadService: ThreadService,\n        routeParams: RouteParams\n      ) {\n        this._routeParams = routeParams;\n        this._messageService = messageService;\n        this._threadService = threadService;\n        this._messageService.messages.subscribe(messages => this.messages = messages);\n        let threadId: string = this._routeParams.get('identifier');\n        this._threadService.setCurrentThread(new Thread(threadId));\n        this._messageService.getByThread(threadId);\n      }\n    ```"]