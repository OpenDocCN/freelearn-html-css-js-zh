- en: Building an Interactive Scatter Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's pretend we've started jogging and we want to visualize the data regarding
    our progress as a runner, with a scatter plot. We're going to have an array of
    objects, each with a date and distance properties. For each object in the array,
    we're going to create a circle in our SVG. If the `distance` property of an object
    is relatively high, its associated circle will be higher up on the graph. If the
    `date` property of an object is relatively high (a later date), its associated
    circle will be farther right.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a link to the D3 library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an`<svg>`tag and size it with D3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create some fake data for our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add SVG circles and style them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a linear scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach data to visual elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use data attached to a visual element to affect its appearance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a time scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse and format times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set dynamic domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically generate SVG elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create axes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display data in a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete code for this section can be found here: [https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter03](https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a link to the D3 library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we want to do is create a basic `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a link to D3 at the bottom of your `<body>` tag in `index.html`. We''ll
    put it at the bottom so that the script loads after all your other HTML elements
    have loaded into the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create `app.js` in the same folder as your `index.html`. In it, we will
    store all of our JS code. For now, just put this code in it to see whether it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Link to it in `index.html` at the bottom of the `<body>` tag. Make sure it
    comes after the D3 script tag so that D3 loads before your `app.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `index.html` in Chrome just as we did in [Chapter 2](f40fadd5-f40b-43dc-a82d-206aac322123.xhtml),
    *Using SVG to Create Images Using Code*, (**File** | **Open File**), and check
    your Dev Tools (**View** | **Developer** | **Developer tools**) to see whether
    your JavaScript files are linked correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45970fd8-68f3-4156-bf2f-70e8a9b48b1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding an<svg>tag and sizing it with D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `<indexentry content=" tag:sizing, with D3">` the `index.html`, at the top
    of `<body>`, before `<indexentry content=" tag:adding">` your script tags, add
    an `<svg>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we examine the **Elements** tab of our dev tools, we''ll `<indexentry content="
    tag:adding">` see the `svg` element has `<indexentry content=" tag:sizing, with
    D3">` been placed. In Chrome, it has a default width/height of 300 px/150 px:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87f192b1-16cf-4835-a11d-30160d13d466.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In `app.js`, remove your previous `console.log` statements and create variables
    to hold the width and height of the `<svg>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use `d3.select()` to select a single element, in this case the
    `<svg>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value of `d3.select(''svg'')` is a D3 version of the svg element
    (as in jQuery), so we can chain commands onto this. Let''s add some styling to
    adjust the height/width of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we check the dev tools, we''ll see the `<svg>` element has been resized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96cba3c4-fabf-4d03-9708-d0d978fd01e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating some fake data for our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `app.js`, let''s create an array of `run` objects, I am storing the date
    as a string on purpose also, it''s important that this is an array of objects,
    to work with D3). Here''s what your `app.js` code should look like so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding SVG circles and styling them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `index.html`, add three circles to your `<svg>` element (each one will represent
    a run):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `app.css` in the same folder as `index.html`, with some styling for
    the circles and our `svg` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Link to it in the head of `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our page should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/256cdb29-f354-48d4-a6c7-f5025e279b3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a linear scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We currently have three circles in our SVG and three objects in our `runs` array.
    One of the best things D3 does is provide the ability to link SVG elements with
    data so that as the data changes so do the SVG elements. In this chapter, we're
    going to link each circle to an object in the `runs` array. If the `distance`
    property of an object is relatively high, its associated circle will be higher
    up on the graph. If the `date` property of an object is relatively high (a later
    date), its associated circle is farther right.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's position the circles vertically, based on the `distance` property
    of the objects in our `runs` array. One of the most important things that D3 does
    is provide the ability to convert (or `map`) data values to visual points and
    vice versa. It does so using a `scale`. There are lots of different kinds of scales
    that handle lots of different data types, but for now we're just going to use
    a `linear scale`, which will map numeric data values to numeric visual points,
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `app.js`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we create a scale, we need to tell it the minimum and maximum possible
    values that can exist in our data (this is called the `domain`). To do so for
    our `yScale`, add the following to the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to tell the scale what visual values correspond to those min/max
    values in the data (this is called the `range`). To do so, add the following to
    the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Your last three lines of code in `app.js` should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, the first (starting) value for the range is `HEIGHT`
    (600) and the second (ending) value is 0\. The minimum for the data values is
    0 and the max is 10\. By doing this, we''re saying that a data point (distance
    run) of 0 should map to a visual height value of `HEIGHT` (600):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b60104e3-ce39-4a3d-b84d-0b15931fe714.png)'
  prefs: []
  type: TYPE_IMG
- en: This is because the lower the distance run (data value), the more we want to
    move the visual point down the *y* axis. Remember that the *y* axis starts with
    0 at the top and increases in value as we move down vertically on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also say that a data point (distance run) of 10 should map to a visual height
    of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec87518e-3736-41cc-80a4-f3dba371424d.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, this is because, as the distance run increases, we want to get back a
    visual value that is lower and lower so that our circles are closer to the top
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever need to remind yourself what the domain/range is, you can do so
    by logging `yScale.domain()` or `yScale.range()`. Temporarily add the following
    at the bottom `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Chrome console should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09e09dd5-9765-4dcf-b00a-9aafb3681bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When declaring the range/domain of a linear scale, we only need to specify
    start/end values for each. Values in between the start/end will be calculated
    by D3\. For instance, to find out what visual value corresponds to the distance
    value of 5, use `yScale()`. Remove the previous two `console.log()` statements
    and add the following to the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what our dev console should look like in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea310230-6299-4cbf-a70e-e7ff2fbd796d.png)'
  prefs: []
  type: TYPE_IMG
- en: It makes sense that this logs `300` because the data value of `5` is half way
    between the minimum data value of `0` and the maximum data value of `10`. The
    range starts at `HEIGHT` (600) and goes to `0`, so halfway between those values
    is 300.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, whenever you want to convert a data point to a visual point, call `yScale()`.
    We can go the other way and convert a visual point to a data value by calling
    `yScale.invert()`. To find out what data point corresponds to a visual value of
    450, remove the previous `console.log()` statement and add the following to the
    bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what Chrome''s console looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c887bf3-a317-481c-8e56-acc4bfa6639f.png)'
  prefs: []
  type: TYPE_IMG
- en: It makes sense that this logs `2.5` because the visual value of 450 is 25% of
    the way from the starting visual value of 600 (`HEIGHT`)to the ending visual value
    of `0`. You can now delete that last `console.log()` line.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching data to visual elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s attach each of the JavaScript objects in our `runs` array to a circle
    in our SVG. Once we do this, each circle can access the data of its associated
    `run` object to determine its position. Add the following to the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If there were more objects in our `runs` array than there are circles, the extra
    objects are ignored. If there are more circles than objects, then JavaScript objects
    are attached to circles in the order in which they appear in the DOM until there
    are no more objects to attach.
  prefs: []
  type: TYPE_NORMAL
- en: Use data attached to a visual element to affect its appearance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can change attributes for a selection of DOM elements by passing static
    values, and all selected elements will have that attribute set to that one specific
    value. Add the following temporarily to the end of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following should be seen on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/699f8f2c-89e5-4ffe-96a8-f81e7ade4939.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But now that each circle has one of our `runs` JavaScript data objects attached
    to it, we can set attributes on each circle using that data. We do that by passing
    the `.attr()` method a callback function instead of a static value for its second
    parameter. Remove `d3.selectAll(''circle'').attr(''cy'', 300);` and adjust the
    last line of `app.js` from `d3.selectAll(''circle'').data(runs);` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the browser, this is what we should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7dca9d4-aa18-47d5-93c1-8809a5fdfb95.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's examine what we just wrote. The callback function passed as the second
    parameter to `.attr()` runs on each of the visual elements selected (each of the
    `circle` elements in this case). During each execution of the callback, the return
    value of that callback function is then assigned to whatever aspect of the current
    element is being set (in this case the `cy` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback function takes two params:'
  prefs: []
  type: TYPE_NORMAL
- en: The individual `datum` object from the `runs` array that was attached to that
    particular visual element when we called `.data(runs)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index` of that `datum` in the`runs` array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, what this does is loop through each `circle` in the SVG. For each
    `circle`, it looks at the `run` object attached to that `circle` and finds its
    `distance` property. It then feeds that data value into `yScale()`, which then
    converts it into its corresponding visual point. That visual point is then assigned
    to that circle's `cy` attribute. Since each data object has a different `distance`
    value, each `circle` is placed differently, vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a time scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s position the circles horizontally, based on the date that their associated
    run happened. First, create a time scale. This is like a linear scale, but instead
    of mapping numeric values to visual points, it maps dates to visual points. Add
    the following to the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what our console should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6141d754-75a9-47bb-9594-8db2b41dd0f9.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now remove the two `console.log()` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing and formatting times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that the `date` properties of the objects in our `runs` array are strings
    and not date objects. This is a problem because `xScale`, as with all time scales,
    expects its data values to be date objects. Fortunately, D3 provides us an easy
    way to convert strings to dates and vice versa. We''ll use a specially formatted
    string, based on the documentation ([https://github.com/d3/d3-time-format#locale_format](https://github.com/d3/d3-time-format#locale_format)),
    to tell D3 how to parse the `date` string properties of the objects in our `runs`
    array into actual JavaScript date objects. Add the following at the end of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our Chrome console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d423b3e5-d578-4b72-89c7-181d4ca448a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use this when calculating `cx` attributes for our circles. Remove the
    last two `console.log()` statements, and add the following to the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what Chrome should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/669b1c8e-9a20-4c67-b62c-037eb47a57f8.png)'
  prefs: []
  type: TYPE_IMG
- en: In summary, this selects all of the `circle` elements. It then sets the `cx`
    attribute of each `circle` to the result of a callback function. That callback
    function runs for each `circle` and takes the `run` data object associated with
    that `circle` and finds its `date` property (remember it's a string, for example,
    `'October 3, 2017 at 6:00PM'`). It passes that string value to `parseTime()` which
    then turns the string into an actual JavaScript date object. That date object
    is then passed to `xScale()`, which converts the date into a visual value. That
    visual value is then used for the `cx` attribute of whichever `circle` the callback
    function has just run on. Since each `date` property of the objects in the `runs`
    array is different, the `circles` have different horizontal locations.
  prefs: []
  type: TYPE_NORMAL
- en: Setting dynamic domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, we're setting arbitrary min/max values for the domains of both
    distance and date. D3 can find the min/max of a dataset, so that our graph displays
    just the data ranges we need. All we need to do is pass the min/max methods a
    callback that gets called for each item of data in the `runs` array. D3 uses the
    callback to determine which properties of the datum object to compare for min/max.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to this part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Chrome should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/478f937b-f01f-4ef9-ad53-8b66bd233768.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s examine what we just wrote. The following code finds the minimum distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: D3 loops through the `runs` array (the first parameter) and calls the callback
    function (the second parameter) on each element of the array. The return value
    of that function is compared the return values of the callback function as it
    runs on the other elements. The lowest value is assigned to `yMin`. The same thing
    happens for `d3.max()` but with the highest value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine both the min/max functions into one `extent` function that returns
    an array that has the exact same structure as`[yMin, yMax]`. Let''s look at the
    code we just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the previous code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s much shorter, right? Let''s do the same for the xScale''s domain. Go
    to this part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we moved `parseTime` and `formatTime` up so they could be used within
    the `.extent()`. Here''s what Chrome should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bab5bea3-f40d-4990-85dc-98cc8620c3eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Dynamically generating SVG elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, we have just enough `<circle>` elements to fit our data. What if
    we don''t want to count how many elements are in the array? D3 can create elements
    as needed. First, remove all `<circle>` elements from `index.html`. Your `<body>`
    tag should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In `app.js`, go to this part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the code to create the circles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It should look exactly the same as before, but now circles are being created
    for each object in the `runs` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db7816e0-542e-4435-9e8e-d6231c750d0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a more in-depth explanation of what we just wrote. Take a look at the
    first line of the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This might seem unnecessary. Why not just do `d3.selectAll('circle')`? Well,
    at the moment, there are no `circle` elements. We're going to be appending `circle`
    elements dynamically, so `d3.select('svg')` tells D3 where to append them. We
    still need `.selectAll('circle')` though, so that when we call `.data(runs)` on
    the next line, D3 knows what elements to bind the various objects in the `runs`
    array to. But there aren't any `circle` elements to bind data to. That's OK.`.enter()`
    finds the `run` objects that haven't been bound to any `circle` elements yet (in
    this case all of them). We then use `.append('circle')` to append a circle for
    each unbound `run` object that `.enter()` found.
  prefs: []
  type: TYPE_NORMAL
- en: Creating axes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'D3 can automatically generate axes for you. Add the following to the bottom
    of`app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a bottom axis generator that can be used to insert an axis into
    any element you choose. Add the following code to the bottom of `app.js` to append
    a `<g>` element inside our SVG element and then insert a bottom axis inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what Chrome should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f285b8a3-8fec-45d2-aeb3-05745e70867f.png)'
  prefs: []
  type: TYPE_IMG
- en: Display of Chrome
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the axis to be at the bottom of the SVG, though. Modify the code we
    just wrote so it looks like this (note: we removed a`;` after`.call(bottomAxis)`
    and added`.attr(''transform'', ''translate(0,''+HEIGHT+'')'');`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, our SVG clips the axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5669c90a-9f8c-412c-9e94-004749f69f0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s alter our `svg` CSS so it doesn''t clip any elements that extend beyond
    its bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it looks good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbf37e37-8453-47d8-96d2-e3320942021b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The left axis is pretty similar. Add the following to the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: we don''t need to set a `transform` attribute, since it starts out in
    the correct place initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2446c71-3c12-42e3-adeb-9e6e89b8edda.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s a little tough to see, so let''s add the following at the bottom of `app.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our axes are complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d82b84-83f6-42ee-a839-a10577191e0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying data in a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just for debugging purposes, let''s create a table that will show all of our
    data. Make your `<body>` tag in `index.html` look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'D3 can also be used to manipulate the DOM, just like jQuery. Let''s populate
    the`<tbody>`in that style. Add the following to the bottom of `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some styling for the table at the bottom of `app.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjust the CSS for `svg` to add a bottom margin. This will create some space
    between the graph and the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the browser should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6ad7a6c-7b35-417a-a97b-a3b7008c7863.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you have a static scatter plot and a table that displays its
    data. In [Chapter 4](e503bfe5-4b90-47eb-bae0-d588a9b545d5.xhtml), *Making a Basic
    Scatter Plot Interactive*, we will be learning how to make it interactive.
  prefs: []
  type: TYPE_NORMAL
