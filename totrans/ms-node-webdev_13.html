<html><head></head><body>
<div><h1 class="chapternumber">12</h1>
<h1 class="chaptertitle" id="_idParaDest-204">Using Databases</h1>
<p class="normal1">In this chapter, I will demonstrate how Node.js applications can use a relational database to store and query data. This chapter explains how to work directly with a database by executing SQL queries, and how to take a more hands-off approach with an <strong class="screentext">Object Relational Mapping</strong> (<strong class="screentext">ORM</strong>) package. <em class="italic">Table 12.1</em> puts this chapter into context.</p>
<p class="packt_figref">Table 12.1: Putting databases into context</p>
<table class="table-container" id="table001-9">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><strong class="keyword">Question</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyword">Answer</strong></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">Databases are the most common means of persistently storing data.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Databases can store large volumes of data and enforce a data structure that makes it possible to perform efficient queries. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How are they used?</p>
</td>
<td class="table-cell">
<p class="normal">Databases are managed by database engines, which can be installed as npm packages, run on dedicated servers, or consumed as cloud services. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">Databases can be complex and require additional knowledge, such as being able to formulate queries in SQL.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Databases are not the only way to store data, but they are the most common, and, generally, the most effective because they are robust and scale up easily.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 12.2</em> summarizes what we will do in the chapter.</p>
<p class="packt_figref">Table 12.2: Chapter summary</p>
<table class="table-container" id="table002-9">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Store data persistently.</p>
</td>
<td class="table-cell">
<p class="normal">Use a database.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">7, 8, 12, 13</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Simplify the process of changing how data is stored.</p>
</td>
<td class="table-cell">
<p class="normal">Use a repository layer.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">9–11</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Display stored data.</p>
</td>
<td class="table-cell">
<p class="normal">Include query results when rendering templates.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">14, 15</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Prevent user-submitted values from being interpreted as SQL. </p>
</td>
<td class="table-cell">
<p class="normal">Use query parameters.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">16, 17</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Ensure that data is updated consistently.</p>
</td>
<td class="table-cell">
<p class="normal">Use a transaction.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">18–21</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Use a database without needing to write SQL queries.</p>
</td>
<td class="table-cell">
<p class="normal">Use an ORM package and describe the data used by the application using JavaScript code.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">22–25, 27, 28</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Perform operations that are too complex to describe using model classes.</p>
</td>
<td class="table-cell">
<p class="normal">Use the ORM package facility for executing SQL.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">26</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Query for and update data using an ORM.</p>
</td>
<td class="table-cell">
<p class="normal">Use the methods defined by the model classes, with constraints specified using JavaScript objects.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">29–32</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-205">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">part2app</code> project from <em class="italic">Chapter 11</em>. To prepare for this chapter, <em class="italic">Listing 12.1</em> removes the client-side validation code, which won’t be used in this chapter.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 12.1: The contents of the client.js file in the src/client folder</p>
<pre class="programlisting"><code class="hljs-code">document.addEventListener('DOMContentLoaded', () =&gt; {
    // do nothing
});
</code></pre>
<p class="normal"><em class="italic">Listing 12.2</em> updates the routing configuration for the example application.</p>
<p class="packt_figref">Listing 12.2: The contents of the server.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import httpProxy from "http-proxy";
import helmet from "helmet";
import { engine } from "express-handlebars";
import { registerFormMiddleware, registerFormRoutes } from "./forms";
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
expressApp.set("views", "templates/server");
expressApp.engine("handlebars", engine());
expressApp.set("view engine", "handlebars");
expressApp.use(helmet());
expressApp.use(express.json());
registerFormMiddleware(expressApp);
registerFormRoutes(expressApp);
expressApp.use("^/$", (req, resp) =&gt; resp.redirect("/form"));
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The new routing configuration removes entries that are no longer required. All the examples in this chapter use templates, and the new route matches requests for the default path and responds with a redirection to the <code class="inlinecode">/form</code> URL. The new route uses Express support for matching URL patterns, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
expressApp.use(<strong class="screentext">"^/$"</strong>, (req, resp) =&gt; resp.redirect("/form"));
...
</code></pre>
<p class="normal">The pattern is required to match requests for <code class="inlinecode">http://localhost:5000</code> and not requests that are handled by other routes, such as <code class="inlinecode">http://localhost:5000/css/bootstrap.min.css</code> (which is handled by the static content middleware) or <code class="inlinecode">http://localhost:5000/bundle.js</code> (which is forwarded to the webpack development HTTP server).</p>
<p class="normal"><em class="italic">Listing 12.3</em> updates the <code class="inlinecode">age</code> template to add a field that allows the user to specify a number of years, just to allow more variations in the results data. The structure of the HTML output has been changed to introduce a two-column layout and use a partial template named <code class="inlinecode">history</code>. This listing also removes the validation error elements, which is something that should not be done in a real project, but they are not needed in this chapter.</p>
<p class="packt_figref">Listing 12.3: The contents of the age.handlebars file in the templates/server folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="container fluid"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-7"&gt;
            {{#if name}}
                &lt;div class="m-2"&gt;
                    &lt;h4&gt;Hello {{ name }}. You will be {{ nextage }}
                        in {{ years }} years.&lt;/h4&gt;
                &lt;/div&gt;
            {{/if}}
            &lt;div&gt;
                &lt;form id="age_form" action="/form" method="post"&gt;
                    &lt;div class="m-2"&gt;
                        &lt;label class="form-label"&gt;Name&lt;/label&gt;
                        &lt;input name="name" class="form-control"
                            value="{{ name }}"/&gt;
                    &lt;/div&gt;
                    &lt;div class="m-2"&gt;
                        &lt;label class="form-label"&gt;Current Age&lt;/label&gt;
                        &lt;input name="age" class="form-control"
                            value="{{ age }}" /&gt;
                    &lt;/div&gt;                  
                    &lt;div class="m-2"&gt;
                        &lt;label class="form-label"&gt;Number of Years&lt;/label&gt;
                        &lt;input name="years" class="form-control"
                            value="{{ years }}" /&gt;         
                    &lt;/div&gt;                          
                    &lt;div class="m-2"&gt;
                        &lt;button class="btn btn-primary"&gt;Submit&lt;/button&gt;                               
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="col-5"&gt;
            {{&gt; history }}
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">To create the partial view, add a file named <code class="inlinecode">history.handlebars</code> to the <code class="inlinecode">templates/server/partials</code> folder with the content shown in <em class="italic">Listing 12.4</em>.</p>
<p class="packt_figref">Listing 12.4: The contents of the history.handlebars folder in the templates/server/partials folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;h4&gt;Recent Queries&lt;/h4&gt;
&lt;table class="table table-sm table-striped my-2"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;th&gt;Years&lt;/th&gt;&lt;th&gt;Result&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{#unless history }}
            &lt;tr&gt;&lt;td colspan="4"&gt;No data available&lt;/td&gt;&lt;/tr&gt;
        {{/unless }}
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p class="normal">The partial template displays data provided through a <code class="inlinecode">history</code> context property and displays a default message when no data is available. <em class="italic">Listing 12.5</em> revises the code that handles the <code class="inlinecode">/form</code> URL to remove the validation checks introduced in the previous chapter.</p>
<p class="packt_figref">Listing 12.5: The contents of the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", (req, resp) =&gt; {
        resp.render("age");
    });
    app.post("/form", (req, resp) =&gt; {
        const nextage = Number.parseInt(req.body.age)
            + Number.parseInt(req.body.years);
        const context = {
            ...req.body, nextage
        };
        resp.render("age", context);  
    });
}
</code></pre>
<p class="normal">Run the command shown in <em class="italic">Listing 12.6</em> in the <code class="inlinecode">part2app</code> folder to start the development tools.</p>
<p class="packt_figref">Listing 12.6: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000</code>, fill out the form, and click the <strong class="screentext">Submit</strong> button, as shown in <em class="italic">Figure 12.1</em>. No data will be displayed in the <strong class="screentext">Recent Queries</strong> section.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_12_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 12.1: Running the example application</p>
<h1 class="heading" id="_idParaDest-206">Using a database</h1>
<p class="normal1">Databases <a id="_idIndexMarker566" class="calibre3"/>allow web applications to read and write data, which can be used to generate responses for HTTP requests. There are many types of database, with choices about how data is stored and queried, how the database software is deployed, and how changes to data are handled. </p>
<p class="normal">The database <a id="_idIndexMarker567" class="calibre3"/>market is competitive and innovative, and there are excellent commercial and open-source products, but my advice is that the best database is one that you already understand and have worked with before. Most projects can use most databases, and the benefit that a particular database technology confers will be undermined by the time taken to learn and master that technology.</p>
<p class="normal">If you don’t have a database, it is easy to get lost in the endless options, and my advice is to start with something as simple as possible. For small applications, I recommend SQLite, which is the database I will use in this chapter. For larger applications, especially where multiple instances of Node.js are used to handle HTTP requests, I <a id="_idIndexMarker568" class="calibre3"/>recommend one of the excellent open-source <a id="_idIndexMarker569" class="calibre3"/>relational databases, such as MySQL (<a href="https://www.mysql.com" class="calibre3">https://www.mysql.com</a>) or PostgreSQL (<a href="https://www.postgresql.org" class="calibre3">https://www.postgresql.org</a>). You can see an example of one <a id="_idIndexMarker570" class="calibre3"/>such database in <em class="italic">Part 3</em> of this book. </p>
<p class="normal">If you don’t like using the <strong class="screentext">Structured Query Language</strong> (<strong class="screentext">SQL</strong>), then there are<a id="_idIndexMarker571" class="calibre3"/> good NoSQL databases available and a good place to start is MongoDB (<a href="https://www.mongodb.com" class="calibre3">https://www.mongodb.com</a>).</p>
<div><p class="normal"><strong class="screentext">Database Complaints</strong></p>
<p class="normal">I receive complaints whenever I write about choosing database products. Many developers have strong views about the superiority of a particular database or style of database and are upset when I don’t recommend their preferred product.</p>
<p class="normal">It isn’t that I think any particular database engine is bad. In fact, the database market has never been so good, to the extent that just about any database product can be used in just about any project with little impact on productivity or scale.</p>
<p class="normal">Database engines are like automobiles: modern cars are so good that most people can get along with just about any car. If you already have a car, then the benefit of changing it is likely to be small when compared to the cost. If you don’t have a car, then a good place to start is with the car that most of your neighbors have and the local mechanics often work on. Some people get really into cars and have strong views about a particular make or model, and that’s fine, but it can be taken to excess, and most people don’t drive in a way where marginal improvements become significant.</p>
<p class="normal">So, I absolutely understand why some developers become deeply invested in a particular database engine – and I respect that level of commitment and understanding – but most projects don’t have the kinds of data storage or processing requirements that make the differences between database products important.</p>
</div>
<h2 class="heading1" id="_idParaDest-207">Installing the database package</h2>
<p class="normal1">The <a id="_idIndexMarker572" class="calibre3"/>database engine used in this chapter is SQLite. It operates within the Node.js process and is a good choice for applications where data doesn’t need to be shared between multiple instances of Node.js, which SQLite doesn’t support because it doesn’t run as a separate server. SQLite <a id="_idIndexMarker573" class="calibre3"/>is widely used and is, at least according to <a href="https://sqlite.org" class="calibre3">https://sqlite.org</a>, the most popular database engine in the world.</p>
<p class="normal">Run the command shown in <em class="italic">Listing 12.7</em> in the <code class="inlinecode">part2app</code> folder to add SQLite to the project. No additional TypeScript type packages are required. </p>
<p class="packt_figref">Listing 12.7: Adding the database package to the project</p>
<pre class="programlisting1"><code class="hljs-con">npm install sqlite3@5.1.6
</code></pre>
<p class="normal">This package includes the database engine, a Node.js API, and descriptions of those APIs for the TypeScript compiler. To describe the database that will be used in this section, add a file named <code class="inlinecode">age.sql</code> to the <code class="inlinecode">part2app</code> folder with the content shown in <em class="italic">Listing 12.8</em>.</p>
<p class="packt_figref">Listing 12.8: The contents of the age.sql file in the part2app folder</p>
<pre class="programlisting"><code class="hljs-code">DROP TABLE IF EXISTS Results;
DROP TABLE IF EXISTS Calculations;
DROP TABLE IF EXISTS People;
CREATE TABLE IF NOT EXISTS `Calculations` (
    id INTEGER PRIMARY KEY AUTOINCREMENT, `age` INTEGER,
    years INTEGER, `nextage` INTEGER);
CREATE TABLE IF NOT EXISTS `People` (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(255));
CREATE TABLE IF NOT EXISTS `Results` (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    calculationId INTEGER REFERENCES `Calculations` (`id`)
        ON DELETE CASCADE ON UPDATE CASCADE,
    personId INTEGER REFERENCES `People` (`id`)
        ON DELETE CASCADE ON UPDATE CASCADE);
INSERT INTO Calculations (id, age, years, nextage) VALUES
    (1, 35, 5, 40), (2, 35, 10, 45);
INSERT INTO People (id, name) VALUES
    (1, 'Alice'), (2, "Bob");
   
INSERT INTO Results (calculationId, personId) VALUES
    (1, 1), (2, 2), (2, 1);
</code></pre>
<p class="normal">The <a id="_idIndexMarker574" class="calibre3"/>SQL statements in <em class="italic">Listing 12.8</em> create three tables, which will record the age calculations performed by the application. The <code class="inlinecode">Calculations</code> table keeps track of the age calculations that have been performed and has columns for the age and year values provided by the user and the future age that has been calculated. The <code class="inlinecode">People</code> table keeps track of the names that users provide. The <code class="inlinecode">Results</code> table keeps track of results by referencing a name and a calculation.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The data the application works with doesn’t justify three tables, but simple data combined with multiple tables allows some common problems to be more easily demonstrated.</p>
</div>
<h2 class="heading1" id="_idParaDest-208">Creating a repository layer</h2>
<p class="normal1">A repository is a<a id="_idIndexMarker575" class="calibre3"/> layer of code that isolates the database from the rest of the application, which<a id="_idIndexMarker576" class="calibre3"/> makes it easier to change the way that data is read and written without needing to change the code that uses that data. Not everyone finds a repository layer useful, but my advice is to use one unless you are completely certain that your application’s use of data or database products won’t change. Create the <code class="inlinecode">src/server/data</code> folder and add to it a file named <code class="inlinecode">repository.ts</code> with the contents shown in <em class="italic">Listing 12.9</em>. </p>
<p class="packt_figref">Listing 12.9: The contents of the repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">export interface Result {
    id: number,
    name: string,
    age: number,
    years: number,
    nextage: number
}
export interface Repository {
    saveResult(r: Result):  Promise&lt;number&gt;;
    getAllResults(limit: number) : Promise&lt;Result[]&gt;;
    getResultsByName(name: string, limit: number): Promise&lt;Result[]&gt;;
}
</code></pre>
<p class="normal">The <code class="inlinecode">Repository</code> interface defines methods for storing new <code class="inlinecode">Result</code> objects, querying for all results, and results that have a specific name. The <code class="inlinecode">Result</code> type defines properties for all of the data columns in the database tables in a simple, flat structure.</p>
<p class="normal">Projects can use data types that match the structure of the database, but that often means that the data that arrives from the user has to be assembled into a complex structure before being extracted and used to create an SQL statement, while the reverse process assembles data from the database into the same structure, only for it to be extracted for use in templates. It isn’t always possible, but using simple, flat data structures often simplifies development.</p>
<h2 class="heading1" id="_idParaDest-209">Implementing the repository</h2>
<p class="normal1">The<a id="_idIndexMarker577" class="calibre3"/> next step is to implement the <code class="inlinecode">Repository</code> interface with a class that uses the SQLite database engine. I am going to implement the repository in stages, which will make it easier to understand the relationship between the data in the database and the JavaScript objects in the application. To start the implementation, create a file named <code class="inlinecode">sql_repository.ts</code> file in the <code class="inlinecode">src/server/data</code> folder with the content shown in <em class="italic">Listing 12.10</em>.</p>
<p class="packt_figref">Listing 12.10: The contents of the sql_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFileSync } from "fs";
import { Database } from "sqlite3";
import { Repository, Result } from "./repository";
export class SqlRepository implements Repository {
    db: Database;
    constructor() {
        this.db = new Database("age.db");
        this.db.exec(readFileSync("age.sql").toString(), err =&gt; {
            if (err != undefined) throw err;
        });
    }
    saveResult(r: Result): Promise&lt;number&gt; {
        throw new Error("Method not implemented.");
    }
    getAllResults($limit: number): Promise&lt;Result[]&gt; {
        throw new Error("Method not implemented.");
    }
    
    getResultsByName($name: string, $limit: number): Promise&lt;Result[]&gt; {
        throw new Error("Method not implemented.");
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">SqlRepository</code> class<a id="_idIndexMarker578" class="calibre3"/> implements the <code class="inlinecode">Repository</code> interface, and its constructor prepares the database. The <code class="inlinecode">sqlite3</code> module contains the database API and creates a new <code class="inlinecode">Database</code> object, specifying <code class="inlinecode">age.db</code> as the filename. The <code class="inlinecode">Database</code> object provides methods for using the database and the <code class="inlinecode">exec</code> method is used to execute SQL statements – in this case, to execute the statements in the <code class="inlinecode">age.sql</code> file.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Real projects don’t need to execute SQL to create the database every time, but doing so allows the example to be reset, and it is for this reason that the SQL in <em class="italic">Listing 12.8</em> will drop and recreate the database tables if they already exist. Databases are usually initialized only when an application is deployed, and you can see an example of this in <em class="italic">Part 3</em> of this book.</p>
</div>
<p class="normal">To make the repository available to the rest of the application, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/server/data</code> folder with the content shown in <em class="italic">Listing 12.11</em>.</p>
<p class="packt_figref">Listing 12.11: The contents of the index.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { Repository } from "./repository";
import { SqlRepository } from "./sql_repository";
const repository: Repository = new SqlRepository();
export default repository;
</code></pre>
<p class="normal">This file is responsible for instantiating the repository so that the rest of the application can access data through the <code class="inlinecode">Repository</code> interface without needing to know which implementation has been used.</p>
<h3 class="heading2" id="_idParaDest-210">Querying the database</h3>
<p class="normal1">The next <a id="_idIndexMarker579" class="calibre3"/>step is to implement the methods that provide access to the database, starting with those that query for data. Add a file named <code class="inlinecode">sql_queries.ts</code> to the <code class="inlinecode">src/server/data</code> folder, with the content shown in <em class="italic">Listing 12.12</em>. </p>
<p class="packt_figref">Listing 12.12: The contents of the sql_queries.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">const baseSql = `
    SELECT Results.*, name, age, years, nextage FROM Results
    INNER JOIN People ON personId = People.id
    INNER JOIN Calculations ON calculationId = Calculations.id`;
const endSql = `ORDER BY id DESC LIMIT $limit`;
export const queryAllSql = `${baseSql} ${endSql}`;
export const queryByNameSql = `${baseSql} WHERE name = $name ${endSql}`;
</code></pre>
<p class="normal">SQL queries can be formulated like any other JavaScript string, and my preference is to avoid duplication by defining a base query and then building on it to create the variations needed. In this case, I have defined <code class="inlinecode">baseSql</code> and <code class="inlinecode">endSql</code> strings, which are combined to create queries, so that the query for data matching a name will be as follows:</p>
<pre class="programlisting"><code class="hljs-code">...
SELECT Results.*, name, age, years, nextage FROM Results
    INNER JOIN People ON personId = People.id
    INNER JOIN Calculations ON calculationId = Calculations.id
    WHERE name = $name
    ORDER BY id DESC LIMIT $limit
...
</code></pre>
<p class="normal">These queries use named parameters, which are denoted by a <code class="inlinecode">$</code> sign and allow values to be provided when the query is executed. As I explain in the <em class="italic">Understanding SQL query parameters</em> section, this is a feature that should always be used and is supported by every database package.</p>
<p class="normal">I am not a professional database administrator, and there are more efficient ways to compose queries, but using a database is easier when the queries return data that can be easily parsed to create JavaScript objects. In this case, the queries will return tables of data like this:</p>
<table class="table-container" id="table003-9">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">id</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">calculationId</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">personId</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">name</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">age</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">years</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">nextage</code></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">1</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">1</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">1</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Alice</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">35</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">5</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">40</code></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">3</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">2</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">1</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">Alice</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">35</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">10</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlinecode3">45</code></p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The SQLite <a id="_idIndexMarker580" class="calibre3"/>package will convert the table of data into an array of JavaScript objects whose properties correspond to the table column names, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
{
    id: 1,
    calculationId: 1,
    personId: 1,
    name: "Alice",
    age: 35,
    years: 5,
    nextage: 40
}
...
</code></pre>
<p class="normal">The structure of the data received from the database is a superset of the <code class="inlinecode">Result</code> interface defined in <em class="italic">Listing 12.9</em>, which means that data received from the database can be used without needing further processing. <em class="italic">Listing 12.13</em> uses the SQL defined in <em class="italic">Listing 12.12</em> to query the database. </p>
<p class="packt_figref">Listing 12.13: Querying the database in the sql_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFileSync } from "fs";
import { Database } from "sqlite3";
import { Repository, Result } from "./repository";
<strong class="screentext">import { queryAllSql, queryByNameSql } from</strong><strong class="screentext"> "./sql_queries";</strong>
export class SqlRepository implements Repository {
    db: Database;
    constructor() {
        this.db = new Database("age.db");
        this.db.exec(readFileSync("age.sql").toString(), err =&gt; {
            if (err != undefined) throw err;
        });
    }
    saveResult(r: Result): Promise&lt;number&gt; {
        throw new Error("Method not implemented.");
    }
    getAllResults($limit: number): Promise&lt;Result[]&gt; {
       <strong class="screentext"> return this.executeQuery(queryAllSql, { $limit });</strong>
    }
    
    getResultsByName($name: string, $limit: number): Promise&lt;Result[]&gt; {
       <strong class="screentext"> return this.executeQuery(queryByNameSql, { $name, $limit });</strong>
    }
   <strong class="screentext"> </strong><strong class="screentext">executeQuery(sql: string, params: any) : Promise&lt;Result[]&gt; {</strong>
<strong class="screentext">        return new Promise&lt;Result[]&gt;((resolve, reject</strong><strong class="screentext">) =&gt; {</strong>
<strong class="screentext">            this.db.all&lt;Result&gt;(sql, params, (err, rows) =&gt; {</strong>
<strong class="screentext">                if (err == undefined) {</strong>
<strong class="screentext">                    resolve(rows);</strong>
<strong class="screentext">                } </strong><strong class="screentext">else {</strong>
<strong class="screentext">                    reject(err);</strong>
<strong class="screentext">                }</strong>
<strong class="screentext">            })</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">Database</code> object <a id="_idIndexMarker581" class="calibre3"/>created in the constructor provides methods for querying the database. The <code class="inlinecode">executeQuery</code> method uses the <code class="inlinecode">Database.all</code> method, which executes a SQL query and returns all the rows that the database produces. For quick reference, <em class="italic">Table 12.3</em> describes the most useful methods provided by the <code class="inlinecode">Database</code> class. Most of these methods accept values for query parameters, which I explain in the <em class="italic">Understanding SQL query parameters</em> section. </p>
<p class="packt_figref">Table 12.3: Useful Database Methods </p>
<table class="table-container" id="table004-6">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">run(sql, params, cb)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method executes a SQL statement with an optional set of parameters. No result data is returned. The optional callback function is invoked if there is an error or when execution is complete.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">get&lt;T&gt;(sql, params, cb)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method executes a SQL statement with an optional set of parameters and passes the first result row as an object to the callback function, with type <code class="inlinecode">T</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">all&lt;T&gt;(sql, params, cb)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method executes a SQL statement with an optional set of parameters and passes all result rows to the callback function as an array of type <code class="inlinecode">T</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">prepare(sql)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method creates a prepared statement, which is represented with a <code class="inlinecode">Statement</code> object, and can improve performance because the database doesn’t have to process SQL every time the query is executed. This method does not accept query parameters.</p>
</td>
</tr>
</tbody>
</table>
<h3 class="heading2" id="_idParaDest-211">Displaying data</h3>
<p class="normal1"><em class="italic">Listing 12.14</em> updates <a id="_idIndexMarker582" class="calibre3"/>the code that handles HTTP requests to create an instance of the SQL repository and uses the methods it provides to query the database and pass the results to the template.</p>
<p class="packt_figref">Listing 12.14: Using the repository in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
<strong class="screentext">import repository  from "./data";</strong>
<strong class="screentext">const</strong><strong class="screentext"> rowLimit = 10;</strong>
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    <strong class="screentext">app.get("/form", async (req, resp) =&gt; {</strong>
        resp.render("age", {
           <strong class="screentext"> history: await repository.getAllResults(rowLimit)</strong>
        });
    });
    <strong class="screentext">app.post("/form", async (req, resp) =&gt; {</strong>
        const nextage = Number.parseInt(req.body.age)
            + Number.parseInt(req.body.years);
        const context = {
            ...req.body, nextage,
         <strong class="screentext">   history</strong><strong class="screentext">: await repository.getResultsByName(</strong>
<strong class="screentext">                req.body.name, rowLimit)</strong>
        };
        resp.render("age", context);  
    });
}
</code></pre>
<p class="normal">The <code class="inlinecode">async</code> keyword<a id="_idIndexMarker583" class="calibre3"/> is applied to the handler functions, which allows the use of the <code class="inlinecode">await</code> keyword when calling the repository methods. The results are passed to the template using a property named <code class="inlinecode">history</code>, which is used to populate the table in <em class="italic">Listing 12.15</em>.</p>
<p class="packt_figref">Listing 12.15: Populating the table in the history.handlebars file in the templates/server/partials folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;h4&gt;Recent Queries&lt;/h4&gt;
&lt;table class="table table-sm table-striped my-2"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;th&gt;Years&lt;/th&gt;&lt;th&gt;Result&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{#unless history }}
            &lt;tr&gt;&lt;td colspan="4"&gt;No data available&lt;/td&gt;&lt;/tr&gt;
        {{/unless }}
        <strong class="screentext">{{#each history }}</strong>
<strong class="screentext"> </strong><strong class="screentext">&lt;tr&gt;</strong>
<strong class="screentext">                &lt;td&gt;{{ this.name }} &lt;/td&gt;</strong>
<strong class="screentext">                &lt;td&gt;{{ this.age }} &lt;/td&gt;</strong>
<strong class="screentext"> </strong><strong class="screentext">&lt;td&gt;{{ this.years }} &lt;/td&gt;</strong>
<strong class="screentext">                &lt;td&gt;{{ this.nextage }} &lt;/td&gt;</strong>
<strong class="screentext">            &lt;/tr&gt;</strong>
<strong class="screentext">        {{/each }}</strong>
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p class="normal">Use a browser to <a id="_idIndexMarker584" class="calibre3"/>request <code class="inlinecode">http://localhost:5000/form</code> and you will see that the right-hand side shows data from all users. Fill out and submit the form and only queries from that user will be displayed, as shown in <em class="italic">Figure 12.2</em>. The queries in the database from other users are no longer shown.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_12_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 12.2: Querying the database</p>
<h2 class="heading1" id="_idParaDest-212">Understanding SQL query parameters</h2>
<p class="normal1">Care must <a id="_idIndexMarker585" class="calibre3"/>be taken when including values <a id="_idIndexMarker586" class="calibre3"/>received from users in SQL queries. As a demonstration, <em class="italic">Listing 12.16</em> alters the implementation of the <code class="inlinecode">getResultsByName</code> defined by the <code class="inlinecode">SQLRepository</code> class. </p>
<p class="packt_figref">Listing 12.16: Including user input in the sql_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">...
getResultsByName($name: string, $limit: number): Promise&lt;Result[]&gt; {
    <strong class="screentext">return this.executeQuery</strong><strong class="screentext">(`</strong>
<strong class="screentext">        SELECT Results.*, name, age, years, nextage FROM Results</strong>
<strong class="screentext">        INNER JOIN People ON personId = People.id</strong>
<strong class="screentext">        INNER JOIN Calculations ON calculationId = Calculations.id</strong>
<strong class="screentext">        WHERE name = "${$name}"`, {});</strong>
}
...
</code></pre>
<p class="normal">The mistake <a id="_idIndexMarker587" class="calibre3"/>being made in this example is to include the value received from the form directly in the query. If the user enters <code class="inlinecode">Alice</code> into the form, then the query will look like this:</p>
<pre class="programlisting"><code class="hljs-code">...
SELECT Results.*, name, age, years, nextage FROM Results
        INNER JOIN People ON personId = People.id
        INNER JOIN Calculations ON calculationId = Calculations.id
        WHERE name = "Alice"
...
</code></pre>
<p class="normal">This is the<a id="_idIndexMarker588" class="calibre3"/> anticipated behavior, and it retrieves the queries made using that name. But it is easy to craft strings that alter the query. If the user enters <code class="inlinecode">Alice" or name = "Bob</code>, for example, then the query will look like this:</p>
<pre class="programlisting"><code class="hljs-code">...
SELECT Results.*, name, age, years, nextage FROM Results
        INNER JOIN People ON personId = People.id
        INNER JOIN Calculations ON calculationId = Calculations.id
        WHERE name = "Alice" OR name = "Bob"
...
</code></pre>
<p class="normal">This isn’t what the developer expects, and it means that queries made by two users are displayed, as shown in <em class="italic">Figure 12.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_12_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 12.3: Executing a query with user input</p>
<p class="normal">This is a <a id="_idIndexMarker589" class="calibre3"/>benign example, but it shows that including user-supplied values directly in queries <a id="_idIndexMarker590" class="calibre3"/>allows malicious users to change how queries are processed. This problem isn’t addressed by the HTML sanitization described in <em class="italic">Chapter 11</em> because the values are not sanitized until they are included in a response. Instead, databases provide support for <em class="italic">query parameters</em>, which allow values to be inserted into queries safely.</p>
<p class="normal">The parameter is defined in the SQL query and is denoted with an initial <code class="inlinecode">$</code> character, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
export const queryByNameSql = `${baseSql} WHERE name = <strong class="screentext">$name</strong> ${endSql}`;
...
</code></pre>
<p class="normal">This statement is combined with the base query, which means that the overall SQL statement looks like this:</p>
<pre class="programlisting"><code class="hljs-code">...
SELECT Results.*, name, age, years, nextage FROM Results
    INNER JOIN People ON personId = People.id
    INNER JOIN Calculations ON calculationId = Calculations.id
    WHERE name = <strong class="screentext">$name</strong> ORDER BY id DESC LIMIT <strong class="screentext">$limit</strong>
...
</code></pre>
<p class="normal">The two query<a id="_idIndexMarker591" class="calibre3"/> parameters are marked in bold, and<a id="_idIndexMarker592" class="calibre3"/> they indicate values that will be supplied when the statement is executed by the <code class="inlinecode">executeQuery</code> method in the <code class="inlinecode">SqlRepository</code> class:</p>
<pre class="programlisting"><code class="hljs-code">...
executeQuery(sql: string, <strong class="screentext">params</strong>: any) : Promise&lt;Result[]&gt; {
    return new Promise&lt;Result[]&gt;((resolve, reject) =&gt; {
        this.db.all&lt;RowResult&gt;(sql, <strong class="screentext">params</strong>, (err, rows) =&gt; {
            if (err == undefined) {
                resolve(rowsToObjects(rows));
            } else {
                reject(err);
            }
        })
    });
}
...
</code></pre>
<p class="normal"><em class="italic">Listing 12.17</em> reverts the changes to the <code class="inlinecode">SqlRepository</code> class so that the query performed by the <code class="inlinecode">getResultsByName</code> method uses the <code class="inlinecode">executeQuery</code> method and provides query parameters.</p>
<p class="packt_figref">Listing 12.17: Using query parameters in the sql_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">...
getResultsByName($name: string, $limit: number): Promise&lt;Result[]&gt; {
    <strong class="screentext">return this.executeQuery(queryByNameSql, { $name, $limit });</strong>
}
...
</code></pre>
<p class="normal">The object that contains the parameter values has property names that match the parameters in the SQL statement: <code class="inlinecode">$name</code> and <code class="inlinecode">$limit</code>. The <code class="inlinecode">$</code> sign isn’t the only way to denote a<a id="_idIndexMarker593" class="calibre3"/> query parameter in SQL, but it works well with<a id="_idIndexMarker594" class="calibre3"/> JavaScript because the <code class="inlinecode">$</code> sign is allowed in variable names. It is for this reason that the <code class="inlinecode">getResultsByName</code> method defines <code class="inlinecode">$name</code> and <code class="inlinecode">$limit</code> parameters, allowing the values to be passed along without needing to alter the names.</p>
<p class="normal">The last piece of the puzzle is provided by the code that handles the form data:</p>
<pre class="programlisting"><code class="hljs-code">...
const context = {
    ...req.body, nextage,
    history: await repository.getResultsByName(<strong class="screentext">req.body.name</strong>, rowLimit)
};
...
</code></pre>
<p class="normal">The value the user entered for the name field in the form is read from the body and used as the value for the <code class="inlinecode">$name</code> query parameter. The methods described in <em class="italic">Table 12.3</em> automatically sanitize query parameters, so they do not alter the way the query is executed, as shown in <em class="italic">Figure 12.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_12_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 12.4: The effect of a sanitized query parameter</p>
<h2 class="heading1" id="_idParaDest-213">Writing to the database</h2>
<p class="normal1">The next step <a id="_idIndexMarker595" class="calibre3"/>is to write data so that the database contains more than just the seed data added when the database is created. <em class="italic">Listing 12.18</em> defines SQL statements that will insert rows into the database tables. </p>
<p class="packt_figref">Listing 12.18: Adding statements in the sql_queries.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">const baseSql = `
    SELECT Results.*, name, age, years, nextage FROM Results
    INNER JOIN People ON personId = People.id
    INNER JOIN Calculations ON calculationId = Calculations.id`;
const endSql = `ORDER BY id DESC LIMIT $limit`;
export const queryAllSql = `${baseSql} ${endSql}`;
export const queryByNameSql = `${baseSql} WHERE name = $name ${endSql}`;
<strong class="screentext">export const insertPerson = `</strong>
<strong class="screentext">    INSERT INTO People (name)</strong>
<strong class="screentext">    SELECT $name</strong>
<strong class="screentext">    WHERE NOT EXISTS (SELECT name FROM People WHERE name = $name)`;</strong>
<strong class="screentext">export const insertCalculation = `</strong>
<strong class="screentext">    INSERT INTO Calculations (age, years, nextage)</strong>
<strong class="screentext">    SELECT $age, $years, $nextage</strong>
<strong class="screentext">    WHERE NOT EXISTS</strong>
<strong class="screentext">	    (SELECT age, years, nextage FROM Calculations</strong>
<strong class="screentext">            WHERE age = $age AND years = $years AND nextage = $nextage)`;</strong>
<strong class="screentext">export const</strong><strong class="screentext"> insertResult = `</strong>
<strong class="screentext">    INSERT INTO Results (personId, calculationId)</strong>
<strong class="screentext">    SELECT People.id as personId, Calculations.id as calculationId from People</strong>
<strong class="screentext">	CROSS JOIN Calculations</strong>
<strong class="screentext">	    WHERE People.name = $name</strong>
<strong class="screentext">		AND Calculations.age = $age</strong>
<strong class="screentext">		AND Calculations.years = $years</strong>
<strong class="screentext">		AND Calculations.nextage = $nextage`;</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">insertPerson</code> and <code class="inlinecode">insertCalculation</code> statements will insert new rows in the <code class="inlinecode">People</code> and <code class="inlinecode">Calculation</code> tables only if there are no existing rows that have the same details. The <code class="inlinecode">insertResult</code> statement creates a row in the <code class="inlinecode">Results</code> table, with references to the other tables.</p>
<p class="normal">These statements<a id="_idIndexMarker596" class="calibre3"/> need to be executed within a transaction to ensure consistency. The SQLite database engine supports transactions, but these are not exposed conveniently to Node.js and additional work is required to run SQL statements in a transaction. Add a file named <code class="inlinecode">sql_helpers.ts</code> to the <code class="inlinecode">src/server/data</code> folder with the content shown in <em class="italic">Listing 12.19</em>.</p>
<p class="packt_figref">Listing 12.19: The contents of the sql_helpers.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { Database } from "sqlite3";
export class TransactionHelper {
    steps: [sql: string, params: any][] = [];
    add(sql: string, params: any): TransactionHelper {
        this.steps.push([sql, params]);
        return this;
    }
    run(db: Database): Promise&lt;number&gt; {
        return new Promise((resolve, reject) =&gt; {
            let index = 0;
            let lastRow: number = NaN;
            const cb = (err: any, rowID?: number) =&gt; {
                if (err) {
                    db.run("ROLLBACK", () =&gt; reject());
                } else {
                    lastRow = rowID ? rowID : lastRow;
                    if (++index === this.steps.length) {
                        db.run("COMMIT", () =&gt; resolve(lastRow));
                    } else {
                        this.runStep(index, db, cb);
                    }
                }
            }
            db.run("BEGIN", () =&gt; this.runStep(0, db, cb));
        }); 
    }
    runStep(idx: number, db: Database, cb: (err: any, row: number) =&gt; void) {
        const [sql, params] = this.steps[idx];
        db.run(sql, params, function (err: any) {
            cb(err, this.lastID)
        });
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">TransactionHelper</code> class defines an <code class="inlinecode">add</code> method that is used to build up a list of SQL statements and query parameters. When the <code class="inlinecode">run</code> method is called, the <code class="inlinecode">BEGIN</code> command is sent to SQLite, and each of the SQL statements is run. If all the statements execute successfully, the <code class="inlinecode">COMMIT</code> command is sent, and SQLite applies the changes <a id="_idIndexMarker597" class="calibre3"/>to the database. The <code class="inlinecode">ROLLBACK</code> command is sent if any of the statements fail and SQLite abandons the changes made by earlier statements. SQLite provides the ID of the row modified by <code class="inlinecode">INSERT</code> statements, and the <code class="inlinecode">run</code> method returns the value produced by the most recent statement. Knowing the ID of the most recently inserted row is generally a good idea because it makes it easy to query for new data, as <em class="italic">Chapter 14</em> will demonstrate.</p>
<p class="normal"><em class="italic">Listing 12.20</em> uses the <code class="inlinecode">TransactionHelper</code> class to perform an update by running the three statements from <em class="italic">Listing 12.18</em> within a SQL transaction.</p>
<p class="packt_figref">Listing 12.20: Inserting data in the sql_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFileSync } from "fs";
import { Database } from "sqlite3";
import { Repository, Result } from "./repository";
<strong class="screentext">import { queryAllSql, queryByNameSql,</strong>
<strong class="screentext">    insertPerson, insertCalculation, insertResult } from "./sql_queries";</strong>
<strong class="screentext">import { TransactionHelper } from "./sql_helpers";</strong>
export class SqlRepository implements Repository {
    db: Database;
    constructor() {
        this.db = new Database("age.db");
        this.db.exec(readFileSync("age.sql").toString(), err =&gt; {
            if (err != undefined) throw err;
        });
    }
    async saveResult(r: Result): Promise&lt;number&gt; {
       <strong class="screentext"> return await new</strong><strong class="screentext"> TransactionHelper()</strong>
<strong class="screentext">            .add(insertPerson, { $name: r.name })</strong>
<strong class="screentext">            .add(insertCalculation, {</strong>
<strong class="screentext">                    $age: r.age, $years: r.years, $nextage</strong><strong class="screentext">: r.nextage</strong>
<strong class="screentext">            })</strong>
<strong class="screentext">            .add(insertResult, {</strong>
<strong class="screentext">                $name: r.name,</strong>
<strong class="screentext">                $age: r.age, $years: r.years, $nextage: r.nextage</strong>
<strong class="screentext">            })</strong>
<strong class="screentext">            .run(this.db);       </strong>
    }
    getAllResults($limit: number): Promise&lt;Result[]&gt; {
        return this.executeQuery(queryAllSql, { $limit });
    }
    
    getResultsByName($name: string, $limit: number): Promise&lt;Result[]&gt; {
        return this.executeQuery(queryByNameSql, { $name, $limit });
    }
    executeQuery(sql: string, params: any) : Promise&lt;Result[]&gt; {
        return new Promise&lt;Result[]&gt;((resolve, reject) =&gt; {
            this.db.all&lt;Result&gt;(sql, params, (err, rows) =&gt; {
                if (err == undefined) {
                    resolve(rows);
                } else {
                    reject(err);
                }
            })
        });
    }
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker598" class="calibre3"/>implementation of the <code class="inlinecode">saveResult</code> method executes the three SQL statements. Each statement requires a separate object for its query parameters because SQLite produces an error if there are unused properties in the parameters object. <em class="italic">Listing 12.21</em> updates the handler for HTTP POST requests to write data to the database through the repository.</p>
<p class="packt_figref">Listing 12.21: Writing data in the forms.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import express, { Express } from "express";
import repository  from "./data";
const rowLimit = 10;
export const registerFormMiddleware = (app: Express) =&gt; {
    app.use(express.urlencoded({extended: true}))
}
export const registerFormRoutes = (app: Express) =&gt; {
    app.get("/form", async (req, resp) =&gt; {
        resp.render("age", {
            history: await repository.getAllResults(rowLimit)
        });
    });
    app.post("/form", async (req, resp) =&gt; {
        const nextage = Number.parseInt(req.body.age)
            + Number.parseInt(req.body.years);
<strong class="screentext">        await repository.saveResult({...req.body, nextage });</strong>
        const context = {
            ...req.body, nextage,
            history: await repository.getResultsByName(
                req.body.name, rowLimit)
        };
        resp.render("age", context);  
    });
}
</code></pre>
<p class="normal">Using <a id="_idIndexMarker599" class="calibre3"/>consistent names for each part of the application means that the request body can be used as the basis for the <code class="inlinecode">Result</code> interface expected by the repository. The effect is that each new request is stored in the database and reflected in the response presented to the user, as shown in <em class="italic">Figure 12.5</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_12_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 12.5: Writing data to the database</p>
<h1 class="heading" id="_idParaDest-214">Using an ORM package</h1>
<p class="normal1">The advantage <a id="_idIndexMarker600" class="calibre3"/>of working directly with the database is that you have control over how every statement is written and executed. The drawback is that can be a complex and time-consuming process. </p>
<p class="normal">An alternative is<a id="_idIndexMarker601" class="calibre3"/> to use an ORM package that deals with the database on behalf of the developer, hiding some aspects of SQL and taking care of mapping between the database and JavaScript objects.</p>
<p class="normal">The range of features provided by ORM packages varies widely. Some take a light-touch approach and focus on transforming data, but most packages deal with most aspects of using a database, including defining the SQL schema, creating the database, and even generating queries.</p>
<p class="normal">ORM packages can be great, but you still have to have a basic understanding of SQL, which is why I started this chapter with a direct-to-database example. ORM packages expect the developer to understand how their features will be used to create and use databases, and you won’t be able to get useful results or diagnose problems without some SQL skills.</p>
<div><p class="normal"><strong class="screentext">The Argument for Object Databases</strong></p>
<p class="normal">An alternative to using SQL and an ORM package is to use a database that stores objects directly, such as MongoDB (<a href="https://www.mongodb.com" class="calibre3">https://www.mongodb.com</a>). The reason that I have not covered object databases in this book is that most projects use relational databases, and most companies standardize on a specific relational database engine. Object databases can be a good choice, but they are not the technology that most developers end up using. SQL databases remain dominant, even though there are some excellent alternatives available.</p>
</div>
<p class="normal">The ORM package <a id="_idIndexMarker602" class="calibre3"/>that I use in this chapter is called Sequelize (<a href="https://www.npmjs.com/package/sequelize" class="calibre3">https://www.npmjs.com/package/sequelize</a>), which is the most popular JavaScript <a id="_idIndexMarker603" class="calibre3"/>ORM package. Sequelize has a comprehensive set of features and supports the most popular database engines, including SQLite.</p>
<p class="normal">Run the command shown in <em class="italic">Listing 12.22</em> in the <code class="inlinecode">part2app</code> folder to install the Sequelize package, which includes TypeScript type information. </p>
<p class="packt_figref">Listing 12.22: Installing the ORM packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install sequelize@6.35.1
</code></pre>
<h2 class="heading1" id="_idParaDest-215">Defining the database using JavaScript objects</h2>
<p class="normal1">When <a id="_idIndexMarker604" class="calibre3"/>working directly with a database, the first step is to write the SQL statements that create the tables and the relationships between them, which is how this chapter started. When using an ORM, the database is described using JavaScript objects. Each ORM package has its own process and, for Sequelize, three steps are required.</p>
<h3 class="heading2" id="_idParaDest-216">Creating the model classes</h3>
<p class="normal1">The first<a id="_idIndexMarker605" class="calibre3"/> step is to define the classes that will represent the data in the database. Add a file named <code class="inlinecode">orm_models.ts</code> to the <code class="inlinecode">src/server/data</code> folder, with the content shown in <em class="italic">Listing 12.23</em>. </p>
<p class="packt_figref">Listing 12.23: The contents of the orm_models.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { Model, CreationOptional, ForeignKey, InferAttributes,</strong>
<strong class="screentext">    InferCreationAttributes  } </strong><strong class="screentext">from "sequelize";</strong>
<strong class="screentext">export class Person extends Model&lt;InferAttributes&lt;Person&gt;,</strong>
<strong class="screentext">        InferCreationAttributes&lt;</strong><strong class="screentext">Person&gt;&gt; {</strong>
<strong class="screentext">    declare id?: CreationOptional&lt;number&gt;;</strong>
<strong class="screentext">    declare name: string</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export class Calculation extends Model&lt;InferAttributes&lt;Calculation&gt;,</strong>
<strong class="screentext"> </strong><strong class="screentext">InferCreationAttributes&lt;Calculation&gt;&gt; {</strong>
<strong class="screentext">    declare id?: CreationOptional&lt;number&gt;;           </strong>
<strong class="screentext">    declare age: number;</strong>
<strong class="screentext">    declare years: number;</strong>
<strong class="screentext">    declare nextage: number;</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export class ResultModel extends </strong><strong class="screentext">Model&lt;InferAttributes&lt;ResultModel&gt;,</strong>
<strong class="screentext">        InferCreationAttributes&lt;ResultModel&gt;&gt; {</strong>
<strong class="screentext">    declare id: CreationOptional&lt;number&gt;;          </strong>
<strong class="screentext">    declare personId: ForeignKey&lt;Person["</strong><strong class="screentext">id"]&gt;;</strong>
<strong class="screentext">    declare calculationId: ForeignKey&lt;Calculation["id"]&gt;;</strong>
<strong class="screentext">    declare Person?: InferAttributes&lt;Person&gt;;</strong>
<strong class="screentext">    declare Calculation?: InferAttributes&lt;</strong><strong class="screentext">Calculation&gt;;</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">Sequelize will use each class to create a database table and each property will be a column in that table. These classes also describe the data in the database to the TypeScript compiler.</p>
<p class="normal">All the <a id="_idIndexMarker606" class="calibre3"/>class properties in <em class="italic">Listing 12.23</em> are defined with the <code class="inlinecode">declare</code> keyword, which tells the TypeScript compiler to behave as though the properties have been defined but not to include those properties in the compiled JavaScript. This is important because Sequelize will add getters and setters to objects to provide access to data, and defining properties conventionally will prevent that feature from working properly.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The names of the model classes should be meaningful. I have chosen <code class="inlinecode">Person</code> and <code class="inlinecode">Calculation</code>, which are obvious enough, but I have used <code class="inlinecode">ResultModel</code> to avoid conflicting with the name of the type used by the <code class="inlinecode">Repository</code> interface.</p>
</div>
<p class="normal">Class properties whose type is a regular JavaScript type will be represented by regular columns in the database, such as the <code class="inlinecode">name</code> property defined by the <code class="inlinecode">Person</code> class:</p>
<pre class="programlisting"><code class="hljs-code">...
export class Person extends Model&lt;InferAttributes&lt;Person&gt;,
        InferCreationAttributes&lt;Person&gt;&gt; {
    declare id?: CreationOptional&lt;number&gt;;
    <strong class="screentext">declare name: string</strong>
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">CreationOptional&lt;T&gt;</code> type is used to describe a property that doesn’t have to be supplied when a new instance of the model class is created, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
<strong class="screentext">export class Person extends Model</strong><strong class="screentext">&lt;InferAttributes&lt;Person&gt;,</strong>
<strong class="screentext">        InferCreationAttributes&lt;Person&gt;&gt; {</strong>
<strong class="screentext"> </strong>declare id?: CreationOptional&lt;number&gt;;
    declare name: string
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">id</code> property represents the primary key for a <code class="inlinecode">Person</code> object when it is stored as a row in a database table. The database will be configured to automatically assign a key when a new row is stored, and so using the <code class="inlinecode">CreationOptional&lt;number&gt;</code> type will prevent TypeScript from reporting an error when a <code class="inlinecode">Person</code> object is created without an <code class="inlinecode">id</code> value.</p>
<p class="normal">The base <a id="_idIndexMarker607" class="calibre3"/>class is used to build a list of the properties defined by the class, which are used to enforce type safety when data is read or written:</p>
<pre class="programlisting"><code class="hljs-code">...
<strong class="screentext">export class Person extends Model&lt;InferAttributes&lt;Person</strong><strong class="screentext">&gt;,</strong>
<strong class="screentext">        InferCreationAttributes&lt;Person&gt;&gt; {</strong>
    declare id?: CreationOptional&lt;number&gt;;
    declare name: string
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">InferAttributes&lt;Person&gt;</code> type selects all of the properties defined by the <code class="inlinecode">Person</code> class, while the <code class="inlinecode">InferCreationAttributes&lt;Person&gt;</code> type excludes the properties whose type is <code class="inlinecode">CreationOptional&lt;T&gt;</code>. The model classes also contain properties for representing relationships between tables in the database:</p>
<pre class="programlisting"><code class="hljs-code">...
export class ResultModel extends Model&lt;InferAttributes&lt;ResultModel&gt;,
        InferCreationAttributes&lt;ResultModel&gt;&gt; {
    declare id: CreationOptional&lt;number&gt;;          
<strong class="screentext">    declare personId: ForeignKey&lt;Person["id"]&gt;;</strong>
<strong class="screentext">    declare calculationId: ForeignKey&lt;Calculation["id"]&gt;;</strong>
<strong class="screentext">    declare Person?: InferAttributes&lt;Person&gt;;</strong>
<strong class="screentext">    declare Calculation?: InferAttributes&lt;Calculation&gt;;</strong>
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">personId</code> and <code class="inlinecode">calculationId</code> properties will store the primary keys of related data, while<a id="_idIndexMarker608" class="calibre3"/> the <code class="inlinecode">Person</code> and <code class="inlinecode">Calculation</code> properties will be populated with objects created by Sequelize, as part of the process of making data available as objects.</p>
<h3 class="heading2" id="_idParaDest-217">Initializing the data model</h3>
<p class="normal1">The <a id="_idIndexMarker609" class="calibre3"/>next step is to tell Sequelize how each property defined by the model classes should be represented in the database. Add a file named <code class="inlinecode">orm_helpers.ts</code> to the <code class="inlinecode">src/server/data</code> folder, with the content shown in <em class="italic">Listing 12.24</em>.</p>
<p class="packt_figref">Listing 12.24: The contents of the orm_helpers.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, Sequelize } from "sequelize";
import { Calculation, Person, ResultModel } from "./orm_models";
const primaryKey = {
    id: {
        type: DataTypes.INTEGER,
        autoIncrement: true,
        primaryKey: true
    }       
};
export const initializeModels = (sequelize: Sequelize) =&gt; {
    Person.init({
        ...primaryKey,
        name: { type: DataTypes.STRING }
    }, { sequelize });
    Calculation.init({
        ...primaryKey,
        age: { type: DataTypes.INTEGER},
        years: { type: DataTypes.INTEGER},
        nextage: { type: DataTypes.INTEGER},
    }, { sequelize });
    ResultModel.init({
        ...primaryKey,
    }, { sequelize });
}
</code></pre>
<p class="normal">The <code class="inlinecode">Model</code> base class used in <em class="italic">Listing 12.24</em> defines the <code class="inlinecode">init</code> method, which accepts <a id="_idIndexMarker610" class="calibre3"/>an object whose properties correspond to those defined by the class. Each property is assigned a configuration object that tells Sequelize how to represent the data in the database.</p>
<p class="normal">All three model classes have an <code class="inlinecode">id</code> property that is configured as the primary key. For the other properties, a value from the <code class="inlinecode">DataTypes</code> class is selected to specify the SQL data type that will be used when the database is created.</p>
<p class="normal">The second argument accepted by the <code class="inlinecode">init</code> method is used to configure the overall data model. Only the <code class="inlinecode">sequelize</code> property is specified in <em class="italic">Listing 12.24</em>, which is a <code class="inlinecode">Sequelize</code> object that will be created to manage the database. Other options are available, allowing the name of the database table to be changed, setting up database triggers, and configuring other database features.</p>
<h3 class="heading2" id="_idParaDest-218">Configuring the model relationships</h3>
<p class="normal1">The <code class="inlinecode">Model</code> base <a id="_idIndexMarker611" class="calibre3"/>class provides methods to describe the relationships between model classes, as shown in <em class="italic">Listing 12.25</em>. </p>
<p class="packt_figref">Listing 12.25: Defining model relationships in the orm_helpers.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, Sequelize } from "sequelize";
import { Calculation, Person, ResultModel } from "./orm_models";
const primaryKey = {
    id: {
        type: DataTypes.INTEGER,
        autoIncrement: true,
        primaryKey: true
    }       
};
export const initializeModels = (sequelize: Sequelize) =&gt; {
    // ...statements omitted for brevity...
}
<strong class="screentext">export const defineRelationships = () =&gt; {</strong>
<strong class="screentext">    ResultModel.belongsTo(Person, { foreignKey: "personId" });</strong>
<strong class="screentext">    ResultModel.belongsTo</strong><strong class="screentext">(Calculation, { foreignKey: "calculationId"});</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">Sequelize defines four kinds of <em class="italic">association</em>, which are used to describe the relationship between data model classes, as described in <em class="italic">Table 12.4</em>.</p>
<p class="packt_figref">Table 12.4: The Sequelize association methods</p>
<table class="table-container" id="table005-5">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">hasOne(T, options)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method denotes a one-to-one relationship between the model class and <code class="inlinecode">T</code>, with the foreign key defined on <code class="inlinecode">T</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">belongsTo(T, options)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method denotes a one-to-one relationship between the model class and <code class="inlinecode">T</code>, with the foreign key defined by the model class.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">hasMany(T, options)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method denotes a one-to-many relationship, with the foreign key defined by <code class="inlinecode">T</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">belongsToMany(T, options)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method denotes a many-to-many relationship using a junction table. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Each of the methods defined in <em class="italic">Table 12.4</em> accepts an options argument that is used to <a id="_idIndexMarker612" class="calibre3"/>configure the relationship. In <em class="italic">Listing 12.25</em>, the <code class="inlinecode">foreignKey</code> property is used to specify the foreign key on the <code class="inlinecode">ResultModel</code> class for the one-to-one relationships with the <code class="inlinecode">Person</code> and <code class="inlinecode">Calculation</code> types. (There are other options, described at <a href="https://sequelize.org/api/v6/identifiers.html#associations" class="calibre3">https://sequelize.org/api/v6/identifiers.html#associations</a>, and you can see a more complex example in <em class="italic">Chapter 15</em>, which uses a many-to-many relationship.)</p>
<h2 class="heading1" id="_idParaDest-219">Defining the seed data</h2>
<p class="normal1">Although <a id="_idIndexMarker613" class="calibre3"/>ORM packages take care of a lot of the details, there can be tasks that are more easily performed simply by executing SQL expressions directly, rather than using JavaScript objects. To demonstrate, <em class="italic">Listing 12.26</em> uses SQL to seed the database. (Later chapters show seeding databases using JavaScript objects so you can compare techniques.)</p>
<p class="packt_figref">Listing 12.26: Adding seed data in the orm_helpers.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, Sequelize } from "sequelize";
import { Calculation, Person, ResultModel } from "./orm_models";
import { Result } from "./repository";
const primaryKey = {
    id: {
        type: DataTypes.INTEGER,
        autoIncrement: true,
        primaryKey: true
    }       
};
// ...statements omitted for brevity...
export const defineRelationships = () =&gt; {
    ResultModel.belongsTo(Person, { foreignKey: "personId" });
    ResultModel.belongsTo(Calculation, { foreignKey: "calculationId"});
}
<strong class="screentext">export const addSeedData = async (sequelize: Sequelize</strong><strong class="screentext">) =&gt; {</strong>
<strong class="screentext">    await sequelize.query(`</strong>
<strong class="screentext">        INSERT INTO Calculations</strong>
<strong class="screentext">            (id, age, years, nextage, createdAt, updatedAt) VALUES</strong>
<strong class="screentext">                (1, 35, 5, 40, date(), date()),</strong>
<strong class="screentext">                (2, 35, 10, 45, date(), date())`);</strong>
<strong class="screentext">    await sequelize.query(`</strong>
<strong class="screentext">        INSERT INTO People (id, name, createdAt, updatedAt) VALUES</strong>
<strong class="screentext">            (1, 'Alice', date(), date()), (2, "Bob", date(), date())`);</strong>
<strong class="screentext">    await sequelize.query</strong><strong class="screentext">(`</strong>
<strong class="screentext">        INSERT INTO ResultModels</strong>
<strong class="screentext">                (calculationId, personId, createdAt, updatedAt) VALUES</strong>
<strong class="screentext">            (1, 1, date(), date()), (2, 2, date(), date()),</strong>
<strong class="screentext">            (2, 1, date(), date());`);</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">Sequelize.query</code> method accepts a string containing an SQL statement. The statements in <em class="italic">Listing 12.26</em> create the same seed data used earlier in the chapter but with <a id="_idIndexMarker614" class="calibre3"/>the addition of values for <code class="inlinecode">createdAt</code> and <code class="inlinecode">updatedAt</code> columns. One consequence of using an ORM package to create a database is that additional features and constraints are often introduced and Sequelize adds these columns to keep track of when table rows are created and modified. The queries that create the seed data use the <code class="inlinecode">date()</code> function, which returns the current date and time.</p>
<h2 class="heading1" id="_idParaDest-220">Converting data models to flat objects</h2>
<p class="normal1">Using<a id="_idIndexMarker615" class="calibre3"/> JavaScript objects to represent data can be a more natural development experience, but it can mean that the data model objects are not in the format expected elsewhere in the application. In the case of the example application, the ORM data model objects do not conform to the requirements of the <code class="inlinecode">Result</code> type used by the <code class="inlinecode">Repository</code> interface. One approach would be to modify the interface, but this would undermine the benefit of isolating the database from the rest of the application. <em class="italic">Listing 12.27</em> defines a function that transforms <code class="inlinecode">ResultModel</code> objects provided by the ORM package into <code class="inlinecode">Result</code> objects required by the <code class="inlinecode">Repository</code> interface. </p>
<p class="packt_figref">Listing 12.27: Transforming data in the orm_helpers.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, Sequelize } from "sequelize";
import { Calculation, Person, ResultModel } from "./orm_models";
<strong class="screentext">import { Result } from "./repository";</strong>
const primaryKey = {
    id: {
        type: DataTypes.INTEGER,
        autoIncrement: true,
        primaryKey: true
    }       
};
// ...functions omitted for brevity...
<strong class="screentext">export const fromOrmModel = (model: ResultModel | null) : Result =&gt; {</strong>
<strong class="screentext">    return {</strong>
<strong class="screentext">        id: model?.id || 0</strong><strong class="screentext">,</strong>
<strong class="screentext">        name: model?.Person?.name || "",</strong>
<strong class="screentext">        age: model?.Calculation?.age || 0,</strong>
<strong class="screentext">        years: model?.Calculation</strong><strong class="screentext">?.years || 0,</strong>
<strong class="screentext">        nextage: model?.Calculation?.nextage || 0</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">This kind <a id="_idIndexMarker616" class="calibre3"/>of transformation can seem clunky, but JavaScript makes it easy to compose new objects in this way, and it is a useful technique that eases integration between modules and packages, which is something that most JavaScript projects have to deal with.</p>
<h2 class="heading1" id="_idParaDest-221">Implementing the repository</h2>
<p class="normal1">The <a id="_idIndexMarker617" class="calibre3"/>plumbing is all in place and it is time to implement the <code class="inlinecode">Repository</code> interface. Add a file named <code class="inlinecode">orm_repository.ts</code> to the <code class="inlinecode">src/server/data</code> folder with the content shown in <em class="italic">Listing 12.28</em>, which sets up the ORM but doesn’t yet implement queries or store data.</p>
<p class="packt_figref">Listing 12.28: The contents of the orm_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { Sequelize } from "sequelize";</strong>
<strong class="screentext">import { Repository, Result } from</strong><strong class="screentext"> "./repository";</strong>
<strong class="screentext">import { addSeedData, defineRelationships,</strong>
<strong class="screentext">    fromOrmModel, initializeModels } from "./orm_helpers";</strong>
<strong class="screentext">import { Calculation, Person, ResultModel } from "./orm_models"</strong><strong class="screentext">;</strong>
<strong class="screentext">export class OrmRepository implements Repository {</strong>
<strong class="screentext">    sequelize: Sequelize;</strong>
<strong class="screentext">    constructor() {</strong>
<strong class="screentext">        this.sequelize = new</strong><strong class="screentext"> Sequelize({</strong>
<strong class="screentext">            dialect: "sqlite",</strong>
<strong class="screentext">            storage: "orm_age.db",</strong>
<strong class="screentext">            logging: console.log,</strong>
<strong class="screentext">            logQueryParameters: true</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">        this.initModelAndDatabase();</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    async initModelAndDatabase() : Promise&lt;void&gt; {</strong>
<strong class="screentext">        initializeModels(this.sequelize);</strong>
<strong class="screentext">        defineRelationships</strong><strong class="screentext">();</strong>
<strong class="screentext">        await this.sequelize.drop();       </strong>
<strong class="screentext">        await this.sequelize.sync();</strong>
<strong class="screentext">        await addSeedData</strong><strong class="screentext">(this.sequelize);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    async saveResult(r: Result): Promise&lt;number&gt; {</strong>
<strong class="screentext">        throw new Error</strong><strong class="screentext">("Method not implemented.");</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    async getAllResults(limit: number): Promise&lt;Result[]&gt; {</strong>
<strong class="screentext">        throw new Error("Method not implemented."</strong><strong class="screentext">);      </strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    async getResultsByName(name: string, limit: number): Promise&lt;Result[]&gt; {</strong>
<strong class="screentext">        throw new Error("Method not implemented."</strong><strong class="screentext">);      </strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">Sequelize supports a range of database engines, including SQLite, and so the first step is to create a <code class="inlinecode">Sequelize</code> object, providing a configuration object that specifies the database engine, and the options for its use. In <em class="italic">Listing 12.28</em>, the <code class="inlinecode">dialect</code> option specifies SQLite and the <code class="inlinecode">storage</code> option specifies the name of the file. When using an ORM, it can be useful to see the SQL queries that are generated, which is why the <code class="inlinecode">logging</code> and <code class="inlinecode">logQueryParameters</code> options are set.</p>
<p class="normal">Once a <code class="inlinecode">Sequelize</code> object has been created, it can be configured. The <code class="inlinecode">initModelAndDatabase</code> method calls the <code class="inlinecode">initializeModels</code> and <code class="inlinecode">defineRelationships</code> functions to configure the data model objects, and then calls these methods:</p>
<pre class="programlisting"><code class="hljs-code">...
await this.sequelize.drop();       
await this.sequelize.sync();
...
</code></pre>
<p class="normal">The <code class="inlinecode">drop</code> method tells Sequelize to drop the tables in the database. This isn’t something <a id="_idIndexMarker618" class="calibre3"/>that should be done in a real project, but it recreates the earlier examples in this chapter. The <code class="inlinecode">sync</code> method tells Sequelize to synchronize the database with the data model objects, which has the effect of creating tables for the <code class="inlinecode">ResultModel</code>, <code class="inlinecode">Person</code>, and <code class="inlinecode">Calculation</code> data. Once the tables have been created, the <code class="inlinecode">addSeedData</code> function is called to add the initial data to the database. Some of these operations are asynchronous, which is why they are performed with the <code class="inlinecode">await</code> keyword inside an <code class="inlinecode">async</code> method.</p>
<h3 class="heading2" id="_idParaDest-222">Querying for data</h3>
<p class="normal1">Queries in<a id="_idIndexMarker619" class="calibre3"/> an ORM are made using an API that returns objects, without any direct interaction with the SQL that is sent to the database. ORM packages have different philosophies about how queries are expressed. With Sequelize, queries are performed using the data model classes, with methods that are inherited from the <code class="inlinecode">Model</code> base class, the most useful of which are described in <em class="italic">Table 12.5</em>. (The full set of <strong class="screentext">Model</strong> features can be found at <a href="https://sequelize.org/api/v6/class/src/model.js~model" class="calibre3">https://sequelize.org/api/v6/class/src/model.js~model</a>.) </p>
<p class="packt_figref">Table 12.5: Useful Model methods </p>
<table class="table-container" id="table006-4">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">findAll</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method finds all matching records and presents them as model objects. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">findOne</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method finds the first matching record and presents it as a model object.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">findByPk</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method finds the record with a specified primary key.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">findOrCreate</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method finds a matching record or creates one if there is no match.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">create</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method creates a new record.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">update</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method updates data in the database.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">upsert</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method updates a single row of data or creates a row if there is no match.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The <a id="_idIndexMarker620" class="calibre3"/>methods in <em class="italic">Table 12.5</em> are configured with a configuration object that changes the way the query or update is executed. The most useful configuration properties are described in <em class="italic">Table 12.6</em>.</p>
<p class="packt_figref">Table 12.6: Useful query configuration properties</p>
<table class="table-container" id="table007-2">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">include</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property loads data from related tables by following foreign keys.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">where</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property is used to narrow a query, which is passed to the database using the SQL <code class="inlinecode">WHERE</code> keyword.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">order</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property configures the query order, which is passed to the database using the SQL <code class="inlinecode">ORDER BY</code> keywords.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">group</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property specifies query grouping, which is passed to the database using the SQL <code class="inlinecode">GROUP BY</code> keywords.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">limit</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property specifies the number of records required, which is passed to the database using the SQL <code class="inlinecode">LIMIT</code> keyword.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">transaction</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property performs the query within the specified transaction, as demonstrated in the <em class="italic">Writing data</em> section.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">attributes</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property restricts results, so they include only the specified attributes/columns.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Listing 12.29</em> shows a basic Sequelize query that implements the <code class="inlinecode">getAllResults</code> method.</p>
<p class="packt_figref">Listing 12.29: Performing a Query in the orm_repository.ts File in the src/server/data Folder</p>
<pre class="programlisting"><code class="hljs-code">...
async getAllResults(limit: number): Promise&lt;Result[]&gt; {
    <strong class="screentext">return (await ResultModel</strong><strong class="screentext">.findAll({</strong>
<strong class="screentext">        include: [Person, Calculation],</strong>
<strong class="screentext">        limit,</strong>
<strong class="screentext">        order: [["id", "DESC"]]</strong>
<strong class="screentext">    })).map(row =&gt; </strong><strong class="screentext">fromOrmModel(row));</strong>
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">findAll</code> method<a id="_idIndexMarker621" class="calibre3"/> is called on the <code class="inlinecode">ResultModel</code> class and is configured with an object that has <code class="inlinecode">include</code>, <code class="inlinecode">limit</code>, and <code class="inlinecode">order</code> properties. The most important property is <code class="inlinecode">include</code>, which tells Sequelize to follow foreign key relationships to load related data and create objects from the results. In this case, the result will be a <code class="inlinecode">ResultModel</code> object whose <code class="inlinecode">Person</code> and <code class="inlinecode">Calculation</code> properties are populated. The <code class="inlinecode">limit</code> property restricts the number of results, and the <code class="inlinecode">order</code> property is used to specify how results are ordered.</p>
<p class="normal">The query is performed asynchronously, and the result is a <code class="inlinecode">Promise</code> that yields an array of <code class="inlinecode">ResultModel</code> objects, which are mapped to the <code class="inlinecode">Result</code> objects required by the <code class="inlinecode">Repository</code> interface using the <code class="inlinecode">fromOrmModel</code> function defined in <em class="italic">Listing 12.27</em>.</p>
<p class="normal">The <code class="inlinecode">where</code> configuration property can be used to select specific data, as demonstrated in <em class="italic">Listing 12.30</em>, which implements the <code class="inlinecode">getResultsByName</code> method.</p>
<p class="packt_figref">Listing 12.30: Searching for data in the orm_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">...
async getResultsByName(name: string, limit: number): Promise&lt;Result[]&gt; {
<strong class="screentext">    return</strong><strong class="screentext"> (await ResultModel.findAll({</strong>
<strong class="screentext">        include: [Person, Calculation],</strong>
<strong class="screentext">        where: {</strong>
<strong class="screentext">            "$Person.name$": name</strong>
<strong class="screentext">        },</strong>
<strong class="screentext">        limit, order: [["id"</strong><strong class="screentext">, "DESC"]]</strong>
<strong class="screentext">    })).map(row =&gt; fromOrmModel(row));</strong>
}
...
</code></pre>
<p class="normal">This is the <a id="_idIndexMarker622" class="calibre3"/>same query used in <em class="italic">Listing 12.29</em> but with the addition of the <code class="inlinecode">where</code> property, which tells Sequelize to follow the foreign key relationship and match <code class="inlinecode">Person</code> objects using the <code class="inlinecode">name</code> property. The syntax for the <code class="inlinecode">where</code> property can take some getting used to, but you will see additional examples in later chapters.</p>
<h3 class="heading2" id="_idParaDest-223">Writing data</h3>
<p class="normal1"><em class="italic">Listing 12.31</em> completes <a id="_idIndexMarker623" class="calibre3"/>the repository by implementing the <code class="inlinecode">saveResult</code> method, which only stores <code class="inlinecode">Person</code> and <code class="inlinecode">Calculation</code> objects if there isn’t already matching data in the database and performs all of its changes using a transaction. </p>
<p class="packt_figref">Listing 12.31: Writing data in the orm_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">...
async saveResult(r: Result): Promise&lt;number&gt; {
   <strong class="screentext"> return await this.sequelize.transaction(async (tx) =&gt; {</strong>
<strong class="screentext">        const [person] = await Person.</strong><strong class="screentext">findOrCreate({</strong>
<strong class="screentext">            where: { name : r.name},</strong>
<strong class="screentext">            transaction: tx</strong>
<strong class="screentext">        });</strong>
<strong class="screentext"> </strong>
<strong class="screentext">        const [calculation] = await Calculation.findOrCreate({</strong>
<strong class="screentext">            where: {</strong>
<strong class="screentext">                age: r.</strong><strong class="screentext">age, years: r.years, nextage: r.nextage</strong>
<strong class="screentext">            },</strong>
<strong class="screentext">            transaction: tx</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">        return (await ResultModel.create({</strong>
<strong class="screentext"> </strong><strong class="screentext">personId: person.id, calculationId: calculation.id},</strong>
<strong class="screentext">        {transaction: tx})).id;</strong>
<strong class="screentext">    });      </strong> 
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">transaction</code> is created with the <code class="inlinecode">Sequelize.transaction</code> method, which accepts a callback function that receives a <code class="inlinecode">Transaction</code> object. The <code class="inlinecode">transaction</code> property is used to enroll each operation in the transaction, which will be committed or rolled back automatically.</p>
<p class="normal">Within the<a id="_idIndexMarker624" class="calibre3"/> transaction, the <code class="inlinecode">findOrCreate</code> method is used to see if there are <code class="inlinecode">Person</code> and <code class="inlinecode">Calculation</code> objects in the database that match the data received by the <code class="inlinecode">saveResult</code> method. The result is the existing object, if there is one, or the newly created object if there is no match.</p>
<p class="normal">A new <code class="inlinecode">ResultModel</code> object must be stored for every request, and this is done using the <code class="inlinecode">create</code> method. The values for the <code class="inlinecode">personId</code> and <code class="inlinecode">calculationId</code> properties are set using the results from the <code class="inlinecode">findOrCreate</code> method and the write operation is enrolled in the transaction. No value is required for the <code class="inlinecode">id</code> property, which will be assigned by the database when the new data is stored, and which is contained in the result of the <code class="inlinecode">create</code> method.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The <code class="inlinecode">create</code> method allows objects to be created and stored in a single step. An alternative is to use the <code class="inlinecode">build</code> method, which creates a model object that isn’t stored until the <code class="inlinecode">save</code> method is called, which allows changes to be made before data is written to the database.</p>
</div>
<h3 class="heading2" id="_idParaDest-224">Applying the repository</h3>
<p class="normal1">The benefit of <a id="_idIndexMarker625" class="calibre3"/>using a repository is that the details of how data is stored can be changed without affecting the parts of the application that use that data. To complete the transition to the ORM package, <em class="italic">Listing 12.32</em> replaces the existing repository with the ORM.</p>
<p class="packt_figref">Listing 12.32: Using the ORM repository in the index.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { Repository } from "./repository";
<strong class="screentext">//import { SqlRepository } from "./sql_repository";</strong>
<strong class="screentext">import { OrmRepository } from "./orm_repository";</strong>
<strong class="screentext">const repository: Repository = </strong><strong class="screentext">new OrmRepository();</strong>
export default repository;
</code></pre>
<p class="normal">No other changes are required because the repository isolates data management from the templates and request handling code. Use a browser to request <code class="inlinecode">http://localhost:5000</code> and you will see the seed data. Fill out and submit the form and you will see the response shown in <em class="italic">Figure 12.6</em>, showing that data has been stored in the database. If you examine the Node.js console output, you will see the SQL queries that <code class="inlinecode">Sequelize</code> is formulating from the operations performed on the data model objects.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_12_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 12.6: Using an ORM package</p>
<h1 class="heading" id="_idParaDest-225">Summary</h1>
<p class="normal1">In this chapter, I explained how a JavaScript web application can use a database, both directly using SQL and indirectly using an ORM package.</p>
<ul class="calibre4">
<li class="bulletlist">Databases are the most common choice for persistent data storage.</li>
<li class="bulletlist1">Node.js can be used with popular database engines, for which there is a wide range of open-source packages.</li>
<li class="bulletlist1">Databases can be used directly or through packages that express data as objects and generate queries automatically.</li>
<li class="bulletlist1">A basic knowledge of how databases work and the ability to understand the core SQL syntax makes it easier to work with databases, even when an ORM package is used.</li>
</ul>
<p class="normal">In the next chapter, I will describe how related HTTP requests can be identified to create sessions.</p>
</div>
</body></html>