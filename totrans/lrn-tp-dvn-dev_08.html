<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Reusing Code with Many Different Types</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we covered a lot of specific techniques. Among others, we have seen how modules are used to package code that defines types and values. We have also seen functions and function types, including their usage techniques, such as currying and partial application.</p>
<p>In this chapter, we are going to build on what we have seen so far, and cover the following topics:</p>
<ul>
<li>Polymorphism techniques in Reason</li>
<li>Generic code with modules and functors</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Polymorphism in Reason</h1>
                </header>
            
            <article>
                
<p>Polymorphism, a category of technique used in many programming languages, allows for writing code that can apply to different types or objects (in languages such as C++ or Java, for example). Looking at things precisely shows that there are several techniques or kinds of polymorphism.</p>
<p>We will discuss two of those ways of doing polymorphism here:</p>
<ul>
<li>Parametric polymorphism</li>
<li>Ad hoc polymorphism</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic functions with parametric polymorphism</h1>
                </header>
            
            <article>
                
<p>Parametric polymorphism allows a function or a data type to be written in a generic way, meaning that it can handle values in the same way regardless of their type. This is both interesting and powerful, since it implies that functions written using parametric polymorphism work on different data types.</p>
<div class="packt_infobox">In C++, parametric polymorphism is usually known as <strong>generic programming</strong> or <strong>compile-time polymorphism</strong>.</div>
<p>We can perform parametric polymorphism with types in ReasonML. There is a special feature we use to do it, <strong>type variables</strong>, which we already encountered in <a href="e6bacad6-b207-4689-b068-088bed455956.xhtml"/><a href="e6bacad6-b207-4689-b068-088bed455956.xhtml">Chapter 7</a>, <em>Making Types that Represent Operations,</em> in one of the examples related to <em>function literals</em>. Instead of using a concrete type such as <kbd>int</kbd> or <kbd>string</kbd> for a parameter or result, we use  <kbd>type variable</kbd>. So, using  <kbd>type variable</kbd> as the type of a parameter would make sure that values of any type are accepted.</p>
<div class="packt_infobox">A function that uses <kbd>type variables</kbd> is called a <strong>generic function</strong>.</div>
<p>Let's explain with an example. The <em>identity</em> function is the usual simple example that helps explain what a generic function is. The identity function (let's call it <kbd>id()</kbd>) just returns its input parameter. It is defined as follows:</p>
<pre><span class="underline">let</span> <em>id</em> = x =&gt; x;</pre>
<p>Based on that definition, ReasonML infers the type of the input parameter using <kbd>'a</kbd>, meaning it uses a type variable to indicate that values of any type are accepted. And the return type of the function is inferred in the same way, as the type of its parameter, the <kbd>'a</kbd> <span>type variable.</span> That is the behavior of a generic function.</p>
<div class="packt_infobox">Whenever we have a type name starting with <kbd>'</kbd>, such as <kbd>'a</kbd> (meaning <em>any type</em>), this defines a type variable.</div>
<p>Here, is another example of such a function. We can think of a function <kbd>(lastElem)</kbd> that returns the last element of a list. The point is that the elements of the list could be of any type. In addition to that, since we must account for the empty list case, we will use the option type with type variable.</p>
<p>We can write an interface for the function (see in the <kbd>src/Ch08/Ch08_GenericFunctionLastElementOfList.rei</kbd> file) as follows:</p>
<pre><span class="underline">let</span> <em>lastElem</em>: <em>list('a)</em> =&gt; option('a);</pre>
<div>And, based on how lists work in Reason, we can define a <strong>recursive</strong> function (using the <kbd>rec</kbd> keyword), as follows:</div>
<pre><span class="underline">let</span> <em>rec</em> <em>lastElem</em> = aList =&gt;<br/>  <span class="underline">switch</span> aList {<br/>  | [] =&gt; None<br/>  | [x] =&gt; Some(x)<br/>  | [_, ...l] =&gt; lastElem(l)<br/>};</pre>
<p>Let's test it with the following <kbd>Js.log</kbd> calls:</p>
<pre>Js.log(<em>lastElem</em>([1, 3, 2, 5, 4]));<br/>Js.log(<em>lastElem</em>(["a", "b", "c", "d"]));</pre>
<p>As expected, the output (see the <kbd>src/Ch08/Ch08_GenericFunctionLastElementOfList.re</kbd> file) shows <kbd>4</kbd> and <kbd>d</kbd> as resulting values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ad hoc polymorphism or overloading</h1>
                </header>
            
            <article>
                
<p>Ad hoc polymorphism is the other technique we are going to discuss now. It is also known as <strong>overloading</strong>, and it provides different implementations for the same operation, such as the <kbd>+</kbd> operation. To stick with this example, we may find in some programming languages, such as Python, that the <kbd>+</kbd> operation has an implementation for the addition of numbers, another one for string concatenation, and a third one for list or array concatenation.</p>
<div class="packt_infobox">Ad hoc polymorphism is supported by almost all programming languages for built-in operations, such as <kbd>+</kbd>, <kbd>-</kbd>, and <kbd>*</kbd>.</div>
<p class="mce-root"/>
<p>ReasonML does not currently support ad hoc polymorphism. So, for example, we have the distinct <kbd>+</kbd> operator for <kbd>int</kbd> addition, the <kbd>+.</kbd> one for float addition, and the <kbd>++</kbd> one for string concatenation. And, if needed, we have to manually convert values into the right types before applying a given operator to them.</p>
<div class="packt_infobox">ReasonML may eventually support ad hoc polymorphism via the modular implicits currently being developed.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic code with functors</h1>
                </header>
            
            <article>
                
<p>As we have seen, modules are important in OCaml and ReasonML, helping to organize code into units with specified interfaces. In addition to that, we are going to see now that they can serve for building generic code using what are called <strong>Functors</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a functor?</h1>
                </header>
            
            <article>
                
<p>A functor is a function whose parameters are modules and whose result is a module.</p>
<p>Functors allow us to extend existing modules with new functionality, without requiring a lot of repetitive code for the different types we have.</p>
<p>The syntax of functors looks as follows:</p>
<pre><strong>module</strong> <em>F</em> = (M1: I1, ···): ResultI =&gt; {<br/>   ...<br/> };</pre>
<p>With these characteristics, note the following:</p>
<ul>
<li>The <kbd>F</kbd> <span>functor </span>has as parameters one or more <kbd>M1</kbd> <span>modules</span> and so on</li>
<li>Each parameter module must be typed via an interface (<kbd>I1</kbd> for <kbd>M1</kbd> and so on)</li>
<li>The interface for the result type (<kbd>ResultI</kbd>) is optional</li>
</ul>
<p>Some examples will help us understand.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 1 – looking in the standard library</h1>
                </header>
            
            <article>
                
<p>The best example is the <kbd>Set</kbd> module that comes with the standard library.</p>
<p>A <kbd>Set</kbd> type has an ordering (for example, in the set of the integer numbers, <em>1 &lt; 2</em> and <em>2 &gt; 1</em>), and elements are unique. Note that we have that in other languages, such as Python, too.</p>
<p>To use sets in ReasonML and OCaml, you first have to make one. You do that by calling <kbd>Set.Make</kbd>, which is a functor. It takes as input another module that must have a <kbd>compare()</kbd> function implemented within it and returns our <kbd>Set</kbd> type module.</p>
<p>We can write this, for example, for a set of integers:</p>
<pre><strong>module</strong> <em>IntSet</em> =<br/>   <em>Set.Make</em>(<br/>     {<br/>       <span class="underline">let</span> <em>compare</em> = Pervasives.compare;<br/>       <strong>type</strong> <em>t</em> = int;<br/>     }<br/> );</pre>
<p>We get a new module that provides functions for conveniently working with sets of integers, such as <kbd>IntSet.of_list()</kbd>:</p>
<pre><span class="underline">let</span> <em>myIntSet</em> = IntSet.of_list([1,2,3]);</pre>
<p>Let's display the result in the console:</p>
<pre>Js.log(myIntSet)</pre>
<p> </p>
<p>When we use the <kbd>node</kbd> command to run the JS file generated by compiling that program file (<kbd>src/Ch08/Ch08_FunctorsExample1.re</kbd>), we get output showing the created <kbd>IntSet</kbd>:</p>
<pre>[ 0, 1, [ 0, 2, [ 0, 3, 0, 1 ], 2 ], 3 ]</pre>
<p>With this first example, we got an idea of how functors work.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 2</h1>
                </header>
            
            <article>
                
<p>Here's another example taken from the ReasonML documentation, also about sets, that we are going to discuss. We will show a <kbd>MakeSet</kbd> functor that takes in a module of the <kbd>Comparable</kbd> <span>type</span> and returns a new set that can contain such comparable items.</p>
<p>We start by defining the <kbd>Comparable</kbd> type, as follows:</p>
<pre><strong>module type</strong> <em>Comparable</em> = {<br/>   <strong>type</strong> <em>t</em>;<br/>   <span class="underline">let</span> <em>equal</em>: (t, t) =&gt; bool;<br/> };</pre>
<p>Now, we define the functor, as follows:</p>
<pre><strong>module</strong> <em>MakeSet</em> = (Item: Comparable) =&gt; {<br/>   /* 1 */<br/>   <strong>type</strong> backingType = list(Item.t);<br/>   <span class="underline">let</span> <em>empty</em> = [];<br/>   <span class="underline">let</span> <em>add</em> = (currentSet: backingType, newItem: Item.t) : backingType =&gt;<br/>     <span class="underline">if</span> (<em>List.exists</em>((<em>x</em>)<em> </em>=&gt;<em> Item.equal</em>(<em>x, newItem</em>)<em>, currentSet</em>)) {<br/>       currentSet /* 2 */<br/>     } <span class="underline">else</span> {<br/>       [<br/>         <em>newItem</em>,<br/>         ...currentSet /* 3 */<br/>       ]<br/>     };<br/> };</pre>
<p>Here is this code block explained:</p>
<p>(1) We use a list as our data structure.</p>
<p>(2) If the item exists, return the same set.</p>
<p>(3) Else, prepend to the set and return it.</p>
<p>Now, let's remember that we want to create a set, the items of which are pairs of integers. We create the input module, <kbd>IntPair</kbd>, which abides by the <kbd>Comparable</kbd> signature required by <kbd>MakeSet</kbd>, as follows:</p>
<pre><strong>module</strong> <em>IntPair</em> = {<br/>   <strong>type</strong> <em>t</em> = (int, int);<br/>   <span class="underline">let</span> <em>equal</em> = ((x1, y1), (x2, y2)) =&gt; x1 == x2 &amp;&amp; y1 == y2;<br/>   <span class="underline">let</span> <em>create</em> = (x, y) =&gt; (x, y);<br/> };</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This means that we can write the following, using the functor:</p>
<pre><strong>module</strong> <em>SetOfIntPairs</em> = <em>MakeSet</em>(IntPair);</pre>
<p>To finish, let's add some code to use the resulting module:</p>
<pre><span class="underline">let</span> <em>aSetOfPairItems</em>: SetOfIntPairs.backingType = SetOfIntPairs.empty;<br/>Js.log(aSetOfPairItems);<br/><span class="underline">let</span> <em>otherSetOfPairItems</em> = SetOfIntPairs.add(aSetOfPairItems, (1, 2));<br/>Js.log(<em>otherSetOfPairItems</em>);<br/><span class="underline">let</span> <em>thirdSetOfPairItems</em> = SetOfIntPairs.add(otherSetOfPairItems, (2, 3));<br/>Js.log(thirdSetOfPairItems);</pre>
<p>This should be enough to get something interesting.</p>
<p>When we use the <kbd>node</kbd> command to run the JS file generated by compiling our Reason code file (<kbd>src/Ch08/Ch08_FunctorsExample2.re</kbd>), we get the following output:</p>
<pre>0<br/>[ [ 1, 2 ], 0 ]<br/>[ [ 2, 3 ], [ [ 1, 2 ], 0 ] ]</pre>
<p>What have we done? Using a functor, we were able to create a module, <kbd>SetOfIntPairs</kbd>, from another module. The new module has the <kbd>add</kbd> function, among other things. Using the module, we can create an empty set (<kbd>0</kbd> in the output), to which we can add pairs of <kbd>int</kbd> instances on demand (using the previously mentioned <kbd>add</kbd> function).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example 3</h1>
                </header>
            
            <article>
                
<p><span>We will now use an example from </span><span>Axel Rauschmayer</span><span> that can be found in his repository</span>, at <a href="https://github.com/rauschma/reasonml-demo-functors">https://github.com/rauschma/reasonml-demo-functors</a>.</p>
<p><span>To be precise, let's use the Printable pair functor example, with a small adaptation, to help us easily understand how this can be useful.</span></p>
<p>Before defining the functor, we must define the interface of its parameters. Here, we will have a single parameter, the <kbd>PrintablePair</kbd> module. For that, we will define a first type, <kbd>PrintableType</kbd>, that will be used by <kbd>PrintablePair</kbd>. We define it as follows:</p>
<pre><strong>module</strong> <strong>type</strong> <em>PrintableType</em> = {<br/>   <strong>type</strong> <em>t</em>;<br/>   <span class="underline">let</span> <em>print</em>: t =&gt; string;<br/> };</pre>
<p class="mce-root"/>
<p>Now, we add the definition of the <kbd>PrintablePair</kbd> type, as follows:</p>
<pre><strong>module</strong> <strong>type</strong> <em>PrintablePair</em> = (First: PrintableType, Second: PrintableType) =&gt; {<br/>   <strong>type</strong> <em>t</em>;<br/>   <span class="underline">let</span> <em>make</em>: (First.t, Second.t) =&gt; t;<br/>   <span class="underline">let</span> <em>print</em>: (t) =&gt; string;<br/> };</pre>
<p>We can then define the functor, as follows:</p>
<pre><strong>module</strong> <em>Make</em>: <em>PrintablePair</em> = (First: PrintableType, Second: PrintableType) =&gt; {<br/> <strong>type</strong> <em>t</em> = (First.t, Second.t);<br/> <span class="underline">let</span> <em>make</em> = (f: First.t, s: Second.t) =&gt; (f, s);<br/> <span class="underline">let</span> <em>print</em> = ((f, s): t) =&gt;<br/>   "(" ++ First.print(f) ++ ", " ++ Second.print(s) ++ ")";<br/> };</pre>
<p>Now, we have the code where we are going to use the functor, starting with defining the <kbd>PrintableString</kbd> and <kbd>PrintableInt</kbd> modules.</p>
<p>We define <kbd>PrintableString</kbd> as follows:</p>
<pre><strong>module</strong> <em>PrintableString</em> = {<br/>   <strong>type</strong> <em>t</em>=string;<br/>   <span class="underline">let</span> <em>print</em> = (s: t) =&gt; s;<br/> };</pre>
<p>And, we define <kbd>PrintableInt</kbd> as follows:</p>
<pre><strong>module</strong> <em>PrintableInt</em> = {<br/>   <strong>type</strong> <em>t</em>=int;<br/>   <span class="underline">let</span> <em>print</em> = (i: t) =&gt; string_of_int(i);<br/> };</pre>
<p>Now, we add the rest of the code, as follows:</p>
<pre><strong>module</strong> <em>PrintableSI</em> = Make(PrintableString, PrintableInt);<br/><span class="underline">let</span> () = <em>PrintableSI</em>.({<br/>   <span class="underline">let</span> <em>pair</em> = <em>make</em>("Jane", 53);<br/>   <span class="underline">let</span> <em>str</em> = <em>print</em>(pair);<br/>   <em>print_string</em>(str);<br/> });</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When we use the <kbd>node</kbd> command to run the <span>generated</span> JS code  (from the Reason file, <kbd>src/Ch08/Ch08_FunctorsExample3.re</kbd>), we get the following output:</p>
<pre>(Jane, 53)</pre>
<p>We are done!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have seen that ReasonML supports parametric polymorphism using <kbd>type variable</kbd>s, one of the language features. When using  <kbd>type variable</kbd> as the type of a function's parameter, values of any type are accepted for that parameter. This technique allows writing what we call generic functions and plays an important part in code reusability in ReasonML.</p>
<p>In contrast, ad hoc polymorphism, the other kind of polymorphism that is supported in popular programming languages, does not yet exist in ReasonML. But work is in progress to correct that lack in a future version.</p>
<p>Modules also play an important role in code reuse. But, that's not all. In addition to what they allow by themselves, ReasonML has a powerful feature that augments what we can do with them: <em>functors</em>. They are like special functions that take one or several modules as input and return a module. That opens up some possibilities in terms of programming generically.</p>
<p><span>In the next chapter, we are going to explore ReasonML techniques for extending types to add behavior. </span></p>


            </article>

            
        </section>
    </body></html>