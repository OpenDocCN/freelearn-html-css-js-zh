<html><head></head><body>
		<div id="_idContainer025">
			<h1 id="_idParaDest-32"><em class="italic"><a id="_idTextAnchor043"/>Chapter 3:</em> Setting Up the Environment</h1>
			<p>The main learning goal of this chapter is to get used to setting up the testing environment for writing end-to-end tests using TestCafe. You will learn how to set up a Node.js environment (including TestCafe itself), create a basic configuration file to run the tests, and structure the test code to follow the best practices.</p>
			<p>This is especially important because in real life, each new project/repository usually requires a testing infrastructure to be set up to prevent regressions and to keep the code quality high.</p>
			<p>To sum up, this chapter will cover the following main topics:</p>
			<ul>
				<li><a id="_idTextAnchor044"/>Setting up the test project environment.</li>
				<li>Creating the test project configuration file.</li>
				<li><a id="_idTextAnchor045"/>Structuring the test code.</li>
			</ul>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor046"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/tree/master/ch3">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/tree/master/ch3</a>.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor047"/>Setting up the test project environment</h1>
			<p>It is important to set<a id="_idIndexMarker087"/> up the environment properly now as we will be using it for the rest of the chapter and up to the end of this book. Doing so will also help you understand the basics of how Node.js deals with different packages and how to spin up pretty much any JavaScript/Node.js-based testing framework. We will divide the setup process into two sections:</p>
			<ul>
				<li>Installing Node.js.</li>
				<li><a id="_idTextAnchor048"/>Installing TestCafe.</li>
			</ul>
			<p>So, let's go through the whole process, starting from the beginning—installing Node.js.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor049"/>Installing Node.js</h2>
			<p>JavaScript is a client-side<a id="_idIndexMarker088"/> programming language<a id="_idIndexMarker089"/> that mostly deals with the frontend, which means it is usually processed by the browser of each user that opens your website or web application. Node.js was developed as a JavaScript runtime environment to provide the ability to use JavaScript as a server-side backend language.</p>
			<p>In order to launch almost<a id="_idIndexMarker090"/> any development tools written in JavaScript, you'll need to use Node.js and <strong class="bold">Node Package Manager (npm)</strong>. This package manager is a tool that helps you install, update, and keep your Node.js project dependencies (packages) all in one place (the <strong class="source-inline">node_modules</strong> folder).</p>
			<p>Node.js is available for a variety of operating systems, macOS, Ubuntu/Linux, and Windows being among them. The easiest way to install Node.js and <strong class="source-inline">npm</strong> is to follow these steps:</p>
			<ol>
				<li>Open <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>.</li>
				<li> Select<a id="_idIndexMarker091"/> the <strong class="bold">long-term support (LTS)</strong> version.</li>
				<li> Select your operating system.</li>
				<li>Download the installation file and run it.</li>
			</ol>
			<p>Another slightly more complex <a id="_idIndexMarker092"/>but reusable way is to install Node.js through <strong class="bold">Node Version Manager (nvm </strong>– <a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a>) or n (<a href="https://github.com/tj/n">https://github.com/tj/n</a>). Version managers give you the ability to install several versions of Node.js simultaneously and switch between them whenever you like, which is quite useful during test development.</p>
			<p>Once the installation is finished, you can check whether both Node.js and <strong class="source-inline">npm</strong> are working properly by <a id="_idIndexMarker093"/>opening <a id="_idIndexMarker094"/>any shell (for example, Terminal or PowerShell) and executing the following:</p>
			<p class="source-code">$ node -v</p>
			<p class="source-code">$ npm -v</p>
			<p>That should output the version number for Node.js and <strong class="source-inline">npm</strong>, respectively.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor050"/>Installing TestCafe</h2>
			<p>As we already <a id="_idIndexMarker095"/>have Node.js and <a id="_idIndexMarker096"/><strong class="source-inline">npm</strong> installed, let's proceed with installing TestCafe. It can be installed from <strong class="source-inline">npm</strong> locally (to run from your project folder) or globally (to run from any location).</p>
			<h3>Installing TestCafe locally</h3>
			<p>To install TestCafe locally <a id="_idIndexMarker097"/>to your project <a id="_idIndexMarker098"/>directory and save it to the dependencies list, open any shell, go to your project folder, and execute the following two commands:</p>
			<p class="source-code">$ npm init --yes</p>
			<p class="source-code">$ npm install testcafe --save-dev</p>
			<p>The first command will create a simple <strong class="source-inline">package.json</strong> file to store all the dependencies. The second command will install the <strong class="source-inline">testcafe</strong> package and save it to the list of your project's dependencies in <strong class="source-inline">package.json</strong>.</p>
			<h3>Installing TestCafe globally</h3>
			<p>To install TestCafe<a id="_idIndexMarker099"/> globally, open any shell <a id="_idIndexMarker100"/>and execute the following command:</p>
			<p class="source-code">$ npm install testcafe --global</p>
			<p>This will install TestCafe globally, and it will be accessible from any folder.</p>
			<p>You can always check the version of the <strong class="source-inline">testcafe</strong> package that is installed by executing the following command:</p>
			<p class="source-code">$ npx testcafe -v --no-install</p>
			<p class="callout-heading">Note</p>
			<p class="callout">On macOS (starting from v10.15 Catalina and up), TestCafe requires screen recording permission to carry out test actions and take screenshots and videos. When TestCafe tests launch for the first time, macOS will ask you to allow screen recording for TestCafe browser tools. Go to <strong class="bold">System Preferences</strong> - <strong class="bold">Security and Privacy</strong> - <strong class="bold">Privacy</strong> and check <strong class="bold">TestCafe Browser Tools</strong> to grant permission. When you update macOS or TestCafe, security permissions may be purged—in this case, the system will repeat the request. So, when the <strong class="bold">Security and Privacy</strong> popup opens again, just uncheck and recheck the <strong class="bold">TestCafe Browser Tools</strong> checkbox.</p>
			<p>Now, as we<a id="_idIndexMarker101"/> have Node.js, npm, and<a id="_idIndexMarker102"/> TestCafe installed and ready, let's proceed with creating a configuration file for our tests.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor051"/>Creating the test project configuration file</h1>
			<p>In this section, we <a id="_idIndexMarker103"/>will see how to configure TestCafe. However, before reviewing the main configuration options, let's set a convention for some coding style standards.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor052"/>Accepting code styling convention</h2>
			<p>When writing code <a id="_idIndexMarker104"/>throughout this book, we will follow some simple rules, such as indenting with two spaces for <strong class="source-inline">.json</strong> files and four spaces for <strong class="source-inline">.js</strong> files. We will also use semicolons and single-quotes. Most popular code editors support a <strong class="source-inline">.editorconfig</strong> configuration file to automatically apply the rules:</p>
			<p class="source-code">root = true [*]indent_style = space indent_size = 4 end_of_line = lf insert_final_newline = true charset = utf-8 trim_trailing_whitespace = true max_line_length = 120 [*.json]indent_size = 2</p>
			<p>You can copy the basic <a id="_idIndexMarker105"/>config file that we will be using from <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/.editorconfig">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/.editorconfig</a>.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor053"/>Exploring the configuration settings</h2>
			<p>The TestCafe <a id="_idIndexMarker106"/>configuration settings are usually stored in the <strong class="source-inline">.testcaferc.json</strong> file in the root folder of your project. Let's look at the main options that can be specified:</p>
			<ul>
				<li><strong class="source-inline">browsers</strong> is a string, or an array of strings, that sets one or more browsers to launch tests in. Browser aliases should be specified for any locally installed browsers, such as <strong class="source-inline">chrome</strong>, <strong class="source-inline">firefox</strong>, <strong class="source-inline">safari</strong>, <strong class="source-inline">ie</strong>, <strong class="source-inline">edge</strong>, or <strong class="source-inline">opera</strong> (<a href="https://devexpress.github.io/testcafe/documentation/guides/concepts/browsers.html#locally-installed-browsers">https://devexpress.github.io/testcafe/documentation/guides/concepts/browsers.html#locally-installed-browsers</a>). You can see the list of all the available browsers in your system—just open any shell and run the following command:<p class="source-code"><strong class="bold">$ npx testcafe --list-browsers</strong></p><p>To run tests in Chrome only, <strong class="source-inline">.testcaferc.json</strong> will look like this:</p><p class="source-code">{<a id="_idTextAnchor054"/>  "browsers": "chrome"}</p><p>To run tests in Firefox and Chrome, your test will look like this:</p><p class="source-code">{<a id="_idTextAnchor055"/>  "browsers": ["firefox", "chrome"]}</p><p>To run tests in remote browsers (such as SauceLabs, BrowserStack, CrossBrowserTesting, and so on) with a browser provider plugin, set the browser provider name, together with the browser alias and operating system, as follows:</p><p class="source-code">{<a id="_idTextAnchor056"/>  "browsers": "saucelabs:Chrome@83.0:Windows 10"}</p><p>Postfixes to <a id="_idIndexMarker107"/>browser aliases can be used to launch tests in headless mode or to apply Chrome device emulation (<a href="https://devexpress.github.io/testcafe/documentation/guides/concepts/browsers.html#use-chromium-device-emulation">https://devexpress.github.io/testcafe/documentation/guides/concepts/browsers.html#use-chromium-device-emulation</a>):</p><p class="source-code">{<a id="_idTextAnchor057"/>  "browsers": ["firefox:headless",     "chrome:emulation:device=iphone X"]}</p><p class="callout-heading">Note</p><p class="callout">TestCafe starts Chrome and Firefox with a fresh profile by default, without any extensions or profile settings. If you need to launch a browser with the current user profile, add the <strong class="source-inline">:userProfile</strong> postfix flag after the browser alias.</p></li>
				<li><strong class="source-inline">src</strong> is a string, or an <a id="_idIndexMarker108"/>array of strings, that sets a path to files or directories from where the tests should be launched. To run tests from one file, use the following code:<p class="source-code">{<a id="_idTextAnchor058"/>  "src": "tests/login-test.js"}</p><p>Global patterns can be used to parse a set of files:</p><p class="source-code">{<a id="_idTextAnchor059"/>  "src": ["tests/**/*.js", "utils/helpers/"]}</p></li>
				<li><strong class="source-inline">reporter</strong> is a string or an array of objects that sets the name of a built-in or custom reporter for generating test reports (<a href="https://devexpress.github.io/testcafe/documentation/guides/concepts/reporters.html">https://devexpress.github.io/testcafe/documentation/guides/concepts/reporters.html</a>). By default, a <strong class="source-inline">spec</strong> reporter is used. To specify any other reporters—for example, <strong class="source-inline">minimal</strong>—use the following:<p class="source-code">{<a id="_idTextAnchor060"/>  "reporter": "minimal"}</p><p>Multiple reporters can be set at the same time, but only one reporter can write to the console output (standard output, or <strong class="source-inline">stdout</strong>), and all other reporters should write to the files:</p><p class="source-code">{<a id="_idTextAnchor061"/>  "reporter": [    {      "name": "minimal"    },    {      "name": "json",      "output": "tests/reports/report.json"    },    {      "name": "xunit",      "output": "tests/reports/report.xml"    }  ]}</p><p>You can also explore and <a id="_idIndexMarker109"/>use any of the available reporters from <a href="https://www.npmjs.com/search?q=testcafe-reporter">https://www.npmjs.com/search?q=testcafe-reporter</a>.</p></li>
				<li><strong class="source-inline">screenshots</strong> is an object that allows you to set the screenshot options. These options include <strong class="source-inline">path</strong>, which is a string for the directory where screenshots are saved; <strong class="source-inline">takeOnFails</strong>, which is a boolean for whether a screenshot should be captured whenever a test fails; <strong class="source-inline">pathPattern</strong>, which is a string for the custom pattern to create a relative path and a name for the screenshot; and <strong class="source-inline">fullPage</strong>, which is a boolean for whether a screenshot should be taken of the full page (including any content that is not visible because of the overflow):<p class="source-code">{<a id="_idTextAnchor062"/>  "screenshots": {    "path": "tests/screenshots/",    "takeOnFails": true,    "pathPattern": "${DATE}_${TIME}/test-${TEST_   INDEX}/${USERAGENT}/${FILE_INDEX}.png",    "fullPage": true   }}</p><p class="callout-heading">Note</p><p class="callout">See the full list of the placeholder path patterns that can be used for screenshots and videos at <a href="https://devexpress.github.io/testcafe/documentation/guides/advanced-guides/screenshots-and-videos.html#path-pattern-placeholders">https://devexpress.github.io/testcafe/documentation/guides/advanced-guides/screenshots-and-videos.html#path-pattern-placeholders</a>.</p></li>
				<li><strong class="source-inline">videoPath</strong> is a string for the <a id="_idIndexMarker110"/>directory where videos of test runs are saved:<p class="source-code">{<a id="_idTextAnchor063"/>  "videoPath": "tests/videos/"}</p></li>
				<li><strong class="source-inline">videoOptions</strong> is an object that allows you to set the video options. These options include <strong class="source-inline">failedOnly</strong>, which is a boolean that should be set to <strong class="source-inline">true</strong> to enable recording for the failed tests only or to <strong class="source-inline">false</strong> (the default) to record all the tests; <strong class="source-inline">singleFile</strong>, which is a boolean that should be set to <strong class="source-inline">true</strong> to save the whole record in a single file or to <strong class="source-inline">false</strong> (the default) for a separate file per test; and <strong class="source-inline">pathPattern</strong>, which is a string for the custom pattern to compose the relative path and the name of the video file:<p class="source-code">{<a id="_idTextAnchor064"/>  "videoOptions": {    "failedOnly": true,    "singleFile": true,    "pathPattern": "${TEST_INDEX}/${USERAGENT}/${FILE_INDEX}.mp4"  }}</p></li>
				<li><strong class="source-inline">videoEncodingOptions</strong> is an object that sets the video encoding options (all the <strong class="source-inline">FFmpeg</strong> library options are supported, which you can find at <a href="https://ffmpeg.org/ffmpeg.html#Options">https://ffmpeg.org/ffmpeg.html#Options</a>). For example, let's set the frame rate and video display aspect ratio:<p class="source-code">{<a id="_idTextAnchor065"/>  "videoEncodingOptions": {    "r": 24,    "aspect": "16:9"  }}</p></li>
				<li><strong class="source-inline">quarantineMode</strong> is a boolean to switch failed tests to quarantine mode (to rerun the unstable tests):<p class="source-code">{<a id="_idTextAnchor066"/>  "quarantineMode": true }</p><p>If quarantine mode is turned on, tests run will follow the next logic:</p></li>
			</ul>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B16280_03_01_New.jpg" alt="Figure 3.1 – Tests run logic in quarantine mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Tests run logic in quarantine mode</p>
			<ul>
				<li><strong class="source-inline">debugMode</strong> is a boolean to run tests in debugging mode:<p class="source-code">{ <a id="_idTextAnchor067"/> "debugMode": true }</p><p class="callout-heading">Note</p><p class="callout">If debug mode is on, test execution will be paused before the first action or assertion so that you can open the developer tools and start debugging. To make it easier, a status bar will be displayed in the footer showing the available debug actions: <strong class="bold">Unlock page</strong>, <strong class="bold">Resume</strong>, and <strong class="bold">Next step</strong>.</p></li>
				<li><strong class="source-inline">debugOnFail</strong> is a boolean to automatically enable debug mode after a test fails. If this option is set to <strong class="source-inline">true</strong> (it's set to <strong class="source-inline">false</strong> by default), TestCafe will pause during the test failure so that you can view the tested page, open the developer tools, and figure out why it failed:<p class="source-code">{ <a id="_idTextAnchor068"/> "debugOnFail": true }</p></li>
				<li><strong class="source-inline">skipJsErrors</strong> is a boolean to ignore JavaScript errors on a tested web page (by default, when these errors occur, TestCafe will stop running the test and post an error message with a stack trace to the output report):<p class="source-code">{ <a id="_idTextAnchor069"/> "skipJsErrors": true }</p></li>
				<li><strong class="source-inline">skipUncaughtErrors</strong> is a boolean to ignore uncaught JavaScript errors and unhandled <a id="_idIndexMarker111"/>promise rejections on a tested web page (by default, when these errors or promise rejections occur, TestCafe will stop running the test and post an error message with a stack trace to the output report):<p class="source-code">{ <a id="_idTextAnchor070"/> "skipUncaughtErrors": true }</p></li>
				<li><strong class="source-inline">appCommand</strong> is a string to execute the specified shell command before tests are started. This option is often used to launch the application you need to run tests over (such application will be automatically stopped after all the tests are executed):<p class="source-code">{ <a id="_idTextAnchor071"/> "appCommand": "node server.js"}</p></li>
				<li><strong class="source-inline">appInitDelay</strong> is the time TestCafe will wait before launching the tests (in milliseconds; the default value is <strong class="source-inline">1000</strong>). So, this delay is used to give an application launched with the <strong class="source-inline">appCommand</strong> option some time to start:<p class="source-code">{ <a id="_idTextAnchor072"/> "appCommand": "node server.js",  "appInitDelay": 5000 }</p></li>
				<li><strong class="source-inline">concurrency</strong> is the number of browser instances spawned to run tests in parallel. TestCafe will start with a specified number of browser instances and create a pool of those instances. Tests will be launched simultaneously against this pool; each test will take the first free browser instance from the pool and run inside this instance:<p class="source-code">{ <a id="_idTextAnchor073"/> "concurrency": 4 }</p></li>
				<li><strong class="source-inline">selectorTimeout</strong> is the time within which the selector sends requests to retrieve a web element node (in milliseconds; the default value is <strong class="source-inline">10000</strong>):<p class="source-code">{ <a id="_idTextAnchor074"/> "selectorTimeout": 15000 }</p></li>
				<li><strong class="source-inline">assertionTimeout</strong> is the time during which TestCafe performs assertion requests (in milliseconds; the default<a id="_idIndexMarker112"/> value is <strong class="source-inline">3000</strong>). This timeout will be applied only if a selector property or a client function is used in an assertion as an <strong class="source-inline">actual</strong> value:<p class="source-code">{ <a id="_idTextAnchor075"/> "assertionTimeout": 5000 }</p></li>
				<li><strong class="source-inline">pageLoadTimeout</strong> is the time after the <strong class="source-inline">DOMContentLoaded</strong> event within which TestCafe waits for the <strong class="source-inline">window.load</strong> event to be fired (in milliseconds; the default value is <strong class="source-inline">3000</strong>). TestCafe starts the test after the <strong class="source-inline">window.load</strong> event is triggered or the timeout passes (whichever happens first):<p class="source-code">{ <a id="_idTextAnchor076"/> "pageLoadTimeout": 10000 }</p></li>
				<li><strong class="source-inline">speed</strong> is the test execution speed (<strong class="source-inline">1</strong> is the fastest and <strong class="source-inline">0.01</strong> is the slowest; <strong class="source-inline">1</strong> is the default). This option can be used to slow down the tests:<p class="source-code">{ <a id="_idTextAnchor077"/> "speed": 0.5 }</p><p class="callout-heading">Note</p><p class="callout">If the speed is set in <strong class="source-inline">.testcaferc.json</strong> and also within the test for an individual action, the action's speed setting will have a higher priority and will override the speed set in the configuration file.</p></li>
				<li><strong class="source-inline">clientScripts</strong> is an object, an array of objects, or a string for the scripts to be injected into any pages opened during the tests. This property is often used to add client-side mock functions, modules, or helper scripts. You can set <strong class="source-inline">content</strong>, which is a string with the code to inject the JavaScript code; <strong class="source-inline">module</strong>, which is a string with the module name to inject the module; and <strong class="source-inline">path</strong>, which is a string with the path to the file to inject the JavaScript file. Any of these settings can be paired with the optional <strong class="source-inline">page</strong> setting to set a specific page that the<a id="_idIndexMarker113"/> provided scripts should be injected into:<p class="source-code">{ <a id="_idTextAnchor078"/> "clientScripts": [    {      "content": "Date.prototype.getTimestamp = () =&gt; new Date().getTime().toString();"    },    {      "module": "js-automation-tools"    },    {      "path": "scripts/helpers.js",      "page": "https://test-site.com/page/"    }  ]}</p></li>
				<li><strong class="source-inline">port1</strong> and <strong class="source-inline">port2</strong> are numbers in the range of <strong class="source-inline">0</strong> to <strong class="source-inline">65535</strong> that represent a custom port, which TestCafe uses to launch the testing infrastructure (if ports are not set, TestCafe automatically selects them):<p class="source-code">{ <a id="_idTextAnchor079"/> "port1": 12340, <a id="_idTextAnchor080"/> "port2": 56789 }</p></li>
				<li><strong class="source-inline">hostname</strong> is a string for the hostname of your computer, used when you run tests within remote browsers. If <strong class="source-inline">hostname</strong> is not set, TestCafe will use the operating system hostname or the network IP address of the current machine:<p class="source-code">{ <a id="_idTextAnchor081"/> "hostname": "host.test-site.com"}</p></li>
				<li><strong class="source-inline">proxy</strong> is a string for the proxy server used in your local network to access the internet:<p class="source-code">{ <a id="_idTextAnchor082"/> "proxy": "123.123.123.123:8080"}</p><p>Authentication credentials can also be set with the proxy host:</p><p class="source-code">{ <a id="_idTextAnchor083"/> "proxy": "username:password@proxy.t<a id="_idTextAnchor084"/>est-site.com"}</p></li>
				<li><strong class="source-inline">proxyBypass</strong> is a <a id="_idIndexMarker114"/>string (or an array of strings) that requires TestCafe to bypass the proxy server to access the specified resources:<p class="source-code">{ <a id="_idTextAnchor085"/> "proxyBypass": ["localhost:8080", "internal.corp.test-site.com"]}</p></li>
				<li><strong class="source-inline">developmentMode</strong> is a boolean to diagnose errors (if you want to report an issue to TestCafe Support, you should set this option to <strong class="source-inline">true</strong>):<p class="source-code">{ <a id="_idTextAnchor086"/> "developmentMode": true }</p></li>
				<li><strong class="source-inline">stopOnFirstFail</strong> is a boolean to stop a test run right after any of the tests fail:<p class="source-code">{ <a id="_idTextAnchor087"/> "stopOnFirstFail": true }</p></li>
				<li><strong class="source-inline">tsConfigPath</strong> is a string to enable TestCafe to use a custom TypeScript configuration file and set its location (<a href="https://devexpress.github.io/testcafe/documentation/guides/concepts/typescript-and-coffeescript.html#customize-compiler-options">https://devexpress.github.io/testcafe/documentation/guides/concepts/typescript-and-coffeescript.html#customize-compiler-options</a>). A relative or an absolute path can be used:<p class="source-code">{ <a id="_idTextAnchor088"/> "tsConfigPath": "/Users/john/testcafe/tsconfig.json"}</p><p>In the case of relative paths, they will be resolved against the directory from which you run TestCafe.</p></li>
				<li><strong class="source-inline">disablePageCaching</strong> is a boolean<a id="_idIndexMarker115"/> to prevent the page's content from being cached by the browser:<p class="source-code">{ <a id="_idTextAnchor089"/> "disablePageCaching": true }</p><p>When browsers open a cached page inside the role code, the <strong class="source-inline">localStorage</strong> and <strong class="source-inline">sessionStorage</strong> content will not be saved. To keep the storage items after navigation, set <strong class="source-inline">disablePageCaching</strong> to <strong class="source-inline">true</strong>.</p><p class="callout-heading">Note</p><p class="callout">Here is a good example of a <strong class="source-inline">.testcaferc.json</strong> file with all the main settings: <a href="https://github.com/DevExpress/testcafe/blob/master/examples/.testcaferc.json">https://github.com/DevExpress/testcafe/blob/master/examples/.testcaferc.json</a>.</p></li>
			</ul>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor090"/>Creating a basic configuration for the test project</h1>
			<p>Now, let's assemble all that<a id="_idIndexMarker116"/> we have learned in this section and create a folder with the basic configuration for our test project by opening any shell (for example, we will use Terminal with Bash) and executing the following steps:</p>
			<ol>
				<li value="1">As we have already downloaded and installed Node.js, let's check its version:<p class="source-code"><strong class="bold">$ node -v</strong></p></li>
				<li>Then, create a folder for your future test project:<p class="source-code"><strong class="bold">$ mkdir test-project</strong></p></li>
				<li>Now, go to that folder and initiate a basic <strong class="source-inline">package.json</strong> file to store all the dependencies:<p class="source-code"><strong class="bold">$ cd test-project/</strong></p><p class="source-code"><strong class="bold">$ npm init --yes</strong></p></li>
				<li>After that, install the TestCafe package and save it to your list as a development dependency:<p class="source-code"><strong class="bold">$ npm install testcafe --save-dev</strong></p></li>
				<li>As a final step (for now), create a <strong class="source-inline">.testcaferc.json</strong> configuration file with a minimal set of options:<p class="source-code">{  "browsers": "chrome",  "src": [    "tests/**/*.js",    "tests/**/*.feature"  ],  "screenshots": {    "path": "tests/screenshots/",    "takeOnFails": true,    "pathPattern": "${DATE}_${TIME}/test-${TEST_INDEX}/${USERAGENT}/${FILE_INDEX}.png"  },  "quarantineMode": false,  "stopOnFirstFail": true,  "skipJsErrors": true,  "skipUncaughtErrors": true,  "concurrency": 1,  "selectorTimeout": 3000,  "assertionTimeout": 1000,  "pageLoadTimeout": 1000,  "disablePageCaching": true }</p></li>
			</ol>
			<p>We have covered the options from this file in the <em class="italic">Exploring the configuration settings</em> section, so you can always refer back to it to understand this example.</p>
			<p>You can also review and download this configuration file from GitHub at <a href="https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch3/test-project/.testcaferc.json">https://github.com/PacktPublishing/Modern-Web-Testing-with-TestCafe/blob/master/ch3/test-project/.testcaferc.json</a>.</p>
			<p>As we <a id="_idIndexMarker117"/>installed Node.js and TestCafe and created a basic config file, let's continue setting up our test project by organizing our test code structure.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor091"/>Structuring the test code</h1>
			<p>To gain a better<a id="_idIndexMarker118"/> understanding of test code structure organization, let's divide it into several parts: fixtures, tests, the starting web page, metadata, and skipping tests.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor092"/>Fixtures</h2>
			<p>TestCafe tests are usually <a id="_idIndexMarker119"/>grouped into test suites, called fixtures (which are the same as the <strong class="source-inline">describe</strong> blocks in the Jasmine and Mocha test frameworks). Any JavaScript, TypeScript, or CoffeeScript files with TestCafe tests should contain one or more fixtures. Test fixtures can be declared with the <strong class="source-inline">fixture</strong> function, which only accepts one argument—<strong class="source-inline">fixtureName</strong>—which is a string for the name of the fixture (set of tests):</p>
			<p class="source-code">fixture('Name for the set of the tests');</p>
			<p>Alternatively, you can write this without the brackets:</p>
			<p class="source-code">fixture `Name for the set of the tests`;</p>
			<p>A fixture is basically a wrapper to indicate the beginning of a set of tests. Let's see how these tests should be structured.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor093"/>Tests</h2>
			<p>Tests are usually written <a id="_idIndexMarker120"/>right after the <strong class="source-inline">fixture</strong> declaration. To create a test, call the <strong class="source-inline">test</strong> function, which accepts two arguments:</p>
			<ul>
				<li><strong class="source-inline">testName</strong>: A string for the name of the test.</li>
				<li><strong class="source-inline">function</strong>: An asynchronous function that contains the test code and accepts one argument — <strong class="source-inline">t</strong>, which is an object for the test controller used to access all actions and assertions.</li>
			</ul>
			<p>A simple test with the block of code usually looks like this: </p>
			<p class="source-code">test('Go to the main page', async (t) =&gt; {    await t.click('#button-main-page');    await t.expect(Selector('#logo-main-page').visible).ok();});</p>
			<p>Due to the fact that TestCafe tests are executed on the server side, you can use any additional packages or modules. Also, inside the test, you can do the following:</p>
			<ul>
				<li>Use test actions to interact with the tested web page.</li>
				<li>Use selectors and client functions to get information regarding page element states or obtain other data from the client side.</li>
				<li>Use assertions to verify whether the page elements have the expected parameters.</li>
			</ul>
			<p>Now, let's see how to specify a starting page for all tests in a fixture.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor094"/>The starting web page</h2>
			<p>You can set the initial <a id="_idIndexMarker121"/>web page that will be the starting point for all tests in a fixture with the <strong class="source-inline">fixture.page</strong> function. It only accepts one argument—<strong class="source-inline">url</strong>, which is a string for the URL of the web page where all tests in a fixture start:</p>
			<p class="source-code">fixture('Contacts page').page('http://test-site.com/example');test('Test Contact form', async (t) =&gt; {    // Starts at http://test-site.com/example });</p>
			<p>Next, let's see how to specify metadata for fixtures and tests.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor095"/>Metadata</h2>
			<p>In TestCafe, you can also<a id="_idIndexMarker122"/> provide additional information for tests, such as key-value metadata. This can be used to filter tests and display this data in reports. To define metadata, use the <strong class="source-inline">fixture.meta</strong> and <strong class="source-inline">test.meta</strong> methods. They accept two string arguments:</p>
			<ul>
				<li><strong class="source-inline">name</strong>: A string for the name of the metadata entry.</li>
				<li><strong class="source-inline">value</strong>: A string for the value of the metadata entry.</li>
			</ul>
			<p>Alternatively, they can accept one argument—<strong class="source-inline">metadata</strong>, which is an object for key-value pairs of metadata.</p>
			<p>Both styles of setting metadata can be combined, which will look like this:</p>
			<p class="source-code">fixture('Contacts page')    .meta('env', 'production')    .meta('fixtureId', 'f0001')    .meta({ author: 'John', creationDate: '01.06.2020' });test.meta('testId', 't0001')    .meta({ testType: 'fast', testedFeatureVersion: '1.1' })    ('Test Contact form', async (t) =&gt; {    // Your test code });</p>
			<p>Fixtures or tests can be launched by the specific metadata values that they contain. To filter tests by <strong class="source-inline">metadata</strong>, add the <strong class="source-inline">filter.testMeta</strong> and <strong class="source-inline">filter.fixtureMeta</strong> properties to the <strong class="source-inline">.testcaferc.json</strong> configuration file:</p>
			<p class="source-code">{  "filter": {    "fixtureMeta": {      "env": "production",      "author": "John"    },    "testMeta": {      "testType": "fast",      "testedFeatureVersion": "1.1"    }  }}</p>
			<p>This configuration will run only tests that have the <strong class="source-inline">testType</strong> property of <strong class="source-inline">metadata</strong> set to <strong class="source-inline">fast</strong> and <strong class="source-inline">testedFeatureVersion</strong> set to <strong class="source-inline">1.1</strong>, as well as tests whose fixture's metadata has the <a id="_idIndexMarker123"/><strong class="source-inline">env</strong> property set to <strong class="source-inline">production</strong> and the <strong class="source-inline">author</strong> property set to <strong class="source-inline">John</strong>.</p>
			<p>You can use custom reporters (<a href="https://devexpress.github.io/testcafe/documentation/guides/extend-testcafe/reporter-plugin.html">https://devexpress.github.io/testcafe/documentation/guides/extend-testcafe/reporter-plugin.html</a>) to display fixture's and test's metadata in reports.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor096"/>Skipping tests</h2>
			<p>In TestCafe, you can<a id="_idIndexMarker124"/> also specify a fixture or test to skip while all the other tests run. This is achieved with the <strong class="source-inline">fixture.skip</strong> and <strong class="source-inline">test.skip</strong> methods:</p>
			<p class="source-code">fixture.skip('Contacts page');test('Test Contact form', async (t) =&gt; {    // Your test code });test('Test Review form', async (t) =&gt; {    // Your test code });fixture('About page');test('Test Reviews block', async (t) =&gt; {    // Your test code });test.skip('Test More info form', async (t) =&gt; {    // Your test code });test('Test Our mission block', async (t) =&gt; {    // Your test code });</p>
			<p>In this example, all tests from the <strong class="source-inline">Contacts</strong> <strong class="source-inline">page</strong> fixture will be excluded from running. The <strong class="source-inline">Test More info form</strong> test will not be executed either.</p>
			<p>Another pair of useful methods is <strong class="source-inline">fixture.only</strong> and <strong class="source-inline">test.only</strong>. They are used to specify that only a particular fixture or test should be launched, and all others should be skipped. If several fixtures or tests are marked with <strong class="source-inline">.only</strong>, then all fixtures or tests marked with <strong class="source-inline">.only</strong> will be executed:</p>
			<p class="source-code">fixture.only('Contacts page');test('Test Contact form', async (t) =&gt; {    // Your test code });test('Test Review form', async (t) =&gt; {    // Your test code });fixture('About page');test('Test Reviews block', async (t) =&gt; {    // Your test code });test.only('Test More info form', async (t) =&gt; {    // Your test code });test('Test Our mission block', async (t) =&gt; {    // Your test code });</p>
			<p>In this example, only the tests <a id="_idIndexMarker125"/>from the <strong class="source-inline">Contacts</strong> <strong class="source-inline">page</strong> fixture and the <strong class="source-inline">Test More info form</strong> test will be executed.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor097"/>Summary</h1>
			<p>In this chapter, we learned how to set up the testing environment for writing end-to-end tests using TestCafe. We installed Node.js and TestCafe, reviewed the configuration options, and created a basic <strong class="source-inline">.testcaferc.json</strong> file to store them. In addition to that, we found out about several techniques to structure TestCafe code, including fixtures, tests, the starting web page, metadata, and skipping tests.</p>
			<p>The lessons of this chapter are important as you will be going through the configuration phase for any new project that you'll start.</p>
			<p>Now, we are well prepared and ready to proceed with utilizing this knowledge in writing TestCafe tests for our test project. We will learn how to create and debug a test, and will start building a real-life test suite right after that.</p>
		</div>
	</body></html>