<html><head></head><body>
        

                            
                    <h1 class="header-title">Staying Compatible with Legacy Browsers</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Installing Node.js with NVM</li>
<li>Installing and configuring webpack</li>
<li>Adding fallback script tags to load client bundles</li>
<li>Shimming methods with Babel Polyfill</li>
<li>Supporting new language features with Babel</li>
<li>Using tools to analyze webpack bundles</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In the preceding chapter, we covered how to take advantage of the new ECMAScript modules to load code from multiple files and organize our code. This cutting-edge technique has only recently become available in browsers. In practice, production websites try to target as many users as possible. This often means targeting older browsers. In addition, JavaScript also runs in other environments (such as Node.js) that do not support ECMAScript modules.</p>
<p>The good news is that we don't have to change our source code in order to support these platforms. There are tools available that produce a single JavaScript file from multiple source files. This way we can use modules to organize our code, and run our programs on more platforms.</p>
<p>The recipes in this chapter focus on installation and configuration of webpack in order to provide a fallback option for platforms that don't support ES modules and other more recent additions to the language.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Node.js with NVM – Linux and macOS</h1>
                
            
            
                
<p>Node provides installation binaries for Windows and macOS on its website:<br/>
<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>.</p>
<p>It's easy to install Node.js by downloading the appropriate installer for your OS and processor. However, it is useful to have a version manager so that you can work on projects that require different versions, and use the latest version. This is especially useful if your package manager doesn't provide a recent version of Node.js (for example, Ubuntu).</p>
<p>Subsequent recipes will assume that Node.js is installed. This recipe demonstrates how to install Node.js for Linux and macOS. The next recipe will cover the installation instructions for Windows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe is only for Linux and macOS. See the next recipe for Windows instructions.</p>
<p>You must have git installed. This comes installed on macOS, and Linux distributions should provide git through their package managers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application.</li>
<li>Clone the <kbd>nvm</kbd> project into a directory in your home folder:</li>
</ol>
<pre style="padding-left: 60px"><strong>git clone https://github.com/creationix/nvm.git ~/.nvm</strong></pre>
<ol start="3">
<li>Add the following code to the bottom of your <kbd>~/.bashrc</kbd> or <kbd>~/.zshrc</kbd> file. If you don't know what shell you are running, it is probably bash and you should add the entry to <kbd>~/.bashrc</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong># Configure NVM 
export NVM_DIR="$HOME/.nvm" 
[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" 
[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; . "$NVM_DIR/bash_completion"  </strong> </pre>
<ol start="4">
<li>Save the file and return to your command line:</li>
</ol>
<pre style="padding-left: 60px"><strong>source ~/.bashrc # (or ~/.zshrc if you're running zshell)</strong></pre>
<ol start="5">
<li>Confirm your installation by checking the version number of <kbd>nvm</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; nvm --version<br/></strong><strong>0.33.5</strong></pre>
<ol start="6">
<li>List all of the node versions available for installation:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; nvm list-remote</strong></pre>
<ol start="7">
<li>Install the latest <strong>Long Term Support</strong> (<strong>LTS</strong>) or stable version. (At the time of writing, version 8.9.4 is the latest LTS version):</li>
</ol>
<pre style="padding-left: 30px">    <strong>&gt; nvm install 8.9.4</strong></pre>
<ol start="8">
<li>Confirm the installation of <kbd>node</kbd> and <kbd>npm</kbd> by checking their version numbers:</li>
</ol>
<pre style="padding-left: 30px">    <strong>&gt;  node --version</strong>
    <strong>v8.9.4</strong>
    <strong>&gt; </strong><strong>npm --version</strong><br/>    <strong>5.6.0</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The keys to this installation are <em>step 4</em> and <em>step 5</em>. The <em>step</em> <em>4</em> ensures that the <kbd>nvm</kbd> executable is part of your environment's PATH, and the associated environment variables are set. When you run <kbd>nvm install 6.11</kbd>, the <kbd>nvm</kbd> executable is run, and the node binaries are installed to the expected location.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If we have also installed version v9.6.1, we would use the following command to set it as the default:</p>
<pre>    <strong>nvm alias default 9.6.1</strong> </pre>
<p>Now when we open a new shell, v9.6.1 will be the Node.js version in use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Node.js with NVM: Windows</h1>
                
            
            
                
<p>Subsequent recipes will assume that Node.js is installed. This recipe demonstrates how to install Node.js for Windows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe is meant for the Windows environment. See the previous recipe for macOS and Linux instructions.</p>
<p>You must also have git installed. You can download git from the following link:</p>
<p><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Visit the project release page:<br/>
<a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a>.<br/></li>
<li>Download the latest <kbd>nvm-setup.zip</kbd> file.</li>
<li>Extract the downloaded ZIP.</li>
<li>Double-click <strong>nvm-setup</strong>.</li>
<li>Go through the wizard to complete the installation.</li>
<li>Open the Command Prompt.</li>
<li>Confirm the installation by checking the version number of <kbd>nvm</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    <strong>&gt; nvm version</strong>
    <strong>1.1.6 </strong></pre>
<ol start="8">
<li>List all of the Node.js versions available for installation:</li>
</ol>
<pre style="padding-left: 30px">    <strong>&gt; nvm list available</strong></pre>
<ol start="9">
<li>Install the latest LTS or stable version (at time of writing, version 8.9.4 is the latest LTS version):</li>
</ol>
<pre style="padding-left: 30px">    <strong>&gt; nvm install 8.9.4</strong>
    <strong>6.11.0</strong>
    <strong>Downloading node.js version 8.9.4 (64-bit)...</strong>
    <strong>Complete</strong>
    <strong>Creating C:UsersrtharAppDataRoamingnvmtemp</strong>
    
    <strong>Downloading npm version 5.6.0... Complete</strong>
    <strong>Installing npm v5.6.0...</strong>
    
    <strong>Installation complete. </strong></pre>
<ol start="10">
<li>Enter the following command to activate this version:</li>
</ol>
<pre style="padding-left: 30px">    <strong>nvm use 8.9.6</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The installation downloads the installation wizard. The installation wizard downloads the executable files associated with <kbd>nvm</kbd>, and adjusts the PATH environment variable. The PATH is used to look up programs when they are executed on the command line. If a program is in one of the folders found in the PATH, then it can be executed without referencing its absolute or relative path.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If we have also installed version v9.6.1, we would use the following command to set it as the default:</p>
<pre>    <strong>nvm use 9.6.1</strong></pre>
<p>Now when we open a new shell, v8.6.0 will be the Node.js version in use. Unlike the macOS and Linux versions, the last version selected is maintained through shell sessions, and a default doesn't need to be set.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing and configuring webpack</h1>
                
            
            
                
<p>As mentioned before, there are a few options for creating JavaScript bundles. Rollup and Babel are popular tools that can perform this task. The webpack is a good option because it is widely used and has a large plugin base.</p>
<p>This recipe demonstrates how to install and configure webpack to build a JavaScript bundle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You'll need to have Node.js installed. If not, please see the appropriate recipe for installing Node.js with <kbd>nvm</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application, navigate to your workspace, and create a new node package:</li>
</ol>
<pre style="padding-left: 30px">    <strong>mkdir 02-creating-client-bundles</strong>
    <strong>cd 02-creating-client-bundles</strong>
    <strong>npm init</strong> -y</pre>
<ol start="2">
<li>Duplicate the <kbd>main.js</kbd> file from the <em>Nesting modules under a single namespace</em> recipe in <a href="85357458-c80c-4ebf-8ada-ce99243c496e.xhtml">Chapter 1</a>, <em>Building with Modules</em>:</li>
</ol>
<pre style="padding-left: 60px">// main.js 
import { atlas, saturnV } from './rockets/index.js' 
 
export function main () { 
  saturnV.launch(); 
  atlas.launch(); 
} </pre>
<ol start="4">
<li>Create the <kbd>rockets</kbd> dependencies directory (these files can be copied from <em>Nesting modules under a single namespace</em> recipe in <a href="85357458-c80c-4ebf-8ada-ce99243c496e.xhtml">Chapter 1</a>, <em>Building with Modules</em>):</li>
</ol>
<pre style="padding-left: 60px">// rockets/index.js 
import * as saturnV from './saturn-v.js'; 
import * as atlas from './atlas.js'; 
export { saturnV, atlas }; 
 
 
// rockets/launch-sequence.js 
export function launchSequence (countDownDuration, name) { 
  let currCount = countDownDuration; 
  console.log(`Launching in ${countDownDuration}`, name); 
 
  const countDownInterval = setInterval(function () { 
    currCount--; 
 
    if (0 &lt; currCount) { 
      console.log(currCount); 
    } else { 
      console.log('%s LIFTOFF!!! <img src="img/f44182f4-a06e-4ea6-890a-553d5d668fbb.png" style="width:1.17em;height:1.17em;"/>', name); 
      clearInterval(countDownInterval); 
    } 
  }, 1000); 
} 
 
// rockets/atlas.js 
import { launchSequence } from './launch-sequence.js'; 
 
const name = 'Atlas'; 
const COUNT_DOWN_DURATION = 20; 
 
export function launch () { 
  launchSequence(COUNT_DOWN_DURATION, name); 
} 
 
// rockets/saturn-v.js 
import { launchSequence } from './launch-sequence.js'; 
 
export const name = "Saturn V"; 
export const COUNT_DOWN_DURATION = 10; 
 
export function launch () { 
  launchSequence(COUNT_DOWN_DURATION, name); 
} </pre>
<ol start="5">
<li>Create an <kbd>index.js</kbd> file that loads and executes the main function from <kbd>main.js</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// index.js 
import { main } from './main.js'; 
main();  </pre>
<ol start="6">
<li>Install webpack:</li>
</ol>
<pre style="padding-left: 30px">   <strong>&gt; npm install --save-dev Webpack</strong></pre>
<ol start="7">
<li>Create a webpack configuration file, named <kbd>webpack.config.js</kbd>, with an entry point at <kbd>index.js</kbd> and this output filename: <kbd>bundle.js</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// webpack.config.js 
const path = require('path'); 
 
module.exports = { 
  entry: './index.js', 
  output: { 
    filename: 'bundle.js', 
    path: path.resolve(__dirname) 
  } 
}; </pre>
<ol start="8">
<li>Add a build script to <kbd>package.json</kbd>:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  /** package.json content**/<br/>  "scripts": {<br/>    "build": "webpack --config webpack.config.js"<br/>  }<br/>}</pre>
<ol start="9">
<li>Run the webpack build to create <kbd>bundle.js</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong> &gt; npm run build</strong></pre>
<ol start="10">
<li>You should see output that describes the build created and the modules contained therein. See the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>Hash: 5f2f1a7c077186c7a7a7 
Version: webpack 3.6.0 
Time: 134ms 
    Asset    Size  Chunks             Chunk Names 
bundle.js  6.7 kB       0  [emitted]  main 
   [0] ./rockets/launch-sequence.js 399 bytes {0} [built] 
   [1] ./index.js 42 bytes {0} [built] 
   [2] ./main.js 155 bytes {0} [built] 
   [3] ./rockets/index.js 162 bytes {0} [built] 
   [4] ./rockets/falcon-heavy.js 206 bytes {0} [built] 
   [5] ./rockets/saturn-v.js 203 bytes {0} [built] 
   [6] ./rockets/atlas.js 270 bytes {0} [built] </strong> </pre>
<ol start="11">
<li>Run the produced <kbd>bundle.js</kbd> file with <kbd>node</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong> node ./bundle.js </strong> </pre>
<p class="mce-root"/>
<ol start="12">
<li>You should see the rockets count down and blast off.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Installing webpack with <kbd>npm</kbd> downloads the published package to the <kbd>node_modules</kbd> directory. Because webpack also includes an executable, it is installed under <kbd>node_modules/.bin</kbd>.</p>
<p>The webpack configuration is fairly simple. It specifies an entry point and an output. The entry point defines where webpack begins its traversal. Next, it visits all the modules that are imported by the entry point and then all the modules imported by those. This is repeated until all the dependencies have been visited.</p>
<p>Then all the dependencies are merged into a single file. The file location is defined by the output settings. In this case, the output is defined as <kbd>bundle.js</kbd>. The output bundles are placed in the current directory.</p>
<p>You can visit the webpack docs for more detail on how it works and how to configure it for different scenarios at: <a href="https://webpack.js.org/">https://webpack.js.org/</a>.<a href="https://webpack.js.org/"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding fallback script tags to load client bundles</h1>
                
            
            
                
<p>In the previous recipe, we showed how to combine multiple modules with webpack. This recipe demonstrates how to load these into browsers that don't support ES modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes that you have webpack installed and configured. It is suggested that you complete the previous recipe, <em>Installing and configuring webpack</em>, before continuing with this recipe.</p>
<p>You will also need to have Python installed. If you haven't yet, visit the <em>Installing Python, using <kbd>SimpleHTTPServer</kbd> to host a local static file server </em>recipe in <a href="85357458-c80c-4ebf-8ada-ce99243c496e.xhtml">Chapter 1</a>, <em>Building with Modules</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to the directory containing the <kbd>02-creating-client-bundles</kbd> package.</li>
<li>Start the Python HTTP server.</li>
<li>Create a file named <kbd>index.html</kbd> (copied from the <em>Nesting modules under a single namespace</em> recipe in <a href="85357458-c80c-4ebf-8ada-ce99243c496e.xhtml">Chapter 1</a>, <em>Building with Modules</em>):</li>
</ol>
<pre style="padding-left: 60px">&lt;html&gt; 
  &lt;head&gt; 
    &lt;meta charset='UTF-8' /&gt; 
  &lt;/head&gt; 
  &lt;body&gt; 
    &lt;h1&gt;Open your console.&lt;/h1&gt; 
    &lt;script type="module"&gt; 
      import { main } from './main.js'; 
      main(); 
    &lt;/script&gt; 
  &lt;/body&gt; 
&lt;/html&gt; </pre>
<ol start="4">
<li>Add a <kbd>nomodule</kbd> script tag to the body after the existing <kbd>module</kbd> in the <kbd>&lt;script&gt;</kbd> tag:</li>
</ol>
<pre style="padding-left: 30px">  &lt;body&gt; 
    &lt;h1&gt;Open your console.&lt;/h1&gt; 
    &lt;script type="module"&gt; 
      import { main } from './main.js'; 
      main(); 
    &lt;/script&gt; 
<strong>    &lt;script nomodule type="text/javascript"</strong><strong>src="img/bundle.js"&gt;&lt;/script&gt;</strong> 
  &lt;/body&gt; </pre>
<ol start="5">
<li>Run the <kbd>webpack</kbd> build command:</li>
</ol>
<pre>    <strong>./node_modules/.bin/webpack --config webpack.config.js</strong></pre>
<ol start="6">
<li>Open your ES module-compatible browser, open the Developer tools to the Network tab, and visit the URL:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the individual files loaded by the browser:</li>
</ol>
<div><img src="img/306a1e80-618f-4911-bb2c-a949f4225e7b.png"/></div>
<ol start="8">
<li>
<p>Open a browser that isn't compatible with ES modules. Open the Developer tools to Network and visit the URL:<br/>
<kbd>http://localhost:8000/</kbd>.</p>
</li>
</ol>
<ol start="9">
<li>You should see the <kbd>bundle.js</kbd> file loaded instead:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ddfaefd4-a27c-4ae9-bdb4-4bd57f928820.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We saw in previous recipes that a script tag with the attribute <kbd>type="module"</kbd> will be executed and treated like an ES module. Browsers that don't support ES modules will not execute this script at all.</p>
<p>If we were to insert a normal script tag, it would be executed by newer browsers as well. In order to avoid running duplicated code we use the <kbd>nomodule</kbd> attribute. This tells newer browsers that support ES modules to ignore ID.</p>
<p>Thus, we get the desired behavior. The module tags are executed by compatible browsers and ignored by older browsers. <kbd>nomodule</kbd>-attributed scripts are ignored by ES module-compatible browsers and executed by legacy browsers.</p>
<p>At the time of writing, <kbd>nomodule</kbd> is an experimental feature and is not supported by all browsers. However, it may be supported in the future.<em><br/></em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Shimming newer features with Babel</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Shimming methods with Babel Polyfill</h1>
                
            
            
                
<p>In the previous two recipes, we saw how to create a client bundle and load it into a browser. This make it possible to use ES modules in source code without breaking compatibility with older browsers.</p>
<p>However, there are also new methods available in newer versions of the language that we'll be using in later chapters.</p>
<p>This recipe demonstrates how to use the <kbd>babel-polyfill</kbd> library to support those methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes that you have the code created in earlier recipes in this chapter, and that you have installed Python and know how to start the static HTTP server. Please visit the earlier recipes or copy the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to the directory containing the <kbd>02-creating-client-bundles</kbd> package.</li>
<li>Start the Python HTTP server.</li>
<li>Update the <kbd>main.js</kbd> file to use the <kbd>Array.prototype.values</kbd> method, and use <kbd>for..of</kbd> to loop over the resulting iterator:</li>
</ol>
<pre style="padding-left: 60px">import { atlas, saturnV } from './rockets/index.js' 
 
export function main () { 
<strong>  const rockets = [saturnV, atlas];<br/></strong><strong>  for (const rocket of rockets.values()) {<br/></strong><strong>    rocket.launch();<br/></strong><strong>  }</strong> 
}  </pre>
<ol start="4">
<li>Install the Babel Polyfill package:</li>
</ol>
<pre>    <strong>npm install --save babel-polyfill</strong>  </pre>
<ol start="5">
<li>To shim the bundle, update the <kbd>webpack.config.js</kbd> file to add Babel Polyfill to the entry point:</li>
</ol>
<pre style="padding-left: 60px">const path = require('path'); 
 
module.exports = { 
<strong>  entry: ['babel-polyfill', './index.js'],</strong> 
  output: { 
    filename: 'bundle.js', 
    path: path.resolve(__dirname) 
  } 
};  </pre>
<ol start="6">
<li>To shim ES modules, you'll need to import the file directly. Update <kbd>index.html</kbd> to import the polyfill:</li>
</ol>
<pre style="padding-left: 60px">&lt;!-- index.html --&gt; 
&lt;script type="module"&gt; 
<strong>  import './node_modules/babel-polyfill/dist/polyfill.min.js';</strong> 
  import { main } from './main.js'; 
  main(); 
&lt;/script&gt;  </pre>
<ol start="7">
<li>Now open a browser, open the Developer Console, and visit the URL:<br/>
 <kbd>http://localhost:8000/</kbd>.</li>
<li>Whether the browser supports <kbd>Array.prototype.values</kbd> or not, the code should run and display output as follows:</li>
</ol>
<div><img src="img/2efe5777-4481-43d9-abf8-fd4079bf0f33.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>babel-polyfill</kbd> package, appropriately enough, provides what are known as polyfills. A polyfill fills in the gaps that legacy browsers leave in the ECMAScript spec.</p>
<p>In the previous example, it just so happens that the current version, 61, of Chrome does not implement the <kbd>Array.prototype.values</kbd> method. The polyfill code runs before the main function. It looks to see if the <kbd>values</kbd> method is implemented on the <kbd>Array.prototype</kbd> object. If it isn't implemented natively, then polyfill implements the method. If it is implemented then polyfill leaves the native implementation in place.</p>
<p>In this way, the polyfill library makes a large set of newer methods available.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Supporting new language features with Babel</h1>
                
            
            
                
<p>In the previous recipe, we saw how to use the <kbd>babel-polyfill</kbd> library to support new ES methods. This add methods to the language at runtime, so that source code that depends on them runs correctly.</p>
<p>There are other language features that are relatively new to ECMAScript, such as the arrow function, <strong>let</strong> and <strong>const</strong> variable declarations, and spread operators. These features are not universally supported. Babel provides a mechanism to use them at the source level, and remain compatible with a build step.</p>
<p>This recipe demonstrates how to use Babel within webpack, in order to support these features in older browsers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes that you have the code created in earlier recipes in this chapter, and that you have installed Python. Please visit these earlier recipes or copy the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to the directory containing the <kbd>02-creating-client-bundles</kbd> package.</li>
<li>Start the Python HTTP server.</li>
<li>Update the <kbd>main.js</kbd> file to use the arrow function syntax:</li>
</ol>
<pre style="padding-left: 60px">import { atlas, saturnV } from './rockets/index.js' 
 
export function main () { 
  const rockets = [saturnV, atlas]; 
<strong>  rockets.map((rocket) =&gt; rocket.launch() );</strong> 
} </pre>
<ol start="4">
<li>Install Babel, the <kbd>preset-es2015</kbd>, and the associated webpack loader:</li>
</ol>
<pre style="padding-left: 30px">    <strong>npm install --save-dev babel-cli babel-preset-es2015 babel-loader</strong></pre>
<ol start="5">
<li>Create a Babel configuration file named <kbd>.babelrc</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// .babelrc 
{ 
  "presets": ["es2015"] 
} </pre>
<ol start="6">
<li>Configure <kbd>webpack</kbd> to use Babel for transpiling new language features:</li>
</ol>
<pre style="padding-left: 60px">const path = require('path'); 
 
module.exports = { 
  entry: ['babel-polyfill', './index.js'], 
  output: { 
    filename: 'bundle.js', 
    path: path.resolve(__dirname) 
<strong>  },</strong><strong>  module: {<br/></strong><strong>    rules: [<br/></strong><strong>      {<br/></strong><strong>        test: /.js$/,</strong><strong>        <br/>        exclude: /node_modules/,<br/></strong><strong>        use: 'babel-loader'<br/></strong><strong>      }<br/></strong><strong>    ]<br/></strong><strong>  }</strong> 
};  </pre>
<ol start="7">
<li>Add a webpack build command to the script section of the <kbd>package.json</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  /* package.json configuration */<br/><br/>  "scripts": {<br/>    "bundle": "webpack --config webpack.config.js",<br/>  }<br/><br/>  /* remaining properties */<br/>}   </pre>
<ol start="8">
<li>Run the <kbd>webpack</kbd> build:</li>
</ol>
<pre style="padding-left: 60px"><strong>npm run bundle </strong> </pre>
<ol start="9">
<li>Now, open a browser and open the Developer Console while visiting the URL:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="10">
<li>You should see the code running correctly:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0357de08-e664-480c-9104-807c079d278c.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Babel project provides a compiler, commonly known as a <strong>transpiler</strong>. A transpiler is a program that ingests source code and produces some target code. The most common use for the Babel transpiler is to take JavaScript source files and translate newer features.</p>
<p>When the transpiler sees an expression that uses a language feature that needs to be translated, it produces a logically equivalent expression. The produced expressions can be very similar, or very different from the source expression.</p>
<p>For more details on how to use Babel to support different platforms, look at its website at: <br/>
<a href="https://babeljs.io/">https://babeljs.io/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The previous recipe uses the ES2015 preset. This means that Babel will always produce ES2015 (ES5)-compatible code regardless of current browser support.</p>
<p>The Babel <kbd>env</kbd> preset is more sophisticated, and uses platform compatibility to determine which language features need to be translated. See the following example from the project readme:</p>
<pre> // .baberc 
{ 
  "presets": [ 
    ["env", { 
   "targets": { 
     "browsers": ["last 2 versions", "safari &gt;= 7"] 
   } 
 }] 
  ] 
} </pre>
<p>The preceding configuration targets the last two version of all browsers except Safari, which is targeted all the way back to version 7. This project allows Babel to discard translations that are no longer needed as browsers implement more language features.</p>
<p>You can find more documentation and support for the <kbd>babel-preset-env</kbd> project at its repository at: <a href="https://github.com/babel/babel-preset-env">https://github.com/babel/babel-preset-env</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using tools to analyze webpack bundles</h1>
                
            
            
                
<p>A major disadvantage of transpiling and using Polyfills is that the source code can diverge quite dramatically from the source code. This can often result in bloated bundle sizes. If you look at the file size of the <kbd>bundle.js</kbd> file after the Polyfill library was added (see the previous two recipes), then you'll see that it is over 200Kb. This is quite large when compared to 5Kb without the Polyfill.</p>
<p>With many bundles, it is difficult to find out what files are responsible for the large file size, and what the dependencies are between them.</p>
<p>In this recipe, we will see how to use analysis tools to get a better perspective on our webpack bundles.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>It will be helpful to have the source code available from previous recipes to bootstrap this recipe. Otherwise, you'll need to reference <em>Exporting/importing multiple modules for external use </em>recipe from <a href="85357458-c80c-4ebf-8ada-ce99243c496e.xhtml">Chapter 1</a><em>, Building with Modules</em>, for how to create the <kbd>index.html</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to the directory containing the <kbd>02-creating-client-bundles</kbd> package.</li>
<li>Run the webpack and output the profile output to a JSON file:</li>
</ol>
<pre style="padding-left: 60px"><strong>./node_modules/.bin/webpack --config webpack.config.js  --profile --json &gt; compilation-stats.json</strong></pre>
<ol start="3">
<li>To see which modules are taking up the most space in your bundle, open your browser and visit the URL:<br/>
<a href="https://chrisbateman.github.io/webpack-visualizer/">https://chrisbateman.github.io/webpack-visualizer/</a>.</li>
<li>Drag and drop the file or use the file selector to select compilation-stats.json.</li>
<li>You should see a chart that will give you hoverable module size information:</li>
</ol>
<div><img src="img/cb9dfeb9-f9cb-490f-b36c-cbf68277e883.png" style="width:40.67em;height:25.42em;"/></div>
<ol start="6">
<li>Now that you know which modules are large, you can look for the dependencies. Visit the webpack analyzer homepage at: <a href="https://webpack.github.io/analyse/">https://webpack.github.io/analyse/</a>.<a href="https://webpack.github.io/analyse/"/></li>
<li>Drag and drop the file or use the file selector to select compilation-stats.json.</li>
<li>You should see the interface change after it loads the file. Click on the Modules line in the header.</li>
<li>From here, you can see individual modules and where the dependencies are:</li>
</ol>
<div><img src="img/57357af1-24f0-4712-8d3e-6b37c7da9ffb.png" style="width:41.00em;height:25.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In <em>step 2</em>, we ran the webpack command and output statistics in a JSON file. This data includes information such as file size contribution and dependencies. The sites we opened up read that JSON data and produced a visualization. The first site, WEBPACK VISUALIZER (<a href="https://chrisbateman.github.io/webpack-visualizer/">https://chrisbateman.github.io/webpack-visualizer/</a>), uses the file size data and emphasizes how much each package contributes to the overall bundle size. This is useful for identifying the culprits when it comes to inflated bundle sizes.</p>
<p>Unfortunately, removing a large dependency isn't always easy. Dependencies can be multiple levels-deep and difficult to find. Once we know what is contributing to large bundle sizes, then we can use the second tool, Webpack Visualizer, to extract them.</p>


            

            
        
    </body></html>