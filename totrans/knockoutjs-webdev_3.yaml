- en: Chapter 3. Giving Forms the Knockout Touch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two of the oldest uses of the web are sharing and gathering information. This
    exchange includes the use of form and non-form elements. In this chapter, we will
    learn how to streamline coding and user interaction using the following focus
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Event binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The textInput binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radio and checkbox binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grid forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me start off by saying that I have not tested every type of event that can
    be bound to Knockout, but there are tons of events in HTML, or rather DOM, that
    can be tested. It seems with HTML5-friendly browsers the number of the browsers
    available to us has increased. I would suggest that you make sure that you test
    to validate if any newer events are actually available on the platform you are
    targeting.
  prefs: []
  type: TYPE_NORMAL
- en: When we bind an event it requires a handler. These handlers are either functions
    or methods on objects. The functions can be part of the ViewModel or external
    to the scope of the ViewModel. As a reminder, when functions are part of the ViewModel
    we can assign the function method without `( )`. If we are passing arguments then
    we would, of course, use them, even if they were part of the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: Common events we would look for in the View would include `click`, `keypress`,
    `mouseover`, and `mouseout`. There are many other events, but that is enough of
    a list to give you an idea of what events are, if this is a new concept to you.
  prefs: []
  type: TYPE_NORMAL
- en: The binding markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating the HTML for our page. Create a file named `enable.html`
    for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We see the `data-bind` attribute has an event declaration in this code. We are
    going to bind the two first elements to the `mouseover` event. `oneLeft` is a
    function that the binding calls when the mouse is over the element. We see again
    that `( )` is not needed because we will be creating the function as part of the
    ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The middle two `div` tags here have the element''s class, the CSS attribute,
    set by the Knockout `data-bind` attribute. This would be a good time for us to
    create our extra classes before we do the code side of the work. Here is the CSS
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These are two very simple float classes. The first two declarations in our ViewModel
    will be observables holding the value of our classes assigned to these elements.
    Note that we are declaring these as classes, so do not start the class name with
    a period. The CSS assumes this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look back at our HTML markup code, we see the events are not mouseover
    but rather mousedown and mouseup. These ViewModel event handlers, also known as
    functions, will call the methods to manage the **(Two)** item in the box on the
    browser page. Let''s add the code for both sets of handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All we are doing is changing the text of the ViewModel elements as this will
    change the bound CSS to match. This will, of course, shift the assigned element
    to float left or right on the page. Here is the complete code for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now run the code in the browser and you should see the **(One)** element shifting
    left and right when hovering over the items above the box. You will have to actually
    click the items below the box to get them to take action.
  prefs: []
  type: TYPE_NORMAL
- en: '![The binding markup](img/1028OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It would be great if we could get the book to show you the results. Perhaps
    in e-books in the future that will be possible, but for now we will stay old school
    and actually enter the code and test it.
  prefs: []
  type: TYPE_NORMAL
- en: The binding checkbox with visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example we will create a file named `event.html` and copy the `_base.html`
    to save time. We will be looking at parameters and doing something in a very elegant
    way that was too much work for a simple task in JavaScript. jQuery made JavaScript
    coding better but Knockout brings binding simplicity that we all needed from the
    start.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create the markup for our example. We see the `data-bind` this
    time is connected to the checked value changing. The second input box is tied
    to the same ViewModel item, `bringingSpouse`. The second input stores the value
    entered into the ViewModel item, `spouseName`. When first loading the page it
    will not store anything because the input box will be disabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![The binding checkbox with visibility](img/1028OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the code to drive the automated logic. It just takes two observables;
    one to hold the value for the spouse's name and the other to handle true or false,
    to toggle the input box when the user has a spouse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test our code to see how this works. It is as simple as clicking
    on the checkbox, following which the input box should become usable and ready
    for you to enter your spouse''s name, if that applies to you, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The binding checkbox with visibility](img/1028OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Modifier keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to revisit our `enable.html` file and learn a little how to deal
    with some modified events. In our case, we will be looking at spotting the event
    when the *Shift* key is pressed. If *Shift* is pressed we will handle the event
    one way and if not, we will handle it another way. First, let''s add a reset button
    to the screen with this HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add the highlighted code in the `script` section of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we hover the mouse over the new button with the *Shift* key pressed, it
    will pull up an alert box similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifier keys](img/1028OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Default actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Knockout prevents the built-in standard browser events from taking
    place. If you want to let these events run, just bind a handler to the event that
    returns true.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing bubbling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another thing you may want to do is to prevent event bubbling. **Bubbling**
    means that an element on the web page, also called the DOM element, has a chain
    relationship with what we will call higher-level elements. After an item has had
    an opportunity to handle an event, the events are then passed up the chain to
    allow a higher element an opportunity to respond to the event.
  prefs: []
  type: TYPE_NORMAL
- en: In our mouseover example, there could have been an area of the page wrapping
    the button that also had a mouseover handler. If there was, after the button handled
    the event, the event would have been passed to the higher element to allow it
    to respond to the event as well.
  prefs: []
  type: TYPE_NORMAL
- en: Control is actually very simple. We only need to prevent the event by telling
    our button handler to return false. Of course, in a different scenario, for the
    event action which you don't want to go beyond, you would have set its handler
    return false value just like the button in our use case example we are discussing
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The textInput binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have obviously done a number of bindings to textboxes already. Now, we are
    going to do something new with them. We are going to put a text input and a text
    area on the page together. Here is our HTML markup, where we will put in a new
    file called `text.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were using the value binding we would only get an update when the input
    element lost focus. Using the `textInput` binding let us have character by character
    feedback. Let''s add our code so we can try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![The textInput binding](img/1028OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We see the page content updating character by character as we type but there
    is an issue. The text in the **Post** is coming into the page as text. There is
    a simple way to fix that. We just change the content target from `text` to `html`.
    Oh, and make sure you use small letters or you will have an issue. Now, run it
    again and it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The textInput binding](img/1028OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic focus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many opportunities to enhance user experience when doing dynamic
    AJAX style sites. Years ago, a website was a dead experience compared to the power
    you could add to a desktop application. Today, the more dynamic application is
    left up to the creative ability of the designers and developers on each platform.
    Changing the user interface to be more responsive creates a virtual relationship
    between the user and your page. Make use of the following steps to make your page
    dynamic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is change the `data-bind` attribute on the title
    of the text input. By adding a comma we can have more than one data binding on
    an element. We will add the `hasFocus` binder to the input, and target the event
    to call the handler that we will name `lookAtTitleBox`. Our input box should now
    look like this in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add a button after this input box to show the ability to dynamically
    control the focus from code. This means we need to tie an event handler, our function,
    to the click event of the button. Then, we will let the code take care of passing
    control back to the title input box. Add this markup right after our title input
    box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will need to add our output text for the View to be displayed when
    the title input has the focus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing we need to do is modify our ViewModel to make our form more
    interactive. We will add two items: an observable attribute on our ViewModel and
    a method to be called by our View element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the page is reloaded, our title field has the focus, by default. Click
    inside **Post** to remove the focus from the title element. You should see the
    focus text after the button is visible and when the title element has focus. Now,
    when the title element does not have focus, click on the **Focus On Title** button.
    You will see through Knockout that we are able to designate the focus of an element
    by toggling a variable in the ViewModel. This is another example of what makes
    ViewModels in MVVM oriented applications powerful. Here is the output we get when
    the page is reloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic focus](img/1028OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our complete code for this logic should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Take a moment and look at the elegant simplicity of this code. This is why many
    Knockout coders feel like what jQuery did for JavaScript, Knockout does as much
    to enhance the design and development experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that is not good enough. If the goal is improved user experience why
    don''t we copy this file, `text.html`, as `text3.html` and create a Web 3.0 level
    experience? We will just show all the code at once and talk through it. We will
    be creating the click-to-edit experience here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is put the input element for the title with a span that displays
    the contents of the title value. You will notice they both have the same item
    starting the `data-bind` attribute. The order is not important as far as the code
    is stable; this is just the order we happen to code in. The visible item in the
    text has parentheses because the `!` (not) symbol means we have entered JavaScript
    code into the attribute value. Whenever we do that we need to enter parentheses
    for it to function correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have added a click event handler to the label and the title content.
    The reason we have added the label is that there will be times when you may have
    a page load without the title prepopulated. This was just an example to show that
    you still have access to calling the edit box by clicking on the title. When the
    page loads it will look like this at first (remember to complete the ViewModel
    before so that it will work correctly):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic focus](img/1028OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We want the same functionality for the **Post** box so you can see our code
    in the markup is identical, except it is a `textArea` field for the post versus
    the title. Now, let''s look at our ViewModel code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that our values for the title and the visibility of the title editor
    are simple observable attributes on our ViewModel. The only thing we need the
    `editTitle` event handler to do is toggle the visible state of the title input
    box to true. Knockout will set the visibility of our View and edit elements correctly
    for us with hardly any code. We did the same thing for the post element. Now,
    when we click either on the title content or the title label, we will see the
    edit box for the title display as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic focus](img/1028OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Radio and checkbox binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Radio and checkbox handling in forms can be a pain. This is another area where
    Knockout just makes things simple. Our example will start by creating a file named
    `radio.html` this time. Let''s start with the markup for our checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Radio and checkbox binding](img/1028OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, add this code in a `script` tag on the bottom of the page, as we have
    done for the other pages. We will need an array to hold the contents of the selected
    items and that is basically all we need in our ViewModel for this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By binding the checked handler in the `data-bind` attributes, we will see that
    the `colors` attribute is automatically populated. The `colors` attribute in the
    `span` tag will show all of the currently selected checkbox elements. You might
    even try clicking earlier items on and off and you will see it always puts the
    last selected item at the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Radio and checkbox binding](img/1028OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The markup for a radio button is very similar. We are going to create our code
    the same way to show the difference in function between a radio button collection
    and a checkbox collection of elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Radio and checkbox binding](img/1028OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All we need to is just add this single line of code in `function VM()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Radio and checkbox binding](img/1028OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the radio button it does not matter how many items are clicked, as radio
    buttons always limit themselves to a single item being selected. In common HTML,
    we would have needed to put a name on each of the radio buttons to make sure the
    DOM knew how to achieve this functionality. In this example, we can plainly see
    again that Knockout is taking care of business for us.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced event integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The radio and checkbox binding, which we explained earlier, is useful and many
    seasoned developers likely think that HTML coding is far too heavy with the manual
    entering of all the details of colors or shapes right in the markup or the View
    part of the document. This type of thing is the best practice to place in a data
    collection of some sort. And this is exactly what we will do with the another
    set of checkboxes that we will label as **Foods**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will add an attribute to our ViewModel called `foodItems`.
    We will also go another step forward and set some preselected values in a variable
    called `foods`. You will notice that our `foodItems` attribute has a structured
    collection with two nested items: `item` and `itemDisplay`. Make sure your preselected
    items are using the `item` value. If you put in `Milk` instead of `milk` you will
    be confused about why it did not appear to work correctly. Items have to have
    a 100 percent match so lower case and upper case make all the difference here.
    Add the following code in `function VM()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add in another set of checkboxes for the foods in the View section
    of our code. We will also be using the foreach binding in this set. Here, we can
    pass a JSON style structure to allow us to create an alias of "food" for our internal
    `$data` item. Each item inside `foreach` is designated as `$data`. Adding the
    `as` key allows us to set an alias for the `$data` as food. We show both approaches
    in use here by using `$data.item` and by using `food.itemDisplay` for the more
    dynamic example. Here is the code to add in the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Enhanced event integration](img/1028OS_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is our complete code, in case it would help you to see all in one place.
    Knockout again has shown a simpler and powerful advantage to the way it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Select binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first example of using Knockout with a `select` element will be for single
    item selection. This is the markup where we will put `colors` into the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In our code we will be doing one more special thing at this time. After we
    create the ViewModel we will modify one of its attributes and add another color
    to the `colorOptions` array using the `push` function, common to JavaScript. This
    means that some parts of JavaScript are great already and we should continue to
    use them. Here is the `script` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Select binding](img/1028OS_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we select the last added item, **Orange**, we will see the selector and the
    display span both showing the value as in the preceding screenshot. Using the
    code you can set the value of the ViewModel `color` attribute and it will automatically
    set the select box to the matching value. You should try it from the browser developer
    tools console. Don't forget to match the case of the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use a multi-select element. We don''t need the options caption
    in this case. What we do need is to change the values of the `data-bind` handler
    to the `selectedOptions` handler. This allows us to capture multiple items. Just
    remember that a value is singular and selected options are plural. I am not saying
    that we always have to think of singular and plural, but we do in this case. Add
    the following code to the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to add in a little bit of code to work with the new select element.
    There is no pragmatic difference between the data coding of a single select and
    the multi-select element in the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, this works really well by allowing
    us to select multiple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Select binding](img/1028OS_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting elements with the object collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes our data comes with the value and the displayed item representing
    the value as two different items. Here is an example of how to code when this
    is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `script` tag, inside `MyModel()`, add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice `optionsText` is not a variable but is the value of the structure element
    inside the collection item. We are using an individual result here so we use the
    value handler to hold the results. If it were multiple selections, we would use
    the `selectedOptions` binding. Here is what the initial display will look like
    after our code is added. Notice that the type is set to `undeclared`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting elements with the object collections](img/1028OS_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also take note of the logic inside our text binding. If there is no item selected,
    the budget item will be a null item. This works in JavaScript as a false result.
    It will then display the contents of the item after the colon. Otherwise it returns
    the results of the item before the colon. In that case we will return the structure
    element from the budget item for the type, which you will see in our script; we
    coded it as `budgetType`. Let''s take a look at the `script` code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The code segment above will come before we declare the structure of our ViewModel.
    We will use it to declare the items within our budget collection as follows. We
    use a simple observable versus an observableArray because we are only returning
    a single item. It is a structured item with nested attributes but it is a single
    item at that level and thus, this is the correct logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the results once we select an item. If we select the **Rental
    House** item we see that the budget type changes to **income**. This makes for
    nice dynamic interaction with far less manual coding of our automated systems.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the management Knockout style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can take our budget system just a little further. We will make a list
    editor that will let us add, delete, and sort our list. While most of what we
    have done so far has been very simple, this one is going to be different. This
    example is going to be simplified. It does a lot more so it will take a little
    more. Yet, through the power of Knockout, we will see that simplicity is still
    intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In our first section of code we use something that we have not used so far.
    We use a `form` tag. Normally forms are not used when coding with Knockout. So
    why the change in this example? The change is because we are going to use the
    `submit` function of the form to act as our trigger to add the new budget items
    to our budget. This is done with the `addBudget` handler in our code. Here is
    our `script` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the rest of the code looks familiar. The only part that might be new
    for some is the sorting of budgets. We do this using the standard JavaScript style
    sorting and a custom function we created outside the ViewModel. The custom function
    is the `bCompare` function. Here is the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple compare function used by JavaScript to interact with the natural
    flow to make sure that all the items are in order. Again, we see that the code
    behind this edit form is simple enough. Let''s take a look at the list editor
    we are building. We did not make it fancy but we are certainly building some sweet
    functionality into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the management Knockout style](img/1028OS_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a little more special markup in the View side of the code to make
    sure things are bound correctly, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you are looking at the code you may be wondering what is special about
    the code. It''s just Knockout making things simple and powerful. This is all it
    takes to get the job done. Oh, did you figure out that I am pretty impressed with
    Knockout? I am. Knockout is what makes it special because it is doing so much
    for us so that we can concentrate on the programming goals instead of how to achieve
    them. Here is a screenshot after we add **Entertainment** as an expense, sort
    the list, and delete **Gas** from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the management Knockout style](img/1028OS_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The uniqueName binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IE6 does not allow radio buttons to be checked if they don''t have a `name`
    attribute. Most of the time this is irrelevant because your radio button elements
    will have the `name` attributes to put them into mutually-exclusive groups. However,
    if you didn''t add a `name` attribute because it''s unnecessary in your case,
    Knockout will internally use `uniqueName` on those elements to ensure they can
    be checked. Hopefully, none of us will have to use IE6 but just in case, add the
    `uniqueName` handler to the `data-bind` attribute, something like this if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Grid forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will take our budget form just one step further. We will combine a number
    of the features we have been learning to this point into an editable grid. We
    will wrap the grid in a form this time also, but you will see in the code a dual
    option for how you use the form. Create a file called `grid.html` for this example.
    Enter the following in the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use Knockout just as an automated editor and still submit the
    form, you could fill in the details on the `action` attribute of the form and
    still submit it in the old-school approach. This might be useful if you are working
    with an older system and your business logic is still form-submission based. This
    will also allow you to enter the realm of Knockout more gradually. It could also
    allow you to test out the functionality without having to totally rewrite your
    systems during testing this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice we are using the `foreach` markup binding to manage a row in our grid
    for every data row on the model of our data. The ViewModel smartly keeps all of
    this tied together and up to date. We have also added in the `uniqueName` logic
    that one would add into an application that needs to support IE6\. Now let''s
    look at the script code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We created a standard ViewModel named BudgetModel in this example. Once again,
    we are using the JavaScript array `push` method to stack another budget item in
    our array collection. We also have handlers for removing a budget item. If we
    look back at our markup you will see it uses the scope-based variable `$root.removeBudget`.
    The rows are added using the foreach functionality so Knockout once again does
    the heavy lifting for us and it will know which row you are trying to delete.
    Don't get stressed out trying to figure it out. Think of it like a smartphone.
    You don't need to know how it works. What you need to know is how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The save method handler is set to show the results in an alert box. You could
    have easily used jQuery AJAX to send these results back to a server for persistent
    data storage. You will also see there is, as stated previously, the ability to
    just send it as a form. The choice is there for you to pick the one that best
    suits your needs. Here is the screenshot for the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid forms](img/1028OS_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now play around with this example. Add some rows. Delete some rows. Click **Submit**
    with data and you will see the results in an alert box. Click it without any rows
    and you will see it is smart enough to just ignore the user trying to submit nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with forms and grids, and keeping the data up to date, anytime
    you touch it, anywhere, is what Knockout has been about from the start. I hope
    you are enjoying coding web forms with the simple but powerful advances this technology
    offers. It makes focusing on business logic much easier with less code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn to integrate data management in Knockout
    using JSON and mapping.
  prefs: []
  type: TYPE_NORMAL
