- en: Chapter 2. Object-Oriented JavaScript with Backbone Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：使用 Backbone 类的面向对象 JavaScript
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The differences between JavaScript's class system and the class systems of traditional
    object-oriented languages
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的类系统与传统面向对象语言的类系统之间的区别
- en: How new, this, and prototype enable JavaScript's class system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过新、原型和原型使 JavaScript 的类系统成为可能
- en: Extend, Backbone's much easier mechanism for creating subclasses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展，Backbone 创建子类的一种更简单的机制
- en: Ways to take advantage of Underscore, which (like jQuery) is one of Backbone's
    dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Underscore 的方法，它是 Backbone 的依赖之一（就像 jQuery 一样）
- en: JavaScript's class system
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 的类系统
- en: Programmers who use JavaScript can use classes to encapsulate units of logic
    in the same way as programmers of other languages. However, unlike those languages,
    JavaScript relies on a less popular form of inheritance known as prototype-based
    inheritance. Since Backbone classes are, at their core, just JavaScript classes,
    they too rely on the prototype system and can be subclassed in the same way as
    any other JavaScript class.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript 的程序员可以使用类以与其他语言程序员相同的方式封装逻辑单元。然而，与这些语言不同，JavaScript 依赖于一种不太流行的继承形式，称为基于原型的继承。由于
    Backbone 类在本质上只是 JavaScript 类，因此它们也依赖于原型系统，并且可以像任何其他 JavaScript 类一样进行子类化。
- en: 'For instance, let''s say you wanted to create your own `Book` subclass of the
    Backbone `Model` class with additional logic that Model doesn''t have, such as
    book-related properties and methods. Here''s how you can create such a class using
    only JavaScript''s native object-oriented capabilities:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想创建一个自己的 `Book` 子类，它是 Backbone `Model` 类的子类，并具有模型没有的附加逻辑，例如与书籍相关的属性和方法。以下是如何仅使用
    JavaScript 的原生面向对象功能创建此类的方法：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you've never worked with prototypes in JavaScript, the preceding code may
    look a little intimidating. Fortunately, Backbone provides a much easier and easier
    to read mechanism for creating subclasses. However, since that system is built
    on top of JavaScript's native system, it's important to first understand how the
    native system works. This understanding will be helpful later when you want to
    do more complex class-related tasks, such as calling a method defined on a parent
    class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未在 JavaScript 中使用过原型，前面的代码可能看起来有点令人畏惧。幸运的是，Backbone 提供了一种更简单、更易于阅读的机制来创建子类。然而，由于该系统建立在
    JavaScript 的原生系统之上，因此首先了解原生系统的工作方式非常重要。这种理解将有助于你以后进行更复杂的类相关任务，例如调用在父类上定义的方法。
- en: The new keyword
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新关键字
- en: The `new` keyword is a relatively simple but extremely useful part of JavaScript's
    class system. The first thing that you need to understand about new is that it
    doesn't create objects in the same way as other languages. In JavaScript, every
    variable is either a function, object, or primitive, which means that when we
    refer to a *class*, what we're really referring to is a specially designed initialization
    function. Creating this class-like function is as simple as defining a function
    that modifies this and then using the new keyword to call that function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 关键字是 JavaScript 类系统的一个相对简单但极其有用的部分。关于 `new` 的第一件事是，它不会以与其他语言相同的方式创建对象。在
    JavaScript 中，每个变量要么是函数、对象或原始值，这意味着当我们提到 *类* 时，我们实际上指的是一个特别设计的初始化函数。创建这种类样式的函数就像定义一个修改
    `this` 的函数然后使用 `new` 关键字调用该函数一样简单。'
- en: 'Normally, when you call a function, its this is obvious. For instance, when
    you call the `turnPage` method of a book object, the `this` method inside `turnPage`
    will be set to this book object, as shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你调用一个函数时，它的 `this` 是显而易见的。例如，当你调用一个书籍对象的 `turnPage` 方法时，`turnPage` 中的 `this`
    方法将被设置为这本书对象，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Calling a function that isn''t attached to an object (in other words, a function
    that is not a method) results in this being set to the global scope. In a web
    browser, this means the window object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个未附加到对象上的函数（换句话说，一个不是方法的函数）会导致 `this` 被设置为全局作用域。在网页浏览器中，这意味着窗口对象：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we use the `new` keyword before calling an initialization function, three
    things happen (well, actually four, but we''ll wait to explain the fourth one
    until we explain prototypes):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在调用初始化函数之前使用 `new` 关键字时，会发生三件事（实际上四件事，但我们将在解释原型时解释第四件事）：
- en: JavaScript creates a brand new object (`{}`)for us
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 为我们创建了一个全新的对象 (`{}`)
- en: JavaScript sets the `this` method inside the initialization function to the
    newly created object
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript将初始化函数内部的 `this` 方法设置为新创建的对象
- en: After the function finishes, JavaScript ignores the normal return value and
    instead returns the object that was created
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数执行完毕后，JavaScript会忽略正常的返回值，而是返回创建的对象
- en: As you can see, although the `new` keyword is simple, it's nevertheless important
    because it allows you to treat initialization functions as if they really are
    actual classes. At the same time, it does so without violating the JavaScript
    principle that all variables must either be a function, object, or primitive.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管 `new` 关键字很简单，但它仍然很重要，因为它允许你将初始化函数视为真正的类。同时，它这样做并没有违反JavaScript的原则，即所有变量必须是函数、对象或原始数据类型。
- en: Prototypal inheritance
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型继承
- en: 'That''s all well and good, but if JavaScript has no true concept of classes,
    how can we create subclasses? As it turns out, every object in JavaScript has
    two special properties to solve this problem: `prototype and __proto__ (hidden)`.
    These two properties are, perhaps, the most commonly misunderstood aspects of
    JavaScript, but once you learn how they work, they are actually quite simple to
    use.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切都很好，但如果JavaScript没有真正的类概念，我们如何创建子类呢？实际上，JavaScript中的每个对象都有两个特殊的属性来解决这个问题：`prototype`
    和 `__proto__`（隐藏的）。这两个属性可能是JavaScript中最常被误解的方面，但一旦你了解了它们的工作原理，实际上它们的使用非常简单。
- en: 'When you call a method on an object or try to retrieve a property JavaScript
    first checks whether the object has the method or property defined in the object
    itself. In other words if you define a method such as this one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在对象上调用方法或尝试检索属性时，JavaScript首先检查对象是否在其自身中定义了该方法或属性。换句话说，如果你定义了一个这样的方法：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: JavaScript will use that definition first when you call `turnPage`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `turnPage` 时，JavaScript将首先使用这个定义。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In real-world code, however, you will almost never want to put methods directly
    in your objects for two reasons. First, doing that will result in duplicate copies
    of those methods, as each instance of your class will have its own separate copy.
    Second, adding methods in this way requires an extra step, and that step can be
    easily forgotten when you create new instances.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际代码中，你几乎永远不会想在对象中直接放置方法，原因有两个。首先，这样做会导致这些方法被复制，因为你的类每个实例都将有自己的单独副本。其次，以这种方式添加方法需要额外的步骤，而这个步骤在你创建新实例时很容易被忘记。
- en: If the object doesn't have a `turnPage` method defined in it, JavaScript will
    next check the object's `hidden __proto__` property. If this `__proto__` object
    doesn't have a `turnPage` method, then JavaScript will look at the `__proto__`
    property on the object's `__proto__`. If that doesn't have the method, JavaScript
    continues to check the `__proto__` of the `__proto__` of the `__proto__` and keeps
    checking each successive `__proto__` until it has exhausted the chain.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象中没有定义 `turnPage` 方法，JavaScript 将接下来检查对象的 `hidden __proto__` 属性。如果这个 `__proto__`
    对象没有 `turnPage` 方法，那么JavaScript将查看对象 `__proto__` 属性上的 `__proto__`。如果没有这个方法，JavaScript将继续检查
    `__proto__` 的 `__proto__` 的 `__proto__`，并继续检查每个后续的 `__proto__`，直到链被耗尽。
- en: '![Prototypal inheritance](img/image00165.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![原型继承](img/image00165.jpeg)'
- en: This is similar to single-class inheritance in more traditional object-oriented
    languages, except that instead of going through a class chain, JavaScript instead
    uses a prototype chain. Just as in an object-oriented language we wind up with
    only a single copy of each method, but instead of the method being defined on
    the class itself, it's defined on the class's prototype.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统面向对象语言中的单类继承类似，只不过JavaScript不是通过类链，而是使用原型链。就像在面向对象语言中我们最终只有一个方法副本一样，但方法不是定义在类本身上，而是定义在类的原型上。
- en: 'In a future version of JavaScript (ES6), it will be possible to work with the
    `__proto__` object directly, but for now, the only way to actually see the `__proto__`
    property is to use your browser''s debugging tool (for instance, the Chrome Developer
    Tools debugger):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的将来版本（ES6）中，将能够直接操作 `__proto__` 对象，但到目前为止，查看 `__proto__` 属性的唯一方法是通过浏览器调试工具（例如，Chrome开发者工具调试器）：
- en: '![Prototypal inheritance](img/image00166.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![原型继承](img/image00166.jpeg)'
- en: 'This means that you can''t use this line of code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不能使用以下这行代码：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, you can''t use the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你不能使用以下代码：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But, if you can''t manipulate `__proto__` directly, how can you take advantage
    of it? Fortunately, it is possible to manipulate `__proto__`, but you can only
    do this indirectly by manipulating `prototype`. Do you remember I mentioned that
    the `new` keyword actually does four things? The fourth thing is that it sets
    the `__proto__` property of the new object it creates to the `prototype` property
    of the initialization function. In other words, if you want to add a `turnPage`
    method to every new instance of `Book` that you create, you can assign this `turnPage`
    method to the `prototype` property of the `Book` initialization function, For
    example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您不能直接操作`__proto__`，您如何利用它呢？幸运的是，您可以操作`__proto__`，但您只能通过间接操作`prototype`来实现。您还记得我提到`new`关键字实际上做了四件事吗？第四件事是它将新创建的对象的`__proto__`属性设置为初始化函数的`prototype`属性。换句话说，如果您想为每个您创建的`Book`新实例添加一个`turnPage`方法，您可以将这个`turnPage`方法赋值给`Book`初始化函数的`prototype`属性，例如：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since these concepts often cause confusion, let''s briefly recap:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些概念经常引起混淆，让我们简要回顾一下：
- en: Every object has a `prototype` property and a hidden `__proto__` property
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象都有一个`prototype`属性和一个隐藏的`__proto__`属性。
- en: An object's `__proto__` property is set to the `prototype` property of its constructor
    when it is first created and cannot be changed
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个对象首次创建时，它的`__proto__`属性被设置为构造函数的`prototype`属性，并且不能被更改。
- en: Whenever JavaScript can't find a property or method on an object, it checks
    each step of the `__proto__` chain until it finds one or until it runs out of
    chain
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当JavaScript在对象上找不到属性或方法时，它会检查`__proto__`链的每个步骤，直到找到它或直到链结束。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有Packt Publishing书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Extending Backbone classes
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Backbone类
- en: 'With that explanation out of the way, we can finally get down to the workings
    of Backbone''s subclassing system, which revolves around Backbone''s extend method.
    To use extend, you simply call it from the class that your new subclass will be
    based on, and extend will return the new subclass. This new subclass will have
    its `__proto__` property set to the `prototype` property of its parent class,
    allowing objects created with the new subclass to access all the properties and
    methods of the parent class. Take an example of the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些解释的完成，我们终于可以深入了解Backbone的子类化系统，该系统围绕Backbone的`extend`方法展开。要使用`extend`，您只需从您的新子类将基于的类中调用它，`extend`将返回新的子类。这个新的子类将它的`__proto__`属性设置为父类的`prototype`属性，使得使用新子类创建的对象可以访问父类的所有属性和方法。以下是一个代码片段的例子：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the last line works because JavaScript will look up
    the `__proto__` chain, find the `Model` method `destroy`, and use it. In other
    words, all the functionality of our original class has been inherited by our new
    class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，最后一行之所以有效，是因为JavaScript会查找`__proto__`链，找到`Model`方法的`destroy`，并使用它。换句话说，我们原始类的所有功能都被我们的新类继承了。
- en: 'But of course, `extend` wouldn''t be exciting if all it can do is make exact
    clones of the parent classes, which is why `extend` takes a `properties` object
    as its first argument. Any properties or methods on this object will be added
    to the new class''s `prototype`. For instance, let''s try making our `Book` class
    a little more interesting by adding a property and a method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果`extend`只能创建父类的精确克隆，那么它就不会那么吸引人，这也是为什么`extend`将其第一个参数作为一个`properties`对象。这个对象上的任何属性或方法都将被添加到新类的`prototype`中。例如，让我们通过添加一个属性和一个方法来让我们的`Book`类变得更有趣：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `extend` method also allows you to create static properties or methods,
    or in other words, properties or methods that live on the class rather than on
    objects created from that class. These static properties and methods are passed
    in as the second `classProperties` argument to `extend`. Here''s a quick example
    of how to add a static method to our `Book` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend` 方法还允许你创建静态属性或方法，换句话说，就是存在于类上而不是从该类创建的对象上的属性或方法。这些静态属性和方法作为第二个 `classProperties`
    参数传递给 `extend`。以下是一个快速示例，说明如何向我们的 `Book` 类添加一个静态方法：'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, there are several advantages to Backbone's approach to inheritance
    over the native JavaScript approach. First, the word `prototype` did not appear
    even once in any of the previously mentioned code; while you still need to understand
    how `prototype` works, you don't have to think about it just to create a class.
    Another benefit is that the entire class definition is contained within a single
    `extend` call, keeping all of the class's parts together visually. Also, when
    we use `extend`, the various pieces of logic that make up the class are ordered
    the same way as in most other programming languages, defining the super class
    first and then the initializer and properties, instead of the other way around.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，与原生的 JavaScript 方法相比，Backbone 对继承的处理方法有几个优点。首先，单词 `prototype` 在之前提到的任何代码中都没有出现过；虽然你仍然需要理解
    `prototype` 的工作原理，但你不必为了创建一个类而思考它。另一个好处是，整个类定义都包含在一个单一的 `extend` 调用中，使得类的所有部分在视觉上保持在一起。此外，当我们使用
    `extend` 时，构成类的各个逻辑部分按照大多数其他编程语言中的顺序排列，首先定义超类，然后是初始化器和属性，而不是相反。
- en: Applying parent methods
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用父类方法
- en: In order to realize the full power of a class system, however, it's not enough
    to just define new methods on subclasses; sometimes, we need to combine a method
    of a parent class with additional logic on a subclass. In traditional object-oriented
    languages, this is often done by referencing a special super object; but in JavaScript,
    no such object exists, which means that we have to utilize JavaScript's apply
    or call methods instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了充分发挥类系统的全部功能，仅仅在子类上定义新方法是不够的；有时，我们需要将父类的方法与子类上的附加逻辑结合起来。在传统的面向对象语言中，这通常是通过引用一个特殊的超对象来完成的；但在
    JavaScript 中，不存在这样的对象，这意味着我们必须利用 JavaScript 的 `apply` 或 `call` 方法。
- en: For instance, `Backbone.Model` has a `destroy` method, but what if we want our
    `Book` class to also have its own `destroy` method? This method might take a number
    of pages and destroy them (reduce the total number of pages by that amount), but
    at the same time, we might want to keep the Backbone version around for its original
    purpose (which is to destroy the server-side version of the `Book`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Backbone.Model` 有一个 `destroy` 方法，但如果我们想让我们的 `Book` 类也有自己的 `destroy` 方法怎么办？这个方法可能需要处理一定数量的页面并将它们销毁（减少总页数），但同时我们可能还想保留
    Backbone 版本以供其原始用途（即销毁服务器端的 `Book` 版本）。
- en: 'Luckily, because Backbone properly configured our `Book` class''s prototype
    for us, calling the parent method from the subclass method is fairly straightforward,
    as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，因为 Backbone 已经为我们正确配置了 `Book` 类的原型，所以从子类方法调用父类方法相当简单，如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The key to making the preceding code work is the `apply` method, which is a
    method of every function in JavaScript (since functions are also objects in JavaScript,
    it is possible for them to have methods just like any other object). The `apply`
    method allows you to call its function as if it were called from the first argument
    given to apply. In other words, apply allows you to change a function's `this`
    method when it is invoked.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使前面的代码能够正常工作的关键是 `apply` 方法，这是 JavaScript 中每个函数的方法（因为函数在 JavaScript 中也是对象，所以它们可以像任何其他对象一样拥有方法）。`apply`
    方法允许你将函数作为从 `apply` 给出的第一个参数调用来调用。换句话说，`apply` 允许你在函数被调用时改变其 `this` 方法。
- en: 'As mentioned before, under normal conditions, `this` will be set to the object
    from which the function was called. However, when you use apply, you can instead
    change this to whatever variable you want, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在正常情况下，`this` 将设置为调用函数的对象。但是，当你使用 `apply` 时，你可以将其改为你想要的任何变量，如下所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also pass regular arguments to a method using `apply`, by providing
    them as a second (array) argument. In fact, `apply` can be used even if this isn''t
    relevant to the function you''re trying to call, and in that case, you can simply
    pass `null` as the first argument:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `apply` 将常规参数传递给一个方法，通过提供第二个（数组）参数来实现。实际上，即使这与你要调用的函数无关，也可以使用 `apply`，在这种情况下，你可以简单地传递
    `null` 作为第一个参数：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'JavaScript functions also have a similar method: `call`. The difference between
    `call` and `apply` is how they provide arguments to the function they invoke.
    Unlike `apply`, `call` expects its arguments to be passed in separately, rather
    than as a single array argument. Take an example of the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数也有类似的方法：`call`。`call` 和 `apply` 之间的区别在于它们向被调用的函数提供参数的方式。与 `apply`
    不同，`call` 预期其参数是单独传递的，而不是作为一个单一的数组参数。以下是一个代码片段的例子：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By using one of these two methods and remembering that every method of a class
    is available to you on its `prototype` property, you can call not just the methods
    of a parent class but also the methods of a grandparent, great grandparent, or
    even a completely unrelated class. For readability reasons, you shouldn't utilize
    this technique too often on unrelated classes, but occasionally it can be quite
    helpful.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这两种方法之一，并记住每个类的每个方法都可通过其 `prototype` 属性访问，你不仅可以调用父类的方法，还可以调用祖父类、曾祖父类甚至完全不相关的类的方法。出于可读性的考虑，你不应该在完全不相关的类上频繁使用这种技术，但偶尔它可能非常有帮助。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's also worth noting that this technique is only possible in a prototype-based
    inheritance language such as JavaScript; it will be impossible to implement `apply`
    or `call` in a true object-oriented language such as Java.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这种技术仅在基于原型的继承语言（如 JavaScript）中可行；在真正的面向对象语言（如 Java）中实现 `apply` 或 `call`
    将是不可能的。
- en: Introducing Underscore
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Underscore
- en: In addition to jQuery, Backbone also requires one library called **Underscore**.
    Underscore was written by Jeremy Ashkenas (the creator of Backbone), and many
    of its functions are relevant to the topics we've discussed so far. Because Underscore
    is required by Backbone, you'll already have it available to you if you use Backbone.
    All of these functions can be accessed via the `_` character (similar to how jQuery
    functions are accessed via the `$` character).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 jQuery 之外，Backbone 还需要一个名为 **Underscore** 的库。Underscore 是由 Jeremy Ashkenas（Backbone
    的创造者）编写的，其中许多函数与我们之前讨论的主题相关。由于 Underscore 是 Backbone 所必需的，所以如果你使用 Backbone，你将已经可以使用它。所有这些函数都可以通过
    `_` 字符访问（类似于 jQuery 函数是通过 `$` 字符访问的）。
- en: 'As we discussed the `call` and `apply` methods, you may have realized that
    this is more fluid in JavaScript than in other languages. While a function that
    is called normally will preserve the `this` method automatically, when a function
    is called in an unusual way—such as through `window.setTimeout` or as a callback
    to a jQuery event handler or AJAX call—that won''t be the case. The `window.setTimeout`
    will change this to the global window object, while jQuery event callbacks will
    change `this` to the element that triggered the event and jQuery AJAX callbacks
    will set it to the HTTP request created by the AJAX call. Here''s a quick example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论 `call` 和 `apply` 方法时，你可能已经意识到这在 JavaScript 中比在其他语言中更灵活。当一个函数正常调用时，它会自动保留
    `this` 方法，但当函数以不寻常的方式调用时——例如通过 `window.setTimeout` 或作为 jQuery 事件处理程序或 AJAX 调用的回调——情况就不同了。`window.setTimeout`
    会将其更改为全局窗口对象，而 jQuery 事件回调会将 `this` 更改为触发事件的元素，jQuery AJAX 回调将设置为 AJAX 调用创建的 HTTP
    请求。以下是一个快速示例：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The solution to this problem is to use extra functions and use `apply` to wrap
    the original function so that we can force JavaScript to preserve our `this` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用额外的函数，并使用 `apply` 来包装原始函数，这样我们就可以强制 JavaScript 保留我们的 `this` 方法：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This works but let''s face it: it''s ugly. Luckily, Underscore has a two solution
    for this: `bind` and `bindAll`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但说实话：它很丑。幸运的是，Underscore 有两个解决方案：`bind` 和 `bindAll`。
- en: 'Let''s start with `bind`. The `bind` functions allows you to force a function,
    which you provide as the first argument, to preserve a specific `this` value,
    which you provide as the second argument:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `bind` 开始。`bind` 函数允许你强制一个函数（作为第一个参数提供），保留你作为第二个参数提供的特定 `this` 值：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Underscore also has a related `bindAll` function, which can be used to permanently
    `bind` a method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore 还有一个相关的 `bindAll` 函数，它可以用来永久地 `bind` 一个方法：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, `bindAll` allows you to use your class's methods with `setTimeout`
    or as callbacks to jQuery event handlers or AJAX operations, without losing `this`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`bindAll` 允许您使用类的 `setTimeout` 或作为回调函数来处理 jQuery 事件处理器或 AJAX 操作，而不会丢失 `this`。
- en: While `bindAll` is very powerful, it is important not to overuse it, because
    it creates a new copy of every method it binds. If used inside a class, this will
    result in every instance of that class to have its own separate copy of that method.
    While this is perfectly fine when you only have a few bound methods and/or only
    a few instances, you will not want to use it on a large number of methods with
    a class that will be instantiated many times.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `bindAll` 非常强大，但重要的是不要过度使用它，因为它会为它绑定的每个方法创建一个新的副本。如果在类内部使用，这将导致该类的每个实例都有自己独立的方法副本。当您只有少量绑定的方法和/或只有少量实例时，这完全没问题，但当您在将被多次实例化的类上使用大量方法时，您可能不想这样做。
- en: More Underscore
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多 Underscore
- en: The `bind` and `bindAll` functions are just the tip of the iceberg of what Underscore
    has to offer web developers. While a full explanation of everything that Underscore
    has to offer is outside the scope of this book, it is worth taking a few moments
    to examine a few of Underscore's most useful functions. If you want to learn more
    about Underscore beyond what we have covered in this chapter, I strongly recommend
    that you read its web page ([http://underscorejs.org/](http://underscorejs.org/)),
    which has well-written documentation for every method in the library.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind` 和 `bindAll` 函数只是 Underscore 为网络开发者提供的大量功能的一小部分。虽然对 Underscore 提供的所有功能的全面解释超出了本书的范围，但花几分钟时间检查
    Underscore 中一些最有用的函数是值得的。如果您想了解关于 Underscore 的更多内容，而不仅仅是本章中涵盖的内容，我强烈建议您阅读其网页 ([http://underscorejs.org/](http://underscorejs.org/))，其中包含了库中每个方法的良好编写的文档。'
- en: Each, Map, and Reduce
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个、Map 和 Reduce
- en: 'Every JavaScript developer knows how to iterate using the `for` loops, but
    Underscore provides three powerful alternatives to those native loops: `each`,
    `map`, and `reduce`. While all three of these methods (along with many of the
    other Underscore methods) are included natively in ES5-supporting browsers, older
    browsers, unfortunately, do not have support for them. These alternative loops
    are so convenient that you may find yourself never using the native `for` loop
    again. Thankfully, Underscore provides its version of them, allowing you to bridge
    the gap until all major browsers support ES5.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 JavaScript 开发者都知道如何使用 `for` 循环进行迭代，但 Underscore 提供了三种强大的替代原生循环的方法：`each`、`map`
    和 `reduce`。虽然这三个方法（以及许多其他 Underscore 方法）都包含在支持 ES5 的浏览器中，但不幸的是，旧浏览器没有对这些方法的支持。这些替代循环如此方便，以至于您可能会发现自己再也不用原生
    `for` 循环了。幸运的是，Underscore 提供了其版本，允许您在所有主要浏览器支持 ES5 之前填补这一差距。
- en: 'Let''s start with an example of the usage of each:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从每个用法的示例开始：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will be the equivalent of the preceding code using JavaScript''s native
    `for` loop:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等同于使用 JavaScript 的原生 `for` 循环编写的 preceding 代码：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, if we instead use the `for`/`in` syntax:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们改用 `for`/`in` 语法：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, both native implementations require you to extract the value
    (in this case, `animalName`) inside the loop, whereas Underscore's version provides
    it automatically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，原生实现都要求您在循环内部提取值（在这种情况下，`animalName`），而 Underscore 的版本会自动提供它。
- en: 'Underscore''s `map` and `reduce` methods are even more powerful. The `map`
    method allows you to convert an array of variables into another (different) array
    of variables, while reduce converts an array of variables into a single variable.
    For instance, let''s say you''ve used jQuery''s `text` method to extract a bunch
    of numbers, but because they came from the DOM, those numbers are actually strings
    (in other words, `5` instead of `5`). By using map, which has an almost identical
    syntax as each, you can easily convert all those strings into actual numbers,
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore 的 `map` 和 `reduce` 方法甚至更强大。`map` 方法允许您将变量数组转换为另一个（不同的）变量数组，而 `reduce`
    则将变量数组转换为一个单一变量。例如，假设您已经使用 jQuery 的 `text` 方法提取了一组数字，但由于它们来自 DOM，这些数字实际上是字符串（换句话说，是
    `5` 而不是 `5`）。通过使用与 `each` 几乎相同的语法的 `map`，您可以轻松地将所有这些字符串转换为实际的数字，如下所示：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see from the preceding example, the values returned inside the `map`
    function are added to the array returned by the overall `map` operation. This
    lets you convert any kind of array into another kind of array, as long as you
    can define a function that sits in the middle and performs the desired conversion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`map` 函数内部返回的值被添加到 `map` 操作返回的数组中。这使得你可以将任何类型的数组转换为另一种类型的数组，只要你能够定义一个位于中间并执行所需转换的函数。
- en: 'However, what if you wanted to combine or sum up all those numbers? In that
    case, you''d instead want to use `reduce`, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要合并或汇总所有这些数字呢？在这种情况下，你将希望使用 `reduce`，如下所示：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `reduce` function is slightly more complex than the previous functions because
    of its last argument, which is known as the *memo* argument. This argument serves
    as the starting value for the object that reduce will eventually return, and then
    as each value is iterated through that, memo is replaced by whatever value the
    `reduce` function (the function that is passed in to reduce) returns. The `reduce`
    function is also passed the previous memo as its first argument, so each iteration
    can choose to modify the previous value the way it wants to. This allows reduce
    to be used for far more complex operations than to simply add two numbers together.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 函数比之前的函数稍微复杂一些，因为它有一个名为 *memo* 的最后一个参数。这个参数作为 `reduce` 最终返回的对象的起始值，然后随着每个值的迭代，memo
    被替换为 `reduce` 函数（传递给 `reduce` 的函数）返回的任何值。`reduce` 函数还将其前一个 memo 作为其第一个参数传递，因此每次迭代都可以选择以它想要的方式修改前一个值。这使得
    `reduce` 可以用于比简单地相加两个数字更复杂的操作。'
- en: Extend and defaults
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和默认值
- en: Another common operation that is made easier with Underscore is copying the
    properties of one object onto another, which is solved with the Underscore methods
    `extend` (not to be confused with Backbone's `extend` class) and `defaults`. For
    instance, let's say you are using a third-party widget, such as a jQuery UI component,
    that takes a configuration argument when it is created. You might want to keep
    some configuration options the same for every widget in your site, but at the
    same time, you might want certain widgets to also have their own unique options.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用 Underscore 可以简化操作的常见操作是将一个对象的属性复制到另一个对象上，这可以通过 Underscore 的 `extend`（不要与
    Backbone 的 `extend` 类混淆）和 `defaults` 方法来解决。例如，假设你正在使用第三方小部件，例如 jQuery UI 组件，它在创建时需要一个配置参数。你可能希望为网站中的每个小部件保留一些相同的配置选项，但同时也可能希望某些小部件有自己的独特选项。
- en: 'Let''s imagine that you''ve defined these two sets of configurations with two
    objects, one for the common configuration and one for a specific widget''s configuration:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你已经用两个对象定义了这两组配置，一个用于通用配置，另一个用于特定小部件的配置：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `extend` method takes the first argument given to it and copies the properties
    from each successive argument onto it. In this case, it allows you to take a new
    object, apply the common options to it first, and then apply the specific options,
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend` 方法接受传递给它的第一个参数，并将每个后续参数的属性复制到它上面。在这种情况下，它允许你首先对一个新对象应用通用选项，然后应用特定选项，如下所示：'
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `defaults` method works in a similar manner, except that it only copies
    over values that the object doesn''t already have. We can instead rewrite the
    preceding example with `defaults`, simply by changing the argument order:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaults` 方法的工作方式与此类似，但它只复制对象尚未拥有的值。我们可以通过简单地改变参数顺序，用 `defaults` 重新编写前面的示例：'
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As its name implies, the `defaults` method is very handy when you want to specify
    default values for an object but don't want to replace any values you've already
    specified.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`defaults` 方法在你想要为对象指定默认值但又不想替换任何已指定的值时非常有用。
- en: Pluck and invoke
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取和调用
- en: 'Two of the most common uses of `map` involve getting certain properties from
    an array of objects or calling a certain method on every object in an array. Underscore
    provides additional convenience methods to do exactly this: `pluck` and `invoke`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 的最常见用途之一是获取对象数组中的某些属性，或者对数组中的每个对象调用某个方法。Underscore 提供了额外的便利方法来完成这项任务：`pluck`
    和 `invoke`。'
- en: 'The `pluck` method allows you to extract a single property value from each
    member of an array. For example, let''s say we have an array of objects representing
    fake books, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`pluck` 方法允许你从数组的每个成员中提取单个属性值。例如，假设我们有一个表示虚构书籍的对象数组，如下所示：'
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you want to create a list of just the titles of these books, you can use
    the `pluck` method as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想创建包含这些书籍标题的列表，你可以使用如下所示的`pluck`方法：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `invoke` method works in a similar way as `pluck` method, except that it
    assumes that the the provided property is a method and runs it and then adds the
    result to the returned array. This can be best demonstrated with the following
    example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoke`方法的工作方式与`pluck`方法类似，不同之处在于它假设提供的属性是一个方法，运行它并将结果添加到返回的数组中。以下示例可以最好地说明这一点：'
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Further reading
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Underscore also has many other useful functions, and as we have mentioned before,
    all of them are well documented at [http://underscorejs.org/](http://underscorejs.org/).
    Since every Backbone programmer is guaranteed to have Underscore available, there's
    no reason why you shouldn't take advantage of this great library; even spending
    just a few minutes on the Underscore site will help make you aware of everything
    that it has to offer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore还有许多其他有用的函数，正如我们之前提到的，所有这些函数都有很好的文档记录，可以在[http://underscorejs.org/](http://underscorejs.org/)找到。由于每个Backbone程序员都保证可以使用Underscore，因此没有理由不利用这个优秀的库；即使在Underscore网站上花上几分钟，也会让你意识到它所能提供的一切。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how JavaScript's native class system works and
    how the `new`, `this`, and `prototype` keywords/properties form the basis of it.
    We also learned how Backbone's `extend` method makes creating new subclasses much
    more convenient as well as how to use `apply` and `call` to invoke parent methods
    (or when providing callback functions) to preserve the desired `this` method.
    Finally, we looked at a number of ways in which Underscore, one of Backbone's
    dependencies, can solve common problems. In the next chapter, we'll dive into
    the first of the four Backbone classes, `Model`. We'll learn how to use Model
    to organize our data on the client side and to exchange this data to and from
    our remote server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了JavaScript的本地类系统是如何工作的，以及`new`、`this`和`prototype`关键字/属性如何构成其基础。我们还学习了Backbone的`extend`方法如何使创建新的子类变得更加方便，以及如何使用`apply`和`call`来调用父方法（或提供回调函数时）以保留所需的`this`方法。最后，我们探讨了Underscore（Backbone的依赖之一）解决常见问题的多种方式。在下一章中，我们将深入探讨四个Backbone类中的第一个，即`Model`。我们将学习如何使用Model在客户端组织我们的数据，以及如何与远程服务器交换这些数据。
