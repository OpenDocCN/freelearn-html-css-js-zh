- en: Chapter 2. Object-Oriented JavaScript with Backbone Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The differences between JavaScript's class system and the class systems of traditional
    object-oriented languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How new, this, and prototype enable JavaScript's class system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend, Backbone's much easier mechanism for creating subclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to take advantage of Underscore, which (like jQuery) is one of Backbone's
    dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript's class system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers who use JavaScript can use classes to encapsulate units of logic
    in the same way as programmers of other languages. However, unlike those languages,
    JavaScript relies on a less popular form of inheritance known as prototype-based
    inheritance. Since Backbone classes are, at their core, just JavaScript classes,
    they too rely on the prototype system and can be subclassed in the same way as
    any other JavaScript class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s say you wanted to create your own `Book` subclass of the
    Backbone `Model` class with additional logic that Model doesn''t have, such as
    book-related properties and methods. Here''s how you can create such a class using
    only JavaScript''s native object-oriented capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you've never worked with prototypes in JavaScript, the preceding code may
    look a little intimidating. Fortunately, Backbone provides a much easier and easier
    to read mechanism for creating subclasses. However, since that system is built
    on top of JavaScript's native system, it's important to first understand how the
    native system works. This understanding will be helpful later when you want to
    do more complex class-related tasks, such as calling a method defined on a parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The new keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `new` keyword is a relatively simple but extremely useful part of JavaScript's
    class system. The first thing that you need to understand about new is that it
    doesn't create objects in the same way as other languages. In JavaScript, every
    variable is either a function, object, or primitive, which means that when we
    refer to a *class*, what we're really referring to is a specially designed initialization
    function. Creating this class-like function is as simple as defining a function
    that modifies this and then using the new keyword to call that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, when you call a function, its this is obvious. For instance, when
    you call the `turnPage` method of a book object, the `this` method inside `turnPage`
    will be set to this book object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling a function that isn''t attached to an object (in other words, a function
    that is not a method) results in this being set to the global scope. In a web
    browser, this means the window object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the `new` keyword before calling an initialization function, three
    things happen (well, actually four, but we''ll wait to explain the fourth one
    until we explain prototypes):'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript creates a brand new object (`{}`)for us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript sets the `this` method inside the initialization function to the
    newly created object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the function finishes, JavaScript ignores the normal return value and
    instead returns the object that was created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, although the `new` keyword is simple, it's nevertheless important
    because it allows you to treat initialization functions as if they really are
    actual classes. At the same time, it does so without violating the JavaScript
    principle that all variables must either be a function, object, or primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypal inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That''s all well and good, but if JavaScript has no true concept of classes,
    how can we create subclasses? As it turns out, every object in JavaScript has
    two special properties to solve this problem: `prototype and __proto__ (hidden)`.
    These two properties are, perhaps, the most commonly misunderstood aspects of
    JavaScript, but once you learn how they work, they are actually quite simple to
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call a method on an object or try to retrieve a property JavaScript
    first checks whether the object has the method or property defined in the object
    itself. In other words if you define a method such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript will use that definition first when you call `turnPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real-world code, however, you will almost never want to put methods directly
    in your objects for two reasons. First, doing that will result in duplicate copies
    of those methods, as each instance of your class will have its own separate copy.
    Second, adding methods in this way requires an extra step, and that step can be
    easily forgotten when you create new instances.
  prefs: []
  type: TYPE_NORMAL
- en: If the object doesn't have a `turnPage` method defined in it, JavaScript will
    next check the object's `hidden __proto__` property. If this `__proto__` object
    doesn't have a `turnPage` method, then JavaScript will look at the `__proto__`
    property on the object's `__proto__`. If that doesn't have the method, JavaScript
    continues to check the `__proto__` of the `__proto__` of the `__proto__` and keeps
    checking each successive `__proto__` until it has exhausted the chain.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototypal inheritance](img/image00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is similar to single-class inheritance in more traditional object-oriented
    languages, except that instead of going through a class chain, JavaScript instead
    uses a prototype chain. Just as in an object-oriented language we wind up with
    only a single copy of each method, but instead of the method being defined on
    the class itself, it's defined on the class's prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a future version of JavaScript (ES6), it will be possible to work with the
    `__proto__` object directly, but for now, the only way to actually see the `__proto__`
    property is to use your browser''s debugging tool (for instance, the Chrome Developer
    Tools debugger):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototypal inheritance](img/image00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that you can''t use this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can''t use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if you can''t manipulate `__proto__` directly, how can you take advantage
    of it? Fortunately, it is possible to manipulate `__proto__`, but you can only
    do this indirectly by manipulating `prototype`. Do you remember I mentioned that
    the `new` keyword actually does four things? The fourth thing is that it sets
    the `__proto__` property of the new object it creates to the `prototype` property
    of the initialization function. In other words, if you want to add a `turnPage`
    method to every new instance of `Book` that you create, you can assign this `turnPage`
    method to the `prototype` property of the `Book` initialization function, For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since these concepts often cause confusion, let''s briefly recap:'
  prefs: []
  type: TYPE_NORMAL
- en: Every object has a `prototype` property and a hidden `__proto__` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object's `__proto__` property is set to the `prototype` property of its constructor
    when it is first created and cannot be changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever JavaScript can't find a property or method on an object, it checks
    each step of the `__proto__` chain until it finds one or until it runs out of
    chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Backbone classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With that explanation out of the way, we can finally get down to the workings
    of Backbone''s subclassing system, which revolves around Backbone''s extend method.
    To use extend, you simply call it from the class that your new subclass will be
    based on, and extend will return the new subclass. This new subclass will have
    its `__proto__` property set to the `prototype` property of its parent class,
    allowing objects created with the new subclass to access all the properties and
    methods of the parent class. Take an example of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the last line works because JavaScript will look up
    the `__proto__` chain, find the `Model` method `destroy`, and use it. In other
    words, all the functionality of our original class has been inherited by our new
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'But of course, `extend` wouldn''t be exciting if all it can do is make exact
    clones of the parent classes, which is why `extend` takes a `properties` object
    as its first argument. Any properties or methods on this object will be added
    to the new class''s `prototype`. For instance, let''s try making our `Book` class
    a little more interesting by adding a property and a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extend` method also allows you to create static properties or methods,
    or in other words, properties or methods that live on the class rather than on
    objects created from that class. These static properties and methods are passed
    in as the second `classProperties` argument to `extend`. Here''s a quick example
    of how to add a static method to our `Book` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are several advantages to Backbone's approach to inheritance
    over the native JavaScript approach. First, the word `prototype` did not appear
    even once in any of the previously mentioned code; while you still need to understand
    how `prototype` works, you don't have to think about it just to create a class.
    Another benefit is that the entire class definition is contained within a single
    `extend` call, keeping all of the class's parts together visually. Also, when
    we use `extend`, the various pieces of logic that make up the class are ordered
    the same way as in most other programming languages, defining the super class
    first and then the initializer and properties, instead of the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Applying parent methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to realize the full power of a class system, however, it's not enough
    to just define new methods on subclasses; sometimes, we need to combine a method
    of a parent class with additional logic on a subclass. In traditional object-oriented
    languages, this is often done by referencing a special super object; but in JavaScript,
    no such object exists, which means that we have to utilize JavaScript's apply
    or call methods instead.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `Backbone.Model` has a `destroy` method, but what if we want our
    `Book` class to also have its own `destroy` method? This method might take a number
    of pages and destroy them (reduce the total number of pages by that amount), but
    at the same time, we might want to keep the Backbone version around for its original
    purpose (which is to destroy the server-side version of the `Book`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, because Backbone properly configured our `Book` class''s prototype
    for us, calling the parent method from the subclass method is fairly straightforward,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The key to making the preceding code work is the `apply` method, which is a
    method of every function in JavaScript (since functions are also objects in JavaScript,
    it is possible for them to have methods just like any other object). The `apply`
    method allows you to call its function as if it were called from the first argument
    given to apply. In other words, apply allows you to change a function's `this`
    method when it is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, under normal conditions, `this` will be set to the object
    from which the function was called. However, when you use apply, you can instead
    change this to whatever variable you want, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass regular arguments to a method using `apply`, by providing
    them as a second (array) argument. In fact, `apply` can be used even if this isn''t
    relevant to the function you''re trying to call, and in that case, you can simply
    pass `null` as the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript functions also have a similar method: `call`. The difference between
    `call` and `apply` is how they provide arguments to the function they invoke.
    Unlike `apply`, `call` expects its arguments to be passed in separately, rather
    than as a single array argument. Take an example of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By using one of these two methods and remembering that every method of a class
    is available to you on its `prototype` property, you can call not just the methods
    of a parent class but also the methods of a grandparent, great grandparent, or
    even a completely unrelated class. For readability reasons, you shouldn't utilize
    this technique too often on unrelated classes, but occasionally it can be quite
    helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's also worth noting that this technique is only possible in a prototype-based
    inheritance language such as JavaScript; it will be impossible to implement `apply`
    or `call` in a true object-oriented language such as Java.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Underscore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to jQuery, Backbone also requires one library called **Underscore**.
    Underscore was written by Jeremy Ashkenas (the creator of Backbone), and many
    of its functions are relevant to the topics we've discussed so far. Because Underscore
    is required by Backbone, you'll already have it available to you if you use Backbone.
    All of these functions can be accessed via the `_` character (similar to how jQuery
    functions are accessed via the `$` character).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed the `call` and `apply` methods, you may have realized that
    this is more fluid in JavaScript than in other languages. While a function that
    is called normally will preserve the `this` method automatically, when a function
    is called in an unusual way—such as through `window.setTimeout` or as a callback
    to a jQuery event handler or AJAX call—that won''t be the case. The `window.setTimeout`
    will change this to the global window object, while jQuery event callbacks will
    change `this` to the element that triggered the event and jQuery AJAX callbacks
    will set it to the HTTP request created by the AJAX call. Here''s a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution to this problem is to use extra functions and use `apply` to wrap
    the original function so that we can force JavaScript to preserve our `this` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This works but let''s face it: it''s ugly. Luckily, Underscore has a two solution
    for this: `bind` and `bindAll`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `bind`. The `bind` functions allows you to force a function,
    which you provide as the first argument, to preserve a specific `this` value,
    which you provide as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Underscore also has a related `bindAll` function, which can be used to permanently
    `bind` a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `bindAll` allows you to use your class's methods with `setTimeout`
    or as callbacks to jQuery event handlers or AJAX operations, without losing `this`.
  prefs: []
  type: TYPE_NORMAL
- en: While `bindAll` is very powerful, it is important not to overuse it, because
    it creates a new copy of every method it binds. If used inside a class, this will
    result in every instance of that class to have its own separate copy of that method.
    While this is perfectly fine when you only have a few bound methods and/or only
    a few instances, you will not want to use it on a large number of methods with
    a class that will be instantiated many times.
  prefs: []
  type: TYPE_NORMAL
- en: More Underscore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bind` and `bindAll` functions are just the tip of the iceberg of what Underscore
    has to offer web developers. While a full explanation of everything that Underscore
    has to offer is outside the scope of this book, it is worth taking a few moments
    to examine a few of Underscore's most useful functions. If you want to learn more
    about Underscore beyond what we have covered in this chapter, I strongly recommend
    that you read its web page ([http://underscorejs.org/](http://underscorejs.org/)),
    which has well-written documentation for every method in the library.
  prefs: []
  type: TYPE_NORMAL
- en: Each, Map, and Reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every JavaScript developer knows how to iterate using the `for` loops, but
    Underscore provides three powerful alternatives to those native loops: `each`,
    `map`, and `reduce`. While all three of these methods (along with many of the
    other Underscore methods) are included natively in ES5-supporting browsers, older
    browsers, unfortunately, do not have support for them. These alternative loops
    are so convenient that you may find yourself never using the native `for` loop
    again. Thankfully, Underscore provides its version of them, allowing you to bridge
    the gap until all major browsers support ES5.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example of the usage of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the equivalent of the preceding code using JavaScript''s native
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we instead use the `for`/`in` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both native implementations require you to extract the value
    (in this case, `animalName`) inside the loop, whereas Underscore's version provides
    it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underscore''s `map` and `reduce` methods are even more powerful. The `map`
    method allows you to convert an array of variables into another (different) array
    of variables, while reduce converts an array of variables into a single variable.
    For instance, let''s say you''ve used jQuery''s `text` method to extract a bunch
    of numbers, but because they came from the DOM, those numbers are actually strings
    (in other words, `5` instead of `5`). By using map, which has an almost identical
    syntax as each, you can easily convert all those strings into actual numbers,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, the values returned inside the `map`
    function are added to the array returned by the overall `map` operation. This
    lets you convert any kind of array into another kind of array, as long as you
    can define a function that sits in the middle and performs the desired conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what if you wanted to combine or sum up all those numbers? In that
    case, you''d instead want to use `reduce`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `reduce` function is slightly more complex than the previous functions because
    of its last argument, which is known as the *memo* argument. This argument serves
    as the starting value for the object that reduce will eventually return, and then
    as each value is iterated through that, memo is replaced by whatever value the
    `reduce` function (the function that is passed in to reduce) returns. The `reduce`
    function is also passed the previous memo as its first argument, so each iteration
    can choose to modify the previous value the way it wants to. This allows reduce
    to be used for far more complex operations than to simply add two numbers together.
  prefs: []
  type: TYPE_NORMAL
- en: Extend and defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common operation that is made easier with Underscore is copying the
    properties of one object onto another, which is solved with the Underscore methods
    `extend` (not to be confused with Backbone's `extend` class) and `defaults`. For
    instance, let's say you are using a third-party widget, such as a jQuery UI component,
    that takes a configuration argument when it is created. You might want to keep
    some configuration options the same for every widget in your site, but at the
    same time, you might want certain widgets to also have their own unique options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that you''ve defined these two sets of configurations with two
    objects, one for the common configuration and one for a specific widget''s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extend` method takes the first argument given to it and copies the properties
    from each successive argument onto it. In this case, it allows you to take a new
    object, apply the common options to it first, and then apply the specific options,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defaults` method works in a similar manner, except that it only copies
    over values that the object doesn''t already have. We can instead rewrite the
    preceding example with `defaults`, simply by changing the argument order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As its name implies, the `defaults` method is very handy when you want to specify
    default values for an object but don't want to replace any values you've already
    specified.
  prefs: []
  type: TYPE_NORMAL
- en: Pluck and invoke
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two of the most common uses of `map` involve getting certain properties from
    an array of objects or calling a certain method on every object in an array. Underscore
    provides additional convenience methods to do exactly this: `pluck` and `invoke`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pluck` method allows you to extract a single property value from each
    member of an array. For example, let''s say we have an array of objects representing
    fake books, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create a list of just the titles of these books, you can use
    the `pluck` method as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `invoke` method works in a similar way as `pluck` method, except that it
    assumes that the the provided property is a method and runs it and then adds the
    result to the returned array. This can be best demonstrated with the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Underscore also has many other useful functions, and as we have mentioned before,
    all of them are well documented at [http://underscorejs.org/](http://underscorejs.org/).
    Since every Backbone programmer is guaranteed to have Underscore available, there's
    no reason why you shouldn't take advantage of this great library; even spending
    just a few minutes on the Underscore site will help make you aware of everything
    that it has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how JavaScript's native class system works and
    how the `new`, `this`, and `prototype` keywords/properties form the basis of it.
    We also learned how Backbone's `extend` method makes creating new subclasses much
    more convenient as well as how to use `apply` and `call` to invoke parent methods
    (or when providing callback functions) to preserve the desired `this` method.
    Finally, we looked at a number of ways in which Underscore, one of Backbone's
    dependencies, can solve common problems. In the next chapter, we'll dive into
    the first of the four Backbone classes, `Model`. We'll learn how to use Model
    to organize our data on the client side and to exchange this data to and from
    our remote server.
  prefs: []
  type: TYPE_NORMAL
