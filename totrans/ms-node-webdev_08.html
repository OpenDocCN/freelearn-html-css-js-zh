<html><head></head><body>
<div><h1 class="chapternumber">8</h1>
<h1 class="chaptertitle" id="_idParaDest-147">Unit Testing and Debugging</h1>
<p class="normal1">In this chapter, I describe the features that Node.js provides for testing and debugging JavaScript code. I begin by demonstrating the Node.js integrated test runner, which makes it easy to define and execute unit tests. I continue by demonstrating the Node.js debugger, which is integrated into the JavaScript runtime but used through external tools. <em class="italic">Table 8.1</em> puts testing and debugging in context.</p>
<p class="packt_figref">Table 8.1: Putting testing and debugging in context</p>
<table class="table-container" id="table001-5">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What is it?</p>
</td>
<td class="table-cell">
<p class="normal">Unit testing<a id="_idIndexMarker407" class="calibre3"/> is the process of defining and running tests that check the behavior of code. Debugging<a id="_idIndexMarker408" class="calibre3"/> is the process of inspecting the state of the application as it is executed to determine the cause of unexpected or undesirable behavior. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why is it useful?</p>
</td>
<td class="table-cell">
<p class="normal">Testing and debugging help identify problems in code before applications are deployed to real users. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How is it used?</p>
</td>
<td class="table-cell">
<p class="normal">Unit tests<a id="_idIndexMarker409" class="calibre3"/> are written in JavaScript code and executed using the integrated Node.js test runner. The Node.js runtime includes support for debugging, which is used through external tools, including popular code editors.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">Differing views on how code should be tested often cause tension in development teams. Effort that could be spent completing the project is too often spent arguing about testing.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Testing and debugging are both optional activities. Both can help produce code with fewer defects, but neither is compulsory.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 8.2</em> summarizes the chapter.</p>
<p class="packt_figref">Table 8.2: Chapter Summary</p>
<table class="table-container" id="table002-5">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Create a unit test </p>
</td>
<td class="table-cell">
<p class="normal">Create a file with the <code class="inlinecode">test.js</code> suffix and use the <code class="inlinecode">test</code> function defined in the <code class="inlinecode">node:test</code> module.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">3</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Run unit tests </p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">--test</code> argument to start Node.js in test mode. Use the <code class="inlinecode">--watch</code> argument to run tests automatically when a change is detected.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">4-8</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Create mocks</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">fn</code>, <code class="inlinecode">method</code>, <code class="inlinecode">getter</code>, or <code class="inlinecode">setter</code> methods.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">9-10</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Understand how mocks are used</p>
</td>
<td class="table-cell">
<p class="normal">Use the spy features added to mocks.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">11</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Check the outcome of a test</p>
</td>
<td class="table-cell">
<p class="normal">Use the assertion functions in the <code class="inlinecode">assert</code> module.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">12</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Test asynchronous code</p>
</td>
<td class="table-cell">
<p class="normal">Create asynchronous mocks that produce test data.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">13-16</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Testing different outcomes</p>
</td>
<td class="table-cell">
<p class="normal">Use subtests.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">17</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Trigger the debugger</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">debugger</code> keyword or set breakpoints in the code editor.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">18-20</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Debug an application </p>
</td>
<td class="table-cell">
<p class="normal">Use the features provided by popular code editors or browsers.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">21-22</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-148">Preparing for this chapter</h1>
<p class="normal1">In this chapter, I continue to use the <code class="inlinecode">webapp</code> project from <em class="italic">Chapter 7</em>. No changes are required to prepare for this chapter. Open a command prompt, navigate to the <code class="inlinecode">webapp</code> folder, and run the command shown in <em class="italic">Listing 8.1</em> to start the build tools.</p>
<p class="packt_figref">Listing 8.1: Starting the build tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a web browser, request <code class="inlinecode">http://localhost:5000</code>, enter a message into the text field, and click the <strong class="screentext">Send Message</strong> button. The client-side JavaScript code will send the contents of the <code class="inlinecode">input</code> element to the backend server, which will pipe it back to the browser in the response, as shown in <em class="italic">Figure 8.1</em>.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<figure class="mediaobject"><img alt="" src="img/B21959_08_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 8.1: Running the example application</p>
<h1 class="heading" id="_idParaDest-149">Unit testing Node.js applications</h1>
<p class="normal1">Node.js<a id="_idIndexMarker410" class="calibre3"/> has a built-in test runner, which is a convenient <a id="_idIndexMarker411" class="calibre3"/>way to define and run unit tests. As much as I recommend TypeScript for development, unit tests are best written in pure JavaScript. Unit testing requires extensive use of fake objects – known as <em class="italic">mocks</em> – to isolate the code being tested from the rest of the application, and the process of creating mocks – known as <em class="italic">mocking</em> – relies on creating objects that have just enough functionality to run a test, which can upset the TypeScript compiler. To prepare for pure JavaScript unit tests, <em class="italic">Listing 8.2</em> changes the configuration for the TypeScript compiler. </p>
<div><p class="normal"><strong class="screentext">Deciding Whether to Unit Test</strong></p>
<p class="normal">Being able to easily perform unit testing is one of the benefits of using Node.js, but it isn’t for everyone, and I have no intention of pretending otherwise. I like unit testing, and I use it in my projects, but not all of them, and not as consistently as you might expect. I tend to focus on writing unit tests for features and functions that I know will be hard to write and likely will be the source of bugs in deployment. In these situations, unit testing helps structure my thoughts about how to best implement what I need. I find that just thinking about what I need to test helps produce ideas about potential problems, and that’s before I start dealing with actual bugs and defects. </p>
<p class="normal">That said, unit testing is a tool and not a religion, and only you know how much testing you require. If you don’t find unit testing useful or you have a different methodology that suits you better, then don’t feel you need to unit test just because it is fashionable. (However, if you don’t have a better methodology and you are not testing at all, then you are probably letting users find your bugs, which is rarely ideal. You don’t have to unit test, but you really should consider doing some testing of some kind.)</p>
<p class="normal">If you have not encountered unit testing before, then I encourage you to give it a try to see how it works. If you are not a fan of unit testing, then you can skip this section and move on to the <em class="italic">Debugging JavaScript code</em> section, where I demonstrate how to use the Node.js debugging features.</p>
</div>
<p class="packt_figref">Listing 8.2: Adding properties in the tsconfig.Json file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "extends": "@tsconfig/node20/tsconfig.json",
     "compilerOptions": {                      
         "rootDir": "src",  
         "outDir": "dist",
        <strong class="screentext"> "allowJs": true</strong>
     },
     <strong class="screentext">"include": ["src/**/*"]</strong>
}
</code></pre>
<p class="normal">The new <a id="_idIndexMarker412" class="calibre3"/>configuration properties tell the TypeScript compiler to<a id="_idIndexMarker413" class="calibre3"/> process JavaScript as well as TypeScript files and specify that all of the source code files are in the <code class="inlinecode">src</code> folder. </p>
<p class="normal">To get <a id="_idIndexMarker414" class="calibre3"/>started with<a id="_idIndexMarker415" class="calibre3"/> testing, add a file named <code class="inlinecode">readHandler.test.js</code> to the <code class="inlinecode">src</code> folder with the contents shown in <em class="italic">Listing 8.3</em>.</p>
<p class="packt_figref">Listing 8.3: The contents of the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
test("my first test", () =&gt; {
    // do nothing - test will pass
});
</code></pre>
<p class="normal">The testing functionality is provided in the <code class="inlinecode">node:test</code> module, and the most important function is <code class="inlinecode">test</code>, which is used to define a unit test. The <code class="inlinecode">test</code> function accepts a name for the test and a function, which is executed to perform the test.</p>
<p class="normal">Tests can be executed from the command line. Open a new command prompt and run the command shown in <em class="italic">Listing 8.4</em> in the <code class="inlinecode">webapp</code> folder. </p>
<p class="packt_figref">Listing 8.4: Running unit tests</p>
<pre class="programlisting1"><code class="hljs-con">node --test dist
</code></pre>
<p class="normal">The <code class="inlinecode">--test</code> argument executes the Node.js test runner. Test files are discovered automatically, either because the filename contains <code class="inlinecode">test</code> or because files are in a folder named <code class="inlinecode">test</code>. I followed the common convention of defining the tests for a module in a file that shares the module’s name but with the<code class="inlinecode">.test.js</code> suffix.</p>
<p class="normal">The TypeScript compiler will process the JavaScript file in the <code class="inlinecode">src</code> folder and generate a file in the <code class="inlinecode">dist</code> folder that contains the test code. The test runner will produce the following output, which may include additional characters, such as checkmarks, depending on your platform and command line:</p>
<pre class="programlisting1"><code class="hljs-con">...
my first test (0.5989ms)
tests 1
suites 0
pass 1
fail 0
cancelled 0
skipped 0
todo 0
duration_ms 51.685
...
</code></pre>
<p class="normal">The <a id="_idIndexMarker416" class="calibre3"/>test doesn’t do anything yet, but the output shows <a id="_idIndexMarker417" class="calibre3"/>the test runner has found the file and executed the function it contains.</p>
<p class="normal">The test runner can also be run in watch mode, where it will run tests automatically when there is a file change. <em class="italic">Listing 8.5</em> adds a new command to the <code class="inlinecode">scripts</code> section of the <code class="inlinecode">package.json</code> file.</p>
<div><p class="normal"><strong class="screentext">Using a Test Package</strong></p>
<p class="normal">I have used the built-in Node.js test runner in this chapter because it is simple to use and does everything that most projects require. But there are good open-source test packages available; the most popular is<a id="_idIndexMarker418" class="calibre3"/> Jest (<a href="https://jestjs.io" class="calibre3">https://jestjs.io</a>). A testing package can be useful if you have specialized testing needs or want to use the same package for testing the client- and server-side JavaScript code in your projects. </p>
</div>
<p class="packt_figref">Listing 8.5: Adding a command in the package.json file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">...
"scripts": {
    "server": "tsc-watch --noClear --onsuccess \"node dist/server.js\"",
    "client": "webpack serve",
    "start": "npm-run-all --parallel server client",
    <strong class="screentext">"test": "node --test --watch dist"</strong>
},
...
</code></pre>
<p class="normal">The <code class="inlinecode">--watch</code> argument puts the test runner into watch mode. Run the command shown in <em class="italic">Listing 8.6</em> in the <code class="inlinecode">webapp</code> folder to start the command defined in <em class="italic">Listing 8.5</em>. </p>
<p class="packt_figref">Listing 8.6: Running the Test Runner in Watch Mode</p>
<pre class="programlisting1"><code class="hljs-con">npm run test
</code></pre>
<p class="normal">The <a id="_idIndexMarker419" class="calibre3"/>test runner will start, discover the test file in<a id="_idIndexMarker420" class="calibre3"/> the <code class="inlinecode">dist</code> file, and run the test it contains, producing the following output:</p>
<pre class="programlisting"><code class="hljs-code">...
my first test (0.5732ms)
...
</code></pre>
<p class="normal"><em class="italic">Listing 8.7</em> changes the name given to the test to confirm the test watch mode is working.</p>
<p class="packt_figref">Listing 8.7: Changing the name in the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
<strong class="screentext">test("my new test name", () =&gt; {</strong>
    // do nothing - test will pass
});
</code></pre>
<p class="normal">The main build process will detect the change to the JavaScript file in the <code class="inlinecode">src</code> folder and create a corresponding file in the <code class="inlinecode">dist</code> folder. The Node.js test runner will detect the change to the pure JavaScript file and execute its contents, producing the following output:</p>
<pre class="programlisting"><code class="hljs-code">...
my first test (0.5732ms)
<strong class="screentext">my new test name (0.6408ms)</strong>
...
</code></pre>
<p class="normal">The Node.js test runner considers tests to have passed if they complete without throwing an exception, which is why the test passes, even though it doesn’t do anything. <em class="italic">Listing 8.8</em> modifies the sample test so that it fails.</p>
<p class="packt_figref">Listing 8.8: Creating a failing test in the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
test("my new test name", () =&gt; {
    <strong class="screentext">throw new Error("something went wrong");</strong>
});
</code></pre>
<p class="normal">When the <a id="_idIndexMarker421" class="calibre3"/>test runner executes the test, the exception is <a id="_idIndexMarker422" class="calibre3"/>thrown and the failure is displayed in the console output, along with some details about the exception:</p>
<pre class="programlisting"><code class="hljs-code">...
my first test (0.5732ms)
my new test name (0.6408ms)
<strong class="screentext">my new test name (0.6288ms)</strong>
<strong class="screentext">  Error: something went wrong</strong>
<strong class="screentext">      at TestContext.&lt;anonymous&gt; (C:\webapp\dist\readHandler.test.js:6:11)</strong>
...
</code></pre>
<h2 class="heading1" id="_idParaDest-150">Writing unit tests</h2>
<p class="normal1">A common approach to writing unit tests is to follow the <strong class="screentext">arrange/act/assert</strong> (<strong class="screentext">A/A/A</strong>) pattern, which <a id="_idIndexMarker423" class="calibre3"/>breaks unit tests into three parts. <em class="italic">Arrange</em> refers to setting up the conditions for the test, <em class="italic">act</em> refers to performing the<a id="_idIndexMarker424" class="calibre3"/> test, and <em class="italic">assert</em> refers to verifying that the result was the one that was expected.</p>
<h3 class="heading2" id="_idParaDest-151">Arranging a test</h3>
<p class="normal1">For web <a id="_idIndexMarker425" class="calibre3"/>applications, the arrange section of a unit test usually means simulating an HTTP request and response to be able to test a request handler. As a reminder, here is the <code class="inlinecode">readHandler</code> from the example project: </p>
<pre class="programlisting"><code class="hljs-code">import { Request, Response } from "express";
export const readHandler = (req: Request, resp: Response) =&gt; {   
    resp.cookie("sessionID", "mysecretcode");
    req.pipe(resp);
}
</code></pre>
<p class="normal">This handler does two things: sets a cookie and invokes the <code class="inlinecode">Request.pipe</code> method so that the body of the response is read from the body of the request. To test this functionality, the unit test needs a mock <code class="inlinecode">Request</code> that has a <code class="inlinecode">pipe</code> method and a <code class="inlinecode">Response</code> that has a <code class="inlinecode">cookie</code> method. The unit test doesn’t need to recreate the real functionality of the <code class="inlinecode">pipe</code> and <code class="inlinecode">cookie</code> methods because these are outside the scope of the code being tested. <em class="italic">Listing 8.9</em> uses the features provided by Node.js to create <a id="_idIndexMarker426" class="calibre3"/>mock objects. </p>
<p class="packt_figref">Listing 8.9: Creating mock HTTP objects in the readHandler.test.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
<strong class="screentext">test("readHandler tests", (testCtx) =&gt; {</strong>
<strong class="screentext">    // Arrange - set up the test</strong>
<strong class="screentext">    const req = {</strong>
<strong class="screentext"> </strong><strong class="screentext">pipe: testCtx.mock.fn()</strong>
<strong class="screentext">    };</strong>
<strong class="screentext">    const resp = {</strong>
<strong class="screentext">        cookie: testCtx.mock.fn()</strong>
<strong class="screentext">    };</strong>
<strong class="screentext">    // TODO - Act - perform the test</strong>
<strong class="screentext"> </strong>
<strong class="screentext">    // TODO - Assert - verify the results</strong>
});
</code></pre>
<p class="normal">A good mock object contains just enough functionality to run the test but also has to support inspecting the outcome. When the Node.js test runner invokes the test function, it provides a <code class="inlinecode">TestContext</code> object, whose <code class="inlinecode">mock</code> property returns a <code class="inlinecode">MockTracker</code> object that can be used to create mocks, and whose most useful methods are described in <em class="italic">Table 8.3</em>. </p>
<p class="packt_figref">Table 8.3: Useful MockTracker Methods </p>
<table class="table-container" id="table003-5">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">fn(orig, impl)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method creates a mock function. The optional arguments are the original implementation of the function and a new implementation. If the arguments are omitted, a <code class="inlinecode">no-op</code> function is returned.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">method(obj, name, impl, opts) </code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method creates a mock method. The arguments are an object and the method name to mock. The optional argument is a replacement implementation of the method.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">getter(obj, name, impl, opts)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">Similar to <code class="inlinecode">method</code> but creates a getter.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">setter(obj, name, impl, opts)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">Similar to <code class="inlinecode">method</code> but creates a setter.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The methods <a id="_idIndexMarker427" class="calibre3"/>described in <em class="italic">Table 8.3</em> are used to create functions or methods that keep track of how they are used, which is useful in the assert part of the test, described in the <em class="italic">Asserting test results</em> section.</p>
<p class="normal">The <code class="inlinecode">method</code>, <code class="inlinecode">getter</code>, and <code class="inlinecode">setter</code> methods can create wrappers around existing functionality, as demonstrated in the <em class="italic">Testing asynchronous code</em> section. It is difficult to wrap the HTTP request and response methods and properties because of the way they are created and their dependency on so much of the Node.js API. Instead, the <code class="inlinecode">fn</code> method can be used to create a function that tracks how it is used and provides a simple building block to create the features needed to test the handler. JavaScript functions can accept any number of arguments, which is how the function returned from the <code class="inlinecode">fn</code> method can be used anywhere. This is one of the reasons why writing tests in TypeScript can be so difficult and why pure JavaScript should be used.</p>
<h3 class="heading2" id="_idParaDest-152">Performing a test</h3>
<p class="normal1">For unit tests on <a id="_idIndexMarker428" class="calibre3"/>HTTP handlers, performing the test is often the simplest part of the process, because it involves invoking the handler function with the mock HTTP request and response objects, as shown in <em class="italic">Listing 8.10</em>. </p>
<p class="packt_figref">Listing 8.10: Performing the test in the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
<strong class="screentext">import { readHandler } from</strong><strong class="screentext"> "./readHandler";</strong>
test("readHandler tests", (testCtx) =&gt; {
    // Arrange - set up the test
    const req = {
        pipe: testCtx.mock.fn()
    };
    const resp = {
        cookie: testCtx.mock.fn()
    };
    <strong class="screentext">// Act - perform the test</strong>
<strong class="screentext">    readHandler(req, resp);</strong>
   
    // TODO - Assert - verify the results
});
</code></pre>
<h3 class="heading2" id="_idParaDest-153">Asserting test results</h3>
<p class="normal1">The methods<a id="_idIndexMarker429" class="calibre3"/> in <em class="italic">Table 8.3</em> produce results that have a <code class="inlinecode">mock</code> property that can be used to learn how a function or method was used when the test was performed. The <code class="inlinecode">mock</code> property returns a <code class="inlinecode">MockFunctionContext</code> object, whose most useful features are described in <em class="italic">Table 8.4</em>. </p>
<p class="packt_figref">Table 8.4: Useful MockFunctionContext Features</p>
<table class="table-container" id="table004-4">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">callCount()</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method returns the number of times the function or method has been called.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">calls</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method returns an array of objects, where each element describes one call.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The <a id="_idIndexMarker430" class="calibre3"/>result from the <code class="inlinecode">calls</code> property described in <em class="italic">Table 8.4</em> contains objects with the properties described in <em class="italic">Table 8.5</em>.</p>
<p class="packt_figref">Table 8.5: Useful Properties Used to Describe a Method or Function Call</p>
<table class="table-container" id="table005-3">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">arguments</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property returns an array of arguments that were passed to the function or method.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">result</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property returns the result produced by the function or method.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">error</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property returns an object if the function throws an error and <code class="inlinecode">undefined</code> if it does not.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">stack</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property returns an <code class="inlinecode">Error</code> object that can be used to determine where an error was thrown.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The mocked functions and methods act as spies that report on how they were used during the test, allowing the result to be easily inspected and assessed, as shown in <em class="italic">Listing 8.11</em>.</p>
<p class="packt_figref">Listing 8.11: Assessing rest results in the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
import { readHandler } from "./readHandler";
test("readHandler tests", (testCtx) =&gt; {
    // Arrange - set up the test
    const req = {
        pipe: testCtx.mock.fn()
    };
    const resp = {
        cookie: testCtx.mock.fn()
    };
    // Act - perform the test
    readHandler(req, resp);
<strong class="screentext">    // Assert - verify the results</strong>
<strong class="screentext">    if (req.pipe.mock.callCount() !== 1</strong><strong class="screentext"> ||</strong>
<strong class="screentext">        req.pipe.mock.calls[0].arguments[0] !== resp) {</strong>
<strong class="screentext">            throw new Error("Request not piped"</strong><strong class="screentext">);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    if (resp.cookie.mock.callCount() === 1) {</strong>
<strong class="screentext">        const [name, val] = resp.cookie.mock.calls[0</strong><strong class="screentext">].arguments;</strong>
<strong class="screentext">        if (name !== "sessionID" || val !== "mysecretcode") {</strong>
<strong class="screentext">            throw new Error("Cookie not set correctly");</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        throw</strong><strong class="screentext"> new Error("cookie method not called once");</strong>
<strong class="screentext">    }</strong>
});
</code></pre>
<p class="normal">The <a id="_idIndexMarker431" class="calibre3"/>new statements use the <code class="inlinecode">mock</code> properties to confirm that the <code class="inlinecode">pipe</code> and <code class="inlinecode">cookie</code> methods have been called once and have received the correct arguments.</p>
<p class="normal">The assessment of test results can be simplified by using <em class="italic">assertions</em>, which are methods that perform comparisons and throw exceptions more concisely. Node.js provides assertions in the <code class="inlinecode">assert</code> module and the most useful methods are described in <em class="italic">Table 8.6</em>. </p>
<p class="packt_figref">Table 8.6: Useful Assertions </p>
<table class="table-container" id="table006-3">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">assert(val)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method throws an error if <code class="inlinecode">val</code> isn’t truthy (as described in <em class="italic">Chapter 2</em>).</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">equal(v1, v2)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method throws an error if <code class="inlinecode">v1</code> doesn’t equal <code class="inlinecode">v2</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">notEqual(v1, v2)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method throws an error if <code class="inlinecode">v1</code> equals <code class="inlinecode">v2</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">deepStrictEqual(v1, v2)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method performs a deep comparison of <code class="inlinecode">v1</code> and <code class="inlinecode">v2</code> and throws an error if they do not match. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">notDeepStrictEqual(v1, v2)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method performs a deep comparison of <code class="inlinecode">v1</code> and <code class="inlinecode">v2</code> and throws an error if they match.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">match(str, regexp)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method throws an error if <code class="inlinecode">str</code> isn’t matched by the specified regular expression.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">doesNotMatch(str, regexp)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method throws an error if <code class="inlinecode">str</code> is matched by the specified regular expression.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Listing 8.12</em> revises the unit test to use the assertions to check the results.</p>
<p class="packt_figref">Listing 8.12: Using assertions in the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
import { readHandler } from "./readHandler";
<strong class="screentext">import { equal } from "assert";</strong>
test("readHandler tests", (testCtx) =&gt; {
    // Arrange - set up the test
    const req = {
        pipe: testCtx.mock.fn()
    };
    const resp = {
        cookie: testCtx.mock.fn()
    };
    // Act - perform the test
    readHandler(req, resp);
    // Assert - verify the results
    <strong class="screentext">equal</strong><strong class="screentext">(req.pipe.mock.callCount(), 1);</strong>
<strong class="screentext">    equal(req.pipe.mock.calls[0].arguments</strong><strong class="screentext">[0], resp);</strong>
<strong class="screentext">    equal(resp.cookie.mock.callCount(), 1);</strong>
<strong class="screentext">    equal(resp.cookie.mock.calls</strong><strong class="screentext">[0].arguments[0], "sessionID");</strong>
<strong class="screentext">    equal(resp.cookie.mock.calls[0].arguments</strong><strong class="screentext">[1], "mysecretcode");</strong>
});
</code></pre>
<p class="normal">The <code class="inlinecode">equal</code> method is<a id="_idIndexMarker432" class="calibre3"/> used to make a series of comparisons and will throw an error that will cause the test to fail if the values do not match.</p>
<h2 class="heading1" id="_idParaDest-154">Testing asynchronous code</h2>
<p class="normal1">The Node.js test runner has support<a id="_idIndexMarker433" class="calibre3"/> for testing asynchronous code. For promise-based code, the test fails if the promise is rejected. To prepare, <em class="italic">Listing 8.13</em> changes the handler so that it performs an asynchronous file read and sends the file contents to the client. </p>
<p class="packt_figref">Listing 8.13: Performing an asynchronous operation in the readHander.ts File in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request, Response } from "express";
<strong class="screentext">import { readFile } from "fs";</strong>
export const readHandler = (req: Request, resp: Response) =&gt; {   
    <strong class="screentext">readFile</strong><strong class="screentext">("data.json", (err, data) =&gt; {</strong>
<strong class="screentext">        if (err != null) {</strong>
<strong class="screentext">            resp.writeHead(500, err.message);</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            resp.setHeader</strong><strong class="screentext">("Content-Type", "application/json")</strong>
<strong class="screentext">            resp.write(data);</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        resp.end();       </strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">Ignore the output from the test runner for the moment and check the handler works by using a browser to request <a href="http://localhost:5000" class="calibre3">http://localhost:5000</a> and clicking the <strong class="screentext">Send Message</strong> button. The response will contain the JSON data read from the <code class="inlinecode">data.json</code> file, as shown in <em class="italic">Figure 8.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_08_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 8.2: Testing the revised handler</p>
<p class="normal">To write the<a id="_idIndexMarker434" class="calibre3"/> unit test, a different approach to mocking is required, as shown in <em class="italic">Listing 8.14</em>.</p>
<p class="packt_figref">Listing 8.14: Testing an asynchronous handler in the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
import { readHandler } from "./readHandler";
import { equal } from "assert";
<strong class="screentext">import fs from "fs";</strong>
test("readHandler tests", async (testCtx) =&gt; {
    // Arrange - set up the test
   <strong class="screentext"> const data = "</strong><strong class="screentext">json-data";</strong>
<strong class="screentext">    testCtx.mock.method(fs, "readFile", (file, cb) =&gt; cb(undefined, data));</strong>
<strong class="screentext">    const req = {};</strong>
<strong class="screentext"> </strong>
<strong class="screentext">    const resp = {</strong>
<strong class="screentext"> </strong><strong class="screentext">setHeader: testCtx.mock.fn(),</strong>
<strong class="screentext">        write: testCtx.mock.fn(),</strong>
<strong class="screentext">        end: testCtx.mock.fn()</strong>
<strong class="screentext">    };</strong>
    // Act - perform the test
    <strong class="screentext">await readHandler(req, resp);</strong>
    // Assert - verify the results
  <strong class="screentext">  equal(resp.setHeader.mock.calls[0].arguments[0], "</strong><strong class="screentext">Content-Type");</strong>
<strong class="screentext">    equal(resp.setHeader.mock.calls[0].arguments[1], "application/json");</strong>
<strong class="screentext">    equal(resp.</strong><strong class="screentext">write.mock.calls[0].arguments[0], data);</strong>
<strong class="screentext">    equal(resp.end.mock.callCount(), </strong><strong class="screentext">1);</strong>
});
</code></pre>
<p class="normal">The key to this test is being able to mock the <code class="inlinecode">readFile</code> function in the <code class="inlinecode">fs</code> module, which is done by this statement:</p>
<pre class="programlisting"><code class="hljs-code">...
testCtx.mock.<strong class="screentext">method</strong>(fs, "readFile", (file, cb) =&gt; cb(undefined, data));
...
</code></pre>
<p class="normal">This is difficult to explain because the name and the result use the same word: the method named <code class="inlinecode">method</code> mocks a method on an object. In this case, the object is the entire <code class="inlinecode">fs</code> module, which was imported like this:</p>
<pre class="programlisting"><code class="hljs-code">...
import fs from "fs";
...
</code></pre>
<p class="normal">The <a id="_idIndexMarker435" class="calibre3"/>top-level functions defined by the module are presented as methods on an object named <code class="inlinecode">fs</code>, which allows them to be mocked using <code class="inlinecode">method</code>. In this case, the <code class="inlinecode">readFile</code> function has been replaced with a mock implementation that invokes the callback function with test data, making it possible to perform the test without having to read from the file system. The other mocks in this example are created with the <code class="inlinecode">fn</code> method and correspond to the <code class="inlinecode">Response</code> methods that are called by the handler being tested.</p>
<h3 class="heading2" id="_idParaDest-155">Testing promises</h3>
<p class="normal1">Testing code that uses <a id="_idIndexMarker436" class="calibre3"/>promises is done in much the same way, except the mock resolves the promise with test data. <em class="italic">Listing 8.15</em> updates the handler to use the promise-based version of the <code class="inlinecode">readFile</code> function. </p>
<p class="packt_figref">Listing 8.15: Using promises in the readHandler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request, Response } from "express";
<strong class="screentext">import { readFile } from "fs/promises";</strong>
<strong class="screentext">export const readHandler = async (req: Request, resp: Response) =&gt; {   </strong>
<strong class="screentext"> </strong><strong class="screentext">try {</strong>
<strong class="screentext">        resp.setHeader("Content-Type", "application/json")</strong>
<strong class="screentext">        resp.write(await readFile("data.json"));</strong>
<strong class="screentext">    } catch (err) {</strong>
<strong class="screentext">        resp.writeHead(</strong><strong class="screentext">500);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    resp.end();</strong>
}
</code></pre>
<p class="normal"><em class="italic">Listing 8.16</em> updates the unit test so that the mock resolves a promise.</p>
<p class="packt_figref">Listing 8.16: Testing a promise in the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
import { readHandler } from "./readHandler";
import { equal } from "assert";
<strong class="screentext">import fs from "fs/promises";</strong>
test("readHandler tests", async (testCtx) =&gt; {
    // Arrange - set up the test
    const data = "json-data";
    <strong class="screentext">testCtx.mock.method(fs, "readFile", async () =&gt; data);</strong>
    const req = {};
       
    const resp = {
        setHeader: testCtx.mock.fn(),
        write: testCtx.mock.fn(),
        end: testCtx.mock.fn()
    };
    // Act - perform the test
    await readHandler(req, resp);
    // Assert - verify the results
    equal(resp.setHeader.mock.calls[0].arguments[0], "Content-Type");
    equal(resp.setHeader.mock.calls[0].arguments[1], "application/json");
    equal(resp.write.mock.calls[0].arguments[0], data);
    equal(resp.end.mock.callCount(), 1);
});
</code></pre>
<p class="normal">The <a id="_idIndexMarker437" class="calibre3"/>mock is an asynchronous function that produces the test data when it resolves. The rest of the unit test is unchanged.</p>
<h2 class="heading1" id="_idParaDest-156">Creating subtests</h2>
<p class="normal1">The test in <em class="italic">Listing 8.16</em> doesn’t test how<a id="_idIndexMarker438" class="calibre3"/> the handler responds when there is a problem reading the data from the file. A little more work is required, as shown in <em class="italic">Listing 8.17</em>. </p>
<p class="packt_figref">Listing 8.17: Testing multiple outcomes in the readHandler.test.js file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { test } from "node:test";
import { readHandler } from "./readHandler";
import { equal } from "assert";
import fs from "fs/promises";
<strong class="screentext">const createMockResponse = (testCtx) =&gt; ({</strong>
<strong class="screentext">    writeHead</strong><strong class="screentext">: testCtx.mock.fn(),</strong>
<strong class="screentext">    setHeader: testCtx.mock.fn(),</strong>
<strong class="screentext">    write: testCtx.mock.fn(),</strong>
<strong class="screentext">    end: testCtx.mock</strong><strong class="screentext">.fn()   </strong>
<strong class="screentext">});</strong>
test("readHandler tests", async (testCtx) =&gt; {
    // Arrange - set up the test
    const req = {};
       
    <strong class="screentext">// const resp = {</strong>
<strong class="screentext">    //     setHeader: testCtx.mock.fn(),</strong>
<strong class="screentext">    //     write: testCtx.mock.fn(),</strong>
<strong class="screentext">    //     end: testCtx.mock.fn()</strong>
<strong class="screentext">    // };</strong>
<strong class="screentext">    // Test the successful outcome</strong>
<strong class="screentext">    await testCtx.test("Successfully reads file", async (innerCtx) =&gt; {</strong>
<strong class="screentext">        // Arrange - set up the test</strong>
<strong class="screentext">        const data = "json-data";</strong>
<strong class="screentext">        innerCtx.mock</strong><strong class="screentext">.method(fs, "readFile", async () =&gt; data);</strong>
<strong class="screentext">        const resp = createMockResponse(innerCtx);</strong>
<strong class="screentext">        // Act - perform the test</strong>
<strong class="screentext">        await readHandler(req, resp);</strong>
<strong class="screentext">        // Assert - verify the results</strong>
<strong class="screentext">        equal</strong><strong class="screentext">(resp.setHeader.mock.calls[0].arguments[0], "Content-Type");</strong>
<strong class="screentext">        equal(resp.setHeader.mock</strong><strong class="screentext">.calls[0].arguments[1], "application/json");</strong>
<strong class="screentext">        equal(resp.write.mock.calls[0</strong><strong class="screentext">].arguments[0], data);</strong>
<strong class="screentext">        equal(resp.end.mock.callCount(), 1);</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    // Test the failure outcome</strong>
<strong class="screentext">    await testCtx.test</strong><strong class="screentext">("Handles error reading file", async (innerCtx) =&gt; {</strong>
<strong class="screentext">        // Arrange - set up the test</strong>
<strong class="screentext">        innerCtx.mock.method(fs, "readFile", </strong>
<strong class="screentext">            () =&gt; Promise.reject("file error"</strong><strong class="screentext">));</strong>
<strong class="screentext">        const resp = createMockResponse(innerCtx);</strong>
<strong class="screentext">        // Act - perform the test</strong>
<strong class="screentext">        await readHandler(req, resp);</strong>
<strong class="screentext"> </strong>
<strong class="screentext">        // Assert - verify the results</strong>
<strong class="screentext">        equal(resp.writeHead.mock.calls</strong><strong class="screentext">[0].arguments[0], 500);</strong>
<strong class="screentext">        equal(resp.end.mock.callCount(), 1);</strong>
<strong class="screentext">    });</strong>
});
</code></pre>
<p class="normal">The <code class="inlinecode">TestContext</code> class<a id="_idIndexMarker439" class="calibre3"/> defines a <code class="inlinecode">test</code> method that can be used to create subtests. Subtests receive their own context object that can be used to create mocks specific to that subtest and <em class="italic">Listing 8.17</em> uses this feature to create tests that use different implementations for the mock <code class="inlinecode">readFile</code> function. Save the changes and the output from the test runner will reflect the addition of the subtests, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
readHandler tests
  Successfully reads file (0.5485ms)
  Handles error reading file (0.2952ms)
readHandler tests (2.0538ms)
...
</code></pre>
<p class="normal">Notice that the subtests are asynchronous and require the <code class="inlinecode">await</code> keyword. If you don’t wait for subtests, then the top-level test will be completed early, and the test runner will report an error.</p>
<h1 class="heading" id="_idParaDest-157">Debugging javascript code</h1>
<p class="normal1">Unit testing<a id="_idIndexMarker440" class="calibre3"/> is the process of confirming code behaves as it should; debugging<a id="_idIndexMarker441" class="calibre3"/> is the process of figuring out why it doesn’t. Before starting, use <em class="italic">Ctrl + C</em> to stop the build process and the unit-testing process. Once the processes have stopped, run the command shown in <em class="italic">Listing 8.18</em> to start the webpack <a id="_idIndexMarker442" class="calibre3"/>development server on its own. The debugger will be applied to the backend server, which will be started on its own, but relies on webpack to handle requests for client-side content. </p>
<p class="packt_figref">Listing 8.18: Starting the webpack development server</p>
<pre class="programlisting1"><code class="hljs-con">npm run client
</code></pre>
<p class="normal">The<a id="_idIndexMarker443" class="calibre3"/> next step is to configure the TypeScript compiler so that it generates source maps, as shown in <em class="italic">Listing 8.19</em>, which lets the debugger correlate the pure JavaScript being executed by Node.js with the TypeScript code written by the developer. </p>
<p class="packt_figref">Listing 8.19: Enabling source maps in the tsconfig.json file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "extends": "@tsconfig/node20/tsconfig.json",
     "compilerOptions": {                      
         "rootDir": "src",  
         "outDir": "dist",
         "allowJs": true,
         <strong class="screentext">"sourceMap": true</strong>
     },
     "include": ["src/**/*"]
}
</code></pre>
<p class="normal">When you save the file, the compiler will start generating files with the <code class="inlinecode">map</code> file extension in the <code class="inlinecode">dist</code> folder.</p>
<h2 class="heading1" id="_idParaDest-158">Adding code breakpoints</h2>
<p class="normal1">Code editors that<a id="_idIndexMarker444" class="calibre3"/> have good TypeScript support, such as Visual Studio Code, allow breakpoints to be added to code files. My experience with this feature has been mixed, and I have found them unreliable, which is why I rely on the less elegant but more predictable <code class="inlinecode">debugger</code> JavaScript keyword.</p>
<p class="normal">When a JavaScript application is executed through a debugger, execution halts when the <code class="inlinecode">debugger</code> keyword is encountered, and control is passed to the developer. <em class="italic">Listing 8.20</em> adds the <code class="inlinecode">debugger</code> keyword to the <code class="inlinecode">readHandler.ts</code> file. </p>
<p class="packt_figref">Listing 8.20: Adding the debugger keyword in the readHandler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request, Response } from "express";
import { readFile } from "fs/promises";
export const readHandler = async (req: Request, resp: Response) =&gt; {   
    try {
        resp.setHeader("Content-Type", "application/json")
        resp.write(await readFile("data.json"));
        <strong class="screentext">debugger</strong>
    } catch (err) {
        resp.writeHead(500);
    }
    resp.end();
}
</code></pre>
<p class="normal">There will be no change in the output when the code is executed because Node.js ignores the <code class="inlinecode">debugger</code> keyword by default.</p>
<h2 class="heading1" id="_idParaDest-159">Using Visual Studio Code for debugging</h2>
<p class="normal1">Most good code editors <a id="_idIndexMarker445" class="calibre3"/>have some degree of support for debugging TypeScript and JavaScript code. In this section, I will show you how to perform debugging with Visual Studio Code to give you an idea of the process. There may be different steps required if you use another editor, but the basic approach is likely to be similar. </p>
<p class="normal">To set up the configuration for debugging, select <strong class="screentext">Add Configuration</strong> from the <strong class="screentext">Run</strong> menu and select <strong class="screentext">Node.js</strong> from the list of environments when prompted, as shown in <em class="italic">Figure 8.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_08_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 8.3: Selecting the debugging environment</p>
<p class="normal">Visual Studio Code <a id="_idIndexMarker446" class="calibre3"/>will create a <code class="inlinecode">.vscode</code> folder and a file called <code class="inlinecode">launch.json</code>, which is used to configure the debugger. Change the value of the <code class="inlinecode">program</code> property so that the debugger executes the JavaScript code in the <code class="inlinecode">dist</code> folder, as shown in <em class="italic">Listing 8.21</em>.</p>
<p class="packt_figref">Listing 8.21: Configuring the debugger in the launch.json file in the .vscode folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "Launch Program",
            "skipFiles": [
                "&lt;node_internals&gt;/**"
            ],
           <strong class="screentext"> "program": "${workspaceFolder}/dist/server.js"</strong><strong class="screentext">,</strong>
            "preLaunchTask": "tsc: build - tsconfig.json",
            "outFiles": [
                "${workspaceFolder}/dist/**/*.js"
            ]
        }
    ]
}
</code></pre>
<p class="normal">Save the changes to the <code class="inlinecode">launch.json</code> file and select <strong class="screentext">Start Debugging</strong> from the <strong class="screentext">Run</strong> menu. Visual Studio Code will start Node.js and execution will continue as normal until the <code class="inlinecode">debugger</code> keyword is reached. Use a browser to request <code class="inlinecode">http://localhost:5000</code> and click the <strong class="screentext">Send Message</strong> button. The request will be passed to the handler for processing, and when the <code class="inlinecode">debugger</code> keyword is reached, execution will be halted and control will be transferred to the debugging popup, as shown in <em class="italic">Figure 8.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_08_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 8.4: Debugging with Visual Studio Code</p>
<p class="normal">The state of the<a id="_idIndexMarker447" class="calibre3"/> application is displayed in the sidebar, showing the variables that are set at the point that execution was halted. Standard debugging features are available, including setting watches, stepping into and over statements, and resuming execution. The <strong class="screentext">Debug Console</strong> window allows JavaScript statements to be executed in the context of the application so that entering a variable name and pressing <em class="italic">Return</em>, for example, will return the value assigned to that variable.</p>
<h2 class="heading1" id="_idParaDest-160">Using the remote Node.js debugger</h2>
<p class="normal1">If you don’t want to use <a id="_idIndexMarker448" class="calibre3"/>the code editor for debugging, then Google Chrome provides good integrated debugging for Node.js, using the same features that are used to debug client-side code. Stop the Visual Studio Code debugger from the previous section and run the command shown in <em class="italic">Listing 8.22</em> in the <code class="inlinecode">webapp</code> folder to start Node.js in debugging mode. </p>
<p class="packt_figref">Listing 8.22: Starting Node.js in debugging mode</p>
<pre class="programlisting1"><code class="hljs-con">node --inspect dist/server.js
</code></pre>
<p class="normal">When Node.js starts, it will produce messages like these, which include details of the URL on which it is ready to accept debugging requests:</p>
<pre class="programlisting1"><code class="hljs-con"><strong class="screentext">Debugger listening on ws://127.0.0.1:9229/faed1dec-fbb0-4425-bd87-410c98980716</strong>
For help, see: https://nodejs.org/en/docs/inspector
HTTP Server listening on port 5000
Debugger attached.
</code></pre>
<p class="normal">Using Google<a id="_idIndexMarker449" class="calibre3"/> Chrome, request <code class="inlinecode">chrome://inspect</code> and click on the <strong class="screentext">Open Dedicated DevTools for Node</strong> option and the debugging window will open, as shown in <em class="italic">Figure 8.5</em>. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">All of the browsers that use the Chromium engine support this feature, including Brave, Opera, and Edge. Use the name of the browser for the URL that opens the Node.js tools, such as <code class="inlinecode">brave://inspect</code> for the Brave browser. This doesn’t work for Firefox, which has its own browser engine. </p>
</div>
<figure class="mediaobject"><img alt="" src="img/B21959_08_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 8.5: Using the chrome node.Js debugging features</p>
<p class="normal">Open a new <a id="_idIndexMarker450" class="calibre3"/>browser window, request <code class="inlinecode">http://localhost:5000</code>, and click <strong class="screentext">Send Message</strong>. As the request is being processed, Node.js reaches the <code class="inlinecode">debugger</code> keyword. Execution is halted and control is passed to the Chrome developer tools, as shown in <em class="italic">Figure 8.6</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_08_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 8.6: The Chrome developer tools debugging Node.js</p>
<h1 class="heading" id="_idParaDest-161">Summary</h1>
<p class="normal1">In this chapter, I described the Node.js features for unit testing and debugging.</p>
<ul class="calibre4">
<li class="bulletlist">Node.js includes a built-in test runner, with support for executing tests and creating mock functions and methods.</li>
<li class="bulletlist1">Unit tests for web applications focus on request handling and require mocks of HTTP requests and responses.</li>
<li class="bulletlist1">Third-party packages, such as Jest, can be used for projects that require the same test tools for client- and server-side JavaScript code.</li>
<li class="bulletlist1">Node.js includes support for debugging, which can be performed with many code editors or with one of the Chromium-based browsers, such as Google Chrome.</li>
</ul>
<p class="normal">In the next part of this book, I demonstrate how Node.js can be used to create the features required for web applications, such as generating dynamic content and authenticating users.</p>
</div>
</body></html>