<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing in Elm</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we will learn how to test our Elm apps.</span></p>
<p><span>The topics we will cover include:</span></p>
<ul>
<li>Testing Elm apps with <kbd>elm-test</kbd></li>
<li>Understanding the structure and the role of the <kbd>elm-package.json</kbd> file</li>
<li>Understanding the structure and functionality of the <kbd>tests</kbd> folder</li>
<li>Working with <kbd>describe</kbd>, <kbd>test</kbd>, and <kbd>Expect</kbd></li>
<li>Writing easier-to-understand tests with the <kbd>left pipe operator</kbd></li>
<li>Using the <kbd>let-in</kbd> and <kbd>case-of</kbd> expressions in our tests</li>
<li>Fuzz testing in Elm</li>
</ul>
<p>After completing this chapter, you will:</p>
<ul>
<li>Have a general idea of how unit testing works</li>
<li>Understand how unit testing and fuzz testing works in Elm</li>
<li>Understand different ways in which you can test your Elm apps</li>
<li>Be able to successfully deploy a variety of tests in your Elm apps</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Elm testing</h1>
                </header>
            
            <article>
                
<p>Since the compiler catches all errors at compilation, the highly-touted zero runtime exceptions is the expected outcome for Elm apps that compile successfully.</p>
<p>Since that is the case, one might ask whether we need to test our Elm apps at all. The answer is a resounding yes, primarily because the compiler will not test the <em>behavior</em> of the app. While the Elm compiler's error-checking is indeed a wonderful tool, i<span>t will only test for logical inconsistencies, and that is pretty much it.</span></p>
<p>To prepare for this chapter, we'll start with the code from the previous chapter. Simply copy the entire folder titled <kbd>improved-weather-app-ch8</kbd> and paste it in another location.</p>
<p>The code files that come with this book have this pasted folder inside <kbd>chapter9</kbd>, and the copy-pasted folder that can be found <em>inside</em> the <kbd>chapter9</kbd> folder has been renamed to <kbd>weather-app-with-tests-ch9</kbd>.</p>
<div class="packt_tip">It's sometimes helpful to simply copy and paste an existing Elm project into a new folder and then change it, rather than create it from scratch with, for example, the <kbd>create-elm-app</kbd> package.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding how testing works in Elm</h1>
                </header>
            
            <article>
                
<p>We'll begin working with testing in Elm by pointing our console to the <kbd>weather-app-with-tests-ch9</kbd> folder.</p>
<p>Once we have our terminal pointed to the proper directory, we will need to install <kbd>elm-test</kbd> as an npm package. There are a number of utilities used in the Elm community that have their npm versions, and <kbd>elm-test</kbd> is just one of them.</p>
<p>Thus, to install <kbd>elm-test</kbd>, let's run:</p>
<pre><strong>npm install -g elm-test</strong></pre>
<p>That's it! The <kbd>elm-test</kbd> npm package is now available globally, because we passed the <kbd>-g</kbd> flag to the command. What this means is we can use elm-test in any folder, not just the one we are currently in.</p>
<div class="packt_infobox">Note that the installation of the elm-test npm package will take some time, so feel free to take a break while it is being installed.</div>
<p>Once the installation gets going, a number of messages will be logged to the console. These messages will look similar to the following:</p>
<pre><strong>C:\Users\PC\AppData\Roaming\npm\elm-test -&gt; C:\Users\PC\AppData\Roaming\npm\node_modules\elm-test\bin\elm-test</strong><br/><br/><strong>&gt; elm-test@0.18.12 install C:\Users\PC\AppData\Roaming\npm\node_modules\elm-test</strong><br/><strong>&gt; node install.js</strong><br/><br/><strong>Downloading binaries from https://dl.bintray.com/elmlang/elm-test/0.18.12/win32-x64.tar.gz</strong><br/><strong>Successfully downloaded and processed https://dl.bintray.com/elmlang/elm-test/0.18.12/win32-x64.tar.gz</strong><br/><strong>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.2 (node_modules\elm-test\node_modules\fsevents):</strong><br/><strong>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.2: wanted {"os":"darwin","arch":"any"} (current: {"os":"win32","arch":"x64"})</strong><br/><br/><strong>+ elm-test@0.18.12</strong><br/><strong>added 166 packages in 649.159s</strong></pre>
<p>Note the last line of the preceding code, which reads:</p>
<pre><strong>added 166 packages in 649.159s</strong></pre>
<p>This means that the installation took a bit over 10 minutes, which is a perfect opportunity to make yourself a nice beverage while waiting for the installation to complete. Once the installation of <kbd>elm-test</kbd> is complete, we can add the tests folder to our existing elm app simply by running the following command:</p>
<pre><strong>elm-test init</strong></pre>
<p>Once the preceding command gets run in the console, the console will record the progress by logging the following messages:</p>
<pre><strong>Starting downloads...</strong><br/><br/><strong>  ● debois/elm-dom 1.2.3</strong><br/><strong>  ● eeue56/elm-html-query 3.0.0</strong><br/><strong>  ● eeue56/elm-html-in-elm 5.2.0</strong><br/><strong>  ● eeue56/elm-lazy 1.0.0</strong><br/><strong>  ● eeue56/elm-lazy-list 1.0.0</strong><br/><strong>  ● eeue56/elm-html-test 5.1.3</strong><br/><strong>  ● eeue56/elm-shrink 1.0.0</strong><br/><strong>  ● elm-community/elm-test 4.2.0</strong><br/><strong>  ● elm-lang/core 5.1.1</strong><br/><strong>  ● debois/elm-mdl 8.1.0</strong><br/><strong>  ● elm-lang/dom 1.1.1</strong><br/><strong>  ● elm-lang/html 2.0.0</strong><br/><strong>  ● elm-lang/http 1.0.0</strong><br/><strong>  ● elm-lang/mouse 1.0.1</strong><br/><strong>  ● elm-lang/virtual-dom 2.0.4</strong><br/><strong>  ● elm-lang/window 1.0.1</strong><br/><strong>  ● mgold/elm-random-pcg 5.0.2</strong><br/><strong>  ● myrho/elm-round 1.0.2</strong><br/><br/><strong>Packages configured successfully!</strong></pre>
<p>Let's run the <kbd>dir</kbd> command to see the structure of our project, from its root:</p>
<pre><strong>dir</strong></pre>
<p>This command will return:</p>
<pre><strong>elm-package.json  elm-stuff  public  README.md  src  tests</strong></pre>
<p>Now, let's change to the <kbd>tests</kbd> folder by running <kbd>cd tests</kbd>. Next, let's inspect the structure of the <kbd>tests</kbd> folder by running the <kbd>dir</kbd> command again. What we get back is the following:</p>
<pre><strong>elm-package.json  elm-stuff  Example.elm  Tests.elm</strong></pre>
<p>The first file in the list, <kbd>elm-package.json</kbd>, lists all the dependencies that are needed for our tests. Here is the content of the <kbd>elm-package.json</kbd> file that's located inside the <kbd>tests</kbd> folder:</p>
<pre>{<br/>    "version": "1.0.0",<br/>    "summary": "Test Suites",<br/>    "repository": "https://github.com/user/project.git",<br/>    "license": "BSD3",<br/>    "source-directories": [<br/>        "..\\src",<br/>        "."<br/>    ],<br/>    "exposed-modules": [],<br/>    "dependencies": {<br/>        "debois/elm-mdl": "8.1.0 &lt;= v &lt; 9.0.0",<br/>        "eeue56/elm-html-test": "5.1.3 &lt;= v &lt; 6.0.0",<br/>        "elm-community/elm-test": "4.0.0 &lt;= v &lt; 5.0.0",<br/>        "elm-lang/core": "5.0.0 &lt;= v &lt; 6.0.0",<br/>        "elm-lang/html": "2.0.0 &lt;= v &lt; 3.0.0",<br/>        "elm-lang/http": "1.0.0 &lt;= v &lt; 2.0.0",<br/>        "myrho/elm-round": "1.0.2 &lt;= v &lt; 2.0.0"<br/>    },<br/>    "elm-version": "0.18.0 &lt;= v &lt; 0.19.0"<br/>}</pre>
<p>The following lines from the preceding code are used for the semantic versioning of our package:</p>
<pre>    "version": "1.0.0",<br/>    "summary": "Test Suites",<br/>    "repository": "https://github.com/user/project.git",<br/>    "license": "BSD3",   </pre>
<p>These lines are only relevant if you are going to publish a package on the Elm package page. Source directories lists the folders where our source files are located. In the case of our <kbd>tests</kbd> folder, it needs to have access to itself, signified by the <kbd>.</kbd>, and it needs to have access to its parent folder's <kbd>src</kbd> folder, signified by <kbd>..\\src</kbd>:</p>
<pre>    "source-directories": [<br/>        "..\\src",<br/>        "."<br/>    ],</pre>
<p>Exposed modules list all the modules that you want to expose to the public. This is only used when publishing a package and it does not need to be specified otherwise.</p>
<p>Dependencies lists all the packages that our tests depend on. It is interesting to compare the list of dependencies from the root of our weather app's folder with the list of dependencies that our tests are using. To compare the two, let's begin by listing the dependencies from the weather app's folder:</p>
<pre>    "dependencies": {<br/>        "debois/elm-mdl": "8.1.0 &lt;= v &lt; 9.0.0",<br/>        "elm-lang/core": "5.0.0 &lt;= v &lt; 6.0.0",<br/>        "elm-lang/html": "2.0.0 &lt;= v &lt; 3.0.0",<br/>        "elm-lang/http": "1.0.0 &lt;= v &lt; 2.0.0",<br/>        "myrho/elm-round": "1.0.2 &lt;= v &lt; 2.0.0"<br/>    },</pre>
<p>Next, let's list the dependencies inside the <kbd>test</kbd> folder:</p>
<pre>    "dependencies": {<br/>        "debois/elm-mdl": "8.1.0 &lt;= v &lt; 9.0.0",<br/>        "eeue56/elm-html-test": "5.1.3 &lt;= v &lt; 6.0.0",<br/>        "elm-community/elm-test": "4.0.0 &lt;= v &lt; 5.0.0",<br/>        "elm-lang/core": "5.0.0 &lt;= v &lt; 6.0.0",<br/>        "elm-lang/html": "2.0.0 &lt;= v &lt; 3.0.0",<br/>        "elm-lang/http": "1.0.0 &lt;= v &lt; 2.0.0",<br/>        "myrho/elm-round": "1.0.2 &lt;= v &lt; 2.0.0"<br/>    },</pre>
<p>As we can see, the <kbd>tests</kbd> folder includes all the dependencies used by our weather app, plus some additional dependencies. Since we already know what the packages inside the weather app's <kbd>src</kbd> folder do, let's focus on those that are specific to our tests folder:</p>
<pre>        "eeue56/elm-html-test": "5.1.3 &lt;= v &lt; 6.0.0",<br/>        "elm-community/elm-test": "4.0.0 &lt;= v &lt; 5.0.0",</pre>
<p>As we can see, there are two packages that are specifically used in our <kbd>tests</kbd> folder. Before looking into what each of them does, let's briefly discuss package naming conventions, as well as our dependencies' versions as they were listed previously.</p>
<p>The way that Elm package naming works is simple. The part of the package name before the slash is the name of the GitHub account associated with the package. In other words, it's the GitHub username of the package author. The part of the package name after the slash should be as descriptive as possible. So, rather than enforcing unique naming for each package, Elm's philosophy is to have as descriptive a name as possible for a package, which will allow its potential users to discern the purpose of the package just by looking at its name. Thus, it's entirely possible that there is more than one <kbd>elm-html-test</kbd> package, and the uniqueness of the name is determined by the username of the package author.</p>
<p>The versions required for our <kbd>eeue56/elm-html-test</kbd> dependency are in a range between 5.1.3 and 6.0.0, meaning, that the lowest acceptable version is 5.1.3 and the highest acceptable version is 6.0.0.</p>
<p>To understand what these two packages do, we can refer to their official documentation, which is available at <a href="http://package.elm-lang.org/packages/elm-community/elm-test/latest">http://package.elm-lang.org/packages/elm-community/elm-test/latest</a> and <a href="http://package.elm-lang.org/packages/eeue56/elm-html-test/latest">http://package.elm-lang.org/packages/eeue56/elm-html-test/latest</a>.</p>
<p>The <kbd>elm-community/elm-test</kbd> package allows us to write unit tests and fuzz tests. <kbd>eeue56/elm-html-test</kbd> allows us to test views by specifying the HTML values that we expect.</p>
<p>Continuing to inspect the contents of the tests folder, the <kbd>tests/elm-stuff</kbd> folder contains the downloaded packages and the list of exact versions of our dependencies, as listed in <kbd>exact-dependencies.json</kbd>. Next, the <kbd>Example.elm</kbd> file has all the necessary setup for us to run our first test. This is the code that our <kbd>Example.elm</kbd> file contains:</p>
<pre>module Example exposing (..)<br/><br/>import Expect exposing (Expectation)<br/>import Fuzz exposing (Fuzzer, int, list, string)<br/>import Test exposing (..)<br/><br/><br/>suite : Test<br/>suite =<br/>    todo "Implement our first test. See http://package.elm-lang.org/packages/elm-community/elm-test/latest for how to do this!"</pre>
<p>The code in this file follows the same rules as any other Elm code. On the first line, we are exposing the <kbd>Example</kbd> module. We follow it up with importing <kbd>Expect</kbd>, <kbd>Fuzz</kbd>, and <kbd>Test</kbd>, which are all needed for our tests to work. </p>
<p>It is helpful to be familiar with some of the jargon of software testing, as it will give some more context to our test writing. Tests are grouped into test suites. A test suite holds test cases. A test case is the smallest test unit. Therefore, appropriately, we start our testing in <kbd>Example.elm</kbd> by specifying a <kbd>suite</kbd> function, which will hold our tests. As we can see, the <kbd>suite</kbd> function is of type <kbd>Test</kbd>. The official documentation on <kbd>Test</kbd> can be found at <a href="http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#Test">http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#Test</a>.</p>
<p>As the official documentation reads, a <kbd>Test</kbd> will produce at least one <kbd>Expectation</kbd>. Let's look at some other functions we'll use in our tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The describe function </h1>
                </header>
            
            <article>
                
<p>Our tests are grouped inside a <kbd>List</kbd>. To describe what this <kbd>List</kbd> of tests is doing, we use the <kbd>describe</kbd> function. The signature of the <kbd>describe</kbd> function can be found at this link <a href="http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#describe">http://package.elm-lang.org/packages/elm-community/elm-test/latest/Test#describe</a></p>
<p>As we can see from the URL <span>provided</span><span>, the</span> <kbd>describe</kbd> <span>function takes a</span> <kbd>String</kbd> <span>and a</span> <kbd>List</kbd> <span>of</span> <kbd>Tests</kbd><span>, and returns a</span> <kbd>Test</kbd><span>. In other words, it follows this kind of structure:</span></p>
<pre>describe "An arbitrary description of our test" <br/>  [ test ...<br/>  , test ...<br/>  , test ... <br/>  ]</pre>
<p>Note that this is not the actual Elm code, but rather an Elm-like pseudocode, written as an intermediate step to better understand tests in Elm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The test and Expect functions</h1>
                </header>
            
            <article>
                
<p>The <kbd>test</kbd> function is used to write the actual unit test. The <kbd>test</kbd> function can have only one <kbd>Expectation</kbd>, and returns a <kbd>Test</kbd>. </p>
<p><kbd>Expectation</kbd> is a type alias. It can be one of the two: a <kbd>pass</kbd> or a <kbd>fail</kbd>. <kbd>Expect</kbd> has several functions, such as <kbd>Expect.equal</kbd>, <kbd>Expect.notEqual</kbd>, <kbd>Expect.lessThan</kbd>, and so on. For the full list of <kbd>Expect</kbd> functions, refer to the official documentation at <a href="http://package.elm-lang.org/packages/elm-community/elm-test/latest/Expect">http://package.elm-lang.org/packages/elm-community/elm-test/latest/Expect</a>.</p>
<p>Now that we have covered some of the concepts and described the functions we will use, it's time to write our first unit test inside <kbd>Example.elm</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing unit tests in Elm</h1>
                </header>
            
            <article>
                
<p>Let's update the code of our <kbd>suite</kbd> function, so that it looks like this:</p>
<pre>suite : Test<br/>suite =<br/>  describe "Zero is equal to zero"<br/>    [ test "Zero is equal to one minus one" &lt;|<br/>        \_ -&gt; Expect.equal 0 (1 - 1)<br/>    , test "Zero is equal to two minus two" &lt;|<br/>        \_ -&gt; Expect.equal 0 (2 - 2)<br/>    ]</pre>
<p>Let's now run this test from the console, by pointing the console to the root of our project (one level up from the <kbd>test</kbd> folder), and typing the following command:</p>
<pre>elm-test tests/Example.elm</pre>
<p>The console will log the following message:</p>
<pre>$ elm-test tests/Example.elm<br/>Success! Compiled 0 modules.<br/>Successfully generated /dev/null<br/>Success! Compiled 1 module.<br/>Successfully generated C:\Users\PC\Desktop\improved-weather-app\elm-stuff\generated-code\elm-community\elm-test\elmTestOutput.js<br/><br/>elm-test 0.18.12<br/>----------------<br/><br/>Running 2 tests. To reproduce these results, run: elm-test --fuzz 100 --seed 800244194 tests/Example.elm<br/><br/><br/>TEST RUN PASSED<br/><br/>Duration: 517 ms<br/>Passed: 2<br/>Failed: 0</pre>
<p>Let's look at a single test case from the code that we have just tested:</p>
<pre>test "Zero is equal to one minus one" &lt;|<br/>        \_ -&gt; Expect.equal 0 (1 - 1)</pre>
<p>Let's start with <kbd>&lt;|</kbd> pipe operator.  What it does is evaluate the expression that can be found on its right-hand side, and passes it as an argument to the function on its left-hand side. In other words, to write the exact same text function without using the <kbd>&lt;|</kbd> operator, we could have written it like this:</p>
<pre>test "Zero is equal to one minus one"<br/>        ( \_ -&gt; Expect.equal 0 (1 - 1) )</pre>
<p>Next, let's look inside the parentheses and describe what is happening there. The code inside the parentheses is the second argument of the <kbd>test</kbd> function:</p>
<pre>( \_ -&gt; Expect.equal 0 (1 - 1) )</pre>
<p>This second argument is an anonymous function which ignores its parameter, which is signified by this bit of code: <kbd>\_</kbd>. Earlier in the book, we discussed how every function in Elm is curried, and how, using partial application, we can conclude that each function in Elm can be made to take only one argument. With <kbd>\_</kbd>, that one argument is ignored.</p>
<p>The arrow (<kbd>-&gt;</kbd>) in anonymous functions is the same as the equals sign (<kbd>=</kbd>) in regular functions. The <kbd>Expect.equal</kbd> will, as mentioned, return either a <kbd>pass</kbd> or a <kbd>fail</kbd>.</p>
<p><kbd>Expect.equal</kbd> takes two arguments: the first one is the expected value, and the second one is the expression that will be tested and that will either be the same as the expected value (so a <kbd>pass</kbd> gets returned), or not (so a <kbd>fail</kbd> gets returned).</p>
<p><span>Since zero is indeed equal to one minus one, we got a </span><kbd>pass</kbd><span>.</span></p>
<p>Going back to using the <kbd>&lt;|</kbd> pipe operator, we could have written this anonymous function as follows:</p>
<pre>( \_ -&gt; Expect.equal 0 &lt;| 1 - 1 )</pre>
<p>Thus, we could, if we wanted to, rewrite the entire <kbd>suite</kbd> function without any parentheses, like this:</p>
<pre>suite : Test<br/>suite =<br/>  describe "Zero is equal to zero"<br/>    [ test "Zero is equal to one minus one" &lt;|<br/>        \_ -&gt; Expect.equal 0 &lt;| 1 - 1<br/>    , test "Zero is equal to two minus two" &lt;|<br/>        \_ -&gt; Expect.equal 0 &lt;| 2 - 2<br/>    ]</pre>
<p>Everything will still work as expected, and our tests, if we ran them again, would still pass.</p>
<p>Let's now divert our attention to the other test file in the <kbd>tests</kbd> folder, called <kbd>Tests.elm</kbd>. The <kbd>Tests.elm</kbd> file has the following code:</p>
<pre>module Tests exposing (..)<br/><br/>import Test exposing (..)<br/>import Expect<br/><br/><br/>-- Check out http://package.elm-lang.org/packages/elm-community/elm-test/latest to learn more about testing in Elm!<br/><br/><br/>all : Test<br/>all =<br/>    describe "A Test Suite"<br/>        [ test "Addition" &lt;|<br/>            \_ -&gt;<br/>                Expect.equal 10 (3 + 7)<br/>        , test "String.left" &lt;|<br/>            \_ -&gt;<br/>                Expect.equal "a" (String.left 1 "abcdefg")<br/>        , test "This test should fail" &lt;|<br/>            \_ -&gt;<br/>                Expect.fail "failed as expected!"<br/>        ]</pre>
<p>Let's run the test in our console by simply running the <kbd>elm-test</kbd> command from the root of our app's folder:</p>
<pre><strong>elm-test</strong></pre>
<p>The following information will be logged to the console:</p>
<pre>Success! Compiled 1 module.<br/>Successfully generated /dev/null<br/>Success! Compiled 1 module.<br/>Successfully generated C:\Users\PC\Desktop\improved-weather-app\elm-stuff\generated-code\elm-community\elm-test\elmTestOutput.js<br/><br/>elm-test 0.18.12<br/>----------------<br/><br/>Running 5 tests. To reproduce these results, run: elm-test --fuzz 100 --seed 1660804947<br/><br/>&gt; Tests<br/>&gt; A Test Suite<br/>&gt; This test should fail<br/><br/>    failed as expected!<br/><br/><br/><br/>TEST RUN FAILED<br/><br/>Duration: 696 ms<br/>Passed: 4<br/>Failed: 1</pre>
<p>This test failed,  but as the console output reads, that was expected. As can be seen in the code of the <kbd>Tests.elm</kbd> file, when we need to write a failing test, we simply use the <kbd>Expect.fail</kbd> function. </p>
<p>As we will continue working with the <kbd>Tests.elm</kbd> file in the following sections of this chapter, a useful command that we can use is <kbd>elm-test --watch</kbd>. If you are familiar with a number of different utilities that can be run in the console, the <kbd>--watch</kbd> flag watches for changes in our code and reruns the command that the <kbd>--watch</kbd> flag is appended to. </p>
<p>This means that we'll only need to run the <kbd>elm-test --watch</kbd> command once, and every time we save the <kbd>Tests.elm</kbd> file, it will run our test suite again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using let-in expressions in our tests</h1>
                </header>
            
            <article>
                
<p>Let's add a let-in expression to our <kbd>Example.elm</kbd> file. To do that, we'll specify another test suite by using another <kbd>describe</kbd> function, and then we'll wrap all our tests in yet another <kbd>describe</kbd> function. This outermost <kbd>describe</kbd> function will contain all the other describe functions, which will, in turn, hold all the <kbd>Lists</kbd> of <kbd>test</kbd> functions:</p>
<pre>module Example exposing (..)<br/><br/>import Expect exposing (Expectation)<br/>-- import Fuzz exposing (Fuzzer, int, list, string)<br/>import Test exposing (..)<br/><br/><br/>suite : Test<br/>suite =<br/>  describe "A Test Suite"<br/>    [ describe "Testing addition"<br/>      [ test "Addition" &lt;|<br/>        \_ -&gt;<br/>          Expect.equal 10 (3 + 7)<br/>      ]<br/>    , describe "Using let-in expression in a test suite"<br/>      [ test "Multiplication" &lt;|<br/>        \_ -&gt;<br/>          let<br/>            x = 2<br/>            y = 4<br/>            xy = x * y<br/>          in<br/>            xy<br/>              |&gt; \_ -&gt; Expect.equal 8 (2 * 4)<br/>      ]<br/>    ]</pre>
<p>Running this <kbd>Example.elm</kbd> file with <kbd>elm-test tests/Example.elm</kbd> will produce the following output to the console:</p>
<pre>Success! Compiled 1 module.<br/>Successfully generated /dev/null<br/>Success! Compiled 1 module.<br/>Successfully generated C:\Users\PC\Desktop\improved-weather-app\elm-stuff\generated-code\elm-community\elm-test\elmTestOutput.js<br/><br/>elm-test 0.18.12<br/>----------------<br/><br/>Running 2 tests. To reproduce these results, run: elm-test --fuzz 100 --seed 983607346 tests/Example.elm<br/><br/><br/>TEST RUN PASSED<br/><br/>Duration: 334 ms<br/>Passed: 2<br/>Failed: 0</pre>
<p>Of course, this example is trivial, but it is helpful to see a very simple implementation that you can build from.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decoding JSON in our tests</h1>
                </header>
            
            <article>
                
<p>Decoding JSON in our tests is simple.</p>
<p>To begin, let's add a new file inside our <kbd>tests</kbd> folder. We'll call this new file <kbd>DecoderTests.elm.</kbd></p>
<p>Next, let's add the following code to <kbd>DecoderTests.elm</kbd>:</p>
<pre>module DecoderTests exposing (..)<br/><br/>import Expect exposing (Expectation)<br/>import Fuzz exposing (Fuzzer, int, list, string)<br/>import Main exposing (..)<br/>import Test exposing (..)<br/><br/><br/>suite : Test<br/>suite =<br/>    describe "Decoder test"<br/>        [ test "Test decoding valid string" &lt;|<br/>            \_ -&gt;<br/>                let<br/>                    jsonInput =<br/>                        "{\"main\":{\"temp\":303.15,\"pressure\":30,\"humidity\":20},\"wind\":{\"speed\":15.3},\"name\":\"Rome\"}"<br/><br/>                    expectedResult =<br/>                        TemperatureInfo "Rome" 15.3 30.0 30.0 20.0<br/>                in<br/>                Expect.equal expectedResult (decodeTemperatureInfo jsonInput)<br/><br/>        {--<br/>        , test "Test decoding invalid string" &lt;|<br/>            \_ -&gt;<br/>                let<br/>                    jsonInput =<br/>                        "Scrabbled json message"<br/><br/>                    expectedResult =<br/>                        TemperatureInfo "Error decoding data!" 0 0 0 0<br/>                in<br/>                Expect.equal expectedResult (decodeTemperatureInfo jsonInput)<br/>        , fuzz string "Fuzz test decoding invalid string" &lt;|<br/>            \randomlyGeneratedString -&gt;<br/>                let<br/>                    expectedResult =<br/>                        TemperatureInfo "Error decoding data!" 0 0 0 0<br/>                in<br/>                Expect.equal expectedResult (decodeTemperatureInfo randomlyGeneratedString)<br/>        -}<br/>        ]</pre>
<p>Now we can run our tests:</p>
<pre><strong>elm-test tests/DecoderTests.elm</strong></pre>
<p>The console will log the following information:</p>
<pre><strong>Success! Compiled 2 modules.</strong><br/><strong>Successfully generated /dev/null</strong><br/><strong>Success! Compiled 3 modules.</strong><br/><strong>Successfully generated C:\Users\PC\Desktop\elm-web-development\chapter9\weather-app-with-tests-ch9\elm-stuff\generated-code\elm-community\elm-test\elmTestOutput.js</strong><br/><br/><strong>elm-test 0.18.12</strong><br/><strong>----------------</strong><br/><br/><strong>Running 1 test. To reproduce these results, run: elm-test --fuzz 100 --seed 1485733894 tests/DecoderTests.elm</strong><br/><br/><br/><strong>TEST RUN PASSED</strong><br/><br/><strong>Duration: 663 ms</strong><br/><strong>Passed: 1</strong><br/><strong>Failed: 0</strong></pre>
<p>The code we wrote to test this JSON has a total of three tests. The first test is written so that it doesn't fail. The other two are written to fail, but they are commented out. Feel free to un-comment the other two tests and see the result in the console.</p>
<p>In order to be able to parse JSON properly, we need to escape double quotes in the JSON string. That's why the <kbd>jsonInput</kbd> variable looks like this:</p>
<pre>jsonInput =<br/>"{\"main\":{\"temp\":303.15,\"pressure\":30,\"humidity\":20},\"wind\":\"speed\":15.3},\"name\":\"Rome\"}"</pre>
<p>An alternative approach would be to enclose the entire JSON string inside the opening and closing multiline quotes, which, as mentioned earlier in the book, are groupings of three double quotes, like this: <kbd>"""</kbd>. We will see an example of this approach in the next section, when we build some custom expectations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building custom expectations while decoding JSON</h1>
                </header>
            
            <article>
                
<p>To build custom expectations, we can refer to the previously-mentioned <kbd>pass</kbd> and <kbd>fail</kbd> functions. The <kbd>pass</kbd> function will always pass, and the <kbd>fail</kbd> function will fail with a message. To produce a custom message, you can use the <kbd>onFail</kbd> function.</p>
<p>Let's see an example by creating a new file inside the <kbd>tests</kbd> folder. We'll call this new file <kbd>CustomExpectations.elm</kbd> and add the following code:</p>
<pre>module CustomExpectations exposing (..)<br/><br/>import Expect exposing (Expectation)<br/>import Json.Decode exposing (decodeString, field, int, list, map2, string)<br/>import Test exposing (..)<br/><br/><br/>type alias Player =<br/>    { name : String<br/>    , language : String<br/>    }<br/><br/><br/>playerDecoder =<br/>    map2 Player<br/>        (field "name" string)<br/>        (field "language" string)<br/><br/><br/>suite : Test<br/>suite =<br/>    describe "A Test Suite"<br/>        [ describe "A custom expectation with a custom decoder"<br/>            [ test "Decoding JSON strings" &lt;|<br/>                \_ -&gt;<br/>                    let<br/>                        json =<br/>                            """<br/>                            {<br/>                            "name" : "John Doe",<br/>                            "language" : "English"<br/>                            }<br/>                            """<br/>                    in<br/>                    case decodeString playerDecoder json of<br/>                        Ok json -&gt;<br/>                            Expect.pass<br/><br/>                        Err err -&gt;<br/>                            Expect.fail err<br/>            ]<br/>        ]</pre>
<p>If we ran this test with the command <kbd>elm-test tests/CustomExpectations.elm</kbd>, we would get the following output:</p>
<pre><strong>Success! Compiled 0 modules.</strong><br/><strong>Successfully generated /dev/null</strong><br/><strong>Success! Compiled 1 module.</strong><br/><strong>Successfully generated C:\Users\PC\Desktop\elm-web-development\chapter9\weather-app-with-tests-ch9\elm-stuff\generated-code\elm-community\elm-test\elmTestOutput.js</strong><br/><br/><strong>elm-test 0.18.12</strong><br/><strong>----------------</strong><br/><br/><strong>Running 1 test. To reproduce these results, run: elm-test --fuzz 100 --seed 619873355 tests/CustomExpectations.elm</strong><br/><br/><br/><strong>TEST RUN PASSED</strong><br/><br/><strong>Duration: 468 ms</strong><br/><strong>Passed: 1</strong><br/><strong>Failed: 0</strong></pre>
<p>In the code, we are setting the type alias <kbd>Player</kbd> in the global scope so that we can access it in our tests when needed. The <kbd>Person</kbd> type alias is a record that has the <kbd>name</kbd> field, which is a <kbd>String</kbd>, and the <kbd>language</kbd> field, with is also a <kbd>String</kbd>. </p>
<p>We use the <kbd>describe</kbd> function to describe our suite of tests, and then we describe the first <kbd>List</kbd> of tests, which actually holds only one test right now. </p>
<p>Let's look at the <kbd>playerDecoder</kbd> function:</p>
<pre>playerDecoder =<br/>    map2 Player<br/>        (field "name" string)<br/>        (field "age" string)</pre>
<p>As we learned in <a href="651ea5bb-9106-4053-b8b4-6481508a775b.xhtml">Chapter 6</a>, <em>Exploring Elm in Greater Detail</em>, <kbd>string</kbd> is a decoder with the following signature:</p>
<pre>decoder : Json.Decode.Decoder String</pre>
<p>So, <kbd>string</kbd> is a decoder of <kbd>Strings</kbd>, meaning it translates JSON <kbd>strings</kbd> into Elm <kbd>Strings</kbd>, and this process of parsing JSON <kbd>strings</kbd> into Elm <kbd>Strings</kbd> is called <em>decoding</em>.</p>
<p>The expression <kbd>field "name" string</kbd> is also a decoder of <kbd>Strings</kbd>, and the entire <kbd>playerDecoder</kbd> is a complex decoder that is composed of the <kbd>field "name" string</kbd> decoder and the <kbd>field "age" string</kbd> decoder.</p>
<p>Inside the anonymous function, we provide the <kbd>let-in</kbd> expression. Inside the <kbd>let</kbd> portion of the <kbd>let-in</kbd> expression, we define our <kbd>json</kbd> string.</p>
<p>Finally, inside the <kbd>in</kbd> portion of the <kbd>let-in</kbd> expression, we evaluate a <kbd>case-of</kbd> expression, and with the help of the <kbd>pass</kbd> and <kbd>fail</kbd> functions, we write our custom expectations.</p>
<p>Next, we will look at fuzz testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing fuzz tests in Elm</h1>
                </header>
            
            <article>
                
<p>Fuzz tests allow us to take our unit tests to a new level by enabling us to run an arbitrary number of combinations of values in our tests, by virtue of randomizing some of the inputs in our tests.</p>
<p>In order to see how fuzz tests work, let's compare unit tests with fuzz tests.</p>
<p>Let's begin with the regular unit test that we have already worked with earlier in this chapter. To refresh our memory of this test, let's add it as the contents of <kbd>Example.elm</kbd>, and then run the actual test:</p>
<pre>module Example exposing (..)<br/><br/>-- import Fuzz exposing (Fuzzer, int, list, string)<br/><br/>import Expect exposing (Expectation)<br/>import Test exposing (..)<br/><br/><br/>suite : Test<br/>suite =<br/>    describe "Zero is equal to zero"<br/>        [ test "Zero is equal to one minus one" &lt;|<br/>            \_ -&gt; Expect.equal 0 (1 - 1)<br/>        , test "Zero is equal to two minus two" &lt;|<br/>            \_ -&gt; Expect.equal 0 (2 - 2)<br/>        ]</pre>
<p>Note that, in this code, the Fuzz import is commented out, since the compiler would give us a warning about this import not being used. </p>
<p>If we ran this test, it would log a successful test message to the console, with the information that two tests have passed and zero have failed.</p>
<p>Although the example is very simplistic, it will help us compare unit tests and fuzz tests in Elm. The very fact that we are listing two tests hints at the usefulness of fuzz tests. </p>
<p>If we wanted to make sure that <kbd>Expect.equal</kbd> will return zero for any number subtracted by itself, we could possibly write a number of tests to confirm this behavior.</p>
<p>However, writing a fuzz test would be a much better solution. Let's look at the updated code:</p>
<pre>module Example exposing (..)<br/><br/>-- import Fuzz exposing (Fuzzer, int, list, string)<br/><br/>import Expect exposing (Expectation)<br/>import Test exposing (..)<br/><br/><br/>suite : Test<br/>suite =<br/>    describe "Zero is equal to zero"<br/>        [ test "Zero is equal to one minus one" &lt;|<br/>            \_ -&gt; Expect.equal 0 (1 - 1)<br/>        , test "Zero is equal to two minus two" &lt;|<br/>            \_ -&gt; Expect.equal 0 (2 - 2)<br/>        ]</pre>
<p>Now, let's rewrite this unit test in the form of a fuzz test.</p>
<p>We'll uncomment the Fuzz import, and we'll randomize some of the inputs in our test, as follows:</p>
<pre>module Example exposing (..)<br/><br/>import Expect exposing (Expectation)<br/>import Fuzz exposing (Fuzzer, int, list, string)<br/>import Test exposing (..)<br/><br/><br/>suite : Test<br/>suite =<br/>    describe "Zero is equal to zero"<br/>        [ fuzz int "Zero is equal to random number minus itself" &lt;|<br/>            \randomNumber -&gt; Expect.equal 0 (randomNumber - randomNumber)<br/>        ]</pre>
<p>This test will run 100 times. This makes us draw conclusions about our passing tests with a lot more confidence than we would writing just plain old unit tests. </p>
<p>Looking at the anatomy of our fuzz test syntax, we can see that the fuzz function takes three parameters: </p>
<ul>
<li>a <kbd>fuzzer</kbd></li>
<li>a <kbd>String</kbd> to describe the fuzz test</li>
<li>an anonymous function (which takes an actual argument, contrary to a unit test, which takes a <kbd>Unit</kbd> as its parameter)</li>
</ul>
<p>Thus, this fuzz test's fuzzer is used to generate <kbd>int</kbd> values. The <kbd>int</kbd> fuzzer generates random <kbd>Ints</kbd>. The <kbd>String</kbd> used to describe the fuzz test is straightforward. We are using the <kbd>String</kbd> that reads <em>Zero is equal to random number minus itself</em>. Finally, our anonymous function <kbd>\</kbd> takes the parameter we named <kbd>randomNumber</kbd>. Since we are using <kbd>randomNumber</kbd> in our actual <kbd>Expect.equal</kbd> assertion, it makes perfect sense to pass this argument to the anonymous function. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with more than one fuzzer</h1>
                </header>
            
            <article>
                
<p>Similarly to how we can use <kbd>map2</kbd>, <kbd>map3</kbd>, <kbd>map4</kbd>, and so on, depending on how many fields we are decoding from JSON values to Elm values, we also have at our disposal the following functions: <kbd>fuzz2,</kbd> <kbd>fuzz3</kbd>, <kbd>fuzz4</kbd>, and <kbd>fuzz5</kbd>.</p>
<p>Let's update our <kbd>Example.elm</kbd> test so that it uses the <kbd>fuzz2</kbd> function. To make things simple, we'll test commutation in number addition. This is the rule in mathematics that says that if we flip the order of numbers that we are adding, the result will be the same:</p>
<pre>module Example exposing (..)<br/><br/>import Expect exposing (Expectation)<br/>import Fuzz exposing (Fuzzer, int, list, string)<br/>import Test exposing (..)<br/><br/><br/>suite : Test<br/>suite =<br/>    describe "Zero is equal to zero"<br/>      [ fuzz2 int int "Swiching positions on two numbers being added will still yield the same result" &lt;|<br/>          \randomNumber1 randomNumber2 -&gt; <br/>            Expect.equal (randomNumber1 + randomNumber2) (randomNumber2 + randomNumber1)<br/>      ]</pre>
<p>All 100 tests pass as expected. It is important to note that the console output will list these 100 tests as only one test passing, since in effect that is what is happening. There is indeed only one test being run, albeit with 100 different combinations of values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned the basics of unit testing and fuzz testing in Elm. We learned about the structure and syntax of tests in Elm:</p>
<ul>
<li>We learned about <kbd>describe</kbd>, <kbd>Expect.equals</kbd>, and <kbd>test</kbd></li>
<li>We discussed how and why to use <kbd>\_</kbd> and <kbd>&lt;|</kbd> in Elm tests</li>
<li>We wrote tests to decode JSON strings to Elm values</li>
<li>We looked at the difference between unit tests and fuzz tests</li>
<li>We wrote fuzz tests that take more than one argument</li>
</ul>
<p>However, the material covered in this chapter is only the beginning. TDD (test-driven development) is an approach to building software that embraces testing throughout our application's life cycle; actually, as its name suggests, it is an approach in which testing drives the complete development process. With the topics covered in this course, you should be able to start implementing tests routinely in your Elm development.</p>
<p>In the next chapter, we will look at authentication in our Elm apps.</p>
<p> </p>


            </article>

            
        </section>
    </body></html>