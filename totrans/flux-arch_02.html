<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Principles of Flux</h1></div></div></div><p>In the previous chapter, you were introduced at a 10,000 foot level to some of the core Flux principles. For example, unidirectional data-flow is central to Flux's existence. The aim of this chapter is to go beyond the simplistic view of Flux principles.</p><p>We'll kick things off with a bit of an MVC retrospective—to identify where it falls apart when we're trying to scale a frontend architecture. Following this, we'll take a deeper look at at unidirectional data-flow and how it solves some of the scaling issues we've identified in MVC architectures.</p><p>Next, we'll address some high-level compositional issues faced by Flux architectures, such as making everything explicit and favoring layers over deep hierarchies. Finally, we'll compare the various kinds of state found in a Flux architecture and introduce the concept of an update round.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Challenges with MV*</h1></div></div></div><p>MV* is the prevailing architectural pattern of frontend JavaScript applications. We're referring to this as MV* because there's a number of accepted variations on the pattern, each of which <a id="id42" class="indexterm"/>have models and views as core concepts. For our discussions in this book, they can all be considered the same style of JavaScript architecture.</p><p>MV* didn't gain traction<a id="id43" class="indexterm"/> in the development community because it's a terrible set of patterns. No, MV* is popular because it works. Although Flux can be thought of as a sort of MV* replacement, there's no need to go out and tear apart a working application.</p><p>There's no such thing as a perfect architecture, and Flux is by no means immune to this fact. The goal of this section isn't to downplay MV* and all the things it does well, but rather to look at some of the MV* weaknesses and see how Flux steps in and improves the situation.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Separation of concerns</h2></div></div></div><p>One thing MV* is really good at is establishing a clear separation of concerns. That is, a component has one responsibility, while another component is responsible for something else, and so on, all throughout the architecture. Complementary to the <em>separation of concerns</em> principle is the <em>single responsibility</em> principle, which enforces a clear separation of concerns.</p><p>Why do we care though? The<a id="id44" class="indexterm"/> simple answer is that when we separate responsibilities into different components, different parts of the system are naturally decoupled from one another. This means that we can change one thing without necessarily impacting the other. This is a desired trait of any software system, regardless of the architecture. But, is this really what we get with MV*, and is this actually something we should shoot for?</p><p>For example, maybe there's no clear advantage in dividing a feature into five distinct responsibilities. Maybe the decoupling of the feature's behavior doesn't actually achieve anything because we would have to touch all five components every time we want to change something anyway. So rather than help us craft a robust architecture, the separation of concerns principle has amounted to nothing more than needles indirection that hampers productivity. Here's an example of a feature that's broken down into several pieces of focused responsibility:</p><div><img src="img/B05419_02_01.jpg" alt="Separation of concerns"/></div><p>Anytime a developer needs to pull apart a feature so that they can understand how it works, they end up spending more time jumping between source code files. The feature feels fragmented, and there's no obvious advantage to structuring the code like this. Here's a look at the moving parts that make up a feature in a Flux architecture:</p><div><img src="img/B05419_02_02.jpg" alt="Separation of concerns"/></div><p>The Flux feature<a id="id45" class="indexterm"/> decomposition leaves us with a feeling of predictability. We've left out the potential ways in which the view itself could be decomposed, but that's because the views are outside Flux. All we care about in terms of our Flux architecture is that the correct information is always passed to our views when state changes occur.</p><p>You'll note that the logic and state of a given Flux feature are tightly coupled with one another. This is in contrast to MV*, where we want application logic to be a standalone entity that can operate on any data. The opposite is true with Flux, where we'll find the logic responsible for change state in close proximity to that state. This is an intentional design trait, with the implication being that we don't need to get carried away with separating concerns from one another, and that this activity can sometimes hurt rather than help.</p><p>As we'll see in the coming chapters, this tight coupling of data and logic is characteristic of Flux stores. The preceding diagram shows that with complex features, it's much easier to add more logic and more state, because they're always near the surface of the feature, rather than buried in a nested tree of components.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Cascading updates</h2></div></div></div><p>It's nice when we have a software component that <em>just works</em>. This could mean any number of things, but it's<a id="id46" class="indexterm"/> meaning is usually centered around automatically handling things for us. For instance, instead of manually having to invoke this method, followed by that method, and so on, everything is handled by the component for us. Let's take a look at the following illustration:</p><div><img src="img/B05419_02_03.jpg" alt="Cascading updates"/></div><p>When we pass input into a larger component, we can expect that it will do the right thing automatically for us. What's compelling about these types of components is that it means less code for us to maintain. After all, the component knows how to update itself by orchestrating the communication between any subcomponents.</p><p>This is where the cascading effect begins. We tell one component to perform some behavior. This, in turn, causes another component to react. We give it some input, which causes another component to react, and so on. Soon, it's very difficult to comprehend what's going on in our code. This is because the things that are <em>taken care of</em> for us are hidden from view. Intentional by design, with unintended consequences.</p><p>The previous diagram isn't too bad. Sure, it might get a little difficult to follow depending on how many subcomponents get added to the larger component, but in general, it's a tractable problem. Let's look at a variation of this diagram:</p><div><img src="img/B05419_02_04.jpg" alt="Cascading updates"/></div><p>What just happened? Three more boxes and four more lines just happened, resulting in an explosion of <a id="id47" class="indexterm"/>cascading update complexity. The problem is no longer tractable because we simply cannot handle this type of complexity, and most MV* applications that rely on this type of automatic updating have way more than six components. The best we can hope for is that once it works the way we want it to, it keeps working.</p><p>This is the naive assumption that we make about automatically updating components—this is something we want to encapsulate. The problem is that this generally isn't true, at least not if we ever plan to maintain the software. Flux sidesteps the problem of cascading updates because only a store can change it's own state, and this is always in response to an action.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Model update responsibilities</h2></div></div></div><p>In an MV* architecture, state is stored within models. To initialize model state, we could fetch data from the backend API. This is clear enough: we create a new model, then tell that model to<a id="id48" class="indexterm"/> go fetch some data. However, MV* doesn't say anything about who is responsible for updating these models. One might think it's the controller component that should have total control over the model, but does this ever happen in practice?</p><p>For example, what happens in view event handlers, called in response to user interactivity? If we only allow controllers to update the state of our models, then the view event handler functions should talk directly to the controller in question. The following diagram is a visualization of a controller changing the state of models in different ways:</p><div><img src="img/B05419_02_05.jpg" alt="Model update responsibilities"/></div><p>At first glance, this controller setup makes perfect sense. It acts as a wrapper around the models that store state. It's a safe assumption the anything that wants to mutate any of these models needs to go through the controller. That's its responsibility after all—to control things. Data that comes from the API, events triggered by the user and handled by the view, and other models—these all need to talk to the controller if they want to change the state of the models.</p><p>As our controller grows, making sure that model state changes are handled by the controller will produce more and more methods that change the model state. If we step back and look at all of these methods as they accumulate, we'll start to notice a lot of needless indirection. What do we stand to gain by proxying these state changes?</p><p>Another reason the controller is a dead-end for trying to establish consistent state changes in MV* is the changes that models can make to themselves. For example, setting one property in a model could end up changing other model properties as a side-effect. Worse, our models could have listeners that respond to state changes, somewhere else in the system (the cascading updates problem).</p><p>Flux stores deal with the cascading updates problem by only allowing state changes via actions. This same mechanism solves the MV* challenges discussed here; we don't have to worry about views or other stores directly changing the state of our store.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Unidirectional data</h1></div></div></div><p>A cornerstone <a id="id49" class="indexterm"/>of any Flux architecture is unidirectional data-flow. The idea being data flows from point A to point B, or from point A to B to C, or from point A to C. It's the direction that's important with unidirectional data-flow, and to a lesser extent, the ordering. So when we say that our architecture uses a unidirectional data-flow, we can say that data never flows from point B to point A. This is an important property of Flux architectures.</p><p>As we saw in the previous section, MV* architectures have no discernible direction with their data-flows. In this section, we'll talk though some of the properties that make a unidirectional data-flow worth implementing. We'll begin with a look at the starting points and completion points of our data-flows, and then we'll think about how side-effects can be avoided when data flows in one direction.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>From start to finish</h2></div></div></div><p>If data-flows in only<a id="id50" class="indexterm"/> one direction, there has to be both a starting point and a finish point. In other words, we can't just have an endless stream of data, which arbitrarily affects the various components the data-flows through. When data-flows are unidirectional with clearly defined start and finish points, there's no way we can have circular flows. Instead, we have one big data-flow cycle in Flux, as visualized here:</p><div><img src="img/B05419_02_06.jpg" alt="From start to finish"/></div><p>This is obviously an over-simplification of any Flux architecture, but it does serve to illustrate the start and finish points of any given data-flow. What we're looking at is called an <strong>update round</strong>. A round is atomic in the sense that it's run-to-completion—there's no way to stop an update round from completing (unless an exception is thrown).</p><p>JavaScript is a run-to-completion language, meaning that once a block of code starts running, it's going to finish. This is good because it means that once we start updating the UI, there's no way a callback function can interrupt our update. The exception to this is when our own code interrupts the updating process. For example, our store logic that's meant to mutate the <a id="id51" class="indexterm"/>state of the store dispatches an action. This would be bad news for our Flux architecture because it would violate the unidirectional data-flow. To prevent this, the dispatcher can actually detect when a dispatch takes place inside of an update round. We'll have more on this in later chapters.</p><p>Update rounds are responsible for updating the state of the entire application, not just the parts that have subscribed to a particular type of action. This means that as our application grows, so do our update rounds. Since an update round touches every store, it may start to feel as though the data is flowing sideways through all of our stores. Here's an illustration of the idea:</p><div><img src="img/B05419_02_07.jpg" alt="From start to finish"/></div><p>From the perspective of unidirectional data-flow, it doesn't actually matter how many stores there are. The important thing to remember is that the updates will not be interrupted by other actions being dispatched.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>No side-effects</h2></div></div></div><p>As we saw with MV* architectures, the nice thing about automatic state changes is also their demise. When we program by hidden rules, we're essentially programming by stitching together a bunch of side-effects. This doesn't scale well, mainly due to the fact that it's impossible to hold all these hidden connections in our head at a given point in time. Flux likes to avoid side-effects wherever possible.</p><p>Let's think about<a id="id52" class="indexterm"/> stores for a moment. These are the arbiters of state in our application. When something changes state, it has the potential to cause another piece of code to run in response. This does indeed happen in Flux. When a store changes state, views may be notified about the change, if they've subscribed to the store. This is the only place where side-effects happen in Flux, which is inevitable since we do need to update the DOM at some point when state changes. But what's different about Flux is how it avoids side-effects when there's data dependencies involved. The typical approach to dealing with data dependencies in user interfaces is to notify the dependent model that something has happened. Think cascading updates, as illustrated here:</p><div><img src="img/B05419_02_08.jpg" alt="No side-effects"/></div><p>When there's a dependency between two stores in Flux, we just need to declare this dependency in the<a id="id53" class="indexterm"/> dependent store. What this does is it tells the dispatcher to make sure that the store we depend on is always updated first. Then, the dependent store can just directly use the store data it depends on. This way, all of the updates can still take place within the same update round.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Explicit over implicit</h1></div></div></div><p>With architectural patterns, the tendency is to make things easier by veiling them behind abstractions that grow more elaborate with time. Eventually, more and more of the system's data changes automatically and developer convenience is superseded by hidden complexity.</p><p>This is a real<a id="id54" class="indexterm"/> scalability issue, and Flux handles it by favoring explicit actions and data transformations over implicit abstractions. In this section, we'll explore the benefits of explicitness along with the trade-offs to be made.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Updates via hidden side-effects</h2></div></div></div><p>We've seen already, in this chapter, how difficult it can be to deal with hidden state changes that hide <a id="id55" class="indexterm"/>behind abstractions. They help us avoid writing code, but they also hurt by making it difficult to comprehend an entire work-flow when we come back and look at the code later. With Flux, state is kept in a store, and the store is responsible for changing its own state. What's nice about this is that when we want to inquire about how a given store changes state, all the state transformation <a id="id56" class="indexterm"/>code is there, in one place. Let's look at an example store:</p><div><pre class="programlisting">// A Flux store with state.
class Store {
  constructor() {

    // The initial state of the store.
    this.state = { clickable: false };

    // All of the state transformations happen
    // here. The "action.type" property is how it
    // determines what changes will take place.
    dispatcher.register((e) =&gt; {

      // Depending on the type of action, we
      // use "Object.assign()" to assign different
      // values to "this.state".
      switch (e.type) {
        case 'show':
          Object.assign(this.state, e.payload,
            { clickable: true });
          break;
        case 'hide':
          Object.assign(this.state, e.payload,
            { clickable: false });
          break;
        default:
          break;
      }
    });
  }
}

// Creates a new store instance.
var store = new Store();

// Dispatches a "show" action.
dispatcher.dispatch({
  type: 'show',
  payload: { display: 'block' }
});

console.log('Showing', store.state);
// → Showing {clickable: true, display: "block"}

// Dispatches a "hide" action.
dispatcher.dispatch({
  type: 'hide',
  payload: { display: 'none' }
});

console.log('Hiding', store.state);
// → Hiding {clickable: false, display: "none"}</pre></div><p>Here, we have a store with a simple <code class="literal">state</code> object. In the constructor, the store registers a callback function <a id="id57" class="indexterm"/>with the <code class="literal">dispatcher</code>. All state transformations take place, explicitly, in one function. This is where data turns into information for our user interface. We don't have to hunt down the little bits and pieces of data as they change state across multiple components; this doesn't happen in Flux.</p><p>So the question now becomes, how do views make use of this monolithic state data? In other types of frontend architecture, the views get notified whenever any piece of state changes. In the preceding example, a view gets notified when the <code class="literal">clickable</code> property changes, and again when the <code class="literal">display</code> property changes. The view has logic to render these two changes independently of one another. However, views in Flux don't get fine-grained updates like these. Instead, they're notified when the store state changes and the state data is what's given to them.</p><p>The implication here is that we should lean toward view technology that's good at re-rendering whole components. This is what makes React a good fit for Flux architectures. Nonetheless, we're free to use any view technology we please, as we'll see later on in the book.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Data changes state in one place</h2></div></div></div><p>As we saw in the preceding section, the store transformation code is encapsulated within the store. This is intentional. The transformation code that mutates a store's state is supposed to live<a id="id58" class="indexterm"/> nearby. Close proximity drastically reduces the complexity of figuring out where state changes happen as systems grow more complex. This makes state changes explicit, instead of abstract and implicit.</p><p>One potential trade-off with having a store manage all of the state transformation code is that there could be a lot of it. The code we looked at used a single <code class="literal">switch</code> statement to handle all of the state transform logic. This would obviously cause a bit of a headache later on when there's a lot of cases to handle. We'll think about this more later in the book, when the time comes to consider large, complex stores. Just know that we can re-factor our stores to elegantly handle a large number of cases, while keeping the coupling of business logic and state tight.</p><p>This leads us right back to the separation of concerns principle. With Flux stores, the data and the logic that operates on it isn't separated at all. Is this actually a bad thing though? An action is <a id="id59" class="indexterm"/>dispatched, a store is notified about it, and it changes its state (or does nothing, ignoring the action). The logic that changes the state is located in the same component because there's nothing to gain by moving it somewhere else.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Too many actions?</h2></div></div></div><p>Actions make everything<a id="id60" class="indexterm"/> that happens in a Flux architecture explicit. By everything, I mean everything—if it happens, it was the result of an action being dispatched. This is good because it's easy to figure out where actions are dispatched from. Even as the system grows, action dispatches are easy to find in our code, because they can only come from a handful of places. For example, we won't find actions being dispatched within stores.</p><p>Any feature we create has the potential to create dozens of actions, if not more. We tend to think that more means bad, from an architectural perspective. If there's more of something, it's going to be more difficult to scale and to program with. There's some truth to this, but if we're going to have a lot of something, which is unavoidable in any large system, it's good that it's actions. Actions are relatively lightweight in that they describe something that happens in our application. In other words, actions aren't heavyweight items that we need to fret over having a lot of.</p><p>Does having a lot of actions mean that we need to cram them all into one huge monolithic actions module? Thankfully, we don't have to do this. Just because actions are the entry point into any Flux system, doesn't mean that we can't modularize them to our liking. This is true of all the Flux components we develop, and we'll keep an eye open for ways that we can keep our code modular as we progress through the book.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Layers over hierarchies</h1></div></div></div><p>User interfaces are hierarchical in nature, partly because HTML is inherently hierarchical and partly because<a id="id61" class="indexterm"/> of the way that we structure the information presented to users. For example, this is why we have nested levels of navigation in some applications—we can't possibly fit everything on the screen at once. Naturally, our code starts to reflect this hierarchical structure by becoming a hierarchy itself. This is good in the sense that it reflects what the user sees. It's bad in the sense that deep hierarchies are difficult to comprehend.</p><p>In this section, we'll look at hierarchical structures in frontend architectures and how Flux is able to avoid complex hierarchies. We'll first cover the idea of having several top-level components, each<a id="id62" class="indexterm"/> with their own hierarchies. Then, we'll look at the side-effects that happen within hierarchies and how data-flows through Flux layers.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Multiple component hierarchies</h2></div></div></div><p>A given application probably has a handful of major features. These are often implemented<a id="id63" class="indexterm"/> as the top-level components or modules in our code. These aren't monolithic components; they're decomposed into smaller and smaller components. Perhaps some of these components share the smaller multipurpose components. For example, a top-level component hierarchy might be composed of models, views, and controllers as is illustrated here:</p><div><img src="img/B05419_02_09.jpg" alt="Multiple component hierarchies"/></div><p>This makes sense in terms of the structure of our application. When we look at pictures of component hierarchies, it's easy to see what our application is made of. Each of these hierarchies, with the top-level component as their root, are like a little universes that exist independently of one anothers. Again, we're back to the notion of separation of concerns. We can develop one feature without impacting another.</p><p>The problem with this approach is that user interface features often depend on other features. In other words, the state of one component hierarchy will likely depend on the state of another. How do we keep these two component trees synchronized with one another when there's no mechanism in place to control when state can change? What ends up happening is that a component in one hierarchy will introduce an arbitrary dependency to a component in another hierarchy. This serves a single purpose, so we have to keep introducing new inter-hierarchy dependencies to make sure everything is synchronized.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Hierarchy depth and side-effects</h2></div></div></div><p>One challenge with hierarchies is depth. That is, how far down will a given hierarchy extend? The features <a id="id64" class="indexterm"/>of our application are constantly changing and expanding in scope. This can lead to our component trees <a id="id65" class="indexterm"/>growing taller. But they also grow wider. For example, let's say that our feature uses a component hierarchy that's three levels deep.</p><p>Then, we add a new level. Well, we'll probably have to add several new components to this new level and in higher levels. So to build upon our hierarchies, we have to scale in multiple directions—horizontally and vertically. This idea is illustrated here:</p><div><img src="img/B05419_02_10.jpg" alt="Hierarchy depth and side-effects"/></div><p>Scaling components in multiple directions is difficult, especially in component hierarchies where there's no data-flow direction. That is, input that ends up changing the state of something can enter the hierarchy at any level. Undoubtedly, this has some sort of side-effect, and if we're dependent on components in other hierarchies, all hope is lost.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Data-flow and layers</h2></div></div></div><p>Flux has distinct architectural layers, which are more favorable to scaling architectures than hierarchies are. The reason<a id="id66" class="indexterm"/> is simple—we only need to scale <a id="id67" class="indexterm"/>components horizontally, within each layer of the architecture. We don't need to add new components to a layer and add new layers. Let's take a look at what scaling a Flux architecture looks like in the following diagram:</p><div><img src="img/B05419_02_11.jpg" alt="Data-flow and layers"/></div><p>No matter how large<a id="id68" class="indexterm"/> an application gets, there's no need to add new architectural layers. We simply add new components to these layers. The reason<a id="id69" class="indexterm"/> we're able to do this without creating a tangled mess of component connections within a given layer is because all three layers play a part in the update round. An update round starts with an action and completes with the last view that is rendered. The data-flows through our application from layer to layer, in one direction.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Application data and UI state</h1></div></div></div><p>When we have a separation of concerns that sticks presentation in one place and application data in <a id="id70" class="indexterm"/>another, we have two distinct places where we need to manage state. Except in Flux, the only place where there's state is within a store. In this section, we'll compare application data and UI data. We'll then address the transformations that ultimately lead to changes in the user interface. Lastly, we'll discuss the feature-centric nature of Flux stores.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Two of the same thing</h2></div></div></div><p>Quite often, application data that's fetched from an API is fed into some kind of view layer. This is also known <a id="id71" class="indexterm"/>as the presentation layer, responsible for transforming application data into something of value for the user—from data to information in other words. In these layers, we end up with state to represent the UI elements. For example, is the checkbox checked? Here is an illustration of how we tend to group the two types of state within our components:</p><div><img src="img/B05419_02_12.jpg" alt="Two of the same thing"/></div><p>This doesn't really fit<a id="id72" class="indexterm"/> well with Flux architectures, because stores are where state belongs, including the UI. So, can a store have both application and UI state within it? Well, there isn't a strong argument against it. If everything that has a state is self-contained within a store, it should be fairly simple to discern between application data and state that belongs to UI elements. Here's an illustration of the types of state found in Flux stores:</p><div><img src="img/B05419_02_13.jpg" alt="Two of the same thing"/></div><p>The fundamental misconception with trying to separate UI state from other state is that components often depend on UI state. Even UI components in different features can depend on each other's state in unpredictable ways. Flux acknowledges this and doesn't try to treat UI state as something special that should be split off from application data.</p><p>The UI state that<a id="id73" class="indexterm"/> ultimately ends up in a store can be derived from a number of things. Generally, two or more items from our application data could determine a UI state item. A UI state could be derived from another UI state, or from something more complex, like a UI state and other application data. In other cases, the application data is simple enough that it can be consumed directly by the view. The key is that the view has enough information that it can render itself without having to track its own state.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Tightly coupled transformations</h2></div></div></div><p>Application data and UI state are tightly coupled together in Flux stores. It only makes sense that the transformations that operate on this data be tightly coupled to the store as well. This makes it easy for us to change the state of the UI based on other application data or based on the<a id="id74" class="indexterm"/> state of other stores.</p><p>If our business logic code wasn't in the store, then we'd need to start introducing dependencies to the components containing the logic needed by the store. Sure, this would mean generic business logic that transforms the state, and this could be shared in several stores, but this seldom happens at a high level. Stores are better off keeping their business logic that transforms the state of the store tightly coupled. If we need to reduce repetitive code, we can introduce smaller, more fine-grained utility functions to help with data transformations.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>We can get <a id="id75" class="indexterm"/>generic with our stores as well. These stores are abstract and don't directly interface with views. We'll go into more detail on this advanced topic later in the book.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Feature centric</h2></div></div></div><p>If the data transformations that change the state of a store are tightly coupled to the store itself, does this <a id="id76" class="indexterm"/>mean that the store is tailored for a specific feature? In other words, do we care about stores being reused for other features? Sure, in some cases we have generic data that doesn't make much sense in repeating several times across stores. But generally speaking, stores are feature specific. Features are synonymous with domains in Flux parlance—everyone divides up the capabilities of their UI in different ways.</p><p>This is a departure from other architectures that base their data models on the data model of the API. Then, they use these models to create more specific view models. Any given MV* framework will have loads of features in their model abstractions, things like data bindings and automatic API fetching. They're only worried about storing state and publishing notifications when this state changes.</p><p>When stores encourage us to create and store new state that's specific to the UI, we can more easily design for the user. This is the fundamental difference between stores in Flux and models in other architectures—the UI data model comes first. The transformations within stores exist to ensure that the correct state is published to views—everything else is secondary.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>This chapter introduced you to the driving principles of Flux. These should be in the back your mind as you work on any Flux architecture. We started the chapter off with a brief retrospective of MV* style architectures that permeate frontend development. Some challenges with this style of architecture include cascading model updates and a lack of data-flow direction. We then looked at the prize concept of Flux—unidirectional data-flow.</p><p>Next, we covered how Flux favors explicit actions over implicit abstractions. This makes things easier to comprehend when reading Flux code, because we don't have to go digging around for the root cause of a state change. We also looked at how Flux utilizes architectural layers to visualize how data-flows in one direction through the system.</p><p>Finally, we compared application data with state that's generally considered specific to UI elements. Flux stores tend to focus on state that's relevant to the feature it supports, and doesn't distinguish between application data and UI state. Now that we have a handle on the principles that drive Flux architectures, it's time for us to code one. In the next chapter, we'll implement our skeleton Flux architecture, allowing us to focus on information design.</p></div></body></html>