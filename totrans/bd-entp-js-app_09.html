<html><head></head><body>
        

                            
                    <h1 class="header-title">Designing Our API</h1>
                
            
            
                
<p>In the last few chapters, we have followed a TDD approach to implement our Create User endpoint. However, a user directory application needs to do much more: retrieve, edit, delete, and search for users. In this chapter, we want you to practice what you've learned and implement these endpoints yourself.</p>
<p>To help you design an API that is easy to use, we will outline some principles of API design. Specifically, we will:</p>
<ul>
<li>Discuss what <strong>REST</strong> is, and what it is not</li>
<li>Learn to design our API to be <strong>consistent</strong>, <strong>fast</strong>, <strong>intuitive</strong>, and <strong>simple</strong></li>
<li>Understand the different types of consistency: <strong>Common</strong>, <strong>Local</strong>, <strong>Transversal</strong>, <strong>Domain</strong>, and <strong>Perennial</strong></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What it means to be RESTful</h1>
                
            
            
                
<p>When you read about APIs, you'll undoubtedly come across the terms <strong>SOAP</strong>, <strong>RCP</strong>, <strong>REST</strong>, and nowadays also <strong>GRPC</strong> and <strong>GraphQL</strong>. The status quo at the time of writing is that all APIs should be "RESTful," and any APIs that are not RESTful are considered subpar. This is a common misconception, which stems from the fact that many misunderstand what REST actually is. Therefore, we start this chapter by examining what REST is, what it is not, why it may not always be practical to use it, and why our API will <em>not</em> be RESTful.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is REST?</h1>
                
            
            
                
<p>REST stands for <strong>representational state transfer</strong>, and is a set of <em>architectural styles</em> that dictates the manners and patterns in which you construct your API. REST is nothing new; you are probably already well attuned to it because that's how the World Wide Web is structured, so don't let the terminology alienate you.</p>
<p class="mce-root"/>
<p>There are six requirements for REST:</p>
<ul>
<li><strong>Client-server</strong>: Defines a clear <strong>separation of concerns</strong> (<strong>SoC</strong>) between client and server. The client should provide the user interface, while the server provides the data.</li>
<li><strong>S</strong><strong>tateless</strong>: No transient information about the client should be held on the server. In other words, the server should not persist client sessions; if sessions need to be persisted, it must be done on the client. Any requests that arrive at the server must contain all the information required to process that request.<br/>
This is not to say that servers cannot store <em>any</em> state; servers can still persist <em>resource state</em> inside databases. But servers should not store temporary <em>application state</em> in memory.<br/>
The importance of this constraint will become apparent in <a href="5d093a43-720f-4ea8-aac0-b64b13f96d12.xhtml" target="_blank">Chapter 18</a>, <em>Robust Infrastructure with Kubernetes</em>, when we deploy our application as a <strong>cluster</strong> of <strong>load-balanced</strong> servers. By being stateless, requests can be fulfilled by any of the servers in the cluster, and servers can be restarted without losing information. It is this constraint that allows for the scalability of our application.<br/>
However, this constraint does have its drawbacks, because the client must repeatedly send authentication information (for instance, a <strong>JSON Web Token</strong>, or <strong>JWT</strong>) with each request, increase the bandwidth used.</li>
<li><strong>Cacheable</strong>: If a response is going to be the same given the same request, then that response should be cached by the client and/or any intermediaries. A RESTful architecture requires that the response message <em>must</em> include an indication of whether the response should be cached, or not, and if so, for how long.<br/>
This constraint could be beneficial as it helps reduce bandwidth usage, and can reduce the load on the server, freeing it up to service more requests.</li>
<li><strong>Layered system</strong>: Many applications, especially Node.js applications, are <strong>reverse proxied</strong> by a web server (for instance, <strong>NGINX</strong>). This means that before a request reaches our application, it may pass through layers consisting of web server(s), load balancers (for instance, <strong>HAProxy</strong>), and/or a <strong>caching server</strong> (for instance, <strong>Varnish</strong>).<br/>
The layered system constraint dictates that the client should not know about these layers; in simpler terms, the client should not have to care about the implementation of the server.</li>
<li><strong>Code on demand</strong>: An optional constraint that allows the server to return code for the client to execute. For example, the server may send back custom JavaScript code, <strong>Java applets</strong>, or <strong>Flash</strong> applications. This can be viewed as an extension to the client-server constraint, as it ensures that the client doesn't need to implement code specific for that server, which would otherwise couple the client and server together.</li>
<li><strong>Uniform interface</strong>: An <strong>interface</strong> is a shared boundary that is used to exchange information between two components. An interface is important as it decouples the server from the clients; as long as both adhere to the same interface, they can be developed independently.<br/>
The uniform interface constraint specifies rules on how this interface should be structured, and is further subdivided into four sub-constraints (a.k.a. <strong>interface constraints</strong>):
<ul>
<li><strong>Identification of resources</strong>: a unit of data that is stored on the server is called a <strong>resource</strong>. The resource is an abstract entity, such as a person or a product. This constraint requires that our API assign an identifier to every resource. Otherwise, the client won't be able to interact with it.<br/>
When using REST with HTTP, this constraint is fulfilled by the use of <em>Uniform Resource</em> <em>Locators</em>, or <em>URLs</em>. For example, product #58 should be accessible through the URL <kbd>api.myapp.com/users/58/</kbd>.</li>
<li><strong>Manipulation of resources through representations</strong>: You can represent a resource in different formats, such as XML or JSON. These are different <strong>representations</strong> of the same resource.<br/>
If a client wishes to manipulate a resource in some way, this constraint requires the client to send a full or partial representation of the desired state of the resource.<br/>
As an extension to this, the server should also indicate to the client which representations it is willing to accept, and which representation it is sending back. When using REST with HTTP, this is done through the <kbd>Accept</kbd> and <kbd>Content-Type</kbd> headers, respectively.</li>
<li><strong>Self-descriptive messages</strong>: The response from the server should contain all the information the client requires to process it properly.</li>
<li><strong>Hypermedia as the engine of application state </strong>(<strong>HATEOAS</strong>): This requires the server response to include a list of actions that the client can take after receiving the response.</li>
</ul>
</li>
</ul>
<p>In order to apply the "RESTful" label to an API, it must adhere to <em>all</em> the constraints except code on demand (which is optional).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What REST is not</h1>
                
            
            
                
<p>Before we discuss which REST constraint we should follow and which ones we should not, let's underline one very important distinction: REST is an <em>architectural style</em>, and does not impose low-level implementation details.</p>
<p>REST is a generic set of rules/patterns that you can apply to any API. We commonly use it to structure HTTP APIs, because HTTP is the protocol of the World Wide Web; however, the HTTP protocol and its verbs are in no way tied to REST.</p>
<p>Having said that, Roy Fielding, the author of the REST specification, was also the chief architect of the HTTP/1.1 specification, and so the REST style fits very well with an HTTP implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Should my API be RESTful?</h1>
                
            
            
                
<p>I n the preceding section, I mentioned that our API will <em>not</em> be RESTful; let me explain why. While almost all constraints of REST make sense for modern APIs, HATEOAS does not.</p>
<p>Roy Fielding outlined the REST constraints in his doctoral dissertation paper titled <em>Architectural Styles and the Design of Network-based Software Architectures</em>, which you can access at <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a>. This was back in the year 2000, before search engines such as Yahoo!, Lycos, Infoseek, AltaVista, Ask Jeeves, and Google became prominent. The HATEOAS constraint made sense then, as it allows website visitors to use the list of links to navigate from any one page to any other page.</p>
<p>However, the HATEOAS constraint makes less sense for APIs. Developers who are looking to use our API today are likely to refer to the API documentation on our project's website, rather than infer it from the server response. They're also likely to hardcode URLs into their application code, rather than obtaining them from links provided by the server.</p>
<p>In other words, HATEOAS makes sense for human users, but is not so great for code. In fact, strictly abiding by the HATEOAS constraint would mean our response must include information that is not useful to the application. This will increase network latency without providing any tangible benefits.</p>
<p>Therefore, our API will, by design, not comply with the HATEOAS constraint. Thus, we cannot call our API RESTful.</p>
<p>This can be confusing because many APIs that claim to be RESTful in fact aren't (how many APIs have you used that actually return a list of endpoints with each request? I'd guess none). The lesson to take away is that we should analyze each REST constraint against our API, apply those that make sense, but understand that an API doesn't have to be RESTful to be "good."</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing our API</h1>
                
            
            
                
<p>An application programming interface, or API, is the interface through which end users can interact with our application. For an API to work, both the client and the API server must agree on some form of mutually agreed convention, or contract; for a specific type of requests, the client can expect the API to reply with a specific type of response. But to have a "good" API, this contract must also be <strong>consistent</strong>, <strong>intuitive</strong>, and <strong>simple</strong>. Now, let's tackle each criterion one at a time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consistent</h1>
                
            
            
                
<p>The principle of consistency is very important in API design. Arnaud Lauret, the author of the book <em>The Design of Everyday APIs</em>, elegantly outlined four different types of consistency in his blog post <em>The four levels of consistency in API design</em> (<a href="http://restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/">restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/</a>), which we've summarized here:</p>
<ul>
<li><strong>Common</strong>: Being consistent with the world</li>
<li><strong>Local</strong>: Being consistent within the same API</li>
<li><strong>Transversal</strong>: Being consistent across different APIs by the same organization</li>
<li><strong>Domain</strong>: Being consistent with a specific domain</li>
</ul>
<p>I have made one addition to this list—<strong>perennial consistency</strong><em>—</em>or being consistency <em>across time</em>.</p>
<p>Let's examine each one individually.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Common consistency</h1>
                
            
            
                
<p>As Lauret explained, common consistency is "being consistent with the world." This means our API should conform to well-established and/or authoritative standards; or if none are available, to the community consensus.</p>
<p>If an API is not consistent with the world, it forces developers to learn a new way of thinking. This may require a sizable time investment, which may deter the user from trying the API in the first place. Therefore, having common consistency will likely improve developer experience, and may even drive up the API's adoption rate.</p>
<p>For an HTTP API, the obvious standard to adopt is the HTTP/1.1 specification. This is a standard sanctioned by the <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>), the authoritative international standards organization for the World Wide Web. So, let's see how we can design our API to conform to that standard.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sending the correct HTTP status code</h1>
                
            
            
                
<p>The HTTP specification dictates that any response must have a three-digit status code that allows programs to determine the nature of the response. These codes allow a program to process the response efficiently:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 63px">
<td style="height: 63px">Status code</td>
<td style="height: 63px">Class of response</td>
<td style="height: 63px">Description</td>
</tr>
<tr style="height: 28.7378px">
<td style="height: 28.7378px"><kbd>1xx</kbd></td>
<td style="height: 28.7378px">Informational</td>
<td style="height: 28.7378px">The request was received but not yet fully processed. The client doesn't need to do anything.</td>
</tr>
<tr style="height: 31px">
<td style="height: 31px"><kbd>2xx</kbd></td>
<td style="height: 31px">Success</td>
<td style="height: 31px">The request was successfully received, understood, and accepted.</td>
</tr>
<tr style="height: 31px">
<td style="height: 31px"><kbd>3xx</kbd></td>
<td style="height: 31px">Redirection</td>
<td style="height: 31px">The resource has moved, either temporarily or permanently. The client needs to take further actions to complete the request.</td>
</tr>
<tr style="height: 63px">
<td style="height: 63px"><kbd>4xx</kbd></td>
<td style="height: 63px">Client error</td>
<td style="height: 63px">The request is syntactically and/or semantically incorrect, and the server was unable (or refused) to process it.</td>
</tr>
<tr style="height: 31px">
<td style="height: 31px"><kbd>5xx</kbd></td>
<td style="height: 31px">Server error</td>
<td style="height: 31px">The request is likely to be valid, but there was an error on the server.</td>
</tr>
</tbody>
</table>
<p>You can find the original Status Code Definitions from the W3C at <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">w3.org/Protocols/rfc2616/rfc2616-sec10.html</a>. The current list of valid HTTP Status Codes is maintained by the <strong>Internet Assigned Numbers Authority</strong> (<strong>IANA</strong>); you can find the full list at <a href="https://www.iana.org/assignments/http-status-codes">iana.org/assignments/http-status-codes</a>. Personally, I use <a href="https://httpstatuses.com/">httpstatuses.com</a>, which for me is easier on the eye.</p>
<p>We have already followed these standards for our Create User endpoint. For instance, we respond with a <kbd>415 Unsupported Media Type</kbd> error status code when the request payload is not JSON; Express will automatically respond with a <kbd>404 Not Found</kbd> error if the client tries to hit an endpoint that is not implemented.</p>
<p>According to IANA, there are currently 62 assigned HTTP status codes. Most developers won't be able to memorize all 62. Thus, many APIs restrict the number of status codes they send back. We will do the same, and limit our API to using only the following nine status codes: </p>
<ul>
<li><kbd>200 OK</kbd>: Generic successful operation.</li>
<li><kbd>201 Created</kbd>: Successful operation where a resource, such as a user, is created.</li>
<li><kbd>400 Bad Request</kbd>: When the request is syntactically or semantically incorrect.</li>
<li><kbd>401 Unauthorized</kbd>: When the request lacks authentication credentials so the server cannot determine who is sending the request. The client should resend the request with these credentials.</li>
<li><kbd>403 Forbidden</kbd>: The server understands the request but does not authorize it.</li>
<li><kbd>404 Not Found</kbd>: The resource is not found, or the endpoint path is invalid.</li>
<li><kbd>409 Conflict</kbd>: The resource has been modified after the client last retrieved it. The client should request a new version of the resource and decide whether it'd like to send the request again.</li>
<li><kbd>415 Unsupported Media Type</kbd>: The payload given for this endpoint is in an unsupported format, for example, sending an XML payload when the server only accepts JSON.</li>
<li><kbd>500 Internal Server</kbd>: The request is most likely to be valid, but there's an error on the server.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Using HTTP methods</h1>
                
            
            
                
<p>The HTTP specification also dictated that HTTP requests must contain a verb, and laid out rules for which verbs can be used for what types of request:</p>
<ul>
<li><kbd>GET</kbd>: Requests the retrieval of a resource.</li>
<li><kbd>POST</kbd>: Requests where the server decides how to process the data. The URL specifies the resource that is to handle this request.</li>
<li><kbd>PUT</kbd>: Requests for the entity to be stored under the specified URL.</li>
<li><kbd>PATCH</kbd>: Requests for partial changes to be made to an existing resource.</li>
<li><kbd>DELETE</kbd>: Requests for the resource to be deleted.</li>
<li><kbd>HEAD</kbd>: Requests for the metadata of a resource.</li>
<li><kbd>OPTIONS</kbd>: Requests for information from the server regarding what requests are allowed.</li>
</ul>
<p>Furthermore, <kbd>GET</kbd>, <kbd>HEAD</kbd>, <kbd>OPTIONS</kbd>, and <kbd>TRACE</kbd> are considered to be <strong>safe</strong> methods, which means they must not modify the representation of any resources. Other verbs, such as <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>, are expected to modify resources and should be considered <em>unsafe</em> methods.</p>
<p>There's also the related concept of <strong>idempotency</strong>. An idempotent HTTP method is one that can be repeated multiple times but still produces the same outcome as if only a single request was sent. For example, <kbd>DELETE</kbd> is an idempotent method, because deleting a resource multiple times has the same effect as deleting it once. <em>All safe methods are also idempotent</em>:</p>
<table style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>Method</td>
<td>Safe</td>
<td>Idempotent</td>
</tr>
<tr>
<td><kbd>CONNECT</kbd></td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td><kbd>DELETE</kbd></td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td><kbd>GET</kbd></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><kbd>HEAD</kbd></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><kbd>OPTIONS</kbd></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><kbd>POST</kbd></td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td><kbd>PUT</kbd></td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td><kbd>PATCH</kbd></td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td><kbd>TRACE</kbd></td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>Even if we conform to the HTTP specifications, there are still multiple ways to update a resource: using <kbd>POST</kbd>, <kbd>PUT</kbd> or <kbd>PATCH</kbd>. Therefore, when there is ambiguity in how to interpret a standard, we should turn to community consensus.</p>
<p>We are going to use a set of project guidelines published by Elsewhen, a digital product studio in London. It has over 17,500 stars on GitHub and can be accessed at <a href="https://github.com/elsewhencode/project-guidelines">github.com/elsewhencode/project-guidelines</a>.</p>
<p>The part of the guidelines on HTTP methods is reproduced here:</p>
<ul>
<li><kbd>GET</kbd>: To retrieve a representation of a resource.</li>
<li><kbd>POST</kbd>: To create new resources and sub-resources.</li>
<li><kbd>PUT</kbd>: To update existing resources.</li>
<li><kbd>PATCH</kbd>: To update existing resources. It only updates the fields that were supplied, leaving the others alone.</li>
<li><kbd>DELETE</kbd>: To delete existing resources.</li>
</ul>
<p>So although we could update a resource by sending a <kbd>POST</kbd> request, we will limit <kbd>POST</kbd> requests only to the creation of resources. </p>
<p>Following the guidelines, we will also structure our API paths using the <kbd>/&lt;collection&gt;/&lt;id&gt;</kbd> structure, where <kbd>&lt;collection&gt;</kbd> is a class of resources (for instance, users, products, or articles), and <kbd>&lt;id&gt;</kbd> is the identifier for a particular resource within that collection (for instance, a particular user).</p>
<p>We will use plural nouns to name our collection to make the URL more consistent and easier to read. In other words, we will use <kbd>/users</kbd> and <kbd>/users/&lt;id&gt;</kbd>, instead of <kbd>/user</kbd> and <kbd>/user/&lt;id&gt;</kbd>.</p>
<p>Putting it all together, we get the following table, which details the actions that should be performed for each resource and HTTP method.</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>Resource</td>
<td><kbd>GET</kbd></td>
<td><kbd>POST</kbd></td>
<td><kbd>PUT</kbd></td>
<td><kbd>PATCH</kbd></td>
<td><kbd>DELETE</kbd></td>
</tr>
<tr>
<td><kbd>/users</kbd></td>
<td>Retrieve a list of users</td>
<td>Create new user</td>
<td>Error</td>
<td>Error</td>
<td>Error</td>
</tr>
<tr>
<td><kbd>/users/&lt;id&gt;</kbd></td>
<td>Retrieve user</td>
<td>Error</td>
<td>Update user object (completely); error if user does not exists</td>
<td>Update user object (partially); error if user does not exists</td>
<td>Delete user object; error if user does not exists</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Using ISO formats</h1>
                
            
            
                
<p>For things such as units, we should use formats provided by the <strong>International Organization for Standardization</strong> (<strong>ISO</strong>) whenever possible:</p>
<ul>
<li><strong>Date/time</strong>: UNIX timestamps (in milliseconds) to represent times, and ISO 8601 complete date format to represent dates (<a href="https://www.iso.org/iso-8601-date-and-time-format.html">iso.org/iso-8601-date-and-time-format.html</a>)</li>
<li><strong>Currencies</strong>: ISO 4217 currency codes (<a href="https://www.iso.org/iso-4217-currency-codes.html">iso.org/iso-4217-currency-codes.html</a>)</li>
<li><strong>Countries</strong>: Either ISO 3166-1 alpha-2, ISO 3166-1 alpha-3, or ISO 3166-1 numeric codes (<a href="https://www.iso.org/iso-3166-country-codes.html">iso.org/iso-3166-country-codes.html</a>)</li>
<li><strong>Languages</strong>: ISO 639-2 codes (<a href="https://www.iso.org/iso-639-language-codes.html">iso.org/iso-639-language-codes.html</a>)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Local consistency</h1>
                
            
            
                
<p>Local consistency means being consistent within the same API. In other words, if a developer has worked with one part of your API (for instance, creating a user), he/she should be able to work with other parts of the API using the same conventions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Naming convention</h1>
                
            
            
                
<p>For example, we should follow a consistent set of naming conventions for all our URLs. Specifically, we will do the following:</p>
<ul>
<li>Use kebab-case for URLs</li>
<li>Use camelCase for parameters in the query string, for example, <kbd>/users/12?fields=name,coverImage,avatar</kbd></li>
<li>For nested resources, structure them like so: <kbd>/resource/id/sub-resource/id</kbd>, for example, <kbd>/users/21/article/583</kbd></li>
</ul>
<p>For our non-CRUD endpoints, the URL naming convention should follow a <kbd>/verb-noun</kbd> structure: we should use <kbd>/search-articles</kbd> instead of <kbd>/articles-search</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consistent data exchange format</h1>
                
            
            
                
<p>This may sound obvious, but we should use either use plain text or <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) as the format for data exchange. You shouldn't use JSON for one endpoint and XML for another endpoint, for example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Error response payload</h1>
                
            
            
                
<p>Error response payloads should follow a consistent structure. For instance, the payload should be a JSON object with an array of error objects, each containing three fields:</p>
<ul>
<li><kbd>code</kbd>: A numeric error code, to be used by the program</li>
<li><kbd>message</kbd>: A short, human-readable summary of the error</li>
<li><kbd>description</kbd>: An optional longer, more detailed description of the error</li>
</ul>
<p>Every error payload must follow this format. This allows developers to write a single function that can process all error messages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transversal consistency</h1>
                
            
            
                
<p>Transversal consistency is being consistent across different APIs within the same organization. The reason for this is similar to those for local consistency.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Domain consistency</h1>
                
            
            
                
<p>Domain consistency is being consistent with a specific domain.</p>
<p>For example, if you're developing a scientific publications directory, you should conduct some research in order to acquire knowledge and norms that are specific to this domain. For example, you should know that a scientific publication may be identified with a <strong>PubMed Identifier</strong> (<strong>PMID</strong>), PMCID, Manuscript ID, or <strong>Digital Object Identifier</strong> (<strong>DOI</strong>), so your API's response object should include fields that contain these different identifiers, or at least allow users to search for articles based on these IDs. This is consistent with the norms of the scientific domain.</p>
<p>Another example is to allow for filters that are consistent with the domain. Continuing with the scientific publication directory example, there are usually a few categories of scientific publications: original/primary research, reviews, editorials/opinions, short reports, clinical case studies, methods, meta-analysis, dissertations, conference proceedings, and so on. Allowing users to filter by these categories would be another example of being domain consistent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Perennial consistency</h1>
                
            
            
                
<p>Lastly, I've coined the term <em>perennial consistency</em> to mean being consistent with the past and future of the API.</p>
<p>I chose the adjective <em>perennial</em> over others such as "perpetual" or "persistent" because <em>p</em><em>erpetual</em> implies the API will <em>never</em> change, which is impractical; <em>p</em><em>ersistent</em> implies that developers should obstinately refuse to change the API even if there's a need to, which is not right; <em>p</em><em>erennial</em> means the API structure should stay the same for a long time, but not forever.</p>
<p>To understand why perennial consistency is important, we must first understand what happens when we introduce a breaking (backward-incompatible) change to our API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Breaking changes in APIs</h1>
                
            
            
                
<p>If we are developing a library and want to introduce a breaking change, we can simply bump the major version and publish it. Developers can freely choose if, and when, they want to migrate. However, the process is not so trivial for APIs because for the following reasons:</p>
<ul>
<li>For every version of the API, the API provider must serve and maintain a different instance of the service. This can be a huge overhead.</li>
<li>Different versions of the API would still use the same set of data, so you must design a data structure that is compatible with all versions. Sometimes, this may require you to have redundant fields in your data.</li>
<li>If the changes are too drastic, developers may keep using the older version, possibly prolonging the period for which you must support the older API. </li>
</ul>
<p>Breaking changes are also bad for developer experience because for the following reasons:</p>
<ul>
<li>Developers are often given a limited period of time to update their code to conform to the newer version, before the older version is dropped.</li>
<li>Third-party libraries that depend on your API would also have to update their code. But if maintainers lack the time or willingness to migrate, it could lead to an accumulation of outdated libraries.</li>
</ul>
<p>For these reasons, breaking changes should be avoided as much as possible. When you design your API, take care not to just think about the current requirements, but also any possible future needs.</p>
<p>This does not contradict the <em>you aren't gonna need it</em> (YAGNI) principle. You're not going to <em>implement</em> a feature you may not need. You are just going to think ahead, so you can plan ahead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Future-proofing your URL</h1>
                
            
            
                
<p>One way of achieving perennial consistency is to design future-proof URLs. For example, if we're building a social network where every user must belong to an organization, we can identify a user with a URL structure similar to <kbd>/orgs/&lt;org-id&gt;/users/&lt;user-id&gt;</kbd>. But if we think ahead, there may be a time in the future where our platform needs to cater for users belonging to multiple organizations; in that case, the URL structure we proposed would not support this.</p>
<p>Therefore, we should design our URL to simply include the user's ID (that is, <kbd>/users/&lt;user-id&gt;</kbd>). Then, to associate a user with an organization, we can implement the concept of membership, and structure the membership URL to have the structure <kbd>/orgs/&lt;org-id&gt;/members/&lt;member-id&gt;</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Future-proofing your data structure</h1>
                
            
            
                
<p>Another way to ensure perennial consistency is to future-proof your data structure. For instance, if we want to store a user's name, we could simply specify a <kbd>name</kbd> property of type string. This may work for now, but in the future, we may want to distinguish between first, middle, and last names. We may even want to implement sorting and filtering based on first or last names. Thinking even further ahead, many people, especially from Asian countries, have both an English and non-English name, and so we might even want to allow users to provide their names in multiple languages. Structuring your name property as a string wouldn't work!</p>
<p>This is why our user schema specifies an object as the data structure for the <kbd>name</kbd> property. This allows us to add more properties to the object without breaking existing code. For example, our profile object may eventually evolve into something like this:</p>
<pre>{<br/>  name: {<br/>    first: "John",<br/>    middle: "Alan",<br/>    last: "Doe"<br/>    display: "John Doe",<br/>    nickname: "JD",<br/>    others: [{<br/>      lang: "zho",<br/>      name: "<img class="alignnone size-full wp-image-1897 image-border" src="img/09fcaa59-8314-4886-b08e-9b8750c9b1b8.png" style="width:1.58em;height:1.33em;"/>"<br/>    }]<br/>  }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Versioning</h1>
                
            
            
                
<p>But if a breaking change cannot be avoided, then we must abide by semantic versioning (semver) and increase the major version of our API. But where do we store the version data? There are generally two approaches:</p>
<ul>
<li>In the URL (for instance, <kbd>/v2/users</kbd>): This is by far the easiest to explain and implement, but it's semantically incorrect. This is because URLs should be used to locate a resource; if we add versioning information to the URL, it'd imply that the resource itself is versioned, not the API.</li>
<li>As part of the <kbd>Accept</kbd> header (for instance, <kbd>Accept: application/vnd.hobnob.api.v2+json</kbd>): The <kbd>vnd</kbd> prefix in the MIME type denotes that this is a vendor-specific MIME type; here, we are using it to specify the API version we want. The <kbd>+json</kbd> denotes that the reply could be parsed as JSON. This is the most semantically correct approach, but it also requires more effort to explain to end users.</li>
</ul>
<p>The URL approach is more practical; the <kbd>Accept</kbd> header approach is more semantic. Neither one is "better" than the other. Pick the one that makes sense for you and your audience.</p>
<p>When making a breaking change, apart from increasing the version of your API, make sure you also:</p>
<ul>
<li>Provide a grace period whenever possible, that is, a deprecation period where both the legacy and new versions run concurrently, in order to allow developers time to migrate to the newer version</li>
<li>Provide deprecation warnings in advance, including the date when the older API version will no longer be supported and the date when it will become unavailable altogether</li>
<li>Provide a clear list of all breaking changes</li>
<li>Provide clear instructions on how to migrate to the newer version</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Intuitive</h1>
                
            
            
                
<p>When we interact with everyday objects, we have an expectation of how they are going to work. This is known in design as affordance. For example, if you see a handle on a door, it should be instinctive to you that you should be pulling on the handle; conversely, a flat rectangular piece of metal (called a finger plate) attached to the door implies it should be pushed:</p>
<div><img src="img/b44fd0e3-0b25-43a0-8504-d5a6449a6f32.jpg" style="width:40.50em;height:27.08em;"/></div>
<p>(Left) Adding a handle to the side of the door that is meant to be pushed is an example of bad design, as the handle is for pulling, not pushing. (Right) The handle already suggests that the door is meant to be pulled, so the "Pull" label is unnecessary here. This image is taken from <kbd>chriselyea.com/wp-content/uploads/2010/01/PushPullDoors.jpg</kbd> (dead link).</p>
<p>This concept of affordance is universal to all design, including API design. Likewise, an API should be self-explanatory and as obvious as possible.</p>
<p>Users don't want to learn new behaviors. Users don't want to read the documentation in order to use your platform. The best case scenario is that your API is so intuitive that they only need to refer to the documentation once in a while.</p>
<p>On the other hand, if your API is unintuitive, then a user may still try it out, but they may feel the learning curve is too high and use an alternative platform instead.</p>
<p>This also touches on the previous point made about consistency: if it is commonly consistent, then users will feel more familiar with using your API.</p>
<p>Being intuitive simply means making things obvious. We should follow the<strong> Principle of Least Astonishment </strong>(<strong>POLA</strong>), which states that <em>"the result of performing some operation should be obvious, consistent, and predictable, based upon the name of the operation and other clues."</em></p>
<p>Here, we outline a few things we can do to make sure our API is as intuitive as possible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">URLs for humans</h1>
                
            
            
                
<p>Related endpoints should be grouped. For example, the Instagram API groups endpoints into user-, media-, tags-, and location-related endpoints, each under <kbd>api.instagram.com/v1/{group}/</kbd>.</p>
<p>This makes it easy for the consumer of the endpoint to immediately be able to deduce the intended function of the endpoint, without having to refer to the documentation. The function of the endpoint should be obvious to the consumer.</p>
<p>For example, it's immediately obvious that <kbd>/users/:user-id/media/recent</kbd> is an endpoint that retrieves the most recent media objects of a user.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Favor verbosity and explicitness</h1>
                
            
            
                
<p>When in doubt, always favor verbosity and explicitness over implicitness, as it can cut out the ambiguity in the API. For example, use <kbd>userId</kbd> instead of <kbd>uid</kbd>, which some may interpret as "unique ID."</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Keep It Simple Stupid (KISS)</h1>
                
            
            
                
<p>Last but not least, a good API must be simple.</p>
<p>One of the main reasons for having an API is to abstract the implementation details away from the end user. You should not expose internal functions to the end user because it will add unnecessary complexity to your API—users will have more documentation to read, even if 90% of it is irrelevant to what they want to do.</p>
<p>The rule is to think about what are the minimum set of functions that can be exposed, but still allow a typical user to perform all the necessary functions. For example, when a new user signs up, a profile is automatically created for them, and so there's no need to expose the internal <kbd>createProfile</kbd> function as the <kbd>/POST profile</kbd> endpoint, as a typical user will never call it.</p>
<p>"When in doubt, leave it out" is a good adage to remember; it's often easier to add to an API than to remove features that some developers (albeit a very small percentage) are already using.</p>
<p>A toddler won't cry if you don't buy them a new toy they didn't ask for, but try to take away a toy they are playing with, and you may find your ears ringing for a while.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Completing our API</h1>
                
            
            
                
<p>In the previous chapters, we have shown you how to write unit, integration, and E2E tests as part of a TDD process. In this chapter, we've outlined the factors you should consider when designing an API. Now, we pass the baton to you to implement the rest of the API. Specifically, you should implement the following requirements:</p>
<ul>
<li>Delete
<ul>
<li>User must provide a user ID to delete</li>
</ul>
</li>
<li>Search
<ul>
<li>Defaults to the last 10 users who have registered</li>
</ul>
</li>
<li>Create
<ul>
<li>User must provide an email address and password</li>
<li>User may optionally provide a profile; otherwise, an empty profile will be created for them</li>
</ul>
</li>
<li>Retrieve
<ul>
<li>When a user provides a user ID of another user, the profile of that user should be returned</li>
</ul>
</li>
<li>Update
<ul>
<li>When a user provides a user ID and a complete user object, we should replace the old user object with the new one</li>
<li>When a user provides a user ID and a partial user object, we should merge the partial object into the existing object</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Remember to also follow our existing conventions:</p>
<ul>
<li>All request data must be transmitted in JSON format</li>
<li>All response data payloads must be in JSON format or plain text</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we took a look at how to design and structure our API so that it is consistent, intuitive, and simple for our end users. We then left you to apply these principles as you implement the CRUD and search endpoints. In the next chapter, we will learn how to deploy our API on a cloud server, so that it's available to the world!</p>


            

            
        
    </body></html>