- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hooks and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it can be incredibly useful to make API requests from any page, imagine
    the nuisance of attempting to authenticate a user for an external API on *every*
    page. It may be possible to create a custom helper that adds specific headers
    or cookies to every single request to assist with this. Fortunately for us, SvelteKit
    provides methods to manipulate Request and Response objects across the entirety
    of a framework. It does so with what are called **hooks**. These hooks can be
    incredibly powerful to manage data that flows in and out of our application. They
    can also be helpful for managing errors. Since our previous encounters with error
    handling have been so brief, we’ll examine error handling a little closer after
    covering hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a practical example, we’ll build a simple interface allowing us to *star*
    the official SvelteKit repository on GitHub. You’ll have to authenticate your
    personal account, but if you don’t have an account on GitHub, fear not, as the
    concepts will be easy enough to follow along with. By the end of the exercise,
    we’ll have covered the hooks available to use within SvelteKit, as well as how
    they can be leveraged to assist in managing errors.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter09](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An account on GitHub is necessary to build the example: [https://github.com/signup](https://github.com/signup).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike other JS frameworks that shall not be named, SvelteKit keeps the list
    of hooks to remember short and simple. At the time of writing, there are only
    two types of hooks – `+page.server.js` runs only on the server and `+page.js`
    runs on either the server or the client. Both server and shared hooks are placed
    in the `src/` directory, either in `src/hooks.server.js` or `src/hooks.client.js`,
    depending on which environment we intend to run the hook on. We’ll break this
    section down into the following subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: Server hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this section, you’ll be able to modify all incoming and outgoing
    requests to your SvelteKit applications.
  prefs: []
  type: TYPE_NORMAL
- en: Server hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hooks that can only be run on the server are `handleFetch()` and `handle()`.
    As we would expect, `handleFetch()` has the ability to manipulate requests made
    by SvelteKit’s included `fetch()` method, which can be called within `load()`
    or through actions. The other hook, `handle()`; can manipulate data as SvelteKit’s
    router receives requests. One way to think of this is that `handleFetch()` manipulates
    the data *leaving* an app and `handle()` manipulates data *coming into* it. As
    server hooks, both can be added to `src/hooks.server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: To begin this chapter’s example to demonstrate how useful hooks can be, let’s
    set up a few things. Firstly, we’ll need a way to authenticate our personal account
    with GitHub. The manner in which we will achieve this is by sending a **personal
    access token** to the appropriate GitHub API endpoints. Once generated, this token
    can be added to the HTTP request headers. It’s very important to treat tokens
    just as we treat passwords, so we’ll import this token securely through environment
    variables, which will be discussed further in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To generate your token, visit [https://github.com](https://github.com) and sign
    in. You can then navigate to your profile settings by clicking your profile image
    in the top-right corner and selecting `SvelteKit star repo`, an expiration date,
    and the full *repo* scope. Once done, click **Generate Token** and copy the value
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then open our SvelteKit project and, in the root folder of the project,
    create a `.env` file. In this file, we’ll add our token, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: .env
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can then save and close the file. We’ll go into more details on how how
    to manage secrets in a later chapter, but for now, just know that we’ve given
    our token a name using which we can import it into our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create a new route and add it to `Nav.svelte`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/lib/Nav.svelte
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is a simple addition where we add markup for a link to our ever-growing
    list of links. Once we have added the markup for our new route to the navigation,
    we’ll create the appropriate `+page.svelte` file to render the route. This page
    will consist of a simple form, with buttons allowing us to *star* and *unstar*
    the SvelteKit repository on GitHub, as well as some text showing just how many
    stars the repository currently has:'
  prefs: []
  type: TYPE_NORMAL
- en: src/routes/(app)/github/+page.svelte
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a lot going on here, but it’s nothing we haven’t seen yet. Starting
    at the end of the file, we can see that this page contains a `<form>` element
    consisting of two buttons. One button calls to the `/github?/star` action and
    the other to the `/github?/unstar` action. The form uses the `enhance` module,
    meaning requests are made in the background and do not trigger a page reload.
    Each button inside the form calls the function expression assigned to the constant
    `reload`. That anonymous function utilizes the `invalidate` module, which then
    forces any `load()` functions with `fetch()` methods calling the specified URL
    to be rerun. This is helpful, as the paragraph tag showing how many stars the
    repository has will then be updated accordingly. The final portion of code to
    make note of is the Svelte `{#if}` directive, which will alert us to the status
    of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have saved `+page.svelte`, we’ll need to move on to our `+page.server.js`,
    as it will contain the bulk of our logic. Importantly, it won’t contain any of
    the code related to authentication, as all of that will reside in the hook:'
  prefs: []
  type: TYPE_NORMAL
- en: src/routes/(app)/github/+page.server.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot going on here, but again, it’s nothing we haven’t seen before.
    The very first line declares a constant `star_url` that can be referenced in our
    `fetch()` requests later on. This is the endpoint we will reach out to alert GitHub
    that we want to *star* or *unstar* the repository. The very next chunk of code
    creates a familiar `load()` function. This endpoint does not actually require
    authentication and will return general information about the specified repository.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we can examine the two actions we’ve created – *star* and *unstar*.
    Both of these destructure the `fetch()` method bundled with SvelteKit. Both then
    use `fetch()` to make a request to the `star_url` endpoint but differ in the type
    of HTTP method they utilize, as per the GitHub API specifications. We’ve also
    added an extra header to the *star* request, as the official GitHub API documentation
    dictates that `Content-Body` should be set to `0` for this particular request.
    Both actions then return an object consisting of the request status and a message
    alerting us as to whether the request went through successfully, or whether an
    error was received.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we could navigate to `http://localhost/github` in our browser
    and view the number of stars on the official SvelteKit repository. However, attempting
    to star it will result in an error, as we won’t have the appropriate permissions
    with the GitHub API. To authenticate, we’ll need to provide our access token in
    the headers of our network requests. While we could do this in the `+page.server.js`
    file inside each of the actions, it would quickly become a hassle if we decided
    to build more routes that also required authentication with GitHub. For instance,
    what if we wanted to build functionality allowing us to read and react to comments
    on issues? Instead, we can use `handleFetch()` to catch all outgoing `fetch()`
    requests before they leave our application and authenticate in a single location.
    To do so, we’ll need to create `src/hooks.server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/hooks.server.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We begin by importing the personal access token we created earlier. Again, we’ll
    examine how this works in a later chapter, so for now, just acknowledge that we’ve
    imported the token saved to `.env`. We then create the function definition for
    `handleFetch()`. Fetch is an asynchronous API, so we need to specify that this
    function will also be `async`. We’ve then destructured the `RequestEvent` object
    to extract `request` and `fetch`. Within the hook, we check to see whether the
    requested URL is [https://api.github.com/](https://api.github.com/). If it is,
    we’ll then set the necessary `Accept`, `Authorization`, and `X-GitHub-Api-Version`
    headers. While `Accept` and `X-GitHub-Api-Version` are simple predetermined strings,
    the `Authorization` header value is the concatenated string *bearer*, as well
    as the imported personal access token.
  prefs: []
  type: TYPE_NORMAL
- en: We can now open `http://localhost/github` in our browser and click the *star*
    button. Because we’ve used `invalidate()` on the GitHub API URL, we should then
    observe the count increasing by one. The developers of SvelteKit have certainly
    earned our star, but if you’re uncomfortable with this simple act of charity,
    try clicking the *unstar* button and observing the change again.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that `handleFetch()` will only hook into the `fetch()`
    function provided by SvelteKit and not a standard `fetch()`. This can be observed
    by removing the destructured `fetch` parameter from the *star* and *unstar* actions
    in `src/routes/(app)/github/+page.server.js`. Then, attempting to star the repository
    will return an *unauthorized* error from the GitHub API, as the `handleFetch()`
    hook is not called unless we use the `fetch()` method provided with SvelteKit.
    This can also be observed by removing the destructured `fetch` from the `load()`
    function in `+page.server.js`. Provided you have not exceeded GitHub’s rate limits,
    the standard `fetch()` function will continue providing data because the endpoint
    called to does not require authentication. Because of this, it is strongly encouraged
    to use SvelteKit’s `fetch()` whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, being able to manipulate requests leaving our application is
    quite powerful, but what about the requests coming into our platform? For that,
    we need to leverage `handle()`. For this example, we’ll demonstrate it by adding
    the `handle()` hook of `src/hooks.server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/hooks.server.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this version, we’ve added the `handle()` function definition to the end of
    the file. This function accepts a `RequestEvent` object as well as a `resolve()`
    function. In our version, we’ve added a custom header that will be added to all
    requests within our application. That header is `X-NOT-FROM-GITHUB` and will contain
    the value *our value*. Once the header has been added to the `event` object, we
    complete the request by passing the event to `resolve()` and returning the promise.
    We’ve also added another method to demonstrate how you might go about modifying
    the headers after the request is made with `resolve()`. These headers can be observed
    by opening the browser on any page within our application, opening **Developer
    Tools**, navigating to the **Network** tab, and refreshing the page. Opening the
    very first request will show our custom headers and values in **Response Headers**.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we’re not limited to setting only headers. Headers were chosen simply
    for demonstration purposes. We can also set data that will be made available to
    us in `load()` and server pages by setting `event.locals` to the object of our
    choosing. We can even utilize `event.cookies` to modify cookie values. However,
    if we use SvelteKit’s included `fetch()` method, those cookies will automatically
    be passed within the application, so long as it lives at a domain that has permission
    to access the cookies. One final note to make is that both `handle()` and `handleFetch()`
    will run either on render or during the prerendering process. This is particularly
    important to remember if you’re attempting to generate a static site using `adapter-static`.
  prefs: []
  type: TYPE_NORMAL
- en: As we just demonstrated, server hooks can be a powerful tool to leverage when
    you need to customize request and response headers. While modifying header data
    is only one use case for them, the example we provided should highlight the many
    possible solutions they can address. Next, let’s take a look at the hooks available
    to us on the client as well as the server.
  prefs: []
  type: TYPE_NORMAL
- en: Shared hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having just covered the two hooks available in server environments, we now
    only have `handleError()` available to us in client environments. This hook is
    useful for capturing errors that weren’t thrown through the use of SvelteKit’s
    `error` module – that is, any critical application errors, or errors thrown using
    `throw new Error()`. It can be very useful to log application errors. It also
    allows us to control what users will see when they encounter a serious issue with
    an application. To demonstrate how a shared hook works, let’s add it to both `src/hooks.server.js`
    and `src/hooks.client.js`. In this example, we’ll log errors on the server to
    a file and errors on the client using `console.log()`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/hooks.client.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we use `console.log()` to show various messages within the
    browser console. It would be nice if `handleError()` ran for every unexpected
    error within the client; however, that is not the case, as it only runs if an
    error is encountered during a client-side `load()` or while rendering on the client.
    As such, we’ll need to throw an error in another location to see it in action.
    To trigger this error, we’ll make a minor change to `src/routes/(site)/fetch/+page.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: src/routes/(site)/fetch/+page.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first change we make is importing the `browser` module from `$app/environment`.
    Once done, we check that the code being run is in the browser and then throw an
    error, leaving the rest of the code alone. When we navigate to the `/fetch` route
    in our application, we’ll see the messages output from `src/hooks.client.js`.
    With this hook, we can ensure that no sensitive data is output to the client during
    client-side errors. We can also tailor the message in the returned error object
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate `handleError()` on the server, we can write the error messages
    to a log file, which can be easily read at a later time by developers or a daemon
    installed on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: src/hooks.server.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first change in this example to note is that we’ve imported the `fs` module.
    This is a Node-specific module for accessing the filesystem. This is worth noting,
    as including it will prevent us from building our application for another environment.
    The next change to note is that we’ve added the `today()` function, which returns
    the current date and time as a string. Ideally, this function would live in a
    `utilities` folder, likely located in `src/lib/`, but for this demonstration,
    we can include it here. We’ve also added `handleError()` to the end of the file.
    It accepts an `error` object as well as an `event` object. We then concatenate
    the output from the `today()` function with the error message, as well as information
    about where the error occurred. This is all then written to our log file using
    `fs.appendFile()`. If an error is encountered while writing to the file, we’ll
    output it to the console. Finally, we return an object containing the error message.
  prefs: []
  type: TYPE_NORMAL
- en: To trigger `handleError()`, we can throw an error in one of our actions or `load()`.
    The precise location isn’t particularly important, but we can see our logging
    in action by adding `throw new Error('our custom error');` to `+page.server.js`.
    In fact, try throwing an error from various `load()` functions or actions we’ve
    created so far. You can even experiment with the data provided from the request.
    For example, it might be helpful to log various headers, such as the client User-Agent,
    as this information can be helpful when troubleshooting browser compatibility.
    Once you have thrown a few errors, open `app.log` in the root of the project directory
    and observe the output. This simple logging mechanism can be tailored to a project’s
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging `handleError()`, we can effortlessly bootstrap our own logging
    mechanism. We can also customize messages shown during errors on client-side rendering
    or `load()`, which is especially helpful if our application is a single-page app.
    Of course, `handleError()` is very helpful, but it’s only helpful for unexpected
    errors. How should we manage errors that we fully expect?
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oftentimes, pesky users attempt to access resources they’re not supposed to
    access. Or maybe they’re just users being users and not paying attention to where
    they’re clicking. In any case, we’ve all met at least one user like this. As developers,
    it is in our best interest to ensure our code gives those users meaningful messages
    when they inevitably encounter an error. For the sake of our sanity and future
    selves, we should discuss errors in SvelteKit.
  prefs: []
  type: TYPE_NORMAL
- en: All of the errors we just created with `handleError()` are considered *unexpected
    errors*. That is because we did not use SvelteKit’s error module. Errors created
    using this module are considered *expected errors*. By importing the module, we
    can send custom status codes and error messages to SvelteKit, which can then be
    captured and used by `+error.svelte` components. This gives us even greater control
    over how our messaging displays to users.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060), we briefly examined
    how the routing mechanism will interact with the closest `+error.svelte` template
    available. However, we didn’t really discuss the `error` module or how to use
    it. Firstly, it needs to be imported from `@sveltejs/kit`. Once imported, we can
    then throw the error with `throw error()` and pass the function two arguments.
    The first argument is an integer representing the HTTP status code classifying
    the error. For instance, a `401` code represents a *client unauthorized* error.
    The second argument passed to `error()` is an object containing a message property,
    with the message we would like conveyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an example, let’s make some modifications to our previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: src/routes/(app)/github/+page.server.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve imported the `error` module from `@sveltejs/kit`. Within
    the `load()` function, we then immediately throw an error using the module. For
    our error, we supply the `401` status code and an object with `message` properties,
    as well as a custom error `id`. Again, this can be helpful for reporting and logging
    errors because we can customize the error object with whatever information we’d
    like to provide. If we prefer not to create a whole object, we can instead provide
    a string with the error message or even just the HTTP status code! We’ll leave
    the rest of the code in this file unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of building a traditional `try catch` statement around the error, we’ll
    let SvelteKit handle the catching by providing a customized `+``error.svelte`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: src/routes/(app)/github/+error.server.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To show our error messages, we’ll have to leverage the data within the Svelte
    store `page`. This store is imported from `$app/stores`, and the data within it
    can be accessed by prefacing the store name with a `$` symbol. The `page` store
    contains various properties and data pertaining to the accessed page. We then
    show the provided error message, followed by a Svelte `{#if}` directive to show
    the error ID, provided it exists.
  prefs: []
  type: TYPE_NORMAL
- en: We can then navigate to `http://localhost/github` and view our new error message,
    as well as an error ID number. To play around with this example and learn a little
    more about error handling, try moving `src/routes/(app)/github/+error.svelte`
    to `src/routes/(app)/+error.svelte`. What happens if you move it all the way up
    to `src/routes/+error.svelte`? You should try this in your own project, but in
    short, Svelte’s routing mechanism is robust enough to take the error to the nearest
    `+error.svelte` component it finds.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored error handling, you should now be able to show your application
    users pertinent information related to the error they’ve stumbled across. Doing
    so in an informative way should minimize the time spent triaging support tickets.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having explored the various hooks available in SvelteKit as well as error handling,
    we’ve covered a lot. We first saw how we can modify outgoing `fetch()` requests
    that leverage SvelteKit’s included `fetch()` by changing familiar `RequestEvent`
    objects in the `handleFetch()` hook. We also saw how we can adjust data flowing
    into our application via `handle()`. Then, we explored the `handleError()` shared
    hook and how it can be utilized to build a rich logging mechanism or incorporated
    with another service. Finally, we returned to look at how we can manage expected
    errors with SvelteKit’s error routing devices, which allow us to customize the
    look and feel through custom Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a firm grasp on how to manage errors, we’ll move on to the
    next chapter to assess how we can best manage static assets.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitHub API documentation: [https://docs.github.com/en/rest](https://docs.github.com/en/rest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
