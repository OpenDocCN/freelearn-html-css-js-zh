<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;REST is Best &#x2013; Interacting with the Server Side of Your App"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. REST is Best – Interacting with the Server Side of Your App</h1></div></div></div><p>The majority of development work involved in creating a JavaScript single page application is generally going to be on the frontend, but not to be overlooked is the all-important data-transfer layer of your application, which communicates with the server and the database. <span class="strong"><strong>Representational State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>) is the standard architectural style of data transfer between client and server for the World Wide Web and the <span class="strong"><strong>Internet of Things</strong></span> (<span class="strong"><strong>IoT</strong></span>). Any time you use a web application, chances are that REST is being used to communicate data and transitions of state from the UI.</p><p>The beauty of using the REST architectural style for a SPA is that the frontend of your application can be entirely agnostic of what type of software is being used to retrieve requests on your server, as long as your application can be used over <span class="strong"><strong>Hypertext Transfer Protocol </strong></span>(<span class="strong"><strong>HTTP</strong></span>), the standard application protocol for the World Wide Web.</p><p>In this chapter, you will learn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The fundamental aspects of the REST architectural style</li><li class="listitem" style="list-style-type: disc">How to write basic REST API endpoints for performing CRUD operations in a single page web application</li><li class="listitem" style="list-style-type: disc">How to work with REST requests on your application frontend using AJAX</li><li class="listitem" style="list-style-type: disc">The basics of some alternatives to REST, such as SOAP, WebSockets, MQTT, CoAP, and DDP</li></ul></div><div class="section" title="Understanding the fundamentals of REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Understanding the fundamentals of REST</h1></div></div></div><p>REST is the architectural style used to serve web pages and make requests on the World Wide Web, or simply the Web. Although the Internet and the Web are often referred to interchangeably, they differ in the fact that the Web is merely a <span class="emphasis"><em>part</em></span> of the Internet.</p><p>The Web is a collection of documents, or <span class="emphasis"><em>web pages</em></span>, which are served or hosted on computers all over the world and are connected via <span class="emphasis"><em>hyperlinks</em></span>, or what are commonly referred to as links. These links are served over HTTP, the language of communication for the Web. REST is often confused with HTTP because of its mutual relationship with the Web, but HTTP and REST are far from the same thing.</p><div class="section" title="Understanding an architectural style versus a protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Understanding an architectural style versus a protocol</h2></div></div></div><p>REST is an architectural style, while HTTP is an application layer protocol. This means that while HTTP is the language of communication on the Web, REST is simply a set of rules for performing requests and operations on the Web. These operations performed through a REST architectural style are commonly referred to as <span class="emphasis"><em>Web Services</em></span>. In this way, HTTP is simply the method of transport for the Web Services performed by an application using REST.</p><div class="section" title="Architectural style"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec48"/>Architectural style</h3></div></div></div><p>An architectural style, or architectural pattern, is a set of rules which provides developers with the ability to build abstraction layers as frameworks that are built to achieve a common language of interaction that is to ultimately be consumed by some type of client, or user agent. In the case of the Web, that user agent is a web browser.</p><p>A web abstraction layer, or web framework, can be written in any number of languages to provide Web Services via REST, or RESTful services, as long as that language can be hosted on a web server. When that framework follows the REST architectural style, the UI for any application using it can be completely<span class="emphasis"><em> agnostic</em></span>, or unbiased, as to the technology behind the RESTful service.</p></div><div class="section" title="Protocol"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec49"/>Protocol</h3></div></div></div><p>A protocol, as it relates to the Web, is part of an abstraction layer of the <span class="strong"><strong>Internet Protocol Suite</strong></span>, or TCP/IP, providing a common method of communication between connected computers.</p><div class="section" title="Transport layer protocols"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec14"/>Transport layer protocols</h4></div></div></div><p>The term TCP/IP is a combination of the Internet Protocol Suite's most widely used protocols: <span class="strong"><strong>Transmission Control Protocol</strong></span> (<span class="strong"><strong>TCP</strong></span>) and <span class="strong"><strong>Internet Protocol </strong></span>(<span class="strong"><strong>IP</strong></span>).</p><p>
<span class="strong"><strong>TCP</strong></span>
</p><p>TCP is a transport layer protocol, which lies underneath the application layer. This means that services and information are <span class="emphasis"><em>transported</em></span> up to the top-level application layer of the Internet Protocol Suite.</p><p>
<span class="strong"><strong>IP</strong></span>
</p><p>IP is also a transport layer protocol. You have most likely seen this protocol associated with the term IP address, or Internet Protocol address, which is a unique numerical identifier for a device on a network. On the Web, domain names are commonly used to point to an IP address to make it easier for people to remember how to reach that address.</p></div><div class="section" title="Application layer protocols"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec15"/>Application layer protocols</h4></div></div></div><p>The application layer of TCP/IP is the abstraction layer that defines methods of communication between host computers that are connected through the Web. This layer specifies several protocols, with some of the most common being HTTP, FTP, SSH, and SMTP.</p><p>
<span class="strong"><strong>HTTP</strong></span>
</p><p>HTTP is the primary protocol for data exchange within the application layer of TCP/IP, and it provides the foundation of communication for RESTful web services. HTTP is also responsible for serving a web page for display within a browser, and for sending data from a form on a web page to a server.</p><p>
<span class="strong"><strong>FTP</strong></span>
</p><p>The <span class="strong"><strong>File Transfer Protocol</strong></span> (<span class="strong"><strong>FTP</strong></span>), is another standard protocol within the TCP/IP application layer that is used for transferring files between computers. FTP communication requires an FTP server and an FTP client.</p><p>
<span class="strong"><strong>SSH</strong></span>
</p><p>
<span class="strong"><strong>Secure Shell</strong></span> (<span class="strong"><strong>SSH</strong></span>) is another common protocol in the application layer which is used to allow secure remote logins to a non-secure network entry point. For SSH connections to work, a SSH server must be available to receive requests from a SSH client. A SSH client most often comes in the form of a terminal application with a <span class="strong"><strong>command line interface</strong></span> (<span class="strong"><strong>CLI</strong></span>).</p><p>
<span class="strong"><strong>SMTP</strong></span>
</p><p>
<span class="strong"><strong>Simple Mail Transfer Protocol</strong></span> (<span class="strong"><strong>SMTP</strong></span>) is the standard method of sending e-mail, or electronic mail, in the application layer of TCP/IP. SMTP may also be used to receive e-mail and is typically used for this purpose by e-mail servers. SMTP is not typically used by user-level e-mail clients for receiving e-mail, however. Instead, these clients more commonly use POP3 or IMAP.</p><p>POP3 is the third version of the <span class="strong"><strong>Post Office Protocol</strong></span>, which is a standard application layer protocol for receiving e-mail over TCP/IP connections. POP3 is generally used to download e-mail to a local computer and then delete it from the host server.</p><p>IMAP is the <span class="strong"><strong>Internet Message Access Protocol</strong></span>. It is also a standard application layer protocol for receiving e-mail over TCP/IP connections. IMAP is generally used as way to manage a host server e-mail inbox by multiple clients, and therefore it does not delete the e-mail from the server after downloading it to a local computer like POP3. The latest versions of IMAP also support tracking the state of an e-mail on the host server, such as read, replied to, or deleted.</p></div><div class="section" title="Using HTTP as a transfer protocol for REST"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec16"/>Using HTTP as a transfer protocol for REST</h4></div></div></div><p>REST defines a set of rules by which to make HTTP requests for a web application or service. HTTP requests can be made in any number of ways, but they are only RESTful if they follow that set of rules. HTTP provides the transport layer upon which those requests are made.</p><p>In the same way that a web application interacting with a REST API is agnostic of the type of software framework being used to serve the API endpoints, HTTP is agnostic of the types of operating systems being used across all of the servers which it communicates with.</p></div></div></div><div class="section" title="The constraints of REST"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>The constraints of REST</h2></div></div></div><p>The REST architectural style is governed by a set of constraints, or rules, that dictate how it should be implemented, interacted with, and handle data. REST was first defined by the American computer scientist Roy Fielding in a doctoral dissertation in 2000, along with these constraints.</p><p>REST is considered to be a <span class="emphasis"><em>hybrid</em></span> architectural style in that it borrows from other architectural styles that existed before its conception. These other architectural styles lend greatly to the REST constraints outlined here.</p><div class="section" title="Client-server"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec50"/>Client-server</h3></div></div></div><p>The first constraint of REST is the client-server architectural style. This constraint exists to enforce the agnostic nature of REST, or the <span class="emphasis"><em>separation of concerns</em></span> that is so fundamental to it:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_04_01.jpg" alt="Client-server"/></div><p>
</p><p>This diagram shows the client-server relationship, and how they are separated. The <span class="strong"><strong>client</strong></span>, or web browser, needs only display the UI for an application. The UI can be as simple or as sophisticated as deemed necessary, without affecting the REST architecture on the server. This REST constraint provides for scalability.</p></div><div class="section" title="Stateless"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec51"/>Stateless</h3></div></div></div><p>The second constraint of REST builds upon the client-server constraint in that the communication between client and server must be stateless. This means that any request from a web browser to the REST server must supply all expected information needed for the context of the request and the current session in order to expect the appropriate response from the server.</p><p>The server will have no stored information to help delineate the request, thereby making the REST server <span class="emphasis"><em>stateless</em></span> and putting the burden of session state on the web browser:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_04_02.jpg" alt="Stateless"/></div><p>
</p><p>This diagram depicts the client-stateless-server architectural style in which the web browser state can change and the REST server remains consistent. This REST constraint provides for visibility, reliability, and scalability, which are a few of the key benefits of using REST.</p></div><div class="section" title="Cache"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec52"/>Cache</h3></div></div></div><p>The third constraint of REST builds again upon the client-server and stateless constraints. A cache, or data stored for reuse, can be permitted for use by the browser for any given request based on the cacheability of that request as delegated by the REST server. If the server's cache component indicates that a request is cacheable, then the browser can cache it for future requests. Cacheability is often indicated in the case where a request made multiple times to a particular REST endpoint will likely result in an identical response each time:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_04_03.jpg" alt="Cache"/></div><p>
</p><p>This diagram depicts the client-cache-stateless-server architectural style. This style is just like client-stateless-server, but with the added component of a client cache.</p></div><div class="section" title="Uniform interface"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec53"/>Uniform interface</h3></div></div></div><p>The fourth constraint of REST is the use of a uniform interface among components of the system. This refers to the simplistic nature of the architecture involved in a REST implementation in which the components are decoupled. This allows each component of the architecture to evolve on its own, without affecting the others:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_04_04.jpg" alt="Uniform interface"/></div><p>
</p><p>This diagram shows the uniform-client-cache-stateless-server architectural style. This combines the three previous architectural style constraints with the added constraint of uniform interface.</p><p>The uniform interface constraint is further subdivided into four of its own constraints.</p><div class="section" title="Identification of resources"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec17"/>Identification of resources</h4></div></div></div><p>A resource in REST is any conceptual mapping of information to a uniquely identifiable object. This object can be a person, place, or thing. An example of this in the case of the Web is a Uniform Resource Identifier (URI). More specifically, a Uniform Resource Locator (URL) is a special type of URI that provides a method to find a web resource and specifies how to obtain a representation of information from that resource. A URL is also commonly referred to as a web address. In relation to REST, a URL may also be referred to as an endpoint.</p></div><div class="section" title="Manipulation of resources through representations"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec18"/>Manipulation of resources through representations</h4></div></div></div><p>A representation in REST is a set of data which represents the current state of a resource. In a web architecture using REST, a JSON document can be used as a representation to pass between client and server, and manipulate or change a resource.</p></div><div class="section" title="Self-descriptive messages"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec19"/>Self-descriptive messages</h4></div></div></div><p>Messages in REST are the communication between components. In keeping with the constraint for a REST server to be stateless, the messages must be self-descriptive, meaning it carries all the information necessary to tell each component how it should be processed.</p></div><div class="section" title="Hypermedia as the engine of application state"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec20"/>Hypermedia as the engine of application state</h4></div></div></div><p>Hypermedia refers to web pages, or hypertext, and the hyperlinks that connect them. In order to remain stateless, a RESTful architecture uses hypermedia to convey the state of the application based on representations received from the server.</p></div></div><div class="section" title="Layered system"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec54"/>Layered system</h3></div></div></div><p>The fifth constraint of REST is a layered system, which is a hierarchy of architectural components, where each layer provides services to the layer above it and uses the services from the layer below it. In this manner, each layer only has visibility into one layer below it, thus making it agnostic of any layers down.</p><p>This concept is applied to distributed servers on the Web that are used to enhance the scalability of an application. For example, a web browser may communicate with any number of <span class="emphasis"><em>intermediate</em></span> servers based on its location, but it is never aware of whether it is connected to the end server or one of those intermediate servers.</p><p>A layered system is also used to implement load balancing across servers. This allows additional servers to take on requests when the primary server is inundated with too many requests:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_04_05.jpg" alt="Layered system"/></div><p>
</p><p>This diagram depicts a uniform-layered-client-cache-stateless-server. This architectural style combines the previous four with the added constraint of a layered system.</p></div><div class="section" title="Code-on-demand"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec55"/>Code-on-demand</h3></div></div></div><p>The sixth and final constraint of REST is the<span class="strong"><strong> code-on-demand </strong></span>architectural style, and it is the only <span class="emphasis"><em>optional</em></span> constraint. In this style, the server provides a set of executable code encapsulated in some form that is consumable by the browser. Some examples of this are Java applets, Flash animations running ActionScript, and client-side widgets running JavaScript.</p><p>Using code-on-demand can improve the flexibility of a REST application, but it also reduces <span class="emphasis"><em>visibility</em></span> by encapsulating some functionality. This is why code-on-demand is an optional constraint for REST:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_04_06.jpg" alt="Code-on-demand"/></div><p>
</p><p>This diagram depicts the final REST architectural style. This combines all previously described constraints, which are required for REST, with the optional constraint of code-on-demand.</p></div></div></div></div>
<div class="section" title="Benefits of REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Benefits of REST</h1></div></div></div><p>The REST constraints were designed with separation of concerns and forward-compatibility in mind, and this design allows for the individual components of REST to evolve without compromising the underlying architectural style itself.</p><p>By enforcing the constraints of REST, some particular architectural properties are exposed that reveal the beneficial nature of this architectural style. Let's explore some specific benefits of REST more closely.</p><div class="section" title="Performance"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Performance</h2></div></div></div><p>Performance is a major benefit of REST, and it is exposed by using cache, simple representations such as JSON, a layered system with multiple servers and load balancing, and the decoupling of components through a uniform interface.</p></div><div class="section" title="Simplicity"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Simplicity</h2></div></div></div><p>Simplicity is another key benefit of REST, and it is primarily exposed by the uniform resource constraint in which individual components of the system are decoupled. Simplicity is also seen in the server component, which needs only to support HTTP requests, and does not have to support state for any request.</p></div><div class="section" title="Separation of concerns"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Separation of concerns</h2></div></div></div><p>Separation of concerns lends to the simplicity of REST, but is also a benefit itself. This is seen in the separate server-client relationship, the burden of caching being put on the frontend, and the use of a layered system. Separation of concerns is a common pattern seen not only in architecture but in software design as well, such as the MVW architectural patterns discussed in <span class="emphasis"><em>
<a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>
</em></span>,<span class="emphasis"><em> Model-View-Whatever</em></span>.</p></div><div class="section" title="Scalability"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Scalability</h2></div></div></div><p>The architectural property of scalability is exposed in REST through the simplicity of the client-server relationship and the separation of concerns properties. By combining these key attributes, the system becomes more scalable because the complexity of relationships between the components is reduced by having specific guidelines around how they should work together.</p></div><div class="section" title="Portability"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Portability</h2></div></div></div><p>Portability is a benefit of REST that is exposed through the client-server separation of concerns. This allows the user interface layer of the application to be <span class="emphasis"><em>portable</em></span> because it is agnostic of the underlying server software being used to host the REST endpoints.</p><p>Portability is also exposed through code-on-demand, giving REST the ability to transport application code from server to client.</p></div><div class="section" title="Visibility"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Visibility</h2></div></div></div><p>Visibility simply refers to the ability to understand what is happening in a system based on the components' interactions with each other. With REST, high visibility is a benefit because of the decoupled nature of components and the fact that they need little to no knowledge of each other. This allows interactions made within the architecture to be easily understood, such as requests for endpoints. To determine the full nature of a request, one need not look beyond the representation of that request itself.</p><p>The code-on-demand constraint of REST is one that actually reduces visibility, but for this reason, it is optional. In following, code-on-demand is not often used by modern-day web applications, aside from simple JavaScript widgets that are found on web pages and used for advertising, social networks, and other third-party interactions.</p></div><div class="section" title="Reliability"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Reliability</h2></div></div></div><p>Reliability is a benefit of REST that is exposed primarily through the stateless server constraint. With a stateless server, a failure in the application can be analyzed at the system level because you know that the origin of that failure is from a single, decoupled component of the system.</p><p>For example, if you receive an error message in the UI for a web application that indicates to the user that information was entered incorrectly, then this failure can be handled at the UI level. If, on the other hand, you receive a HTTP 400 response code error from the server after entering the correct information, you can further deduce that the REST server endpoint is not configured correctly.</p></div></div>
<div class="section" title="RESTful web services"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>RESTful web services</h1></div></div></div><p>As mentioned earlier, the REST architectural style is often used to perform , <span class="strong"><strong>Read</strong></span>, <span class="strong"><strong>Update</strong></span> and <span class="strong"><strong>Delete</strong></span> (<span class="strong"><strong>Create</strong></span>,<span class="strong"><strong> Read</strong></span>,<span class="strong"><strong> Update</strong></span>,<span class="strong"><strong> and Delete </strong></span>(<span class="strong"><strong>CURD</strong></span>)) operations in modern web single page applications, and these operations are known as web services. To employ RESTful web services for your own application, you will need not only a HTTP server, but a hosted database or database server in order to perform CRUD operations on the data.</p><div class="section" title="Setting up a simple database with MongoDB"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Setting up a simple database with MongoDB</h2></div></div></div><p>MongoDB is the database used for the MEAN stack. It is an open source, document-oriented database system and can easily be added to your stack via download or package manager, depending upon the operating system you are using.</p><div class="section" title="Installing MongoDB"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec56"/>Installing MongoDB</h3></div></div></div><p>MongoDB can be installed on systems running Linux, Windows, and OS X. Direct downloads are available for these operating systems and, additionally, MongoDB can be installed using Homebrew on OS X. Homebrew is a popular CLI package manager for OS X. For instructions on installing Homebrew, visit brew.sh.</p><p>If you are running OS X and have Homebrew installed, you can use the following instructions to install MongoDB using a CLI. For installation on other systems, you can find instructions on MongoDB's documentation site at <a class="ulink" href="http://docs.mongodb.com/manual/installation/">docs.mongodb.com/manual/installation/</a>.</p><div class="section" title="Installing MongoDB on Mac using Homebrew"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec21"/>Installing MongoDB on Mac using Homebrew</h4></div></div></div><p>Start by updating Homebrew to the latest version before using it:</p><pre class="programlisting">
<span class="strong"><strong>$ brew update</strong></span>
</pre><p>Next, install the <code class="literal">mongodb</code> package:</p><pre class="programlisting">
<span class="strong"><strong>$ brew install mongodb</strong></span>
</pre><p>Once MongoDB is installed, you will want to add it to your command-line <code class="literal">PATH</code> for convenience. To do so, add the following to your user directory <code class="literal">.profile</code>, <code class="literal">.bash_profile</code>, or <code class="literal">.bashrc</code> file if you have one of them already. If you don't have any of these files, then create <code class="literal">.profile</code>:</p><pre class="programlisting">export PATH=/usr/local/opt/mongodb/bin:$PATH &#13;
</pre><p>Once you have added MongoDB to your <code class="literal">PATH</code>, you will need to create a directory for storing your data before you can run it. The default data directory for MongoDB is <code class="literal">/data/db</code>. You will most likely have to run this command as the superuser.</p></div><div class="section" title="Creating a MongoDB data directory"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec22"/>Creating a MongoDB data directory</h4></div></div></div><p>First, go to the CLI and create a database directory using <code class="literal">sudo</code>:</p><pre class="programlisting">
<span class="strong"><strong>$ sudo mkdir -p /data/db</strong></span>
</pre><p>Next, you will need to set the permissions on the directory to give you read and write access:</p><pre class="programlisting">
<span class="strong"><strong>$ sudo chown -R $(whoami):admin /data/db</strong></span>
</pre></div><div class="section" title="Running MongoDB"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec23"/>Running MongoDB</h4></div></div></div><p>Now you should be all set and you can go ahead and run MongoDB using the mongod command on the CLI:</p><pre class="programlisting">
<span class="strong"><strong>$ mongod</strong></span>
</pre><p>If everything is set up properly, you should see several lines of output with the last line showing something similar to the following line:</p><pre class="programlisting">
<span class="strong"><strong>I NETWORK  [initandlisten] waiting for connections on port 27017</strong></span>
</pre><p>Port 27017 is the default port for MongoDB but it can be changed, if necessary, using the <code class="literal">--port</code> option on the CLI:</p><pre class="programlisting">
<span class="strong"><strong>$ mongod --port 27018</strong></span>
</pre><p>To stop MongoDB from running at any time, press <span class="emphasis"><em>Ctrl</em></span> +<span class="emphasis"><em> C</em></span> at the command prompt where it is running.</p></div></div><div class="section" title="Creating a collection with MongoDB"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec57"/>Creating a collection with MongoDB</h3></div></div></div><p>A collection in MongoDB is analogous to a table in a traditional relational database. Let's set up a test database and collection using the <code class="literal">user.json</code> document we have been working with in our example application. From the root directory of the application, run the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ mongoimport --db test --collection users --file user.json</strong></span>
</pre><p>This command will create a database named test and a collection named users, then it will import the data from the user.json file to the users collection. You should see two lines of output after running this command:</p><pre class="programlisting">
<span class="strong"><strong>connected to: localhost</strong></span>
<span class="strong"><strong>imported 1 document</strong></span>
</pre><p>This output indicates that the <code class="literal">user.json</code> document was imported to the MongoDB instance running on localhost.</p></div><div class="section" title="Installing the Node.js MongoDB driver"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec58"/>Installing the Node.js MongoDB driver</h3></div></div></div><p>MongoDB provides drivers for several programming languages. We will be using the Node.js driver. The Node.js driver for MongoDB can be installed using NPM. Go to the root directory of the application and install it there and save to your local <code class="literal">package.json</code>:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install mongodb --save</strong></span>
</pre><p>Now you can start using MongoDB within your Node.js application. First, let's add some additional lines to the <code class="literal">server.js</code> file we created earlier:</p><pre class="programlisting">var mongo = require('mongodb').MongoClient; &#13;
var assert = require('assert'); &#13;
var url = 'mongodb://localhost:27017/test'; &#13;
 &#13;
mongo.connect(url, function(err, db) { &#13;
    assert.equal(null, err); &#13;
    console.log('Connected to MongoDB.'); &#13;
    db.close(); &#13;
}); &#13;
</pre><p>This will set up a connection to your local MongoDB test database and output a message to the console if it is successful.</p><p>If you added these lines to the additional code we wrote to <code class="literal">server.js</code> in <a class="link" href="ch03.html" title="Chapter 3. SPA Essentials – Creating the Ideal Application Environment"><span class="emphasis"><em>Chapter 3</em></span></a>,<span class="emphasis"><em>SPA Essentials - Creating the Ideal Application Environment</em></span>, the entire content of the file should look like the following code:</p><pre class="programlisting">var express = require('express'); &#13;
var app = express(); &#13;
var mongo = require('mongodb').MongoClient; &#13;
var assert = require('assert'); &#13;
var url = 'mongodb://localhost:27017/test'; &#13;
 &#13;
mongo.connect(url, function(err, db) { &#13;
    assert.equal(null, err); &#13;
    console.log('Connected to MongoDB.'); &#13;
    db.close(); &#13;
}); &#13;
 &#13;
app.use('/', express.static('./')); &#13;
 &#13;
app.get('*', function(request, response) { &#13;
    response.sendFile('/index.html', {root: __dirname}); &#13;
}); &#13;
 &#13;
app.listen(8080, function() { &#13;
    console.log('App now listening on port 8080'); &#13;
}); &#13;
</pre><p>The assert module we added provides a simple set of assertion tests that can be used for testing invariants, or values that cannot change. Now let's save the file and run the server again:</p><pre class="programlisting">
<span class="strong"><strong>$ node server.js</strong></span>
</pre><p>If everything is working properly and your Node.js server is connected to the database, you should see the following output:</p><pre class="programlisting">
<span class="strong"><strong>App now listening on port 8080</strong></span>
<span class="strong"><strong>Connected to MongoDB.</strong></span>
</pre><p>This indicates that your Node.js server is running and connected to MongoDB. If the MongoDB connection is not successful, an error will be thrown in the console.</p><p>Now that we've got a Node.js server running with a connection to the test database in MongoDB, we can begin writing some REST API endpoints.</p></div></div></div>
<div class="section" title="Writing basic REST API endpoints"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Writing basic REST API endpoints</h1></div></div></div><p>The most common type of RESTful request on the Web is a HTTP <code class="literal">GET</code> or <code class="literal">Read</code> operation. An example of this is a simple request to view a web page through a URL. GET requests can be performed to read any kind of data and do not need to be supported by a database, but in order to implement the Create, Update, and Delete operations on data, some type of database or data store must be used, along with a REST <span class="strong"><strong>Application Programming Interface </strong></span>(<span class="strong"><strong>API</strong></span>).</p><div class="section" title="CRUD with REST"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>CRUD with REST</h2></div></div></div><p>Performing full CRUD operations with your web application can be done using the simple NPM, Bower, and Grunt application you have been working with thus far; we just need to write some API endpoints now to make this possible. Let's go back to our application CLI to make some changes.</p><div class="section" title="Handling request data with Node.js and Express"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec59"/>Handling request data with Node.js and Express</h3></div></div></div><p>Before we can handle any API request data sent to our server, we have to add the ability to parse that data. In most cases, this will be data that is sent from a web page through a form or some other means. This type of data is referred to as the <span class="strong"><strong>body</strong></span> of the request, and in order to parse it we will need to add another Node.js package:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install body-parser --save</strong></span>
</pre><p>This will add the Node.js <code class="literal">body-parser</code> package to our application dependencies. Now let's go back to editing <code class="literal">server.js</code> and add some additional code:</p><pre class="programlisting">var bodyParser = require('body-parser'); &#13;
 &#13;
app.use(bodyParser.json()); &#13;
 &#13;
</pre><p>Add the bodyParser variable declaration below the other variable declarations at the top of the file, and then call <code class="literal">app.use(bodyParser.json())</code> just below it and above all route definitions. This will now allow us to handle and parse any JSON data sent as the body of any request to the server.</p></div><div class="section" title="Creating with a POST request"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec60"/>Creating with a POST request</h3></div></div></div><p>Express follows REST vernacular by providing method names for routes that match their respective HTTP request type. In REST, a HTTP POST request is the standard method used for a Create operation. The respective Express method for this is <code class="literal">.post()</code>. Let's set up a simple POST request with Express that will allow us to add additional records to our users collection in MongoDB.</p><p>First, let's remove the MongoDB connection test code in <code class="literal">server.js</code> and replace it with the following:</p><pre class="programlisting">app.post('/api/users', function(request, response) { &#13;
    console.dir(request.body); &#13;
    mongo.connect(url, function(err, db) { &#13;
        db.collection('users') &#13;
        .insertOne(request.body, function(err, result) { &#13;
            if (err) { &#13;
                throw err; &#13;
            } &#13;
            console.log('Document inserted successfully.'); &#13;
            response.json(result); &#13;
            db.close(); &#13;
        }); &#13;
    }); &#13;
}); &#13;
</pre><p>Make sure this code is <span class="emphasis"><em>above</em></span> the<code class="literal"> app.use('/', ...)</code> and <code class="literal">app.get('*', ...)</code> definitions we created in <a class="link" href="ch03.html" title="Chapter 3. SPA Essentials – Creating the Ideal Application Environment"><span class="emphasis"><em>Chapter 3</em></span></a>,<span class="emphasis"><em> SPA Essentials - Creating the Ideal Application Environment</em></span>.</p><p>The entire content of <code class="literal">server.js</code> should now look like the following code:</p><pre class="programlisting">var express = require('express'); &#13;
var app = express(); &#13;
var mongo = require('mongodb').MongoClient; &#13;
var assert = require('assert'); &#13;
var url = 'mongodb://localhost:27017/test'; &#13;
var bodyParser = require('body-parser'); &#13;
 &#13;
app.use(bodyParser.json()); &#13;
 &#13;
app.post('/api/users', function(request, response) { &#13;
    console.dir(request.body); &#13;
    mongo.connect(url, function(err, db) { &#13;
        db.collection('users') &#13;
        .insertOne(request.body, function(err, result) { &#13;
            if (err) { &#13;
                throw err; &#13;
            } &#13;
            console.log('Document inserted successfully.'); &#13;
            response.json(result); &#13;
            db.close(); &#13;
        }); &#13;
    }); &#13;
}); &#13;
 &#13;
app.use('/', express.static('./')); &#13;
 &#13;
app.get('*', function(request, response) { &#13;
    response.sendFile('/index.html', {root: __dirname}); &#13;
}); &#13;
 &#13;
app.listen(8080, function() { &#13;
    console.log('App now listening on port 8080'); &#13;
}); &#13;
</pre><p>The .post() request endpoint or handler we added will first log the <code class="literal">request.body</code> object, which has been parsed and converted from JSON, to the server console on the command line. It will then connect to MongoDB and call the MongoDB <code class="literal">insertOne()</code> method to insert the <code class="literal">request.body</code> document into the users collection in our database.</p><p>There are many libraries available that can handle this type of interaction and database inserts from a request much more gracefully, but it is important to understand how the Express server is interacting with MongoDB, so for that reason, we are using the native MongoDB API to perform these operations.</p><div class="section" title="Testing the POST request on the frontend"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec24"/>Testing the POST request on the frontend</h4></div></div></div><p>Now that we have a POST handler set up in our server, let's test that it works by sending a request from the frontend. Inserting information is commonly done from user entry in a form, so let's edit the application layout index.html file and add one:</p><pre class="programlisting">&lt;h2&gt;POST Request&lt;/h2&gt; &#13;
&lt;form data-url="/api/users" data-method="post"&gt; &#13;
    &lt;p&gt; &#13;
        &lt;label&gt; &#13;
            First name:  &#13;
            &lt;input type="text" name="first_name"&gt; &#13;
        &lt;/label&gt; &#13;
    &lt;/p&gt; &#13;
    &lt;p&gt; &#13;
        &lt;label&gt; &#13;
            Last name:  &#13;
            &lt;input type="text" name="last_name"&gt; &#13;
        &lt;/label&gt; &#13;
    &lt;/p&gt; &#13;
    &lt;p&gt; &#13;
        &lt;label&gt; &#13;
            Title:  &#13;
            &lt;input type="text" name="title"&gt; &#13;
        &lt;/label&gt; &#13;
    &lt;/p&gt; &#13;
    &lt;p&gt; &#13;
        &lt;label&gt; &#13;
            Website:  &#13;
            &lt;input type="text" name="website"&gt; &#13;
        &lt;/label&gt; &#13;
    &lt;/p&gt; &#13;
    &lt;p&gt; &#13;
        &lt;button type="submit"&gt;Submit&lt;/button&gt; &#13;
    &lt;/p&gt; &#13;
&lt;/form&gt; &#13;
</pre><p>Add this HTML code just under the opening <code class="literal">&lt;body&gt;</code> tag in the page. We will again use the <code class="literal">Payload.js</code> API for making a request to the server; this time, a simple POST request. Notice that the <code class="literal">data-url</code> attribute of the <code class="literal">&lt;form&gt;</code> tag is set to the API endpoint URL, and the <code class="literal">data-method</code> attribute is set to <span class="emphasis"><em>post</em></span>. When the form is submitted, this will take the form data and convert it to JSON and send it as the request body to the server via a POST request.</p><p>Now run the app from the CLI and go to <code class="literal">localhost:8080</code> in your browser. You should see the form there. Add some sample data to the form inputs:</p><pre class="programlisting">First name: Peebo&#13;
Last name: Sanderson&#13;
Title: Vagrant&#13;
Website: http://salvationarmy.org</pre><p>Now click to submit the form just once. If all goes well, you should see something like the following displayed in your console:</p><pre class="programlisting">
<span class="strong"><strong>App now listening on port 8080</strong></span>
<span class="strong"><strong>{ first_name: 'Peebo',</strong></span>
<span class="strong"><strong>  last_name: 'Sanderson',</strong></span>
<span class="strong"><strong>  title: 'Vagrant',</strong></span>
<span class="strong"><strong>  website: 'http://salvationarmy.org' }</strong></span>
<span class="strong"><strong>Document inserted successfully.</strong></span>
</pre><p>The JSON document created from the form should now be inserted into the users collection in the MongoDB test database. This means there are now two documents in the collection - the document we inserted originally from the user.json file, and the one we just added from the form POST.</p><p>Now that we've got a couple of records in our database, we need a way to retrieve those documents and display them in the browser. We can do this by first creating an endpoint to read data from the database.</p></div></div><div class="section" title="Reading with a GET request"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec61"/>Reading with a GET request</h3></div></div></div><p>A HTTP <code class="literal">GET</code> request is the standard method used for a Read operation in REST. The respective Express method for this is <code class="literal">.get()</code>. We previously set up a GET request in <span class="emphasis"><em>Chapter 3</em></span> to load our layout page, but this time we want to write a REST API request that will return the user records from MongoDB in JSON format.</p><p>First, hit <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> on the command line to stop the server, then open up <code class="literal">server.js</code> again for editing. Just below the <code class="literal">.post()</code> endpoint we wrote, add the following code:</p><pre class="programlisting">app.get('/api/users', function(req, res) { &#13;
    mongo.connect(url, function(err, db) { &#13;
        db.collection('users').find() &#13;
            .toArray(function(err, result) { &#13;
            if (err) { &#13;
                throw err; &#13;
            } &#13;
            console.log(result.length + ' documents retrieved.'); &#13;
            res.json(result); &#13;
            db.close(); &#13;
        }); &#13;
    }); &#13;
}); &#13;
</pre><p>You will notice that this handler is requested through the same URL as the<code class="literal"> .post()</code> handler, but it will be handled differently because of the HTTP request method being a GET instead of a POST.</p><p>First, the request will connect to the test database and then call the MongoDB .find() method on the users collection, which will return a cursor. A cursor in MongoDB is a pointer to the results of a database query. As we mentioned in <span class="emphasis"><em>
<a class="link" href="ch03.html" title="Chapter 3. SPA Essentials – Creating the Ideal Application Environment">Chapter 3</a>
</em></span>, <span class="emphasis"><em>SPA Essentials - Creating the Ideal Application Environment</em></span>, MongoDB uses the BSON data format internally, so in order to format the cursor for use in our application, we have to convert the BSON data to a format that is consumable over HTTP. For this purpose, we chain the <code class="literal">.toArray()</code> method to the <code class="literal">.find()</code> operation, which will convert the result set to an array of documents. We can also access the length property of the resulting array and log the number of documents retrieved to the server console.</p><p>Next, we pass an anonymous callback function to the <code class="literal">.toArray()</code> method and return the resulting data as a JSON response.</p><div class="section" title="Testing the GET request on the frontend"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec25"/>Testing the GET request on the frontend</h4></div></div></div><p>Now let's set up some HTML to test our GET request on the frontend. Edit the application layout index.html page and edit the HTML we added to retrieve and display data from the <code class="literal">user.json</code> file in <span class="emphasis"><em>
<a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>, Model-View-Whatever</em></span>. This should be right underneath the form we just added for the POST request:</p><pre class="programlisting">&lt;h2&gt;GET Request&lt;/h2&gt; &#13;
&lt;p&gt; &#13;
    &lt;a href="#" &#13;
       data-url="/api/users" &#13;
       data-template="users" &#13;
       data-selector=".results"&gt;Load user data&lt;/a&gt; &#13;
&lt;/p&gt; &#13;
&lt;div class="results"&gt;&lt;/div&gt; &#13;
</pre><p>We have now changed the URL for the GET request from <code class="literal">/user.json</code> to<code class="literal"> /api/users</code>. Payload.js will handle an API request as a GET by default, so there is no need to add the d<code class="literal">ata-method="get"</code> attribute to this URL, other than to provide more transparency. Additionally, the empty .results &lt;div&gt; is indicated as where we want to display our resulting data.</p><p>We also have changed the <code class="literal">data-template</code> attribute value here from user (singular) to users (plural). This indicates that we want to load a Handlebars template named users. Create a new file in the root of your app directory called <code class="literal">users.handlebars</code> and add the following code to it:</p><pre class="programlisting">{{#each data}} &#13;
    &lt;p&gt;{{first_name}} {{last_name}}&lt;/p&gt; &#13;
{{/each}} &#13;
</pre><p>Now we need to recompile the Handlebars templates and save them to the <code class="literal">templates.js</code> file:</p><pre class="programlisting">
<span class="strong"><strong>$ handlebars *.handlebars -f templates.js</strong></span>
</pre><p>Run this from the command line and you will be just about ready to load the MongoDB data into the template. First, run the server again, and then go to or refresh <code class="literal">localhost:8080</code> in your browser. Click the Load user data link and you should see only one name show up below it: the <code class="literal">first_name</code> and <code class="literal">last_name</code> fields from the document you just inserted into the database. If you check the console, you should see output like the following:</p><pre class="programlisting">
<span class="strong"><strong>App now listening on port 8080</strong></span>
<span class="strong"><strong>2 documents retrieved.</strong></span>
</pre><p>So two documents were actually retrieved from the database, but only one name is displayed in the browser. Why is this? The reason is quite simple, but easy to overlook. The data from the document we first inserted from <code class="literal">user.json</code> looks like the following:</p><pre class="programlisting">{ &#13;
    "id": 1, &#13;
    "name": { &#13;
        "first": "Philip", &#13;
        "last": "Klauzinski" &#13;
    }, &#13;
    "title": "Sr. UI Engineer", &#13;
    "website": "http://webtopian.com" &#13;
} &#13;
</pre><p>The new document we added from the form <code class="literal">POST</code> request, however, looks like this:</p><pre class="programlisting">{ &#13;
    "first_name": "Peebo", &#13;
    "last_name": "Sanderson", &#13;
    "title": "Vagrant", &#13;
    "website": "http://salvationarmy.org" &#13;
} &#13;
</pre><p>As you can see, the document we created from the form does not have a name object with the first and last properties nested in it like the <code class="literal">user.json</code> document, but instead has the explicit <code class="literal">first_name</code> and <code class="literal">last_name</code> properties, and those are the properties that we are looking to display in the Handlebars template.</p><p>This is the reason why the HTML view only displays one name, but how did we overlook this? The reason for this is attributed to the fact that MongoDB is a document-oriented database with no strict data typing, like a relational database. As we discussed in <span class="emphasis"><em>
<a class="link" href="ch03.html" title="Chapter 3. SPA Essentials – Creating the Ideal Application Environment">Chapter 3</a>
</em></span>, <span class="emphasis"><em>SPA Essentials – Creating the Ideal Application Environment</em></span>, this is one of the things that makes NoSQL document-oriented databases completely different than traditional SQL databases.</p><p>So when we inserted the new data into our collection from the form POST, MongoDB did nothing to check that the format of the new document matched the format of the existing document. Self-defined document structure is a powerful feature of a document-oriented database, but it can also lead to application errors and missing data for the UI when the document collections are not normalized.</p><p>Now let's write an Update endpoint to change one of our existing documents and have it match the other.</p></div></div><div class="section" title="Updating with a PUT request"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec62"/>Updating with a PUT request</h3></div></div></div><p>In REST, a HTTP <code class="literal">PUT </code>request is the standard method used for an Update operation. The respective Express method for this is .put().</p><p>Now hit <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>C </em></span>to stop the Node.js server, then open up the server.js file again and add the following code below the <code class="literal">.get()</code> handler:</p><pre class="programlisting">app.put('/api/users', function(req, res) { &#13;
    mongo.connect(url, function(err, db) { &#13;
        db.collection('users').updateOne( &#13;
            { "id": 1 }, &#13;
            req.body, &#13;
            function(err, result) { &#13;
                if (err) { &#13;
                    throw err; &#13;
                } &#13;
                console.log(result); &#13;
                res.json(result); &#13;
                db.close(); &#13;
            } &#13;
        ); &#13;
    }); &#13;
}); &#13;
</pre><p>We are again using the same endpoint URL, but this will only handle a <code class="literal">PUT</code> request made from the frontend. This method will first connect to our test database, and then it will call the MongoDB <code class="literal">.udpateOne()</code> method to update an existing document. The first argument passed to this method is a filter, or data to look for and find a match. The <code class="literal">.updateOne()</code> method will only look for the first document that matches a filter and then end the query.</p><p>Notice that the filter passed to the method here is <code class="literal">{ "id": 1 }</code>. This is the <code class="literal">id</code> field that was passed in from the <code class="literal">user.json</code> file. Remember that MongoDB actually creates its own internal id for every document if one is not supplied, and this field is called <code class="literal">_id</code>. So in the case of our original user object we supplied, it will have an <code class="literal">_id</code> field set to a BSON <code class="literal">ObjectId</code> and the original <span class="emphasis"><em>id</em></span> field we supplied set to 1. Since we know that the new document we created from the form POST does not have the extraneous <span class="emphasis"><em>id</em></span> field, we can safely filter on that field to find the original document and update it.</p><p>The second parameter we are passing to the <code class="literal">.updateOne()</code> method is the entire request body, which will be an object produced from a form submission. Typically, with a PUT request, the intention is to update existing fields with new values, but in this case we actually want to change the structure of the document to match the structure of the new record we created using the form POST.</p><p>The third parameter passed to the <code class="literal">.updateOne()</code> method is an anonymous callback function to which the result of the update request is passed. Here, we log that result to the console and return it as JSON to the frontend.</p><div class="section" title="Testing the PUT request on the frontend"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec26"/>Testing the PUT request on the frontend</h4></div></div></div><p>Now let's go back to the application layout index.html file and add some more HTML just below the GET request HTML we added previously. To do this, copy the HTML from the <code class="literal">POST</code> request form and change it to look like the following:</p><pre class="programlisting">&lt;h2&gt;PUT Request&lt;/h2&gt; &#13;
&lt;form data-url="/api/users" data-method="put"&gt; &#13;
    &lt;p&gt; &#13;
        &lt;label&gt; &#13;
            First name: &#13;
            &lt;input type="text" name="first_name"&gt; &#13;
        &lt;/label&gt; &#13;
    &lt;/p&gt; &#13;
    &lt;p&gt; &#13;
        &lt;label&gt; &#13;
            Last name:  &#13;
            &lt;input type="text" name="last_name"&gt; &#13;
        &lt;/label&gt; &#13;
    &lt;/p&gt; &#13;
    &lt;p&gt; &#13;
        &lt;label&gt; &#13;
            Title:  &#13;
            &lt;input type="text" name="title"&gt; &#13;
        &lt;/label&gt; &#13;
    &lt;/p&gt; &#13;
    &lt;p&gt; &#13;
        &lt;label&gt; &#13;
            Website:  &#13;
            &lt;input type="text" name="website"&gt; &#13;
        &lt;/label&gt; &#13;
    &lt;/p&gt; &#13;
    &lt;p&gt; &#13;
        &lt;button type="submit"&gt;Submit&lt;/button&gt; &#13;
    &lt;/p&gt; &#13;
&lt;/form&gt; &#13;
 &#13;
</pre><p>This code matches the POST request HTML save for a few minor changes. We have edited the <code class="literal">&lt;h2&gt;</code> title to show that this is the PUT request form, and the <code class="literal">data-method</code> attribute on the form is now set to <code class="literal">put</code>. Leave all form inputs as they are because we will want the updated document to match the new document we created.</p><p>Now start the server again from the command line and then go to or refresh localhost:8080 in your browser. You should see the new <code class="literal">PUT</code> Request form we added below the <code class="literal">POST</code> request and <code class="literal">GET</code> request areas on the page. Now enter the data from the original <code class="literal">user.json</code> object into the corresponding form fields:</p><pre class="programlisting">First name: Philip&#13;
Last name: Klauzinski&#13;
Title: Sr. UI Engineer&#13;
Website: http://webtopian.com</pre><p>Now click the submit button once and check your console output. You should see a lot of information printed to the console. At the very top of it, you should see the following:</p><pre class="programlisting">
<span class="strong"><strong>{ result: { ok: 1, nModified: 1, n: 1 }</strong></span>
</pre><p>This result indicates that one record was modified. If the update was successful, the original <code class="literal">user.json</code> document should now match the format of the second one we added from the form POST. To test this, click on the Load user data link to GET the user documents and list the names using the Handlebars template and the <code class="literal">first_name</code> and <code class="literal">last_name</code> properties. You should now see each of the two names listed in the browser:</p><pre class="programlisting">Philip Klauzinski&#13;
Peebo Sanderson</pre><p>To complete our RESTful API endpoints in server.js, let's add a final <code class="literal">Delete</code> handler and use it to remove one of the two user records.</p></div></div><div class="section" title="Deleting with a DELETE request"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec63"/>Deleting with a DELETE request</h3></div></div></div><p>A HTTP <code class="literal">DELETE</code> request is the standard method used for the homonymous Delete operation in REST. Naturally, the respective Express method for this is <code class="literal">.delete()</code>.</p><p>Hit <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> on the command to stop the server and then open <span class="emphasis"><em>server.js</em></span> again for editing. Add the following code just below the <code class="literal">.put()</code> handler:</p><pre class="programlisting">app.delete('/api/users', function(req, res) { &#13;
    mongo.connect(url, function(err, db) { &#13;
        db.collection('users').deleteOne( &#13;
            { "first_name": "Peebo" }, &#13;
            function(err, result) { &#13;
            if (err) { &#13;
                throw err; &#13;
            } &#13;
            console.log(result); &#13;
            res.json(result); &#13;
            db.close(); &#13;
        }); &#13;
    }); &#13;
}); &#13;
 &#13;
</pre><p>This handler will first connect to the database, then it will call the MongoDB <code class="literal">.deleteOne()</code> method on the users collection. The first parameter passed to the <code class="literal">.deleteOne()</code> method is a condition to match against a record to delete. In this case, we want to delete the new record we created earlier from the form POST, so we are using the unique <code class="literal">first_name</code> value of <code class="literal">Peebo</code> for this.</p><p>The second parameter passed to the <code class="literal">.deleteOne()</code> method is an anonymous callback function which is passed the result of the delete request. We are again going to log that result to the console and return it to the frontend as JSON.</p><div class="section" title="Testing the DELETE request on the frontend"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec27"/>Testing the DELETE request on the frontend</h4></div></div></div><p>Open the application layout index.html file again and add the following code below the <code class="literal">PUT</code> request form we added previously:</p><pre class="programlisting">&lt;h2&gt;DELETE Request&lt;/h2&gt; &#13;
&lt;button data-url="/api/users"  &#13;
        data-method="delete"  &#13;
        data-template="user"  &#13;
        data-selector=".delete-response"&gt;Delete Peebo&lt;/button&gt; &#13;
&lt;div class="delete-response"&gt;&lt;/div&gt; &#13;
</pre><p>Here we have added a simple button with the Payload.js attributes necessary to send a HTTP <code class="literal">DELETE</code> request.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip5"/>Tip</h3><p>It should be noted that no request body, such as form data, can be sent with a <code class="literal">DELETE</code> request.</p></div></div><p>Start up the Node.js server again and then go to or reload index.html in your browser. You should see the <span class="strong"><strong>Delete Peebo</strong></span> button at the bottom of the page. Click the button just once and then check the console output. You will see a lot of information from the result. At the very top of the output, you should see the following:</p><pre class="programlisting">
<span class="strong"><strong>{ result: { ok: 1, n: 1 }</strong></span>
</pre><p>The n: 1 property shown here indicates that one record was successfully deleted. To verify this, go back to the browser and scroll up to the Load user data link under the <span class="strong"><strong>GET Request</strong></span> title. Click that link, and you should now see only the original <code class="literal">user.json</code> document <code class="literal">first_name</code> and <code class="literal">last_name</code> shown. The console will also indicate that only a single result was found in the users collection:</p><pre class="programlisting">
<span class="strong"><strong>1 documents retrieved.</strong></span>
</pre><p>Congratulations, you now have a full RESTful set of endpoints written to perform CRUD operations with Express and MongoDB. Although quite primitive, these example methods should give you a foundation for learning more and building upon them to create a more robust single page application. They should also give you a better understanding of the REST architectural style, and how Node.js interacts with MongoDB.</p></div></div></div></div>
<div class="section" title="Alternatives to REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Alternatives to REST</h1></div></div></div><p>REST is arguably the most widely used architectural style across the Web and the IoT, but there are many other technologies, protocols, and architectural styles available to use for web services and single page web application data exchange.</p><div class="section" title="TCP versus UDP"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>TCP versus UDP</h2></div></div></div><p>As mentioned earlier, TCP is the transport layer protocol upon which HTTP travels to the application layer. Some of the beneficial attributes of TCP connections are that they are reliable, serial, and checked for errors while sending information. These benefits, however, can sometimes lead to undesirable latency:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_007.jpg" alt="TCP versus UDP"/></div><p>
</p><p>The Internet Protocol Suite includes many other protocols alongside TCP. One of these protocols is <span class="strong"><strong>User Datagram Protocol </strong></span>(<span class="strong"><strong>UDP</strong></span>). UDP is also a core member of the <span class="emphasis"><em>transport layer</em></span> of TCP/IP. The primary difference between UDP and TCP is that UDP is <span class="emphasis"><em>connectionless</em></span>. This means that individual units of data are transmitted with self-identifying information and the receiving end of that information has no prior knowledge of when or how it will be received. UDP does nothing to ensure that a recipient endpoint is actually available to receive that information, and thus this risk must be taken into consideration when using UDP.</p><p>Since UDP uses no connection, it is inherently not <span class="emphasis"><em>reliable</em></span>, and that is what sets it apart from a connection-based protocol such as TCP. TCP allows for error checking and correction during a transmission because both parties are aware of each other due to their <span class="emphasis"><em>connection</em></span>.</p><p>Messages sent over UDP and other connectionless protocols are called <span class="emphasis"><em>datagrams</em></span>. UDP and datagrams should only be used when error checking and correction is not needed or is performed within the application layer itself. Checking errors at the application level is often the model that is used with UDP since error checking and correction is almost always a necessity with any application. Some examples of application types that use UDP are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Streaming media</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Voice over IP </strong></span>(<span class="strong"><strong>VoIP</strong></span>)</li><li class="listitem" style="list-style-type: disc">Massively multiplayer online games</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Domain Name System </strong></span>(<span class="strong"><strong>DNS</strong></span>)</li><li class="listitem" style="list-style-type: disc">Some <span class="strong"><strong>Virtual Private Network</strong></span> (<span class="strong"><strong>VPN</strong></span>) systems</li></ul></div><p>The most obvious disadvantages with UDP and a connectionless protocol are that there is no guarantee of message delivery, no error checking, and, consequently, no error correction. This can be a major disadvantage in an application where a user is interacting with the system on their own and most events are user generated. In a system where hundreds or thousands of users may be interacting with each other, however, a connectionless protocol allows the application to be free of latency due to error correction. A massively multiplayer online game is a good example of a system in which thousands or even millions of messages may need to be transported across a network consistently, but this cannot be done reliably while also maintaining connections with error checking and correction.</p></div><div class="section" title="SOAP"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>SOAP</h2></div></div></div><p>REST is often compared to <span class="strong"><strong>Simple Object Access Protocol </strong></span>(<span class="strong"><strong>SOAP</strong></span>), although SOAP is actually a protocol and not an architectural style like REST. The reason for the comparison is because both are used for web services, and in this context, REST is synonymous with HTTP, which is a protocol. Even though SOAP is a protocol, it also interacts with HTTP to transmit messages for implementing web services. It can also be used over SMTP.</p><p>The message format for SOAP is XML. An XML message sent with SOAP is referred to as an <span class="emphasis"><em>envelope</em></span>. The structure of a SOAP envelope follows a particular pattern involving elements including a mandatory <span class="emphasis"><em>body</em></span> element and an optional <span class="emphasis"><em>header</em></span> element. The body may also include nested <span class="emphasis"><em>fault</em></span> constructs which carry information regarding exceptions. An example of a SOAP message is shown as follows:</p><pre class="programlisting">&lt;env:Envelope &gt; &#13;
&lt;env:Header&gt; &#13;
    &lt;n:shipping &gt; &#13;
      This is a shipping message &#13;
    &lt;/n:shipping&gt; &#13;
  &lt;/env:Header&gt; &#13;
  &lt;env:Body&gt; &#13;
    &lt;env:Fault&gt; &#13;
      &lt;env:Code&gt; &#13;
        &lt;env:Value&gt; &#13;
          env:VersionMismatch &#13;
        &lt;/env:Value&gt; &#13;
      &lt;/env:Code&gt; &#13;
      &lt;env:Reason&gt; &#13;
        &lt;env:Text xml:lang="en"&gt; &#13;
          versions do not match &#13;
        &lt;/env:Text&gt; &#13;
      &lt;/env:Reason&gt; &#13;
    &lt;/env:Fault&gt; &#13;
  &lt;/env:Body&gt; &#13;
&lt;/env:Envelope&gt; &#13;
</pre><p>REST can also use XML for data exchange, but more commonly uses JSON in modern-day web applications.</p></div><div class="section" title="WebSockets"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>WebSockets</h2></div></div></div><p>WebSockets is a protocol that allows interactive communication between a web browser and a server. The term <span class="emphasis"><em>interactive</em></span> in this context means that the server can <span class="emphasis"><em>push </em></span>messages to the web browser without the browser needing to periodically <span class="emphasis"><em>poll </em></span>the server for new data, as might typically be done in a web application using HTTP, AJAX, and REST.</p><p>You may have heard of <span class="emphasis"><em>push</em></span> technology before. This paradigm is evident in many smartphone applications that push update notifications to a phone as soon as new data is available. This is also referred to as <span class="emphasis"><em>real-time data</em></span>. HTTP is limited in that it does not support open connections that can receive real-time data. Instead, HTTP requires that a request be made and a connection or <span class="emphasis"><em>socket </em></span>is opened, a response is received, information is downloaded, and the connection is then closed. Once new information becomes available, this will not be evident to the application needing that information without making periodic requests to the server, which is referred to as <span class="emphasis"><em>polling</em></span>.</p><p>In 2011, WebSockets became officially standardized and supported by modern web browsers. This protocol allows data to be transferred to and from a server by using an <span class="emphasis"><em>open</em></span> socket connection, allowing the client to request data at will but also allowing the server to <span class="emphasis"><em>push</em></span> data to the client in real time:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_008.jpg" alt="WebSockets"/></div><p>
</p><p>Web applications using REST are limited by the open/close connection constraint with HTTP. This makes sense for many web applications that do not need a server response without a user interaction, or that can implement periodic server polling without too much overhead required. Web applications that want to provide real-time data to the user without an action, however, may be better served by using WebSockets.</p></div><div class="section" title="MQTT"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>MQTT</h2></div></div></div><p>MQTT originally stood for <span class="strong"><strong>MQ Telemetry Transport</strong></span>. It is a messaging protocol designed to be used on top of TCP/IP, or the Internet Protocol Suite. MQTT employs a <span class="emphasis"><em>publish-subscribe</em></span>, or PubSub, messaging pattern in which events or messages are published by publishers and available to any number of subscribers. In following, subscribers receive messages from any number of publishers. In this paradigm, publishers are entirely agnostic of subscribers.</p><p>In contrast to SOAP and WebSockets, MQTT is not designed to be used for web services over HTTP, but instead is primarily use for <span class="strong"><strong>machine-to-machine </strong></span>(<span class="strong"><strong>M2M</strong></span>) communication. MQTT is often used for satellite communications, home or <span class="strong"><strong>smart home</strong></span> automation, and for mobile applications. MQTT is considered to be lightweight and have a small code footprint, making it ideal for mobile applications which may be using slower, wireless mobile network connections.</p><p>The "MQ" in MQTT was originally derived from IBM's <span class="strong"><strong>Message Queuing</strong></span> (<span class="strong"><strong>MQ</strong></span>) protocol. Message queuing is not actually a requirement for MQTT, however, which is why it is no longer a true acronym and is simply referred to as MQTT.</p><p>MQTT is an <span class="strong"><strong>Organization for the Advancement of Structured Information Standards </strong></span>(<span class="strong"><strong>OASIS</strong></span>) standard. OASIS is an organization that defines standards for the IoT and other areas of technology.</p><p>Any software that implements MQTT is referred to as an MQTT broker, which is a type of message broker architectural pattern that translates messages sent from an application to the proprietary format of the receiver, or the message broker itself:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_009.jpg" alt="MQTT"/></div><p>
</p><p>The purpose of the message broker is to take the messages received by an application and perform some type of action on them. For example, some actions might be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initiating web service requests</li><li class="listitem" style="list-style-type: disc">Forwarding messages to other destinations</li><li class="listitem" style="list-style-type: disc">Transforming messages to a different type of representation for consumption by anther application or endpoint</li><li class="listitem" style="list-style-type: disc">Storing messages to be used for publish-subscribe events and responses</li><li class="listitem" style="list-style-type: disc">Logging and/or responding to application errors</li></ul></div><p>There are many popular message broker applications and services that can be used for message exchange in single page applications. Some of these are Mosquitto, CloudMQTT, IBM MessageSight, and ActiveMQ.</p></div><div class="section" title="AMQP"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>AMQP</h2></div></div></div><p>
<span class="strong"><strong>Advanced Message Queuing Protocol</strong></span> (<span class="strong"><strong>AMQP</strong></span>) is similar to MQTT. It is an open standard application layer protocol for use with message brokers.</p><p>One of the most popular open source message brokers for modern-day web applications is RabbitMQ, which employs AMQP. In an AMQP architecture using something like RabbitMQ, messages are <span class="emphasis"><em>produced</em></span> by an application and then <span class="emphasis"><em>queued</em></span> or stored in the RabbitMQ server. A queue is also, in a sense, a <span class="emphasis"><em>buffer</em></span> because it can store any amount of information for any amount of time until it is needed:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_010.jpg" alt="AMQP"/></div><p>
</p><p>Although it uses AMQP, RabbitMQ also includes an adapter for MQTT. It additionally supports HTTP and <span class="strong"><strong>Streaming Text Oriented Messaging Protocol </strong></span>(<span class="strong"><strong>STOMP</strong></span>). The fact that RabbitMQ is open source and that it also includes adapters for other protocols, most notably HTTP, contributes greatly to its popularity today.</p></div><div class="section" title="CoAP"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>CoAP</h2></div></div></div><p>
<span class="strong"><strong>Constrained Application Protocol</strong></span> (<span class="strong"><strong>CoAP</strong></span>) is a web transfer protocol designed for M2M<span class="strong"><strong> </strong></span>communication. The machines primarily targeted for CoAP services are IoT devices.</p><p>CoAP is actually quite similar to HTTP and employs the REST architectural style as part of its specification. The difference with CoAP is that it strictly adheres to REST principles, while HTTP merely supports REST but does not require it.</p><p>Since CoAP uses the REST architectural style, it can actually be connected to over HTTP because, like with any RESTful architecture, the client is agnostic of the RESTful server it is accessing. In this scenario, a cross-protocol proxy is used to make the CoAP services available to a HTTP client:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_011.jpg" alt="CoAP"/></div><p>
</p></div><div class="section" title="DDP"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>DDP</h2></div></div></div><p>
<span class="strong"><strong>Distributed Data Protocol </strong></span>(<span class="strong"><strong>DDP</strong></span>) is not commonly used but gaining ground through the popular Meteor JavaScript framework. DDP is a simple protocol used for explicitly retrieving representations from a server, and also receiving updates regarding modifications on those representations in real time.</p><p>DDP allows Meteor applications to use WebSockets for services, providing a framework around those services to be connectionless. JSON data is used, but instead of being explicitly requested like it is with a RESTful architecture, the JSON data messages can be <span class="emphasis"><em>pushed</em></span> in real time to an application.</p><p>DDP was originally developed for Meteor by its founders; however, it is not specific to Meteor and can be used in other frameworks. Meteor's implementation of DDP is written entirely in JavaScript and is open source.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>You have now learned the fundamental aspects of the REST architectural style, the differences between an architectural style and a protocol, the relationship between REST and the HTTP protocol, and the constraints of REST. You have also learned to write some basic REST API endpoints using Express and MongoDB. A good understanding of REST and the server side of a single page application is paramount to becoming a skilled web SPA developer. In the next chapter, we will transition our focus to the frontend of SPA development, learn a few things about SPA UI frameworks and best practices, and take everything we have learned so far and apply it to the View layer.</p></div></body></html>