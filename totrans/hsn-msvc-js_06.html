<html><head></head><body>
		<div id="_idContainer073">
			<h1 class="chapter-number" id="_idParaDest-103"><a id="_idTextAnchor104"/>6</h1>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/>Synchronous Microservices</h1>
			<p>We implemented our first microservice in the previous chapter, but to demonstrate microservice communication, we need to run at least one more service. To understand the beauty of JavaScript in microservice development, we will use a different Node.js framework called NestJS for the <span class="No-Break">current chapter.</span></p>
			<p>As we discussed earlier, microservice architecture consists of multiple services, and one of the complexities that this approach brings with it is communication. We already know that microservices, while offering advantages in scalability and development, introduce a layer of complexity in communication compared to monolithic applications. Unlike monolithic applications, where everything runs together, microservices communicate over a network. This introduces challenges in <em class="italic">latency</em> (the time it takes for a request to be processed and a response to be received), <em class="italic">reliability</em> (since network issues can disrupt communication), and <em class="italic">security</em> (since you need to secure communication <span class="No-Break">between services).</span></p>
			<p>In this chapter, we will delve into details of synchronous communication between microservices in practice and learn the use cases of synchronous communication <span class="No-Break">between services.</span></p>
			<p>This chapter covers the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding the requirements for the <span class="No-Break">transaction microservice</span></li>
				<li>Tools to develop the <span class="No-Break">transaction microservice</span></li>
				<li>Hands-on transaction <span class="No-Break">microservice development</span></li>
				<li>Establishing synchronous communication with the <span class="No-Break">account microservice</span></li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>To develop and test the second microservice, we need <span class="No-Break">the following:</span></p>
			<ul>
				<li>IDE (we <a id="_idIndexMarker389"/>prefer <strong class="bold">Visual Studio Code</strong> (<span class="No-Break"><strong class="bold">VS Code</strong></span><span class="No-Break">))</span></li>
				<li><span class="No-Break">Postman</span></li>
				<li>Browser of <span class="No-Break">your choice</span></li>
			</ul>
			<p>It is recommended to download our repository from <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript</a> and open the <strong class="source-inline">Ch06</strong> folder to easily follow our <span class="No-Break">code snippets.</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Understanding the requirements for the transaction microservice</h1>
			<p>Everything starts from the requirements. Software requirements are basically instructions <a id="_idIndexMarker390"/>that tell programmers exactly what a software program needs to do. They’re like a recipe for the program, outlining the ingredients (features) and steps (functions) needed. Before starting our development, we need to understand <span class="No-Break">our requirements.</span></p>
			<p>The system consists of two <span class="No-Break">main microservices:</span></p>
			<ul>
				<li><strong class="bold">Transaction microservice</strong>: This microservice will be responsible for processing <a id="_idIndexMarker391"/>transactions. It will receive transaction information, validate the account associated with the transaction, and process <span class="No-Break">the transaction.</span></li>
				<li><strong class="bold">Account microservice</strong>: This <a id="_idIndexMarker392"/>microservice will provide account information and validation functionality. We implemented this service in <a href="B09148_05.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. It is responsible for verifying if an account exists and is in <span class="No-Break">good standing.</span></li>
			</ul>
			<p>The transaction microservice will communicate with the account microservice to validate the provided <strong class="source-inline">accountId</strong> value. The account microservice will verify if the <strong class="source-inline">accountId</strong> <span class="No-Break">value exists.</span></p>
			<p>The transaction should be successful only if the account exists and is in an <em class="italic">active</em> or a <em class="italic">new</em> state.  For other states, we should add a new row to the transaction service with the <span class="No-Break"><em class="italic">FAILED</em></span><span class="No-Break"> state:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer056">
					<img alt="Figure 6.1: Communication between transaction and account microservices" src="image/B09148_06_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Communication between transaction and account microservices</p>
			<p>First, we need <a id="_idIndexMarker393"/>to develop our transaction microservice. After having a proper working microservice, we will create synchronous communication between transactions and the previously built <span class="No-Break">account microservice.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Tools to develop the transaction microservice</h1>
			<p>To build our second microservice, we plan to use completely different tools to show that we don’t <a id="_idIndexMarker394"/>depend on concrete tools and technologies even in JavaScript. You can develop the same microservice using different technologies, and having multiple ones in your arsenal allows you to select the optimal stack tools for <span class="No-Break">your development.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>NestJS</h2>
			<p>As a Node.js <a id="_idIndexMarker395"/>framework, we plan to <a id="_idIndexMarker396"/>use NestJS. The official page describes it as “<em class="italic">A progressive Node.js framework for building efficient, reliable and scalable server-side applications</em>.” Although Express.js has been the de facto standard for building web applications with a combination of Node.js, it doesn’t force you to use Express.js for all types of <span class="No-Break">web applications.</span></p>
			<p>First things first – NestJS is <a id="_idIndexMarker397"/>another Node.js framework. Check out <a href="B09148_04.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>’s <em class="italic">Node.js frameworks</em> section to learn more about NestJS. Here’s a summary of what <span class="No-Break">it offers:</span></p>
			<ul>
				<li>It promotes a <strong class="bold">modular architecture</strong> that allows you to build scalable and easily <a id="_idIndexMarker398"/>organizable applications. You can easily organize your application into modules, components, controllers, <span class="No-Break">and services.</span></li>
				<li>NestJS is <a id="_idIndexMarker399"/>built on top of <strong class="bold">TypeScript</strong> and uses TypeScript at its core. If you are a big fan of <strong class="bold">strongly typed</strong> tools/languages like me, then it is for you. Strongly typed languages enforce type safety, meaning compiler checks for operations. This can prevent unexpected crashes and incorrect <span class="No-Break">results later.</span></li>
				<li>NestJS <a id="_idIndexMarker400"/>supports <strong class="bold">validation</strong> out of the box. It validates incoming data, which may be helpful when <span class="No-Break">building APIs.</span></li>
			</ul>
			<p>Installing all the required applications directly to your computer is not always the best choice. That is why we use Docker. While directly installing applications isn’t inherently wrong, Docker provides a more efficient and manageable approach for <span class="No-Break">certain situations.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor110"/>Docker</h2>
			<p>Docker helps <a id="_idIndexMarker401"/>developers build things such as software programs more easily. Imagine a <a id="_idIndexMarker402"/>box that holds all the tools and parts a program needed to run. This box is like a Docker container. Docker lets you put your program and all its bits and pieces in this box so that it works the same way on <span class="No-Break">any computer.</span></p>
			<p>Check out <a href="B09148_04.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> to learn more about how to set up Docker on <span class="No-Break">your computer.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor111"/>Prisma ORM</h2>
			<p>Prisma is <a id="_idIndexMarker403"/>a next-generation <strong class="bold">Object-Relational Mapper</strong> (<strong class="bold">ORM</strong>). In the world of programming, an ORM acts as <a id="_idIndexMarker404"/>a bridge between two different ways of handling data: <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) and <span class="No-Break">relational databases.</span></p>
			<p>Prisma, as an <a id="_idIndexMarker405"/>open source ORM, that simplifies database interactions in Node.js applications. It’s like a set of helpful tools that take care of a lot of the complex stuff for you. The good news is, you don’t need to deal with pure SQL queries. Here’s what <span class="No-Break">it offers:</span></p>
			<ul>
				<li><strong class="bold">Prisma Client</strong>: This tool automatically builds code to access your database, making it <a id="_idIndexMarker406"/>safe and straightforward. It even checks your code for errors as you write it (if you’re <span class="No-Break">using TypeScript).</span></li>
				<li><strong class="bold">Prisma Migrate</strong>: This tool <a id="_idIndexMarker407"/>helps you define how your database is structured and keeps it up to date as your <span class="No-Break">application changes.</span></li>
				<li><strong class="bold">Prisma Studio</strong>: This is <a id="_idIndexMarker408"/>a visual tool that lets you see and edit the information stored in your database directly, like a <span class="No-Break">user-friendly dashboard.</span></li>
			</ul>
			<p>Under the hood, you can use PostgreSQL, MySQL, SQL Server, SQLite, MongoDB, and more. When your application requires migrating from one database to another that Prisma supports, it will not affect your project source code because Prisma abstracts your code from <span class="No-Break">internal details.</span></p>
			<p>Prisma Client works well with many different ways of building <span class="No-Break">Node.js applications:</span></p>
			<ul>
				<li>Traditional <span class="No-Break">REST APIs</span></li>
				<li>Modern <span class="No-Break">GraphQL APIs</span></li>
				<li>Efficient <span class="No-Break">gRPC APIs</span></li>
				<li>Any Node.js project that needs to use <span class="No-Break">a database</span></li>
			</ul>
			<p>In short, Prisma simplifies interacting with databases in Node.js, saving you time and effort. It offers a variety of features to fit your <span class="No-Break">project’s needs.</span></p>
			<p>Now, we are ready to develop our transaction service, and starting from the next section, we will dive into the details of the <span class="No-Break">development process.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor112"/>Hands-on transaction microservice development</h1>
			<p>The best way of learning from a technical book is by following its instructions. For all practical chapters, it is preferable to follow us along the journey and type every command <a id="_idIndexMarker409"/>with us. Downloading source code from the Git repository and investigating source code is also a good way of learning things <span class="No-Break">in practice.</span></p>
			<p>Getting started with NestJS is easier than Express.js. It has code generation steps and easy-to-use packages that help you to do a fast development. If you’re looking for a better, modern template to get started, NestJS is one way of achieving it. NestJS provides a built-in command-line tool called the <em class="italic">Nest CLI</em>. It acts as a powerful assistant throughout your NestJS application’s lifecycle. If offers interesting and useful functionalities such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Project initialization</strong>: Quickly set up a new NestJS project with a well-structured <a id="_idIndexMarker410"/>directory layout following <span class="No-Break">best </span><span class="No-Break">practices.</span></li>
				<li><strong class="bold">Development support</strong>: Run your application in development mode for hot reloading <a id="_idIndexMarker411"/>and <span class="No-Break">streamlined </span><span class="No-Break">debugging.</span></li>
				<li><strong class="bold">Production build</strong>: Bundle <a id="_idIndexMarker412"/>your application for deployment in production environments, optimizing it <span class="No-Break">for </span><span class="No-Break">efficiency.</span></li>
				<li><strong class="bold">Code generation</strong>: Generate <a id="_idIndexMarker413"/>various components such as controllers, services, modules, and more using schematics, saving you time and <span class="No-Break">ensuring consistency.</span></li>
			</ul>
			<p>Let’s begin the <span class="No-Break">development process:</span></p>
			<ol>
				<li>Create a folder for your project (it is <strong class="source-inline">Ch06</strong> in our <span class="No-Break">Git repo).</span></li>
				<li>Open VS Code and open your folder <span class="No-Break">from it.</span></li>
				<li>Go to the <strong class="bold">Terminal</strong> menu, then select <span class="No-Break"><strong class="bold">New Terminal</strong></span><span class="No-Break">.</span></li>
				<li>Type <strong class="source-inline">npm i -g @nestjs/cli</strong> and <span class="No-Break">hit </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
			</ol>
			<p>After the NestJS CLI is installed, we can create our project template with a single command. Just type <strong class="source-inline">nest new transactionservice</strong> and press <span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break"> again.</span></p>
			<p>If you <a id="_idIndexMarker414"/>encounter a <strong class="source-inline">Cannot Be Loaded Because Running Scripts is Disabled on This System</strong> error message while trying to run a script in Windows, follow these steps to <span class="No-Break">resolve it:</span></p>
			<ol>
				<li><strong class="bold">Open Windows PowerShell</strong>: Press <em class="italic">Win</em> + <em class="italic">X</em> and select <strong class="bold">Windows PowerShell (Admin)</strong> to open it with <span class="No-Break">administrator privileges.</span></li>
				<li><strong class="bold">Set the execution policy</strong>: In the PowerShell window, type the following command and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">Set-ExecutionPolicy RemoteSigned</strong></pre></li>				<li><strong class="bold">Confirm the change</strong>: When prompted, type <strong class="source-inline">Y</strong> (for Yes) and press <strong class="bold">Enter</strong> <span class="No-Break">to confirm.</span></li>
				<li><strong class="bold">Run your script again</strong>: Try running your script once more. The issue should now <span class="No-Break">be resolved.</span></li>
			</ol>
			<p>You will get a prompt that asks you to select package manager during project setup (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em>). We have the <span class="No-Break">following options:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">npm</strong></span></li>
				<li><span class="No-Break">Yarn</span></li>
				<li><span class="No-Break">Pnpm</span></li>
			</ul>
			<p>Our choice is <strong class="source-inline">npm</strong> for this project. It is a strong contender in the world of package managers, particularly for Node.js projects. It has a massive package registry, is the default for Node.js, and has a large community (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer057">
					<img alt="Figure 6.2: NestJS offers to select a package manager" src="image/B09148_06_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: NestJS offers to select a package manager</p>
			<p>After you’ve <a id="_idIndexMarker415"/>made your selection, the CLI will generate a project template for us (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer058">
					<img alt="Figure 6.3: CLI-generated folder structure for NestJS" src="image/B09148_06_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: CLI-generated folder structure for NestJS</p>
			<p>The <strong class="source-inline">src</strong> and <strong class="source-inline">test</strong> folders are not empty and contain the initial project skeleton (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer059">
					<img alt="Figure 6.4: CLI-generated src and test folders" src="image/B09148_06_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: CLI-generated src and test folders</p>
			<p>To run <a id="_idIndexMarker416"/>the generated template successfully, take the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Navigate to the <strong class="source-inline">transactionservice</strong> folder from the terminal using the <strong class="source-inline">cd transactionservice</strong> command. For all types of commands, we need to navigate to this folder to run them properly. You can simply open the <strong class="source-inline">transactionservice</strong> folder directly from VS Code if you do not want to type the <strong class="source-inline">cd</strong> command <span class="No-Break">every time.</span></li>
				<li>Type <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">run start:dev</strong></span><span class="No-Break">.</span><p class="list-inset">This command starts a special server that helps you see changes quickly. It watches your files closely, and if it sees anything different, it automatically fixes things up and refreshes the server. This means you can see your updates right away without needing to restart <span class="No-Break">everything yourself.</span></p></li>
				<li>Open your favorite browser and navigate to <strong class="source-inline">http://localhost:3000</strong> (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">):</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 6.5: Successful NestJS project run result" src="image/B09148_06_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Successful NestJS project run result</p>
			<p>The next <a id="_idIndexMarker417"/>subsections will help us to understand how to prepare our environment and build our <span class="No-Break">microservice easily.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/>Dockerizing your PostgreSQL instance</h2>
			<p><strong class="bold">PostgreSQL</strong> is one <a id="_idIndexMarker418"/>of the best choices when it comes to storing data in the database. We will use Docker to containerize our database, isolating it from <span class="No-Break">other environments.</span></p>
			<p>Right-click <a id="_idIndexMarker419"/>on your root project folder (it is <strong class="source-inline">transactionservice</strong> for us) and add a <span class="No-Break"><strong class="source-inline">docker-compose.yml</strong></span><span class="No-Break"> file.</span></p>
			<p>Open this empty file and add the <span class="No-Break">following lines:</span></p>
			<pre class="source-code">
networks:
  my-app-network:  # Define the network name exactly as used later
services:
  postgres:
    image: postgres
    env_file:
      - .env
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    ports:
      - ${POSTGRES_PORT}:5432
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - my-app-network  # Add the service to the network
  pgadmin:
    image: dpage/pgadmin4
    env_file:
      - .env
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD}
      - POSTGRES_HOST=postgreshost
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - PGADMIN_CONFIG_SERVER_MODE=False
      - PGADMIN_CONFIG_MASTER_PASSWORD_REQUIRED=False
    ports:
      - ${PGADMIN_PORT}:80
    depends_on:
      - postgres
    user: root
    volumes:
      - postgres_data:/var/lib/pgadmin/data
    networks:
      - my-app-network  # Add the service to the network
volumes:
  postgres_data:</pre>			<p>We used <strong class="source-inline">docker-compose.yml</strong> in <a href="B09148_04.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> when we talked about installing Apache Kafka. We have a separate chapter about containerization, but let’s explain the file itself here for <span class="No-Break">more clarity.</span></p>
			<p>A <strong class="source-inline">docker-compose.yml</strong> file is a YAML configuration file used to define and manage multi-container <a id="_idIndexMarker420"/>Docker applications. Docker Compose is a tool that allows you to define services, networks, and volumes required for your application in a single file, making it easier to manage <span class="No-Break">complex setups.</span></p>
			<p>Each <a id="_idIndexMarker421"/>service represents a containerized <span class="No-Break">application component.</span></p>
			<p>You can <a id="_idIndexMarker422"/>define custom networks for your services to communicate with each other. By default, Docker Compose creates a default network for your application, but you can define custom networks to control communication between <span class="No-Break">specific services.</span></p>
			<p>You can also define named volumes or mount host directories into containers to persist data or share files <span class="No-Break">between containers.</span></p>
			<p>Docker Compose allows you to start all your services together with a single command, instead of running services one by one, <strong class="source-inline">docker-compose</strong> helps you to spin up your entire infrastructure with a single command (<strong class="source-inline">docker-compose up</strong>) and manage it consistently across <span class="No-Break">different environments.</span></p>
			<p>This <strong class="source-inline">docker-compose.yml</strong> file defines a Docker Compose configuration for setting up two services: <strong class="source-inline">postgres</strong> and <strong class="source-inline">pgadmin</strong>. Let’s break <span class="No-Break">it down:</span></p>
			<ul>
				<li><strong class="source-inline">networks</strong>: This section within your Docker Compose YAML file defines named networks <a id="_idIndexMarker423"/>that can be used by your application’s services. These networks provide a way for containers to communicate with each other in a controlled and <span class="No-Break">isolated manner.</span></li>
				<li><strong class="source-inline">services</strong>: This <a id="_idIndexMarker424"/>section defines the services to <span class="No-Break">be created.</span><ul><li><strong class="source-inline">postgres</strong>: This service uses the official PostgreSQL Docker image. It sets up a PostgreSQL <span class="No-Break">database container.</span></li><li><strong class="source-inline">image: postgres</strong>: Specifies the Docker image to be used for <span class="No-Break">this service.</span></li><li><strong class="source-inline">env_file</strong>: Specifies a file from which to read <span class="No-Break">environment variables.</span></li><li><strong class="source-inline">environment</strong>: Sets environment variables for the PostgreSQL container, including username, password, and <span class="No-Break">database name.</span></li><li><strong class="source-inline">ports</strong>: Maps the container’s PostgreSQL port to a port on the host machine, allowing <span class="No-Break">external access.</span></li><li><strong class="source-inline">volumes</strong>: Mounts a volume to persist <span class="No-Break">PostgreSQL data.</span></li></ul></li>
				<li><strong class="source-inline">pgadmin</strong>: This <a id="_idIndexMarker425"/>service uses the <strong class="source-inline">pgAdmin</strong> 4 Docker image to set up a web-based administration interface <span class="No-Break">for PostgreSQL.</span><ul><li><strong class="source-inline">image: dpage/pgadmin4</strong>: Specifies the Docker image for <span class="No-Break"><strong class="source-inline">pgAdmin</strong></span><span class="No-Break"> 4.</span></li><li><strong class="source-inline">env_file</strong>: Similar to the <strong class="source-inline">postgres</strong> service, this specifies a file from which to read <span class="No-Break">environment variables.</span></li><li><strong class="source-inline">environment</strong>: Sets environment variables for <strong class="source-inline">pgAdmin</strong>, including default email, password, and PostgreSQL <span class="No-Break">connection details.</span></li><li><strong class="source-inline">ports</strong>: Maps the container’s port <strong class="source-inline">80</strong> to a port on the <span class="No-Break">host machine.</span></li><li><strong class="source-inline">depends_on</strong>: Specifies that this service depends on the <strong class="source-inline">postgres</strong> service, ensuring that the PostgreSQL database is available before <span class="No-Break">starting </span><span class="No-Break"><strong class="source-inline">pgAdmin</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">user: root</strong>: Specifies <a id="_idIndexMarker426"/>that the container should run as the <span class="No-Break">root user.</span></li><li><strong class="source-inline">volumes</strong>: Mounts a volume to persist <span class="No-Break"><strong class="source-inline">pgAdmin</strong></span><span class="No-Break"> data.</span></li></ul></li>
				<li><strong class="source-inline">volumes</strong>: This section <a id="_idIndexMarker427"/>defines a named volume <strong class="source-inline">postgres_data</strong>, which is used by both services to <span class="No-Break">persist data.</span></li>
			</ul>
			<p>In the end, this Docker Compose configuration sets up a PostgreSQL database container and a <strong class="source-inline">pgAdmin</strong> container, providing a convenient way to manage and interact with the PostgreSQL database using a web-based interface. To run your <strong class="source-inline">docker-compose</strong> file, just navigate to the folder of it and type <strong class="source-inline">docker-compose up -d</strong> from <span class="No-Break">the terminal.</span></p>
			<p>Instead of <a id="_idIndexMarker428"/>directly adding credentials/values to the <strong class="source-inline">docker-compose</strong> file, we can specify it from a <strong class="source-inline">.env</strong> file (we have already talked about this file), and Docker can read the required data from environment variables. Just create a <strong class="source-inline">.env</strong> file inside your main folder (it is the <strong class="source-inline">transactionservice</strong> folder for us) and add the missing configuration for Docker to <span class="No-Break">run successfully:</span></p>
			<pre class="source-code">
# PostgreSQL settings
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=tservice_db
POSTGRES_PORT=5438
# pgAdmin settings
PGADMIN_DEFAULT_EMAIL=admin@tservice.com
PGADMIN_DEFAULT_PASSWORD=tservice_password
PGADMIN_PORT=5050</pre>			<p>We now have our PostgreSQL database up and running. In most cases, developers prefer not to directly interact with databases using SQL queries. Not all developers have a solid understanding of SQL, and even so, using pure SQL queries to manipulate to database in most cases is not a good choice nowadays. Instead, we have various packages available that abstract away the complexity of raw SQL, enabling us to create beautiful applications without needing deep expertise in SQL. One of these packages is Prisma. As we mentioned before, Prisma is an open source ORM that automates and abstracts most of the operations you need to do when you deal with <span class="No-Break">a database.</span></p>
			<p>To <a id="_idIndexMarker429"/>start work with Prisma, we need a <em class="italic">CLI</em>. Prisma CLI is a combination of tools that help us migrate, seed, and do additional database-oriented operations easily. You just need to run the <strong class="source-inline">npm install prisma -D</strong> command from the terminal. After executing the command, <strong class="source-inline">npm</strong> should successfully install Prisma CLI as a dev dependency. You can check <strong class="source-inline">package.json</strong>’s <span class="No-Break"><strong class="source-inline">devDependencies</strong></span><span class="No-Break"> section.</span></p>
			<p>After Prisma CLI, it is time to install Prisma itself. The <strong class="source-inline">npx prisma init</strong> command handles the initialization of the Prisma package. It will create an additional folder called <strong class="source-inline">prisma</strong> with a <strong class="source-inline">schema.prisma</strong> file and a <strong class="source-inline">.env</strong> file. In our case, we already have a <strong class="source-inline">.env</strong> file, so running the preceding command will end up updating our existing <strong class="source-inline">.env</strong> file. Open your <strong class="source-inline">.env</strong> file, and at the end of the file, update the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">DATABASE_URL</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
DATABASE_URL="postgres://postgres:postgres@localhost:5438/tservice_db"</pre>			<p>At the <a id="_idIndexMarker430"/>heart of your Prisma setup lies the <strong class="source-inline">schema.prisma</strong> file. This file uses <strong class="bold">Prisma Schema Language</strong> (<strong class="bold">PSL</strong>), a declarative approach to defining your database structure.  It acts as the central configuration for Prisma, specifying both your database connection and the generation of the Prisma Client API. The following code demonstrates how to define a simple schema file <span class="No-Break">for Prisma:</span></p>
			<pre class="source-code">
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}</pre>			<p>The <strong class="source-inline">schema.prisma</strong> file, written in PSL, acts as your database blueprint with three <span class="No-Break">key sections:</span></p>
			<ul>
				<li><strong class="source-inline">generator</strong>: This <a id="_idIndexMarker431"/>section configures the Prisma Client generator. The Prisma Client, a powerful API, is then generated to help you access <span class="No-Break">your database.</span></li>
				<li><strong class="source-inline">datasource</strong>: Here, you <a id="_idIndexMarker432"/>define the database connection details. This includes the database provider and the connection string, often leveraging the <strong class="source-inline">DATABASE_URL</strong> environment variable <span class="No-Break">for convenience.</span></li>
				<li><strong class="source-inline">Model:</strong> This is <a id="_idIndexMarker433"/>where the heart of your database schema lies. You define the structure of your data by specifying tables and their <span class="No-Break">corresponding fields.</span></li>
			</ul>
			<p>The next <a id="_idIndexMarker434"/>section describes how to model your data inside the <span class="No-Break"><strong class="source-inline">schema.prisma</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/>Modeling the data</h2>
			<p>The <strong class="source-inline">schema.prisma</strong> file is the main place where we need to add our models. Modeling <a id="_idIndexMarker435"/>is a special <a id="_idIndexMarker436"/>language over SQL. It isolates you from the internals of SQL and provides data in a more <span class="No-Break">human-readable language.</span></p>
			<p>Open the <strong class="source-inline">schema.prisma</strong> file under the <strong class="source-inline">prisma</strong> folder and add the following <span class="No-Break">model structure:</span></p>
			<pre class="source-code">
model Transaction {
  id           Int      @id @default(autoincrement())
  status       Status
  accountId    String   @default(uuid())
  description  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}
enum Status {
  CREATED
  SETTLED
  FAILED
}</pre>			<p>The <a id="_idIndexMarker437"/>provided code defines <a id="_idIndexMarker438"/>a Prisma model named <strong class="source-inline">Transaction</strong> and an <strong class="source-inline">enum</strong> named <strong class="source-inline">Status</strong> within your NestJS <span class="No-Break">application schema.</span></p>
			<p>Here’s a breakdown of <span class="No-Break">each section:</span></p>
			<ul>
				<li><strong class="source-inline">id</strong>: This field represents the unique identifier for each transaction. It’s of type <strong class="source-inline">Int</strong> and is automatically marked as the primary key with the <strong class="source-inline">@id</strong> directive. Additionally, <strong class="source-inline">@default(autoincrement())</strong> ensures a new, unique ID is generated for each <span class="No-Break">transaction automatically.</span></li>
				<li><strong class="source-inline">status</strong>: This field defines the current state of the transaction. It’s of type <strong class="source-inline">Status</strong>, which will reference <strong class="source-inline">Status </strong><span class="No-Break"><strong class="source-inline">Enumeration(enum Status)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">accountId</strong>: This field stores the identifier for the associated account involved in the <a id="_idIndexMarker439"/>transaction. It’s of type <strong class="source-inline">String</strong> and uses <strong class="source-inline">@default(uuid())</strong> to generate a <strong class="bold">universally unique identifier</strong> (<strong class="bold">UUID</strong>) <span class="No-Break">by default.</span></li>
				<li><strong class="source-inline">description</strong>: This optional field allows for storing a brief description of the transaction. It’s of type <strong class="source-inline">String?</strong>, indicating it can <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">createdAt</strong>: This field captures the timestamp of when the transaction was created. It’s of type <strong class="source-inline">DateTime</strong> and uses <strong class="source-inline">@default(now())</strong> to automatically set the creation time to the <span class="No-Break">current moment.</span></li>
				<li><strong class="source-inline">updatedAt</strong>: This field is automatically updated whenever the transaction record is modified. It’s of type <strong class="source-inline">DateTime</strong> and uses the <strong class="source-inline">@updatedAt</strong> directive to achieve <span class="No-Break">this behavior.</span></li>
			</ul>
			<p>OK – but how to generate SQL based on the model we defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">schema.prisma</strong></span><span class="No-Break">?</span></p>
			<p>Run <strong class="source-inline">npx prisma migrate dev --name init</strong> from the command line (VS Code terminal) to start <a id="_idIndexMarker440"/>the migration journey. In the context of NestJS and Prisma, <strong class="bold">migration</strong> refers to <a id="_idIndexMarker441"/>a process that manages changes to your database schema <span class="No-Break">over time.</span></p>
			<p>Here <a id="_idIndexMarker442"/>is a breakdown of <span class="No-Break">the command:</span></p>
			<ul>
				<li><strong class="source-inline">npx prisma migrate dev</strong>: This command invokes the Prisma migration tool in <span class="No-Break">development mode.</span></li>
				<li><strong class="source-inline">--name init</strong>: This option specifies the name of the new migration. Here, it’s set to <strong class="source-inline">init</strong>, likely signifying the initial setup of your <span class="No-Break">database schema.</span></li>
			</ul>
			<p>By running this command, you’re essentially creating a starting point for managing your database schema changes using Prisma migrations. As you make modifications to your <strong class="source-inline">schema.prisma</strong> file, Prisma will automatically generate new migrations to reflect <span class="No-Break">those changes.</span></p>
			<p>The command will end up creating a <strong class="source-inline">migrations</strong> folder with a <strong class="source-inline">migration.sql</strong> file (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer061">
					<img alt="Figure 6.6: Automatically generated migration structure" src="image/B09148_06_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: Automatically generated migration structure</p>
			<p>Check the generated <span class="No-Break"><strong class="source-inline">migration.sql</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
-- CreateEnum
CREATE TYPE "Status" AS ENUM ('CREATED', 'SETTLED', 'FAILED');
-- CreateTable
CREATE TABLE "Transaction" (
    "id" SERIAL NOT NULL,
    "status" "Status" NOT NULL,
    "accountId" TEXT NOT NULL,
    "description" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    CONSTRAINT "Transaction_pkey" PRIMARY KEY ("id")
);</pre>			<p>Now, you <a id="_idIndexMarker443"/>should have tables <a id="_idIndexMarker444"/>with the name <strong class="source-inline">Transaction</strong> and <strong class="source-inline">_prisma_migrations</strong> in your database. It may take a few seconds for Docker to set up the services, so a brief wait might be necessary. To check this, let’s do the <span class="No-Break">following operations:</span></p>
			<ol>
				<li>Open Docker Desktop and ensure all services <span class="No-Break">are running.</span></li>
				<li>Click on the <span class="No-Break"><strong class="source-inline">postgres</strong></span><span class="No-Break"> container.</span></li>
				<li>From the <strong class="bold">Inspect</strong> tab, find the IP address of the container (in our case, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">172.26.0.2</strong></span><span class="No-Break">):</span></li>
				<li>Navigate to <strong class="source-inline">http://localhost:5050/browser/</strong> from <span class="No-Break">your browser.</span></li>
				<li>Right-click on <strong class="bold">Servers</strong>, then select <strong class="bold">Register</strong> | <strong class="bold">Server</strong> from <span class="No-Break">the menu.</span></li>
				<li>Under the <strong class="bold">General</strong> tab, type any name you want for <strong class="bold">Name</strong>. We have specified <strong class="source-inline">localhost</strong> for <span class="No-Break">its value.</span></li>
				<li>Go to <a id="_idIndexMarker445"/>the <strong class="bold">Connection</strong> tab and <a id="_idIndexMarker446"/>fill in the inputs (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">):</span><ul><li><strong class="bold">Host name/address</strong>: The IP address you just took (it is <strong class="source-inline">172.26.0.2</strong> <span class="No-Break">for us)</span></li><li><span class="No-Break"><strong class="bold">Port</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">5432</strong></span></li><li><strong class="bold">Maintenance </strong><span class="No-Break"><strong class="bold">database</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">tservice_db</strong></span></li><li><span class="No-Break"><strong class="bold">Username</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">postgres</strong></span></li><li><span class="No-Break"><strong class="bold">Password</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">postgres</strong></span></li></ul></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer062">
					<img alt="Figure 6.7: Server registration window for postgres" src="image/B09148_06_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7: Server registration window for postgres</p>
			<ol>
				<li value="8">Click the <strong class="bold">Save</strong> button, and your server connection should <span class="No-Break">be successful.</span></li>
				<li>Now, expand <strong class="source-inline">localhost</strong> (or your name) | <strong class="bold">Databases</strong>| <strong class="source-inline">tservice_db</strong> | <strong class="bold">Schemas</strong> | <strong class="bold">Public</strong> | <strong class="bold">Tables</strong> (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">):</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer063">
					<img alt="Figure 6.8: postgres tables after migration via Prisma" src="image/B09148_06_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8: postgres tables after migration via Prisma</p>
			<ol>
				<li value="10">If you <a id="_idIndexMarker447"/>have locally installed  <strong class="source-inline">pgAdmin</strong>, to connect to your Docker <strong class="source-inline">postgres</strong> instance, just enter <a id="_idIndexMarker448"/>the following to the server registration window for <strong class="source-inline">postgres</strong> (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">):</span><ul><li><strong class="bold">Host </strong><span class="No-Break"><strong class="bold">name/address</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">localhost</strong></span></li><li><span class="No-Break"><strong class="bold">Port</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">5438</strong></span></li><li><strong class="bold">Maintenance </strong><span class="No-Break"><strong class="bold">database</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">tservice_db</strong></span></li><li><span class="No-Break"><strong class="bold">Username</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">postgres</strong></span></li><li><span class="No-Break"><strong class="bold">Password</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">postgres</strong></span></li></ul></li>
				<li>Click the <strong class="bold">Save</strong> button, and your server connection should <span class="No-Break">be successful.</span></li>
			</ol>
			<p>The <strong class="source-inline">_prisma_migrations</strong> table you see when using NestJS and Prisma ORM plays a crucial role in managing database schema changes. It has the <span class="No-Break">following responsibilities:</span></p>
			<ul>
				<li>Tracks applied <span class="No-Break">database migrations</span></li>
				<li>Ensures migrations are applied <span class="No-Break">only once</span></li>
				<li>Maintains consistency between your Prisma schema and the actual <span class="No-Break">database structure</span></li>
			</ul>
			<p>Each time you run a Prisma migration, a new entry is added to the <span class="No-Break"><strong class="source-inline">_prisma_migrations</strong></span><span class="No-Break"> table.</span></p>
			<p>When Prisma needs to apply migrations, it checks the <strong class="source-inline">_prisma_migrations</strong> table to see which migrations have already been run based on the <span class="No-Break">unique hash.</span></p>
			<p>This <a id="_idIndexMarker449"/>prevents applying the same <a id="_idIndexMarker450"/>migration multiple times, potentially corrupting <span class="No-Break">your data.</span></p>
			<p>Modifying the <strong class="source-inline">_prisma_migrations</strong> table manually can lead to inconsistencies and errors. Don’t edit, delete, or modify it. This table is essential for Prisma to manage <span class="No-Break">migrations effectively.</span></p>
			<p>Long story short, the <strong class="source-inline">_prisma_migrations</strong> table acts as a logbook for your database schema changes, ensuring a smooth and controlled <span class="No-Break">migration process.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor115"/>Seeding test data</h2>
			<p>Seeding data involves populating your database with an initial set of data. If you want your <a id="_idIndexMarker451"/>database to have <a id="_idIndexMarker452"/>initial data before running your application, you may <span class="No-Break">apply seeding.</span></p>
			<p>Add a <strong class="source-inline">seed.ts</strong> file under the <strong class="source-inline">prisma</strong> folder with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
// prisma/seed.ts
import { PrismaClient } from '@prisma/client';
// initialize Prisma Client
const prismaClient = new PrismaClient();
async function seedData() {
  // create two dummy recipes
  const first_transaction = await
    prismaClient.transaction.upsert({
    where: { id:1 },
    update: {},
    create: {
      id:1,
      status: 'CREATED',
      accountId: '662c081370bd2ba6b5f04e94',
      description: 'simple transaction',
    }
  });
  console.log(first_transaction);
}
// execute the seed function
seedData()
  .catch(e =&gt; {
    console.error(e);
    process.exit(1);
  })
  .finally(async () =&gt; {
    // close Prisma Client at the end
    await prismaClient.$disconnect();
  });</pre>			<p>Go <a id="_idIndexMarker453"/>to <strong class="source-inline">package.json</strong> and add <a id="_idIndexMarker454"/>the following <span class="No-Break">after </span><span class="No-Break"><strong class="source-inline">devDependencies</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
"prisma": {
    "seed": "ts-node prisma/seed.ts"
  }</pre>			<p>Now, open the terminal window and type the <strong class="source-inline">npx prisma db seed</strong> command. You should see a message that indicates a successful operation (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer064">
					<img alt="Figure 6.9: Executing seed" src="image/B09148_06_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9: Executing seed</p>
			<p>Open <a id="_idIndexMarker455"/>the <strong class="source-inline">Transaction</strong> table <a id="_idIndexMarker456"/>using <strong class="source-inline">PgAdmin</strong>, and you’ll see your first successfully inserted row (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer065">
					<img alt="Figure 6.10: Transaction table after seed" src="image/B09148_06_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10: Transaction table after seed</p>
			<p>It is time to explain what we have inserted into our <span class="No-Break"><strong class="source-inline">seed.ts</strong></span><span class="No-Break"> file:</span></p>
			<ul>
				<li><strong class="source-inline">PrismaClient from @prisma/client</strong>: This line imports the necessary class to interact with our database schema <span class="No-Break">using Prisma.</span></li>
				<li><strong class="source-inline">const prismaClient = new PrismaClient()</strong>: Here, we create an instance of the <strong class="source-inline">PrismaClient</strong> class, which will be used to perform <span class="No-Break">database operations.</span></li>
				<li><strong class="source-inline">async function seedData() { ... }</strong>: This function is the heart of the script and is marked <strong class="source-inline">async</strong> because it includes asynchronous operations that involve interacting with <span class="No-Break">the database.</span></li>
				<li><strong class="source-inline">const first_transaction = await prismaClient.transaction.upsert({ ... })</strong>: This line performs the core <span class="No-Break">seeding operation.</span></li>
				<li><strong class="source-inline">prismaClient.transaction</strong>: This part accesses the transaction model of your <a id="_idIndexMarker457"/>Prisma schema <a id="_idIndexMarker458"/>through the <span class="No-Break">initialized client.</span></li>
				<li><strong class="source-inline">.upsert({ ... }):</strong> The <strong class="source-inline">upsert</strong> method is a convenient way to create or update a record in the database. It checks for existing data based on the provided <strong class="source-inline">where</strong> clause and performs the <span class="No-Break">appropriate action.</span></li>
				<li>If a record with <strong class="source-inline">id: 1</strong> (assuming your schema has an ID field) already exists, the <span class="No-Break">following happens:</span><ul><li>The <strong class="source-inline">update</strong> object (empty here) would be used to update the existing record (but since it’s empty, no update happens) if a record with <strong class="source-inline">id: </strong><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break"> exists.</span></li><li>The <strong class="source-inline">create</strong> object defines the data for the new transaction record if a record with an ID <span class="No-Break">doesn’t exist.</span><ul><li><strong class="source-inline">create Object (Seed Data)</strong>: This object defines the details of the dummy transaction to <span class="No-Break">be created.</span></li><li><strong class="source-inline">id: 1</strong>: Sets the ID of the transaction to 1 (replace with a unique value <span class="No-Break">if needed).</span></li><li><strong class="source-inline">status: 'CREATED'</strong>: Sets the initial status of the transaction <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CREATED</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">accountId: '662c081370bd2ba6b5f04e94'</strong>: Assigns an account ID to the transaction (you can use <span class="No-Break">any ID).</span></li><li><strong class="source-inline">description: 'simple transaction'</strong>: Provides a descriptive text for <span class="No-Break">the transaction.</span></li></ul></li></ul></li>
			</ul>
			<p>To <a id="_idIndexMarker459"/>apply business rules <a id="_idIndexMarker460"/>to our application, we need to add an extra layer over a database, and it is going to be our service layer. The next section will introduce a service layer for the <span class="No-Break">transaction database.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor116"/>Implementing the transaction service</h2>
			<p>We are done with the database. As a classical development style, it is time to create a service <a id="_idIndexMarker461"/>over our database. Creating a service layer is simple with NestJS, especially if you deal with <span class="No-Break">Prisma ORM.</span></p>
			<p>First, let’s create <a id="_idIndexMarker462"/>our module using the <strong class="source-inline">npx nest generate module </strong><span class="No-Break"><strong class="source-inline">prisma</strong></span><span class="No-Break"> command.</span></p>
			<p>This Prisma CLI command should generate a new folder called <strong class="source-inline">prisma</strong> and should generate a <strong class="source-inline">prisma.module.ts</strong> file under this folder. This command also will affect your <strong class="source-inline">app.module.js</strong> file under the <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder.</span></p>
			<p>We need one more command to run to generate our <span class="No-Break">service files:</span></p>
			<pre class="console">
Npx nest generate service prisma</pre>			<p>This command will create <strong class="source-inline">prisma.service.ts,prisma.service.spec.ts</strong> files under <strong class="source-inline">src/prisma</strong> and update the <span class="No-Break"><strong class="source-inline">prisma.module.ts</strong></span><span class="No-Break"> file.</span></p>
			<p>For this chapter, you can remove all files that have <strong class="source-inline">.spec.ts</strong> extensions from the project. These files contain unit tests for the application’s components, typically services and controllers. We have a separate chapter to work with unit tests; for the chapter’s simplicity, we don’t need them. For now, replace the content of <strong class="source-inline">prisma.service.ts</strong> with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
import { Injectable } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
@Injectable()
export class PrismaService extends PrismaClient {}</pre>			<p>In <a id="_idIndexMarker463"/>this code, we <a id="_idIndexMarker464"/>have a straightforward implementation for the <span class="No-Break"><strong class="source-inline">prisma</strong></span><span class="No-Break"> service:</span></p>
			<ul>
				<li><strong class="source-inline">import { Injectable } from '@nestjs/common';</strong>: This line imports the <strong class="source-inline">Injectable</strong> decorator from the <strong class="source-inline">@nestjs/common</strong> module. This <a id="_idIndexMarker465"/>decorator marks the class as a NestJS injectable service, making it available for <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) in other parts of <span class="No-Break">your application.</span></li>
				<li><strong class="source-inline">import { PrismaClient } from '@prisma/client';</strong>: This line imports the <strong class="source-inline">PrismaClient</strong> class from the <strong class="source-inline">@prisma/client</strong> package. This class provides an interface for interacting with your database using <span class="No-Break">Prisma queries.</span></li>
				<li><strong class="source-inline">@Injectable()</strong>: This decorator applied to the class declaration marks it as a NestJS injectable service. NestJS will manage the lifecycle of this service and provide it to other components that require <span class="No-Break">database access.</span></li>
				<li><strong class="source-inline">export class PrismaService extends PrismaClient {}</strong>: This line defines the <strong class="source-inline">PrismaService</strong> class. It inherits from the <strong class="source-inline">PrismaClient</strong> class, giving it access to all the database interaction methods provided <span class="No-Break">by Prisma.</span></li>
			</ul>
			<p>In essence, this code creates a service specifically for interacting with our database through Prisma. This service can then be injected into other parts of our application (such as controllers) to perform <span class="No-Break">database operations.</span></p>
			<p>The <strong class="source-inline">prisma.service.ts</strong> file acts as a wrapper over the Prisma client. It is an injectable element that we can use to inject it <span class="No-Break">into modules.</span></p>
			<p>Let’s update our <strong class="source-inline">prisma.module.ts</strong> file to have the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';
@Module({
  providers: [PrismaService],
  exports: [PrismaService]
})
export class PrismaModule {}</pre>			<p>To <a id="_idIndexMarker466"/>make the Prisma service accessible throughout your NestJS application, you’ll need to <a id="_idIndexMarker467"/>create a dedicated module. This module will import the <strong class="source-inline">PrismaService</strong> class and provide it for injection into other modules or components. That is the reason why we have a <span class="No-Break"><strong class="source-inline">prisma.module.ts</strong></span><span class="No-Break"> file.</span></p>
			<p>Nowadays, it is popular to use a UI for APIs, and it allows us to document and easily use endpoints. One of the packages that allows us to do it is Swagger. The next section explains how to integrate Swagger for <span class="No-Break">our endpoints.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor117"/>Configuring Swagger</h2>
			<p>To <a id="_idIndexMarker468"/>have visible documentation and visual usage for our APIs, we will configure <span class="No-Break">Swagger UI.</span></p>
			<p>Open the <a id="_idIndexMarker469"/>VS Code terminal and type <span class="No-Break">the following:</span></p>
			<pre class="console">
npm install --save @nestjs/swagger swagger-ui-express</pre>			<p>Open <strong class="source-inline">src/main.ts</strong> and update its content with the following to <span class="No-Break">integrate Swagger:</span></p>
			<pre class="source-code">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
// bootstrap function
async function bootstrap() {
  // Create a NestJS application instance
  const app = await NestFactory.create(AppModule);
  // new Swagger document configuration
  const config = new DocumentBuilder()
    .setTitle('Transaction API') // title of the API
    .setDescription('Transaction API description')
    // description of the API
    .setVersion('1.0') // version of the API
    .build(); // Build the document
  // Create a Swagger document
  const document = SwaggerModule.createDocument(app,
    config);
  // Setup Swagger module
  SwaggerModule.setup('api', app, document);
  // Start the application and listen for requests on port 3000
  await app.listen(3000);
}
// Call the bootstrap function to start the application
bootstrap();</pre>			<p>Let’s <a id="_idIndexMarker470"/>understand <a id="_idIndexMarker471"/>this <span class="No-Break">code here:</span></p>
			<ul>
				<li><strong class="source-inline">NestFactory</strong> from <strong class="source-inline">@nestjs/core</strong>: This import provides the core functionality for creating a NestJS <span class="No-Break">application instance.</span></li>
				<li><strong class="source-inline">AppModule</strong> from <strong class="source-inline">./app.module</strong>: This imports your main application module, where all the necessary components and services of your NestJS application <span class="No-Break">are defined.</span></li>
				<li><strong class="source-inline">SwaggerModule</strong> and <strong class="source-inline">DocumentBuilder</strong> from <strong class="source-inline">@nestjs/swagger</strong>: These <a id="_idIndexMarker472"/>imports are used for integrating Swagger documentation with your <span class="No-Break">NestJS application.</span></li>
				<li>Bootstrap <span class="No-Break">function (</span><span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break">):</span><ul><li>This <a id="_idIndexMarker473"/>function is marked as <strong class="source-inline">async</strong> because it involves asynchronous operations such as creating an application instance and listening for <span class="No-Break">incoming requests.</span></li><li>It serves as the entry point for your NestJS application and is typically called at the bottom of your <span class="No-Break"><strong class="source-inline">main.ts</strong></span><span class="No-Break"> file.</span></li></ul></li>
				<li><strong class="source-inline">const app = await NestFactory.create(AppModule);</strong>: This line creates a new NestJS application instance using the <strong class="source-inline">AppModule</strong> class. The <strong class="source-inline">await</strong> keyword signifies that the function will wait for the application creation to complete <span class="No-Break">before proceeding.</span></li>
				<li><span class="No-Break">Swagger configuration:</span><ul><li><strong class="source-inline">const config = new DocumentBuilder()...</strong>: Here, you’re configuring the Swagger documentation using the <span class="No-Break"><strong class="source-inline">DocumentBuilder</strong></span><span class="No-Break"> class.</span></li><li><strong class="source-inline">.setTitle('Transaction API')</strong>: Sets the title of your API documentation to <span class="No-Break"><strong class="source-inline">Transaction API</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">.setDescription('Transaction API description')</strong>: Provides a brief description of <span class="No-Break">your API.</span></li><li><strong class="source-inline">.setVersion('1.0')</strong>: Sets the version of your API <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1.0</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">.build()</strong>: Builds the Swagger document based on the provided <span class="No-Break">configuration options.</span></li></ul></li>
				<li><strong class="source-inline">const document = SwaggerModule.createDocument(app, config);</strong>: This line generates the actual Swagger document using the <strong class="source-inline">SwaggerModule</strong> class. It takes the NestJS application instance (<strong class="source-inline">app</strong>) and the built configuration (<strong class="source-inline">config</strong>) <span class="No-Break">as arguments.</span></li>
				<li><strong class="source-inline">SwaggerModule.setup('api', app, document);</strong>: This code integrates <a id="_idIndexMarker474"/>the Swagger documentation with your application. It sets the path prefix for the documentation to <strong class="source-inline">api</strong> (for example, <strong class="source-inline">http://localhost:3000/api</strong>) and associates the generated document (<strong class="source-inline">document</strong>) with the application (<strong class="source-inline">app</strong>). This allows developers to access the interactive <a id="_idIndexMarker475"/>Swagger documentation at the <span class="No-Break">specified URL.</span></li>
				<li><strong class="source-inline">await app.listen(3000);</strong>: This line starts the NestJS application and makes it listen for incoming requests on port <strong class="source-inline">3000</strong>. You can change this port number to your <span class="No-Break">desired option.</span></li>
			</ul>
			<p>Overall, this <strong class="source-inline">main.ts</strong> file performs two <span class="No-Break">crucial tasks:</span></p>
			<ul>
				<li><strong class="bold">Boots up the NestJS application</strong>: It establishes an instance using your <strong class="source-inline">AppModule</strong> class and starts the server listening <span class="No-Break">for requests</span></li>
				<li><strong class="bold">Integrates Swagger documentation</strong>: It configures and provides Swagger documentation for your API, allowing developers to explore your API endpoints, understand data models, and interact with your API using the <span class="No-Break">interactive interface</span></li>
			</ul>
			<p>Navigate to <strong class="source-inline">localhost:3000/api</strong>, and you should see the Swagger page (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer066">
					<img alt="Figure 6.11: Swagger UI" src="image/B09148_06_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: Swagger UI</p>
			<p>As you’ll realize, we don’t have any endpoints yet; the next section talks about <span class="No-Break">creating them.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Working on transaction implementation</h2>
			<p>To start <a id="_idIndexMarker476"/>to work with transactions, first, we need <a id="_idIndexMarker477"/>to generate resources. To implement <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations <a id="_idIndexMarker478"/>for transactions, we’ll first generate REST resources, creating boilerplate code for the <a id="_idIndexMarker479"/>module, controller, service, and <strong class="bold">Data Transfer </strong><span class="No-Break"><strong class="bold">Object</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DTO</strong></span><span class="No-Break">).</span></p>
			<p>Run the <strong class="source-inline">npx nest generate resource transaction</strong> command to generate resources for <span class="No-Break">a transaction:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer067">
					<img alt="Figure 6.12: Selecting a transport layer" src="image/B09148_06_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12: Selecting a transport layer</p>
			<p>It will ask you which transport layer to choose (<span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.12</em>). Select <strong class="source-inline">REST API</strong> and hit <em class="italic">Enter</em>. As the next question, you will be asked <strong class="source-inline">Would you like to generate CRUD entry points?.</strong> Select <strong class="source-inline">Y</strong>, and the following files should be generated (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.13</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer068">
					<img alt="Figure 6.13: CRUD generation for transaction" src="image/B09148_06_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13: CRUD generation for transaction</p>
			<p>Run <strong class="source-inline">npm run start:dev</strong> and <a id="_idIndexMarker480"/>navigate to <strong class="source-inline">localhost:3000/api</strong>. You should get a page <a id="_idIndexMarker481"/>that stores transaction boilerplate endpoints (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer069">
					<img alt="Figure 6.14: Swagger UI for transaction" src="image/B09148_06_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14: Swagger UI for transaction</p>
			<p>Of course, we don’t need to implement all these CRUD endpoints. We need the <span class="No-Break">following functions:</span></p>
			<ul>
				<li>Get all transactions (<span class="No-Break"><strong class="source-inline">GET /transaction</strong></span><span class="No-Break">)</span></li>
				<li>Get transaction by ID (<strong class="source-inline">GET /</strong><span class="No-Break"><strong class="source-inline">transaction/{id}</strong></span><span class="No-Break"> )</span></li>
				<li>Create transaction (<span class="No-Break"><strong class="source-inline">POST /transaction</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Let’s <a id="_idIndexMarker482"/>remove the rest of the unused code blocks <span class="No-Break">and files.</span></p>
			<p>Remove <a id="_idIndexMarker483"/>the <span class="No-Break">following files:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">transaction/transaction.controller.spec.ts</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">transaction/dto/update-transaction.dto.ts</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">transaction/transaction.service.spec.ts</strong></span></li>
			</ul>
			<p>Remove the following <span class="No-Break">code blocks:</span></p>
			<ul>
				<li><strong class="source-inline">remove</strong> and <strong class="source-inline">update</strong> functions <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">transaction.service.ts</strong></span></li>
				<li><strong class="source-inline">remove</strong> and <strong class="source-inline">update</strong> functions <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">transaction.controller.ts</strong></span></li>
			</ul>
			<p>If you haven’t removed them yet, remove the following <span class="No-Break">files too:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">app.controller.ts</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">app.module.ts</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">app.service.ts</strong></span></li>
			</ul>
			<p>Update <strong class="source-inline">main.ts</strong> to work with <strong class="source-inline">TransactionModule</strong>, <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">AppModule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import { NestFactory } from '@nestjs/core';
import { TransactionModule } from
  './transaction/transaction.module';
import { SwaggerModule, DocumentBuilder } from
  '@nestjs/swagger';
// bootstrap function
async function bootstrap() {
  // Create a NestJS application instance
  const app = await NestFactory.create(TransactionModule);
……..</pre>			<p>You’ll <a id="_idIndexMarker484"/>end up <a id="_idIndexMarker485"/>with three endpoints (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer070">
					<img alt="Figure 6.15: Final transaction endpoints" src="image/B09148_06_015.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15: Final transaction endpoints</p>
			<p>After having generated REST resources, we’re ready to integrate our <strong class="source-inline">PrismaClient</strong> class. Having this client will help us to interact with the database easily. First, let’s update our <strong class="source-inline">transaction.module.ts</strong> file to <span class="No-Break">have </span><span class="No-Break"><strong class="source-inline">PrismaModule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import { Module } from '@nestjs/common';
import { TransactionService } from './transaction.service';
import { TransactionController } from
  './transaction.controller';
import { PrismaModule } from '../prisma/prisma.module';
@Module({
  imports: [PrismaModule],
  controllers: [TransactionController],
  providers: [TransactionService],
})
export class TransactionModule {}</pre>			<p>Having <strong class="source-inline">PrismaModule</strong> in <a id="_idIndexMarker486"/>the <strong class="source-inline">imports</strong> array will make <strong class="source-inline">PrismaService</strong> available <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">TransactionService</strong></span><span class="No-Break">.</span></p>
			<p>Now, open <a id="_idIndexMarker487"/>the <strong class="source-inline">transaction.service.ts</strong> file and make the <span class="No-Break">following changes:</span></p>
			<pre class="source-code">
import { Injectable } from '@nestjs/common';
import { CreateTransactionDto } from
  './dto/create-transaction.dto';
import { PrismaService } from 'src/prisma/prisma.service';
@Injectable()
export class TransactionService {
  constructor(private readonly prisma: PrismaService) {}
…….</pre>			<p>The transaction controller file (<strong class="source-inline">transaction.controller.ts</strong>) already has <strong class="source-inline">transactionservice</strong> as an injected service. It has all the required contracts to request the transaction service and <span class="No-Break">retrieve data.</span></p>
			<p>Open <strong class="source-inline">transaction.controller.ts</strong> and have a look at the <span class="No-Break"><strong class="source-inline">findAll()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
@Get()
  findAll() {
    return this.transactionService.findAll();
  }</pre>			<p>The same applies to <strong class="source-inline">POST</strong> and the single <strong class="source-inline">GET</strong> request. The only thing we need to do is to call Prisma to provide all the data when we call <strong class="source-inline">transactionservice</strong>’s <strong class="source-inline">findAll()</strong> method. For that reason, open <strong class="source-inline">transaction.service.ts</strong> and update the <strong class="source-inline">findAll()</strong> method content (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
findAll() {
    return this.prisma.transaction.findMany();
  }</pre>			<p>Using <strong class="source-inline">findMany()</strong>, we’re able to call all transaction data from the transaction table via Prisma. Let’s <a id="_idIndexMarker488"/>run our application (run <strong class="source-inline">npm run start:dev</strong>) and run our endpoint from <span class="No-Break">Swagger UI.</span></p>
			<p>Open <strong class="source-inline">GET /transaction</strong> from Swagger UI, click the <strong class="bold">Try it out</strong> button, and click the  <strong class="bold">Execute</strong> button. Now, you should see only the data we migrated to our database when we talked <a id="_idIndexMarker489"/>about seeding data (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.16</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer071">
					<img alt="Figure 6.16: Response for “Get all transactions”" src="image/B09148_06_016.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16: Response for “Get all transactions”</p>
			<p>To modify your <strong class="source-inline">GET</strong> request by ID endpoint for it to work properly, open <strong class="source-inline">transaction.service.ts</strong> and replace the <strong class="source-inline">findOne()</strong> method with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
findOne(id: number) {
    return this.prisma.transaction.findUnique({
      where: { id },
    });
  }</pre>			<p>Everything <a id="_idIndexMarker490"/>is really simple when it comes to retrieving data, but how about <span class="No-Break">creating it?</span></p>
			<p>We have a <strong class="source-inline">POST</strong> endpoint in <strong class="source-inline">transaction.controller.ts</strong> that was automatically <a id="_idIndexMarker491"/>generated when we generated the <span class="No-Break">file itself:</span></p>
			<pre class="source-code">
@Post()
  create(@Body() createTransactionDto:
    CreateTransactionDto) {
      return
      this.transactionService.create(createTransactionDto);
    }</pre>			<p>When our resources were created, <strong class="source-inline">CreateTransactionDTO</strong> was also generated; you can find it inside the <strong class="source-inline">src/transaction/dto</strong> folder. Surprisingly, it has only one <span class="No-Break">class declaration:</span></p>
			<pre class="source-code">
export class CreateTransactionDto {}</pre>			<p>You should manually add the required properties into the class. Our DTOs just transfer data from the source to the destination. DTOs are used in various programming languages and frameworks, not specific to NestJS. They act as a way to efficiently transfer data between different layers of an application. We also have a validation possibility before getting data from the user and creating DTOs based on this data. That is why we will use the <strong class="source-inline">class-validator</strong> package to validate our data. To install it, run the <a id="_idIndexMarker492"/>following command from <span class="No-Break">the terminal:</span></p>
			<pre class="console">
npm install class-validator</pre>			<p>Open <strong class="source-inline">create-transaction.dto.ts</strong> and <a id="_idIndexMarker493"/>add the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
import { IsString, IsOptional, IsEnum, IsNotEmpty,IsUUID }
  from 'class-validator';
enum Status {
    CREATED = 'CREATED',
      SETTLED= 'SETTLED',
    FAILED = 'FAILED',
    }
export class CreateTransactionDto {
  @IsNotEmpty()
  @IsEnum(Status)
  status: Status;
  @IsUUID()
  @IsNotEmpty()
  accountID: string;
  @IsOptional()
  @IsString()
  description?: string;
}</pre>			<p>Update your <strong class="source-inline">POST</strong> method (<strong class="source-inline">transaction.controller.ts</strong>) to accept <strong class="source-inline">CreateTransactionDTO</strong> and <span class="No-Break">execute it:</span></p>
			<pre class="source-code">
@Post()
  create(@Body() createTransactionDto:
    CreateTransactionDto) {
      return
      this.transactionService.create(createTransactionDto);
    }</pre>			<p>Now, let’s <a id="_idIndexMarker494"/>run our application. From Swagger UI, open <strong class="source-inline">POST/ transaction</strong> and <a id="_idIndexMarker495"/>provide the following <span class="No-Break">JSON payload:</span></p>
			<pre class="source-code">
{
  "status": "CREATED",
  "accountId": "662c081370bd2ba6b5f04e94",
  "description": "Optional transaction description"
}</pre>			<p>Click the <strong class="bold">Execute</strong> button, and here we are (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.17</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 6.17: Successful transaction creation" src="image/B09148_06_017.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17: Successful transaction creation</p>
			<p>Starting from <a id="_idIndexMarker496"/>the next section, we will explore how to establish communication <a id="_idIndexMarker497"/>between the transaction and <span class="No-Break">account microservices.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Establishing synchronous communication with the account microservice</h1>
			<p>We’re <a id="_idIndexMarker498"/>done with the transaction service, but the only thing missing is our account service. The transaction <a id="_idIndexMarker499"/>service allows us to specify an <strong class="source-inline">accountId</strong> value and status from the payload. We need to make the <span class="No-Break">following changes:</span></p>
			<ul>
				<li>Verify if the provided <strong class="source-inline">accountId</strong> exists and is in a valid state (new <span class="No-Break">or active)</span></li>
				<li>If <strong class="source-inline">accountId</strong> is valid, then create a transaction with the <span class="No-Break"><strong class="source-inline">Created</strong></span><span class="No-Break"> status</span></li>
				<li>If <strong class="source-inline">accountId</strong> is invalid, then create a transaction with the <span class="No-Break"><strong class="source-inline">Failed</strong></span><span class="No-Break"> status</span></li>
			</ul>
			<p>The purpose here is not to fully implement the transaction domain. Of course, the current domain has more requirements than the previous one, but our focus is to practice and establish synchronous communication between the transaction and <span class="No-Break">account services.</span></p>
			<p>We have already talked about the pros and cons of synchronous communication between microservices. While asynchronous communication offers many benefits for microservices, there are situations where synchronous communication might be a better fit. If the interaction between microservices requires straightforward logic and an immediate response, synchronous communication can be easier to implement. Also, it is beneficial to use it for user interactions where you need to display information or confirm an action right away. It creates tight coupling, but in some cases, microservices might <a id="_idIndexMarker500"/>be tightly coupled and rely heavily on each other’s results to complete a task. Synchronous communication allows for a more controlled flow, ensuring one service doesn’t proceed until <a id="_idIndexMarker501"/>the other provides the necessary information. Synchronous communication can be easier to debug at times. Since the entire interaction happens in one go, tracing errors and understanding the flow of data is more straightforward. This can be helpful during development or troubleshooting <span class="No-Break">specific issues.</span></p>
			<p>To communicate with the account service, we need an HTTP client package. One of the most used packages is <strong class="source-inline">axios</strong>. Let’s install it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">npm</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
npm i --save @nestjs/axios axios</pre>			<p>Now, we need to import <strong class="source-inline">HttpModule</strong> from <strong class="source-inline">axios</strong> and import it from <strong class="source-inline">transaction.module.ts</strong>. Here is the final code in <span class="No-Break">this file:</span></p>
			<pre class="source-code">
import { Module } from '@nestjs/common';
import { TransactionService } from './transaction.service';
import { TransactionController } from
  './transaction.controller';
import { PrismaModule } from '../prisma/prisma.module';
import { HttpModule } from '@nestjs/axios';
@Module({
  imports: [PrismaModule,HttpModule],
  controllers: [TransactionController],
  providers: [TransactionService],
})
export class TransactionModule {}</pre>			<p>After importing <strong class="source-inline">HttpModule</strong> from <strong class="source-inline">transaction.module.ts</strong>, we’re able to use <strong class="source-inline">HttpService</strong> from <strong class="source-inline">axios</strong> in <strong class="source-inline">transaction.service.ts</strong>. Let’s import and inject it as <a id="_idIndexMarker502"/>a service for the transaction service. Open <strong class="source-inline">transaction.service.ts</strong> and change the <a id="_idIndexMarker503"/>code to have the <span class="No-Break">following lines:</span></p>
			<pre class="source-code">
import { Injectable } from '@nestjs/common';
import { CreateTransactionDto } from
  './dto/create-transaction.dto';
import { PrismaService } from 'src/prisma/prisma.service';
import { HttpService } from '@nestjs/axios';
import { AccountApiResponse } from './dto/account.dto';
@Injectable()
export class TransactionService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly httpService: HttpService) {}
//the rest of the code</pre>			<p>As our business requires, we need to remove the status property from <strong class="source-inline">createTransactionDto</strong> because, depending on the account service, we should internally define the status of the transaction. That is why we’re going to remove the status from <strong class="source-inline">src/transaction/dto/create-transaction.dto</strong>. The following is the final version of <span class="No-Break">this file:</span></p>
			<pre class="source-code">
import { IsString, IsOptional, IsNotEmpty,IsUUID } from 
  'class-validator';
export class CreateTransactionDto {
  @IsUUID()
  @IsNotEmpty()
  accountId: string;
  @IsOptional()
  @IsString()
  description?: string;
}</pre>			<p>Great! Now, let’s <a id="_idIndexMarker504"/>open our <strong class="source-inline">transaction.service.ts</strong> file again and change our <em class="italic">create</em> functionality. After injecting <strong class="source-inline">httpService</strong>, we should be able to make a request to any <a id="_idIndexMarker505"/>service and get a <span class="No-Break">response back.</span></p>
			<p>Here is what we plan <span class="No-Break">to do:</span></p>
			<ul>
				<li>Make a request to the account service’s <strong class="source-inline">http://url/v1/accounts/{account_id}</strong> endpoint and account information based on the provided ID from <span class="No-Break">the endpoint</span></li>
				<li>If the given account by <strong class="source-inline">accountId</strong> doesn’t exist, we throw <span class="No-Break">an exception</span></li>
				<li>If the account exists, and its status is either <strong class="source-inline">'new'</strong> or <strong class="source-inline">'active'</strong>, then the transaction should be created with a <strong class="source-inline"> '</strong><span class="No-Break"><strong class="source-inline">CREATED' </strong></span><span class="No-Break">status</span></li>
				<li>If the account exists, and its status is neither <strong class="source-inline">'new'</strong> nor <strong class="source-inline">'active'</strong>, we should create a transaction with a <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">FAILED' </strong></span><span class="No-Break">status</span></li>
			</ul>
			<p>That is simply it. Open <strong class="source-inline">transaction.service.ts</strong> and update it with the following <span class="No-Break">code lines:</span></p>
			<pre class="source-code">
import { Injectable } from '@nestjs/common';
import { CreateTransactionDto } from
  './dto/create-transaction.dto';
import { PrismaService } from 'src/prisma/prisma.service';
import { HttpService } from '@nestjs/axios';
import { AccountApiResponse } from './dto/account.dto';
@Injectable()
export class TransactionService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly httpService: HttpService,
  ) {}
 async create(createTransactionDto: CreateTransactionDto) {
  const { accountId, description } = createTransactionDto;
  let accountApiResponse = await
    this.httpService.axiosRef.get&lt;AccountApiResponse&gt;(
      `http://localhost:3001/v1/accounts/${createTransactionDto.accountId}`,
      );
     const {account} = accountApiResponse.data;
     if (!account) {
      throw new Error('Transaction creation failed: Account
        not found');
    }
      if(account.status == 'new' || account.status ==
        'active')
        {
          return this.prisma.transaction.create({
            data: { accountId, description, status:
              'CREATED' },
          });
        }
        else
        {
          return this.prisma.transaction.create({
            data: { accountId, description, status:
              'FAILED' },
          });
        }
  }
//rest of the functionalities
}</pre>			<p>The <a id="_idIndexMarker506"/>last thing <a id="_idIndexMarker507"/>we need <a id="_idIndexMarker508"/>to do is to configure <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>) in the account service. Follow the <span class="No-Break">next steps:</span></p>
			<ol>
				<li>Open your account service from <span class="No-Break">VS Code.</span></li>
				<li> From the menu, select <strong class="bold">Terminal</strong> | <span class="No-Break"><strong class="bold">New Terminal</strong></span><span class="No-Break">.</span></li>
				<li> Navigate to the <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder.</span></li>
				<li> Execute <strong class="source-inline">npm install cors</strong> to install the <span class="No-Break"><strong class="source-inline">cors</strong></span><span class="No-Break"> package.</span></li>
				<li> Open <strong class="source-inline">app.js</strong> and add the following code after the <strong class="source-inline">app</strong> object <span class="No-Break">is created:</span><pre class="source-code">
const corsOptions = {
    origin: 'http://localhost:3001', //(https://your-client-app.com)
    optionsSuccessStatus: 200,
};
app.use(cors(corsOptions));</pre></li>			</ol>
			<p>The <a id="_idIndexMarker509"/>final code <a id="_idIndexMarker510"/>in <strong class="source-inline">app.js</strong> should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const express = require('express');
const v1 = require('./routes/v1');
const cors = require('cors');
const app = express();
//added while implementing transaction service, for Ch06
const corsOptions = {
    origin: 'http://localhost:3001', //(https://your-client-app.com)
    optionsSuccessStatus: 200,
};
app.use(cors(corsOptions));
// service
app.use(express.json());
// V1 API
app.use('/v1', v1);
module.exports = app;</pre>			<p>Before running our application, make sure of <span class="No-Break">the following:</span></p>
			<ul>
				<li>Your account service lives <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">localhost:3001</strong></span></li>
				<li>The account service has at least one piece of valid account information in <span class="No-Break">your table</span></li>
				<li>Make sure that Docker is running and the <strong class="source-inline">postgres</strong> container <span class="No-Break">is active</span></li>
			</ul>
			<p>Go <a id="_idIndexMarker511"/>to our account <a id="_idIndexMarker512"/>service and run it (for more details, check <a href="B09148_05.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>). Run our newly created transaction service using <strong class="source-inline">npm run start:dev</strong>. Open your favorite browser, and navigate to <strong class="source-inline">http://localhost:3000/api</strong>. Open <strong class="source-inline">POST /transaction</strong> and add the <span class="No-Break">following payload:</span></p>
			<pre class="source-code">
{
"accountId": "663fd142ecbdce73baf1ed1a",
 "description": "Optional transaction description"
}</pre>			<p>The <strong class="source-inline">accountId</strong> value you provided from the payload should exist in the account service to have a successful operation. In the case of a successful request, you will get the <span class="No-Break">following response:</span></p>
			<pre class="source-code">
{
  "id": {your_transaction_id},
  "status": "CREATED",
  "accountId": "663fd142ecbdce73baf1ed1a",
  "description": "Optional transaction description",
  "createdAt": "2024-05-12T17:21:38.727Z",
  "updatedAt": "2024-05-12T17:21:38.727Z"
}</pre>			<p>If <a id="_idIndexMarker513"/>the service <a id="_idIndexMarker514"/>is not available and the account doesn’t exist, you will get errors. We didn’t cover exception handling in this chapter, but we’ll learn about it in our <span class="No-Break">upcoming chapters.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/>Summary</h1>
			<p>Another microservice journey ends here. The main points in this chapter were creating a second microservice and establishing synchronous communication between microservices. We started our chapter with business requirements. After getting a clear understanding of what we should do, we started to introduce main stack tools to develop our transaction microservice. We didn’t use the tools we used before to develop our account service. JavaScript has really rich tools and frameworks to use when it comes to developing microservices. To demonstrate the beauty of having multiple tools, we used NestJS with some popular packages such as Prisma and Axios. In the end, we established communication with an already existing microservice (the account microservice) using a synchronous communication model. Of course, we still missed out a lot. We didn’t cover exception handling, resiliency, and a lot of other interesting topics that we plan to introduce in our <span class="No-Break">upcoming chapters.</span></p>
			<p><a href="B09148_07.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> explores how to implement asynchronous communication in JavaScript microservices using Apache Kafka and NestJS, focusing on building scalable systems, configuring Kafka, and adapting services like transaction and account services for <span class="No-Break">asynchronous messaging.</span></p>
		</div>
	</body></html>