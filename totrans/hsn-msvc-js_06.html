<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-103"><a id="_idTextAnchor104"/>6</h1>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/>Synchronous Microservices</h1>
			<p>We implemented our first microservice in the previous chapter, but to demonstrate microservice communication, we need to run at least one more service. To understand the beauty of JavaScript in microservice development, we will use a different Node.js framework called NestJS for the current chapter.</p>
			<p>As we discussed earlier, microservice architecture consists of multiple services, and one of the complexities that this approach brings with it is communication. We already know that microservices, while offering advantages in scalability and development, introduce a layer of complexity in communication compared to monolithic applications. Unlike monolithic applications, where everything runs together, microservices communicate over a network. This introduces challenges in <em class="italic">latency</em> (the time it takes for a request to be processed and a response to be received), <em class="italic">reliability</em> (since network issues can disrupt communication), and <em class="italic">security</em> (since you need to secure communication between services).</p>
			<p>In this chapter, we will delve into details of synchronous communication between microservices in practice and learn the use cases of synchronous communication between services.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Understanding the requirements for the transaction microservice</li>
				<li>Tools to develop the transaction microservice</li>
				<li>Hands-on transaction microservice development</li>
				<li>Establishing synchronous communication with the account microservice</li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>To develop and test the second microservice, we need the following:</p>
			<ul>
				<li>IDE (we <a id="_idIndexMarker389"/>prefer <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>))</li>
				<li>Postman</li>
				<li>Browser of your choice</li>
			</ul>
			<p>It is recommended to download our repository from <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript</a> and open the <code>Ch06</code> folder to easily follow our code snippets.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Understanding the requirements for the transaction microservice</h1>
			<p>Everything starts from the requirements. Software requirements are basically instructions <a id="_idIndexMarker390"/>that tell programmers exactly what a software program needs to do. They’re like a recipe for the program, outlining the ingredients (features) and steps (functions) needed. Before starting our development, we need to understand our requirements.</p>
			<p>The system consists of two main microservices:</p>
			<ul>
				<li><strong class="bold">Transaction microservice</strong>: This microservice will be responsible for processing <a id="_idIndexMarker391"/>transactions. It will receive transaction information, validate the account associated with the transaction, and process the transaction.</li>
				<li><strong class="bold">Account microservice</strong>: This <a id="_idIndexMarker392"/>microservice will provide account information and validation functionality. We implemented this service in <a href="B09148_05.xhtml#_idTextAnchor074"><em class="italic">Chapter 5</em></a>. It is responsible for verifying if an account exists and is in good standing.</li>
			</ul>
			<p>The transaction microservice will communicate with the account microservice to validate the provided <code>accountId</code> value. The account microservice will verify if the <code>accountId</code> value exists.</p>
			<p>The transaction should be successful only if the account exists and is in an <em class="italic">active</em> or a <em class="italic">new</em> state.  For other states, we should add a new row to the transaction service with the <em class="italic">FAILED</em> state:</p>
			<div><div><img alt="Figure 6.1: Communication between transaction and account microservices" src="img/B09148_06_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Communication between transaction and account microservices</p>
			<p>First, we need <a id="_idIndexMarker393"/>to develop our transaction microservice. After having a proper working microservice, we will create synchronous communication between transactions and the previously built account microservice.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Tools to develop the transaction microservice</h1>
			<p>To build our second microservice, we plan to use completely different tools to show that we don’t <a id="_idIndexMarker394"/>depend on concrete tools and technologies even in JavaScript. You can develop the same microservice using different technologies, and having multiple ones in your arsenal allows you to select the optimal stack tools for your development.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>NestJS</h2>
			<p>As a Node.js <a id="_idIndexMarker395"/>framework, we plan to <a id="_idIndexMarker396"/>use NestJS. The official page describes it as “<em class="italic">A progressive Node.js framework for building efficient, reliable and scalable server-side applications</em>.” Although Express.js has been the de facto standard for building web applications with a combination of Node.js, it doesn’t force you to use Express.js for all types of web applications.</p>
			<p>First things first – NestJS is <a id="_idIndexMarker397"/>another Node.js framework. Check out <a href="B09148_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>’s <em class="italic">Node.js frameworks</em> section to learn more about NestJS. Here’s a summary of what it offers:</p>
			<ul>
				<li>It promotes a <strong class="bold">modular architecture</strong> that allows you to build scalable and easily <a id="_idIndexMarker398"/>organizable applications. You can easily organize your application into modules, components, controllers, and services.</li>
				<li>NestJS is <a id="_idIndexMarker399"/>built on top of <strong class="bold">TypeScript</strong> and uses TypeScript at its core. If you are a big fan of <strong class="bold">strongly typed</strong> tools/languages like me, then it is for you. Strongly typed languages enforce type safety, meaning compiler checks for operations. This can prevent unexpected crashes and incorrect results later.</li>
				<li>NestJS <a id="_idIndexMarker400"/>supports <strong class="bold">validation</strong> out of the box. It validates incoming data, which may be helpful when building APIs.</li>
			</ul>
			<p>Installing all the required applications directly to your computer is not always the best choice. That is why we use Docker. While directly installing applications isn’t inherently wrong, Docker provides a more efficient and manageable approach for certain situations.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor110"/>Docker</h2>
			<p>Docker helps <a id="_idIndexMarker401"/>developers build things such as software programs more easily. Imagine a <a id="_idIndexMarker402"/>box that holds all the tools and parts a program needed to run. This box is like a Docker container. Docker lets you put your program and all its bits and pieces in this box so that it works the same way on any computer.</p>
			<p>Check out <a href="B09148_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a> to learn more about how to set up Docker on your computer.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor111"/>Prisma ORM</h2>
			<p>Prisma is <a id="_idIndexMarker403"/>a next-generation <strong class="bold">Object-Relational Mapper</strong> (<strong class="bold">ORM</strong>). In the world of programming, an ORM acts as <a id="_idIndexMarker404"/>a bridge between two different ways of handling data: <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) and relational databases.</p>
			<p>Prisma, as an <a id="_idIndexMarker405"/>open source ORM, that simplifies database interactions in Node.js applications. It’s like a set of helpful tools that take care of a lot of the complex stuff for you. The good news is, you don’t need to deal with pure SQL queries. Here’s what it offers:</p>
			<ul>
				<li><strong class="bold">Prisma Client</strong>: This tool automatically builds code to access your database, making it <a id="_idIndexMarker406"/>safe and straightforward. It even checks your code for errors as you write it (if you’re using TypeScript).</li>
				<li><strong class="bold">Prisma Migrate</strong>: This tool <a id="_idIndexMarker407"/>helps you define how your database is structured and keeps it up to date as your application changes.</li>
				<li><strong class="bold">Prisma Studio</strong>: This is <a id="_idIndexMarker408"/>a visual tool that lets you see and edit the information stored in your database directly, like a user-friendly dashboard.</li>
			</ul>
			<p>Under the hood, you can use PostgreSQL, MySQL, SQL Server, SQLite, MongoDB, and more. When your application requires migrating from one database to another that Prisma supports, it will not affect your project source code because Prisma abstracts your code from internal details.</p>
			<p>Prisma Client works well with many different ways of building Node.js applications:</p>
			<ul>
				<li>Traditional REST APIs</li>
				<li>Modern GraphQL APIs</li>
				<li>Efficient gRPC APIs</li>
				<li>Any Node.js project that needs to use a database</li>
			</ul>
			<p>In short, Prisma simplifies interacting with databases in Node.js, saving you time and effort. It offers a variety of features to fit your project’s needs.</p>
			<p>Now, we are ready to develop our transaction service, and starting from the next section, we will dive into the details of the development process.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor112"/>Hands-on transaction microservice development</h1>
			<p>The best way of learning from a technical book is by following its instructions. For all practical chapters, it is preferable to follow us along the journey and type every command <a id="_idIndexMarker409"/>with us. Downloading source code from the Git repository and investigating source code is also a good way of learning things in practice.</p>
			<p>Getting started with NestJS is easier than Express.js. It has code generation steps and easy-to-use packages that help you to do a fast development. If you’re looking for a better, modern template to get started, NestJS is one way of achieving it. NestJS provides a built-in command-line tool called the <em class="italic">Nest CLI</em>. It acts as a powerful assistant throughout your NestJS application’s lifecycle. If offers interesting and useful functionalities such as the following:</p>
			<ul>
				<li><strong class="bold">Project initialization</strong>: Quickly set up a new NestJS project with a well-structured <a id="_idIndexMarker410"/>directory layout following best practices.</li>
				<li><strong class="bold">Development support</strong>: Run your application in development mode for hot reloading <a id="_idIndexMarker411"/>and streamlined debugging.</li>
				<li><strong class="bold">Production build</strong>: Bundle <a id="_idIndexMarker412"/>your application for deployment in production environments, optimizing it for efficiency.</li>
				<li><strong class="bold">Code generation</strong>: Generate <a id="_idIndexMarker413"/>various components such as controllers, services, modules, and more using schematics, saving you time and ensuring consistency.</li>
			</ul>
			<p>Let’s begin the development process:</p>
			<ol>
				<li>Create a folder for your project (it is <code>Ch06</code> in our Git repo).</li>
				<li>Open VS Code and open your folder from it.</li>
				<li>Go to the <strong class="bold">Terminal</strong> menu, then select <strong class="bold">New Terminal</strong>.</li>
				<li>Type <code>npm i -g @nestjs/cli</code> and hit <em class="italic">Enter</em>.</li>
			</ol>
			<p>After the NestJS CLI is installed, we can create our project template with a single command. Just type <code>nest new transactionservice</code> and press <em class="italic">Enter</em> again.</p>
			<p>If you <a id="_idIndexMarker414"/>encounter a <code>Cannot Be Loaded Because Running Scripts is Disabled on This System</code> error message while trying to run a script in Windows, follow these steps to resolve it:</p>
			<ol>
				<li><strong class="bold">Open Windows PowerShell</strong>: Press <em class="italic">Win</em> + <em class="italic">X</em> and select <strong class="bold">Windows PowerShell (Admin)</strong> to open it with administrator privileges.</li>
				<li><strong class="bold">Set the execution policy</strong>: In the PowerShell window, type the following command and press <em class="italic">Enter</em>:<pre class="source-code">
<code>Y</code> (for Yes) and press <strong class="bold">Enter</strong> to confirm.</li>
				<li><strong class="bold">Run your script again</strong>: Try running your script once more. The issue should now be resolved.</li>
			</ol>
			<p>You will get a prompt that asks you to select package manager during project setup (<em class="italic">Figure 6</em><em class="italic">.2</em>). We have the following options:</p>
			<ul>
				<li><code>npm</code></li>
				<li>Yarn</li>
				<li>Pnpm</li>
			</ul>
			<p>Our choice is <code>npm</code> for this project. It is a strong contender in the world of package managers, particularly for Node.js projects. It has a massive package registry, is the default for Node.js, and has a large community (<em class="italic">Figure 6</em><em class="italic">.2</em>):</p>
			<div><div><img alt="Figure 6.2: NestJS offers to select a package manager" src="img/B09148_06_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: NestJS offers to select a package manager</p>
			<p>After you’ve <a id="_idIndexMarker415"/>made your selection, the CLI will generate a project template for us (<em class="italic">Figure 6</em><em class="italic">.3</em>):</p>
			<div><div><img alt="Figure 6.3: CLI-generated folder structure for NestJS" src="img/B09148_06_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: CLI-generated folder structure for NestJS</p>
			<p>The <code>src</code> and <code>test</code> folders are not empty and contain the initial project skeleton (<em class="italic">Figure 6</em><em class="italic">.4</em>):</p>
			<div><div><img alt="Figure 6.4: CLI-generated src and test folders" src="img/B09148_06_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: CLI-generated src and test folders</p>
			<p>To run <a id="_idIndexMarker416"/>the generated template successfully, take the following steps:</p>
			<ol>
				<li>Navigate to the <code>transactionservice</code> folder from the terminal using the <code>cd transactionservice</code> command. For all types of commands, we need to navigate to this folder to run them properly. You can simply open the <code>transactionservice</code> folder directly from VS Code if you do not want to type the <code>cd</code> command every time.</li>
				<li>Type <code>npm </code><code>run start:dev</code>.<p class="list-inset">This command starts a special server that helps you see changes quickly. It watches your files closely, and if it sees anything different, it automatically fixes things up and refreshes the server. This means you can see your updates right away without needing to restart everything yourself.</p></li>
				<li>Open your favorite browser and navigate to <code>http://localhost:3000</code> (<em class="italic">Figure 6</em><em class="italic">.5</em>):</li>
			</ol>
			<div><div><img alt="Figure 6.5: Successful NestJS project run result" src="img/B09148_06_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Successful NestJS project run result</p>
			<p>The next <a id="_idIndexMarker417"/>subsections will help us to understand how to prepare our environment and build our microservice easily.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/>Dockerizing your PostgreSQL instance</h2>
			<p><strong class="bold">PostgreSQL</strong> is one <a id="_idIndexMarker418"/>of the best choices when it comes to storing data in the database. We will use Docker to containerize our database, isolating it from other environments.</p>
			<p>Right-click <a id="_idIndexMarker419"/>on your root project folder (it is <code>transactionservice</code> for us) and add a <code>docker-compose.yml</code> file.</p>
			<p>Open this empty file and add the following lines:</p>
			<pre class="source-code">
networks:
  my-app-network:  # Define the network name exactly as used later
services:
  postgres:
    image: postgres
    env_file:
      - .env
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    ports:
      - ${POSTGRES_PORT}:5432
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - my-app-network  # Add the service to the network
  pgadmin:
    image: dpage/pgadmin4
    env_file:
      - .env
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD}
      - POSTGRES_HOST=postgreshost
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - PGADMIN_CONFIG_SERVER_MODE=False
      - PGADMIN_CONFIG_MASTER_PASSWORD_REQUIRED=False
    ports:
      - ${PGADMIN_PORT}:80
    depends_on:
      - postgres
    user: root
    volumes:
      - postgres_data:/var/lib/pgadmin/data
    networks:
      - my-app-network  # Add the service to the network
volumes:
  postgres_data:</pre>			<p>We used <code>docker-compose.yml</code> in <a href="B09148_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a> when we talked about installing Apache Kafka. We have a separate chapter about containerization, but let’s explain the file itself here for more clarity.</p>
			<p>A <code>docker-compose.yml</code> file is a YAML configuration file used to define and manage multi-container <a id="_idIndexMarker420"/>Docker applications. Docker Compose is a tool that allows you to define services, networks, and volumes required for your application in a single file, making it easier to manage complex setups.</p>
			<p>Each <a id="_idIndexMarker421"/>service represents a containerized application component.</p>
			<p>You can <a id="_idIndexMarker422"/>define custom networks for your services to communicate with each other. By default, Docker Compose creates a default network for your application, but you can define custom networks to control communication between specific services.</p>
			<p>You can also define named volumes or mount host directories into containers to persist data or share files between containers.</p>
			<p>Docker Compose allows you to start all your services together with a single command, instead of running services one by one, <code>docker-compose</code> helps you to spin up your entire infrastructure with a single command (<code>docker-compose up</code>) and manage it consistently across different environments.</p>
			<p>This <code>docker-compose.yml</code> file defines a Docker Compose configuration for setting up two services: <code>postgres</code> and <code>pgadmin</code>. Let’s break it down:</p>
			<ul>
				<li><code>networks</code>: This section within your Docker Compose YAML file defines named networks <a id="_idIndexMarker423"/>that can be used by your application’s services. These networks provide a way for containers to communicate with each other in a controlled and isolated manner.</li>
				<li><code>services</code>: This <a id="_idIndexMarker424"/>section defines the services to be created.<ul><li><code>postgres</code>: This service uses the official PostgreSQL Docker image. It sets up a PostgreSQL database container.</li><li><code>image: postgres</code>: Specifies the Docker image to be used for this service.</li><li><code>env_file</code>: Specifies a file from which to read environment variables.</li><li><code>environment</code>: Sets environment variables for the PostgreSQL container, including username, password, and database name.</li><li><code>ports</code>: Maps the container’s PostgreSQL port to a port on the host machine, allowing external access.</li><li><code>volumes</code>: Mounts a volume to persist PostgreSQL data.</li></ul></li>
				<li><code>pgadmin</code>: This <a id="_idIndexMarker425"/>service uses the <code>pgAdmin</code> 4 Docker image to set up a web-based administration interface for PostgreSQL.<ul><li><code>image: dpage/pgadmin4</code>: Specifies the Docker image for <code>pgAdmin</code> 4.</li><li><code>env_file</code>: Similar to the <code>postgres</code> service, this specifies a file from which to read environment variables.</li><li><code>environment</code>: Sets environment variables for <code>pgAdmin</code>, including default email, password, and PostgreSQL connection details.</li><li><code>ports</code>: Maps the container’s port <code>80</code> to a port on the host machine.</li><li><code>depends_on</code>: Specifies that this service depends on the <code>postgres</code> service, ensuring that the PostgreSQL database is available before starting <code>pgAdmin</code>.</li><li><code>user: root</code>: Specifies <a id="_idIndexMarker426"/>that the container should run as the root user.</li><li><code>volumes</code>: Mounts a volume to persist <code>pgAdmin</code> data.</li></ul></li>
				<li><code>volumes</code>: This section <a id="_idIndexMarker427"/>defines a named volume <code>postgres_data</code>, which is used by both services to persist data.</li>
			</ul>
			<p>In the end, this Docker Compose configuration sets up a PostgreSQL database container and a <code>pgAdmin</code> container, providing a convenient way to manage and interact with the PostgreSQL database using a web-based interface. To run your <code>docker-compose</code> file, just navigate to the folder of it and type <code>docker-compose up -d</code> from the terminal.</p>
			<p>Instead of <a id="_idIndexMarker428"/>directly adding credentials/values to the <code>docker-compose</code> file, we can specify it from a <code>.env</code> file (we have already talked about this file), and Docker can read the required data from environment variables. Just create a <code>.env</code> file inside your main folder (it is the <code>transactionservice</code> folder for us) and add the missing configuration for Docker to run successfully:</p>
			<pre class="source-code">
# PostgreSQL settings
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=tservice_db
POSTGRES_PORT=5438
# pgAdmin settings
PGADMIN_DEFAULT_EMAIL=admin@tservice.com
PGADMIN_DEFAULT_PASSWORD=tservice_password
PGADMIN_PORT=5050</pre>			<p>We now have our PostgreSQL database up and running. In most cases, developers prefer not to directly interact with databases using SQL queries. Not all developers have a solid understanding of SQL, and even so, using pure SQL queries to manipulate to database in most cases is not a good choice nowadays. Instead, we have various packages available that abstract away the complexity of raw SQL, enabling us to create beautiful applications without needing deep expertise in SQL. One of these packages is Prisma. As we mentioned before, Prisma is an open source ORM that automates and abstracts most of the operations you need to do when you deal with a database.</p>
			<p>To <a id="_idIndexMarker429"/>start work with Prisma, we need a <em class="italic">CLI</em>. Prisma CLI is a combination of tools that help us migrate, seed, and do additional database-oriented operations easily. You just need to run the <code>npm install prisma -D</code> command from the terminal. After executing the command, <code>npm</code> should successfully install Prisma CLI as a dev dependency. You can check <code>package.json</code>’s <code>devDependencies</code> section.</p>
			<p>After Prisma CLI, it is time to install Prisma itself. The <code>npx prisma init</code> command handles the initialization of the Prisma package. It will create an additional folder called <code>prisma</code> with a <code>schema.prisma</code> file and a <code>.env</code> file. In our case, we already have a <code>.env</code> file, so running the preceding command will end up updating our existing <code>.env</code> file. Open your <code>.env</code> file, and at the end of the file, update the value of <code>DATABASE_URL</code>:</p>
			<pre class="source-code">
DATABASE_URL="postgres://postgres:postgres@localhost:5438/tservice_db"</pre>			<p>At the <a id="_idIndexMarker430"/>heart of your Prisma setup lies the <code>schema.prisma</code> file. This file uses <strong class="bold">Prisma Schema Language</strong> (<strong class="bold">PSL</strong>), a declarative approach to defining your database structure.  It acts as the central configuration for Prisma, specifying both your database connection and the generation of the Prisma Client API. The following code demonstrates how to define a simple schema file for Prisma:</p>
			<pre class="source-code">
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}</pre>			<p>The <code>schema.prisma</code> file, written in PSL, acts as your database blueprint with three key sections:</p>
			<ul>
				<li><code>generator</code>: This <a id="_idIndexMarker431"/>section configures the Prisma Client generator. The Prisma Client, a powerful API, is then generated to help you access your database.</li>
				<li><code>datasource</code>: Here, you <a id="_idIndexMarker432"/>define the database connection details. This includes the database provider and the connection string, often leveraging the <code>DATABASE_URL</code> environment variable for convenience.</li>
				<li><code>Model:</code> This is <a id="_idIndexMarker433"/>where the heart of your database schema lies. You define the structure of your data by specifying tables and their corresponding fields.</li>
			</ul>
			<p>The next <a id="_idIndexMarker434"/>section describes how to model your data inside the <code>schema.prisma</code> file.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/>Modeling the data</h2>
			<p>The <code>schema.prisma</code> file is the main place where we need to add our models. Modeling <a id="_idIndexMarker435"/>is a special <a id="_idIndexMarker436"/>language over SQL. It isolates you from the internals of SQL and provides data in a more human-readable language.</p>
			<p>Open the <code>schema.prisma</code> file under the <code>prisma</code> folder and add the following model structure:</p>
			<pre class="source-code">
model Transaction {
  id           Int      @id @default(autoincrement())
  status       Status
  accountId    String   @default(uuid())
  description  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}
enum Status {
  CREATED
  SETTLED
  FAILED
}</pre>			<p>The <a id="_idIndexMarker437"/>provided code defines <a id="_idIndexMarker438"/>a Prisma model named <code>Transaction</code> and an <code>enum</code> named <code>Status</code> within your NestJS application schema.</p>
			<p>Here’s a breakdown of each section:</p>
			<ul>
				<li><code>id</code>: This field represents the unique identifier for each transaction. It’s of type <code>Int</code> and is automatically marked as the primary key with the <code>@id</code> directive. Additionally, <code>@default(autoincrement())</code> ensures a new, unique ID is generated for each transaction automatically.</li>
				<li><code>status</code>: This field defines the current state of the transaction. It’s of type <code>Status</code>, which will reference <code>Status </code><code>Enumeration(enum Status)</code>.</li>
				<li><code>accountId</code>: This field stores the identifier for the associated account involved in the <a id="_idIndexMarker439"/>transaction. It’s of type <code>String</code> and uses <code>@default(uuid())</code> to generate a <strong class="bold">universally unique identifier</strong> (<strong class="bold">UUID</strong>) by default.</li>
				<li><code>description</code>: This optional field allows for storing a brief description of the transaction. It’s of type <code>String?</code>, indicating it can be <code>null</code>.</li>
				<li><code>createdAt</code>: This field captures the timestamp of when the transaction was created. It’s of type <code>DateTime</code> and uses <code>@default(now())</code> to automatically set the creation time to the current moment.</li>
				<li><code>updatedAt</code>: This field is automatically updated whenever the transaction record is modified. It’s of type <code>DateTime</code> and uses the <code>@updatedAt</code> directive to achieve this behavior.</li>
			</ul>
			<p>OK – but how to generate SQL based on the model we defined in <code>schema.prisma</code>?</p>
			<p>Run <code>npx prisma migrate dev --name init</code> from the command line (VS Code terminal) to start <a id="_idIndexMarker440"/>the migration journey. In the context of NestJS and Prisma, <strong class="bold">migration</strong> refers to <a id="_idIndexMarker441"/>a process that manages changes to your database schema over time.</p>
			<p>Here <a id="_idIndexMarker442"/>is a breakdown of the command:</p>
			<ul>
				<li><code>npx prisma migrate dev</code>: This command invokes the Prisma migration tool in development mode.</li>
				<li><code>--name init</code>: This option specifies the name of the new migration. Here, it’s set to <code>init</code>, likely signifying the initial setup of your database schema.</li>
			</ul>
			<p>By running this command, you’re essentially creating a starting point for managing your database schema changes using Prisma migrations. As you make modifications to your <code>schema.prisma</code> file, Prisma will automatically generate new migrations to reflect those changes.</p>
			<p>The command will end up creating a <code>migrations</code> folder with a <code>migration.sql</code> file (<em class="italic">Figure 6</em><em class="italic">.6</em>):</p>
			<div><div><img alt="Figure 6.6: Automatically generated migration structure" src="img/B09148_06_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: Automatically generated migration structure</p>
			<p>Check the generated <code>migration.sql</code> file:</p>
			<pre class="source-code">
-- CreateEnum
CREATE TYPE "Status" AS ENUM ('CREATED', 'SETTLED', 'FAILED');
-- CreateTable
CREATE TABLE "Transaction" (
    "id" SERIAL NOT NULL,
    "status" "Status" NOT NULL,
    "accountId" TEXT NOT NULL,
    "description" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    CONSTRAINT "Transaction_pkey" PRIMARY KEY ("id")
);</pre>			<p>Now, you <a id="_idIndexMarker443"/>should have tables <a id="_idIndexMarker444"/>with the name <code>Transaction</code> and <code>_prisma_migrations</code> in your database. It may take a few seconds for Docker to set up the services, so a brief wait might be necessary. To check this, let’s do the following operations:</p>
			<ol>
				<li>Open Docker Desktop and ensure all services are running.</li>
				<li>Click on the <code>postgres</code> container.</li>
				<li>From the <code>172.26.0.2</code>):</li>
				<li>Navigate to <code>http://localhost:5050/browser/</code> from your browser.</li>
				<li>Right-click on <strong class="bold">Servers</strong>, then select <strong class="bold">Register</strong> | <strong class="bold">Server</strong> from the menu.</li>
				<li>Under the <code>localhost</code> for its value.</li>
				<li>Go to <a id="_idIndexMarker445"/>the <code>172.26.0.2</code> for us)</li><li><code>5432</code></li><li><code>tservice_db</code></li><li><code>postgres</code></li><li><code>postgres</code></li></ul></li>
			</ol>
			<div><div><img alt="Figure 6.7: Server registration window for postgres" src="img/B09148_06_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7: Server registration window for postgres</p>
			<ol>
				<li value="8">Click the <strong class="bold">Save</strong> button, and your server connection should be successful.</li>
				<li>Now, expand <code>localhost</code> (or your name) | <code>tservice_db</code> | <strong class="bold">Schemas</strong> | <strong class="bold">Public</strong> | <strong class="bold">Tables</strong> (<em class="italic">Figure 6</em><em class="italic">.8</em>):</li>
			</ol>
			<div><div><img alt="Figure 6.8: postgres tables after migration via Prisma" src="img/B09148_06_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8: postgres tables after migration via Prisma</p>
			<ol>
				<li value="10">If you <a id="_idIndexMarker447"/>have locally installed  <code>pgAdmin</code>, to connect to your Docker <code>postgres</code> instance, just enter <a id="_idIndexMarker448"/>the following to the server registration window for <code>postgres</code> (<em class="italic">Figure 6</em><em class="italic">.7</em>):<ul><li><code>localhost</code></li><li><code>5438</code></li><li><code>tservice_db</code></li><li><code>postgres</code></li><li><code>postgres</code></li></ul></li>
				<li>Click the <strong class="bold">Save</strong> button, and your server connection should be successful.</li>
			</ol>
			<p>The <code>_prisma_migrations</code> table you see when using NestJS and Prisma ORM plays a crucial role in managing database schema changes. It has the following responsibilities:</p>
			<ul>
				<li>Tracks applied database migrations</li>
				<li>Ensures migrations are applied only once</li>
				<li>Maintains consistency between your Prisma schema and the actual database structure</li>
			</ul>
			<p>Each time you run a Prisma migration, a new entry is added to the <code>_prisma_migrations</code> table.</p>
			<p>When Prisma needs to apply migrations, it checks the <code>_prisma_migrations</code> table to see which migrations have already been run based on the unique hash.</p>
			<p>This <a id="_idIndexMarker449"/>prevents applying the same <a id="_idIndexMarker450"/>migration multiple times, potentially corrupting your data.</p>
			<p>Modifying the <code>_prisma_migrations</code> table manually can lead to inconsistencies and errors. Don’t edit, delete, or modify it. This table is essential for Prisma to manage migrations effectively.</p>
			<p>Long story short, the <code>_prisma_migrations</code> table acts as a logbook for your database schema changes, ensuring a smooth and controlled migration process.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor115"/>Seeding test data</h2>
			<p>Seeding data involves populating your database with an initial set of data. If you want your <a id="_idIndexMarker451"/>database to have <a id="_idIndexMarker452"/>initial data before running your application, you may apply seeding.</p>
			<p>Add a <code>seed.ts</code> file under the <code>prisma</code> folder with the following content:</p>
			<pre class="source-code">
// prisma/seed.ts
import { PrismaClient } from '@prisma/client';
// initialize Prisma Client
const prismaClient = new PrismaClient();
async function seedData() {
  // create two dummy recipes
  const first_transaction = await
    prismaClient.transaction.upsert({
    where: { id:1 },
    update: {},
    create: {
      id:1,
      status: 'CREATED',
      accountId: '662c081370bd2ba6b5f04e94',
      description: 'simple transaction',
    }
  });
  console.log(first_transaction);
}
// execute the seed function
seedData()
  .catch(e =&gt; {
    console.error(e);
    process.exit(1);
  })
  .finally(async () =&gt; {
    // close Prisma Client at the end
    await prismaClient.$disconnect();
  });</pre>			<p>Go <a id="_idIndexMarker453"/>to <code>package.json</code> and add <a id="_idIndexMarker454"/>the following after <code>devDependencies</code>:</p>
			<pre class="source-code">
"prisma": {
    "seed": "ts-node prisma/seed.ts"
  }</pre>			<p>Now, open the terminal window and type the <code>npx prisma db seed</code> command. You should see a message that indicates a successful operation (<em class="italic">Figure 6</em><em class="italic">.9</em>):</p>
			<div><div><img alt="Figure 6.9: Executing seed" src="img/B09148_06_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9: Executing seed</p>
			<p>Open <a id="_idIndexMarker455"/>the <code>Transaction</code> table <a id="_idIndexMarker456"/>using <code>PgAdmin</code>, and you’ll see your first successfully inserted row (<em class="italic">Figure 6</em><em class="italic">.10</em>):</p>
			<div><div><img alt="Figure 6.10: Transaction table after seed" src="img/B09148_06_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10: Transaction table after seed</p>
			<p>It is time to explain what we have inserted into our <code>seed.ts</code> file:</p>
			<ul>
				<li><code>PrismaClient from @prisma/client</code>: This line imports the necessary class to interact with our database schema using Prisma.</li>
				<li><code>const prismaClient = new PrismaClient()</code>: Here, we create an instance of the <code>PrismaClient</code> class, which will be used to perform database operations.</li>
				<li><code>async function seedData() { ... }</code>: This function is the heart of the script and is marked <code>async</code> because it includes asynchronous operations that involve interacting with the database.</li>
				<li><code>const first_transaction = await prismaClient.transaction.upsert({ ... })</code>: This line performs the core seeding operation.</li>
				<li><code>prismaClient.transaction</code>: This part accesses the transaction model of your <a id="_idIndexMarker457"/>Prisma schema <a id="_idIndexMarker458"/>through the initialized client.</li>
				<li><code>.upsert({ ... }):</code> The <code>upsert</code> method is a convenient way to create or update a record in the database. It checks for existing data based on the provided <code>where</code> clause and performs the appropriate action.</li>
				<li>If a record with <code>id: 1</code> (assuming your schema has an ID field) already exists, the following happens:<ul><li>The <code>update</code> object (empty here) would be used to update the existing record (but since it’s empty, no update happens) if a record with <code>id: </code><code>1</code> exists.</li><li>The <code>create</code> object defines the data for the new transaction record if a record with an ID doesn’t exist.<ul><li><code>create Object (Seed Data)</code>: This object defines the details of the dummy transaction to be created.</li><li><code>id: 1</code>: Sets the ID of the transaction to 1 (replace with a unique value if needed).</li><li><code>status: 'CREATED'</code>: Sets the initial status of the transaction to <code>CREATED</code>.</li><li><code>accountId: '662c081370bd2ba6b5f04e94'</code>: Assigns an account ID to the transaction (you can use any ID).</li><li><code>description: 'simple transaction'</code>: Provides a descriptive text for the transaction.</li></ul></li></ul></li>
			</ul>
			<p>To <a id="_idIndexMarker459"/>apply business rules <a id="_idIndexMarker460"/>to our application, we need to add an extra layer over a database, and it is going to be our service layer. The next section will introduce a service layer for the transaction database.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor116"/>Implementing the transaction service</h2>
			<p>We are done with the database. As a classical development style, it is time to create a service <a id="_idIndexMarker461"/>over our database. Creating a service layer is simple with NestJS, especially if you deal with Prisma ORM.</p>
			<p>First, let’s create <a id="_idIndexMarker462"/>our module using the <code>npx nest generate module </code><code>prisma</code> command.</p>
			<p>This Prisma CLI command should generate a new folder called <code>prisma</code> and should generate a <code>prisma.module.ts</code> file under this folder. This command also will affect your <code>app.module.js</code> file under the <code>src</code> folder.</p>
			<p>We need one more command to run to generate our service files:</p>
			<pre class="console">
Npx nest generate service prisma</pre>			<p>This command will create <code>prisma.service.ts,prisma.service.spec.ts</code> files under <code>src/prisma</code> and update the <code>prisma.module.ts</code> file.</p>
			<p>For this chapter, you can remove all files that have <code>.spec.ts</code> extensions from the project. These files contain unit tests for the application’s components, typically services and controllers. We have a separate chapter to work with unit tests; for the chapter’s simplicity, we don’t need them. For now, replace the content of <code>prisma.service.ts</code> with the following:</p>
			<pre class="source-code">
import { Injectable } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
@Injectable()
export class PrismaService extends PrismaClient {}</pre>			<p>In <a id="_idIndexMarker463"/>this code, we <a id="_idIndexMarker464"/>have a straightforward implementation for the <code>prisma</code> service:</p>
			<ul>
				<li><code>import { Injectable } from '@nestjs/common';</code>: This line imports the <code>Injectable</code> decorator from the <code>@nestjs/common</code> module. This <a id="_idIndexMarker465"/>decorator marks the class as a NestJS injectable service, making it available for <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) in other parts of your application.</li>
				<li><code>import { PrismaClient } from '@prisma/client';</code>: This line imports the <code>PrismaClient</code> class from the <code>@prisma/client</code> package. This class provides an interface for interacting with your database using Prisma queries.</li>
				<li><code>@Injectable()</code>: This decorator applied to the class declaration marks it as a NestJS injectable service. NestJS will manage the lifecycle of this service and provide it to other components that require database access.</li>
				<li><code>export class PrismaService extends PrismaClient {}</code>: This line defines the <code>PrismaService</code> class. It inherits from the <code>PrismaClient</code> class, giving it access to all the database interaction methods provided by Prisma.</li>
			</ul>
			<p>In essence, this code creates a service specifically for interacting with our database through Prisma. This service can then be injected into other parts of our application (such as controllers) to perform database operations.</p>
			<p>The <code>prisma.service.ts</code> file acts as a wrapper over the Prisma client. It is an injectable element that we can use to inject it into modules.</p>
			<p>Let’s update our <code>prisma.module.ts</code> file to have the following content:</p>
			<pre class="source-code">
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';
@Module({
  providers: [PrismaService],
  exports: [PrismaService]
})
export class PrismaModule {}</pre>			<p>To <a id="_idIndexMarker466"/>make the Prisma service accessible throughout your NestJS application, you’ll need to <a id="_idIndexMarker467"/>create a dedicated module. This module will import the <code>PrismaService</code> class and provide it for injection into other modules or components. That is the reason why we have a <code>prisma.module.ts</code> file.</p>
			<p>Nowadays, it is popular to use a UI for APIs, and it allows us to document and easily use endpoints. One of the packages that allows us to do it is Swagger. The next section explains how to integrate Swagger for our endpoints.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor117"/>Configuring Swagger</h2>
			<p>To <a id="_idIndexMarker468"/>have visible documentation and visual usage for our APIs, we will configure Swagger UI.</p>
			<p>Open the <a id="_idIndexMarker469"/>VS Code terminal and type the following:</p>
			<pre class="console">
npm install --save @nestjs/swagger swagger-ui-express</pre>			<p>Open <code>src/main.ts</code> and update its content with the following to integrate Swagger:</p>
			<pre class="source-code">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
// bootstrap function
async function bootstrap() {
  // Create a NestJS application instance
  const app = await NestFactory.create(AppModule);
  // new Swagger document configuration
  const config = new DocumentBuilder()
    .setTitle('Transaction API') // title of the API
    .setDescription('Transaction API description')
    // description of the API
    .setVersion('1.0') // version of the API
    .build(); // Build the document
  // Create a Swagger document
  const document = SwaggerModule.createDocument(app,
    config);
  // Setup Swagger module
  SwaggerModule.setup('api', app, document);
  // Start the application and listen for requests on port 3000
  await app.listen(3000);
}
// Call the bootstrap function to start the application
bootstrap();</pre>			<p>Let’s <a id="_idIndexMarker470"/>understand <a id="_idIndexMarker471"/>this code here:</p>
			<ul>
				<li><code>NestFactory</code> from <code>@nestjs/core</code>: This import provides the core functionality for creating a NestJS application instance.</li>
				<li><code>AppModule</code> from <code>./app.module</code>: This imports your main application module, where all the necessary components and services of your NestJS application are defined.</li>
				<li><code>SwaggerModule</code> and <code>DocumentBuilder</code> from <code>@nestjs/swagger</code>: These <a id="_idIndexMarker472"/>imports are used for integrating Swagger documentation with your NestJS application.</li>
				<li>Bootstrap function (<code>async</code>):<ul><li>This <a id="_idIndexMarker473"/>function is marked as <code>async</code> because it involves asynchronous operations such as creating an application instance and listening for incoming requests.</li><li>It serves as the entry point for your NestJS application and is typically called at the bottom of your <code>main.ts</code> file.</li></ul></li>
				<li><code>const app = await NestFactory.create(AppModule);</code>: This line creates a new NestJS application instance using the <code>AppModule</code> class. The <code>await</code> keyword signifies that the function will wait for the application creation to complete before proceeding.</li>
				<li>Swagger configuration:<ul><li><code>const config = new DocumentBuilder()...</code>: Here, you’re configuring the Swagger documentation using the <code>DocumentBuilder</code> class.</li><li><code>.setTitle('Transaction API')</code>: Sets the title of your API documentation to <code>Transaction API</code>.</li><li><code>.setDescription('Transaction API description')</code>: Provides a brief description of your API.</li><li><code>.setVersion('1.0')</code>: Sets the version of your API to <code>1.0</code>.</li><li><code>.build()</code>: Builds the Swagger document based on the provided configuration options.</li></ul></li>
				<li><code>const document = SwaggerModule.createDocument(app, config);</code>: This line generates the actual Swagger document using the <code>SwaggerModule</code> class. It takes the NestJS application instance (<code>app</code>) and the built configuration (<code>config</code>) as arguments.</li>
				<li><code>SwaggerModule.setup('api', app, document);</code>: This code integrates <a id="_idIndexMarker474"/>the Swagger documentation with your application. It sets the path prefix for the documentation to <code>api</code> (for example, <code>http://localhost:3000/api</code>) and associates the generated document (<code>document</code>) with the application (<code>app</code>). This allows developers to access the interactive <a id="_idIndexMarker475"/>Swagger documentation at the specified URL.</li>
				<li><code>await app.listen(3000);</code>: This line starts the NestJS application and makes it listen for incoming requests on port <code>3000</code>. You can change this port number to your desired option.</li>
			</ul>
			<p>Overall, this <code>main.ts</code> file performs two crucial tasks:</p>
			<ul>
				<li><code>AppModule</code> class and starts the server listening for requests</li>
				<li><strong class="bold">Integrates Swagger documentation</strong>: It configures and provides Swagger documentation for your API, allowing developers to explore your API endpoints, understand data models, and interact with your API using the interactive interface</li>
			</ul>
			<p>Navigate to <code>localhost:3000/api</code>, and you should see the Swagger page (<em class="italic">Figure 6</em><em class="italic">.11</em>):</p>
			<div><div><img alt="Figure 6.11: Swagger UI" src="img/B09148_06_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: Swagger UI</p>
			<p>As you’ll realize, we don’t have any endpoints yet; the next section talks about creating them.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Working on transaction implementation</h2>
			<p>To start <a id="_idIndexMarker476"/>to work with transactions, first, we need <a id="_idIndexMarker477"/>to generate resources. To implement <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations <a id="_idIndexMarker478"/>for transactions, we’ll first generate REST resources, creating boilerplate code for the <a id="_idIndexMarker479"/>module, controller, service, and <strong class="bold">Data Transfer </strong><strong class="bold">Object</strong> (<strong class="bold">DTO</strong>).</p>
			<p>Run the <code>npx nest generate resource transaction</code> command to generate resources for a transaction:</p>
			<div><div><img alt="Figure 6.12: Selecting a transport layer" src="img/B09148_06_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12: Selecting a transport layer</p>
			<p>It will ask you which transport layer to choose (<em class="italic">Figure 6</em><em class="italic">.12</em>). Select <code>REST API</code> and hit <em class="italic">Enter</em>. As the next question, you will be asked <code>Would you like to generate CRUD entry points?.</code> Select <code>Y</code>, and the following files should be generated (<em class="italic">Figure 6</em><em class="italic">.13</em>):</p>
			<div><div><img alt="Figure 6.13: CRUD generation for transaction" src="img/B09148_06_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13: CRUD generation for transaction</p>
			<p>Run <code>npm run start:dev</code> and <a id="_idIndexMarker480"/>navigate to <code>localhost:3000/api</code>. You should get a page <a id="_idIndexMarker481"/>that stores transaction boilerplate endpoints (<em class="italic">Figure 6</em><em class="italic">.14</em>):</p>
			<div><div><img alt="Figure 6.14: Swagger UI for transaction" src="img/B09148_06_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14: Swagger UI for transaction</p>
			<p>Of course, we don’t need to implement all these CRUD endpoints. We need the following functions:</p>
			<ul>
				<li>Get all transactions (<code>GET /transaction</code>)</li>
				<li>Get transaction by ID (<code>GET /</code><code>transaction/{id}</code> )</li>
				<li>Create transaction (<code>POST /transaction</code>)</li>
			</ul>
			<p>Let’s <a id="_idIndexMarker482"/>remove the rest of the unused code blocks and files.</p>
			<p>Remove <a id="_idIndexMarker483"/>the following files:</p>
			<ul>
				<li><code>transaction/transaction.controller.spec.ts</code></li>
				<li><code>transaction/dto/update-transaction.dto.ts</code></li>
				<li><code>transaction/transaction.service.spec.ts</code></li>
			</ul>
			<p>Remove the following code blocks:</p>
			<ul>
				<li><code>remove</code> and <code>update</code> functions from <code>transaction.service.ts</code></li>
				<li><code>remove</code> and <code>update</code> functions from <code>transaction.controller.ts</code></li>
			</ul>
			<p>If you haven’t removed them yet, remove the following files too:</p>
			<ul>
				<li><code>app.controller.ts</code></li>
				<li><code>app.module.ts</code></li>
				<li><code>app.service.ts</code></li>
			</ul>
			<p>Update <code>main.ts</code> to work with <code>TransactionModule</code>, not <code>AppModule</code>:</p>
			<pre class="source-code">
import { NestFactory } from '@nestjs/core';
import { TransactionModule } from
  './transaction/transaction.module';
import { SwaggerModule, DocumentBuilder } from
  '@nestjs/swagger';
// bootstrap function
async function bootstrap() {
  // Create a NestJS application instance
  const app = await NestFactory.create(TransactionModule);
……..</pre>			<p>You’ll <a id="_idIndexMarker484"/>end up <a id="_idIndexMarker485"/>with three endpoints (<em class="italic">Figure 6</em><em class="italic">.15</em>):</p>
			<div><div><img alt="Figure 6.15: Final transaction endpoints" src="img/B09148_06_015.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15: Final transaction endpoints</p>
			<p>After having generated REST resources, we’re ready to integrate our <code>PrismaClient</code> class. Having this client will help us to interact with the database easily. First, let’s update our <code>transaction.module.ts</code> file to have <code>PrismaModule</code>:</p>
			<pre class="source-code">
import { Module } from '@nestjs/common';
import { TransactionService } from './transaction.service';
import { TransactionController } from
  './transaction.controller';
import { PrismaModule } from '../prisma/prisma.module';
@Module({
  imports: [PrismaModule],
  controllers: [TransactionController],
  providers: [TransactionService],
})
export class TransactionModule {}</pre>			<p>Having <code>PrismaModule</code> in <a id="_idIndexMarker486"/>the <code>imports</code> array will make <code>PrismaService</code> available to <code>TransactionService</code>.</p>
			<p>Now, open <a id="_idIndexMarker487"/>the <code>transaction.service.ts</code> file and make the following changes:</p>
			<pre class="source-code">
import { Injectable } from '@nestjs/common';
import { CreateTransactionDto } from
  './dto/create-transaction.dto';
import { PrismaService } from 'src/prisma/prisma.service';
@Injectable()
export class TransactionService {
  constructor(private readonly prisma: PrismaService) {}
…….</pre>			<p>The transaction controller file (<code>transaction.controller.ts</code>) already has <code>transactionservice</code> as an injected service. It has all the required contracts to request the transaction service and retrieve data.</p>
			<p>Open <code>transaction.controller.ts</code> and have a look at the <code>findAll()</code> method:</p>
			<pre class="source-code">
@Get()
  findAll() {
    return this.transactionService.findAll();
  }</pre>			<p>The same applies to <code>POST</code> and the single <code>GET</code> request. The only thing we need to do is to call Prisma to provide all the data when we call <code>transactionservice</code>’s <code>findAll()</code> method. For that reason, open <code>transaction.service.ts</code> and update the <code>findAll()</code> method content (<em class="italic">Figure 6</em><em class="italic">.14</em>):</p>
			<pre class="source-code">
findAll() {
    return this.prisma.transaction.findMany();
  }</pre>			<p>Using <code>findMany()</code>, we’re able to call all transaction data from the transaction table via Prisma. Let’s <a id="_idIndexMarker488"/>run our application (run <code>npm run start:dev</code>) and run our endpoint from Swagger UI.</p>
			<p>Open <code>GET /transaction</code> from Swagger UI, click the <strong class="bold">Try it out</strong> button, and click the  <strong class="bold">Execute</strong> button. Now, you should see only the data we migrated to our database when we talked <a id="_idIndexMarker489"/>about seeding data (<em class="italic">Figure 6</em><em class="italic">.16</em>):</p>
			<div><div><img alt="Figure 6.16: Response for “Get all transactions”" src="img/B09148_06_016.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16: Response for “Get all transactions”</p>
			<p>To modify your <code>GET</code> request by ID endpoint for it to work properly, open <code>transaction.service.ts</code> and replace the <code>findOne()</code> method with the following:</p>
			<pre class="source-code">
findOne(id: number) {
    return this.prisma.transaction.findUnique({
      where: { id },
    });
  }</pre>			<p>Everything <a id="_idIndexMarker490"/>is really simple when it comes to retrieving data, but how about creating it?</p>
			<p>We have a <code>POST</code> endpoint in <code>transaction.controller.ts</code> that was automatically <a id="_idIndexMarker491"/>generated when we generated the file itself:</p>
			<pre class="source-code">
@Post()
  create(@Body() createTransactionDto:
    CreateTransactionDto) {
      return
      this.transactionService.create(createTransactionDto);
    }</pre>			<p>When our resources were created, <code>CreateTransactionDTO</code> was also generated; you can find it inside the <code>src/transaction/dto</code> folder. Surprisingly, it has only one class declaration:</p>
			<pre class="source-code">
export class CreateTransactionDto {}</pre>			<p>You should manually add the required properties into the class. Our DTOs just transfer data from the source to the destination. DTOs are used in various programming languages and frameworks, not specific to NestJS. They act as a way to efficiently transfer data between different layers of an application. We also have a validation possibility before getting data from the user and creating DTOs based on this data. That is why we will use the <code>class-validator</code> package to validate our data. To install it, run the <a id="_idIndexMarker492"/>following command from the terminal:</p>
			<pre class="console">
npm install class-validator</pre>			<p>Open <code>create-transaction.dto.ts</code> and <a id="_idIndexMarker493"/>add the following content:</p>
			<pre class="source-code">
import { IsString, IsOptional, IsEnum, IsNotEmpty,IsUUID }
  from 'class-validator';
enum Status {
    CREATED = 'CREATED',
      SETTLED= 'SETTLED',
    FAILED = 'FAILED',
    }
export class CreateTransactionDto {
  @IsNotEmpty()
  @IsEnum(Status)
  status: Status;
  @IsUUID()
  @IsNotEmpty()
  accountID: string;
  @IsOptional()
  @IsString()
  description?: string;
}</pre>			<p>Update your <code>POST</code> method (<code>transaction.controller.ts</code>) to accept <code>CreateTransactionDTO</code> and execute it:</p>
			<pre class="source-code">
@Post()
  create(@Body() createTransactionDto:
    CreateTransactionDto) {
      return
      this.transactionService.create(createTransactionDto);
    }</pre>			<p>Now, let’s <a id="_idIndexMarker494"/>run our application. From Swagger UI, open <code>POST/ transaction</code> and <a id="_idIndexMarker495"/>provide the following JSON payload:</p>
			<pre class="source-code">
{
  "status": "CREATED",
  "accountId": "662c081370bd2ba6b5f04e94",
  "description": "Optional transaction description"
}</pre>			<p>Click the <strong class="bold">Execute</strong> button, and here we are (<em class="italic">Figure 6</em><em class="italic">.17</em>):</p>
			<div><div><img alt="Figure 6.17: Successful transaction creation" src="img/B09148_06_017.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17: Successful transaction creation</p>
			<p>Starting from <a id="_idIndexMarker496"/>the next section, we will explore how to establish communication <a id="_idIndexMarker497"/>between the transaction and account microservices.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Establishing synchronous communication with the account microservice</h1>
			<p>We’re <a id="_idIndexMarker498"/>done with the transaction service, but the only thing missing is our account service. The transaction <a id="_idIndexMarker499"/>service allows us to specify an <code>accountId</code> value and status from the payload. We need to make the following changes:</p>
			<ul>
				<li>Verify if the provided <code>accountId</code> exists and is in a valid state (new or active)</li>
				<li>If <code>accountId</code> is valid, then create a transaction with the <code>Created</code> status</li>
				<li>If <code>accountId</code> is invalid, then create a transaction with the <code>Failed</code> status</li>
			</ul>
			<p>The purpose here is not to fully implement the transaction domain. Of course, the current domain has more requirements than the previous one, but our focus is to practice and establish synchronous communication between the transaction and account services.</p>
			<p>We have already talked about the pros and cons of synchronous communication between microservices. While asynchronous communication offers many benefits for microservices, there are situations where synchronous communication might be a better fit. If the interaction between microservices requires straightforward logic and an immediate response, synchronous communication can be easier to implement. Also, it is beneficial to use it for user interactions where you need to display information or confirm an action right away. It creates tight coupling, but in some cases, microservices might <a id="_idIndexMarker500"/>be tightly coupled and rely heavily on each other’s results to complete a task. Synchronous communication allows for a more controlled flow, ensuring one service doesn’t proceed until <a id="_idIndexMarker501"/>the other provides the necessary information. Synchronous communication can be easier to debug at times. Since the entire interaction happens in one go, tracing errors and understanding the flow of data is more straightforward. This can be helpful during development or troubleshooting specific issues.</p>
			<p>To communicate with the account service, we need an HTTP client package. One of the most used packages is <code>axios</code>. Let’s install it using <code>npm</code>:</p>
			<pre class="console">
npm i --save @nestjs/axios axios</pre>			<p>Now, we need to import <code>HttpModule</code> from <code>axios</code> and import it from <code>transaction.module.ts</code>. Here is the final code in this file:</p>
			<pre class="source-code">
import { Module } from '@nestjs/common';
import { TransactionService } from './transaction.service';
import { TransactionController } from
  './transaction.controller';
import { PrismaModule } from '../prisma/prisma.module';
import { HttpModule } from '@nestjs/axios';
@Module({
  imports: [PrismaModule,HttpModule],
  controllers: [TransactionController],
  providers: [TransactionService],
})
export class TransactionModule {}</pre>			<p>After importing <code>HttpModule</code> from <code>transaction.module.ts</code>, we’re able to use <code>HttpService</code> from <code>axios</code> in <code>transaction.service.ts</code>. Let’s import and inject it as <a id="_idIndexMarker502"/>a service for the transaction service. Open <code>transaction.service.ts</code> and change the <a id="_idIndexMarker503"/>code to have the following lines:</p>
			<pre class="source-code">
import { Injectable } from '@nestjs/common';
import { CreateTransactionDto } from
  './dto/create-transaction.dto';
import { PrismaService } from 'src/prisma/prisma.service';
import { HttpService } from '@nestjs/axios';
import { AccountApiResponse } from './dto/account.dto';
@Injectable()
export class TransactionService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly httpService: HttpService) {}
//the rest of the code</pre>			<p>As our business requires, we need to remove the status property from <code>createTransactionDto</code> because, depending on the account service, we should internally define the status of the transaction. That is why we’re going to remove the status from <code>src/transaction/dto/create-transaction.dto</code>. The following is the final version of this file:</p>
			<pre class="source-code">
import { IsString, IsOptional, IsNotEmpty,IsUUID } from 
  'class-validator';
export class CreateTransactionDto {
  @IsUUID()
  @IsNotEmpty()
  accountId: string;
  @IsOptional()
  @IsString()
  description?: string;
}</pre>			<p>Great! Now, let’s <a id="_idIndexMarker504"/>open our <code>transaction.service.ts</code> file again and change our <em class="italic">create</em> functionality. After injecting <code>httpService</code>, we should be able to make a request to any <a id="_idIndexMarker505"/>service and get a response back.</p>
			<p>Here is what we plan to do:</p>
			<ul>
				<li>Make a request to the account service’s <code>http://url/v1/accounts/{account_id}</code> endpoint and account information based on the provided ID from the endpoint</li>
				<li>If the given account by <code>accountId</code> doesn’t exist, we throw an exception</li>
				<li>If the account exists, and its status is either <code>'new'</code> or <code>'active'</code>, then the transaction should be created with a <code> '</code><code>CREATED' </code>status</li>
				<li>If the account exists, and its status is neither <code>'new'</code> nor <code>'active'</code>, we should create a transaction with a <code>'</code><code>FAILED' </code>status</li>
			</ul>
			<p>That is simply it. Open <code>transaction.service.ts</code> and update it with the following code lines:</p>
			<pre class="source-code">
import { Injectable } from '@nestjs/common';
import { CreateTransactionDto } from
  './dto/create-transaction.dto';
import { PrismaService } from 'src/prisma/prisma.service';
import { HttpService } from '@nestjs/axios';
import { AccountApiResponse } from './dto/account.dto';
@Injectable()
export class TransactionService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly httpService: HttpService,
  ) {}
 async create(createTransactionDto: CreateTransactionDto) {
  const { accountId, description } = createTransactionDto;
  let accountApiResponse = await
    this.httpService.axiosRef.get&lt;AccountApiResponse&gt;(
      `http://localhost:3001/v1/accounts/${createTransactionDto.accountId}`,
      );
     const {account} = accountApiResponse.data;
     if (!account) {
      throw new Error('Transaction creation failed: Account
        not found');
    }
      if(account.status == 'new' || account.status ==
        'active')
        {
          return this.prisma.transaction.create({
            data: { accountId, description, status:
              'CREATED' },
          });
        }
        else
        {
          return this.prisma.transaction.create({
            data: { accountId, description, status:
              'FAILED' },
          });
        }
  }
//rest of the functionalities
}</pre>			<p>The <a id="_idIndexMarker506"/>last thing <a id="_idIndexMarker507"/>we need <a id="_idIndexMarker508"/>to do is to configure <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>) in the account service. Follow the next steps:</p>
			<ol>
				<li>Open your account service from VS Code.</li>
				<li> From the menu, select <strong class="bold">Terminal</strong> | <strong class="bold">New Terminal</strong>.</li>
				<li> Navigate to the <code>src</code> folder.</li>
				<li> Execute <code>npm install cors</code> to install the <code>cors</code> package.</li>
				<li> Open <code>app.js</code> and add the following code after the <code>app</code> object is created:<pre class="source-code">
const corsOptions = {
    origin: 'http://localhost:3001', //(https://your-client-app.com)
    optionsSuccessStatus: 200,
};
app.use(cors(corsOptions));</pre></li>			</ol>
			<p>The <a id="_idIndexMarker509"/>final code <a id="_idIndexMarker510"/>in <code>app.js</code> should look like this:</p>
			<pre class="source-code">
const express = require('express');
const v1 = require('./routes/v1');
const cors = require('cors');
const app = express();
//added while implementing transaction service, for Ch06
const corsOptions = {
    origin: 'http://localhost:3001', //(https://your-client-app.com)
    optionsSuccessStatus: 200,
};
app.use(cors(corsOptions));
// service
app.use(express.json());
// V1 API
app.use('/v1', v1);
module.exports = app;</pre>			<p>Before running our application, make sure of the following:</p>
			<ul>
				<li>Your account service lives in <code>localhost:3001</code></li>
				<li>The account service has at least one piece of valid account information in your table</li>
				<li>Make sure that Docker is running and the <code>postgres</code> container is active</li>
			</ul>
			<p>Go <a id="_idIndexMarker511"/>to our account <a id="_idIndexMarker512"/>service and run it (for more details, check <a href="B09148_05.xhtml#_idTextAnchor074"><em class="italic">Chapter 5</em></a>). Run our newly created transaction service using <code>npm run start:dev</code>. Open your favorite browser, and navigate to <code>http://localhost:3000/api</code>. Open <code>POST /transaction</code> and add the following payload:</p>
			<pre class="source-code">
{
"accountId": "663fd142ecbdce73baf1ed1a",
 "description": "Optional transaction description"
}</pre>			<p>The <code>accountId</code> value you provided from the payload should exist in the account service to have a successful operation. In the case of a successful request, you will get the following response:</p>
			<pre class="source-code">
{
  "id": {your_transaction_id},
  "status": "CREATED",
  "accountId": "663fd142ecbdce73baf1ed1a",
  "description": "Optional transaction description",
  "createdAt": "2024-05-12T17:21:38.727Z",
  "updatedAt": "2024-05-12T17:21:38.727Z"
}</pre>			<p>If <a id="_idIndexMarker513"/>the service <a id="_idIndexMarker514"/>is not available and the account doesn’t exist, you will get errors. We didn’t cover exception handling in this chapter, but we’ll learn about it in our upcoming chapters.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/>Summary</h1>
			<p>Another microservice journey ends here. The main points in this chapter were creating a second microservice and establishing synchronous communication between microservices. We started our chapter with business requirements. After getting a clear understanding of what we should do, we started to introduce main stack tools to develop our transaction microservice. We didn’t use the tools we used before to develop our account service. JavaScript has really rich tools and frameworks to use when it comes to developing microservices. To demonstrate the beauty of having multiple tools, we used NestJS with some popular packages such as Prisma and Axios. In the end, we established communication with an already existing microservice (the account microservice) using a synchronous communication model. Of course, we still missed out a lot. We didn’t cover exception handling, resiliency, and a lot of other interesting topics that we plan to introduce in our upcoming chapters.</p>
			<p><a href="B09148_07.xhtml#_idTextAnchor121"><em class="italic">Chapter 7</em></a> explores how to implement asynchronous communication in JavaScript microservices using Apache Kafka and NestJS, focusing on building scalable systems, configuring Kafka, and adapting services like transaction and account services for asynchronous messaging.</p>
		</div>
	</body></html>