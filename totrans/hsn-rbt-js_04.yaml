- en: Bringing in Input with Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now explored digital and PWM output in Johnny-Five, but that's only half
    of the story. There is so much you can do with input devices in robotics projects,
    allowing either user input or observations of the world surrounding your projects
    to affect the outputs.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to start with a user-input device—buttons. We're also going to talk
    about how the Raspberry Pi handles digital inputs, and build buttons into our
    previous project that allows users to stop the rainbow color cycle, and advance
    the color themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using inputs in robotics projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Johnny-Five sensor and button objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring up buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding buttons to our RGB LED project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need your Pi, with the RGB LED from the  [Chapter 3](c7b761b9-d526-4998-8ec4-375debe53806.xhtml), *Building
    Interactive Projects with RGB LED* project wired up, along with the GPIO expander
    board.
  prefs: []
  type: TYPE_NORMAL
- en: Using inputs in robotics projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can do a lot with output devices in robotics projects, but the possibilities
    become endless when you add inputs. Whether they are user-controlled inputs, such
    as buttons and potentiometers, or environmental sensors that measure things such
    as ambient light or air quality, input devices can add a new dimension to any
    robotics project.
  prefs: []
  type: TYPE_NORMAL
- en: Digital versus analog input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like with digital and PWM output, there are two types of input devices:
    digital and analog. Digital inputs are either on or off: buttons are a prime example
    of this. Analog inputs give a different level of voltage of signal depending on
    what they are sensing; a photoresistor, for example, puts out higher voltage signals
    when the ambient light is high, and lower when it is darker.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to read data from analog devices, you'll need a pin that can accept
    an analog input. But as we saw in the last chapter, all of the GPIO pins on the
    Raspberry Pi are digital. Luckily, there are ways to get around this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: How to handle analog input with the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to go about obtaining analog sensor data on the Raspberry
    Pi: adding a GPIO expander that has analog pins, or using sensors that make use
    of digital signaling to communicate analog data.'
  prefs: []
  type: TYPE_NORMAL
- en: Analog GPIO expanders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These boards act almost exactly like the GPIO expansion board we used in [Chapter
    3](c7b761b9-d526-4998-8ec4-375debe53806.xhtml),*Building Interactive Projects
    with RGB LED*, except instead of adding PWM output pins, they add analog input
    pins. These boards also usually utilize an I²C interface to communicate with the
    Raspberry Pi. However, I usually find these boards unnecessary, because many sensors
    that collect more than one channel of data (such as an accelerometer) already
    utilize I²C or other digital interfaces, and the few sensors that collect one
    channel of data can be found with these digital interfaces on board.
  prefs: []
  type: TYPE_NORMAL
- en: Using input devices with digital interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the way we'll go in our projects. Devices like these use protocols such
    as UART, SPI, and I²C that allow devices that only have digital GPIO to receive
    analog data. In the materials for each project, the devices included will not
    require analog input pins.
  prefs: []
  type: TYPE_NORMAL
- en: How Johnny-Five handles input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we've gotten a glimpse of the way Johnny-Five uses events via the board `ready` event.
    If you've ever programmed with C and Arduino, you may be familiar with the event
    loop style of program—a loop runs forever and checks the state of the input devices,
    then responds accordingly. You may also be aware of interrupt-driven programming,
    where a change in a hardware pin causes the code to jump to a specific function.
  prefs: []
  type: TYPE_NORMAL
- en: Johnny-Five code is closer to the interrupt style; events drive nearly all Johnny-Five
    projects. This has several benefits; you can keep your code organized by event
    type, and make sure each piece of functionality fires only when it needs to, without
    having to deal with programming your own hardware interrupt routines.
  prefs: []
  type: TYPE_NORMAL
- en: When a Johnny-Five project receives input from a sensor or device, it fires
    a `data` event. But what if you only want to run a function when the environment
    changes? The `change` event is for you. We'll look more at the exact event types
    and when they fire in a later section, but for now keep in mind that events are
    how you'll capture the data of your sensors and input devices.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a typical Johnny-Five project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Johnny-Five project consists of a few key sections and building blocks that
    make it really easy to read through an example. Let's go through an example here
    to see more.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning – including libraries and creating our board object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section sets the stage for us by bringing in the Johnny-Five. The following
    code snippet tells it we''re using a Raspberry Pi, and constructs the appropriate
    board objects. If you''re using other `npm` modules, like the `color` module we
    used in [Chapter 3](c7b761b9-d526-4998-8ec4-375debe53806.xhtml),*Building Interactive
    Projects with RGB LED*, you''d use `require` to bring them in here as well, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The board ready event handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything else that we do in a Johnny-Five project, besides the header, goes
    inside this event handler. This handler, as shown here, means our board is ready
    to read and write to GPIO pins, and any code run outside this event handler that
    manipulates GPIO is not guaranteed to work and may cause strange behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Constructing our component objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing I do inside the board ready event handler is set up Johnny-Five
    objects for all of the components of my projects. It''s easier to wire up a project
    from the code if all of the component types and pins are in the same place in
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Input event handlers and output device manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is where the fun happens, we wait for input and manipulate outputs accordingly!
    This will watch for a button connected to `P1–8` to be pressed, then turn on an
    LED. But how would we turn the LED off when the button is released? For that,
    we''re going to take another look at the Johnny-Five documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Johnny-Five button object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we program our button project, let's take a good look at the Johnny-Five
    button object, so we know what events to look for, and what information the constructor
    wants from us.
  prefs: []
  type: TYPE_NORMAL
- en: The button object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we look at the button''s parameters section, there is only one required
    parameter, pin. So we''ll need to remember what pin to which we hook the signal
    from the button, but other than that, the defaults will serve us nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invert`: Defaults to false, and inverts the up and down values. We''d like
    to keep this false, as we''re wiring the button to not require inversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isPullup`: Tells boards with pull-up resistors tied to their GPIO pins to
    initialize this button with the pull-up enabled. We''re going to wire our own
    resistor, so this can stay the default false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isPulldown`: Similar to `isPullup`, but with pull-down resistors. Leave this
    false as we are wiring our own pull-down resistor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holdtime`: This is the number of milliseconds a button must be held down before
    the hold event is fired. The default of 500 milliseconds will do fine for us here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's also a special section called `collection`, which details how you can
    control several buttons with the same object. It's an interesting design, and
    while we won't explore it for our two-button project, a good bonus project would
    be to refactor it to use the buttons `collection` object.
  prefs: []
  type: TYPE_NORMAL
- en: Button events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three events that the button object uses, and each of them can be
    used on a single instance of a button object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`press`, `down`: These are the same event, and they fire when the button has
    been pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release`, `up`: These events fire when the button is released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hold`: This event fires when the button is held down for longer than the threshold
    set in the `holdtime` parameter in the constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you've dealt with hardware before, you might be worried about button event
    `noise`; multiple events firing on one button press or release, release events
    when the button hasn't been pressed, and so on. Johnny-Five has baked debouncing
    into the button object, so there's no need to worry about noisy buttons!
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to add buttons to the project from the previous chapter, to allow
    users to change the way the RGB LED works by pressing buttons. When you look at
    a button, you see four prongs. While there are four prongs, there are only two
    input/outputs to a button—one where electricity goes in, and one where it goes
    out when the button is pressed. This is because a button essentially controls
    the flow of electricity. When the button is not pressed, the contacts are not
    connected and electricity cannot flow, and when pressed, a conductor bridges the
    two sides and electricity flows. This is how we will use the button as an input
    device: a high signal means the button is pressed, a low signal means it isn''t.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting a button on a breadboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take your button and observe the metal prongs on the bottom. Usually, the two
    pairs curve towards the inside of the button. There is one in and out on each
    side, and each pair with the same curve has one of each. Keep this in mind when
    placing it on the breadboard, shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b131c0d4-93f1-465d-bcaa-73d885ecb681.png)'
  prefs: []
  type: TYPE_IMG
- en: When you're placing a button on the breadboard, you'll want to make sure that
    the button crosses the trough in the middle of the breadboard in order to prevent
    a short.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've placed the button into the breadboard, make sure it's well-seated,
    and that none of the prongs have curled up into themselves instead of going into
    the breadboard socket. If one has, use needle-nose pliers to straighten it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've got your button on the breadboard, it's time to wire it to your
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Using a pull-down resistor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So the question is, how are we going to get three wires into a device with two
    leads? We're going to use what's called a pull-down resistor to tie an input to
    the side of the button not connected to power. When the button is pressed, electricity
    will flow through the resistor into the signal wire, and we'll use a digital input
    pin on the Pi to detect that as a button press.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, wire one side of your button to a 5V power pin on the cobbler. On
    the other side, place a 10K ohm resistor that bridges to another row of the breadboard,
    and in that row place a wire to bridge to a GPIO pin on the cobbler. Then, in
    the second row of the button, below the resistor, place a wire bridging to a GND
    pin on the cobbler.
  prefs: []
  type: TYPE_NORMAL
- en: The resistor prevents the Pi from shorting when the button is pressed, which
    will cause your Pi to temporarily cease functioning and, if left for too long,
    will cause irreparable damage.
  prefs: []
  type: TYPE_NORMAL
- en: A short circuit, or short, is when the power and ground of a circuit are connected
    without a load (like our resistor) in between, which causes a lot of issues. To
    learn more, check out the *Further reading* section of this chapter, or any introduction
    to an electronics book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons to our RGB LED project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how buttons work and how to wire one up to the Pi, let's add
    two buttons to our RGB LED project.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring everything up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we wire up our buttons, we're going to need to do some housekeeping on
    our current wiring setup.
  prefs: []
  type: TYPE_NORMAL
- en: Using the power and ground side rails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From here on, we'll be needing more access to power and GND pins, and we don't
    want a ton of really long wires criss-crossing our projects. So the first thing
    we'll do is a little hardware refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Take the RGB LED ground off the cobbler row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the VCC and GND from the GPIO expander off the 5V and GND cobbler rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a wire between the 5V row of the cobbler and the outer long row (if there's
    one marked red and one blue, use red).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a wire between a GND pin of the cobbler and the other outer row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the RGB LED ground into the side rail you linked to the GND on the cobbler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Plug the GND from the GPIO expander into the side rail linked to GND on the
    cobbler, and the VCC into the side rail linked to 5V on the cobbler, as shown
    in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea36319f-bb5a-41f2-898c-1bafe7fa91e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Wiring up the buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve sorted out our power and ground rails, let''s place buttons.
    For both of the two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the button on the breadboard as outlined in the last section, bridging
    the gap in the center of the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire one side of the button to the side rail connected to the 5V pin on the
    cobbler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 10K ohm resistor on the other side, bridging to an empty rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire the side of the button with the resistor to the side rail linked to GND
    on the cobbler. Make sure the resistor is in between the button and the link to
    ground!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wire the other end of the resistors to a pin on the cobbler; use #5 for button
    1 and #6 for button 2, as shown in the next diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b2cc4051-e57e-44d5-adb5-686c5f6bf6a9.png)'
  prefs: []
  type: TYPE_IMG
- en: And now you're ready to write some code!
  prefs: []
  type: TYPE_NORMAL
- en: Button 1 – stop and start rainbow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we set up our buttons, we're going to refactor our rainbow-cycle program
    a bit to accommodate the new functionality of the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the rainbow cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to refactor the rainbow cycle to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at a scoped variable to see if the color should keep changing on a timed
    interval or not (for the stop and start button)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Break the code that changes the RGB LED to the next color into its own function
    (for the next color button)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to make `button1` stop and start the cycle through rainbow colors.
    To do this, we''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a button object to represent our button in the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Watch for the `press` event from the Johnny-Five button object API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a variable called `cycleOn` that can be set to true or false, and have the
    loop that changes the color use to either change the color or not
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're also going to pull the logic for changing the color out in preparation
    for our next button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add it to the beginning of our board ready handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Load this on your Pi, run it with `sudo node rainbow-pause-button.js`, and see
    what happens when you press the button a few times!
  prefs: []
  type: TYPE_NORMAL
- en: Button 2 – next color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''ll add a second button and press handler to make the second advance
    the color when it is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you press the second button, the color of the LED will advance to
    the next color in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter brought together user inputs and output—an RGB LED. We learned
    how to use input events in Johnny-Five to manipulate output devices, which is
    the core of most Johnny-Five projects, and learned how to use multiple inputs
    (buttons) to achieve different effects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What events are available to the Johnny-Five button object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the Raspberry Pi use analog input devices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How will we use sensors with the Pi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are there no events for the `RGB.LED` object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**More about analog input pins**: [https://learn.sparkfun.com/tutorials/analog-to-digital-conversion](https://learn.sparkfun.com/tutorials/analog-to-digital-conversion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More about pull-up resistors**: [https://learn.sparkfun.com/tutorials/pull-up-resistors](https://learn.sparkfun.com/tutorials/pull-up-resistors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
