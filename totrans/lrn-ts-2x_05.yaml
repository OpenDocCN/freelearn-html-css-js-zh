- en: Working with Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to work with classes and interfaces.
    We also learned about the SOLID principles and other object-oriented programming
    best practices. In this chapter, we will learn how to work with dependencies.
    The first part of the chapter will focus on the usage of modules. The second part
    of the chapter will focus on the management of dependencies in object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Third-party dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous module definition (AMD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CommonJS modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browserify and universal module definition (UMD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circular dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Third-party dependencies are usually open source libraries created by third-party
    organizations or independent software engineers. Third-party dependencies are
    external modules and can be imported using their name instead of a relative or
    absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: Package management tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Package management tools are used for dependency management so that we no longer
    have to download and manage our application's dependencies manually.
  prefs: []
  type: TYPE_NORMAL
- en: The rise and fall of package management tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TypeScript ecosystem has experienced the rise and fall of many package managers
    over the past few years. This generated some confusion in the early days of TypeScript
    but, fortunately, today we have a much more stable ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Some notable package managers in the TypeScript history include tsd, typings,
    npm, bower, yarn, and turbo. Some package managers, such as tsd, typings, and
    bower, are not recommended anymore, and others, such as yarn or turbo, are relatively
    new and not as widely adopted as npm. The recommended package manager at the time
    of writing is npm.
  prefs: []
  type: TYPE_NORMAL
- en: npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Node Package Manager** (**npm**) was originally developed as the default
    Node.js package management tool, but today it is used by many other tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'npm uses a configuration file, named `package.json`, to store references to
    all the dependencies installed in our project. Originally, npm was usually only
    used to install backend dependencies, but today it is used to install any dependencies.
    This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Backend dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript type definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we install any packages, we should add a `package.json` file to our
    project. We can do this by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we must install Node.js to be able to use the `npm` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `npm init` command will ask for some basic information about our project,
    including its name, version, description, entry point, test command, Git repository,
    keywords, author, and license.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official npm documentation at [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)
    if you are unsure about the purpose of some of the `package.json` fields mentioned
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The `npm` command will then show us a preview of the `package.json` file that
    is about to be generated, and ask for our final confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to skip the questions and generate the file using the default
    settings, you can use the `npm init` command together with the `--yes` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After creating the project's `package.json` file, we will use the `npm install`
    command to install our first dependency.
  prefs: []
  type: TYPE_NORMAL
- en: The `npm install` command takes as arguments the name of one or multiple dependencies
    separated by a single space, and the scope of the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scope can be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Global dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency at development time (for example, testing frameworks, compilers,
    and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency at runtime (for example, a web framework, database ORMs, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the `tslint` npm package to check the style of our TypeScript code,
    so let''s install it as a development dependency (using the `--save-dev` argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To install a global dependency, we will use the `-g` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We might need administrative privileges to install packages with global scope
    in our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that npm will not add any entries to our `package.json` when installing
    packages with a global scope, but is important that we manually add the right
    dependencies to the `devDependencies` section in `package.json` to guarantee that
    the continuous integration build server will resolve all our project's dependencies
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a runtime dependency, use the `--save` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please note that `react` is a module that can be used to create user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have installed some dependencies in the `package.json` file, the contents
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Some fields in the `package.json` file must be configured manually. To learn
    more about the available `package.json` configuration fields, visit [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).
  prefs: []
  type: TYPE_NORMAL
- en: The versions of the npm packages used throughout this book may have been updated
    since its publication. Refer to the package documentation at [https://npmjs.com](https://npmjs.com)
    to find out potential incompatibilities and learn about new features.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using one of the modern versions of npm, installing a module will
    also generate a file named `package-lock.json`. This file describes the exact
    dependency tree that was generated, such that subsequent installations can generate
    identical trees, regardless of intermediate dependency updates.
  prefs: []
  type: TYPE_NORMAL
- en: All the npm packages will be saved in the `node_modules` directory. It is recommended
    to avoid saving the `node_modules` directory into source control (for example,
    a Git repository).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next time we set up our development environment, we will need to download
    all our dependencies again, but to do so, we will only need to execute the `npm
    install` command without any additional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The package manager (npm) will then search for the `package.json` file and install
    all the dependencies listed in it.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the npm search engine at [https://www.npmjs.com](https://www.npmjs.com)
    to find potential modules that could be useful for our application.
  prefs: []
  type: TYPE_NORMAL
- en: We can check whether the dependencies of our project are outdated using the
    `npm outdated` command.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to use npm to manage the dependencies of a project. However,
    npm is more than a package manager, because it also allows us to create commands
    to perform some custom automation tasks, for example, to release a version of
    our application or run some automated tests. We will learn more about this feature
    later in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: Type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TypeScript support for existing JavaScript libraries is achieved thanks
    to the declaration of the public interface, or API, of the library. The declaration
    of the public interface of a third-party module is known as **type definition**.
  prefs: []
  type: TYPE_NORMAL
- en: When we install an npm module, we can face a few different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Modules with native support for TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some third-party dependencies feature built-in support for TypeScript. For
    example, an example of a module with native support for TypeScript is the InversifyJS
    module. In this case, installing the npm module is enough, because the module
    includes the required type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Modules with external support for TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some third-party dependencies do not feature built-in support for TypeScript,
    but type definitions are available in a separate npm module. An example of a module
    with external support for TypeScript is the `react` module. In this case, installing
    the npm module is not enough, because it doesn''t include the required type definitions.
    We can solve this by installing the npm module which contains the missing type
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript team has developed an automated process that publishes all the
    available open source type definitions under one unique organization on the npm
    public registry. The organization is named `@types`, and the type definitions
    use the name of the module that they are defining.
  prefs: []
  type: TYPE_NORMAL
- en: Modules with no support for TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some third-party dependencies don't feature built-in support for TypeScript,
    and type definitions are not available in a separate npm. In this case, installing
    the npm module is not enough, because it doesn't include the required type definitions.
    We can solve this by creating our type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the process of creating our type definitions is not something
    that can be systematically described and requires a bit of experience, but we
    are going to try to explain the main complexities around it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend that we need to write custom type definition for the `react-side-effect`
    npm module, which is not the case because the type definitions are available already,
    but we will use it as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is to install the package that is missing
    the type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to open the `package.json` contained inside the `react-side-effect`
    module. Each npm module contains a `package.json` file, so it should be located
    at the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we examine the `package.json` file, we should be able to find the `main`
    field. The `main `field describes the entry point of the npm module. The `main`
    field in the `package.json` of the `react-side-effect` npm module looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to open that file and find which elements are exported by the module
    and how they are exported. This is the complicated part: we need to navigate through
    the source code and identify the exported elements and the kind of exports. The
    `lib/index.js` file only exports a function named `withSideEffect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can create a file named `external.d.ts` and add the following
    type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that we have used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export = withSideEffect;`'
  prefs: []
  type: TYPE_NORMAL
- en: We have used this kind of module export because that is the kind of export that
    we can [see](https://github.com/gaearon/react-side-effect/blob/eb25efece753108b083f9c2c1be8e650712810d0/src/index.js#L5)
    in the library's source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we will see a module export like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export default withSideEffect;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or one like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export { withSideEffect };`'
  prefs: []
  type: TYPE_NORMAL
- en: We need to ensure that our type definition file uses the same kind of export
    that is used in the library. We will learn more about the different kinds of exports
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code snippet declares a module named react-side-effect. The module
    exports an entity named `withSideEffect` with type `any`. The preceding type definitions
    should be enough to be able to import the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we do so, we will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the only way to fix this is by adding an extra namespace, as
    described at [https://github.com/Microsoft/TypeScript/issues/5073](https://github.com/Microsoft/TypeScript/issues/5073):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can import the module without errors, but the type of `withSideEffect`
    is `any`. We can solve this by examining the source code and spending some time
    trying to figure out the signature of the function. If we do so, we will end up
    with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please note that it is highly recommended to share your type definitions with
    the TypeScript community at [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript specification type definitions (lib.d.ts)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript compiler automatically includes type definitions for the ECMAScript
    version that we are targeting. For example, if we target ES5, we will not be able
    to access the Promise API, because it is part of the ES6 specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, TypeScript allows us to import the type definitions for a proposal
    instead of an entire ECMAScript specification. For example, we can target ES5
    and use the Promise API by adding the following to our `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding setting is indicating to the TypeScript compiler that we want
    it to import the type definitions for the entire ECMAScript 5 specification, the
    **document object model** (**DOM**) and the Promise API.
  prefs: []
  type: TYPE_NORMAL
- en: External TypeScript helpers (tslib)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already know, TypeScript allows us to use features of the upcoming ECMAScript
    specifications. TypeScript uses a series of helper functions to implement some
    of these features at runtime. The following are some of the helper functions generated
    by TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__extends` for inheritance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__assign` for object spread properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__rest` for object rest properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__decorate`, `__param`, and `__metadata` for decorators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__awaiter` and `__generator` for `async`/`await`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one of these helpers is required, TypeScript will generate it at compilation
    time. However, this can be a problem, because the helper is generated in all of
    the files that require it, which can lead to a lot of duplicated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following compilation settings to solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: The `noEmitHelpers` flag will prevent TypeScript from emitting the helper functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `importHelpers` flag will emit the code necessary to import the helpers
    from the `tslib` npm module instead of emitting the helper functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `tslib` module contains the declaration of all the required TypeScript
    helpers. We can install the `tslib` module using npm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This way, the helper functions are only declared once (by the `tslib` module).
  prefs: []
  type: TYPE_NORMAL
- en: Internal modules (module and namespace)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `module` and `namespace` keywords to define internal modules.
    TypeScript originally allowed us to use the `module` keyword to declare internal
    modules, but it was later deprecated in favor of the `namespace` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Internal modules (`namespaces`) can be used to encapsulate certain elements
    of an application and to provide our code with a better organization. However,
    **we should try to avoid them and favor external modules over namespaces**. External
    modules should be our preferred option because they are required by some tools
    that allow us to optimize certain aspects of our application. External modules
    will be covered in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use namespaces to group interfaces, classes, and objects that are somehow
    related. For example, we could wrap all our application models inside an internal
    module named `Models`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All entities contained by a `namespace` are private by default. We can use the
    `export` keyword to declare what parts of our `namespace` we wish to make public.
  prefs: []
  type: TYPE_NORMAL
- en: Nested internal modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can nest one `namespace` inside another as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have declared a namespace named `App`, and inside
    it, we have declared a public namespace named `Models`, which contains two public
    classes: `UserModel` and `TalkModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then access the namespace entities by indicating the full namespace
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Cross-file internal modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript allows us to declare internal modules across multiple files. If an
    internal module becomes too big, it can be divided into multiple files to increase
    its maintainability. If we take the preceding example, we could add more contents
    to the internal module named `App` by referencing it in a new file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file, named `validation.ts`, and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access the namespace entities declared in both files by indicating
    the full namespace name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Even though the namespaces `Models` and `Validation` are declared in two different
    files, we can access them through the `App` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace names can contain periods. For example, instead of nesting the internal
    modules (validation and models) inside the `app` module, we could have used periods
    in the `validation` and `models` internal module names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Internal module aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `import` keyword can be used within an internal module to provide an alias
    for another module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Compiling internal modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have finished declaring our internal modules, we can decide whether
    we want to compile each one into JavaScript or whether we prefer to concatenate
    all the files into one single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `--out` flag to compile all the input files into a single JavaScript
    output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will automatically order the output file based on the reference
    tags present in the files. We can then import our files or file using an HTML
    `<script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: External modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript also has the concept of an external module. JavaScript versions before
    ECMAScript 6 (ES6) don't include native support for external modules. Developers
    were forced to develop custom module loaders, and the open source community tried
    to come up with improved solutions over the years. As a result, today, there are
    several types of module loaders, and each one of them supports at least one module
    definition syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we can assume that when someone talks about a module, without explicitly
    specifying whether they are talking about an internal or external module, they
    are referring to an external module.
  prefs: []
  type: TYPE_NORMAL
- en: Module loaders and module definition syntaxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main difference between using modules (instead of namespaces or internal
    modules) is that after declaring all our modules, we will not import them using
    an HTML `<script>` tag. Using the `<script>` tag is not recommended, because web
    browsers "halt" (or "freeze") simultaneous downloads and rendering of the page
    when they encounter and load the contents of a `<script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: We will discover more about network performance in [Chapter 13](2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml),
    *Application Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: External modules avoid loading the modules of our application using the `<script>`
    and use a module loader instead. A **module loader** is a tool that allows us
    to have better control over the module loading process. This allows us to perform
    tasks such as loading files asynchronously or combining multiple modules into
    a single highly optimized file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several module definition syntaxes have been proposed over the years by different
    open source projects due to the lack of native support for external modules in
    JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module definition syntax** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| AMD | Introduced by the RequireJS module loader |'
  prefs: []
  type: TYPE_TB
- en: '| CommonJS | Introduced by Node.js |'
  prefs: []
  type: TYPE_TB
- en: '| UMD | Supports both AMD and UMD |'
  prefs: []
  type: TYPE_TB
- en: '| SystemJS | Introduced by Angular 2, supports multiple syntaxes |'
  prefs: []
  type: TYPE_TB
- en: '| ES6 modules | Introduced by the ECMAScript 6 specification |'
  prefs: []
  type: TYPE_TB
- en: 'We can also encounter a wide variety of module loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module loader** | **Module definition syntax** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| RequireJS | AMD | RequireJS was the very first mainstream module loader for
    JavaScript applications |'
  prefs: []
  type: TYPE_TB
- en: '| Browserify | CommonJS | CommonJS modules were introduced by the original
    Node.js module system, but today Node.js supports ES6 modules natively |'
  prefs: []
  type: TYPE_TB
- en: '| SystemJS | Supports multiple module definition syntaxes | Supports multiple
    module definition syntaxes |'
  prefs: []
  type: TYPE_TB
- en: '| Native | ES6 | Modern JavaScript engines can support ES6 modules natively
    |'
  prefs: []
  type: TYPE_TB
- en: External modules at design time and runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript adds a layer of choice, because it allows us to choose which module
    definition syntax we want to use at design time and which one we want to use at
    runtime. In a landscape with so many options, it is very easy to feel overwhelmed
    and confused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, only two module definition syntaxes are available at design time
    in TypeScript, and one of them is considered deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: The legacy external module syntax (deprecated)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ES6 module syntax (recommended)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to use other module definition syntaxes at runtime, such
    as the AMD or the UMD syntaxes, but the TypeScript compiler will not try to compile
    them into the selected module definition output.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript allows us to choose which kind of module definition syntax will
    be used at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: ES6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CommonJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SystemJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UMD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can indicate our preference by using the `--module` flag when compiling,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that the kind of module definition syntax used
    at design time and the one used at runtime can be different.
  prefs: []
  type: TYPE_NORMAL
- en: Since the release of TypeScript 1.5, it has been recommended to use the ECMAScript
    6 module definition syntax, because it is based on the ECMAScript specification,
    which is considered a standard. Additionally, if we are planning to run our TypeScript
    application in a modern JavaScript engine, we will be able to use the ECMAScript
    6 module definition syntax at both design time and runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at each of the available module definition syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 modules (runtime and design time)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript 1.5 introduced support for the ES6 module syntax. The following
    code snippet defines an external module using the ES6 module syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t need to use the `namespace` keyword to declare an ES6 module, but
    we must use the `export` keyword. We can use the `export` keyword at the bottom
    of the module or when an entity is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also export an entity using an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'An export declaration exports all meanings of a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To import a module from another module, we must use the `import` keyword as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `import` keyword creates a variable for each imported component. In the
    preceding code snippet, a new variable named `UserModel` is declared, and its
    value contains a reference to the `UserModel` class, which is declared and exported
    by the imported module (the `model.ts` file).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `export` keyword to export multiple entities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can use the `import` keyword to import multiple entities from
    a single module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can also use the `default` keyword to declare the default entity
    to be imported when no explicit entities are imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then import the default export as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: ES6 modules work natively on modern JavaScript engines, but if you are targeting
    a JavaScript engine that doesn't support ES6 modules, you will need to use a tool
    such as webpack to enable backward compatibility with previous JavaScript engines.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy external modules (design time only)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before TypeScript 1.5, external modules were declared using a specific design-time
    syntax. However, once compiled into JavaScript, modules were transformed into
    AMD, CommonJS, UMD, or SystemJS modules.
  prefs: []
  type: TYPE_NORMAL
- en: We should **try to avoid using the legacy external module syntax and use the
    new ES6 syntax instead**. However, we will take a quick look at the external module
    syntax, because it is still possible to face it sometimes in old applications
    and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To export a module using the legacy external module syntax, we need to use
    the `export` keyword. We can apply the `export` keyword directly to a class or
    interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `export` keyword on its own by assigning to it the value
    that we desire to export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: External modules can be compiled into any of the available module definition
    syntaxes (AMD, CommonJS, SystemJS, or UMD).
  prefs: []
  type: TYPE_NORMAL
- en: 'The legacy external module syntax `import` statements look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: AMD modules (runtime only)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we compile the external module that we defined in the ES6 modules section
    into an AMD module (using the flag `--compile amd`), we will generate the following
    AMD module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `define` function takes an array as its first argument. This array contains
    a list of the names of the module dependencies. The second argument is a callback
    that will be invoked once all the module dependencies have been loaded. The callback
    takes each of the module dependencies as its parameters and contains all the logic
    from our TypeScript component. Notice how the return type of the callback matches
    the components that we declared as public by using the `export` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript will throw a compilation error because the `define` function is
    not declared. We can solve this problem by installing the RequireJS type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The AMD module can then be loaded using the RequireJS module loader as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As we can observe, AMD modules use two different functions to define modules
    (`define`) and consume modules (`require`). Usually, the application entry point
    uses the require function to load all the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We will not discuss AMD and RequireJS further in this book, but if you want
    to learn more about it, you can do so by visiting [http://requirejs.org/docs/start.html](http://requirejs.org/docs/start.html).
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS modules (runtime only)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we compile the external module that we defined in the ES6 modules section
    into an CommonJS module (using the flag `--compile commonjs`), we will obtain
    the following CommonJS module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, the CommonJS module definition
    syntax is almost identical to that of the legacy external module syntax. The main
    difference is the usage of the `module` object and its `exports` property instead
    of the `exports` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding CommonJS module can be loaded natively by a Node.js application
    using the `import` keyword and the `require` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: However, if we attempt to use the `require` function in a web browser, an exception
    will be thrown because the `require` function is undefined. We can easily solve
    this problem by using Browserify. Browserify is a module loader that allows us
    to use CommonJS modules in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more information about Browserify, visit the official documentation
    at [https://github.com/substack/node-browserify#usage](https://github.com/substack/node-browserify#usage).
  prefs: []
  type: TYPE_NORMAL
- en: UMD modules (runtime only)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to release a JavaScript library or framework, we will need to compile
    our TypeScript application into both CommonJS and AMD modules, as well as compile
    in a way that it can be used by developers who don't want to use a module loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web development community has developed the following code snippet to help
    us to achieve UMD support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is great, but we want to avoid manually adding it
    to every single module in our application. Fortunately, there are a few options
    available to achieve UMD support with ease.
  prefs: []
  type: TYPE_NORMAL
- en: The first option is to use the flag `--compile umd` to generate one UMD module
    for each module in our application. The second option is to create one single
    UMD module that will contain all the modules in the application using a module
    loader such as Browserify.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official Browserify project website at [http://browserify.org/](http://browserify.org/)
    to learn more about Browserify. Refer to the `Browserify-standalone` option to
    learn more about the generation of one unique optimized file.
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS modules (runtime only)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While UMD gives you a way to output a single module that works in both AMD and
    CommonJS, SystemJS will allow you to use ES6 modules closer to their native semantics
    without requiring an ES6-compatible browser engine.
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS was introduced by Angular 2.0, which is a popular web application development
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official SystemJS project website at [https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)
    to learn more about SystemJS.
  prefs: []
  type: TYPE_NORMAL
- en: There is a free list of common module mistakes available online at [http://www.typescriptlang.org/Handbook#modules-pitfalls-of-modules](http://www.typescriptlang.org/Handbook#modules-pitfalls-of-modules).
  prefs: []
  type: TYPE_NORMAL
- en: Modules summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can summarize all the preceding details using the following comparison table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module syntax** | **Design-time support** | **Module loader runtime support**
    | **Native runtime support** | **Optimization tool support** | **Recommended**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Legacy internal modules** | Yes | No | Yes (via closures) | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Namespaces** | Yes | No | Yes (via closures) | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| **ES6** | **Yes** | **Yes** | **Yes** | **Yes** | **Yes** |'
  prefs: []
  type: TYPE_TB
- en: '| **Legacy external modules** | Yes | Yes | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **AMD** | No | Yes | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **CommonJS** | No | Yes | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **UMD** | No | Yes | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **SystemJS** | No | Yes | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: As we can see, **the recommended solution going forward is the usage of ES6
    modules**. If you are targeting a JavaScript engine that doesn't support ES6 modules,
    you will need to use a tool such as webpack to enable backward compatibility with
    previous JavaScript engines.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about Webpack in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies in OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to work with application dependencies and third-party dependencies.
    We will now learn about the dependency inversion and extend what we learned in
    the previous chapter about the dependency inversion principle.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection versus dependency inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many articles use the terms *dependency injection* and *dependency inversion* as
    if their meanings were identical, but they are two very different concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example declares a class named `Ninja` and a class named `Katana`.
    The `Ninja` class has a dependency on the class `Katana`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the preceding classes, we can inject an instance of `Katana`
    into the `Ninja` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet implements the dependency injection design pattern
    because we are injecting a dependency (`Katana`) into the `Ninja` class. However,
    we are not implementing the dependency inversion principle because the `Ninja`
    class has a direct dependency on the `Katana` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship between the `Ninja` class and the `Katana` class can be represented
    using the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Ninja → Katana***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares an interface named `Weapon`, which is then
    implemented by the `Katana` class. This time, the `Ninja` class has a dependency
    on the `Weapon` interface instead of the `Katana` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the preceding classes, we can inject an instance of `Katana`
    into the `Ninja` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet implements the dependency injection design pattern
    because we are injecting a dependency (`Katana`) into the `Ninja` class. It also
    implements the dependency inversion principle because the `Ninja` class does not
    have a direct dependency on the `Katana` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, the relationship between the classes can be represented using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Ninja → Weapon ← Katana***'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the arrow that represents the relationship between the `Ninja`
    and the `Katana` classes has been inverted. This explains the name of the dependency
    inversion principle.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle is important because it makes our code easier
    to maintain by reducing the level of coupling between the entities in our application.
    For example, if we rename the `Katana` class, we will not need to change the `Ninja`
    class. This means that the `Katana` and the `Ninja` classes are fully independent
    of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of control containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **inversion of control** (**IoC**) container is a kind of tool that acts
    as a *smart factory*. An IoC container can be used to create instances of a class.
    If the class has some dependencies, the IoC container will be able to use dependency
    injection to cover the need for them. We say that the factory is *smart* because
    it can create dependencies based on matching conditions in the execution context
    and it can also control the life cycle of the instances that it creates.
  prefs: []
  type: TYPE_NORMAL
- en: When we use an IoC container, we are *losing control* of the creation of class
    instances, and the injection of dependencies and the IoC container will take control
    of these aspects of our application. This fact should explain the meaning of the
    term *inversion of control*.
  prefs: []
  type: TYPE_NORMAL
- en: InversifyJS basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: InversifyJS is an IoC container for TypeScript applications. InversifyJS can
    be used to implement the dependency inversion principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use InversifyJS, we need to install it using npm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then import some of the entities declared by `inversify` and `reflect-metadata`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet adds an annotation to the `Ninja` class using the
    `inject` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an instance of `Ninja` using InversifyJS, we need to create an instance
    of the `Container` class and declare what is known as **type binding**. A type
    binding is a link between a type and an implementation of that type. The following
    code snippet declares two type bindings. The first type binding links the type
    `Weapon` with the implementation `Katana`. The second type binding links the type
    `Ninja` to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create instances of the `Ninja` class using the container. The
    container uses the annotation to identify that the `Ninja` class has a dependency
    on the `Weapon` type. The container then creates an instance of the `Katana` class
    and is injected into the `Ninja` class because it knows that the `Katana` class
    is a valid implementation of the `Weapon` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'InversifyJS also allows us to control the life cycle of the dependencies. For
    example, we can configure the `Katana` type binding to make all instances a single
    shared instance (singleton):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also configure complex runtime constraints, which will determine how
    dependencies are resolved. For example, we could have two implementations of `Weapon`
    that are injected in different circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Circular dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A circular dependency is an issue that we can encounter when working with multiple
    components and dependencies. Sometimes it is possible to reach a point in which
    one component (A) has a dependency on a second component (B), which depends on
    the first component (A). In the following diagram, each node is a component, and
    we can observe that the nodes **circular1.ts** and **circular2.ts** (in red) have
    a circular dependency. The nodes without dependencies are displayed in green,
    and those with dependencies but no issues are displayed in blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2abf1609-4a3d-41de-8296-5c408b103420.png)'
  prefs: []
  type: TYPE_IMG
- en: The circular dependencies don't necessarily need to involve just two components.
    We can encounter scenarios in which a component depends on another component,
    which depends on other components, and some of the components in the dependency
    tree end up pointing to one of their parent components in the tree. InversifyJS
    will throw a runtime exception if a circular dependency is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics about managing third-party dependencies.
    We also learned the differences between internal and external modules, and each
    of the main kinds of modules in each of these categories.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to work with dependencies in object-oriented programming.
    Finally, we learned how to implement dependency injection and how to work with
    IoC containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the TypeScript/JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
