<html><head></head><body>
		<div id="_idContainer134">
			<h1 id="_idParaDest-259" class="chapter-number"><a id="_idTextAnchor261"/>14</h1>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor262"/>Logging in Microservices with Node.js</h1>
			<p>When working with microservices architecture and Node.js, it is important to enable and <span class="No-Break">check logs.</span></p>
			<p>We’ll start this chapter by understanding the core concepts of logging in microservices with Node.js. Logging is a critical aspect of microservices architecture, providing valuable insights into behavior, performance, and issues within a distributed system. In Node.js microservices, various logging techniques and libraries are employed to capture relevant information and robust logging systems for your <span class="No-Break">Node.js microservices.</span></p>
			<p>In a microservices architecture, logging plays a crucial role. Let me summarize what happens when there is no <span class="No-Break">proper logging:</span></p>
			<ul>
				<li><strong class="bold">Lack of visibility</strong>: Without logging, it becomes<a id="_idIndexMarker1097"/> challenging to track and understand what’s happening within individual microservices. You won’t have insights into their behavior, events, <span class="No-Break">or transactions.</span></li>
				<li><strong class="bold">Troubleshooting difficulties</strong>: When issues arise, troubleshooting<a id="_idIndexMarker1098"/> becomes cumbersome. Without logs, you won’t have information about errors, exceptions, or stack traces. Identifying failure points within a specific service becomes a <span class="No-Break">guessing game.</span></li>
				<li><strong class="bold">Holistic view missing</strong>: Each microservice may generate<a id="_idIndexMarker1099"/> its own logs, but without a centralized logging system, you won’t get a holistic view of the entire system. Patterns or trends that span multiple services may <span class="No-Break">remain hidden.</span></li>
			</ul>
			<p>Remember—proper logging ensures better visibility, faster troubleshooting, and a more robust <span class="No-Break">microservices architecture!</span></p>
			<p>By the end of this chapter, you will have learned how to debug better and faster in microservices <span class="No-Break">with Node.js.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Choosing a logging framework and defining <span class="No-Break">log levels</span></li>
				<li>Structured logging, log transport, <span class="No-Break">and storage</span></li>
				<li>Log filtering, sampling, error handling, and <span class="No-Break">exception logging</span></li>
				<li>Context propagation, monitoring, and <span class="No-Break">analyzing logs</span></li>
			</ul>
			<p>In the first section, we’re going to show how to choose a logging framework and define <span class="No-Break">log levels.</span></p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor263"/>Choosing a logging framework and defining log levels</h1>
			<p><strong class="bold">Logging</strong> is a crucial aspect of microservices, aiding in debugging, performance monitoring, and system analysis. By selecting an appropriate logging library and implementing best practices, you can build a robust logging system for your <span class="No-Break">Node.js microservices.</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor264"/>Choosing a logging library</h2>
			<p>A logging library is a piece of software<a id="_idIndexMarker1100"/> that can help you generate and manage log data from your Node.js application. Logging libraries can provide various features, such as different log levels, log formats, log transports, and log aggregation. Logging libraries can also improve the performance and functionality of your application by reducing the overhead of <strong class="source-inline">console.log</strong> and providing more information and control over your <span class="No-Break">log data.</span></p>
			<p>Selecting a suitable logging<a id="_idIndexMarker1101"/> library is the first step. Some popular logging libraries for Node.js include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Winston</strong>: A versatile logging library <a id="_idIndexMarker1102"/>with support for multiple transports (console, file, database). It allows for logging at different levels (<strong class="source-inline">info</strong>, <strong class="source-inline">debug</strong>, <strong class="source-inline">warn</strong>, <strong class="source-inline">error</strong>). Supports log formatting <span class="No-Break">and customization.</span></li>
				<li><strong class="bold">Bunyan</strong>: Emphasizes structured <a id="_idIndexMarker1103"/>logging, which is especially useful in microservices. Efficient for large-scale systems with high-throughput requirements. Supports log rotation and various <span class="No-Break">log levels.</span></li>
				<li><strong class="bold">Pino</strong>: Focused on fast and lightweight<a id="_idIndexMarker1104"/> logging. Well suited for high-performance applications. Supports JSON logging and customizable <span class="No-Break">log levels.</span></li>
			</ul>
			<p>These are the most used logging<a id="_idIndexMarker1105"/> libraries for Node.js, and they will help developers and system engineers save time while debugging and have no headaches while <span class="No-Break">creating systems.</span></p>
			<p>For this book, let’s choose the <em class="italic">Winston</em> logging library, which is a widely used and versatile logging library for Node.js applications. Winston allows you to log messages at different levels, and it supports various transports (e.g., console, <span class="No-Break">file, database).</span></p>
			<p>Let’s first install Winston using the command <span class="No-Break">given here:</span></p>
			<pre class="console">
npm install winston</pre>
			<p>Then, create a file (for example, <strong class="source-inline">logger.js</strong>) to configure Winston with different <span class="No-Break">log levels:</span></p>
			<pre class="source-code">
const winston = require('winston');
// Define log levels
const logLevels = {
  error: 0,
  warn: 1,
  info: 2,
  debug: 3,
};
// Define log level colors (optional)
const logColors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  debug: 'blue',
};
// Configure Winston logger
const logger = winston.createLogger({
  levels: logLevels,
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ level, message, timestamp }) =&gt; {
      return `${timestamp} [${level.toUpperCase()}]: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console({
      level: 'debug', // Log level for the console transport
      format: winston.format.combine(
        winston.format.colorize({ all: true }),
        winston.format.simple()
      ),
    }),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});
// Apply colors to log levels (optional)
winston.addColors(logColors);
module.exports = logger;</pre>
			<p>Now, you can use this logger in your application, as in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
const logger = require('./logger');
logger.error('This is an error message');
logger.warn('This is a warning message');
logger.info('This is an info message');
logger.debug('This is a debug message');</pre>
			<p>In this example, we’ve defined four log levels: <strong class="source-inline">error</strong>, <strong class="source-inline">warn</strong>, <strong class="source-inline">info</strong>, and <strong class="source-inline">debug</strong>. The levels are associated with increasing severity. The configuration also includes colorization for better visibility in the console. You can customize log levels, colors, and transports based on your <span class="No-Break">specific requirements.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.1</em> illustrates <span class="No-Break">logging libraries:</span></p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B14980_14_01.jpg" alt="Figure 14.1: Logging libraries (image by johnstocker on Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1: Logging libraries (image by johnstocker on Freepik)</p>
			<p>In summary, while <strong class="source-inline">console.log</strong> is straightforward and immediate, Winston provides more powerful features, including customizable log levels, structured formatting, and the ability to redirect logs to <span class="No-Break">various destinations.</span></p>
			<p><em class="italic">Best practice</em>: Instead of <strong class="source-inline">console.log</strong>, use a proper logging library (such as Winston or Bunyan). These allow you to control log levels, format messages, and direct logs to appropriate destinations (files, databases, and so on). Leaving <strong class="source-inline">console.log</strong> in production can inadvertently expose<a id="_idIndexMarker1106"/> sensitive information. Imagine accidentally logging user credentials or API keys! Remember – production logs matter. Make them meaningful, secure, <span class="No-Break">and efficient!</span></p>
			<p>Now, let’s move on to <span class="No-Break">log levels.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor265"/>Log levels</h2>
			<p><strong class="bold">Log levels</strong> are a way of categorizing<a id="_idIndexMarker1107"/> the severity and importance of log messages in Node.js. Log levels can help you filter, prioritize, and manage your log data more effectively. Log levels can also affect the performance and functionality of your application, depending on how you configure your <span class="No-Break">logging framework.</span></p>
			<p>Here are the main recommendations<a id="_idIndexMarker1108"/> for <span class="No-Break">log levels:</span></p>
			<ul>
				<li>Utilize different log levels (<strong class="source-inline">info</strong>, <strong class="source-inline">debug</strong>, <strong class="source-inline">warn</strong>, <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break">) appropriately.</span></li>
				<li>Adjust log levels dynamically based on the deployment environment <span class="No-Break">or configuration.</span></li>
			</ul>
			<p>Log levels are very important for a system<a id="_idIndexMarker1109"/> and need to be adjusted correctly to achieve what is required in terms of faster debugging <span class="No-Break">and performance.</span></p>
			<p>Additionally, remember that the log levels can be adjusted dynamically based on your environment or configuration, allowing<a id="_idIndexMarker1110"/> you to control the verbosity of your logs in <span class="No-Break">different scenarios.</span></p>
			<p>With an understanding of these concepts, let’s now move to structured logging, log transport, <span class="No-Break">and storage.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor266"/>Structured logging, log transport, and storage</h1>
			<p>Structured logging, log transport, and storage are related concepts that can help you manage and analyze your application logs more effectively. Let’s look at structured logging in depth in <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor267"/>Structured logging</h2>
			<p><strong class="bold">Structured logging</strong> is a method of logging <a id="_idIndexMarker1111"/>where log messages are formatted as a set of key-value pairs or as JSON objects. This format makes logs more machine-readable and allows for easier parsing, filtering, and analysis. When combined with appropriate log transport and storage mechanisms, structured logging becomes a powerful tool for monitoring and troubleshooting in <span class="No-Break">microservices architectures.</span></p>
			<p>Here are some benefits<a id="_idIndexMarker1112"/> of <span class="No-Break">structured logging:</span></p>
			<ul>
				<li><strong class="bold">Machine readability</strong>: Structured logs are easily parseable by machines, facilitating automated <span class="No-Break">log analysis.</span></li>
				<li><strong class="bold">Contextual information</strong>: Key-value pairs allow the inclusion of contextual information with log messages, aiding <span class="No-Break">in troubleshooting.</span></li>
				<li><strong class="bold">Consistency</strong>: A consistent log format makes it easier to create log analysis tools and ensures uniformity across <span class="No-Break">different microservices.</span></li>
			</ul>
			<p>Now, let’s look at an implementation of structured logging with <span class="No-Break">Winston (Node.js):</span></p>
			<pre class="source-code">
const winston = require('winston');
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.simple(),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
  ],
});
logger.info('This is an info message');
logger.error('This is an error message');</pre>
			<p>In the preceding example, the log<a id="_idIndexMarker1113"/> message includes structured data as <span class="No-Break">key-value pairs.</span></p>
			<p>What is sensitive data? Sensitive data refers<a id="_idIndexMarker1114"/> to private information that must be protected from unauthorized access. While the specifics may vary depending on your context, here are some common<a id="_idIndexMarker1115"/> types of <span class="No-Break">sensitive data:</span></p>
			<ul>
				<li><strong class="bold">Personally identifiable information (PII)</strong>: This includes data such as full names, addresses, email addresses, driver’s license numbers, and <span class="No-Break">phone numbers.</span></li>
				<li><strong class="bold">Financial data</strong>: Credit card information and other financial details fall into <span class="No-Break">this category.</span></li>
				<li><strong class="bold">Healthcare data</strong>: Medical history, records, and any <span class="No-Break">health-related information.</span></li>
				<li><strong class="bold">Passwords</strong>: Storing passwords in logs is a significant <span class="No-Break">security risk.</span></li>
				<li><strong class="bold">IP addresses</strong>: Although not always strictly sensitive, leaking IP addresses can have <span class="No-Break">privacy implications.</span></li>
			</ul>
			<p>Remember that data sensitivity depends on your business context. Even seemingly innocuous details (such as zip codes) should be handled carefully if their exposure could harm your business or erode <span class="No-Break">customer trust.</span></p>
			<p>Here are some best practices<a id="_idIndexMarker1116"/> for avoiding sensitive <span class="No-Break">data logging:</span></p>
			<ul>
				<li><strong class="bold">Exclude sensitive data</strong>: The simplest approach is to avoid logging sensitive data altogether. Only log <span class="No-Break">necessary information.</span></li>
				<li><strong class="bold">Use structured logging</strong>: Format logs in a structured way (for example, JSON) to make them more manageable <span class="No-Break">and searchable.</span></li>
				<li><strong class="bold">Log levels</strong>: Set different log levels (<strong class="source-inline">INFO</strong>, <strong class="source-inline">DEBUG</strong>, <strong class="source-inline">ERROR</strong>) and be selective about what <span class="No-Break">gets logged.</span></li>
				<li><strong class="bold">Centralized logging</strong>: Use a centralized system to collect and store <span class="No-Break">logs securely.</span></li>
				<li><strong class="bold">Mask sensitive data</strong>: If you must log certain data (for example, for debugging), mask or redact sensitive<a id="_idIndexMarker1117"/> parts (for example, replace credit card numbers <span class="No-Break">with asterisks).</span></li>
			</ul>
			<p>Remember – handling sensitive data responsibly is crucial for both security <span class="No-Break">and compliance.</span></p>
			<p>With these concepts learned, we can continue with log transport <span class="No-Break">and storage.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor268"/>Log transport and storage</h2>
			<p>Structured logging, when combined <a id="_idIndexMarker1118"/>with appropriate <strong class="bold">log transport and storage</strong> mechanisms, enhances the observability and manageability of microservices. Log transport and storage are the processes of moving and storing your log data from your application to a log <span class="No-Break">management system.</span></p>
			<p>Here are the most <span class="No-Break">common mechanisms:</span></p>
			<ul>
				<li><strong class="bold">Console transport</strong>: Logs are often initially<a id="_idIndexMarker1119"/> output to the console for development and debugging purposes. Console transport is quick and easy to set up, as <span class="No-Break">shown here:</span><pre class="source-code">
new winston.transports.Console()</pre></li>
				<li><strong class="bold">File transport</strong>: Logs can be stored in files for later<a id="_idIndexMarker1120"/> analysis. File transports are suitable for storing logs locally and can be set up <span class="No-Break">like this:</span><pre class="source-code">
new winston.transports.File({ filename: 'error.log', level: 'error' })</pre></li>
				<li><strong class="bold">Cloud-based storage</strong>: For cloud-based storage, consider services such as Amazon CloudWatch, Google<a id="_idIndexMarker1121"/> Cloud Logging, or Azure Monitor. These services provide scalable, searchable, and centralized log storage. Here’s how to set <span class="No-Break">them up:</span><pre class="source-code">
const { CloudWatchLogTransport } = require('winston-aws-cloudwatch');</pre><pre class="source-code">
new CloudWatchLogTransport({</pre><pre class="source-code">
  logGroupName: 'your-log-group-name',</pre><pre class="source-code">
  logStreamName: 'your-log-stream-name',</pre><pre class="source-code">
  level: 'info',</pre><pre class="source-code">
  formatLog: (info) =&gt; `${info.timestamp} ${info.message}`,</pre><pre class="source-code">
})</pre></li>
				<li><strong class="bold">ELK Stack (Elasticsearch, Logstash, Kibana)</strong>: The ELK Stack is a popular open source solution<a id="_idIndexMarker1122"/> for log storage and <a id="_idIndexMarker1123"/>analysis. It allows you to index logs in Elasticsearch, process them with Logstash, and visualize them <span class="No-Break">using Kibana.</span></li>
				<li><strong class="bold">Centralized logging solutions</strong>: Services such as Splunk, Sumo Logic, or Datadog <a id="_idIndexMarker1124"/>offer centralized logging solutions. <strong class="bold">Centralized logging solutions</strong> are systems that collect, store, and analyze<a id="_idIndexMarker1125"/> log data from multiple sources, such as Node.js applications, servers, networks, or other services. Centralized logging solutions can help you monitor, troubleshoot, and optimize your Node.js applications by providing a unified and comprehensive view of your log data. Centralized logging solutions can also help you improve the security, performance, and reliability of your Node.js applications by detecting and resolving issues faster, reducing log noise, and enhancing log quality with advanced features such as search, analytics, <span class="No-Break">and alerting.</span></li>
			</ul>
			<p>In summary, the choice of transport and storage depends on factors such as scalability, analysis requirements, and the overall architecture of <span class="No-Break">your application.</span></p>
			<p>Now, we can continue to the next section, in which we will talk about log filtering, sampling, error handling, and <span class="No-Break">exception logging.</span></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor269"/>Log filtering, sampling, error handling, and exception logging</h1>
			<p>In a microservices architecture, effective <strong class="bold">log filtering</strong>, <strong class="bold">sampling</strong>, <strong class="bold">error handling</strong>, and <strong class="bold">exception logging</strong> are crucial for managing logs efficiently and gaining insights into the <span class="No-Break">system’s behavior.</span></p>
			<p>Here’s how you can approach <span class="No-Break">these aspects:</span></p>
			<ul>
				<li><strong class="bold">Log filtering</strong>: Log filtering involves selectively capturing<a id="_idIndexMarker1126"/> and storing log entries based on specific criteria. This is essential for managing the volume of logs and focusing on <span class="No-Break">relevant information.</span><p class="list-inset">Here is its implementation with <span class="No-Break">Winston (Node.js):</span></p><pre class="source-code">
const winston = require('winston');</pre><pre class="source-code">
const logger = winston.createLogger({</pre><pre class="source-code">
  format: winston.format.simple(),</pre><pre class="source-code">
  transports: [</pre><pre class="source-code">
    new winston.transports.Console(),</pre><pre class="source-code">
    new winston.transports.File({ filename: 'error.log', level: 'error' }),</pre><pre class="source-code">
    new winston.transports.File({ filename: 'combined.log' }),</pre><pre class="source-code">
  ],</pre><pre class="source-code">
  // Filtering to include only error logs in a specific file</pre><pre class="source-code">
  exceptionHandlers: [</pre><pre class="source-code">
    new winston.transports.File({ filename: 'exceptions.log' }),</pre><pre class="source-code">
  ],</pre><pre class="source-code">
});</pre><pre class="source-code">
logger.info('This will be logged');</pre><pre class="source-code">
logger.error('This will be logged as an error');</pre><pre class="source-code">
// Manually throw an exception to trigger the exception handler</pre><pre class="source-code">
try {</pre><pre class="source-code">
  throw new Error('This is a manually triggered exception');</pre><pre class="source-code">
} catch (error) {</pre><pre class="source-code">
  logger.error('Caught an exception:', error);</pre><pre class="source-code">
}</pre><p class="list-inset">In this example, logs are<a id="_idIndexMarker1127"/> filtered based on severity levels, and exceptions are <span class="No-Break">separately handled.</span></p></li>
				<li><strong class="bold">Log sampling</strong>: Log sampling involves capturing<a id="_idIndexMarker1128"/> a subset of logs, rather than logging every event. This is useful when dealing with high-volume systems to avoid overwhelming <span class="No-Break">log storage.</span><p class="list-inset">Here’s an implementation of log sampling <span class="No-Break">with Winston:</span></p><pre class="source-code">
const winston = require('winston');</pre><pre class="source-code">
const logger = winston.createLogger({</pre><pre class="source-code">
  format: winston.format.simple(),</pre><pre class="source-code">
  transports: [</pre><pre class="source-code">
    new winston.transports.Console(),</pre><pre class="source-code">
    new winston.transports.File({ filename: 'sampled.log' }),</pre><pre class="source-code">
  ],</pre><pre class="source-code">
});</pre><pre class="source-code">
// Custom sampling function to log only 10% of the messages</pre><pre class="source-code">
const samplingFunction = (info) =&gt; Math.random() &lt; 0.1 ? info : false;</pre><pre class="source-code">
logger.add(</pre><pre class="source-code">
  new winston.transports.File({</pre><pre class="source-code">
    filename: 'sampled.log',</pre><pre class="source-code">
    format: winston.format.combine(</pre><pre class="source-code">
      winston.format(info =&gt; samplingFunction(info))(),</pre><pre class="source-code">
      winston.format.simple()</pre><pre class="source-code">
    ),</pre><pre class="source-code">
  })</pre><pre class="source-code">
);</pre><pre class="source-code">
for (let i = 0; i &lt; 100; i++) {</pre><pre class="source-code">
  logger.info(`Log message ${i}`);</pre><pre class="source-code">
}</pre><p class="list-inset">In this example, only approximately 10% of log<a id="_idIndexMarker1129"/> messages are written to the <span class="No-Break"><strong class="source-inline">sampled.log</strong></span><span class="No-Break"> file.</span></p></li>
				<li><strong class="bold">Error handling and exception logging</strong>: Error handling is crucial for<a id="_idIndexMarker1130"/> identifying and resolving issues in a microservices architecture. Logging exceptions with detailed information aids <span class="No-Break">in debugging.</span><p class="list-inset">Here’s an implementation of error handling<a id="_idIndexMarker1131"/> with exception logging <span class="No-Break">with Winston:</span></p><pre class="source-code">
const winston = require('winston');</pre><pre class="source-code">
const logger = winston.createLogger({</pre><pre class="source-code">
  format: winston.format.simple(),</pre><pre class="source-code">
  transports: [</pre><pre class="source-code">
    new winston.transports.Console(),</pre><pre class="source-code">
    new winston.transports.File({ filename: 'error.log', level: 'error' }),</pre><pre class="source-code">
  ],</pre><pre class="source-code">
  exceptionHandlers: [</pre><pre class="source-code">
    new winston.transports.File({ filename: 'exceptions.log' }),</pre><pre class="source-code">
  ],</pre><pre class="source-code">
});</pre><pre class="source-code">
// Example of logging an exception</pre><pre class="source-code">
try {</pre><pre class="source-code">
  // Some code that might throw an exception</pre><pre class="source-code">
  throw new Error('This is an exception');</pre><pre class="source-code">
} catch (error) {</pre><pre class="source-code">
  logger.error('Caught an exception:', error);</pre><pre class="source-code">
}</pre><p class="list-inset">In this example, the exception is caught, and the details are logged separately in the <span class="No-Break"><strong class="source-inline">exceptions.log</strong></span><span class="No-Break"> file.</span></p></li>
			</ul>
			<p>In summary, use filtering<a id="_idIndexMarker1132"/> to include or exclude logs based on specific criteria, such as severity<a id="_idIndexMarker1133"/> levels or custom conditions. Implement log sampling to capture a subset of logs, especially in high-volume systems, to avoid overwhelming log storage. Properly handle errors in your code and log detailed information about exceptions to aid in debugging and troubleshooting. Separate exception logs from regular logs <span class="No-Break">for clarity.</span></p>
			<p>Tailoring log filtering and sampling to your specific application and environment is essential for achieving the right balance<a id="_idIndexMarker1134"/> between capturing valuable information and managing<a id="_idIndexMarker1135"/> log <span class="No-Break">volume efficiently.</span></p>
			<p>In the next section, we will learn about context propagation, monitoring, and <span class="No-Break">analyzing logs.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor270"/>Context propagation, monitoring, and analyzing logs</h1>
			<p>Context propagation, monitoring, and log analysis are critical aspects of managing microservices in a distributed system. In this section, we take a deeper look at <span class="No-Break">context propagation.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor271"/>Context propagation</h2>
			<p>In microservices, where requests<a id="_idIndexMarker1136"/> can traverse multiple services, propagating context information is essential for tracking and understanding the flow of requests. Contextual information, often in the form of headers or tokens, allows you to correlate logs across <span class="No-Break">different microservices.</span></p>
			<p>Here is an example of context propagation. In a Node.js environment with Express.js, you can use middleware to propagate <span class="No-Break">context information:</span></p>
			<pre class="source-code">
// Middleware to add context to requests
app.use((req, res, next) =&gt; {
  // Add a unique request ID to the request
  req.requestId = generateRequestId();
  // Log the start of the request
  logger.info(`[${new Date()}] Start processing request ${req.requestId}`);
  next();
});
// Middleware for logging requests
app.use((req, res, next) =&gt; {
  // Log relevant information with the request context
  logger.info(`[${new Date()}] ${req.method} ${req.url} - Request ID: ${req.requestId}`);
  next();
});
// Other middleware and routes
// Error handling middleware
app.use((err, req, res, next) =&gt; {
  // Log errors with the request context
  logger.error(`[${new Date()}] Error processing request ${req.requestId}: ${err.message}`, err);
  res.status(500).send('Something went wrong!');
});</pre>
			<p>In this example, a unique request ID is added to the request, and it’s used to log the start of the request and any errors that occur. Context propagation in Node.js is the process of transferring context information, such as trace IDs, across asynchronous boundaries, such as callbacks, promises, or event emitters. Context propagation enables distributed tracing, which allows you to monitor and analyze the performance and behavior of your Node.js applications<a id="_idIndexMarker1137"/> across multiple services <span class="No-Break">and processes.</span></p>
			<p>In the next section, we will talk <span class="No-Break">about monitoring.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor272"/>Monitoring</h2>
			<p><strong class="bold">Monitoring</strong> involves actively observing<a id="_idIndexMarker1138"/> the behavior and performance<a id="_idIndexMarker1139"/> of microservices to ensure they meet <strong class="bold">service-level objectives</strong> (<strong class="bold">SLOs</strong>) and to identify and address <span class="No-Break">issues proactively.</span></p>
			<p>The following are some tools<a id="_idIndexMarker1140"/> <span class="No-Break">for monitoring:</span></p>
			<ul>
				<li><strong class="bold">Prometheus</strong>: An open source monitoring and alerting<a id="_idIndexMarker1141"/> toolkit designed for reliability <span class="No-Break">and scalability.</span></li>
				<li><strong class="bold">Grafana</strong>: Works well with Prometheus<a id="_idIndexMarker1142"/> to visualize and <span class="No-Break">analyze metrics.</span></li>
				<li><strong class="bold">Datadog, New Relic, or AppDynamics</strong>: Commercial solutions<a id="_idIndexMarker1143"/> that provide comprehensive<a id="_idIndexMarker1144"/> monitoring<a id="_idIndexMarker1145"/> capabilities, including performance metrics, error rates, and<a id="_idIndexMarker1146"/> <span class="No-Break">distributed tracing.</span></li>
			</ul>
			<p>These are just some of the tools that can help you monitor your Node.js applications. You can also use other tools or methods, such as the built-in Node.js debugger, the <strong class="source-inline">console</strong> module, or the <strong class="source-inline">node:async_hooks</strong> module. The choice of the tool depends on your specific needs and goals. You can also combine different tools to get a more complete picture of your application’s performance <span class="No-Break">and behavior.</span></p>
			<p>In the next section, we will talk about <span class="No-Break">log analysis.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor273"/>Log analysis</h2>
			<p><strong class="bold">Log analysis</strong> involves extracting valuable<a id="_idIndexMarker1147"/> insights from logs to understand the behavior of microservices, troubleshoot issues, and identify areas <span class="No-Break">for optimization.</span></p>
			<p>Here are some tools<a id="_idIndexMarker1148"/> for <span class="No-Break">log analysis:</span></p>
			<ul>
				<li><strong class="bold">ELK Stack</strong>: Elasticsearch is used for <a id="_idIndexMarker1149"/>indexing logs, Logstash for log processing, and Kibana <span class="No-Break">for visualization.</span></li>
				<li><strong class="bold">Splunk</strong>: A commercial log analysis<a id="_idIndexMarker1150"/> platform that allows you to search, monitor, and analyze <span class="No-Break">machine-generated data.</span></li>
				<li><strong class="bold">Graylog</strong>: An open source log management<a id="_idIndexMarker1151"/> platform with search and <span class="No-Break">analysis capabilities.</span></li>
			</ul>
			<p>In summary, propagate context information, such as request IDs, across microservices to correlate logs and trace the flow of requests. Actively monitor microservices using tools such as Prometheus, Grafana, Datadog, or others to ensure they meet performance and reliability objectives. Use log analysis tools such as the ELK Stack, Splunk, or Graylog to extract meaningful insights from logs and facilitate troubleshooting <span class="No-Break">and optimization.</span></p>
			<p>By effectively implementing context propagation, monitoring, and log analysis, you can enhance the observability of your microservices, making it easier to maintain, troubleshoot, and optimize the <span class="No-Break">entire system.</span></p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor274"/>Summary</h1>
			<p>In this chapter, we have learned a lot about microservices and how to monitor microservices in Node.js using several principles <span class="No-Break">and tools.</span></p>
			<p>In summary, logging in microservices with Node.js is a crucial aspect of ensuring observability, troubleshooting, and maintaining the health of a distributed system. Here’s a summary of <span class="No-Break">key points:</span></p>
			<ul>
				<li><strong class="bold">Logging libraries</strong>: Use logging libraries such as Winston in Node.js for structured and <span class="No-Break">flexible logging.</span></li>
				<li><strong class="bold">Log levels</strong>: Utilize different log levels (for example, <strong class="source-inline">error</strong>, <strong class="source-inline">warn</strong>, <strong class="source-inline">info</strong>, <strong class="source-inline">debug</strong>) to categorize and prioritize logs based <span class="No-Break">on severity.</span></li>
				<li><strong class="bold">Structured logging</strong>: Implement structured logging by formatting logs as key-value pairs or JSON objects for better <span class="No-Break">machine readability.</span></li>
				<li><strong class="bold">Context propagation</strong>: Propagate contextual information (for example, request IDs) across microservices to correlate logs and trace the flow <span class="No-Break">of requests.</span></li>
				<li><strong class="bold">Error handling</strong>: Implement error handling and exception logging to capture detailed information about errors, aiding <span class="No-Break">in debugging.</span></li>
				<li><strong class="bold">Log filtering and sampling</strong>: Apply log filtering to selectively capture logs based on criteria such as severity levels. Consider log sampling to capture a subset of logs, especially in <span class="No-Break">high-volume systems.</span></li>
				<li><strong class="bold">Log transport and storage</strong>: Choose appropriate log transports (for example, console, file, cloud-based storage) based on your application’s needs <span class="No-Break">and architecture.</span></li>
				<li><strong class="bold">Monitoring</strong>: Actively monitor microservices using tools such as Prometheus, Grafana, Datadog, or commercial solutions to ensure performance <span class="No-Break">and reliability.</span></li>
				<li><strong class="bold">Log analysis</strong>: Leverage log analysis tools such as the ELK Stack, Splunk, or Graylog to extract valuable insights from logs for troubleshooting <span class="No-Break">and optimization.</span></li>
				<li><strong class="bold">Centralized logging</strong>: Consider centralized logging solutions for better aggregation, search, and analysis of logs. Effective logging practices contribute to the overall observability of microservices, facilitating quick identification and resolution of issues, optimizing performance, and improving the reliability of the <span class="No-Break">entire system.</span></li>
			</ul>
			<p>In the next chapter, we are going to learn about interpreting monitoring data <span class="No-Break">in microservices.</span></p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor275"/>Quiz time</h1>
			<ul>
				<li>What are some popular logging libraries <span class="No-Break">for Node.js?</span></li>
				<li>What is <span class="No-Break">structured logging?</span></li>
				<li>What are log filtering, sampling, error handling and <span class="No-Break">exception logging?</span></li>
			</ul>
		</div>
	</body></html>