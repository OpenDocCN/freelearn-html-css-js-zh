<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing the Reflect API</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Reflect API is used for object reflection (that is, inspecting and manipulating the properties of objects). Although ES5 already had APIs for object reflection, these APIs were not well organized and, on failure, used to throw an exception. The Reflect API is well organized and makes it easier to read and write code, as it doesn't throw exceptions on failure. Instead, it returns the Boolean value, representing if the operation was true or false. Since developers are adapting to the Reflect API for object reflection, it's important to learn this API in depth. In this chapter, we'll cover:</p>
<ul>
<li class="mce-root">Calling a function with a given <kbd>this</kbd> value</li>
<li class="mce-root">Invoking a constructor with the prototype property of another constructor</li>
<li class="mce-root">Defining or modifying the attributes of the object properties</li>
<li class="mce-root">Enumerating the properties of an object using an iterator object</li>
<li class="mce-root">Retrieving and setting the internal [[prototype]] property of an object</li>
<li class="mce-root">A lot of other operations related to inspecting and manipulating methods and properties of objects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect object</h1>
                </header>
            
            <article>
                
<p>The global <kbd>Reflect</kbd> object exposes all the new methods for object reflection. <kbd>Reflect</kbd> is not a function object; therefore, you cannot invoke the <kbd>Reflect</kbd> object. Also, you cannot use it with the <kbd>new</kbd> operator. All the methods of the Reflect API are wrapped in the <kbd>Reflect</kbd> object to make it look well organized.</p>
<p>The <kbd>Reflect</kbd> object provides many methods, which overlap with the global object's methods in terms of functionality. Let's see the various methods provided by the <kbd>Reflect</kbd> object for object reflection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.apply(function, this, args) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.apply()</kbd> method is used to invoke a function with a given <kbd>this</kbd> value. The function invoked by <kbd>Reflect.apply()</kbd> is called as the target function. It's the same as the <kbd>apply()</kbd> method of the function object. The <kbd>Reflect.apply()</kbd> method takes three arguments:</p>
<ul>
<li>The first argument represents the target function.</li>
<li>The second argument represents the value of <kbd>this</kbd> inside the target function. This argument is optional.</li>
<li>The third argument is an array object, specifying the arguments of the target function. This argument is optional.</li>
</ul>
<p>The <kbd>Reflect.apply()</kbd> method returns whatever the target function returns. Here is a code example to demonstrate how to use the <kbd>Reflect.apply()</kbd> method:</p>
<pre>function function_name(a, b, c) { <br/>  return this.value + a + b + c; <br/>} <br/>var returned_value = Reflect.apply(function_name, {value: 100}, [10, 20, 30]); <br/>console.log(returned_value); //Output "160"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.construct(constructor, args, prototype) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.construct()</kbd> method is used to invoke a function as a constructor. It's similar to the <kbd>new</kbd> operator. The function that will be invoked is called as the target constructor.</p>
<p>One special reason why you may want to use the <kbd>Reflect.construct()</kbd> method instead of the <kbd>new</kbd> operator is that you can target the constructor's prototype to match the prototype of another constructor.</p>
<p>The <kbd>Reflect.construct()</kbd> method takes three arguments:</p>
<ul>
<li>The first argument is the target constructor.</li>
<li>The second argument is an array, specifying the arguments of the target constructor. This argument is optional.</li>
<li>The third argument is another constructor whose prototype will be used as the prototype of the target constructor. This argument is optional. The <kbd>Reflect.construct()</kbd> method returns the new instance created by the target constructor.</li>
</ul>
<p>Here is the code example, to demonstrate how to use the <kbd>Reflect.constructor()</kbd> method:</p>
<pre>function constructor1(a, b) { <br/>  this.a = a; <br/>  this.b = b; <br/>  this.f = function(){ <br/>    return this.a + this.b + this.c; <br/>  } <br/>} <br/>function constructor2(){<br/>} <br/>constructor2.prototype.c = 100; <br/>var myObject = Reflect.construct(constructor1, [1,2], constructor2); <br/>console.log(myObject.f()); //Output "103" </pre>
<p>In the preceding example, we used the prototype chain of <kbd>consturctor2</kbd> as the prototype of <kbd>constructor1</kbd> while invoking <kbd>constructor1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.defineProperty(object, property, descriptor) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.defineProperty()</kbd> method defines a new property directly on an object or modifies an existing property on an object. It returns a Boolean value indicating whether the operation was successful or not.</p>
<p>It's similar to the <kbd>Object.defineProperty()</kbd> method. The difference is that the <kbd>Reflect.defineProperty()</kbd> method returns a Boolean, whereas the <kbd>Object. defineProperty()</kbd> returns the modified object. If the <kbd>Object.defineProperty()</kbd> method fails to modify or define an object property, then it throws an exception, whereas the <kbd>Reflect.defineProperty()</kbd> method returns a <kbd>false</kbd> result. The <kbd>Reflect.defineProperty()</kbd> method takes in three arguments:</p>
<ul>
<li>The first argument is the object that is used to define or modify a property</li>
<li>The second argument is the symbol or name of the property that is to be defined or modified</li>
<li>The third argument is the descriptor for the property that is being defined or modified</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the data properties and accessor properties</h1>
                </header>
            
            <article>
                
<p>Since ES5, every object property is either a data property or an accessor property. A data property has a value, which may or may not be writable, whereas an accessor property has a getter-setter pair of functions to set and retrieve the property value.</p>
<p>The attributes of a data property are <kbd>value</kbd>, <kbd>writable</kbd>, <kbd>enumerable</kbd>, and <kbd>configurable</kbd>. On the other hand, the attributes of an accessor property are <kbd>set</kbd>, <kbd>get</kbd>, <kbd>enumerable</kbd>, and <kbd>configurable</kbd>.</p>
<p>A descriptor is an object that describes the attributes of a property. When creating a property using the <kbd>Reflect.defineProperty()</kbd> method, the <kbd>Object. defineProperty()</kbd> method, the <kbd>Object.defineProperties()</kbd> method, or the <kbd>Object.create()</kbd> method, we need to pass a descriptor for the property.</p>
<p>A data property's descriptor object has the following properties:</p>
<ul>
<li><strong>Value:</strong> This is the value associated with the property. The default value is <kbd>undefined</kbd>.</li>
<li><strong>Writable:</strong> If this is <kbd>true</kbd>, then the property value can be changed with an assignment operator. The default value is <kbd>false</kbd>.</li>
<li><strong>Configurable:</strong> If this is <kbd>true</kbd>, then the property attributes can be changed, and the property may be deleted. The default value is <kbd>false</kbd>. Remember, when the configurable attribute is <kbd>false</kbd> and the writable is <kbd>true</kbd>, the value and the writable attributes can be changed.</li>
<li><strong>Enumerable:</strong> If this is <kbd>true</kbd>, then the property shows up in the <kbd>for…in</kbd> loop and the <kbd>Object.keys()</kbd> method. The default value is <kbd>false</kbd>.</li>
</ul>
<p>An accessor property's descriptor has the following properties:</p>
<ul>
<li><strong>Get:</strong> This is a function that returns the property value. The function has no parameters and the default value is <kbd>undefined</kbd>.</li>
<li><strong>Set:</strong> This is a function that sets the property value. The function will receive the new value that is being assigned to the property.</li>
<li><strong>Configurable:</strong> If this is <kbd>true</kbd>, then the property descriptor can be changed and the property may be deleted. The default value is <kbd>false</kbd>.</li>
<li><strong>Enumerable:</strong> If this is <kbd>true</kbd>, then the property shows up in the <kbd>for…in</kbd> loop and the <kbd>Object.keys()</kbd> method. The default value is <kbd>false</kbd>.</li>
</ul>
<p>Depending on the properties of the descriptor object, JavaScript decides whether the property is a data property or an accessor property.</p>
<p>If you add a property without using the <kbd>Reflect.defineProperty()</kbd> method, the <kbd>Object.defineProperty()</kbd> method, the <kbd>Object.defineProperties()</kbd> method, or the <kbd>Object.create()</kbd> method, then the property is a data property and the writable, enumerable, and configurable attributes are all set to <kbd>true</kbd>. After the property is added, you can modify its attributes.</p>
<p>If an object already has a property with the specified name while calling the <kbd>Reflect.defineProperty()</kbd> method, the <kbd>Object.defineProperty()</kbd> method, or the <kbd>Object.defineProperties()</kbd> method, then the property is modified. The attributes that are not specified in the descriptor remain the same.</p>
<p>You can change a data property to an accessor property, and vice versa. If you do this, the configurable and enumerable attributes that are not specified in the descriptor will be preserved in the property. Other attributes that are not specified in the descriptor are set to their default values.</p>
<p>Here is example code that demonstrates how to create a data property using the <kbd>Reflect.defineProperty()</kbd> method:</p>
<pre>var obj = {}<br/>Reflect.defineProperty(obj, "name", { <br/>  value: "Eden", <br/>  writable: true, <br/>  configurable: true, <br/>  enumerable: true <br/>}); <br/>console.log(obj.name); //Output "Eden"</pre>
<p>Here is more example code that demonstrates how to create an accessor property using the <kbd>Reflect.defineProperty()</kbd> method:</p>
<pre>var obj = { __name__: "Eden" } <br/>Reflect.defineProperty(obj, "name", { <br/>  get: function(){<br/>    return this.__name__; <br/>  }, <br/>  set: function(newName){ <br/>    this.__name__ = newName; <br/>  }, <br/>  configurable: true, <br/>  enumerable: true <br/>}); <br/>obj.name = "John"; <br/>console.log(obj.name); //Output "John"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.deleteProperty(object, property) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.deleteProperty()</kbd> method is used to delete a property of an object. It's the same as the <kbd>delete</kbd> operator.</p>
<p>This method takes two arguments--that is, the first argument is the reference to the object and the second argument is the name of the property to delete. The <kbd>Reflect. deleteProperty()</kbd> method returns <kbd>true</kbd> if it has deleted the property successfully. Otherwise, it returns <kbd>false</kbd>.</p>
<p>Here is a code example that demonstrates how to delete a property using the <kbd>Reflect.deleteProperty()</kbd> method:</p>
<pre>var obj = { name: "Eden" } <br/>console.log(obj.name); //Output "Eden" <br/>Reflect.deleteProperty(obj, "name"); <br/>console.log(obj.name); //Output "undefined"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.get(object, property, this) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.get()</kbd> method is used to retrieve the value of an object's property. The first argument is the object and the second argument is the property name. If the property is an accessor property, then we can provide a third argument, which will be the value of <kbd>this</kbd> inside the <kbd>get</kbd> function.</p>
<p>Here is a code example that demonstrates how to use the <kbd>Reflect.get()</kbd> method:</p>
<pre>var obj = { __name__: "Eden" };<br/>Reflect.defineProperty(obj, "name", { <br/>  get: function(){ <br/>    return this.__name__; <br/>  } <br/>}); <br/>console.log(obj.name); //Output "Eden" <br/>var name = Reflect.get(obj, "name", {__name__: "John"}); <br/>console.log(name); //Output "John"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.set(object, property, value, this) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.set()</kbd> method is used to set the value of an object's property. The first argument is the object, the second argument is the property name, and the third argument is the property value. If the property is an accessor property, then we can provide a fourth argument, which will be the value of <kbd>this</kbd> inside the <kbd>set</kbd> function.</p>
<p>The <kbd>Reflect.set()</kbd> method returns <kbd>true</kbd> if the property value was set successfully. Otherwise, it returns <kbd>false</kbd>.</p>
<p>Here is a code example that demonstrates how to use the <kbd>Reflect.set()</kbd> method:</p>
<pre>var obj1 = { __name__: "Eden" }; <br/>Reflect.defineProperty(obj1, "name", { <br/>  set: function(newName){ <br/>    this.__name__ = newName; <br/>  }, <br/>  get: function(){ <br/>    return this.__name__; <br/>  }<br/>}); <br/>var obj2 = { __name__: "John" };<br/>Reflect.set(obj1, "name", "Eden", obj2); <br/>console.log(obj1.name); //Output "Eden" <br/>console.log(obj2.__name__); //Output "Eden"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.getOwnPropertyDescriptor(object, property) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.getOwnPropertyDescriptor()</kbd> method is used to retrieve the descriptor of an object's property.</p>
<p>The <kbd>Reflect.getOwnPropertyDescriptor()</kbd> method is the same as the <kbd>Object.getOwnPropertyDescriptor()</kbd> method. The <kbd>Reflect. getOwnPropertyDescriptor()</kbd> method takes two arguments. The first argument is the object and the second argument is the property name.</p>
<p>Here is an example to demonstrate the <kbd>Reflect.getOwnPropertyDescriptor()</kbd> method:</p>
<pre>var obj = { name: "Eden" }; <br/>var descriptor = Reflect.getOwnPropertyDescriptor(obj, "name"); <br/>console.log(descriptor.value); <br/>console.log(descriptor.writable); <br/>console.log(descriptor.enumerable); <br/>console.log(descriptor.configurable);</pre>
<p>The output is the following:</p>
<pre><strong>Eden</strong><br/><strong>true</strong><br/><strong>true</strong><br/><strong>true</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.getPrototypeOf(object) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.getPrototypeOf()</kbd> method is used to retrieve the prototype of an object--that is, the value of the internal <kbd>[[prototype]]</kbd> property of an object.</p>
<p>The <kbd>Reflect.getPrototypeOf()</kbd> method is the same as the <kbd>Object.getPrototypeOf()</kbd> method.</p>
<p>Here is a code example that demonstrates how to use the <kbd>Reflect. getPrototypeOf()</kbd> method:</p>
<pre>var obj1 = { <br/>__proto__:  { name: "Eden" } <br/>}; <br/>var obj2 = Reflect.getPrototypeOf(obj1); <br/>console.log(obj2.name); //Output "Eden"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.setPrototypeOf(object, prototype) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.setPrototypeOf()</kbd> is used to set the internal <kbd>[[prototype]]</kbd> property's value of an object. The <kbd>Reflect.setPrototypeOf()</kbd> method will return <kbd>true</kbd> if the internal <kbd>[[prototype]]</kbd> property's value was set successfully. Otherwise, it will return <kbd>false</kbd>.</p>
<p>Here is a code example that demonstrates how to use it:</p>
<pre>var obj = {}; <br/>Reflect.setPrototypeOf(obj, { name: "Eden" }); <br/>console.log(obj.name); //Output "Eden"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.has(object, property) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.has()</kbd> is used to check if a property exists in an object. It also checks for the inherited properties. It returns <kbd>true</kbd> if the property exists. Otherwise, it returns <kbd>false</kbd>.</p>
<p class="mce-root">It's the same as the <kbd>in</kbd> operator in JavaScript.</p>
<p>Here is a code example that demonstrates how to use the <kbd>Reflect.has()</kbd> method:</p>
<pre>var obj = { <br/>  __proto__: { name: "Eden" }, <br/>  age: 12 <br/>}; <br/>console.log(Reflect.has(obj, "name")); //Output "true" <br/>console.log(Reflect.has(obj, "age")); //Output "true"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.isExtensible(object) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.isExtensible()</kbd> method is used to check if an object is extensible or not,--that is, if we can add new properties to an object.</p>
<p>An object can be marked as non-extensible using the <kbd>Object.preventExtensions()</kbd>, <kbd>Object.freeze()</kbd>, and the <kbd>Object.seal()</kbd> methods.</p>
<p>The <kbd>Reflect.isExtensible()</kbd> method is the same as the <kbd>Object.isExtensible()</kbd> method.</p>
<p>Here is a code example that demonstrates how to use the <kbd>Reflect.isExtensible()</kbd> method:</p>
<pre>var obj = { name: "Eden" }; <br/>console.log(Reflect.isExtensible(obj)); //Output "true" <br/>Object.preventExtensions(obj); <br/>console.log(Reflect.isExtensible(obj)); //Output "false"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.preventExtensions(object) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.preventExtensions()</kbd> is used to mark an object as non-extensible. It returns a Boolean, indicating whether the operation was successful or not.</p>
<p>It's the same as the <kbd>Object.preventExtensions()</kbd> method:</p>
<pre>var obj = { name: "Eden" };<br/>console.log(Reflect.isExtensible(obj)); //Output "true" <br/>console.log(Reflect.preventExtensions(obj)); //Output "true" <br/>console.log(Reflect.isExtensible(obj)); //Output "false"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reflect.ownKeys(object) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reflect.ownKeys()</kbd> method returns an array whose values represent the keys of the properties of a provided object. It ignores the inherited properties.</p>
<p>Here is the example code to demonstrate this method:</p>
<pre>var obj = { a: 1, b: 2, __proto__: { c: 3 } }; <br/>var keys = Reflect.ownKeys(obj); <br/>console.log(keys.length); //Output "2" <br/>console.log(keys[0]); //Output "a" <br/>console.log(keys[1]); //Output "b"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned what object reflection is and how to use the Reflect API for object reflection. We saw various methods of the <kbd>Reflect</kbd> object with examples. Overall, this chapter introduced the Reflect API to inspect and manipulate the properties of objects. In the next chapter, we will learn about proxies and their uses.</p>


            </article>

            
        </section>
    </body></html>