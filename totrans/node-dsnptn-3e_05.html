<html><head></head><body>
  <div><h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-117" class="chapterTitle">Asynchronous Control Flow Patterns with Promises and Async/Await</h1>
    <p class="normal">Callbacks are the low-level building blocks of asynchronous programming in Node.js, but they are far from being developer-friendly. In fact, in the last chapter, we learned techniques to implement different control flow constructs using callbacks, and we can say that they are quite complex and verbose compared to the (low) level of complexity of the tasks they try to accomplish. In particular, serial execution flow, which is the predominant control flow structure in most of the code we write, can easily lead an untrained developer to write code affected by the callback hell problem. On top of that, even if properly implemented, a serial execution flow seems needlessly complicated and error-prone. Let's also remember how fragile error management with callbacks is; if we forget to forward an error, then it just gets lost, and if we forget to catch any exception thrown by some synchronous code, then the program crashes. And all of this without considering that Zalgo is always breathing down our necks.</p>
    <p class="normal">Node.js and JavaScript have been criticized for many years for the lack of a native solution to a problem so common and ubiquitous. Luckily, over the years, the community has worked on new solutions to the problem and finally, after many iterations, discussions, and years of waiting, today we have a proper solution to the "callback issue."</p>
    <p class="normal">The first step toward a better asynchronous code experience is the <strong class="keyword">promise</strong>, an object that "carries" the status and the eventual result of an asynchronous operation. A promise can be easily chained to implement serial execution flows and can be moved around like any other object. Promises simplify asynchronous code a lot; however, there was still room for improvement. So, in an attempt to make the ubiquitous serial execution flow as simple as possible, a new construct was introduced, called <strong class="keyword">async/await</strong>, which can finally make asynchronous code look like synchronous code.</p>
    <p class="normal">In today's modern Node.js programming, async/await is the preferred construct to use when dealing with asynchronous code. However, async/await is built on top of promises, as much as promises are built on top of callbacks. So, it's important that we know and master all of them in order to tackle our asynchronous programming problems with the right approach.</p>
    <p class="normal">In this chapter, you will learn the following:</p>
    <ul>
      <li class="Bullet--PACKT-">How promises work and how to use them effectively to implement the main control flow constructs we already know about.</li>
      <li class="Bullet-End--PACKT-">The async/await syntax, which will become our main tool for dealing with asynchronous code in Node.js.</li>
    </ul>
    <p class="normal">By the end of the chapter, you will have learned about the two most important components that we have in JavaScript for taming asynchronous code. So, let's get started by discovering promises.</p>
    <h1 id="_idParaDest-118" class="title">Promises</h1>
    <p class="normal">Promises are part of the <a id="_idIndexMarker312"/>ECMAScript 2015 standard (or ES6, which is why they are also called ES6 promises) and have been natively available in Node.js since version 4. But the history of promises goes back a few years earlier, when there were dozens of implementations around, initially with different features and behavior. Eventually, the majority of those implementations <a id="_idIndexMarker313"/>settled on a standard called <strong class="keyword">Promises/A+</strong>.</p>
    <p class="normal">Promises represent a big step ahead toward providing a robust alternative to continuation-passing style callbacks for propagating an asynchronous result. As we will see, the use of promises will make all the major asynchronous control flow constructs easier to read, less verbose, and more robust compared to their callback-based alternatives.</p>
    <h2 id="_idParaDest-119" class="title">What is a promise?</h2>
    <p class="normal">A <code class="Code-In-Text--PACKT-">Promise</code> is an object that <a id="_idIndexMarker314"/>embodies the eventual result (or error) of an asynchronous operation. In promises jargon, we say that a <code class="Code-In-Text--PACKT-">Promise</code> is <strong class="keyword">pending</strong> when the asynchronous operation is not yet complete, it's <strong class="keyword">fulfilled</strong> when the operation successfully completes, and <strong class="keyword">rejected</strong> when the operation terminates with an error. Once a <code class="Code-In-Text--PACKT-">Promise</code> is either fulfilled or rejected, it's considered <strong class="keyword">settled</strong>.</p>
    <p class="normal">To receive the <strong class="keyword">fulfillment value</strong> or the error (<strong class="keyword">reason</strong>) associated with the rejection, we can use the <code class="Code-In-Text--PACKT-">then()</code> method of a <code class="Code-In-Text--PACKT-">Promise</code> instance. The following is its signature:</p>
    <pre class="programlisting code"><code class="hljs-code">promise.then(onFulfilled, onRejected)
</code></pre>
    <p class="normal">In the preceding signature, <code class="Code-In-Text--PACKT-">onFulfilled</code> is a callback that will eventually receive the fulfillment value of the <code class="Code-In-Text--PACKT-">Promise</code>, and <code class="Code-In-Text--PACKT-">onRejected</code> is another callback that will receive the reason for the rejection (if any). Both are optional.</p>
    <p class="normal">To have an idea of how promises can transform our code, let's consider the following callback-based code:</p>
    <pre class="programlisting code"><code class="hljs-code">asyncOperation(arg, (err, result) =&gt; {
  if(err) {
    // handle the error
  }
  // do stuff with the result
})
</code></pre>
    <p class="normal">Promises allow us to<a id="_idIndexMarker315"/> transform this typical continuation-passing style code into a better structured and more elegant code, such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">asyncOperationPromise(arg)
  .then(result =&gt; {
    // do stuff with result
  }, err =&gt; {
    // handle the error
  })
</code></pre>
    <p class="normal">In the code above, <code class="Code-In-Text--PACKT-">asyncOperationPromise()</code> is returning a <code class="Code-In-Text--PACKT-">Promise</code>, which we can then use to receive the fulfillment value or the rejection reason of the eventual result of the function. So far, it seems that there is nothing major going on, but one crucial property of the <code class="Code-In-Text--PACKT-">then()</code> method is that it <em class="italic">synchronously</em> returns another <code class="Code-In-Text--PACKT-">Promise</code>. </p>
    <p class="normal">Moreover, if any of the <code class="Code-In-Text--PACKT-">onFulfilled</code> or <code class="Code-In-Text--PACKT-">onRejected</code> functions return a value <em class="italic">x</em>, the <code class="Code-In-Text--PACKT-">Promise</code> returned by the <code class="Code-In-Text--PACKT-">then()</code> method will:</p>
    <ul>
      <li class="Bullet--PACKT-">Fulfill with <em class="italic">x</em> if <em class="italic">x</em> is a value</li>
      <li class="Bullet--PACKT-">Fulfill with the fulfillment value of <em class="italic">x</em> if <em class="italic">x</em> is a <code class="Code-In-Text--PACKT-">Promise</code></li>
      <li class="Bullet-End--PACKT-">Reject with the eventual rejection reason of <em class="italic">x</em> if <em class="italic">x</em> is a <code class="Code-In-Text--PACKT-">Promise</code></li>
    </ul>
    <p class="normal">This behavior allows us to build <em class="italic">chains</em> of promises, allowing easy aggregation and arrangement of asynchronous operations into several configurations. Moreover, if we don't specify an <code class="Code-In-Text--PACKT-">onFulfilled</code> or <code class="Code-In-Text--PACKT-">onRejected</code> handler, the fulfillment value or rejection reason is automatically forwarded to the next promise in the chain. This allows us, for example, to automatically propagate errors across the whole chain until they are caught by an <code class="Code-In-Text--PACKT-">onRejected</code> handler. With a <code class="Code-In-Text--PACKT-">Promise</code> chain, the sequential execution of tasks suddenly becomes a trivial operation:</p>
    <pre class="programlisting code"><code class="hljs-code">asyncOperationPromise(arg)
  .then(result1 =&gt; {
    // returns another promise
    return asyncOperationPromise(arg2)
  })
  .then(result2 =&gt; {
    // returns a value
    return 'done'
  })
  .then(undefined, err =&gt; {
    // any error in the chain is caught here
  })
</code></pre>
    <p class="normal">The following diagram<a id="_idIndexMarker316"/> provides another perspective on how a <code class="Code-In-Text--PACKT-">Promise</code> chain works:</p>
    <figure class="mediaobject"><img src="img/B15729_05_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.1: Promise chain execution flow</p>
    <p class="normal"><em class="italic">Figure 5.1</em> shows how our program flows when we use a chain of promises. When we invoke <code class="Code-In-Text--PACKT-">then()</code> on <strong class="keyword">Promise A</strong> we synchronously receive <strong class="keyword">Promise B</strong> as a result and when we invoke <code class="Code-In-Text--PACKT-">then()</code> on <strong class="keyword">Promise B</strong> we synchronously receive <strong class="keyword">Promise C</strong> as a result. Eventually, when <strong class="keyword">Promise A</strong> settles, it will either fulfill or reject, which results in the invocation of either the <code class="Code-In-Text--PACKT-">onFulfilled()</code> or the <code class="Code-In-Text--PACKT-">onRejected()</code> callback respectively. The result of the execution of such a callback will then fulfill or reject <strong class="keyword">Promise B</strong> and such a result is, in turn, propagated to the <code class="Code-In-Text--PACKT-">onFulfilled()</code> or the <code class="Code-In-Text--PACKT-">onRejected()</code> callback passed to the <code class="Code-In-Text--PACKT-">then()</code> invocation on <strong class="keyword">Promise B</strong>. The execution continues similarly for <strong class="keyword">Promise C</strong> and any other promise that follows in the chain.</p>
    <p class="normal">An important property of promises is that the <code class="Code-In-Text--PACKT-">onFulfilled()</code> and <code class="Code-In-Text--PACKT-">onRejected()</code> callbacks are <em class="italic">guaranteed</em> to be invoked asynchronously and at most once, even if we resolve the <code class="Code-In-Text--PACKT-">Promise</code> synchronously with a value. Not only that, the <code class="Code-In-Text--PACKT-">onFulfilled()</code> and <code class="Code-In-Text--PACKT-">onRejected()</code> callbacks will be invoked asynchronously even if the <code class="Code-In-Text--PACKT-">Promise</code> object is already settled at the moment in which <code class="Code-In-Text--PACKT-">then()</code> is called. This behavior shields our code against all those situations where we could unintentionally release Zalgo (see <em class="chapterRef">Chapter 3</em>, <em class="italic">Callbacks and Events</em>), making our asynchronous code more consistent and robust without any extra effort.</p>
    <p class="normal">Now comes the best<a id="_idIndexMarker317"/> part. If an exception is thrown (using the <code class="Code-In-Text--PACKT-">throw</code> statement) in the <code class="Code-In-Text--PACKT-">onFulfilled()</code> or <code class="Code-In-Text--PACKT-">onRejected()</code> handler, the <code class="Code-In-Text--PACKT-">Promise</code> returned by the <code class="Code-In-Text--PACKT-">then()</code> method will automatically reject, with the exception that was thrown provided as the rejection reason. This is a tremendous advantage over CPS, as it means that with promises, exceptions will propagate automatically across the chain, and the <code class="Code-In-Text--PACKT-">throw</code> statement becomes finally usable.</p>
    <h2 id="_idParaDest-120" class="title">Promises/A+ and thenables</h2>
    <p class="normal">Historically, there have<a id="_idIndexMarker318"/> been many different implementations<a id="_idIndexMarker319"/> of promises, and most of them were not compatible with each other, meaning that it was not possible to create chains between <code class="Code-In-Text--PACKT-">Promise</code> objects coming from libraries that were using different <code class="Code-In-Text--PACKT-">Promise</code> implementations.</p>
    <p class="normal">The JavaScript community worked very hard to address this limitation and those efforts led to the creation of the <strong class="keyword">Promises/A+</strong> specification. This specification details the behavior of the <code class="Code-In-Text--PACKT-">then()</code> method, providing an interoperable base, which makes <code class="Code-In-Text--PACKT-">Promise</code> objects from different libraries able to work with each other out of the box. Today, the majority of <code class="Code-In-Text--PACKT-">Promise</code> implementations use this standard, including the native <code class="Code-In-Text--PACKT-">Promise</code> object of JavaScript and Node.js.</p>
    <div><p class="Tip--PACKT-">For a detailed overview of the <strong class="keyword">Promises/A+</strong> specification, you can refer to the official <a id="_idIndexMarker320"/>website at <a href="http://nodejsdp.link/promises-aplus">nodejsdp.link/promises-aplus</a>.</p>
    </div>
    <p class="normal">As a result of the adoption of the Promises/A+ standard, many <code class="Code-In-Text--PACKT-">Promise</code> implementations, including the native JavaScript <code class="Code-In-Text--PACKT-">Promise</code> API, will consider any object with a <code class="Code-In-Text--PACKT-">then()</code> method a <code class="Code-In-Text--PACKT-">Promise</code>-like object, also called <strong class="keyword">thenable</strong>. This behavior allows different <code class="Code-In-Text--PACKT-">Promise</code> implementations to interact with each other seamlessly.</p>
    <div><p class="Tip--PACKT-">The technique <a id="_idIndexMarker321"/>of recognizing (or typing) objects based on their<a id="_idIndexMarker322"/> external behavior, rather than their actual type, is called <strong class="keyword">duck typing</strong> and is widely<a id="_idIndexMarker323"/> used in JavaScript.</p>
    </div>
    <h2 id="_idParaDest-121" class="title">The promise API</h2>
    <p class="normal">Let's now take a <a id="_idIndexMarker324"/>quick look at the API of the native JavaScript <code class="Code-In-Text--PACKT-">Promise</code>. This is just an overview to give you an idea of what we can do with promises, so don't worry if things are not so clear at this point yet; we will have the chance to use most of these APIs throughout the book.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Promise</code> constructor (<code class="Code-In-Text--PACKT-">new Promise((resolve, reject) =&gt; {})</code>) creates a new <code class="Code-In-Text--PACKT-">Promise</code> instance that fulfills or rejects based on the behavior of the function provided as an argument. The function provided to the constructor will receive two arguments:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">resolve(obj)</code>: This is a function that, when invoked, will fulfill the <code class="Code-In-Text--PACKT-">Promise</code> with the provided fulfillment value, which will be <code class="Code-In-Text--PACKT-">obj</code> if <code class="Code-In-Text--PACKT-">obj</code> is a value. It will be the fulfillment value of <code class="Code-In-Text--PACKT-">obj</code> if <code class="Code-In-Text--PACKT-">obj</code> is a <code class="Code-In-Text--PACKT-">Promise</code> or a thenable.</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">reject(err)</code>: This rejects the <code class="Code-In-Text--PACKT-">Promise</code> with the reason <code class="Code-In-Text--PACKT-">err</code>. It is a convention for <code class="Code-In-Text--PACKT-">err</code> to be an instance of <code class="Code-In-Text--PACKT-">Error</code>.</li>
    </ul>
    <p class="normal">Now, let's take a look at the most important static methods of the <code class="Code-In-Text--PACKT-">Promise</code> object:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">Promise.resolve(obj)</code>: This method creates a new <code class="Code-In-Text--PACKT-">Promise</code> from another <code class="Code-In-Text--PACKT-">Promise</code>, a thenable, or a value. If a <code class="Code-In-Text--PACKT-">Promise</code> is passed, then that <code class="Code-In-Text--PACKT-">Promise</code> is returned as it is. If a thenable is provided, then it's <em class="italic">converted</em> to the <code class="Code-In-Text--PACKT-">Promise</code> implementation in use. If a value is provided, then the <code class="Code-In-Text--PACKT-">Promise</code> will be fulfilled with that value.</li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">Promise.reject(err)</code>: This method creates a <code class="Code-In-Text--PACKT-">Promise</code> that rejects with <code class="Code-In-Text--PACKT-">err</code> as the reason.</li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">Promise.all(iterable)</code>: This method creates a <code class="Code-In-Text--PACKT-">Promise</code> that fulfills with an array of fulfillment values when every item in the input <code class="Code-In-Text--PACKT-">iterable</code> (such as an <code class="Code-In-Text--PACKT-">Array</code>) object fulfills. If any <code class="Code-In-Text--PACKT-">Promise</code> in the iterable object rejects, then the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">Promise.all()</code> will reject with the first rejection reason. Each item in the <code class="Code-In-Text--PACKT-">iterable</code> object can be a <code class="Code-In-Text--PACKT-">Promise</code>, a generic thenable, or a value.</li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">Promise.allSettled(iterable)</code>: This method waits for all the input promises to fulfill or reject and then returns an array of objects containing the fulfillment value or the rejection reason for each input <code class="Code-In-Text--PACKT-">Promise</code>. Each output object has a <code class="Code-In-Text--PACKT-">status</code> property, which can be equal to <code class="Code-In-Text--PACKT-">'fulfilled'</code> or <code class="Code-In-Text--PACKT-">'rejected'</code>, and a <code class="Code-In-Text--PACKT-">value</code> property containing the fulfillment value, or a <code class="Code-In-Text--PACKT-">reason</code> property containing the rejection reason. The difference with <code class="Code-In-Text--PACKT-">Promise.all()</code> is that <code class="Code-In-Text--PACKT-">Promise.allSettled()</code> will always wait for each <code class="Code-In-Text--PACKT-">Promise</code> to either fulfill or reject, instead of immediately rejecting when one of the promises rejects.</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">Promise.race(iterable)</code>: This method returns a <code class="Code-In-Text--PACKT-">Promise</code> that is equivalent to the first <code class="Code-In-Text--PACKT-">Promise</code> in <code class="Code-In-Text--PACKT-">iterable</code> that settles.</li>
    </ul>
    <p class="normal">Finally, the following are the<a id="_idIndexMarker325"/> main methods available on a <code class="Code-In-Text--PACKT-">Promise</code> instance:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">promise.then(onFulfilled, onRejected)</code>: This is the essential method of a <code class="Code-In-Text--PACKT-">Promise</code>. Its behavior is compatible with the Promises/A+ standard that we mentioned before.</li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">promise.catch(onRejected)</code>: This method is just syntactic sugar (<a href="http://nodejsdp.link/syntactic-sugar">nodejsdp.link/syntactic-sugar</a>) for <code class="Code-In-Text--PACKT-">promise.then(undefined, onRejected)</code>.</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">promise.finally(onFinally)</code>: This method allows us to set up an <code class="Code-In-Text--PACKT-">onFinally</code> callback, which is invoked when the <code class="Code-In-Text--PACKT-">Promise</code> is settled (either fulfilled or rejected). Unlike <code class="Code-In-Text--PACKT-">onFulfilled</code> and <code class="Code-In-Text--PACKT-">onRejected</code>, the <code class="Code-In-Text--PACKT-">onFinally</code> callback will not receive any argument as input and any value returned from it will be ignored. The <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">finally</code> will settle with the same fulfillment value or rejection reason of the current <code class="Code-In-Text--PACKT-">Promise</code> instance. There is only once exception to all this, which is the case in which we <code class="Code-In-Text--PACKT-">throw</code> inside the <code class="Code-In-Text--PACKT-">onFinally</code> callback or return a rejected <code class="Code-In-Text--PACKT-">Promise</code>. In this case, the returned <code class="Code-In-Text--PACKT-">Promise</code> will reject with the error that is thrown or the rejection reason of the rejected <code class="Code-In-Text--PACKT-">Promise</code> returned.</li>
    </ul>
    <p class="normal">Let's now see an example of how we can create a <code class="Code-In-Text--PACKT-">Promise</code> from scratch using its constructor.</p>
    <h2 id="_idParaDest-122" class="title">Creating a promise</h2>
    <p class="normal">Let's now see how we <a id="_idIndexMarker326"/>can create a <code class="Code-In-Text--PACKT-">Promise</code> using its constructor. Creating a <code class="Code-In-Text--PACKT-">Promise</code> from scratch is a low-level operation and it's usually required when we need to convert an API that uses another asynchronous style (such as a callback-based style). Most of the time we—as developers—are consumers of promises produced by other libraries and most of the promises we create will come from the <code class="Code-In-Text--PACKT-">then()</code> method. Nonetheless, in some advanced scenarios, we need to manually create a <code class="Code-In-Text--PACKT-">Promise</code> using its constructor.</p>
    <p class="normal">To demonstrate how to use the <code class="Code-In-Text--PACKT-">Promise</code> constructor, let's create a function that returns a <code class="Code-In-Text--PACKT-">Promise</code> that fulfills with the current date after a specified number of milliseconds. Let's take a look at it:</p>
    <pre class="programlisting code"><code class="hljs-code">function delay (milliseconds) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(new Date())
    }, milliseconds)
  })
}
</code></pre>
    <p class="normal">As you probably already guessed, we used <code class="Code-In-Text--PACKT-">setTimeout()</code> to invoke the <code class="Code-In-Text--PACKT-">resolve()</code> function of the <code class="Code-In-Text--PACKT-">Promise</code> constructor. We can notice how the entire body of the function is wrapped<a id="_idIndexMarker327"/> by the <code class="Code-In-Text--PACKT-">Promise</code> constructor; this is a frequent code pattern you will see when creating a <code class="Code-In-Text--PACKT-">Promise</code> from scratch.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">delay()</code> function we just created can then be used with some code like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">console.log(`Delaying...${new Date().getSeconds()}s`)
delay(1000)
  .then(newDate =&gt; {
    console.log(`Done ${newDate.getSeconds()}s`)
  })
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">console.log()</code> within the <code class="Code-In-Text--PACKT-">then()</code> handler will be executed approximately after 1 second from the invocation of <code class="Code-In-Text--PACKT-">delay()</code>.</p>
    <div><p class="Information-Box--PACKT-">The Promises/A+ specification states that the <code class="Code-In-Text--PACKT-">onFulfilled</code> and <code class="Code-In-Text--PACKT-">onRejected</code> callbacks of the <code class="Code-In-Text--PACKT-">then()</code> method have to be invoked only once and exclusively (only one or the other is invoked). A compliant promises implementation makes sure that even if we call <code class="Code-In-Text--PACKT-">resolve</code> or <code class="Code-In-Text--PACKT-">reject</code> multiple times, the <code class="Code-In-Text--PACKT-">Promise</code> is either fulfilled or rejected only once.</p>
    </div>
    <h2 id="_idParaDest-123" class="title">Promisification</h2>
    <p class="normal">When some characteristics of a callback-based function are known in advance, it's possible to create a<a id="_idIndexMarker328"/> function that transforms such a callback-based function into an equivalent function returning a <code class="Code-In-Text--PACKT-">Promise</code>. This transformation is called <strong class="keyword">promisification</strong>.</p>
    <p class="normal">For example, let's consider the conventions used in Node.js-style callback-based functions:</p>
    <ul>
      <li class="Bullet--PACKT-">The callback is the last argument of the function</li>
      <li class="Bullet--PACKT-">The error (if any) is always the first argument passed to the callback</li>
      <li class="Bullet-End--PACKT-">Any return value is passed after the error to the callback</li>
    </ul>
    <p class="normal">Based on these rules, we can easily create a generic function that <em class="italic">promisifies</em> a Node.js-style callback-based<a id="_idIndexMarker329"/> function. Let's see what this function looks like:</p>
    <pre class="programlisting code"><code class="hljs-code">function promisify (callbackBasedApi) {
  return function promisified (...args) {
    return new Promise((resolve, reject) =&gt; {              // (1)
      const newArgs = [
        ...args,
        function (err, result) {                           // (2)
          if (err) {
            return reject(err)
          }
          resolve(result)
        }
      ]
      callbackBasedApi(...newArgs)                         // (3)
    })
  }
}
</code></pre>
    <p class="normal">The preceding function returns another function called <code class="Code-In-Text--PACKT-">promisified()</code>, which represents the promisified version of the <code class="Code-In-Text--PACKT-">callbackBasedApi</code> given as the input. This is how it works:</p>
    <ol>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">promisified()</code> function creates a new <code class="Code-In-Text--PACKT-">Promise</code> using the <code class="Code-In-Text--PACKT-">Promise</code> constructor and immediately returns it to the caller.</li>
      <li class="numbered">In the function passed to the <code class="Code-In-Text--PACKT-">Promise</code> constructor, we make sure to pass to <code class="Code-In-Text--PACKT-">callbackBasedApi</code> a special callback. Since we know that the callback always comes last, we simply append it to the arguments list (<code class="Code-In-Text--PACKT-">args</code>) provided to the <code class="Code-In-Text--PACKT-">promisified()</code> function. In the special callback, if we receive an error, we immediately reject the <code class="Code-In-Text--PACKT-">Promise</code>; otherwise, we resolve it with the given <code class="Code-In-Text--PACKT-">result</code>.</li>
      <li class="numbered">Finally, we simply invoke <code class="Code-In-Text--PACKT-">callbackBasedApi</code> with the list of arguments we have built.</li>
    </ol>
    <p class="normal">Now, let's promisify a Node.js function using our newly created <code class="Code-In-Text--PACKT-">promisify()</code> function. We can use the <code class="Code-In-Text--PACKT-">randomBytes()</code> function of the core <code class="Code-In-Text--PACKT-">crypto</code> module, which produces a buffer containing the specified number of random bytes. The <code class="Code-In-Text--PACKT-">randomBytes()</code> function accepts a callback as the last argument and it follows the conventions we already know very well. Let's see what this looks like:</p>
    <pre class="programlisting code"><code class="hljs-code">import { randomBytes } from 'crypto'
const randomBytesP = promisify(randomBytes)
randomBytesP(32)
  .then(buffer =&gt; {
    console.log(`Random bytes: ${buffer.toString()}`)
  })
</code></pre>
    <p class="normal">The previous code should print some gibberish to the console; that's because not all generated bytes have<a id="_idIndexMarker330"/> a corresponding printable character.</p>
    <div><p class="Information-Box--PACKT-">The promisification function we created here is just for educational purposes and it's missing a few features, such as the ability to deal with callbacks returning more than one result. In real life, we would use the <code class="Code-In-Text--PACKT-">promisify()</code> function of the <code class="Code-In-Text--PACKT-">util</code> core module to promisify our Node.js-style callback-based functions. You can take a look at its documentation at <a href="http://nodejsdp.link/promisify">nodejsdp.link/promisify</a>.</p>
    </div>
    <h2 id="_idParaDest-124" class="title">Sequential execution and iteration</h2>
    <p class="normal">We now know enough to<a id="_idIndexMarker331"/> convert the web spider application that we created in the previous<a id="_idIndexMarker332"/> chapter to use promises. Let's start directly from version 2, the one downloading the links of a webpage in sequence.</p>
    <div><p class="Tip--PACKT-">We can access an already promisified version of the core <code class="Code-In-Text--PACKT-">fs</code> API through the <code class="Code-In-Text--PACKT-">promises</code> object of the <code class="Code-In-Text--PACKT-">fs</code> module. For example: <code class="Code-In-Text--PACKT-">import { promises } from 'fs'</code>.</p>
    </div>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">spider.js</code> module, the very first step required is to import our dependencies and promisify any callback-based function that we are going to use:</p>
    <pre class="programlisting code"><code class="hljs-code">import { promises as fsPromises } from 'fs'                // (1)
import { dirname } from 'path'
import superagent from 'superagent'
import mkdirp from 'mkdirp'
import { urlToFilename, getPageLinks } from './utils.js'
import { promisify } from 'util'
const mkdirpPromises = promisify(mkdirp)                   // (2)
</code></pre>
    <p class="normal">There are two main differences here compared to the <code class="Code-In-Text--PACKT-">spider.js</code> module of the previous chapter:</p>
    <ol>
      <li class="numbered">We import the <code class="Code-In-Text--PACKT-">promises</code> object of the <code class="Code-In-Text--PACKT-">fs</code> module to get access to all the <code class="Code-In-Text--PACKT-">fs</code> functions already promisified.</li>
      <li class="numbered">We manually promisify the <code class="Code-In-Text--PACKT-">mkdirp()</code> function.</li>
    </ol>
    <p class="normal">Now, we can start converting the <code class="Code-In-Text--PACKT-">download()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">function download (url, filename) {
  console.log(`Downloading ${url}`)
  let content
  return superagent.get(url)                               // (1)
    .then((res) =&gt; {
      content = res.text                                   // (2)
      return mkdirpPromises(dirname(filename))
    })
    .then(() =&gt; fsPromises.writeFile(filename, content))
    .then(() =&gt; {
      console.log(`Downloaded and saved: ${url}`)
      return content                                       // (3)
    })
}
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker333"/>straightaway appreciate the elegance of implementing <a id="_idIndexMarker334"/>sequential asynchronous operations with promises. We simply have a clean and very intuitive chain of <code class="Code-In-Text--PACKT-">then()</code> invocations.</p>
    <p class="normal">Compared to the previous version of the function, this time we are leveraging the out-of-the-box support for promises of the <code class="Code-In-Text--PACKT-">superagent</code> package. Instead of invoking <code class="Code-In-Text--PACKT-">end()</code> on the request object returned by <code class="Code-In-Text--PACKT-">superagent.get()</code>, we simply invoke <code class="Code-In-Text--PACKT-">then()</code> to send the request (1) and receive a <code class="Code-In-Text--PACKT-">Promise</code> that fulfills/rejects with the result of the request.</p>
    <p class="normal">The final return value of the <code class="Code-In-Text--PACKT-">download()</code> function is the <code class="Code-In-Text--PACKT-">Promise</code> returned by the last <code class="Code-In-Text--PACKT-">then()</code> call in the chain, which fulfills with the <code class="Code-In-Text--PACKT-">content</code> of the webpage (3), which we initialized in the <code class="Code-In-Text--PACKT-">onFulfilled</code> handler of the first <code class="Code-In-Text--PACKT-">then()</code> call (2). This makes sure that the caller receives a <code class="Code-In-Text--PACKT-">Promise</code> that fulfills with <code class="Code-In-Text--PACKT-">content</code> only after all operations (<code class="Code-In-Text--PACKT-">get</code>, <code class="Code-In-Text--PACKT-">mkdirp</code>, and <code class="Code-In-Text--PACKT-">writeFile</code>) have completed.</p>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">download()</code> function that we've just seen, we have executed a known set of asynchronous operations in sequence. However, in the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function, we will have to deal with a sequential iteration over a dynamic set of asynchronous tasks. Let's see how we can achieve that:</p>
    <pre class="programlisting code"><code class="hljs-code">function spiderLinks (currentUrl, content, nesting) {
  let promise = Promise.resolve()                            // (1)
  if (nesting === 0) {
    return promise
  }
  const links = getPageLinks(currentUrl, content)
  for (const link of links) {
    promise = promise.then(() =&gt; spider(link, nesting - 1))  // (2)
  }
  return promise
}
</code></pre>
    <p class="normal">To iterate over all <a id="_idIndexMarker335"/>the links of a webpage asynchronously, we had <a id="_idIndexMarker336"/>to dynamically build a chain of promises as follows:</p>
    <ol>
      <li class="numbered">First, we defined an "empty" <code class="Code-In-Text--PACKT-">Promise</code>, which resolves to <code class="Code-In-Text--PACKT-">undefined</code>. This <code class="Code-In-Text--PACKT-">Promise</code> is used just as the starting point for our chain.</li>
      <li class="numbered">Then, in a loop, we update the <code class="Code-In-Text--PACKT-">promise</code> variable with a new <code class="Code-In-Text--PACKT-">Promise</code> obtained by invoking <code class="Code-In-Text--PACKT-">then()</code> on the previous <code class="Code-In-Text--PACKT-">promise</code> in the chain. This is actually our asynchronous iteration pattern using promises.</li>
    </ol>
    <p class="normal">At the end of the <code class="Code-In-Text--PACKT-">for</code> loop, the <code class="Code-In-Text--PACKT-">promise</code> variable will contain the promise of the last <code class="Code-In-Text--PACKT-">then()</code> invocation, so it will resolve only when all the promises in the chain have been resolved.</p>
    <div><p class="Information-Box--PACKT-"><strong class="screenText">Pattern (sequential iteration with promises)</strong></p>
      <p class="Information-Box--PACKT-">Dynamically build a chain of promises using a loop.</p>
    </div>
    <p class="normal">Now, we can finally convert the <code class="Code-In-Text--PACKT-">spider()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">export function spider (url, nesting) {
  const filename = urlToFilename(url)
  return fsPromises.readFile(filename, 'utf8')
    .catch((err) =&gt; {
      if (err.code !== 'ENOENT') {
        throw err
      }
      // The file doesn't exist, so let's download it
      return download(url, filename)
    })
    .then(content =&gt; spiderLinks(url, content, nesting))
}
</code></pre>
    <p class="normal">In this new <code class="Code-In-Text--PACKT-">spider()</code> function, we are using <code class="Code-In-Text--PACKT-">catch()</code> to handle any error produced by <code class="Code-In-Text--PACKT-">readFile()</code>. In particular, if the error has code <code class="Code-In-Text--PACKT-">'ENOENT'</code>, it means that the file doesn't exist yet and therefore<a id="_idIndexMarker337"/> we need to download the corresponding URL. The <code class="Code-In-Text--PACKT-">Promise</code> returned from <code class="Code-In-Text--PACKT-">download()</code>, if fulfilled, will return the <code class="Code-In-Text--PACKT-">content</code> at the URL. On <a id="_idIndexMarker338"/>the other hand, if the <code class="Code-In-Text--PACKT-">Promise</code> produced by <code class="Code-In-Text--PACKT-">readFile()</code> fulfills, it will <em class="italic">skip</em> the <code class="Code-In-Text--PACKT-">catch()</code> handler and go straight to the next <code class="Code-In-Text--PACKT-">then()</code>. In both cases, the <code class="Code-In-Text--PACKT-">onFulfilled</code> handler of the last <code class="Code-In-Text--PACKT-">then()</code> call will always receive the <code class="Code-In-Text--PACKT-">content</code> of the webpage, either coming from the local file or from a fresh download.</p>
    <p class="normal">Now that we have converted our <code class="Code-In-Text--PACKT-">spider()</code> function as well, we can finally modify the <code class="Code-In-Text--PACKT-">spider-cli.js</code> module:</p>
    <pre class="programlisting code"><code class="hljs-code">spider(url, nesting)
  .then(() =&gt; console.log('Download complete'))
  .catch(err =&gt; console.error(err))
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">catch()</code> handler here will intercept any error originating from the entire <code class="Code-In-Text--PACKT-">spider()</code> process.</p>
    <p class="normal">If we look again at all the code we have written so far, we will be pleasantly surprised by the fact that we haven't included any error propagation logic (as we would be forced to do when using callbacks). This is clearly an enormous advantage, as it greatly reduces the boilerplate in our code and the chances of missing any asynchronous errors.</p>
    <p class="normal">This completes the implementation of version 2 of our web spider application with promises.</p>
    <div><p class="Tip--PACKT-">An alternative of the sequential <a id="_idIndexMarker339"/>iteration pattern with promises<a id="_idIndexMarker340"/> makes use of the <code class="Code-In-Text--PACKT-">reduce()</code> function, for an even more compact implementation:</p>
      <pre class="programlisting code"><code class="hljs-code">const promise = tasks.reduce((prev, task) =&gt; {
  return prev.then(() =&gt; {
    return task()
  })
}, Promise.resolve())
</code></pre>
    </div>
    <h2 id="_idParaDest-125" class="title">Parallel execution</h2>
    <p class="normal">Another execution flow that becomes trivial with promises is the parallel execution flow. In fact, all that we<a id="_idIndexMarker341"/> need to do is use the built-in <code class="Code-In-Text--PACKT-">Promise.all()</code> method. This helper function creates another <code class="Code-In-Text--PACKT-">Promise</code> that fulfills only when all the promises received as input are fulfilled. If there is no causal relationship between those promises (for example, they are not part of the same chain of promises), then they will be executed in parallel.</p>
    <p class="normal">To demonstrate this, let's consider version 3 of our web spider application, which downloads all the links of a page in parallel. Let's just update the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function again to implement a parallel execution flow using promises:</p>
    <pre class="programlisting code"><code class="hljs-code">function spiderLinks (currentUrl, content, nesting) {
  if (nesting === 0) {
    return Promise.resolve()
  }
  const links = getPageLinks(currentUrl, content)
  const promises = links.map(link =&gt; spider(link, nesting - 1))
  return Promise.all(promises)
}
</code></pre>
    <p class="normal">The pattern here consists in starting the <code class="Code-In-Text--PACKT-">spider()</code> tasks all at once in the <code class="Code-In-Text--PACKT-">links.map()</code> loop. At the same time, each <code class="Code-In-Text--PACKT-">Promise</code> returned by invoking <code class="Code-In-Text--PACKT-">spider()</code> is collected in the final <code class="Code-In-Text--PACKT-">promises</code> array. The critical difference in this loop—as compared to the sequential iteration loop—is that we are not waiting for the previous <code class="Code-In-Text--PACKT-">spider()</code> task in the list to complete before starting a new one. All the <code class="Code-In-Text--PACKT-">spider()</code> tasks are started in the loop at once, in the same event loop cycle.</p>
    <p class="normal">Once we have all the promises, we pass them to the <code class="Code-In-Text--PACKT-">Promise.all()</code> method, which returns a new <code class="Code-In-Text--PACKT-">Promise</code> that will be fulfilled when all the promises in the array are fulfilled. In other <a id="_idIndexMarker342"/>words, it fulfills when all the download tasks have completed. In addition to that, the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">Promise.all()</code> will reject immediately if any of the promises in the input array reject. This is exactly what we wanted for this version of our web spider.</p>
    <h2 id="_idParaDest-126" class="title">Limited parallel execution</h2>
    <p class="normal">So far, promises have not disappointed our expectations. We were able to greatly improve our code<a id="_idIndexMarker343"/> for both serial and parallel execution. Now, with limited parallel execution, things should not be that different, considering that this flow is just a combination of serial and parallel execution.</p>
    <p class="normal">In this section, we will go straight to implementing a solution that allows us to <em class="italic">globally</em> limit the concurrency of our web spider tasks. In other words, we are going to implement our solution in a class that we can use to instantiate objects that we can pass around to different functions of the same application. If you are just interested in a simple solution to locally limit the parallel execution of a set of tasks, you can still apply the same principles that we will see in this section to implement a special asynchronous version of <code class="Code-In-Text--PACKT-">Array.map()</code>. We leave this to you as an exercise; you can find more details and hints at the end of this chapter.</p>
    <div><p class="Tip--PACKT-">For a ready-to-use, production-ready implementation of a <code class="Code-In-Text--PACKT-">map()</code> function supporting promises and limited concurrency, you can rely on the <code class="Code-In-Text--PACKT-">p-map</code> package. Find out more at <a href="http://nodejsdp.link/p-map">nodejsdp.link/p-map</a>.</p>
    </div>
    <h3 id="_idParaDest-127" class="title">Implementing the TaskQueue class with promises</h3>
    <p class="normal">To globally limit<a id="_idIndexMarker344"/> the concurrency of our spider<a id="_idIndexMarker345"/> download tasks, we are going to reuse the <code class="Code-In-Text--PACKT-">TaskQueue</code> class we implemented in the previous chapter. Let's start with the <code class="Code-In-Text--PACKT-">next()</code> method, where we trigger the execution of a set of tasks until we reach the concurrency limit:</p>
    <pre class="programlisting code"><code class="hljs-code">next () {
  while (this.running &lt; this.concurrency &amp;&amp; this.queue.length) {
    const task = this.queue.shift()
    task().finally(() =&gt; {
      this.running--
      this.next()
    })
    this.running++
  }
}
</code></pre>
    <p class="normal">The core change in the <code class="Code-In-Text--PACKT-">next()</code> method is where we invoke <code class="Code-In-Text--PACKT-">task()</code>. In fact, now we expect that <code class="Code-In-Text--PACKT-">task()</code> returns a <code class="Code-In-Text--PACKT-">Promise</code>, so all we have to do is invoke <code class="Code-In-Text--PACKT-">finally()</code> on that <code class="Code-In-Text--PACKT-">Promise</code> so we can reset the count of running tasks if it either fulfills or rejects.</p>
    <p class="normal">Now, we implement a new method called <code class="Code-In-Text--PACKT-">runTask()</code>. This method is responsible for queueing a special wrapper function and also for returning a newly built <code class="Code-In-Text--PACKT-">Promise</code>. Such a <code class="Code-In-Text--PACKT-">Promise</code> will <a id="_idIndexMarker346"/>essentially forward the result (fulfillment or rejection) of the <code class="Code-In-Text--PACKT-">Promise</code> eventually returned by <code class="Code-In-Text--PACKT-">task()</code>. Let's see what this method<a id="_idIndexMarker347"/> looks like:</p>
    <pre class="programlisting code"><code class="hljs-code">runTask (task) {
  return new Promise((resolve, reject) =&gt; {                // (1)
    this.queue.push(() =&gt; {                                // (2)
      return task().then(resolve, reject)                  // (4)
    })
    process.nextTick(this.next.bind(this))                 // (3)
  })
}
</code></pre>
    <p class="normal">In the method we have just seen:</p>
    <ol>
      <li class="numbered">We create a new <code class="Code-In-Text--PACKT-">Promise</code> using its constructor.</li>
      <li class="numbered">We add a special wrapper function to the tasks queue. This function is going to be executed at a later <code class="Code-In-Text--PACKT-">next()</code> run, when there are enough concurrency slots left.</li>
      <li class="numbered">We invoke <code class="Code-In-Text--PACKT-">next()</code> to trigger a new set of tasks to be run. We defer this to a subsequent run of the event loop to guarantee that <code class="Code-In-Text--PACKT-">task</code> is always invoked asynchronously with respect to when <code class="Code-In-Text--PACKT-">runTask()</code> is invoked. This prevents the problems we described in <em class="chapterRef">Chapter 3</em>, <em class="italic">Callbacks and Events</em> (for example, Zalgo). In fact, we can notice that in the <code class="Code-In-Text--PACKT-">next()</code> method there is another invocation of <code class="Code-In-Text--PACKT-">next()</code> itself, in the <code class="Code-In-Text--PACKT-">finally()</code> handler, that is always asynchronous.</li>
      <li class="numbered">When the wrapper function we queued is finally run, we execute the <code class="Code-In-Text--PACKT-">task</code> we have received as the input, and we forward its results—fulfilment value or rejection reason—to the outer <code class="Code-In-Text--PACKT-">Promise</code>, the one we return from the <code class="Code-In-Text--PACKT-">runTask()</code> method.</li>
    </ol>
    <p class="normal">With this, we have<a id="_idIndexMarker348"/> completed the implementation of<a id="_idIndexMarker349"/> our new <code class="Code-In-Text--PACKT-">TaskQueue</code> class using promises. Next, we'll use this new version of the <code class="Code-In-Text--PACKT-">TaskQueue</code> class to implement version 4 of our web spider.</p>
    <h3 id="_idParaDest-128" class="title">Updating the web spider</h3>
    <p class="normal">Now it's time to <a id="_idIndexMarker350"/>adapt our web spider to implement a limited parallel execution flow using the <code class="Code-In-Text--PACKT-">TaskQueue</code> class we have just created.</p>
    <p class="normal">First, we need to split the <code class="Code-In-Text--PACKT-">spider()</code> function into two functions, one simply initializing a new <code class="Code-In-Text--PACKT-">TaskQueue</code> object and another actually executing the spidering task, which we will call <code class="Code-In-Text--PACKT-">spiderTask()</code>. Then, we need to update the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function to invoke the newly created <code class="Code-In-Text--PACKT-">spiderTask()</code> function and forward the task <code class="Code-In-Text--PACKT-">queue</code> instance received as an input. Let's see what all this looks like:</p>
    <pre class="programlisting code"><code class="hljs-code">function spiderLinks (currentUrl, content, nesting, queue) {
  if (nesting === 0) {
    return Promise.resolve()
  }
  const links = getPageLinks(currentUrl, content)
  const promises = links
    .map(link =&gt; spiderTask(link, nesting - 1, queue))
  return Promise.all(promises)                             // (2)
}
const spidering = new Set()
function spiderTask (url, nesting, queue) {
  if (spidering.has(url)) {
    return Promise.resolve()
  }
  spidering.add(url)
  const filename = urlToFilename(url)
  return queue
    .runTask(() =&gt; {                                       // (1)
      return fsPromises.readFile(filename, 'utf8')
        .catch((err) =&gt; {
          if (err.code !== 'ENOENT') {
            throw err
          }
          // The file doesn't exists, so let's download it
          return download(url, filename)
        })
    })
    .then(content =&gt; spiderLinks(url, content, nesting, queue))
}
export function spider (url, nesting, concurrency) {
  const queue = new TaskQueue(concurrency)
  return spiderTask(url, nesting, queue)
}
</code></pre>
    <p class="normal">The crucial instruction in the code we have just seen is where we invoke <code class="Code-In-Text--PACKT-">queue.runTask()</code> (1). Here, the task that we are queuing (and therefore limiting) comprises just the retrieval of the contents of the URL from either the local filesystem or the remote URL location. Only after this task has been run by the queue can we continue to spider the<a id="_idIndexMarker351"/> links of the webpage. Note that we are intentionally keeping <code class="Code-In-Text--PACKT-">spiderLinks()</code> outside of the task that we want to limit. This is because <code class="Code-In-Text--PACKT-">spiderLinks()</code> can trigger more <code class="Code-In-Text--PACKT-">spiderTasks()</code> and that would create a deadlock if the depth of the spidering process is higher than the concurrency limit of the queue.</p>
    <p class="normal">We can also notice how in <code class="Code-In-Text--PACKT-">spiderLinks()</code> we simply continue to use <code class="Code-In-Text--PACKT-">Promise.all()</code> (2) to download all the links of a webpage in parallel. This is because it's the responsibility of our <code class="Code-In-Text--PACKT-">queue</code> to limit the concurrency of the tasks.</p>
    <div><p class="Tip--PACKT-">In production code, you can use the package <code class="Code-In-Text--PACKT-">p-limit</code> (available at <a href="http://nodejsdp.link/p-limit">nodejsdp.link/p-limit</a>) to limit the concurrency of a set of tasks. The package essentially implements the pattern we have just shown but wrapped in a slightly different API.</p>
    </div>
    <p class="normal">This concludes our exploration of JavaScript promises. Next, we are going to learn about the async/await pair, which will completely revolutionize the way we deal with asynchronous code.</p>
    <h1 id="_idParaDest-129" class="title">Async/await</h1>
    <p class="normal">As we have just seen, promises are a quantum leap ahead of callbacks. They allow us to write clean and readable<a id="_idIndexMarker352"/> asynchronous code and provide a set of safeguards that can only be achieved with boilerplate code when working with callback-based asynchronous code. However, promises are still suboptimal when it comes to writing sequential asynchronous code. The <code class="Code-In-Text--PACKT-">Promise</code> chain is indeed much better than having callback hell, but still, we have to invoke a <code class="Code-In-Text--PACKT-">then()</code> and create a new function for each task in the chain. This is still too much for a control flow that is definitely the most commonly used in everyday programming. JavaScript needed a proper way to deal with the ubiquitous asynchronous sequential execution flow, and the answer arrived with the introduction in the ECMAScript standard of <strong class="keyword">async functions</strong> and the <code class="Code-Highlighted--PACKT-" style="font-weight: bold">await</code><strong class="keyword"> expression</strong> (<strong class="keyword">async/await</strong> for short).</p>
    <p class="normal">The async/await dichotomy allows us to write functions that appear to block at each asynchronous operation, waiting for the results before continuing with the following statement. As we will see, any asynchronous code using async/await has a readability comparable to traditional synchronous code.</p>
    <p class="normal">Today, async/await is the recommended construct for dealing with asynchronous code in both Node.js and JavaScript. However, async/await does not replace all that we have learned so far about asynchronous control flow patterns; on the contrary, as we will see, async/await piggybacks heavily onto promises.</p>
    <h2 id="_idParaDest-130" class="title">Async functions and the await expression</h2>
    <p class="normal">An async function <a id="_idIndexMarker353"/>is a special <a id="_idIndexMarker354"/>type of function in which it's possible to use the <code class="Code-In-Text--PACKT-">await</code> expression to "pause" the execution on a given <code class="Code-In-Text--PACKT-">Promise</code> until it resolves. Let's consider a simple example and use the <code class="Code-In-Text--PACKT-">delay()</code> function we implemented in the <em class="italic">Creating a promise</em> subsection. The <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">delay()</code> resolves with the current date as the value after the given number of milliseconds. Let's use this function with the async/await pair:</p>
    <pre class="programlisting code"><code class="hljs-code">async function playingWithDelays () {
  console.log('Delaying...', new Date())
  const dateAfterOneSecond = await delay(1000)
  console.log(dateAfterOneSecond)
  const dateAfterThreeSeconds = await delay(3000)
  console.log(dateAfterThreeSeconds)
  return 'done'
}
</code></pre>
    <p class="normal">As we can see from the previous function, async/await seems to work like magic. The code doesn't even look like it contains any asynchronous operation. However, don't be mistaken; this function does not run synchronously (they are called async functions for a reason!). At each <code class="Code-In-Text--PACKT-">await</code> expression, the execution of the function is put on hold, its state saved, and the control returned to the event loop. Once the <code class="Code-In-Text--PACKT-">Promise</code> that has been <em class="italic">awaited</em> resolves, the control is given back to the async function, returning the fulfilment value of the <code class="Code-In-Text--PACKT-">Promise</code>.</p>
    <div><p class="Tip--PACKT-">The <code class="Code-In-Text--PACKT-">await</code> expression works with any value, not just promises. If a value other than a <code class="Code-In-Text--PACKT-">Promise</code> is provided, then its behavior is similar to awaiting a value that it first passed to <code class="Code-In-Text--PACKT-">Promise.resolve()</code>.</p>
    </div>
    <p class="normal">Let's now see how we can invoke our new async function:</p>
    <pre class="programlisting code"><code class="hljs-code">playingWithDelays()
  .then(result =&gt; {
    console.log(`After 4 seconds: ${result}`)
  })
</code></pre>
    <p class="normal">From the<a id="_idIndexMarker355"/> preceding code, it's clear that async functions can be invoked just like any other<a id="_idIndexMarker356"/> function. However, the most observant of you may have already spotted another important property of async functions: they always return a <code class="Code-In-Text--PACKT-">Promise</code>. It's like if the return value of an async function was passed to <code class="Code-In-Text--PACKT-">Promise.resolve()</code> and then returned to the caller.</p>
    <div><p class="Information-Box--PACKT-">Invoking an async function is instantaneous, like any other asynchronous operation. In other words, async functions return a <code class="Code-In-Text--PACKT-">Promise</code> synchronously. That <code class="Code-In-Text--PACKT-">Promise</code> will then eventually settle based on the result or error produced by the function.</p>
    </div>
    <p class="normal">From this first encounter with async/await, we can see how dominant promises still are in our discussion. In fact, we can consider async/await just a syntactic sugar for a simpler consumption of promises. As we will see, all the asynchronous control flow patterns with async/await use promises and their API for most of the heavy-lifting operations.</p>
    <h2 id="_idParaDest-131" class="title">Error handling with async/await</h2>
    <p class="normal">Async/await<a id="_idIndexMarker357"/> doesn't just improve the readability of asynchronous code under standard conditions, but it also helps when handling errors. In fact, one of the biggest gains of async/await is the ability to normalize the behavior of the <code class="Code-In-Text--PACKT-">try...catch</code> block, to make it work seamlessly with both synchronous <em class="italic">throws</em> and asynchronous <code class="Code-In-Text--PACKT-">Promise</code> rejections. Let's demonstrate that with an example.</p>
    <h3 id="_idParaDest-132" class="title">A unified try...catch experience</h3>
    <p class="normal">Let's define a<a id="_idIndexMarker358"/> function that returns a <code class="Code-In-Text--PACKT-">Promise</code> that rejects with an error after a given number of milliseconds. This is very similar to the <code class="Code-In-Text--PACKT-">delay()</code> function that we already know very well:</p>
    <pre class="programlisting code"><code class="hljs-code">function delayError (milliseconds) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      reject(new Error(`Error after ${milliseconds}ms`))
    }, milliseconds)
  })
}
</code></pre>
    <p class="normal">Next, let's implement an async function that can <code class="Code-In-Text--PACKT-">throw</code> an error synchronously or <code class="Code-In-Text--PACKT-">await</code> a <code class="Code-In-Text--PACKT-">Promise</code> that will reject. This function demonstrates how both the synchronous <code class="Code-In-Text--PACKT-">throw</code> and the <code class="Code-In-Text--PACKT-">Promise</code> rejection are caught by the same <code class="Code-In-Text--PACKT-">catch</code> block:</p>
    <pre class="programlisting code"><code class="hljs-code">async function playingWithErrors (throwSyncError) {
  try {
    if (throwSyncError) {
      throw new Error('This is a synchronous error')
    }
    await delayError(1000)
  } catch (err) {
    console.error(`We have an error: ${err.message}`)
  } finally {
    console.log('Done')
  }
}
</code></pre>
    <p class="normal">Now, invoking the function like this:</p>
    <pre class="programlisting code"><code class="hljs-code">playingWithErrors(true)
</code></pre>
    <p class="normal">Will print to the console the following:</p>
    <pre class="programlisting con"><code class="hljs-con">We have an error: This is a synchronous error
Done
</code></pre>
    <p class="normal">While invoking the function with <code class="Code-In-Text--PACKT-">false</code> as the input, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">playingWithErrors(false)
</code></pre>
    <p class="normal">Will produce the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">We have an error: Error after 1000ms
Done
</code></pre>
    <p class="normal">If we remember how we had to deal with errors in <em class="chapterRef">Chapter 4</em>, <em class="italic">Asynchronous Control Flow Patterns with Callbacks</em>, we will surely appreciate the giant improvements introduced by both promises and async/await. Now, error <a id="_idIndexMarker359"/>handling is just as it should be: simple, readable, and most importantly, supporting both synchronous and asynchronous errors.</p>
    <h3 id="_idParaDest-133" class="title">The "return" versus "return await" trap</h3>
    <p class="normal">One common <a id="_idIndexMarker360"/>antipattern when dealing with errors with async/await is returning a <code class="Code-In-Text--PACKT-">Promise</code> that rejects to the caller and expecting the error to be caught by the local <code class="Code-In-Text--PACKT-">try...catch</code> block of the function that is returning the <code class="Code-In-Text--PACKT-">Promise</code>.</p>
    <p class="normal">For example, consider the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">async function errorNotCaught () {
  try {
    return delayError(1000)
  } catch (err) {
    console.error('Error caught by the async function: ' +
      err.message)
  }
}
errorNotCaught()
  .catch(err =&gt; console.error('Error caught by the caller: ' +
    err.message))
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">delayError()</code> is not awaited locally, which means that it's returned as it is to the caller. As a consequence, the local <code class="Code-In-Text--PACKT-">catch</code> block will never be invoked. In fact, the previous code will output:</p>
    <pre class="programlisting con"><code class="hljs-con">Error caught by the caller: Error after 1000ms
</code></pre>
    <p class="normal">If our intention is catching locally any error generated by the asynchronous operation that produces the value that we want to return to the caller, then we have to use the <code class="Code-In-Text--PACKT-">await</code> expression on that <code class="Code-In-Text--PACKT-">Promise</code> <em class="italic">before</em> we return the value to the caller. The following code demonstrates this:</p>
    <pre class="programlisting code"><code class="hljs-code">async function errorCaught () {
  try {
    return await delayError(1000)
  } catch (err) {
    console.error('Error caught by the async function: ' +
      err.message) }
}
errorCaught()
  .catch(err =&gt; console.error('Error caught by the caller: ' +
    err.message))
</code></pre>
    <p class="normal">All we did was add an <code class="Code-In-Text--PACKT-">await</code> after the <code class="Code-In-Text--PACKT-">return</code> keyword. This is enough to cause the async function to "deal" with the <code class="Code-In-Text--PACKT-">Promise</code> locally and <a id="_idIndexMarker361"/>therefore also catch any rejection locally. As a confirmation, when we run the previous code, we should see the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">Error caught by the async function: Error after 1000ms
</code></pre>
    <h2 id="_idParaDest-134" class="title">Sequential execution and iteration</h2>
    <p class="normal">Our exploration<a id="_idIndexMarker362"/> of control flow patterns with async/await starts with sequential execution and iteration. We already mentioned a few times that the core<a id="_idIndexMarker363"/> strength of async/await lies in its ability to make asynchronous serial execution easy to write and straightforward to read. This was already apparent in all the code samples we have written so far; however, it will become even more obvious now that we will start converting our web spider version 2. Async/await is so simple to use and understand that there are really no patterns here to study. We will get straight to the code, without any preamble.</p>
    <p class="normal">So, let's start with the <code class="Code-In-Text--PACKT-">download()</code> function of our web spider; this is how it looks with async/await:</p>
    <pre class="programlisting code"><code class="hljs-code">async function download (url, filename) {
  console.log(`Downloading ${url}`)
  const { text: content } = await superagent.get(url)
  await mkdirpPromises(dirname(filename))
  await fsPromises.writeFile(filename, content)
  console.log(`Downloaded and saved: ${url}`)
  return content
}
</code></pre>
    <p class="normal">Let's appreciate for a moment how simple and compact the <code class="Code-In-Text--PACKT-">download()</code> function has become. Let's just consider that the same functionality was implemented with callbacks in two different functions using a total of 19 lines of code. Now we just have seven. Plus, the code is now <a id="_idIndexMarker364"/>completely flat, with no nesting at all. This tells<a id="_idIndexMarker365"/> us a lot about the enormous positive impact that async/await has on our code.</p>
    <p class="normal">Now, let's see how we can iterate asynchronously over an array using async/await. This is exemplified in the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">async function spiderLinks (currentUrl, content, nesting) {
  if (nesting === 0) {
    return
  }
  const links = getPageLinks(currentUrl, content)
  for (const link of links) {
    await spider(link, nesting - 1)
  }
}
</code></pre>
    <p class="normal">Even here there is no pattern to learn. We just have a simple iteration over a list of <code class="Code-In-Text--PACKT-">links</code> and for each item, we <code class="Code-In-Text--PACKT-">await</code> on the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">spider()</code>.</p>
    <p class="normal">The next code fragment shows the <code class="Code-In-Text--PACKT-">spider()</code> function implemented using async/await. The aspect to notice here is how errors are easily dealt with using just a <code class="Code-In-Text--PACKT-">try...catch</code> statement, making everything easier to read:</p>
    <pre class="programlisting code"><code class="hljs-code">export async function spider (url, nesting) {
  const filename = urlToFilename(url)
  let content
  try {
    content = await fsPromises.readFile(filename, 'utf8')
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err
    }
    content = await download(url, filename)
  }
  return spiderLinks(url, content, nesting)
}
</code></pre>
    <p class="normal">And with the <code class="Code-In-Text--PACKT-">spider()</code> function, we <a id="_idIndexMarker366"/>have completed the<a id="_idIndexMarker367"/> conversion of our web spider application to async/await. As you can see, it has been quite a smooth process but the results are quite impressive.</p>
    <h3 id="_idParaDest-135" class="title">Antipattern – using async/await with Array.forEach for serial execution</h3>
    <p class="normal">It's worth mentioning <a id="_idIndexMarker368"/>that there is a common antipattern whereby developers will try to use <code class="Code-In-Text--PACKT-">Array.forEach()</code> or <code class="Code-In-Text--PACKT-">Array.map()</code> to implement a sequential asynchronous iteration with async/await, which, of course, won't work as expected.</p>
    <p class="normal">To see why, let's take a look at the following alternate implementation (which is wrong!) of the asynchronous iteration in the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">links.forEach(async function iteration(link) {
  await spider(link, nesting - 1)
})
</code></pre>
    <p class="normal">In the previous code, the <code class="Code-In-Text--PACKT-">iteration</code> function is invoked once for each element of the <code class="Code-In-Text--PACKT-">links</code> array. Then, in the <code class="Code-In-Text--PACKT-">iteration</code> function, we use the <code class="Code-In-Text--PACKT-">await</code> expression on the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">spider()</code>. However, the <code class="Code-In-Text--PACKT-">Promise</code> returned by the <code class="Code-In-Text--PACKT-">iteration</code> function is just ignored by <code class="Code-In-Text--PACKT-">forEach()</code>. The result is that all the <code class="Code-In-Text--PACKT-">spider()</code> functions are invoked in the same round of the event loop, which means they are started in parallel, and the execution continues immediately after invoking <code class="Code-In-Text--PACKT-">forEach()</code>, without waiting for all the <code class="Code-In-Text--PACKT-">spider()</code> operations to complete.</p>
    <h2 id="_idParaDest-136" class="title">Parallel execution</h2>
    <p class="normal">There are mainly two ways to run a set of tasks in parallel using async/await; one purely uses the <code class="Code-In-Text--PACKT-">await</code> expression<a id="_idIndexMarker369"/> and the other relies on <code class="Code-In-Text--PACKT-">Promise.all()</code>. They are both very simple to implement; however, be advised that the method relying on <code class="Code-In-Text--PACKT-">Promise.all()</code> is the recommended (and optimal) one to use.</p>
    <p class="normal">Let's see an example of both. Let's consider the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function of our web spider. If we wanted to purely use the <code class="Code-In-Text--PACKT-">await</code> expression to implement an unlimited parallel asynchronous execution flow, we would do it with some code like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">async function spiderLinks (currentUrl, content, nesting) {
  if (nesting === 0) {
    return
  }
  const links = getPageLinks(currentUrl, content)
  const promises = links.map(link =&gt; spider(link, nesting - 1))
  for (const promise of promises) {
    await promise
  }
}
</code></pre>
    <p class="normal">That's it—very simple. In the previous code, we first start all the <code class="Code-In-Text--PACKT-">spider()</code> tasks in parallel, collecting their promises with a <code class="Code-In-Text--PACKT-">map()</code>. Then, we loop, and we <code class="Code-In-Text--PACKT-">await</code> on each one of those promises.</p>
    <p class="normal">At first, it seems neat and functional; however, it has a small undesired effect. If a <code class="Code-In-Text--PACKT-">Promise</code> in the array rejects, we have to wait for all the preceding promises in the array to resolve before the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">spiderLinks()</code> will also reject. This is not optimal in most situations, as we usually want to know if an operation has failed as soon as possible. Luckily, we already have a built-in function that behaves exactly the way we want, and that's <code class="Code-In-Text--PACKT-">Promise.all()</code>. In fact, <code class="Code-In-Text--PACKT-">Promise.all()</code> will reject as soon as any of the promises provided in the input array reject. Therefore, we can simply rely on this method even for all our async/await code. And, since <code class="Code-In-Text--PACKT-">Promise.all()</code> returns just another <code class="Code-In-Text--PACKT-">Promise</code>, we can simply invoke an <code class="Code-In-Text--PACKT-">await</code> on it to get the results from multiple asynchronous operations. The following code shows an example:</p>
    <pre class="programlisting code"><code class="hljs-code">const results = await Promise.all(promises)
</code></pre>
    <p class="normal">So, to wrap up, our recommended implementation of the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function with parallel execution and async/await will look almost identical to that using promises. The only visible difference is the fact that we are now using an async function, which always returns a <code class="Code-In-Text--PACKT-">Promise</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">async function spiderLinks (currentUrl, content, nesting) {
  if (nesting === 0) {
    return
  }
  const links = getPageLinks(currentUrl, content)
  const promises = links.map(link =&gt; spider(link, nesting - 1))
  return Promise.all(promises)
}
</code></pre>
    <p class="normal">What we just learned about parallel execution and async/await simply reiterates the fact that async/await is inseparable from promises. Most of the utilities that work with promises will<a id="_idIndexMarker370"/> also seamlessly work with async/await and we should never hesitate to take advantage of them in our async functions.</p>
    <h2 id="_idParaDest-137" class="title">Limited parallel execution</h2>
    <p class="normal">To implement a limited parallel<a id="_idIndexMarker371"/> execution pattern with async/await, we can simply reuse the <code class="Code-In-Text--PACKT-">TaskQueue</code> class that we created in the <em class="italic">Limited parallel execution</em> subsection within the <em class="italic">Promises</em> section. We can either use it as it is or convert its internals to async/await. Converting the <code class="Code-In-Text--PACKT-">TaskQueue</code> class to async/await is a trivial operation and we'll leave this to you as an exercise. Either way, the <code class="Code-In-Text--PACKT-">TaskQueue</code> external interface shouldn't change; both implementations will have a <code class="Code-In-Text--PACKT-">runTask()</code> method that returns a <code class="Code-In-Text--PACKT-">Promise</code> that settles when the task has been run by the queue.</p>
    <p class="normal">Starting from this assumption, converting the web spider v4 from promises to async/await is also a trivial task and we won't show all the steps here as we wouldn't be learning anything new. Instead, what we'll do in this section is examine a third variation of the <code class="Code-In-Text--PACKT-">TaskQueue</code> class that uses async/await and a <strong class="keyword">producer-consumer</strong> approach.</p>
    <p class="normal">The general idea to apply this approach to our problem goes as follows:</p>
    <ul>
      <li class="Bullet--PACKT-">On one side, we have an unknown set of <em class="italic">producers</em> adding tasks into a queue.</li>
      <li class="Bullet-End--PACKT-">On the other side, we have a predefined set of <em class="italic">consumers</em>, responsible for extracting and executing the tasks from the queue, one at a time.</li>
    </ul>
    <p class="normal">The following diagram should help us understand the setup:</p>
    <figure class="mediaobject"><img src="img/B15729_05_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.2: Using the Producer-Consumer pattern to implement limited parallel execution</p>
    <p class="normal">The number of consumers will determine the concurrency with which the tasks will be executed. The challenge here is to put the consumers to "sleep" when the queue is empty and "wake them up" again when there are new tasks to run. But we are lucky, since Node.js is<a id="_idIndexMarker372"/> single-threaded, so putting a task to "sleep" just means giving back control to the event loop, while "resuming" a task is equivalent to invoking a callback.</p>
    <p class="normal">With this in mind, let's then take a look at some code. We will create a new class called <code class="Code-In-Text--PACKT-">TaskQueuePC</code> with a public interface similar to one of the <code class="Code-In-Text--PACKT-">TaskQueue</code> classes we implemented previously in this chapter. Taking a top-down approach, let's see how we can implement the constructor:</p>
    <pre class="programlisting code"><code class="hljs-code">export class TaskQueuePC {
  constructor (concurrency) {
    this.taskQueue = []
    this.consumerQueue = []
    // spawn consumers
    for (let i = 0; i &lt; concurrency; i++) {
      this.consumer()
    }
  }
  // ...
</code></pre>
    <p class="normal">First of all, we can notice that we now have two queues, one to hold our tasks (<code class="Code-In-Text--PACKT-">taskQueue</code>) and the other to store our sleeping consumers (<code class="Code-In-Text--PACKT-">consumerQueue</code>). It will be clearer in a while how these queues will be used. In the second part of our constructor, we spawn as many consumers as the concurrency we want to attain. Let's see what a consumer looks like:</p>
    <pre class="programlisting code"><code class="hljs-code">async consumer () {
  while (true) {                                           // (1)
    try {
      const task = await this.getNextTask()                // (2)
      await task()                                         // (3)
    } catch (err) {
      console.error(err)                                   // (4)
    }
  }
}
</code></pre>
    <p class="normal">Our consumer is an infinite <code class="Code-In-Text--PACKT-">while</code> loop (1). At each iteration, we try to retrieve a new task from the queue using <code class="Code-In-Text--PACKT-">getNextTask()</code> (2). As we will see, this will cause the current <a id="_idIndexMarker373"/>consumer to sleep if the queue is empty. When a new <code class="Code-In-Text--PACKT-">task</code> is eventually available, we just execute it (3). Any error thrown from the above operation should not cause the consumer to stop, so we simply log it (4) and continue with the next iteration.</p>
    <div><p class="Information-Box--PACKT-">By the look of it, it may seem that each consumer in <code class="Code-In-Text--PACKT-">TaskQueuePC</code> is an actual thread. In fact, our <code class="Code-In-Text--PACKT-">consumer()</code> function has an infinite loop and it can "pause" until awakened by some other "thread." In reality, we should not forget that each consumer is an async function, which is nothing more than a nice syntax built around promises and callbacks. The <code class="Code-In-Text--PACKT-">while</code> loop may seem to be spinning continuously consuming CPU cycles, but under the hood, the loop is more similar to an asynchronous recursion than a traditional <code class="Code-In-Text--PACKT-">while</code> loop.</p>
    </div>
    <p class="normal">With the next code fragment, we should start to get an idea of what's going on. Let's take a look at the implementation of <code class="Code-In-Text--PACKT-">getNextTask()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">async getNextTask () {
  return new Promise((resolve) =&gt; {
    if (this.taskQueue.length !== 0) {
      return resolve(this.taskQueue.shift())               // (1)
    }
    this.consumerQueue.push(resolve)                       // (2)
  })
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">getNextTask()</code> method returns a new <code class="Code-In-Text--PACKT-">Promise</code> that resolves with the first task in the queue if the queue is not empty. The first task is removed from <code class="Code-In-Text--PACKT-">taskQueue</code> and used as an argument to invoke <code class="Code-In-Text--PACKT-">resolve</code> (1). If the queue is instead empty, we postpone the resolution of the <code class="Code-In-Text--PACKT-">Promise</code> by queuing the <code class="Code-In-Text--PACKT-">resolve</code> callback into the <code class="Code-In-Text--PACKT-">consumerQueue</code>. This will effectively put the <code class="Code-In-Text--PACKT-">Promise</code>—and the consumer that is awaiting the <code class="Code-In-Text--PACKT-">Promise</code>—to sleep.</p>
    <p class="normal">Now comes the "gluing" part of the whole <code class="Code-In-Text--PACKT-">TaskQueuePC</code> class, which corresponds to the <em class="italic">producer</em> side of the algorithm. That's <a id="_idIndexMarker374"/>implemented in the <code class="Code-In-Text--PACKT-">runTask()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">runTask (task) {
  return new Promise((resolve, reject) =&gt; {
    const taskWrapper = () =&gt; {                            // (1)
      const taskPromise = task()
      taskPromise.then(resolve, reject)
      return taskPromise
    }
    if (this.consumerQueue.length !== 0) {                 // (2)
      const consumer = this.consumerQueue.shift()
      consumer(taskWrapper)
    } else {                                               // (3)
      this.taskQueue.push(taskWrapper)
    }
  })
}
</code></pre>
    <p class="normal">First, we create a <code class="Code-In-Text--PACKT-">taskWrapper</code> function (1) that, when executed, has the responsibility for running the input <code class="Code-In-Text--PACKT-">task</code> and forwarding the status of the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">task()</code> to the outer <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">runTask()</code>. Next, if the <code class="Code-In-Text--PACKT-">consumerQueue</code> is not empty (2), it means that there is at least one consumer that is asleep, waiting for new tasks to run. We then extract the first consumer from the queue (remember, that's essentially the <code class="Code-In-Text--PACKT-">resolve</code> callback of the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">getNextTask()</code>) and we invoke it immediately by passing our <code class="Code-In-Text--PACKT-">taskWrapper</code>. If, instead, all the consumers are already busy (3), we push <code class="Code-In-Text--PACKT-">taskWrapper</code> into the <code class="Code-In-Text--PACKT-">taskQueue</code>.</p>
    <p class="normal">This concludes the implementation of our <code class="Code-In-Text--PACKT-">TaskQueuePC</code> class. The public interface of the <code class="Code-In-Text--PACKT-">TaskQueuePC</code> class is identical to that of the <code class="Code-In-Text--PACKT-">TaskQueue</code> class that we implemented in the <em class="italic">Promises</em> section, so migrating the code of our web spider to the new algorithm will be a trivial task.</p>
    <p class="normal">This also concludes our<a id="_idIndexMarker375"/> exploration of the async/await construct. But, before we wrap up the chapter, we'll dive into a subtle problem affecting promises.</p>
    <h1 id="_idParaDest-138" class="title">The problem with infinite recursive promise resolution chains</h1>
    <p class="normal">At this point in the chapter, you should have a strong understanding of how promises work and how to use<a id="_idIndexMarker376"/> them to implement the most common control flow constructs. This is therefore the right time to discuss an advanced topic that every professional Node.js developer should know and understand. This advanced topic is about a memory leak caused by infinite <code class="Code-In-Text--PACKT-">Promise</code> resolution chains. The bug seems to affect the actual Promises/A+ specification, so no compliant implementation is immune.</p>
    <p class="normal">It is quite common in programming to have tasks that don't have a predefined ending or take as an input a potentially infinite array of data. We can include in this category things like the encoding/decoding of live audio/video streams, the processing of live cryptocurrency market data, and the monitoring of IoT sensors. But we can have much more trivial situations than those, for example, when making heavy use of functional programming.</p>
    <p class="normal">To take a simple example, let's consider the following code, which defines a simple infinite operation using promises:</p>
    <pre class="programlisting code"><code class="hljs-code">function leakingLoop () {
  return delay(1)
    .then(() =&gt; {
      console.log(`Tick ${Date.now()}`)
      return leakingLoop()
    })
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">leakingLoop()</code> function that we just defined uses the <code class="Code-In-Text--PACKT-">delay()</code> function (which we created at the beginning of this chapter) to simulate an asynchronous operation. When the given number of milliseconds has elapsed, we print the current timestamp and we invoke <code class="Code-In-Text--PACKT-">leakingLoop()</code> recursively to start the operation over again. The interesting part is that the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">leakingLoop()</code> never resolves because its status depends on the next invocation of <code class="Code-In-Text--PACKT-">leakingLoop()</code>, which in turn depends on the next invocation of <code class="Code-In-Text--PACKT-">leakingLoop()</code> and so on. This situation creates a chain of promises that never settle, and it will cause a memory leak in <code class="Code-In-Text--PACKT-">Promise</code> implementations that strictly follow the Promises/A+ specification, including JavaScript ES6 promises.</p>
    <p class="normal">To demonstrate the leak, we can try running the <code class="Code-In-Text--PACKT-">leakingLoop()</code> function many times to accentuate the effects of the leak:</p>
    <pre class="programlisting code"><code class="hljs-code">for (let i = 0; i &lt; 1e6; i++) {
  leakingLoop()
}
</code></pre>
    <p class="normal">Then we can take a look<a id="_idIndexMarker377"/> at the memory footprint of the process using our favorite process inspector and notice how it grows indefinitely until (after a few minutes) the process crashes entirely.</p>
    <p class="normal">The solution to the problem is to break the chain of <code class="Code-In-Text--PACKT-">Promise</code> resolution. We can do that by making sure that the status of the <code class="Code-In-Text--PACKT-">Promise</code> returned by <code class="Code-In-Text--PACKT-">leakingLoop()</code> does not depend on the promise returned by the next invocation of <code class="Code-In-Text--PACKT-">leakingLoop()</code>. </p>
    <p class="normal">We can ensure that by simply removing a <code class="Code-In-Text--PACKT-">return</code> instruction:</p>
    <pre class="programlisting code"><code class="hljs-code">function nonLeakingLoop () {
  delay(1)
    .then(() =&gt; {
      console.log(`Tick ${Date.now()}`)
      nonLeakingLoop()
    })
}
</code></pre>
    <p class="normal">Now, if we use this new function in our sample program, we should see that the memory footprint of the process will go up and down, following the schedule of the various runs of the garbage collector, which means that there is no memory leak.</p>
    <p class="normal">However, the solution we have just proposed radically changes the behavior of the original <code class="Code-In-Text--PACKT-">leakingLoop()</code> function. In particular, this new function won't propagate eventual errors produced deeply within the recursion, since there is no link between the status of the various promises. This inconvenience may be mitigated by adding some extra logging within the function. But sometimes the new behavior itself may not be an option. So, a possible solution involves wrapping the recursive function with a <code class="Code-In-Text--PACKT-">Promise</code> constructor, such as in the following code sample:</p>
    <pre class="programlisting code"><code class="hljs-code">function nonLeakingLoopWithErrors () {
  return new Promise((resolve, reject) =&gt; {
    (function internalLoop () {
      delay(1)
        .then(() =&gt; {
          console.log(`Tick ${Date.now()}`)
          internalLoop()
        })
        .catch(err =&gt; {
          reject(err)
        })
    })()
  })
}
</code></pre>
    <p class="normal">In this case, we still don't have any link between the promises created at the various stages of the<a id="_idIndexMarker378"/> recursion; however, the <code class="Code-In-Text--PACKT-">Promise</code> returned by the <code class="Code-In-Text--PACKT-">nonLeakingLoopWithErrors()</code> function will still reject if any asynchronous operation fails, no matter at what depth in the recursion that happens.</p>
    <p class="normal">A third solution makes use of async/await. In fact, with async/await we can <em class="italic">simulate</em> a recursive <code class="Code-In-Text--PACKT-">Promise</code> chain with a simple infinite <code class="Code-In-Text--PACKT-">while</code> loop, such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">async function nonLeakingLoopAsync () {
  while (true) {
    await delay(1)
    console.log(`Tick ${Date.now()}`)
  }
}
</code></pre>
    <p class="normal">In this function too, we preserve the behavior of the original recursive function, whereby any error thrown by the asynchronous task (in this case <code class="Code-In-Text--PACKT-">delay()</code>) is propagated to the original function caller.</p>
    <p class="normal">We should note that we would still have a memory leak if instead of a <code class="Code-In-Text--PACKT-">while</code> loop, we chose to implement the async/await solution with an actual asynchronous recursive step, such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">async function leakingLoopAsync () {
  await delay(1)
  console.log(`Tick ${Date.now()}`)
  return leakingLoopAsync()
}
</code></pre>
    <p class="normal">The code above would still create an infinite chain of promises that never resolve and therefore it's still affected by the same memory leak issue of the equivalent promise-based implementation.</p>
    <div><p class="Tip--PACKT-">If you are interested in knowing more about the memory leak discussed in this section, you can check the related Node.js issue at <a href="http://nodejsdp.link/node-6673">nodejsdp.link/node-6673</a> or the related issue on the Promises/A+ GitHub repository at <a href="http://nodejsdp.link/promisesaplus-memleak">nodejsdp.link/promisesaplus-memleak</a>.</p>
    </div>
    <p class="normal">So, the next time you <a id="_idIndexMarker379"/>are building an infinite promise chain, remember to double-check if there are the conditions for creating a memory leak, as you learned in this section. If that's the case, you can apply one of the proposed solutions, making sure to choose the one that is best suited to your context.</p>
    <h1 id="_idParaDest-139" class="title">Summary</h1>
    <p class="normal">In this chapter, we've learned how to use promises and async/await syntax to write asynchronous code that is more concise, cleaner, and easier to read.</p>
    <p class="normal">As we've seen, promises and async/await greatly simplify the serial execution flow, which is the most commonly used control flow. In fact, with async/await, writing a sequence of asynchronous operations is almost as easy as writing synchronous code. Running some asynchronous operations in parallel is also very easy thanks to the <code class="Code-In-Text--PACKT-">Promise.all()</code> utility.</p>
    <p class="normal">But the advantages of using promises and async/await don't stop here. We've learned that they provide a transparent shield against tricky situations such as code with mixed synchronous/asynchronous behavior (a.k.a. Zalgo, which we discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Callbacks and Events</em>). On top of that, error management with promises and async/await is much more intuitive and leaves less room for mistakes (such as forgetting to forward errors, which is a serious source of bugs in code using callbacks).</p>
    <p class="normal">In terms of patterns and techniques, we should definitely keep in mind the chain of promises (to run tasks in series), promisification, and the Producer-Consumer pattern. Also, pay attention when using <code class="Code-In-Text--PACKT-">Array.forEach()</code> with async/await (you are probably doing it wrong) and keep in mind the difference between a simple <code class="Code-In-Text--PACKT-">return</code> and <code class="Code-In-Text--PACKT-">return await</code> in async functions.</p>
    <p class="normal">Callbacks are still widely used in the Node.js and JavaScript world. We find them in legacy APIs, in code that interacts with native libraries, or when there is the need to micro-optimize particular routines. That's why they are still relevant to us, Node.js developers; however, for most of our day-to-day programming tasks, promises and async/await are a huge step ahead compared to callbacks and therefore they are now the de facto standard for dealing with asynchronous code in Node.js. That's why we will be using promises and async/await throughout the rest of the book too to write our asynchronous code.</p>
    <p class="normal">In the next chapter, we will explore another fascinating topic relative to asynchronous code execution, which is also another fundamental building block in the whole Node.js ecosystem, that is, streams.</p>
    <h1 id="_idParaDest-140" class="title">Exercises</h1>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">5.1 Dissecting </strong><code class="Code-Highlighted--PACKT-" style="font-weight: bold;">Promise.all()</code>: Implement your own version of <code class="Code-In-Text--PACKT-">Promise.all()</code> leveraging promises, async/await, or a combination of the two. The function must be functionally equivalent to its original counterpart.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">5.2 </strong><code class="Code-Highlighted--PACKT-" style="font-weight: bold;">TaskQueue</code> <strong class="keyword">with promises</strong>: Migrate the <code class="Code-In-Text--PACKT-">TaskQueue</code> class internals from promises to async/await where possible. Hint: you won't be able to use async/await everywhere.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">5.3 Producer-consumer with promises</strong>: Update the <code class="Code-In-Text--PACKT-">TaskQueuePC</code> class internal methods so that they use just promises, removing any use of the async/await syntax. Hint: the infinite loop must become an asynchronous recursion. Beware of the recursive <code class="Code-In-Text--PACKT-">Promise</code> resolution memory leak!</li>
      <li class="Bullet--PACKT-"><strong class="keyword">5.4 An asynchronous </strong><code class="Code-Highlighted--PACKT-" style="font-weight: bold;">map()</code>: Implement a parallel asynchronous version of <code class="Code-In-Text--PACKT-">Array.map()</code> that supports promises and a concurrency limit. The function should not directly leverage the <code class="Code-In-Text--PACKT-">TaskQueue</code> or <code class="Code-In-Text--PACKT-">TaskQueuePC</code> classes we presented in this chapter, but it can use the underlying patterns. The function, which we will define as <code class="Code-In-Text--PACKT-">mapAsync(iterable, callback, concurrency)</code>, will accept the following as inputs:<ul>
          <li class="Bullet-Within-Bullet--PACKT-">An <code class="Code-In-Text--PACKT-">iterable</code>, such as an array.</li>
          <li class="Bullet-Within-Bullet--PACKT-">A <code class="Code-In-Text--PACKT-">callback</code>, which will receive as the input each item of the iterable (exactly like in the original <code class="Code-In-Text--PACKT-">Array.map()</code>) and can return either a <code class="Code-In-Text--PACKT-">Promise</code> or a simple value.</li>
          <li class="Bullet-Within-Bullet-End--PACKT-">A <code class="Code-In-Text--PACKT-">concurrency</code>, which defines how many items in the iterable can be processed by <code class="Code-In-Text--PACKT-">callback</code> in parallel at each given time.</li>
        </ul>
      </li>
    </ul>
  </div>
</body></html>