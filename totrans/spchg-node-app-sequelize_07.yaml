- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Handling Customized, JSON, and Blob Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理自定义、JSON和Blob数据类型
- en: Some database management systems offer a way of storing niche column types such
    as JSON and Blob-related data. These column types are useful for rapid prototyping,
    handling schemaless data, and sending and receiving buffered data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库管理系统提供了一种存储特定列类型（如JSON和Blob相关数据）的方法。这些列类型对于快速原型设计、处理无模式数据和发送接收缓冲数据非常有用。
- en: Typically, an application would use a **NoSQL** database, such as MongoDB, to
    process and query JSON documents, but this comes with a set of its own problems.
    We can no longer adhere to some sort of normalization for our structures without
    an extensive list of validations, and the NoSQL database cannot perform transactions
    nor provide ACID-compliant capabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序会使用**NoSQL**数据库，如MongoDB，来处理和查询JSON文档，但这带来了一系列自己的问题。如果没有详尽的验证列表，我们就不能再坚持某种形式的规范化结构，NoSQL数据库也无法执行事务或提供ACID兼容的功能。
- en: Note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some NoSQL databases claim to offer ACID compliance, but they often come with
    stipulations and limitations such as a maximum number of documents that can be
    updated in a single transaction, or a transaction cannot take longer than some
    temporal window; otherwise, you will lose all of the performance advantages of
    NoSQL over SQL databases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些NoSQL数据库声称提供ACID兼容性，但它们通常附带一些规定和限制，例如单次事务中可以更新的最大文档数，或者事务不能超过某个时间窗口；否则，您将失去NoSQL数据库相对于SQL数据库的所有性能优势。
- en: There are several use cases for JSON and Blob column data types. With JSON,
    you can store a record set of non-deterministic values, which is great for use
    cases such as creating receipts of transactions and auditing systems. A Blob column
    data type can store any file that helps centralize retrieving and inserting from
    one location, but internally, the DBMS could shard or distribute that file.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和Blob列数据类型有几种用例。使用JSON，您可以存储一组非确定性的值记录集，这对于创建交易收据和审计系统等用例非常有用。Blob列数据类型可以存储任何有助于集中检索和插入的文件，但内部，DBMS可能会对该文件进行分片或分发。
- en: Usually, it is not recommended to store files within a DBMS due to losing external
    access control lists, clogging Write-Ahead log files, and a false sense of security
    for storing those files. We could also run into increased page sizes, which would
    increase the time it takes to retrieve records. As a general rule, for quick prototyping
    of handling files, using a DBMS is fine but not for a production environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，由于失去外部访问控制列表、阻塞写前日志文件以及存储这些文件时的虚假安全感，我们不推荐在DBMS中存储文件。我们还可能遇到页面大小增加的情况，这将增加检索记录所需的时间。一般来说，对于快速原型设计处理文件，使用DBMS是可以的，但不适用于生产环境。
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An example of using a JSON column type for auditing would be PGAudit’s Postgres
    extension. This extension will convert the previous and new record sets as JSON
    data types for storing differentiating values. You may refer to [https://www.pgaudit.org/](https://www.pgaudit.org/)
    for more information on how this works.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON列类型进行审计的一个例子是PGAudit的Postgres扩展。此扩展将转换之前的和新的记录集为JSON数据类型以存储不同的值。您可以参考[https://www.pgaudit.org/](https://www.pgaudit.org/)了解更多关于其工作原理的信息。
- en: Sequelize is capable of handling custom and Blob types for all supported DBMSs,
    and JSON column types for SQLite, MySQL, MariaDB, and PostgreSQL only. There is
    a workaround for MSSQL, which will be explained in detail under the *Working with
    JSON* section of this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize能够处理所有支持DBMS的自定义和Blob类型，以及SQLite、MySQL、MariaDB和PostgreSQL的JSON列类型。对于MSSQL有一个解决方案，将在本章的*与JSON一起工作*部分详细解释。
- en: 'In this chapter, we will cover the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Querying JSON and JSONB data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询JSON和JSONB数据
- en: Using the `BLOB` column type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BLOB`列类型
- en: Creating custom data types
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义数据类型
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files of this chapter at [https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch7](https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch7).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch7](https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch7)找到本章的代码文件。
- en: Querying JSON and JSONB data
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询JSON和JSONB数据
- en: As stated previously, JSON column types are only available for SQLite, MySQL,
    MariaDB, and PostgreSQL. The JSONB column is only supported on the PostgreSQL
    DBMS. The difference between the two column types is that JSONB will store additional
    information related to the fields within the JSON document internally. This will
    increase the requirements for disk space but will help make querying the data
    quicker.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JSON 列类型仅适用于 SQLite、MySQL、MariaDB 和 PostgreSQL。JSONB 列类型仅支持 PostgreSQL
    数据库管理系统。这两种列类型之间的区别在于，JSONB 将在内部存储与 JSON 文档中的字段相关的附加信息。这将增加磁盘空间的需求，但将有助于使数据查询更快。
- en: 'For this section, presume that we have the following model within our application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，假设我们在应用程序中有一个以下模型：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can create our document:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的文档：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now query for our document using the traditional Sequelize methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用传统的 Sequelize 方法查询我们的文档：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or we can use a special dot-notation style:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用特殊的点符号风格：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The dot-notation method will also work on other finder attributes such as `order`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 点符号方法也适用于其他查找属性，例如 `order`：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We would have to re-insert the entire document like traditional NoSQL document
    storage systems when updating records:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新记录时，我们必须像传统的 NoSQL 文档存储系统一样重新插入整个文档：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we wanted to query for a value within an array, we may need to use the `Sequelize.literal`
    function if our DBMS does not natively support the `Op.contains` operator (PostgreSQL
    only). The following is an example of how to query an array’s value with PostgreSQL’s
    `@>` operator:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要查询数组中的值，我们可能需要使用 `Sequelize.literal` 函数，如果我们的数据库管理系统没有本地支持 `Op.contains`
    操作符（仅 PostgreSQL）。以下是一个使用 PostgreSQL 的 `@>` 操作符查询数组值的示例：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since MySQL does not support a `contains` operator, the equivalent of the previous
    query would look like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MySQL 不支持 `contains` 操作符，上一个查询的等效操作如下：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'MSSQL can also perform basic operations for JSON. The following is an example
    of how to query JSON data with MSSQL and Sequelize:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: MSSQL 也可以执行 JSON 的基本操作。以下是一个使用 MSSQL 和 Sequelize 查询 JSON 数据的示例：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unfortunately for MSSQL, to search through nested arrays would require a cross-join
    and a few more topics that are out of this book’s scope, such as OpenJSON (which
    can be referenced at [https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql?view=sql-server-ver15)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于 MSSQL，要搜索嵌套数组需要交叉连接和更多超出本书范围的主题，例如 OpenJSON（可以在 [https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql?view=sql-server-ver15)
    中参考）。
- en: Using the BLOB column type
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BLOB 列类型
- en: 'Sometimes, our application will require us to store buffer or binary data in
    our system. The following is a quick example of how to create and read binary
    data with Sequelize:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的应用程序将需要我们存储缓冲区或二进制数据到我们的系统中。以下是一个使用 Sequelize 创建和读取二进制数据的快速示例：
- en: 'We will start with our definition:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从我们的定义开始：
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we can insert our record, like so:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以插入我们的记录，如下所示：
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To retrieve and use the buffered data, we can simply use a finder method and
    write directly using Node.js’ `fs` module:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检索和使用缓冲数据，我们可以简单地使用查找方法，并直接使用 Node.js 的 `fs` 模块写入：
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have gone through all of the built-in data types, we can now begin
    creating our own custom data type. Custom data types can also be useful for just
    extending several validations together or creating several rulesets into one data
    type.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了所有内置的数据类型，我们现在可以开始创建我们自己的自定义数据类型。自定义数据类型也可以用于将几个验证组合在一起或创建几个规则集到一个数据类型中。
- en: Creating custom data types
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义数据类型
- en: 'Sequelize offers us a way to create custom types by extending the `DataTypes.ABSTRACT`
    abstraction class. This allows us to keep our code base more organized and consistent.
    Suppose our application required a lot of columns all abiding by the laws of natural
    numbers. A quick demonstration would look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 通过扩展 `DataTypes.ABSTRACT` 抽象类为我们提供了一种创建自定义类型的方法。这允许我们保持代码库更加有序和一致。假设我们的应用程序需要大量遵守自然数法则的列。一个快速演示如下：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we had hundreds of these columns, writing these columns out could be tiresome.
    A way to resolve this issue would be to create our own custom attribute. Let’s
    look at the steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有数百个这样的列，写出这些列可能会很繁琐。解决这个问题的方法之一是创建我们自己的自定义属性。让我们看看步骤：
- en: 'The first step is to extend the `ABSTRACT` class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是扩展 `ABSTRACT` 类：
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we will need to tell Sequelize how to translate this data type into a
    column type. We can do this by defining a `toSql` method within the class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要告诉 Sequelize 如何将此数据类型转换为列类型。我们可以在类中定义一个 `toSql` 方法来完成此操作：
- en: '[PRE14]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will tell Sequelize that we want a zero-filled and unsigned integer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 Sequelize 我们想要一个零填充的无符号整数。
- en: 'Next, we can enforce a validation rule by creating a `validate` method:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过创建一个 `validate` 方法来强制执行验证规则：
- en: '[PRE15]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sequelize will automatically check whether the value is an integer and above
    zero for this attribute type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 将自动检查此属性类型的值是否为整数且大于零。
- en: 'The next step is optional, but for completeness, the following methods are
    for writing and reading to and from the database, respectively:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个步骤是可选的，但为了完整性，以下方法分别用于写入和从数据库读取：
- en: '[PRE16]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `_stringify` method will convert the value into a string before sending
    it off to your database, and the `parse` method will transform the returned value
    from the database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`_stringify` 方法将在将值发送到您的数据库之前将其转换为字符串，而 `parse` 方法将转换从数据库返回的值。'
- en: 'Now, we can close our class and invoke some mandatory methods:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以关闭我们的类并调用一些强制性的方法：
- en: '[PRE17]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sequelize will identify your attribute’s data type by mapping out the `key`
    value from your class. The next line will add your custom data type to Sequelize’s
    `DataTypes` namespace. The `classToInvokable` method will simply wrap your class’s
    constructor and return a new instance so that you do not have to explicitly call
    `new DataTypes.NATURAL_NUMBER()` when defining your models.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 将通过映射出类中的 `key` 值来识别您的属性数据类型。下一行将添加您的自定义数据类型到 Sequelize 的 `DataTypes`
    命名空间。`classToInvokable` 方法将简单地包装您的类构造函数并返回一个新实例，这样您在定义模型时就不必显式调用 `new DataTypes.NATURAL_NUMBER()`。
- en: 'Now we can define our previous model, like so:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们之前的模型，如下所示：
- en: '[PRE18]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And when we go to create or update, our attributes will abide by the rules
    that we previously set. The following three examples will return a validation
    error due to the value of the `C` column not being a natural number:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们去创建或更新时，我们的属性将遵守我们之前设置的规则。以下三个示例将返回验证错误，因为 `C` 列的值不是一个自然数：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we change `C` to a natural number (as shown in the following code), our
    query will now successfully create the record:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `C` 改为一个自然数（如下面的代码所示）时，我们的查询现在将成功创建记录：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So far, we have gone over how to handle JSON and BLOB data types using Sequelize’s
    built-in classes. We also created our own custom data types by extending the Sequelize
    `ABSTRACT` data type class. Now, we can start using some of these data types in
    our project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何使用 Sequelize 内置类处理 JSON 和 BLOB 数据类型。我们还通过扩展 Sequelize 的 `ABSTRACT`
    数据类型类创建了自定义数据类型。现在，我们可以在我们的项目中开始使用这些数据类型。
- en: Now that we have a better understanding of how to handle JSON data types explicitly,
    we can start using that type in our Avalon Airlines project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何显式处理 JSON 数据类型有了更好的理解，我们可以在 Avalon Airlines 项目中使用该类型。
- en: Putting it all together
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'Our business partner just informed us that we want to be able to record transaction
    receipts for every applicable event. This could be for the boarding ticket, extra
    luggage, or an additional water bottle, which means there is no deterministic
    structure for our data. For this task, we will need to generate a new model, `Receipts`,
    and update our `BoardingTicket` model. Here are the steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的商业伙伴刚刚通知我们，我们希望能够记录每个适用事件的交易收据。这可能包括登机牌、额外行李或额外的水瓶，这意味着我们的数据没有确定的结构。为此任务，我们需要生成一个新的模型
    `Receipts` 并更新我们的 `BoardingTicket` 模型。以下是步骤：
- en: 'First, we can begin by generating a new model called `Receipts` for storing
    transaction events:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以开始生成一个新的模型，名为 `Receipts`，用于存储交易事件：
- en: '[PRE21]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, run our migration:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行我们的迁移：
- en: '[PRE22]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will want to add another life cycle event to our `BoardingTicket`
    model located in `models/boardingticket.js` by adding the following code at the
    end of the `module.exports` block:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望在 `models/boardingticket.js` 中的 `BoardingTicket` 模型中添加另一个生命周期事件，方法是在
    `module.exports` 块的末尾添加以下代码：
- en: '[PRE23]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That wraps up our changes to the Avalon Airlines project. We implemented a new
    model for storing receipt data using JSON, and we added a life cycle event after
    creating or updating the `BoardingTicket` model. This should complete the requirements
    for our next investor meeting.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对 Avalon Airlines 项目的更改。我们使用 JSON 实现了一个新的存储收据数据的模型，并在创建或更新 `BoardingTicket`
    模型后添加了一个生命周期事件。这应该完成我们下一次投资者会议的要求。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through different ways of reading and writing attributes
    with specific data types such as JSON and `BLOB`. We also learned how to create
    custom data types by extending the `ABSTRACT` class in order to create a more
    ergonomic code base that is easier to maintain overall.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用特定数据类型（如 JSON 和 `BLOB`）读取和写入属性的不同方法。我们还学习了如何通过扩展 `ABSTRACT` 类来创建自定义数据类型，以创建一个更易于维护的代码库。
- en: In the next chapter, we will be covering how to monitor and log queries from
    your application. The following chapter will also contain further instructions
    on completing the Avalon Airlines project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何监控和记录您应用程序的查询。下一章还将包含完成 Avalon 航空公司项目的进一步说明。
- en: Part 3 – Advanced Queries, Using Adapters, and Logging Queries
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分 – 高级查询、使用适配器和日志查询
- en: In this part, you will understand how to monitor and measure metrics for your
    application’s performance. You will use third-party applications that integrate
    with Sequelize and logging queries. You will also learn how to deploy your application
    to a cloud application platform.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，您将了解如何监控和衡量您应用程序的性能指标。您将使用与 Sequelize 和日志查询集成的第三方应用程序。您还将学习如何将您的应用程序部署到云应用程序平台。
- en: 'This part comprises the following chapters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 8*](B17841_08.xhtml#_idTextAnchor168), *Logging and Monitoring Your
    Application*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B17841_08.xhtml#_idTextAnchor168)，*记录和监控您的应用程序*'
- en: '[*Chapter 9*](B17841_09.xhtml#_idTextAnchor177), *Using and Creating Adapters*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B17841_09.xhtml#_idTextAnchor177)，*使用和创建适配器*'
- en: '[*Chapter 10*](B17841_10.xhtml#_idTextAnchor184), *Deploying a Sequelize Application*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B17841_10.xhtml#_idTextAnchor184)，*部署 Sequelize 应用*'
