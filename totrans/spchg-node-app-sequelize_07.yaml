- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Customized, JSON, and Blob Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some database management systems offer a way of storing niche column types such
    as JSON and Blob-related data. These column types are useful for rapid prototyping,
    handling schemaless data, and sending and receiving buffered data.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, an application would use a **NoSQL** database, such as MongoDB, to
    process and query JSON documents, but this comes with a set of its own problems.
    We can no longer adhere to some sort of normalization for our structures without
    an extensive list of validations, and the NoSQL database cannot perform transactions
    nor provide ACID-compliant capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some NoSQL databases claim to offer ACID compliance, but they often come with
    stipulations and limitations such as a maximum number of documents that can be
    updated in a single transaction, or a transaction cannot take longer than some
    temporal window; otherwise, you will lose all of the performance advantages of
    NoSQL over SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: There are several use cases for JSON and Blob column data types. With JSON,
    you can store a record set of non-deterministic values, which is great for use
    cases such as creating receipts of transactions and auditing systems. A Blob column
    data type can store any file that helps centralize retrieving and inserting from
    one location, but internally, the DBMS could shard or distribute that file.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, it is not recommended to store files within a DBMS due to losing external
    access control lists, clogging Write-Ahead log files, and a false sense of security
    for storing those files. We could also run into increased page sizes, which would
    increase the time it takes to retrieve records. As a general rule, for quick prototyping
    of handling files, using a DBMS is fine but not for a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An example of using a JSON column type for auditing would be PGAudit’s Postgres
    extension. This extension will convert the previous and new record sets as JSON
    data types for storing differentiating values. You may refer to [https://www.pgaudit.org/](https://www.pgaudit.org/)
    for more information on how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize is capable of handling custom and Blob types for all supported DBMSs,
    and JSON column types for SQLite, MySQL, MariaDB, and PostgreSQL only. There is
    a workaround for MSSQL, which will be explained in detail under the *Working with
    JSON* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Querying JSON and JSONB data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `BLOB` column type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files of this chapter at [https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch7](https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch7).
  prefs: []
  type: TYPE_NORMAL
- en: Querying JSON and JSONB data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated previously, JSON column types are only available for SQLite, MySQL,
    MariaDB, and PostgreSQL. The JSONB column is only supported on the PostgreSQL
    DBMS. The difference between the two column types is that JSONB will store additional
    information related to the fields within the JSON document internally. This will
    increase the requirements for disk space but will help make querying the data
    quicker.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this section, presume that we have the following model within our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create our document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now query for our document using the traditional Sequelize methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use a special dot-notation style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot-notation method will also work on other finder attributes such as `order`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We would have to re-insert the entire document like traditional NoSQL document
    storage systems when updating records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to query for a value within an array, we may need to use the `Sequelize.literal`
    function if our DBMS does not natively support the `Op.contains` operator (PostgreSQL
    only). The following is an example of how to query an array’s value with PostgreSQL’s
    `@>` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since MySQL does not support a `contains` operator, the equivalent of the previous
    query would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'MSSQL can also perform basic operations for JSON. The following is an example
    of how to query JSON data with MSSQL and Sequelize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately for MSSQL, to search through nested arrays would require a cross-join
    and a few more topics that are out of this book’s scope, such as OpenJSON (which
    can be referenced at [https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql?view=sql-server-ver15)).
  prefs: []
  type: TYPE_NORMAL
- en: Using the BLOB column type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, our application will require us to store buffer or binary data in
    our system. The following is a quick example of how to create and read binary
    data with Sequelize:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with our definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can insert our record, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To retrieve and use the buffered data, we can simply use a finder method and
    write directly using Node.js’ `fs` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have gone through all of the built-in data types, we can now begin
    creating our own custom data type. Custom data types can also be useful for just
    extending several validations together or creating several rulesets into one data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequelize offers us a way to create custom types by extending the `DataTypes.ABSTRACT`
    abstraction class. This allows us to keep our code base more organized and consistent.
    Suppose our application required a lot of columns all abiding by the laws of natural
    numbers. A quick demonstration would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had hundreds of these columns, writing these columns out could be tiresome.
    A way to resolve this issue would be to create our own custom attribute. Let’s
    look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to extend the `ABSTRACT` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will need to tell Sequelize how to translate this data type into a
    column type. We can do this by defining a `toSql` method within the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will tell Sequelize that we want a zero-filled and unsigned integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can enforce a validation rule by creating a `validate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sequelize will automatically check whether the value is an integer and above
    zero for this attribute type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is optional, but for completeness, the following methods are
    for writing and reading to and from the database, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `_stringify` method will convert the value into a string before sending
    it off to your database, and the `parse` method will transform the returned value
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can close our class and invoke some mandatory methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sequelize will identify your attribute’s data type by mapping out the `key`
    value from your class. The next line will add your custom data type to Sequelize’s
    `DataTypes` namespace. The `classToInvokable` method will simply wrap your class’s
    constructor and return a new instance so that you do not have to explicitly call
    `new DataTypes.NATURAL_NUMBER()` when defining your models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define our previous model, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And when we go to create or update, our attributes will abide by the rules
    that we previously set. The following three examples will return a validation
    error due to the value of the `C` column not being a natural number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we change `C` to a natural number (as shown in the following code), our
    query will now successfully create the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have gone over how to handle JSON and BLOB data types using Sequelize’s
    built-in classes. We also created our own custom data types by extending the Sequelize
    `ABSTRACT` data type class. Now, we can start using some of these data types in
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of how to handle JSON data types explicitly,
    we can start using that type in our Avalon Airlines project.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our business partner just informed us that we want to be able to record transaction
    receipts for every applicable event. This could be for the boarding ticket, extra
    luggage, or an additional water bottle, which means there is no deterministic
    structure for our data. For this task, we will need to generate a new model, `Receipts`,
    and update our `BoardingTicket` model. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can begin by generating a new model called `Receipts` for storing
    transaction events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, run our migration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will want to add another life cycle event to our `BoardingTicket`
    model located in `models/boardingticket.js` by adding the following code at the
    end of the `module.exports` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That wraps up our changes to the Avalon Airlines project. We implemented a new
    model for storing receipt data using JSON, and we added a life cycle event after
    creating or updating the `BoardingTicket` model. This should complete the requirements
    for our next investor meeting.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through different ways of reading and writing attributes
    with specific data types such as JSON and `BLOB`. We also learned how to create
    custom data types by extending the `ABSTRACT` class in order to create a more
    ergonomic code base that is easier to maintain overall.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be covering how to monitor and log queries from
    your application. The following chapter will also contain further instructions
    on completing the Avalon Airlines project.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 – Advanced Queries, Using Adapters, and Logging Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will understand how to monitor and measure metrics for your
    application’s performance. You will use third-party applications that integrate
    with Sequelize and logging queries. You will also learn how to deploy your application
    to a cloud application platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B17841_08.xhtml#_idTextAnchor168), *Logging and Monitoring Your
    Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B17841_09.xhtml#_idTextAnchor177), *Using and Creating Adapters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B17841_10.xhtml#_idTextAnchor184), *Deploying a Sequelize Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
