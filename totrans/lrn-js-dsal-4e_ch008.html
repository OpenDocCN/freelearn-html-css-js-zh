<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning JavaScript Data Structures and Algorithms - Fourth Edition</title>
<link rel="stylesheet" type="text/css" href="../override_v1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/><link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section id="sets" class="level1 pkt" data-number="8">
<h1 data-number="8">7 Sets</h1>
<p><strong>Before you begin: Join our book community on Discord</strong></p>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p>
<img style="width:10rem;" src="../media/file0.png" width="200" height="200"/>
</p>
<a href="https://packt.link/EarlyAccess/">https://packt.link/EarlyAccess/</a>
<p>Building on your knowledge of sequential data structures, this chapter introduces you to the unique world of <strong>sets</strong>, a collection that stores only distinct values. We will cover the fundamentals of creating sets, adding or removing elements, and efficiently checking for membership. We will then discover how to leverage the power of sets with mathematical operations like union, intersection, and difference. To make things even easier, we will explore JavaScript's built-in <code>Set</code> class, providing you with a convenient tool for working with sets directly. So, in this chapter, we will cover:</p>
<ul>
<li>Creating a Set class from scratch</li>
<li>Performing mathematical operations with a set</li>
<li>JavaScript native Set class</li>
<li>Exercises</li>
</ul>
<section id="the-set-data-structure" class="level2" data-number="8.1">
<h2 data-number="8.1">The set data structure</h2>
<p>A <strong>set</strong> is a fundamental concept in mathematics and computer science. It is an unordered collection of distinct items (elements). Think of it as a bag where you can put things in, but the order you put them in does not matter, and you cannot have duplicates.</p>
<p>Sets are a fundamental concept in mathematics and computer science, with numerous real-world applications across various fields.</p>
<p>Let's take a look at the mathematical concept of sets before we dive into the computer science implementation of it. In mathematics, a set is a collection of distinct objects. For example, we have a set of natural numbers, which consists of integer numbers greater than or equal to 0 - that is, N = {0, 1, 2, 3, 4, 5, 6, ...}. The list of the objects within the set is surrounded by {} (curly braces).</p>
<p>There is also the null set concept. A set with no element is called a <strong>null set</strong> or an <strong>empty set</strong>. An example would be a set of prime numbers between 24 and 29. Since there is no prime number (a natural number greater than 1 that has no positive divisors other than 1 and itself) between 24 and 29, the set will be empty. We will represent an empty set with { }.</p>
<p>In mathematics, a set also has some basic operations such as union, intersection, and difference. We will also cover these operations in this chapter.</p>
<p>In computer science for example, sets are used to model relationships between data and to perform operations like filtering, sorting, and searching. Sets are also extremely useful to remove duplicate elements from other collections such as lists.</p>
<p>You can also imagine a set as an array with no repeated elements and no concept of order.</p>
</section>
<section id="creating-the-myset-class" class="level2" data-number="8.2">
<h2 data-number="8.2">Creating the MySet class</h2>
<p>ECMAScript 2015 (ES6) introduced the native Set class to JavaScript, providing a built-in and efficient way to work with sets. However, understanding the underlying implementation of a set is crucial for grasping data structures and algorithms. We will delve into creating our own custom <code>MySet</code> class that mirrors the functionality of the native Set, but with additional features like union, intersection, and difference operations.</p>
<p>Our implementation will reside in the <code>src/07-set/set.js</code> file. We will start by defining the <code>MySet</code> class:</p>
<div class="C0-SHCodePACKT">
<pre><code>class MySet {
  #items = {};
  #size = 0;
} </code></pre>
</div>
<p>We chose the name <code>MySet</code> to avoid conflicts with the native <code>Set</code> class. We utilize an object (<code>{}</code>) instead of an array to store elements within the <code>#items</code> private property. The keys of this object represent the set's unique values, while the corresponding values can be anything (we will use true as a simple placeholder). This choice leverages the fact that JavaScript objects cannot have duplicate keys, naturally enforcing the uniqueness of set elements. Arrays could also be used, but they require additional logic to prevent duplicates and might have slightly slower lookups in some cases. In other languages, this data structure (using a hash table-like approach) is often referred to as a <strong>hash set</strong>. We will also keep track of the number of elements in the set with the property <code>size</code>.</p>
<p>Next, we need to declare the methods available for a set:</p>
<p>The <code>MySet</code> class will provide the following methods:</p>
<ul>
<li><code>add(value)</code>: adds a unique value to the set.</li>
<li><code>delete(value)</code>: removes the value from the set if it exists.</li>
<li><code>has(value)</code>: returns true if the element exists in the set and false otherwise.</li>
<li><code>clear()</code>: removes all the values from the set.</li>
<li><code>size()</code>: returns how many values the set contains.</li>
<li><code>values()</code>: returns an array of all the values of the set.</li>
<li><code>union(otherSet)</code>: combines two sets.</li>
<li><code>intersection(otherSet)</code>: finds common elements between the two sets.</li>
<li><code>difference(otherSet)</code>: finds elements unique to one set.</li>
</ul>
<p>We will implement each of these methods in detail in the following sections.</p>
<section id="finding-a-value-in-the-set" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1">Finding a value in the set</h3>
<p>The first method we implement in our custom <code>MySet</code> class is <code>has(value)</code>. This method plays a crucial role as a building block for other operations like adding and removing elements. It allows us to efficiently determine if a given value already exists within the set. Here is the implementation:</p>
<div class="C0-SHCodePACKT">
<pre><code>has(value) {
  return this.#items.hasOwnProperty(value);
}</code></pre>
</div>
<p>The method directly utilizes JavaScript's built-in <code>hasOwnProperty</code> function on the internal <code>#items</code> object. This is a highly optimized way to check if a specific key (representing the value) exists in the object.</p>
<p>The <code>hasOwnProperty</code> method provides constant time complexity (<em>O(1)</em>) on average, making it an extremely fast way to check for existence within the set. This efficiency is a key reason we often prefer using objects over arrays for set implementations in JavaScript.</p>
<p>And now that we have this method, we can proceed with the implementation of the methods for adding and removing values.</p>
</section>
<section id="adding-values-to-the-set" class="level3" data-number="8.2.2">
<h3 data-number="8.2.2">Adding values to the set</h3>
<p>Next, we will implement the add method in our custom <code>MySet</code> class. This method is responsible for inserting a new element into the set, but only if it's not already present (maintaining the set's uniqueness property) as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>add(value) {
  if (!this.has(value)) {
    this.#items[value] = true; // mark the value as present
    this.#size++;
    return true;
  }
  return false;
}</code></pre>
</div>
<p>We start by efficiently checking if the value already exists within the set using the <code>has(value)</code> method we implemented earlier. If the value is not already present, we insert it into the <code>#items</code> object. We use the <code>value</code> itself as the key and assign a value of <code>true</code> to it. This serves as a simple flag indicating that the value is part of the set. After a successful insertion, we increment the <code>#size</code> property to accurately reflect the new number of elements in the set.</p>
<p>We return <code>true</code> to signal that the value was successfully added (it was not already in the set). Otherwise, we return <code>false</code> to indicate that the value was not added because it was a duplicate.</p>
</section>
<section id="removing-and-clearing-all-values" class="level3" data-number="8.2.3">
<h3 data-number="8.2.3">Removing and clearing all values</h3>
<p>Next, we will implement the <code>delete</code> method as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>delete(value) {
  if (this.has(value)) {
    delete this.#items[value];
    this.#size--;
    return true;
  }
  return false;
}</code></pre>
</div>
<p>We start by checking if the specified value exists within the set using the previously implemented <code>has(value)</code> method. This ensures we only try to delete elements that are present. If the value is found, we use the <code>delete</code> operator to remove the corresponding key-value pair from the <code>#items</code> object. This directly eliminates the element from the set's internal storage. After a successful deletion, we decrease the <code>#size</code> property to maintain an accurate count of elements in the set.</p>
<p>We return <code>true</code> to signal that the value was successfully deleted from the set, and <code>false</code> to indicate that the value was not found in the set and therefore could not be deleted.</p>
<p>And if we want to remove all the elements from the set, we can use the <code>clear</code> method, as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>clear() {
  this.#items = {};
  this.#size = 0;
}</code></pre>
</div>
<p>We achieve a complete clearing of the set by directly reassigning the <code>#items</code> object to a new, empty object <code>{}</code>. This effectively discards all previous key-value pairs (representing the set's elements) and creates a fresh, empty container for future additions. And we also reset the <code>#size</code> property back to 0 to accurately reflect that the set now contains no elements.</p>
<p>This implementation is extremely efficient, as reassigning the <code>#items</code> object is a constant time operation (<em>O(1)</em>). The alternative of iterating and deleting each element individually would be much slower, especially for large sets. This is generally not recommended unless we have a specific reason to track which elements are being removed during the clear operation.</p>
</section>
<section id="retrieving-the-size-and-checking-if-it-is-empty" class="level3" data-number="8.2.4">
<h3 data-number="8.2.4">Retrieving the size and checking if it is empty</h3>
<p>The next method we will implement is the size method (technically a getter method) as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>  get size() {
    return this.#size;
  }</code></pre>
</div>
<p>This method simply returns the size property we are using to keep count.</p>
<p>If we weren't tracking the <code>#size</code> property, we could determine the size of the set by:</p>
<ol>
<li>Iterating over the keys (elements) of the <code>#items</code> object.</li>
<li>Incrementing a counter for each key encountered.</li>
</ol>
<p>Here is the code for this alternative approach:</p>
<div class="C0-SHCodePACKT">
<pre><code>getSizeWithoutSizeProperty() {
  let count = 0;
  for (const key in this.#items) {
    if (this.#items.hasOwnProperty(key)) {
      count++;
    }
  }
  return count;
}</code></pre>
</div>
<p>The code uses a <code>for...in</code> loop to iterate over the keys (which are the values of the set) in the <code>#items</code> object. Inside the loop, <code>hasOwnProperty</code> is used to ensure we are only counting properties that belong directly to the object (not inherited properties from the prototype chain).</p>
<p>This approach would be less efficient, especially for large sets, as it would involve iterating over all elements, resulting in a time complexity of <em>O(n)</em>, where <em>n</em> is the number of elements in the set</p>
<p>And to determine if the <code>MySet</code> is empty, we implement the <code>isEmpty()</code> method, following a pattern consistent with other data structures we have covered in this book:</p>
<div class="C0-SHCodePACKT">
<pre><code>isEmpty() {
  return this.#size === 0;
}</code></pre>
</div>
<p>This method directly compares the private <code>#size</code> property to 0. The property <code>#size</code> is meticulously maintained to always reflect the number of elements in the set.</p>
</section>
<section id="retrieving-all-the-values" class="level3" data-number="8.2.5">
<h3 data-number="8.2.5">Retrieving all the values</h3>
<p>To retrieve an array containing all the elements (values) within our <code>MySet</code>, we can implement the <code>values</code> method as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>values() {
  return Object.keys(this.#items);
}</code></pre>
</div>
<p>We can leverage the built-in <code>Object.keys()</code> method for a concise implementation. This built-in JavaScript method takes an object (in our case, <code>this.#items</code>) and returns an array containing all its enumerable property keys as strings. Remember, in our <code>MySet</code> implementation, we use the keys of the <code>#items</code> object to store the actual values that are added to the set.</p>
<p>Now that we have completed the implementation of our custom <code>MySet</code> data structure, let's explore how to put it into action!</p>
</section>
<section id="using-the-myset-class" class="level3" data-number="8.2.6">
<h3 data-number="8.2.6">Using the MySet class</h3>
<p>We will dive into practical examples that showcase the utility and flexibility of <code>MySet</code>, demonstrating how it can be used to efficiently manage collections of unique elements. Imagine we are building a blog or content management system where users can add tags (keywords) to their articles or posts. We want to ensure that each post has a list of unique tags, with no duplicates.</p>
<p>The source code for this example can be found in the file src/07-set/01-using-myset-class.js. Let's start by defining the article:</p>
<div class="C0-SHCodePACKT">
<pre><code>const MySet = require('./set');
const article = {
  title: 'The importance of data structures in programming',
  content: '...',
  tags: new MySet()  // using MySet to store tags
};</code></pre>
</div>
<p>Now, let's add some tags to our article:</p>
<div class="C0-SHCodePACKT">
<pre><code>article.tags.add('programming');
article.tags.add('data structures');
article.tags.add('algorithms');
article.tags.add('programming');</code></pre>
</div>
<p>Note that the first and last tags are duplicates. We can confirm if we have three tags in the set, meaning there are no duplicates:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log(article.tags.size);  // 3</code></pre>
</div>
<p>We can also use the <code>has</code> method to double check which tags are part of the article:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log(article.tags.has('data structures'));  // true
console.log(article.tags.has('algorithms'));  // true
console.log(article.tags.has('programming'));  // true
console.log(article.tags.has('javascript'));  // false</code></pre>
</div>
<p>We can also use the values method to retrieve all the tags:</p>
<div class="C0-SHCodePACKT">
<pre><code>console.log(article.tags.values()); 
// output: ['programming', 'data structures', 'algorithms']</code></pre>
</div>
<p>Now, let's say we want to remove the tag programming and add the tag JavaScript instead:</p>
<div class="C0-SHCodePACKT">
<pre><code>article.tags.delete('programming');
article.tags.add('JavaScript');
console.log(article.tags.values()); 
// output: ['data structures', 'algorithms', 'JavaScript']</code></pre>
</div>
<p>So, now we have a remarkably similar implementation of the Set class, as in ECMAScript 2015. But we can also enhance our implementation by adding some basic operations such as union, intersection, and difference.</p>
</section>
</section>
<section id="performing-mathematical-operations-with-a-set" class="level2" data-number="8.3">
<h2 data-number="8.3">Performing mathematical operations with a set</h2>
<p>Sets are a fundamental concept in mathematics with far-reaching applications in computer science, particularly within the realm of <strong>databases</strong>. Databases serve as the backbone of countless applications, and sets play a crucial role in their design and operation.</p>
<p>When we construct a query to retrieve data from a relational database (such as Oracle, Microsoft SQL Server, MySQL, etc.), we are essentially using set notation to define the desired result. The database, in turn, returns a set of data that matches our criteria.</p>
<p>SQL queries allow us to specify the scope of the data we want to retrieve. We can select all records from a table, or we can narrow down the search to a specific subset based on certain conditions. Furthermore, SQL leverages set operations to perform various types of data manipulation. The concept of <em>joins</em> in SQL is fundamentally based on set operations. Here are some common examples:</p>
<ul>
<li><strong>Union</strong>: combining data from two or more tables to create a new set containing all unique rows.</li>
<li><strong>Intersection</strong>: identifying rows that are common to multiple tables, resulting in a set containing only the shared data.</li>
<li><strong>Difference</strong> (Except/Minus): finding rows that exist in one table but not in another, creating a set of unique rows from the first table.</li>
</ul>
<p>And beyond the operations used in SQL, there are other essential set operations such as:</p>
<ul>
<li><strong>Subset</strong>: determining if one set is entirely contained within another set. This helps establish relationships between sets and can be useful for various logical and analytical tasks.</li>
</ul>
<p>Understanding sets and their operations is essential for working with databases and other data-intensive applications. The ability to manipulate sets effectively allows us to efficiently extract, filter, and analyze information from complex datasets. Let's see how we can simulate these operations using our <code>MySet</code> class.</p>
<section id="union-combining-two-sets" class="level3" data-number="8.3.1">
<h3 data-number="8.3.1">Union: combining two sets</h3>
<p>The union of two sets, A and B, is a new set that contains all the unique elements from both sets. It is like combining the contents of two bags into one larger bag, making sure not to put in any duplicates.</p>
<p>For example, consider we have two sets: A and B as follows:</p>
<ul>
<li>Set A = {1, 2, 3}</li>
<li>Set B = {3, 4, 5}</li>
<li>A ∪ B = {1, 2, 3, 4, 5}</li>
</ul>
<p>In this example, the value 3 appears in both sets, but it is only included once in the resulting union set because sets cannot contain duplicates.</p>
<p>The union of sets A and B is denoted by the symbol ∪. So, the union of A and B is written as A ∪ B in the mathematical notation. The following diagram exemplifies the union operation:</p>
<figure>
<img src="../media/file54.png" alt="The union operation of two sets, highlighting all the area of both sets" width="466" height="281"/><figcaption aria-hidden="true">The union operation of two sets, highlighting all the area of both sets</figcaption>
</figure>
<p>Now, let's implement the union method in our <code>MySet</code> class with the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>union(otherSet) {
  const unionSet = new MySet();
  this.values().forEach(value =&gt; unionSet.add(value));
  otherSet.values().forEach(value =&gt; unionSet.add(value));
  return unionSet;
}</code></pre>
</div>
<p>We need three steps to perform the union of two sets:</p>
<ol>
<li>Create a new empty set: this will be the set to hold the results of the union.</li>
<li>Iterate over the first set: add each element from the first set to the new set.</li>
<li>Iterate over the second set: add each element from the second set to the new set.</li>
</ol>
<p>When performing the add operation, it will evaluate if the value is duplicate or not, resulting in a new set containing all the unique elements from the original sets.</p>
<blockquote>
<p>It is important to note that the union, intersection, and difference methods we are implementing in this chapter do not modify the current instance of the <code>MySet</code> class nor the <code>otherSet</code> that is being passed as a parameter. Methods or functions that do not have collateral effects are called <strong>pure functions</strong>. A pure function does not modify the current instance nor the parameters; it only produces a new result.</p>
</blockquote>
<p>Let's see this in action. Suppose an online advertising platform wants to target users based on their interests, which are collected from various sources (for example: websites visited and social media activity). To be able to launch a campaign, we need:</p>
<ol>
<li>Collect sets of keywords representing interests from different sources.</li>
<li>Calculate the union of these sets to get a comprehensive list of user interests.</li>
<li>Use this combined set to match users with relevant advertisements.</li>
</ol>
<p>The following would be the code that would represent this logic. Let's first collect the interest from websites:</p>
<div class="C0-SHCodePACKT">
<pre><code>const interestsFromWebsites = new MySet();
interestsFromWebsites.addAll(['technology', 'politics', 'photography']);</code></pre>
</div>
<p>Next, let's collect the interested from social media:</p>
<div class="C0-SHCodePACKT">
<pre><code>const interestsFromSocialMedia = new MySet();
interestsFromSocialMedia.addAll(['technology', 'movies', 'books']);</code></pre>
</div>
<p>With both sources, we can calculate the union to have a list of all interests:</p>
<div class="C0-SHCodePACKT">
<pre><code>const allInterests = interestsFromWebsites.union(interestsFromSocialMedia);
console.log(allInterests.values()); 
// output: ['technology', 'politics', 'photography', 'movies', 'books']</code></pre>
</div>
<p>Now we can try to launch a successful campaign!</p>
<p>To facilitate our examples, we can also create a new method what will take an array of values as the input:</p>
<div class="C0-SHCodePACKT">
<pre><code>addAll(values) {
  values.forEach(value =&gt; this.add(value));
}</code></pre>
</div>
<p>This method will add each element individually so we can save some time during the next examples.</p>
</section>
<section id="intersection-identifying-common-values-in-two-sets" class="level3" data-number="8.3.2">
<h3 data-number="8.3.2">Intersection: identifying common values in two sets</h3>
<p>The intersection of two sets, A and B, is a new set that contains only the elements that are common to both sets. Think of it as finding the overlap between the contents of two bags.</p>
<p>For example, consider we have two sets: A and B as follows:</p>
<ul>
<li>Set A = {1, 2, 3, 4}</li>
<li>Set B = {3, 4, 5, 6}</li>
<li>A ∩ B = {3, 4}</li>
</ul>
<p>In this example, the values 3 and 4 are present in both sets, so they are included in the resulting intersection set.</p>
<p>The intersection of sets A and B is denoted by the symbol ∩. So, the intersection of A and B is written as A ∩ B. The following diagram exemplifies the intersection operation:</p>
<figure>
<img src="../media/file55.png" alt="The intersection operation of two sets, highlighting only the middle, which is the shared area of both sets" width="508" height="304"/><figcaption aria-hidden="true">The intersection operation of two sets, highlighting only the middle, which is the shared area of both sets</figcaption>
</figure>
<p>Now, let's implement the intersection method in our <code>MySet</code> class with the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>intersection(otherSet) {
  const intersectionSet = new MySet();
  this.values().forEach(value =&gt; {
    if (otherSet.has(value)) {
      intersectionSet.add(value);
    }
  });
  return intersectionSet;
}</code></pre>
</div>
<p>We need three steps to perform the intersection of two sets:</p>
<ol>
<li>Create a new empty set: this will be the set to hold the results of the intersection.</li>
<li>Iterate over the first set: for each element in the first set, check if it also exists in the second set.</li>
<li>Conditional addition: If the element is found in both sets, add it to the new set.</li>
</ol>
<p>Let's see this in action. Suppose a job platform wants to match candidates with job postings based on their skills. For this implementation we would need the following logic:</p>
<ol>
<li>Represent a candidate's skills and a job's required skills as sets.</li>
<li>Find the intersection of these sets to determine the skills that the candidate possesses, and the job requires.</li>
<li>Rank job postings based on the size of the intersection to show the most relevant jobs to the candidate.</li>
</ol>
<p>The following would be the code that would represent this logic. First, we will define the job postings available:</p>
<div class="C0-SHCodePACKT">
<pre><code>const job1Skills = new MySet();
job1Skills.addAll(['JavaScript', 'Angular', 'Java', 'SQL']);
const job2Skills = new MySet();
job2Skills.addAll(['Python', 'Machine Learning', 'SQL', 'Statistics']);
const jobPostings =
 [{
      title: 'Software Engineer',
      skills: job1Skills
  },
  {
      title: 'Data Scientist',
      skills: job2Skills
  }];</code></pre>
</div>
<p>The <code>jobPostings</code> variable is an array of job objects, each with a <code>title</code> and a <code>MySet</code> named skills containing the required skills for that job.</p>
<p>Next, we will define the candidate with the name and their skills:</p>
<div class="C0-SHCodePACKT">
<pre><code>const candidateSkills = new MySet();
candidateSkills.addAll(['JavaScript', 'Angular', 'TypeScript', 'AWS']);
const candidate = {
  name: 'Loiane',
  skills: candidateSkills
};</code></pre>
</div>
<p>The <code>candidate</code> is an object representing a job seeker with a name and a <code>MySet</code> named skills containing their skills.</p>
<p>Then, we can create a function that will calculate the best potential matches between the candidate and the job postings available:</p>
<div class="C0-SHCodePACKT">
<pre><code>function matchCandidateWithJobs(candidate, jobPostings) {
  const matches = [];
  for (const job of jobPostings) {
      const matchingSkillsSet = candidate.skills.intersection(job.skills);
      if (!matchingSkillsSet.isEmpty()) {
          matches.push({
              title: job.title,
              matchingSkills: matchingSkillsSet.values()
          });
      }
  }
  return matches;
}</code></pre>
</div>
<p>Here is an explanation of the <code>matchCandidateWithJobs</code> function:</p>
<ul>
<li>Takes the <code>candidate</code> and the <code>jobPostings</code> as input.</li>
<li>Initializes an empty array <code>matches </code>to store the matching jobs.</li>
<li>Iterates through each job in the <code>jobPostings</code> array.</li>
<li>For each job, it calculates the intersection of the candidate's skills and the job's required skills.</li>
<li>If the intersection set is not empty (meaning there are matching skills), the job title and the matching skills (as an array) are added to the <code>matches</code> array.</li>
<li>Finally, we return the matches array containing the job titles and their matching skills with the candidate.</li>
</ul>
<p>Putting all together:</p>
<div class="C0-SHCodePACKT">
<pre><code>const matchingJobs = matchCandidateWithJobs(candidate, jobPostings);
console.log(matchingJobs);
// output: [{ title: 'Software Engineer', matchingSkills: [ 'JavaScript', 'Angular' ] }]</code></pre>
</div>
<p>We get the output that the best job posting for this candidate would be the Software Engineer job because the candidate also has JavaScript and Angular skills.</p>
<p>The intersection logic we created works perfectly, however, there is an improvement we can make.</p>
<section id="improving-the-intersection-logic" class="level4" data-number="8.3.2.1">
<h4 data-number="8.3.2.1">Improving the intersection logic</h4>
<p>Consider the following scenario:</p>
<ul>
<li>Set A contains values: {1, 2, 3, 4, 5, 6, 7}</li>
<li>Set B contains values: {4, 6}</li>
</ul>
<p>In our initial intersection method, we would iterate through all seven elements of Set A and check for their presence in Set B. However, a more efficient approach exists.</p>
<p>We can optimize the intersection method by iterating over the <em>smaller</em> of the two sets. This significantly reduces the number of iterations and comparisons needed when one set is considerably smaller than the other. The optimized code is presented as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>intersection(otherSet) {
  const intersectionSet = new MySet();
  const [smallerSet, largerSet] = this.size &lt;= otherSet.size ? [this, otherSet] : [otherSet, this];
  smallerSet.values().forEach(value =&gt; {
    if (largerSet.has(value)) {
      intersectionSet.add(value);
    }
  });
  return intersectionSet;
}</code></pre>
</div>
<p>We use a concise ternary expression to determine which set has fewer elements: <code>this.size &lt;= otherSet.size ? [this, otherSet] : [otherSet, this]</code>. This assigns the smaller set to <code>smallerSet</code> and the larger set to <code>largerSet</code>. Then, we iterate over the <code>values()</code> of the <code>smallerSet</code>. This immediately reduces the number of loop iterations to the size of the smaller set.</p>
<p>In cases where one set is much smaller than the other, this optimization significantly reduces the number of iterations and comparisons, leading to faster execution time. And the overall performance of the intersection operation is enhanced, especially for scenarios with large set size disparities.</p>
</section>
</section>
<section id="difference-between-two-sets" class="level3" data-number="8.3.3">
<h3 data-number="8.3.3">Difference between two sets</h3>
<p>The difference between two sets, A and B (denoted as A - B or A \ B), is a new set that contains all the elements of A that are not present in B. In other words, it is the set of elements that are unique to set A.</p>
<p>For example, consider we have two sets: A and B as follows:</p>
<ul>
<li>Set A = {1, 2, 3, 4}</li>
<li>Set B = {3, 4, 5, 6}</li>
<li>A - B = {1, 2}</li>
<li>B - A = {5, 6}</li>
</ul>
<p>In this example, A - B results in the set {1, 2} because these elements are in A but not in B. Similarly, B - A results in {5, 6}.</p>
<p>The difference of sets A and B is written as:</p>
<ul>
<li>A - B (sometimes read as <em>A minus B</em>)</li>
<li>A \ B</li>
</ul>
<p>The following diagram exemplifies the difference operation of A - B:</p>
<figure>
<img src="../media/file56.png" alt="The difference operation of two sets A - B, highlighting only the area of A not common to B" width="497" height="304"/><figcaption aria-hidden="true">The difference operation of two sets A - B, highlighting only the area of A not common to B</figcaption>
</figure>
<p>Now, let's implement the difference method in our <code>MySet</code> class with the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>difference(otherSet) {
  const differenceSet = new MySet();
  this.values().forEach(value =&gt; {
    if (!otherSet.has(value)) {
      differenceSet.add(value);
    }
  });
  return differenceSet;
}</code></pre>
</div>
<p>We need three steps to perform the difference of two sets:</p>
<ol>
<li>Create a new empty set: this will hold the result of the difference.</li>
<li>Iterate over the first set: for each element in the first set, check if it exists in the second set.</li>
<li>Conditional addition: if the element is <em>not</em> found in the second set, add it to the new set.</li>
</ol>
<p>Let's see this in action. Suppose we are running an online store with a list of subscribers who receive promotional emails. We have segmented the subscribers based on their interests (books, fashion, technology). We want to send a targeted email campaign about books, but we want to exclude subscribers who have already shown interest in these books.</p>
<p>So, let's start by declaring all the sets we need for this scenario:</p>
<div class="C0-SHCodePACKT">
<pre><code>const allSubscribers = new MySet();
allSubscribers.addAll(['Aelin', 'Rowan', 'Xaden', 'Poppy', 'Violet']);
const booksInterested = new MySet();
booksInterested.addAll(['Aelin', 'Poppy', 'Violet']);
const alreadyPurchasedBooks = new MySet();
alreadyPurchasedBooks.addAll(['Poppy']);</code></pre>
</div>
<p>We have three sets:</p>
<ul>
<li><code>allSubscribers</code>: a set of all email subscribers.</li>
<li><code>booksInterested</code>: a set of subscribers who have expressed interest in the books.</li>
<li><code>alreadyPurchasedBooks</code>: a set of subscribers who have already purchased books.</li>
</ul>
<p>Next, we will find the subscribers interested in books, but have not purchased yet:</p>
<div class="C0-SHCodePACKT">
<pre><code>const targetSubscribers = booksInterested.difference(alreadyPurchasedBooks);</code></pre>
</div>
<p>We use <code>booksInterested.difference(alreadyPurchasedBooks)</code> to find the subscribers who are interested in books but have not yet made a purchase in that category. This gives us the <code>targetSubscribers</code> set.</p>
<p>And finally, we will send the email to the target subscribers:</p>
<div class="C0-SHCodePACKT">
<pre><code>targetSubscribers.values().forEach(subscriber =&gt; {
  sendEmail(subscriber, 'New books you will love!');
});
function sendEmail(subscriber, message) {
  console.log(`Sending email to ${subscriber}: ${message}`);
}</code></pre>
</div>
<p>And the output we will get is:</p>
<div class="C0-SHCodePACKT">
<pre><code>Sending email to Aelin: New books you will love!
Sending email to Violet: New books you will love!</code></pre>
</div>
<p>We only have one last operation to cover: subsets</p>
</section>
<section id="subset-checking-if-a-set-contains-all-the-values" class="level3" data-number="8.3.4">
<h3 data-number="8.3.4">Subset: checking if a set contains all the values</h3>
<p>A set A is a subset of another set B if every element of A is also an element of B. In simpler terms, A is completely contained within B.</p>
<p>For example, consider we have two sets: A and B as follows:</p>
<ul>
<li>Set A = {1, 2}</li>
<li>Set B = {1, 2, 3, 4}</li>
<li>A ⊆ B</li>
</ul>
<p>In this example, A is a subset of B because every element in A is also in B.</p>
<p>The subset relationship is denoted by the symbol ⊆. So, if A is a subset of B, we write: A ⊆ B. The following diagram exemplifies the subset relationship:</p>
<figure>
<img src="../media/file57.png" alt="A is a subset of B because element in A is also in B" width="374" height="355"/><figcaption aria-hidden="true">A is a subset of B because element in A is also in B</figcaption>
</figure>
<p>Now, let's implement the <code>isSubsetOf</code> method in our <code>MySet</code> class with the following code:</p>
<div class="C0-SHCodePACKT">
<pre><code>isSubsetOf(otherSet) {
  if (this.size &gt; otherSet.size) {
    return false;
  }
  return this.values().every(value =&gt; otherSet.has(value));
}</code></pre>
</div>
<p>We start by checking if the size of the current set (<code>this.size</code>) is greater than the size of the <code>otherSet</code>. If it is, we know immediately that the current set cannot be a subset of <code>otherSet</code> because a subset cannot have more elements than the set it is a part of. In this case, the method returns <code>false</code> early, saving unnecessary further checks.</p>
<p>If the size check passes, we call <code>this.values()</code> to get an array of all the values in the current set. Then, we use the <code>every()</code> method on this array to check if the other set has the value from the current set. If every value in the current set is also found in <code>otherSet</code>, then the <code>every()</code> method returns <code>true</code> (meaning the current set is a subset). If even a single value in the current set is not found in <code>otherSet</code>, <code>every()</code> returns <code>false</code> (meaning it's not a subset).</p>
<p>Let's see this in action. Imagine we are developing a recipe app with a large database of recipes. Each recipe has a set of ingredients. Users can filter the recipes based on the ingredients they have available.</p>
<p>We will start by declaring the sets that store the ingredients of our recipes:</p>
<div class="C0-SHCodePACKT">
<pre><code>const chickenIngredients = new MySet()
chickenIngredients.addAll(['chicken', 'tomato', 'onion', 'garlic', 'ginger', 'spices']);
const spaghettiIngredients = new MySet();
spaghettiIngredients.addAll(['spaghetti', 'eggs', 'bacon', 'parmesan', 'pepper']);</code></pre>
</div>
<p>Next, we will declare the recipes along with the ingredients:</p>
<div class="C0-SHCodePACKT">
<pre><code>const recipes =
[{
      name: 'Chicken Tikka Masala',
      ingredients: chickenIngredients
  },
  {
      name: 'Spaghetti Carbonara',
      ingredients: spaghettiIngredients
  }];</code></pre>
</div>
<p>The <code>recipes</code> variable is an array of recipe objects, each with a name and a <code>MySet</code> named ingredients representing the ingredients required for that recipe.</p>
<p>Then, we also need a set with the list of ingredients we have available:</p>
<div class="C0-SHCodePACKT">
<pre><code>const userIngredients = new MySet();
userIngredients.addAll(['chicken', 'onion', 'garlic', 'ginger']);</code></pre>
</div>
<p>The next step would be the logic to check if we have a recipe that matches our ingredients:</p>
<div class="C0-SHCodePACKT">
<pre><code>function filterRecipes(recipes, userIngredients) {
  const filteredRecipes = [];
  for (const recipe of recipes) {
      if (userIngredients.isSubsetOf(recipe.ingredients)) {
          filteredRecipes.push({ name: recipe.name });
      }
  }
  return filteredRecipes;
}</code></pre>
</div>
<p>Here is an explanation of the <code>filterRecipes</code> function:</p>
<ul>
<li>Takes the <code>recipes</code> and <code>userIngredients</code> as input.</li>
<li>Initializes an empty array <code>filteredRecipes</code> to store the matching recipe names.</li>
<li>Iterates over each recipe in the recipes array.</li>
<li>For each recipe, it checks if <code>recipe.ingredients.isSubsetOf(userIngredients)</code>. If <code>true</code> (meaning all the recipe's ingredients are present in the user's ingredients), the recipe's name is added to <code>filteredRecipes</code>.</li>
<li>Returns the <code>filteredRecipes</code> array.</li>
</ul>
<p>And finally, putting all together:</p>
<div class="C0-SHCodePACKT">
<pre><code>const matchingRecipes = filterRecipes(recipes, userIngredients);
console.log(matchingRecipes);</code></pre>
</div>
<p>We will get the following output:</p>
<div class="C0-SHCodePACKT">
<pre><code>[ { name: 'Chicken Tikka Masala' } ]</code></pre>
</div>
<blockquote>
<p>We can also implement the isSupersetOf method, which would check if the current set A is a superset of another set B if every element of B is also an element of A. In simpler terms, B is completely contained within A. Try it, and you can find the source code within the <code>MySet</code> class when you download the source code of this book.</p>
</blockquote>
<p>Now that we have added some additional logic to the <code>MySet</code> class, let's check how the native JavaScript Set class works.</p>
</section>
</section>
<section id="the-javascript-set-class" class="level2" data-number="8.4">
<h2 data-number="8.4">The JavaScript Set class</h2>
<p>Let's dive into the native Set class introduced in ECMAScript 2015 (ES6) and explore how to use it effectively.</p>
<p>The Set class provides a built-in, efficient way to work with sets in JavaScript. It offers all the fundamental set operations and is optimized for performance.</p>
<p>Now, let's look at the methods and features available in the native Set class:</p>
<ul>
<li>Two constructors:
<ul>
<li><code>new Set()</code>: creates an empty Set.</li>
<li><code>new Set(iterable)</code>: creates a Set from an iterable object (for example, an array).</li>
</ul></li>
<li><code>add(value)</code>: adds a value to the set (if it is not already present). Returns the Set object itself for chaining.</li>
<li><code>delete(value)</code>: removes the specified value from the set. Returns <code>true</code> if the value was present and removed, otherwise <code>false</code>.</li>
<li><code>clear()</code>: removes all elements from the set.</li>
<li><code>has(value)</code>: returns <code>true</code> if the value exists in the set, otherwise <code>false</code>.</li>
<li>Different methods for iterating the set:
<ul>
<li><code>forEach(callbackFn)</code>: executes the provided <code>callbackFn</code> for each value in the set.</li>
<li><code>values()</code>: returns an iterator over the values of the set.</li>
<li><code>keys()</code>: alias for <code>values()</code>.</li>
<li><code>entries()</code>: Returns an iterator over <code>[value, value]</code> pairs (since keys and values are the same in a Set).</li>
</ul></li>
<li><code>size</code>: property that returns the number of elements in the set.</li>
</ul>
<p>If we would like to rewrite our example of the article and its tags, can we simply replace <code>MySet</code> with <code>Set</code> and the code would still work as follows:</p>
<div class="C0-SHCodePACKT">
<pre><code>const article = {
  title: 'The importance of data structures in programming',
  content: '...',
  tags: new Set() 
};
article.tags.add('programming');
article.tags.add('data structures');
article.tags.add('algorithms');
article.tags.add('programming');</code></pre>
</div>
<p>Given the Set class also has a constructor that accepts an array, we could simplify the previous code and pass the tags directly to the constructor:</p>
<div class="C0-SHCodePACKT">
<pre><code>const article = {
  title: 'The importance of data structures in programming',
  content: '...',
  tags: new Set(['programming', 'data structures', 'algorithms'])
};</code></pre>
</div>
<p>The other methods, such as delete, check the size, has and values would also work as expected.</p>
<p>Building our custom <code>MySet</code> class served as a valuable learning exercise, providing insights into the internal workings and mechanics of set data structures. While in everyday JavaScript development, we would likely use the efficient and convenient built-in Set class, the knowledge gained from implementing our own set empowers us to understand the underlying principles, make informed choices between built-in and custom solutions, and troubleshoot set-related issues more effectively.</p>
</section>
<section id="reviewing-the-efficiency-of-sets" class="level2" data-number="8.5">
<h2 data-number="8.5">Reviewing the efficiency of sets</h2>
<p>Let's review the efficiency of each method by reviewing the Big O notation in terms of time of execution:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>MySet</strong></td>
<td><strong>Set</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr class="even">
<td><code>add(value)</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>Constant time insertion into the object or underlying data structure.</td>
</tr>
<tr class="odd">
<td><code>addAll(values)</code></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td>Calls <code>add(value)</code> for each value in the input array, where <em>n</em> is the size of the array.</td>
</tr>
<tr class="even">
<td><code>delete(value)</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>Constant time deletion from the object or underlying data structure.</td>
</tr>
<tr class="odd">
<td><code>has(value)</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>Object lookup in both cases has constant time</td>
</tr>
<tr class="even">
<td><code>values()</code></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td>In <code>MySet</code> , it iterates over the object's keys. In <code>Set</code> , it creates an iterator that yields each value in linear time.</td>
</tr>
<tr class="odd">
<td><code>size (getter)</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>Returns the value of the <code>#size</code> property or equivalent in the native Set.</td>
</tr>
<tr class="even">
<td><code>isEmpty()</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>Checks if <code>#size</code> is 0.</td>
</tr>
<tr class="odd">
<td><code>values()</code></td>
<td><em>O(n)</em></td>
<td><em>O(n)</em></td>
<td>In <code>MySet</code> , it iterates over the object's keys. In <code>Set</code> , it creates an iterator that yields each value in linear time.</td>
</tr>
<tr class="even">
<td><code>clear()</code></td>
<td><em>O(1)</em></td>
<td><em>O(1)</em></td>
<td>Reassigns the <code>#items</code> object to an empty object and resets <code>#size</code> .</td>
</tr>
</tbody>
</table>
<p>The overall space complexity of sets is considered O(n), where n is the number of unique elements stored in the set. This means that the memory used by a set data structure increases linearly with the number of elements it contains.</p>
<p>Reviewing the time complexity, adding, removing values, and checking if a value exists in a set have constant time. One might ask why not always use sets instead of arrays or lists? While sets excel at specific tasks, there are a few reasons why we would not always choose them over arrays or lists:</p>
<ul>
<li>If the order of the elements is crucial, arrays are the way to go. Sets do not guarantee any specific order of elements.</li>
<li>If we frequently need to access elements by their position (for example, getting the third item in a list), arrays are much faster due to their direct indexing. Sets require iteration to find a specific element.</li>
<li>If the data naturally contains duplicates, and those duplicates are meaningful, then an array is the more appropriate choice.</li>
</ul>
<p>Let's put our knowledge into practice with some exercises.</p>
</section>
<section id="exercises-5" class="level2" data-number="8.6">
<h2 data-number="8.6">Exercises</h2>
<p>We will resolve one exercise from <strong>LeetCode</strong> using the set data structure to remove duplicate values from an array.</p>
<section id="remove-duplicates-from-sorted-array" class="level3" data-number="8.6.1">
<h3 data-number="8.6.1">Remove duplicates from sorted array</h3>
<p>The exercise we will resolve the is the <em>26. Remove Duplicates from Sorted Array</em> problem available at <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/">https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/</a>.</p>
<p>When resolving the problem using JavaScript or TypeScript, we will need to add our logic inside the function <code>function removeDuplicates(nums: number[]): number</code>, which receives an array of numbers and expects the number of unique elements within the array as a return. For our solution to be accepted, we also have to remove the duplicates from the <code>nums</code> array in-place, meaning we cannot simply assign a new reference to it.</p>
<p>Let's write the <code>removeDuplicates</code> function using a set data structure to easily remove the duplicates from the array:</p>
<div class="C0-SHCodePACKT">
<pre><code>export function removeDuplicates2(nums: number[]): number {
  const set = new Set(nums);
  const arr = Array.from(set);
  for (let i = 0; i &lt; arr.length; i++) {
    nums[i] = arr[i];
  }
  return arr.length;
}</code></pre>
</div>
<p>Here is an explanation of the solution:</p>
<p>We start by creating a new JavaScript Set object, initializing it with the values from the input array <code>nums</code>. Sets automatically store only unique values, so any duplicates in <code>nums</code> are eliminated.</p>
<p>Next, we convert the set back into a regular array <code>arr</code>. This new array contains only the unique elements from the original <code>nums</code> array, in sorted order. This step is required because we cannot access each set value directly, like an <code>array[i]</code>.</p>
<p>The for loop iterates through the <code>arr</code> (unique elements) array and copies each element back into the original <code>nums</code> array, overwriting any duplicate values that were present. Since <code>arr</code> is guaranteed to be shorter or equal in length to <code>nums</code>, we only need to iterate up to the length of arr. This step is a requirement as the problem judge will also check if the <code>nums</code> array was modified in-place.</p>
<p>Finally, the method returns arr.length, which is the number of unique elements in the original array. This is the expected output for the LeetCode problem.</p>
<p>The time complexity of this function is <em>O(n)</em>, where <em>n</em> is the number of values we have in the array <code>nums</code>. We are creating the set, adding all the elements (<em>O(n)</em>), we convert the set into an array (<em>O(n)</em>), and we also have a loop to overwrite the original array (<em>O(k)</em>, where <em>k</em> is the number of unique elements). Therefore, the overall time complexity is <em>O(n)</em>, as it is dominated by the linear-time operations of creating the set and converting it to an array.</p>
<p>The space complexity is <em>O(k)</em> because we are creating a set to store the unique elements. In the worst-case scenario where all elements are unique, it will store all <em>n</em> elements. However, in most cases, <em>k</em> (the number of unique elements) will be smaller than <em>n</em>. We also have the array <code>arr</code>, which stores only the unique elements, so its size is <em>k</em>. Therefore, the overall space complexity is <em>O(k)</em>, where <em>k</em> is the number of unique elements in the input array.</p>
<p>While the algorithm is correct and solves the problem, it is not the most <em>space-efficient</em> solution. We will resolve this same problem later in this book using a different technique. In the meantime, give it a try and try to solve this problem using <em>O(1)</em> space complexity.</p>
</section>
</section>
<section id="summary-6" class="level2" data-number="8.7">
<h2 data-number="8.7">Summary</h2>
<p>In this chapter, we delved into the inner workings of set data structures by implementing a custom <code>MySet</code> class. This hands-on approach mirrors the core functionality of the Set class introduced in ECMAScript 2015, giving you a deeper understanding of how sets operate under the hood. We also extended our exploration beyond the standard JavaScript Set by implementing additional methods like union, intersection, difference, and subset, enriching your toolkit for working with sets.</p>
<p>To put our newfound knowledge into practice, we tackled a real-world LeetCode problem, demonstrating the power of sets in solving algorithmic challenges.</p>
<p>In the next chapter, we will shift our focus to non-sequential data structures, specifically hashes and dictionaries. Get ready to discover how these versatile structures enable efficient data storage and retrieval based on key-value pairs!</p>
</section>
</section>
</div>
</div>
</body>
</html>