<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functional Programming with TypeScript</h1>
                </header>
            
            <article>
                
<p>JavaScript has been a multi-paradigm programming language since its inception back in 1995. It allows us to take advantage of an object-oriented programming style, but it also allows us to take advantage of a <strong>functional programming</strong> (<strong>FP</strong>) style. The same can be said about TypeScript. However, TypeScript is even better suited to FP than JavaScript because, as we will learn in this chapter, static type systems and type inference are very important in FP languages, such as the ML family of programming languages.</p>
<p>The JavaScript and TypeScript ecosystems have experienced a significant increase in interest in FP over the last 3 or 4 years. I believe that the cause of this increase in interest is the success of React. React is a library used to build user interfaces developed by Facebook, which is highly influenced by some core FP concepts.</p>
<p>We will learn more about React toward the end of this book, but, for now, we will focus on learning how to use some basic FP techniques with TypeScript on its own and with some small FP libraries such as <kbd>Immutable.js</kbd> and <kbd>Ramda</kbd>.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>Pure functions</li>
<li>Side effects</li>
<li>Immutability</li>
<li>Function arity</li>
<li>Higher-order functions</li>
<li>Function composition</li>
<li>Function partial application</li>
<li>Currying andÂ Pointfree style</li>
<li>Pipes and sequences</li>
<li>Category theory</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">FP concepts</h1>
                </header>
            
            <article>
                
<p>FP receives its name from the way we build applications when we use it as our preferred programming paradigm.</p>
<p>In a programming paradigm such as object-oriented programming, the main building blocks that we use to create an application are objects (objects are declared using classes). However, in FP we use functions as the main building block in our applications.</p>
<p>Each new programming paradigm introduces a series of concepts and ideas associated with it. Some of these concepts are universal and are also of interest while learning a different programming paradigm. In object-oriented programming, we have concepts such as inheritance, encapsulation, and polymorphism. In FP we have concepts such as higher-order functions, function partial application, immutability, and referential transparency. We will try to learn about some of these concepts in this chapter.</p>
<p>Michael Feathers, the author of the SOLID acronym and many other well-known software engineering principles, once wrote:</p>
<div class="packt_quote">"Object-oriented programming makes code understandable by encapsulating moving parts. Functional Programming makes code understandable by minimizing moving parts."</div>
<p>The preceding quote mentions <q>moving parts</q>; we should understand these moving parts as state changes (also known as state mutations). In object-oriented programming, we use encapsulation to prevent objects from being aware of the state mutations of other objects. In FP we try to avoid dealing with a mutable state instead of encapsulating it. FP reduces the number of places in which state changes take place within an application and tries to move these places into the boundaries of the application to try to keep application's core stateless.</p>
<p>A mutable state is bad because it makes the behavior of our code harder to predict. Take, for example, the following function:</p>
<pre>function isIndexPage() { <br/>   return window.location.pathname === "/"; <br/> }</pre>
<p>The preceding code snippet declared a function named <kbd>isIndexPage</kbd>. This function can be used to check whether the current page is the root page in a web application based on the current path.</p>
<p>The path is some data that changes all the time, so we can consider it a piece of state. If we try to predict the result of invoking the <kbd>isIndexPage</kbd>, we will need to know the current state. The problem is that we could wrongly assume that the state has not changed since the last known state. We can solve this problem by transforming the function into a pure function, as we will learn in the following section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pure functions</h1>
                </header>
            
            <article>
                
<p>FP introduces some concepts and principles that will help us to improve the predictability of our code. Let's look at one of these core concepts: <strong>pure functions</strong>.</p>
<p>A function can be considered pure when it returns a value computed using only the arguments passed to it. Also, a pure function avoids mutating its arguments or any other external variables. As a result, a pure function always returns the same value given the same arguments, independently of when it is invoked.</p>
<p>The <kbd>isIndexPage</kbd> function declared in the preceding section is not a pure function because it accesses the <kbd>pathname</kbd> variable and it has not been passed as an argument to the function. We can transform the preceding function into a pure function by rewriting it as follows:</p>
<pre>function isIndexPage(pathname: string) { <br/>   return pathname === "/"; <br/> }</pre>
<p>Even though this is a basic example, we can easily perceive that the newer version is much easier to predict. Pure functions help us to make our code easier to understand, maintain, and test.</p>
<p>Imagine that we wanted to write a unit test for the impure version of the <kbd>isIndexPage</kbd> function. We would encounter some problems when trying to test because the function uses the <kbd>window.location</kbd> object. We could overcome this issue using a mocking framework, but it would add a lot of complexity to our unit tests just because we didn't use a pure function.</p>
<p>On the other hand, testing the pure version of the <kbd>isIndexPage</kbd> function would be straightforward:</p>
<pre>function shouldReturnTrueWhenPathIsIndex(){ 
    let expected = true; 
    let result = isIndexPage("/"); 
    if (expected !== result) { 
        throw new Error(`Expected ${expected} to equals ${result}`); 
    } 
} 
 
function shouldReturnFalseWhenPathIsNotIndex() { 
    let expected = false; 
    let result = isIndexPage("/someotherpage"); 
    if (expected !== result) { 
        throw new Error(`Expected ${expected} to equals ${result}`); 
    } 
} </pre>
<p>Now that we understand how FP helps us to write better code by avoiding state mutations, we can learn about side effects and referential transparency.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Side effects</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we learned that a pure function returns a value that can be computed using only the arguments passed to it. A pure function also avoids mutating its arguments or any other external variable that is not passed to the function as an argument. In FP terminology, it is common to say that a pure function is a function that has no side effects. This means that when we invoke a pure function, we can expect that the function is not going to interfere (via a state mutation) with any other component in our application.</p>
<p>Some programming languages, such as Haskell, can ensure that an application is free of side effects using its type system. TypeScript has fantastic interoperability with JavaScript, but the downside of this, compared to a more isolated language such as Haskell, is that the type system is not able to guarantee that our application is free of side effects.</p>
<div class="packt_infobox">
<div>If you like the idea of your JavaScript applications being free of side effects, you can try open source projects such as <a href="https://github.com/bodil/eslint-config-cleanjs">https://github.com/bodil/eslint-config-cleanjs</a>. The project is an ESLint configuration that aims to restrict you to a subset of JavaScript that is as close to an idealized pure functional language as possible. Unfortunately, at the time of writing, there were no similar tools available that were specifically designed for TypeScript.</div>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Referential transparency</h1>
                </header>
            
            <article>
                
<p>Referential transparency is another concept closely related to pure functions and side effects. A function is pure when it is free of side effects. An expression is said to be referentially transparent when it can be replaced with its corresponding value without changing the application's behavior.</p>
<p>A pure function is a referentially transparent expression. An expression that is not referentially transparent is known as referentially opaque.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Immutability</h1>
                </header>
            
            <article>
                
<p>Immutability refers to the inability to change the value of a variable after a value has been assigned to it. Purely FP languages include immutable implementations of common data structures. For example, when we add an element to an array, we are mutating the original array. However, if we use an immutable array, and we try to add a new element to it, the original array will not be mutated, and we will add the new item to a copy of it.</p>
<p>In JavaScript and TypeScript, we can use the <kbd>Immutable.js</kbd> library to enjoy immutable data structures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions as first-class citizens</h1>
                </header>
            
            <article>
                
<p>It is common to find mentions of functions as <q>first-class citizens</q>Â in FP literature. We say that a function is a <q>"first-class citizen"</q>Â when it can do everything that a variable can do. This means that functions can be passed to other functions as an argument or to be returned by another function. Functions can also be assigned to variables. Both JavaScript and TypeScript treat functions as <q>"first-class citizens"</q>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lambda expressions</h1>
                </header>
            
            <article>
                
<p>Lambda expressions are just expressions that can be used to declare anonymous functions (functions without a name). Before the ES6 specification, the only way to assign a function as a value to a variable was using a function expression:</p>
<pre>const log = function(arg: any) { console.log(arg); }; </pre>
<p>The ES6 specification introduced the arrow function syntax:</p>
<pre>const log = (arg: any) =&gt; console.log(arg); </pre>
<div class="packt_infobox">Please refer to <a href="82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml">Chapter 3</a>, <em>Working with Functions</em>, and <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml">Chapter 6</a>, <em>Understanding the Runtime,</em>Â to learn more about arrow functions and function expressions.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function arity</h1>
                </header>
            
            <article>
                
<p>The arity of a function is the number of arguments that the function takes. A unary function is a function that only takes one argument:</p>
<pre>function isNull&lt;T&gt;(a: T|null) { 
    return (a === null); 
} </pre>
<p>Unary functions are very important in FP because they facilitate the usage of the function composition pattern.</p>
<div class="packt_infobox">We will learn more about the function composition pattern later in this chapter.</div>
<p>A <strong>binary function</strong> is a function that takes two arguments:</p>
<pre>function add(a: number, b: number) { 
    return a + b; 
} </pre>
<p>Functions with two or more arguments are also important because some of the most common FP patterns and techniques (for example, partial application and currying) have been designed to transform functions that allow multiple arguments into unary functions.</p>
<div class="packt_infobox">We will learn more about partial application and currying later in this chapter.</div>
<p>There are also functions with three (<strong>ternary function</strong>) or more arguments. However, functions that accept a variable number of arguments, known as <strong>variadic functions</strong>, are particularly interesting in FP:</p>
<pre>function addMany(...numbers: number[]) { 
    numbers.reduce((p, c) =&gt; p + c, 0); 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Higher-order functions</h1>
                </header>
            
            <article>
                
<p>A higher-order function is a function that does at least one of the following:</p>
<ul>
<li>Takes one or more functions as arguments</li>
<li>Returns a function as its result</li>
</ul>
<p>Higher-order functions are one of the most powerful tools that we can use to write JavaScript in an FP style. Let's see some examples.</p>
<p>The following code snippet declares a function named <kbd>addDelay</kbd>. The function creates a new function that waits a given number of microseconds before printing a message in the console. The function is considered a higher-order function because it takes a function as one of its arguments:</p>
<pre>function addDelay(msg: string, ms: number) { 
    return () =&gt; { 
        setTimeout(() =&gt; { 
            console.log(msg); 
        }, ms); 
    }; 
} 
 
const delayedSayHello = addDelay("Hello world!", 500); 
delayedSayHello(); // Prints "Hello world!" (after 500 ms) </pre>
<p>The following code snippet declares a function named <kbd>addDelay</kbd>. The function adds a delay in microseconds to the execution of another function that is passed as an argument. The function is considered a higher-order function because it returns a function:</p>
<pre class="mce-root">function addDelay(func: () =&gt; void, ms: number) {
    setTimeout(() =&gt; { 
        func(); 
    }, ms); 
} 
 
function sayHello() { 
    console.log("Hello world!"); 
} 
 
addDelay(sayHello, 500); // Prints "Hello world!" (after 500 ms) </pre>
<p>The following code snippet declares a function named <kbd>addDelay</kbd>. The function creates a new function that adds a delay in microseconds to the execution of another function that is passed as an argument. The function is considered a higher-order function because it takes a function as an argument and returns a function:</p>
<pre>function addDelay(func: () =&gt; void, ms: number) {
    return () =&gt; { 
        setTimeout(() =&gt; { 
            func(); 
        }, ms); 
    }; 
} 
 
function sayHello() { 
    console.log("Hello world!"); 
} 
 
const delayedSayHello = addDelay(sayHello, 500); 
delayedSayHello(); // Prints "Hello world!" (after 500 ms) </pre>
<p>Higher-order functions are an effective technique to abstract a solution for a common problem. The preceding example demonstrates how we can use a higher-order function (<kbd>addDelay</kbd>) to add a delay to another function (<kbd>sayHello</kbd>). This allows us to abstract the delay functionality and keep the <kbd>sayHello</kbd> function or other functions agnostic of the implementation details of the delay functionality.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The benefits of FP</h1>
                </header>
            
            <article>
                
<p>Writing TypeScript code using an FP style has many benefits, among which we can highlight the following:</p>
<ul>
<li><strong>Testable code</strong>: If we try to write our functions pure functions, we will be able to write unit tests extremely easily.</li>
<li><strong>Code is easy to reason about</strong>: FP can seem hard to understand for developers with a lack of experience in FP. However, when an application is implemented correctly using the FP paradigm, the results are very small functions (often one-line functions) and very declarative APIs that can be reasoned about with ease.</li>
<li><strong>Concurrency</strong>: Most of our functions are stateless, and our entities are mostly stateless. We push state out of the core of our application, which makes our applications much more likely to be able to support many concurrent operations and be more scalable.</li>
<li><strong>Caching</strong>: Strategies for caching results become much simpler when we can predict the output of a function given its arguments.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Is TypeScript a FP language?</h1>
                </header>
            
            <article>
                
<p>The answer to this question is yes, but only partially. TypeScript is a multi-paradigm programming language and, as a result, it includes many influences from both object-oriented programming languages and FP languages.</p>
<p>However, if we focus on TypeScript as an FP language, we can observe that it is not a purely FP language because, for example, the TypeScript compiler doesn't enforce our code to be free of side effects.</p>
<p>Not being a purely FP language should not be interpreted as something negative. TypeScript provides us with an extensive set of features and allows us to take advantage of some of the best features of both the world of object-oriented programming languages and the world of FP languages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">FP techniques</h1>
                </header>
            
            <article>
                
<p>Now that we have learned about the most common FP concepts, it is time to learn about the most common FP techniques and patterns.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composition</h1>
                </header>
            
            <article>
                
<p><strong>Functional composition</strong> is a technique or pattern that allows us to combine multiple functions to create a more complex function.</p>
<p>The following code snippet declares a function used to trim a string and a function used to transform a piece of text in uppercase text:</p>
<pre>const trim = (s: string) =&gt; s.trim();
const capitalize = (s: string) =&gt; s.toUpperCase(); </pre>
<p>We can create a function that performs both the preceding operations by composing them:</p>
<pre>    const trimAndCapitalize = (s: string) =&gt; capitalize(trim(s));</pre>
<p>The variable <kbd>trimAndCapitalize</kbd> is a function that invokes the <kbd>trim</kbd> function using <kbd>s</kbd> as its argument and passes its return to the <kbd>capitalize</kbd> function. We can invoke the <kbd>trimAndCapitalize</kbd> function as follows:</p>
<pre>trimAndCapitalize("   hello world   "); // "HELLO WORLD" </pre>
<p>The composition of two functions <kbd>f(x)</kbd> and <kbd>g(x)</kbd> is defined as <kbd>f(g(x))</kbd>, and that is exactly what we have done in the <kbd>trimAndCapitalize</kbd> function. However, such a behavior can be abstracted using a higher-order function:</p>
<pre>    const compose = &lt;T&gt;(f: (x: T) =&gt; T, g: (x: T) =&gt; T) =&gt; (x: T) =&gt; f(g(x));</pre>
<p>We can then use the preceding function to compose two given functions:</p>
<pre>    const trimAndCapitalize = compose(trim, capitalize);</pre>
<p>We can invoke the <kbd>trimAndCapitalize</kbd> function as follows:</p>
<pre>trimAndCapitalize("   hello world   "); // "HELLO WORLD" </pre>
<p>One important thing to note is that the result of the <kbd>g</kbd> function is passed as the argument of the <kbd>f</kbd> function. This means that <kbd>f</kbd> can only take one argument (it must be a unary function), and its type must match the return type of the <kbd>g</kbd> function. A more correct definition of the <kbd>compose</kbd> function would be something like the following:</p>
<pre>const compose = &lt;T1, T2, T3&gt;(
    f: (x: T2) =&gt; T3, 
    g: (x: T1) =&gt; T2 
) =&gt; (x: T1) =&gt; f(g(x)); </pre>
<p>We can also compose <kbd>composed</kbd> functions:</p>
<pre>const composed1 = compose(func1, func2); 
const composed2 = compose(func1, func2); 
const composed3 = compose(composed1, composed2); </pre>
<p>Alternatively, we can declare a higher-order function to compose three functions in one call:</p>
<pre>const compose3 = &lt;T1, T2, T3, T4&gt;( 
    f: (x: T3) =&gt; T4, 
    g: (x: T2) =&gt; T3, 
    h: (x: T1) =&gt; T2 
) =&gt; (x: T1) =&gt; f(g(h(x))); </pre>
<p>We can also create a helper that allows us to compose an unlimited number of functions:</p>
<pre>const compose = (...functions: Array&lt;(arg: any) =&gt; any&gt;) =&gt;
    (arg: any) =&gt; 
        functions.reduce((prev, curr) =&gt; { 
            return curr(prev); 
        }, arg); </pre>
<p>Functional composition is an extremely powerful technique, but it can be hard to put into practice in certain scenarios, for example, when our functions are not unary functions. However, there are other techniques that can help in those scenarios.</p>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partial application</h1>
                </header>
            
            <article>
                
<p><strong>Partial application</strong> is an FP technique that allows us to pass the arguments required by a function at different points in time.</p>
<p>This technique can feel like a weird idea at first glance because most software engineers are used to the idea of applying (also known as invoking) a function at one unique point in time (complete application), as opposed to applying a function at multiple points in time (partial application).</p>
<p>The following code snippet implements a function that doesn't support partial application and invokes it (providing all the required arguments) at one single point in time:</p>
<pre>function add(a: number, b: number) { 
    return a + b; 
} 
 
const result = add(5, 5); // All arguments are provided at the same time 
console.log(result); // 10 </pre>
<p>The following code snippet implements the preceding function as a higher-order function to allow us to provide the required arguments at different points in time:</p>
<pre>function add(a: number) {
    return (b: number) =&gt; { 
        return a + b; 
    }; 
} 
                           
const add5 = add(5); // The 1st argument is provided 
const result = add5(5); // The 2nd argument is provided later 
console.log(result); // 10 </pre>
<p>As we can see in the preceding code snippet, the first and the second arguments are provided at a different point in time. However, it cannot be considered an example of function partial application because the two functions are unary functions, and we have provided one argument at a time.</p>
<p>We can also write a function that allows both its complete and partial application:</p>
<pre>function add(a: number, b?: number) {
    if (b !== undefined) { 
        return a + b; 
    } else { 
        return (b2: number) =&gt; { 
            return a + b2; 
        }; 
    } 
} 
 
const result1 = add(5, 5); // All arguments are  
console.log(result1); // 10 
 
const add5 = add(5) as (b: number) =&gt; number; // The 1st passed 
const result2 = add5(5); // The 2nd argument is passed later 
console.log(result2); // 10 </pre>
<p>The preceding example can be considered an example of partial application because we can apply the function with all its arguments (complete application) or some of them (partial application).</p>
<p>Now that we know how function partial application works, let's focus on why it is useful. In the preceding <em>Composition</em> section, we learned how to compose two functions named <kbd>trim</kbd> and <kbd>capitalize</kbd> into a third function named <kbd>trimAndCapitalize</kbd>:</p>
<pre>const trim = (s: string) =&gt; s.trim();
const capitalize = (s: string) =&gt; s.toUpperCase(); 
const trimAndCapitalize = compose(trim, capitalize);</pre>
<p>Function composition works very well with unary functions but not so well with binary or ternary functions. We are going to declare the following function to demonstrate this:</p>
<pre>const replace = (s: string, f: string, r: string) =&gt; s.split(f).join(r); </pre>
<p>The preceding function can be used to replace a substring in given string. Unfortunately, the function cannot be used with compose with ease because it is not a unary function:</p>
<pre>const trimCapitalizeAndReplace = compose(trimAndCapitalize, replace); // Error </pre>
<p>However, we can implement the function in a way that allows us to apply the function partially:</p>
<pre>const replace = (f: string, r: string) =&gt;
(s: string) =&gt; 
s.split(f).join(r);  </pre>
<p>We can then use the compose function without problems:</p>
<pre>const trimCapitalizeAndReplace = compose( <br/>    trimAndCapitalize, <br/>    replace("/", "-") <br/>); <br/>trimCapitalizeAndReplace(" 13/feb/1989 "); &lt;// "13-FEB-1989" </pre>
<p>Thanks to our knowledge of function partial application, we can use compose with ease, without having to worry about the arity of the functions. However, enabling partial application requires a significant amount of manual boilerplate. In the next section, we will learn how an FP technique known as currying can help us to solve this problem.</p>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Currying</h1>
                </header>
            
            <article>
                
<p><strong>Currying</strong> is an FP technique that allows us to use partial application without having to worry about partial application while we write our functions. Currying is the process of taking a function that takes multiple arguments and transforming it into a chain of unary functions:</p>
<pre>function curry2&lt;T1, T2, T3&gt;(fn: (a: T1, b: T2) =&gt; T3) {
    return (a: T1) =&gt; (b: T2) =&gt; fn(a, b); 
} </pre>
<p>The preceding function is a higher-order function that allows us to abstract our functions from the partial application functionality:</p>
<pre>function add(a: number, b: number) { 
    return a + b; 
} 
 
const curriedAdd = curry2(add); 
const add5 = curriedAdd(5); 
const addResult = add5(5); 
console.log(addResult); // 10 </pre>
<p>The <kbd>curry2</kbd> function allows us to transform a binary function into two unary functions. The <kbd>curry2</kbd> function is a higher-order function and can be used with any binary function. For example, in the preceding code snippet, we passed the add function to the <kbd>curry2</kbd> function, but the following example passes the multiply function to the <kbd>curry2</kbd> function instead:</p>
<pre>function multiply(a: number, b: number) {
    return a * b; 
} 
 
const curriedMultiply = curry2(multiply);
const multiplyBy5 = curriedMultiply(5); 
const multiplyResult = multiplyBy5(5); 
console.log(multiplyResult); // 25 </pre>
<p>In the preceding <em>Partial application</em> section, we learned how to use partial application to use compose with functions that are not unary. We declared the following function named <kbd>replace</kbd> and then passed it to the <kbd>compose</kbd> function:</p>
<pre>const replace = (f: string, r: string) =&gt; 
    (s: string) =&gt; 
        s.split(f).join(r); 
 
const trimCapitalizeAndReplace = compose( 
    trimAndCapitalize, 
    replace("/", "-") 
); </pre>
<p>We can declare a function named <kbd>curry3</kbd> that transforms a ternary function into a chain of three unary functions:</p>
<pre>function curry3&lt;T1, T2, T3, T4&gt;(fn: (a: T1, b: T2, c: T3) =&gt; T4) { 
    return (a: T1) =&gt; (b: T2) =&gt; (c: T3) =&gt; fn(a, b, c); 
} </pre>
<p>We can then use the <kbd>curry3</kbd> function to rewrite the <kbd>replace</kbd> function in a way that is agnostic of the function partial application implementation details:</p>
<pre>const replace = (s: string, f: string, r: string) =&gt; 
    s.split(f).join(r); 
 
const curriedReplace = curry3(replace);
 
const trimCapitalizeAndReplace = compose( 
    trimAndCapitalize, 
    curriedReplace("/")("-") 
); </pre>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pipes</h1>
                </header>
            
            <article>
                
<p>A pipe is a function or operator that allows us to pass the output of a function as the input of another. JavaScript and TypeScript don't support piles natively (as an operator), but we can implement our pipes using the following function:</p>
<pre>const pipe = &lt;T&gt;(...fns: Array&lt;(arg: T) =&gt; T&gt;) =&gt;
    (value: T) =&gt; fns.reduce((acc, fn) =&gt; fn(acc), value); </pre>
<p>We are going to use the <kbd>curry3</kbd>, <kbd>trim</kbd>, <kbd>capitalize</kbd>, and <kbd>replace</kbd> functions that we declared previously in this chapter:</p>
<pre>const trim = (s: string) =&gt; s.trim(); 
const capitalize = (s: string) =&gt; s.toUpperCase(); 
 
const replace = curry3( 
    (s: string, f: string, r: string) =&gt; s.split(f).join(r) 
); </pre>
<p>We can then use the pipe function to declare a new function:</p>
<pre>const trimCapitalizeAndReplace = pipe( 
    trim, 
    capitalize, 
    replace("/")("-") 
); 
trimCapitalizeAndReplace("   13/feb/1989   "); // "13-FEB-1989" </pre>
<p>The <kbd>pipe</kbd> function ensures that the output of the <kbd>trim</kbd> function is passed to the <kbd>capitalize</kbd> function. The return of the <kbd>capitalize</kbd> function is then passed to the <kbd>replace</kbd> function, which has been already partially applied.</p>
<p>There is an official proposal to add a new operator to JavaScript known as the pipeline operator (|&gt;). This operator will allow us to implement a pipe as follows:</p>
<pre>const result = "   13/feb/1989   " 
  |&gt; trim 
  |&gt; capitalize 
  |&gt; replace("/")("-"); </pre>
<div class="packt_infobox">Please refer to the pipeline operator proposal:Â <a href="https://github.com/tc39/proposal-pipeline-operator">https://github.com/tc39/proposal-pipeline-operator</a>. Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pointfree style</h1>
                </header>
            
            <article>
                
<p>Tacit programming, also known as <strong>pointfree style</strong>, is a programming style in which function declarations do not declare the arguments (or <q>points</q>) on which they operate.</p>
<p>The following code snippet declares a few functions that are used to determine whether a person is eligible to vote in elections:</p>
<pre>interface Person { 
    age: number; 
    birthCountry: string; 
    naturalizationDate: Date; 
} 
 
const OUR_COUNTRY = "Ireland"; 
 
const wasBornInCountry = (person: Person) =&gt; 
    person.birthCountry === OUR_COUNTRY; 
 
const wasNaturalized = (person: Person) =&gt; 
    Boolean(person.naturalizationDate); 
 
const isOver18 = (person: Person) =&gt; 
    person.age &gt;= 18; 
 
const isCitizen = (person: Person) =&gt; 
    wasBornInCountry(person) || wasNaturalized(person); 
 
const isEligibleToVote = (person: Person) =&gt; 
    isOver18(person) &amp;&amp; isCitizen(person); 
 
isEligibleToVote({ 
    age: 27, 
    birthCountry: "Ireland", 
    naturalizationDate: new Date(), 
}); </pre>
<p>The preceding code snippet didn't use any of the FP techniques that we have already learned in this chapter. The following code snippet implements an alternative solution for the same problem, using techniques such as partial application. This code snippet declares two functions named <kbd>both</kbd> and <kbd>either</kbd> that can be used to determine whether a variable matches the requirements specified by some or both functions, provided to these functions:</p>
<pre>const either = &lt;T1&gt;(
    funcA: (a: T1) =&gt; boolean, 
    funcB: (a: T1) =&gt; boolean 
) =&gt; (arg: T1) =&gt; funcA(arg) || funcB(arg); 
 
const both = &lt;T1&gt;( 
    funcA: (a: T1) =&gt; boolean, 
    funcB: (a: T1) =&gt; boolean 
) =&gt; (arg: T1) =&gt; funcA(arg) &amp;&amp; funcB(arg); 
 
interface Person { 
    age: number; 
    birthCountry: string; 
    naturalizationDate: Date; 
} 
 
const OUR_COUNTRY = "Ireland";
 
const wasBornInCountry = (person: Person) =&gt; 
    person.birthCountry === OUR_COUNTRY; 
 
const wasNaturalized = (person: Person) =&gt; 
    Boolean(person.naturalizationDate); 
 
const isOver18 = (person: Person) =&gt; 
    person.age &gt;= 18; 
 
// Pointfree style 
const isCitizen = either(wasBornInCountry, wasNaturalized); 
const isEligibleToVote = both(isOver18, isCitizen); 
 
isEligibleToVote({ 
    age: 27, 
    birthCountry: "Ireland", 
    naturalizationDate: new Date(), 
}); </pre>
<p>As we can see, the functions <kbd>isCitizen</kbd> and <kbd>isEligibleToVote</kbd> take some functions as arguments, but they don't mention which data they expect as arguments. For example, we could write the following:</p>
<pre>const isCitizen = (person: Person) =&gt; 
    wasBornInCountry(person) || wasNaturalized(person); </pre>
<p>However, we could write the following instead:</p>
<pre>const isEligibleToVote = both(isOver18, isCitizen); </pre>
<p>This style, in which we avoid referencing the function arguments, is known as pointfree style, and it has some advantages over more conventional function declaration styles:</p>
<ul>
<li>It makes programs simpler and more concise. This isn't always a good thing, but it can be.</li>
<li>It makes algorithms easier to understand by focusing only on the functions being combined; we get a better sense of what's going on without the data arguments getting in the way.</li>
<li>It forces us to think more about the how the data is used than about which data is being used.</li>
<li>It helps us think about our functions as generic building blocks that can work with different kinds of data, rather than thinking about them as operations on a kind of data.</li>
</ul>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Recursion</h1>
                </header>
            
            <article>
                
<p>A function that calls itself is known as a <strong>recursive function</strong>. The following function is a recursive function that allows us to calculate the factorial of a given number <em>n</em>. The factorial is the product of all positive integers less than or equal to <em>n</em>:</p>
<pre>const factorial = (n: number): number =&gt; 
(n === 0) ? 1 : (n * factorial(n - 1)); </pre>
<p>We can invoke the preceding function as follows:</p>
<pre>factorial(5); // 120 </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Category theory</h1>
                </header>
            
            <article>
                
<p>FP has a reputation for being difficult to learn and understand because of its mathematical background. FP languages and design patterns are influenced by concepts that originated in many different mathematical fields. However, we can highlight <strong>category theory</strong> as one of the most significant fields of influence. We can think about category theory as an alternative to set theory, which defines the theory behind a series of data structures or objects known as <strong>algebraic data types</strong>.</p>
<p>There are many algebraic data types, and understanding all their properties and rules that they must implement requires a significant amount of time and effort. The following diagram illustrates the relationships between some of the most common algebraic data types:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/435b9b31-f36a-47ba-8301-2a4b400592b6.png" width="1198" height="347"/></div>
<p>The arrows in the diagram indicate that a given algebraic data type must implement the specification of some other algebraic data types. For example, the <kbd>Monad</kbd> type must implement the specifications of the <kbd>Applicative</kbd> and <kbd>Chain</kbd> types.</p>
<p>The open source project <kbd>fantasy<span>Â âÂ </span>land</kbd> declares a specification for some of these algebraic data types, while the open source project <kbd>ramda â fantasy</kbd> implements the specifications in a way that is compatible with <kbd>Ramda</kbd>, which is a popular FP library that we will explore later in this chapter.</p>
<p>The algebraic data type specifications can be implemented in many ways. For example, the fnctor specification can be implemented by a <kbd>Maybe</kbd> or an <kbd>Either</kbd> data type. Both types implement the <kbd>Functor</kbd> specification but can also implement other specifications, such as the monad or the applicative specification.</p>
<p>The following table describes which specifications (listed in the top row) are implemented by one of the algebraic data type implementations (left row) in the <kbd><span>ramda â fantasy</span></kbd>Â project:</p>
<table>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td><strong>Setoid</strong></td>
<td><strong>Semigroup</strong></td>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>Functor</strong></div>
</td>
<td><strong>Applicative</strong></td>
<td><strong>Monad</strong></td>
<td><strong>Foldable</strong></td>
<td><strong>ChainRec</strong></td>
</tr>
<tr>
<td><strong>Either</strong></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
</tr>
<tr>
<td><strong>Future</strong></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
</tr>
<tr>
<td><strong>Identity</strong></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
</tr>
<tr>
<td><strong>IO</strong></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
</tr>
<tr>
<td><strong>Maybe</strong></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
</tr>
<tr>
<td><strong>Reader</strong></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
</tr>
<tr>
<td><strong>Tuple</strong></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
</tr>
<tr>
<td><strong>State</strong></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
<td><span>â</span></td>
</tr>
</tbody>
</table>
<p>Â </p>
<p><span>Understanding category theory and all these data types and specifications is beyond the scope of this book. However, in this chapter, we are going to learn the basics of two of the most common algebraic data types: the <kbd>Functor</kbd> and the <kbd>Monad</kbd>.</span></p>
<div class="packt_infobox">Please refer to the <kbd>fantasy<span>Â âÂ </span>land</kbd> project at <a href="https://github.com/fantasyland/fantasy-land">https://github.com/fantasyland/fantasy-land</a> and theÂ <kbd><span>ramda â fantasy</span></kbd> project at <a href="https://github.com/ramda/ramda-fantasy">https://github.com/ramda/ramda-fantasy</a> to learn more about algebraic data types.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functor</h1>
                </header>
            
            <article>
                
<p>A <kbd>Functor</kbd> is an object that holds a value and implements a method named <kbd>map</kbd>. The following code snippet declares a class named <kbd>Container</kbd>. This class can be considered a <kbd>Functor</kbd>:</p>
<pre>class Container&lt;T&gt; { 
    private _value: T; 
    public constructor(val: T) { 
        this._value = val; 
    } 
    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) { 
        return new Container&lt;TMap&gt;(fn(this._value)); 
    } 
} </pre>
<p>We can use the container as follows:</p>
<pre>let double = (x: number) =&gt; x + x;
let container = new Container(3); 
let container2 = container.map(double); 
console.log(container2); // { _value: 6 } </pre>
<p>At this point, it might feel like a <kbd>Functor</kbd> is not very useful because we have implemented the most basic version possible. The next two sections implement two functors known as <kbd>Maybe</kbd> and <kbd>Either</kbd>. These two functors are much more useful and should demonstrate that functors are a powerful tool.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Applicative</h1>
                </header>
            
            <article>
                
<p>An <kbd>Applicative</kbd> is a <kbd>Functor</kbd> that implements a method named of:</p>
<pre>class Container&lt;T&gt; {
    public static of&lt;TVal&gt;(val: TVal) { 
        return new Container(val); 
    } 
    private _value!: T; 
    public constructor(val: T) { 
        this._value = val; 
    } 
    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) { 
        return new Container&lt;TMap&gt;(fn(this._value)); 
    } 
} </pre>
<p>We can use the <kbd>Applicative</kbd> as follows:</p>
<pre>let double = (x: number) =&gt; x + x; 
let container = Container.of(3); 
let container2 = container.map(double); 
console.log(container2); // { _value: 6 } </pre>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Maybe</h1>
                </header>
            
            <article>
                
<p class="mce-root">The following <kbd>Maybe</kbd> data type is a <kbd>Functor</kbd> and an <kbd>Applicative</kbd>, which means it contains a value and implements the map method. The main difference with the preceding implementation of <kbd>Functor</kbd> is that in the <kbd>MaybeÂ Functor</kbd>, the value contained by the data type is optional:</p>
<pre>class MayBe&lt;T&gt; { 
    public static of&lt;TVal&gt;(val?: TVal) { 
        return new MayBe(val); 
    } 
    private _value!: T; 
    public constructor(val?: T) { 
        if (val) { 
            this._value = val; 
        } 
    } 
    public isNothing() { 
        return (this._value === null || this._value === undefined); 
    } 
    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) { 
        if (this.isNothing()) { 
            return new MayBe&lt;TMap&gt;(); 
        } else { 
            return new MayBe&lt;TMap&gt;(fn(this._value)); 
        } 
    } 
} </pre>
<p>As we can see in the preceding implementation of the <kbd>map</kbd> method, the mapping function is only applied if the <kbd>Maybe</kbd> data type contains a value.</p>
<p>To demonstrate how to use the <kbd>Maybe</kbd> type and why it is useful, we are going to declare a function to fetch the latest TypeScript news in <a href="http://www.reddit.com">www.reddit.com</a>:</p>
<pre>interface New {
    subreddit: string; 
    id: string; 
    title: string; 
    score: number; 
    over_18: boolean; 
    url: string; 
    author: string; 
    ups: number; 
    num_comments: number; 
    created_utc: number; 
} 
 
interface Response { 
    kind: string; 
    data: { 
        modhash: string; 
        whitelist_status: boolean|null; 
        children: Array&lt;{ kind: string, data: New }&gt;; 
        after: string|null; 
        before: string|null; 
    }; 
} 
 
async function fetchNews() { 
    return new Promise&lt;MayBe&lt;Response&gt;&gt;((resolve, reject) =&gt; { 
        const url = "https://www.reddit.com/r/typescript/new.json"; 
        fetch(url) 
            .then((response) =&gt; { 
                return response.json(); 
            }).then((json) =&gt; { 
                resolve(new MayBe(json)); 
            }).catch(() =&gt; { 
                resolve(new MayBe()); 
            }); 
    }); 
} </pre>
<p>The preceding code snippet uses the fetch API to send an HTTP request. This is an asynchronous operation, which explains why the snippet creates a promise instance. When the operations are completed successfully, the response is returned as a <kbd>Maybe</kbd> instance. When the operations are completed unsuccessfully, an empty <kbd>Maybe</kbd> instance is returned.</p>
<p>The following code snippet demonstrates how we can use the <kbd>fetchNews</kbd> function:</p>
<pre>(async () =&gt; {
 
    const maybeOfResponse = await fetchNews(); 
 
    const maybeOfNews = maybeOfResponse 
        .map(r =&gt; r.data) 
        .map(d =&gt; d.children) 
        .map(children =&gt; children.map(c =&gt; c.data)); 
 
    maybeOfNews.map((news) =&gt; { 
        news.forEach((n) =&gt; console.log(`${n.title} - ${n.url}`)); 
        return news; 
    }); 
 
})(); </pre>
<p>The preceding code snippet uses <kbd>fetchNews</kbd> to fetch a list of posts about TypeScript from Reddit. If the request is completed successfully, the <kbd>fetchNews</kbd> function returns the HTTP response wrapped in a <kbd>MayBe</kbd> instance. We then use the <kbd>map</kbd> method to find the list of posts within the response. The nice thing about using a <kbd>MayBe</kbd> instance is that mapping logic is only executed if there is an actual response, so we don't need to worry about potential null or undefined errors.</p>
<div class="packt_infobox">Please note that the preceding example uses some browser APIs, which means that we need to addÂ <kbd>dom</kbd> to the <kbd>lib</kbd> field in our <kbd>tsconfig.json</kbd> file. This will prevent compilation errors such as Cannot find name <em>console</em>.<br/>
<span>Please note that the entire example is included in the companion source code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Either</h1>
                </header>
            
            <article>
                
<p>The <kbd>Either</kbd> algebraic data type is the union of the <kbd>Just</kbd> and <kbd>Nothing</kbd> types:</p>
<pre>    type Either&lt;T1, T2&gt; = Just&lt;T1&gt; | Nothing&lt;T2&gt;;</pre>
<p>The <kbd>Just</kbd> type is a <kbd>Functor</kbd> used to represent a non-nullable value:</p>
<pre>class Nothing&lt;T&gt; { 
    public static of&lt;TVal&gt;(val?: TVal) { 
        return new Nothing(val); 
    } 
    private _value: T|undefined; 
    public constructor(val?: T) { 
        this._value = val; 
    } 
    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) { 
        if (this._value !== undefined) { 
            return new Nothing&lt;TMap&gt;(fn(this._value)); 
        } else { 
            return new Nothing&lt;TMap&gt;(this._value as any); 
        } 
    } 
} </pre>
<p>The <kbd>Nothing</kbd> type represents the lack of a value:</p>
<pre>class Just&lt;T&gt; { 
    public static of&lt;TVal&gt;(val: TVal) { 
        return new Just(val); 
    } 
    private _value: T; 
    public constructor(val: T) { 
        this._value = val; 
    } 
    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) { 
        return new Just&lt;TMap&gt;(fn(this._value)); 
    } 
} </pre>
<p>The following code snippet is an implementation of the <kbd>fetchNews</kbd> function that we declared in the preceding section. The main difference this time is that we will return an instance of <kbd>Just</kbd> if the HTTP request is completed successfully and an instance of <kbd>Nothing</kbd> if the HTTP request is not completed successfully:</p>
<pre>interface New {
    subreddit: string; 
    id: string; 
    title: string; 
    score: number; 
    over_18: boolean; 
    url: string; 
    author: string; 
    ups: number; 
    num_comments: number; 
    created_utc: number; 
} 
 
interface Response { 
    kind: string; 
    data: { 
        modhash: string; 
        whitelist_status: boolean|null; 
        children: Array&lt;{ kind: string, data: New }&gt;; 
        after: string|null; 
        before: string|null; 
    }; 
} 
 
async function fetchNews() { 
    return new Promise&lt;Either&lt;Response, Error&gt;&gt;((resolve, reject) =&gt; { 
        const url = "https://www.reddit.com/r/typescript/new.json"; 
        fetch(url) 
            .then((response) =&gt; { 
                return response.json(); 
            }).then((json) =&gt; { 
                resolve(new Just(json)); 
            }).catch((e) =&gt; { 
                resolve(new Nothing(e)); 
            }); 
    }); 
} </pre>
<p>If we try to use <kbd>map</kbd> on an <kbd>Either</kbd> instance, we will get a compilation error:</p>
<pre>(async () =&gt; {
 
    const maybeOfResponse = await fetchNews(); 
 
    maybeOfResponse.map(r =&gt; r.message) 
    // Error: 
    // Cannot invoke an expression whose type lacks a call signature. 
    // Type 
    // (&lt;TMap&gt;(fn: (val: Response) =&gt; TMap) =&gt; Just&lt;TMap&gt;) | 
    // (&lt;TMap&gt;(fn: (val: Error) =&gt; TMap) =&gt; Nothin&lt;TMap&gt;' 
    // has no compatible call signatures. 
 
})(); </pre>
<p>We can use a type guard to ensure that we are accessing a <kbd>Nothing</kbd> instance when the request fails and a <kbd>Just</kbd> instance if the request was completed without errors:</p>
<pre>(async () =&gt; { 
 
    const maybeOfResponse = await fetchNews(); 
 
    if (maybeOfResponse instanceof Nothing) { 
 
        maybeOfResponse 
            .map(r =&gt; r.message) 
            .map(msg =&gt; { 
                console.log(`Error: ${msg}`); 
                return msg; 
            }); 
 
    } else { 
 
        const maybeOfNews = maybeOfResponse.map(r =&gt; r.data) 
            .map(d =&gt; d.children) 
            .map(children =&gt; children.map(c =&gt; c.data)); 
 
        maybeOfNews.map((news) =&gt; { 
            news.forEach((n) =&gt; console.log(`${n.title} - ${n.url}`)); 
            return news; 
        }); 
    } 
 
})(); </pre>
<p>The good thing about using Either is that the compiler forces us to use a type guard. This means that using an Either can lead to increased type safety when dealing with potential failures in operations.</p>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monad</h1>
                </header>
            
            <article>
                
<p>We are going to finish our introduction to algebraic data types by learning about monads. A <kbd>Monad</kbd> is a <kbd>Functor</kbd>, but it also implements the <kbd>Applicative</kbd> and <kbd>Chain</kbd> specifications.</p>
<p>We can transform the previously declared <kbd>Maybe</kbd> data type into a <kbd>Monad</kbd> by adding two extra methods named <kbd>join</kbd> and <kbd>chain</kbd>:</p>
<pre>class MayBe&lt;T&gt; { 
    public static of&lt;TVal&gt;(val?: TVal) { 
        return new MayBe(val); 
    } 
    private _value!: T; 
    public constructor(val?: T) { 
        if (val) { 
            this._value = val; 
        } 
    } 
    public isNothing() { 
        return (this._value === null || this._value === undefined); 
    } 
    public map&lt;TMap&gt;(fn: (val: T) =&gt; TMap) { 
        if (this.isNothing()) { 
            return new MayBe&lt;TMap&gt;(); 
        } else { 
            return new MayBe&lt;TMap&gt;(fn(this._value)); 
        } 
    } 
    public join() { 
        return this.isNothing() ? Nothing.of(this._value) : this._value; 
    } 
    public chain&lt;TMap&gt;(fn: (val: T) =&gt; TMap) { 
        return this.map(fn).join(); 
    } 
} </pre>
<p>The <kbd>Maybe</kbd> data type was already a <kbd>Functor</kbd> and an <kbd>Applicative</kbd>, but now it is also a <kbd>Monad</kbd>. The following code snippet showcases how we can use it:</p>
<pre>let maybeOfNumber = MayBe.of(5); 
 
maybeOfNumber.map((a) =&gt; a * 2); 
// MayBe { value: 10 } 
 
maybeOfNumber.join(); 
// 5 
 
maybeOfNumber.chain((a) =&gt; a * 2); 
// 10 
 
let maybeOfMaybeOfNumber = MayBe.of(MayBe.of(5)); 
// MayBe { value: MayBe { value: 5 } } 
 
maybeOfMaybeOfNumber.map((a) =&gt; a.map(v =&gt; v * 2)); 
// MayBe { value: MayBe { value: 10 } } 
 
maybeOfMaybeOfNumber.join(); 
// MayBe { value: 5 } 
 
maybeOfMaybeOfNumber.chain((a) =&gt; a.map(v =&gt; v * 2)); 
// MayBe { value: 10 } </pre>
<p>The preceding code snippet demonstrates how the <kbd>join</kbd> and <kbd>chain</kbd> methods work. As we can see, they are very useful when we have a <kbd>Functor</kbd> of a <kbd>Functor</kbd>, and we want to access the contained value. The <kbd>chain</kbd> method is just a one-step shortcut for the two operations, <kbd>join</kbd> and <kbd>map</kbd>.</p>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Real-world FP</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to explore some open source libraries that can be useful while working in a real-world FP application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Immutable.js</h1>
                </header>
            
            <article>
                
<p>As we have learned in this chapter, one of the main ideas in FP is minimizing the number of places in which state is mutated in our application. However, in JavaScript, objects are not immutable, which we can lead us to mutate the application's state by mistake. For example, we could try to sort an array using the following function:</p>
<pre>function sort(arr: number[]) { 
    return arr.sort((a, b) =&gt; b - a); 
} </pre>
<p>The preceding function could lead to issues because the <kbd>sort</kbd> method mutates the original array. This example is a demonstration of what is known as an implicit mutation. We mutated the application's state, but we didn't do it explicitly. <kbd>Immutable.js</kbd> helps us to make all the mutations in our application explicit.</p>
<p>We can install <kbd>immutable</kbd> using <kbd>npm</kbd>:</p>
<pre><strong>npm install --save immutable</strong> </pre>
<p>No type definitions are required because they are already included in the <kbd>immutable</kbd> package.</p>
<p>The following code snippet demonstrates how to transform objects into immutable objects and how to work with them. The immutable API includes methods such as <kbd>set</kbd>, <kbd>mergeDeep</kbd>, or <kbd>updateIn</kbd> that allow us to work with basic objects and nested objects:</p>
<pre>Import * as immutable from "immutable";
 
const map1 = immutable.Map({ a: 1, b: 2, c: 3 }); 
const map2 = map1.set("b", 50); 
console.log(`${map1.get("b")} vs.${map2.get("b")}`); 
// 2 vs. 50 
 
const nested = immutable.fromJS({ a: { b: { c: [ 3, 4, 5 ] } } }); 
 
const nested2 = nested.mergeDeep({ a: { b: { d: 6 } } }); 
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } } 
 
console.log(nested2.getIn([ "a", "b", "d" ])); 
// 6 
 
const nested3 = nested2.updateIn( 
    [ "a", "b", "d" ], 
    (value: string) =&gt; value + 1 
); 
 
console.log(nested3); 
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } } 
 
const nested4 = nested3.updateIn( 
    [ "a", "b", "c" ], 
    (list: number[]) =&gt; list.push(6) 
); 
 
console.log(nested4); 
// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } } </pre>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>
<p>These immutable objects cannot be mutated. The methods return new copies of the original objects, instead of mutating them. Immutable uses some smart algorithms and data structures to share some memory between objects and to be as efficient as possible when comparing them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ramda</h1>
                </header>
            
            <article>
                
<p>In a real-world application, we don't need to create our own our FP utilities (for example, compose or curry functions). We can use existing JavaScript libraries that already implement these helpers and many others. One of these libraries is <kbd>Ramda</kbd>.</p>
<p>We can install <kbd>Ramda</kbd> using <kbd>npm</kbd>:</p>
<pre><strong>npm install --save ramda <br/>npm install --save-dev @types/ramda</strong> </pre>
<p><kbd>Ramda</kbd> includes helper functions to implement function composition, currying, and many more FP techniques, and its API is influenced by the pointfree style.</p>
<p>The following code snippet re-implements the example that we used earlier in this chapter in the <em>Currying</em> section but uses the <kbd>Ramda</kbd> implementations of compose and currying, instead of using custom implementations:</p>
<pre>import * as R from "ramda";const trim = (s: string) =&gt; s.trim();
const capitalize = (s: string) =&gt; s.toUpperCase(); 
const trimAndCapitalize = R.compose(trim, capitalize); 
 
const replace = (s: string, f: string, r: string) =&gt; 
    s.split(f).join(r); 
 
const curriedReplace = R.curry(replace); 
const trimCapitalizeAndReplace = R.compose( 
    trimAndCapitalize, 
    curriedReplace("/")("-") 
); 
 
trimAndCapitalizeReplace("   13/feb/1989   "); // "13-FEB-1989" </pre>
<div class="packt_infobox">Please note that the entire example is included in the companion source code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">React and MobX</h1>
                </header>
            
            <article>
                
<p>Earlier in the chapter, we learned that FP reduces the number of places in which state changes take place within an application and tries to move these places into the boundaries of the application to try to keep application's core stateless.</p>
<p><kbd>React</kbd> and <kbd>MobX</kbd> are two popular open source libraries that can be used to build user interfaces. These libraries are highly influenced by FP and try to prevent state mutations by using pure functions and immutable objects (powered by libraries such as <kbd>Immutable.js</kbd>). However, state mutations must take place at some point. That is the main role of <kbd>MobX</kbd>, a library that allows us to manage the state in a <kbd>React</kbd> application.</p>
<p>In a <kbd>MobX</kbd> application, a new state should only be generated within one of the application's components, known as a <kbd>Store</kbd>. This is a very clear example of an FP architecture because it pushes all the state mutations in the entire application to one unique location.</p>
<div class="packt_infobox">Please refer to <a href="b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml">Chapter 11</a>, <em>Frontend Development with React and TypeScript</em>, to learn more about <kbd>React</kbd> and <kbd>MobX</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We started this chapter by learning some of the main FP concepts, including concepts such as pure functions, higher-order functions, and immutability.</p>
<p>We also learned some of the main FP techniques, including techniques such as functional composition, function partial application, and currying.</p>
<p>Later, we learned what category theory is and how to work with some algebraic data types.</p>
<p>Finally, we learned about some FP libraries that can help us to put some of these techniques and concepts into practice in a real-world application.</p>
<p>In the next chapter, we will learn how to work with decorators.</p>


            </article>

            
        </section>
    </div>



  </body></html>