- en: Chapter 7. Functional Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a frontend or backend JavaScript developer who works on large and
    complex JavaScript applications and deals with a lot of code that responds to
    asynchronous data updates, user activities, and system activities, then it's perhaps
    the best time to explore **functional reactive programming** (**FRP**), as it's
    a time-saving, bug-preventing, easy-to-read, and modularized style of writing
    code. You don't need to know any functional programming language or be a hardcore
    functional language programmer; rather, you just need to know the basics of functional
    programming. In this chapter, we will learn how to use FRP using `Bacon.js`, which
    is an FRP library for both frontend and backend JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems with writing reactive code in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What FRP is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The building blocks of FRP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of FRP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the APIs provided by Bacon.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into FRP, we need to understand what it is. I will be explaining
    reactive programming with respect to JavaScript. The concept of reactive programming
    is the same in every programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive programming** is writing code to look for asynchronous data updates,
    user activities, and system activities and propagate changes onto the dependent
    parts of the application. Reactive programming is not something new; believe it
    or not, you have already been doing reactive programming without realizing it.
    For example, the code you write to handle a button''s click event is reactive
    code. There are various approaches to reactive programming, such as event-driven,
    callback, promise patterns and FRP.'
  prefs: []
  type: TYPE_NORMAL
- en: Not every snippet of asynchronous code we write is reactive code. For example,
    uploading analytics data to a server asynchronously after a page load is not reactive
    code. But uploading a file to a server asynchronously and displaying a message
    to the user after the upload is complete is reactive code because we are reacting
    to the completion of the file upload.
  prefs: []
  type: TYPE_NORMAL
- en: A more complex example of reactive programming is in the MVC architecture, where
    reactive programming is what reacts to a change in the model and updates the view
    accordingly, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with writing reactive code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are basically three patterns natively supported by JavaScript for writing
    reactive code: **event-driven**, **callback**,and **promise**.'
  prefs: []
  type: TYPE_NORMAL
- en: Anyone who knows a bit of JavaScript is familiar with event-driven and callback
    patterns. Although these two patterns are the most popular way of writing reactive
    code, they make it difficult to catch exceptions and result in nested function
    calls, which makes the code harder to read and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the problems caused by event-driven and callback patterns, ES6 ([https://www.packtpub.com/web-development/learning-ecmascript-6](https://www.packtpub.com/web-development/learning-ecmascript-6))
    introduced the promise pattern. The promise pattern makes the code look more like
    synchronous code, therefore making it easy to read and debug. The pattern also
    makes exception handling easier. A promise represents an asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: But the promise pattern has a problem, that is, a promise can be resolved only
    once. The promise pattern can only respond to a single activity or data update
    of an asynchronous operation. For example, if we make an AJAX request using a
    promise pattern, then we can handle only *request success* and *failure* activities
    and not the states of the request and response cycle, such as weather server connections
    that have been established and response headers received. Similarly, if we handle
    a user click activity using a promise pattern, then we can handle only the first
    click, not the ones occurring after it, because the promise gets resolved in the
    first click.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may or may not be familiar with the promise pattern, so let''s look at
    some sample code of what a promise pattern looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `$http()` method makes an HTTP request asynchronously and returns
    a promise. The promise is resolved if the request is successful, and the callback
    passed to the first `then()` method is invoked, that is, the promise is resolved.
    If the request fails, then the callback is passed to the `catch()` method, which
    is invoked, and the promise is rejected. The `then()` method always returns a
    promise, making it possible to run multiple asynchronous operations one after
    another. In the code, you can see how asynchronous operations are chained. What's
    important here is that the `then()` methods are invoked only once, that is, the
    promise returned by the `$http()` method can be resolved only once, and multiple
    attempts to resolve a promise will be ignored. Therefore, we cannot use promise
    patterns to write reactive code when we have to deal with multiple activities
    or data updates of an asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some developers create a new promise for every activity and data update. This
    technique may seem fine since you are able to write reactive code involving multiple
    activities and data updates using promise patterns, but it's an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the problems with the event-driven, callback, and promise patterns, there
    was a need for another pattern, and functional reactive programming came to the
    rescue.
  prefs: []
  type: TYPE_NORMAL
- en: FRP is simply reactive programming using functional programming style. We will
    learn more about functional programming in the next section. Actually, the drawbacks
    of the event-driven, callback, and promise patterns weren't the real reason for
    the invention of FRP; rather, FRP was actually invented because there were demands
    for a functional pattern for reactive programming, as functional code is easy
    to write, test, debug, reuse, update, and read. But as FRP solves the problems
    caused by the event-driven, callback, and promise patterns, we can say that FRP
    is an alternative to the other patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about FRP, which is considered the modern way
    of writing reactive code.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into FRP, it's necessary to have basic knowledge about functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, functional programming is a style of writing code in which we
    use only pure function calls (including recursion) instead of loops and conditionals,
    and data is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming falls under the criterion of declarative programming.
    Declarative programming is a style of writing code where we write code to tell
    the system what we would like to happen instead of how to do it. Some other examples
    of declarative programming are SQL and regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: So what is a pure function? A **pure function** is a function that depends only
    on its input arguments and that always provides the same output for a particular
    input. If it reads anything else outside of its scope, including global variables,
    then it's not a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, it's not always possible to make all the functions pure. For example,
    a function that fetches a web page or reads from the filesystem cannot guarantee
    the same return value. We should try to make as many as functions as pure as possible.
    So, we can say that 100% purity is impossible to achieve, but 85% purity is still
    very productive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions without side effects, stateless functions, and pure functions are
    terms used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: As data is immutable in functional programming, you must be wondering how it
    is possible to write code without modifying data. Well, in practice, we simply
    create new data structures instead of modifying existing ones. For example, if
    we have an array with four values and we want to remove the last one, then we
    simply create a new array, which doesn't have the last value.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of immutable data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several advantages of immutable data. Here are a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: They are thread-safe, that is, multiple threads operating on them cannot modify/corrupt
    their state. Learn more about thread safety at [https://en.wikipedia.org/wiki/Thread_safety](https://en.wikipedia.org/wiki/Thread_safety).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They object copying can be shared easily. One doesn't have to employ a strategy
    such as defensive copying, like in mutable data structures. Learn more about object
    copying at [https://en.wikipedia.org/wiki/Object_copying](https://en.wikipedia.org/wiki/Object_copying).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They help avoid temporal coupling. More about temporal coupling can be found
    at [https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming](https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As data is immutable, there are several problems you are likely to face. Here
    are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: If an immutable array has millions of values, then creating a new array and
    copying all the values from the previous array is CPU and memory intensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If two threads need to write to the same variable, coordinating the final value
    of the variable will be difficult
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other issues. These issues led to the idea of functional data
    structures. Functional data structures are a different type of data structure
    that aim to solve these kinds of issue. But you don't need to know about functional
    data structures to follow this chapter or write functional reactive code in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few advantages of pure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: They increase reusability and maintainability, as each function is independent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier testing and debugging is possible, as each function can be tested and
    debugged separately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programs are easy to understand as they are written in a declarative
    manner, that is, the code says what is to be done instead of how it's done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The style of writing code using loops, conditionals, and function calls is called
    imperative programming. Imperative programming and functional programming are
    considered opposites of each other. JavaScript, C++, Java, Python, Ruby, are examples
    of imperative programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't have to use a functional programming language such as Erlang, Haskell,
    and so on to write functional code. Most imperative programming languages allow
    us to write functional code.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that functions in JavaScript are first-class (we will learn
    more about first-class functions later), it is possible to write functional code
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"First-class" and "high-order" are terms used interchangeably.'
  prefs: []
  type: TYPE_NORMAL
- en: A function is said to be first-class when it can be passed as an argument to
    another function, can return another function, and be assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, functions are first-class because they are objects. Because an
    object can be passed as an argument to another function, a function can return
    an object, and an object can be assigned to a variable, functions can be first-class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is the difference between a closure and a first-class function?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closures** are the most misunderstood topic in JavaScript. In a nutshell,
    a closure is a function returned by another function, and when the function is
    invoked, it has access to the lexical scope in which it was defined. A function
    returned by a first-class function may or may not be a closure. Here is an example
    to demonstrate closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the function named `c` is a closure as it's returned by `a`, and when
    invoked, it has access to the variables declared inside `a`.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming helper functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Functional programming languages** provide a lot of in-built functions called
    helper functions to make it easy to write functional code. For example, as we
    cannot use loops for iteration in functional code, we need some sort of function
    to take a collection and map each value of the collection to a function. Functional
    programming languages provide the `map` helper function for this purpose. Similarly,
    there are a lot of other helper functions for different purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: As JavaScript is not a functional programming language, it doesn't come with
    functional helper functions. However, ES6 introduced some helper functions, such
    as `Array.from()`, `Array.prototype.from()`, and `Array.prototype.find()`. Still,
    this list is not enough to write functional code. Therefore, developers use libraries
    such as `Underscore.js` to write functional code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with FRP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FRP is simply reactive programming using functional programming style.
  prefs: []
  type: TYPE_NORMAL
- en: EventStreams and properties (don't get these confused with object properties)
    are the building blocks of FRP. Let's look at an overview of what both these terms
    mean.
  prefs: []
  type: TYPE_NORMAL
- en: EventStreams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An EventStream represents a stream of events. Events in an EventStream may happen
    at any time and need not occur synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand EventStreams by comparing them to events in an event-driven
    pattern. Just like we subscribe to events in an event-driven pattern, we subscribe
    to EventStreams in FRP. Unlike events in event-driven programming, the power of
    EventStreams is that they can be merged, concatenated, combined, zipped, filtered,
    or transformed in any number of ways before you handle and act on the events.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, data is immutable, so merging, concatenating, combining,
    zipping, filtering, or transforming an EventStream creates a new EventStream instead
    of modifying the existing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram that shows how an EventStream representing the click event
    of a UI element would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EventStreams](img/B05154_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This EventStream can be merged with any other stream. Here is a diagram that
    shows how it looks when two EventStreams are merged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EventStreams](img/B05154_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Merging can be useful when we want to apply the same action when an event occurs
    to two different EventStreams. Instead of subscribing and attaching a callback
    to two different EventStreams, we can now subscribe to a single EventStream, eliminating
    duplicate code and making it easy to update code. Merging can be useful in various
    other cases as well.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A property represents a value that changes over time. Properties can be used
    as an alternative to JavaScript variables whose values change in response to asynchronous
    activities and data updates. For example, you can use properties to represent
    the total number of times a button was clicked, the total number of logged-in
    users, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Properties are also called signals or behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using properties instead of JavaScript variables is that you
    can subscribe to properties, that is, whenever the value of a property changes,
    a callback is fired to update the parts of the system that depend on it. This
    prevents code duplication and has many other benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create a property from another property as well as merge, combine, zip,
    sample, filter, or transform properties.
  prefs: []
  type: TYPE_NORMAL
- en: We've just looked at the basics of FRP. Creating EventStreams and properties,
    their methods, and other things to work with them differ depending on the library
    we use to write functional reactive code. Now, let's explore how to write functional
    reactive code using the Bacon.js library.
  prefs: []
  type: TYPE_NORMAL
- en: FRP using Bacon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Bacon.js** is a JavaScript library that helps us write functional reactive
    code in JavaScript. It can be used for both frontend and backend JavaScript. The
    official website of Bacon.js library is [https://baconjs.github.io/](https://baconjs.github.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a basic website project to demonstrate FRP with Bacon.js.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's learn how to download and install Bacon.js for use with frontend and backend
    JavaScript. On the frontend, Bacon.js depends on jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `baconjs-example`. Inside it, create files called `package.json`
    and `app.js` and a directory called `public`. Inside the `public` directory, create
    directories called `html` and `js`. Inside the `html` directory, create a file
    called `index.html`. Finally, inside the `js` directory, create a file called
    `index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Download the frontend Bacon.js library from [http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js](http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js)
    and jQuery from [https://code.jquery.com/jquery-2.2.0.min.js](https://code.jquery.com/jquery-2.2.0.min.js),
    and place them in the `js` directory.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, 0.7.73 was the latest version of the frontend
    Bacon.js library, and 2.2.0 was the latest version of jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `index.html` file, place this code to enqueue jQuery and the frontend
    Bacon.js library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `package.json` file, place this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, run `npm install` inside the `baconjs-example` directory to download the
    npm packages.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, 0.7.83 was the latest version of backend Bacon.js
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `app.js` file, place the following code to import the backend Bacon.js
    and Express modules. It also starts our webserver in order to serve the web page
    and static files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have now set up a basic Bacon.js project. Run `node app.js` to start the
    web server. Now, let's explore Bacon.js APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Bacon.js APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bacon.js provides APIs to do almost anything that's possible using EventStreams
    and properties. The method of importing and downloading Bacon.js for the backend
    and frontend is different, but the APIs are the same for both. Let's look at the
    most important APIs provided by Bacon.js.
  prefs: []
  type: TYPE_NORMAL
- en: Creating EventStreams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are various ways of creating EventStreams, depending on how an asynchronous
    API is designed, that is, which pattern an asynchronous API follows. An asynchronous
    API follows the event-driven, promise, or callback pattern. We need to wrap these
    patterns with Bacon-provided APIs to connect their data updates or activity updates
    to event streams, that is, convert them to functional reactive patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create an EventStream for a UI element on a web page, we can
    use the `$.asEventStream()` method. Let''s look at an example of how it works.
    Place the following code in the `<body>` tag of the `index.html` file to create
    a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In an event-driven pattern, to print something whenever a button is clicked,
    we would write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But in Bacon.js, we will write it this way. Place this code in the `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use a jQuery selector to point to the button, and we then use the `$.asEventStream`
    method to connect its click events to an EventStream. The `$.asEventStream` method
    takes the name of the event as its first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `onValue` method is used to add subscribers to an EventStream. The `onValue`
    method of an EventStream takes a callback, which is executed every time a new
    event is added to the EventStream. The callback has a single parameter, which
    represents the current event that has been added to the EventStream. In this case,
    it's of the event interface. We can call the `onValue` method multiple times to
    add multiple callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: A subscriber can be used to update the UI, perform logging, and so on. But the
    logic code for handling the event should be written using the helper functions
    and not be inside the subscriber. This is how functional reactive code is supposed
    to be written.
  prefs: []
  type: TYPE_NORMAL
- en: The subscriber callback will not be invoked for events that occurred before
    the subscriber was registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, there are lots of other APIs provided by Bacon.js to create EventStreams.
    Here are a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bacon.fromPromise`: This is used to create an EventStream from a promise object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bacon.fromEvent`: This is used to create an EventStream from events of an
    EventTarget or Node.js EventEmitter object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bacon.fromCallback`: This is used to create an EventStream from a function
    that accepts a callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bacon.fromNodeCallback`: This is the same as `Bacon.fromCallback`, but it
    requires the callback to be called in Node.js convention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bacon.fromBinder`: If none of the previous APIs are fitting well, then you
    can use this one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A property is created from an EventStream, that is, a stream whose events the
    value of the property depends on. Whenever an event occurs in the EventStream,
    a callback is executed to update the property value.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a property for an EventStream using either the `toProperty` or
    `scan` methods. The `scan` method is used instead of `toProperty` when we want
    to give an initial value as well as an accumulator function to the property. You
    may or may not provide an initial value when creating a property using `toProperty`().
  prefs: []
  type: TYPE_NORMAL
- en: Calling `scan` or `toProperty` multiple times create multiple properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a property to hold the total number of times a button is clicked.
    Here is the code to do this; place it in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a property using the `scan` method and initialized it to `0`.
    The second argument is a callback, which is invoked to update the property value
    whenever an event happens in the EventStream to which the property is attached.
    This callback should return the new property value. The callback has two parameters,
    that is, the current value of the property and the event.
  prefs: []
  type: TYPE_NORMAL
- en: The `onValue` method of a property takes a callback that is executed every time
    the property value changes. We can call the `onValue` method multiple times to
    register multiple callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: When we register a subscriber for a property, the subscriber is executed with
    the current value as soon as it's registered, but not for the values that occurred
    before it had been registered. If the property has not yet been assigned to anything,
    then the callback is not executed.
  prefs: []
  type: TYPE_NORMAL
- en: Here, whenever the property value changes, we log a statement informing us about
    the total number of times the button was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'A property can also be created from another property. This is useful when a
    property''s value depends on another property. Let''s create a property from the
    previous property, which holds the time at which the property was last clicked
    and the button click count at that time. Here is the code to do this; place it
    in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Everything here is self-explanatory. The only thing you need to know is that
    the second parameter of the second argument passed to the `scan` method represents
    the value of the property we used to create this property.
  prefs: []
  type: TYPE_NORMAL
- en: A property holds a stream that has all of its previous and current values internally;
    therefore, we can also merge, combine, zip, sample, filter, and transform properties.
    Merging, combining, zipping, sampling, filtering, or transforming properties gives
    us new properties. This feature is useful for writing code for the more complex
    situation of a property's value depending on another property. For example, if
    we want to ignore some values of a property while calculating the value of another
    property based on it, then we can use filter feature.
  prefs: []
  type: TYPE_NORMAL
- en: Bacon.js also allows us to create EventStreams based on properties, that is,
    the events of an EventStream represent the values of a property. Events in these
    EventStreams occur when their respective property value is changed. This feature
    has many benefits, one of which is that it can prevent code duplication when we
    have to trigger the same action in response to several properties changing their
    values.
  prefs: []
  type: TYPE_NORMAL
- en: To create EventStreams based on properties, we can use the `toEventStream` method
    of a property.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Retrieving the latest value of a property**'
  prefs: []
  type: TYPE_NORMAL
- en: There is no method to obtain the latest value of a property, and there will
    be. You obtain the value by subscribing to the property and handling the values
    in your callback. If you need the value of more than one source, use one of the
    `combine` methods. This is how functional reactive code using Bacon.js is supposed
    to be written.
  prefs: []
  type: TYPE_NORMAL
- en: Merging, filtering, and transforming EventStreams and properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bacon.js provides various helper functions to work with EventStreams and properties.
    Let's look at some of the most useful helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Merging** streams or properties gives us a new stream or property that delivers
    all the events or values of all the streams or properties. To merge EventStreams
    or properties, we can use their `Bacon.mergeAll` method instances. Here is some
    example code to demonstrate this. Place it in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we merge two properties. `Bacon.mergeAll` takes an array of either EventStreams
    or properties. Whenever the value of either of the two properties changes, the
    value is made the current value of the resultant property.
  prefs: []
  type: TYPE_NORMAL
- en: There are various other helper functions available for merging properties and
    EventStreams.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Filtering** is removing specific events or values from EventStreams or properties,
    respectively, that we don''t need.'
  prefs: []
  type: TYPE_NORMAL
- en: Bacon.js provides a lot of helper functions to filter EventStreams and properties,
    depending on what you want to filter. Let's look at the `filter` method for EventStreams
    and properties that lets us filter based on a predicate function; that is, if
    the function returns `true`, then the value is accepted; otherwise, it is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at example code to demonstrate this. In the `index.js` file, find
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace that with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are filtering all those click events in which we didn't press the *Shift*
    key. So, for the click event to be accepted, we need to press the *Shift* key
    while clicking on the button.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of filtering as an alternative to using the `if…else` conditional.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Transforming** is creating an EventStream or property from another EventStream
    or property, respectively, whose events are transformed to something else. For
    example, a property whose value represents a URL can be transformed to another
    property, whose value represents the response of the URL. Transforming EventStreams
    and properties actually creates new EventStreams and properties, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of transforming as an alternative to loops, that is, to using
    `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: There are several helper functions provided by Bacon.js for transformation depending
    on how and what you want to transform.
  prefs: []
  type: TYPE_NORMAL
- en: 'One popular transformation function is `map()`, which maps events or values
    of EventStreams or properties to a function. Let''s look at a code sample to demonstrate
    this. Find this code in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using `map()` to transform the Unix timestamp to the HH:MM format,
    which is easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another, vital transformation helper function provided by Bacon.js
    called `flatMap`. There are basically two differences between `flatMap` and `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap` function always returns an EventStream regardless of whether it
    was called on a EventStream or property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the callback passed to `flatMap` returns an EventStream or property, then
    the events of the EventStream returned by the `flatMap` function are events and
    values of the streams and properties returned by the callback passed to `flatMap`.
    Whenever an event or value is added to the streams and properties returned by
    the callback passed to `flatMap`, the event and value will automatically be added
    to the EventStream returned by the `flatMap` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to use `flatMap` instead of `map` when retrieving the return value
    of a callback passed to a network, disk drive, or somewhere else asynchronous.
    For example, in the previous example, where I talked about transforming a URL
    to a URL response, we need to use `flatMap` instead of `map` as instead of a callback,
    we need to make an AJAX request, and its response will be captured as a stream,
    and the stream will be returned. When the AJAX request completes, the event will
    be put inside the stream returned by the `flatMap` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an implementation of this example. First, create an input text
    field and place it in the `index.html` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write code using Bacon.js to log the output of the URL entered
    in the field when a user hits the *Enter* key. Here is the code to do this. Place
    it in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an EventStream for the `keyup` event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we filter only *Enter*-key events because we will take action only if
    the *Enter* key is pressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create a variable to hold the value of the text field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we use `flatMap` to fetch the response of the URL using jQuery AJAX. We
    are using `Bacon.fromPromise` to create an EventStream from a promise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the AJAX request finishes, it adds the response to the EventStream returned
    by the callback passed to `flatMap`. Then, `flatMap` adds the same response to
    the EventStream returned by the `flatMap` function itself. As soon as it's added,
    we log the response using `onValue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, if we had used `map` instead of `flatMap`, then we would have ended up
    logging EventStream objects instead of the events of the EventStream returned
    by the `map` function.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can have both `url` and `response` properties directly created from
    the `enter_key_click_stream`, it is likely to cause code repetition and make the
    code difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you call a method to transform, filter, or do something else with EventStreams,
    then the events that occurred before the method call are not taken into account.
    However, in the case of a property, the current value is taken into account, but
    not the values that occurred before the method call. If the property has not yet
    been assigned to anything, nothing is taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at reactive programming, functional programming, FRP, and finally
    an overview of Bacon.js. You should now be comfortable with writing basic functional
    reactive code and have a clear idea of its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about more of the APIs provided by Bacon.js and build a real-world
    project using Bacon.js in the next chapter.
  prefs: []
  type: TYPE_NORMAL
