- en: Chapter 7. Functional Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。函数式反应式编程
- en: If you are a frontend or backend JavaScript developer who works on large and
    complex JavaScript applications and deals with a lot of code that responds to
    asynchronous data updates, user activities, and system activities, then it's perhaps
    the best time to explore **functional reactive programming** (**FRP**), as it's
    a time-saving, bug-preventing, easy-to-read, and modularized style of writing
    code. You don't need to know any functional programming language or be a hardcore
    functional language programmer; rather, you just need to know the basics of functional
    programming. In this chapter, we will learn how to use FRP using `Bacon.js`, which
    is an FRP library for both frontend and backend JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名前端或后端JavaScript开发者，你在大型且复杂的JavaScript应用程序上工作，并且处理大量响应于异步数据更新、用户活动和系统活动的代码，那么现在是探索**函数式反应式编程**（**FRP**）的最佳时机，因为它是一种节省时间、防止错误、易于阅读和模块化的代码编写风格。你不需要了解任何函数式编程语言或成为硬核函数式语言程序员；相反，你只需要了解函数式编程的基础知识。在本章中，我们将学习如何使用`Bacon.js`来使用FRP，这是一个适用于前端和后端的JavaScript
    FRP库。
- en: 'We''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下内容：
- en: Reactive programming in a nutshell
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程概述
- en: Problems with writing reactive code in JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中编写反应式代码的问题
- en: Introduction to functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程简介
- en: What FRP is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FRP是什么
- en: The building blocks of FRP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FRP的构建块
- en: The advantages of FRP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FRP的优势
- en: All the APIs provided by Bacon.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bacon.js提供的所有API
- en: Introduction to reactive programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程简介
- en: Before we get into FRP, we need to understand what it is. I will be explaining
    reactive programming with respect to JavaScript. The concept of reactive programming
    is the same in every programming language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解FRP之前，我们需要了解它是什么。我将用JavaScript来解释反应式编程。反应式编程的概念在每种编程语言中都是相同的。
- en: '**Reactive programming** is writing code to look for asynchronous data updates,
    user activities, and system activities and propagate changes onto the dependent
    parts of the application. Reactive programming is not something new; believe it
    or not, you have already been doing reactive programming without realizing it.
    For example, the code you write to handle a button''s click event is reactive
    code. There are various approaches to reactive programming, such as event-driven,
    callback, promise patterns and FRP.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**反应式编程**是编写代码以查找异步数据更新、用户活动和系统活动，并将更改传播到应用程序的依赖部分。反应式编程并不是什么新鲜事物；信不信由你，你可能已经在不知不觉中进行了反应式编程。例如，你编写的处理按钮点击事件的代码就是反应式代码。反应式编程有多种方法，例如事件驱动、回调、Promise
    模式和 FRP。'
- en: Not every snippet of asynchronous code we write is reactive code. For example,
    uploading analytics data to a server asynchronously after a page load is not reactive
    code. But uploading a file to a server asynchronously and displaying a message
    to the user after the upload is complete is reactive code because we are reacting
    to the completion of the file upload.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的并非所有异步代码都是反应式代码。例如，在页面加载后异步上传分析数据到服务器不是反应式代码。但是，在文件上传完成后异步上传文件并向用户显示消息是反应式代码，因为我们正在对文件上传的完成做出反应。
- en: A more complex example of reactive programming is in the MVC architecture, where
    reactive programming is what reacts to a change in the model and updates the view
    accordingly, and vice versa.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程的一个更复杂的例子是在MVC架构中，其中反应式编程是对模型变化的响应并相应地更新视图，反之亦然。
- en: Problems with writing reactive code
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写反应式代码的问题
- en: 'There are basically three patterns natively supported by JavaScript for writing
    reactive code: **event-driven**, **callback**,and **promise**.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript原生支持三种模式来编写反应式代码：**事件驱动**、**回调**和**Promise**。
- en: Anyone who knows a bit of JavaScript is familiar with event-driven and callback
    patterns. Although these two patterns are the most popular way of writing reactive
    code, they make it difficult to catch exceptions and result in nested function
    calls, which makes the code harder to read and debug.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何稍微了解一点JavaScript的人都会熟悉事件驱动和回调模式。尽管这两种模式是编写反应式代码最流行的方式，但它们使得捕获异常变得困难，并导致嵌套函数调用，这使得代码更难以阅读和调试。
- en: Due to the problems caused by event-driven and callback patterns, ES6 ([https://www.packtpub.com/web-development/learning-ecmascript-6](https://www.packtpub.com/web-development/learning-ecmascript-6))
    introduced the promise pattern. The promise pattern makes the code look more like
    synchronous code, therefore making it easy to read and debug. The pattern also
    makes exception handling easier. A promise represents an asynchronous operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件驱动和回调模式引起的问题，ES6 ([https://www.packtpub.com/web-development/learning-ecmascript-6](https://www.packtpub.com/web-development/learning-ecmascript-6))
    引入了承诺模式。承诺模式使代码看起来更像同步代码，因此更容易阅读和调试。该模式还使异常处理变得更容易。承诺代表一个异步操作。
- en: But the promise pattern has a problem, that is, a promise can be resolved only
    once. The promise pattern can only respond to a single activity or data update
    of an asynchronous operation. For example, if we make an AJAX request using a
    promise pattern, then we can handle only *request success* and *failure* activities
    and not the states of the request and response cycle, such as weather server connections
    that have been established and response headers received. Similarly, if we handle
    a user click activity using a promise pattern, then we can handle only the first
    click, not the ones occurring after it, because the promise gets resolved in the
    first click.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但承诺模式有一个问题，那就是承诺只能被解决一次。承诺模式只能响应异步操作的单一活动或数据更新。例如，如果我们使用承诺模式发起 AJAX 请求，那么我们只能处理
    *请求成功* 和 *失败* 活动，而不能处理请求和响应周期的状态，例如已建立的服务器连接和接收到的响应头。同样，如果我们使用承诺模式处理用户点击活动，那么我们只能处理第一次点击，而不能处理随后的点击，因为承诺在第一次点击时就被解决了。
- en: 'You may or may not be familiar with the promise pattern, so let''s look at
    some sample code of what a promise pattern looks like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉或不熟悉承诺模式，所以让我们看看一些承诺模式样例代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the `$http()` method makes an HTTP request asynchronously and returns
    a promise. The promise is resolved if the request is successful, and the callback
    passed to the first `then()` method is invoked, that is, the promise is resolved.
    If the request fails, then the callback is passed to the `catch()` method, which
    is invoked, and the promise is rejected. The `then()` method always returns a
    promise, making it possible to run multiple asynchronous operations one after
    another. In the code, you can see how asynchronous operations are chained. What's
    important here is that the `then()` methods are invoked only once, that is, the
    promise returned by the `$http()` method can be resolved only once, and multiple
    attempts to resolve a promise will be ignored. Therefore, we cannot use promise
    patterns to write reactive code when we have to deal with multiple activities
    or data updates of an asynchronous operation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$http()` 方法异步发起 HTTP 请求并返回一个承诺。如果请求成功，则承诺被解决，传递给第一个 `then()` 方法的回调被调用，即承诺被解决。如果请求失败，则回调传递给
    `catch()` 方法，该方法被调用，承诺被拒绝。`then()` 方法总是返回一个承诺，这使得可以依次运行多个异步操作。在代码中，你可以看到异步操作是如何链式调用的。这里重要的是
    `then()` 方法只被调用一次，也就是说，`$http()` 方法返回的承诺只能被解决一次，多次尝试解决承诺将被忽略。因此，当我们必须处理多个活动或异步操作的数据更新时，我们不能使用承诺模式来编写响应式代码。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some developers create a new promise for every activity and data update. This
    technique may seem fine since you are able to write reactive code involving multiple
    activities and data updates using promise patterns, but it's an anti-pattern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者为每个活动和数据更新创建一个新的承诺。这种技术可能看起来不错，因为你可以使用承诺模式编写涉及多个活动和数据更新的响应式代码，但这是一种反模式。
- en: Due to the problems with the event-driven, callback, and promise patterns, there
    was a need for another pattern, and functional reactive programming came to the
    rescue.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件驱动、回调和承诺模式的问题，需要另一种模式，函数式响应式编程应运而生。
- en: FRP is simply reactive programming using functional programming style. We will
    learn more about functional programming in the next section. Actually, the drawbacks
    of the event-driven, callback, and promise patterns weren't the real reason for
    the invention of FRP; rather, FRP was actually invented because there were demands
    for a functional pattern for reactive programming, as functional code is easy
    to write, test, debug, reuse, update, and read. But as FRP solves the problems
    caused by the event-driven, callback, and promise patterns, we can say that FRP
    is an alternative to the other patterns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: FRP（函数式响应式编程）简单来说就是使用函数式编程风格的响应式编程。我们将在下一节中了解更多关于函数式编程的内容。实际上，事件驱动、回调和承诺模式的不利之处并不是FRP被发明的真正原因；相反，FRP实际上是因为对响应式编程的函数式模式有需求而被发明的，因为函数式代码易于编写、测试、调试、重用、更新和阅读。但是，由于FRP解决了由事件驱动、回调和承诺模式引起的问题，我们可以说FRP是其他模式的替代品。
- en: In this chapter, we will learn about FRP, which is considered the modern way
    of writing reactive code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习FRP，它被认为是编写响应式代码的现代方式。
- en: Functional programming in a nutshell
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程概述
- en: Before we get into FRP, it's necessary to have basic knowledge about functional
    programming.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解FRP之前，有必要对函数式编程有基本了解。
- en: In a nutshell, functional programming is a style of writing code in which we
    use only pure function calls (including recursion) instead of loops and conditionals,
    and data is immutable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，函数式编程是一种编写代码的风格，其中我们只使用纯函数调用（包括递归）而不是循环和条件语句，并且数据是不可变的。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Functional programming falls under the criterion of declarative programming.
    Declarative programming is a style of writing code where we write code to tell
    the system what we would like to happen instead of how to do it. Some other examples
    of declarative programming are SQL and regular expressions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程属于声明式编程的范畴。声明式编程是一种编写代码的风格，我们编写代码来告诉系统我们希望发生什么，而不是如何去做。声明式编程的其他例子还包括SQL和正则表达式。
- en: So what is a pure function? A **pure function** is a function that depends only
    on its input arguments and that always provides the same output for a particular
    input. If it reads anything else outside of its scope, including global variables,
    then it's not a pure function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是纯函数？**纯函数**是一个只依赖于其输入参数并且对于特定的输入总是提供相同输出的函数。如果它在其作用域之外读取任何其他内容，包括全局变量，那么它就不是纯函数。
- en: Obviously, it's not always possible to make all the functions pure. For example,
    a function that fetches a web page or reads from the filesystem cannot guarantee
    the same return value. We should try to make as many as functions as pure as possible.
    So, we can say that 100% purity is impossible to achieve, but 85% purity is still
    very productive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并不是总是可能使所有函数都是纯函数。例如，一个获取网页或从文件系统中读取的函数不能保证相同的返回值。我们应该尽量使尽可能多的函数保持纯函数。因此，我们可以这样说，100%的纯度是无法实现的，但85%的纯度仍然非常高效。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Functions without side effects, stateless functions, and pure functions are
    terms used interchangeably.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无副作用函数、无状态函数和纯函数是可互换使用的术语。
- en: As data is immutable in functional programming, you must be wondering how it
    is possible to write code without modifying data. Well, in practice, we simply
    create new data structures instead of modifying existing ones. For example, if
    we have an array with four values and we want to remove the last one, then we
    simply create a new array, which doesn't have the last value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，数据是不可变的，你可能想知道在不修改数据的情况下如何编写代码。实际上，在实践中，我们只是简单地创建新的数据结构，而不是修改现有的数据结构。例如，如果我们有一个包含四个值的数组，并且我们想要移除最后一个值，那么我们只需创建一个新的数组，这个数组不包含最后一个值。
- en: The advantages of immutable data
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变数据的优点
- en: 'There are several advantages of immutable data. Here are a few of them:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据有几个优点。以下是一些：
- en: They are thread-safe, that is, multiple threads operating on them cannot modify/corrupt
    their state. Learn more about thread safety at [https://en.wikipedia.org/wiki/Thread_safety](https://en.wikipedia.org/wiki/Thread_safety).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是线程安全的，也就是说，在它们上操作的多个线程不能修改/破坏它们的状态。更多关于线程安全的信息请参阅[https://en.wikipedia.org/wiki/Thread_safety](https://en.wikipedia.org/wiki/Thread_safety)。
- en: They object copying can be shared easily. One doesn't have to employ a strategy
    such as defensive copying, like in mutable data structures. Learn more about object
    copying at [https://en.wikipedia.org/wiki/Object_copying](https://en.wikipedia.org/wiki/Object_copying).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象复制可以轻松共享。不需要像在可变数据结构中那样采用防御性复制等策略。更多关于对象复制的信息可以在[https://en.wikipedia.org/wiki/Object_copying](https://en.wikipedia.org/wiki/Object_copying)找到。
- en: They help avoid temporal coupling. More about temporal coupling can be found
    at [https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming](https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有助于避免时间耦合。更多关于时间耦合的信息可以在[https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming](https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming)找到。
- en: Functional data structures
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式数据结构
- en: 'As data is immutable, there are several problems you are likely to face. Here
    are a few:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据是不可变的，你可能会遇到几个问题。以下是一些：
- en: If an immutable array has millions of values, then creating a new array and
    copying all the values from the previous array is CPU and memory intensive
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个不可变数组有数百万个值，那么创建一个新的数组并从上一个数组中复制所有值将会占用大量的CPU和内存
- en: If two threads need to write to the same variable, coordinating the final value
    of the variable will be difficult
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个线程需要写入同一个变量，协调该变量的最终值将会很困难
- en: There are many other issues. These issues led to the idea of functional data
    structures. Functional data structures are a different type of data structure
    that aim to solve these kinds of issue. But you don't need to know about functional
    data structures to follow this chapter or write functional reactive code in JavaScript.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多其他问题。这些问题导致了函数式数据结构的概念。函数式数据结构是一种旨在解决这些问题的不同类型的数据结构。但你不需要了解函数式数据结构来跟随本章内容或编写JavaScript中的函数式响应式代码。
- en: The advantages of pure functions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数的优势
- en: 'Here are a few advantages of pure functions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是纯函数的一些优势：
- en: They increase reusability and maintainability, as each function is independent
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们增加了可重用性和可维护性，因为每个函数都是独立的
- en: Easier testing and debugging is possible, as each function can be tested and
    debugged separately
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个函数都可以单独测试和调试，因此更容易进行测试和调试
- en: Functional programs are easy to understand as they are written in a declarative
    manner, that is, the code says what is to be done instead of how it's done.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序易于理解，因为它们是以声明式方式编写的，也就是说，代码说明了要做什么，而不是如何做。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The style of writing code using loops, conditionals, and function calls is called
    imperative programming. Imperative programming and functional programming are
    considered opposites of each other. JavaScript, C++, Java, Python, Ruby, are examples
    of imperative programming languages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环、条件和函数调用来编写代码的风格被称为命令式编程。命令式编程和函数式编程被认为是彼此的相反。JavaScript、C++、Java、Python、Ruby等都是命令式编程语言的例子。
- en: Functional programming with JavaScript
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript进行函数式编程
- en: You don't have to use a functional programming language such as Erlang, Haskell,
    and so on to write functional code. Most imperative programming languages allow
    us to write functional code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用像Erlang、Haskell这样的函数式编程语言来编写函数式代码。大多数命令式编程语言都允许我们编写函数式代码。
- en: Due to the fact that functions in JavaScript are first-class (we will learn
    more about first-class functions later), it is possible to write functional code
    in JavaScript.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中的函数是一等函数（我们将在后面学习更多关于一等函数的内容），因此可以在JavaScript中编写函数式代码。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '"First-class" and "high-order" are terms used interchangeably.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “一等”和“高阶”是可互换使用的术语。
- en: A function is said to be first-class when it can be passed as an argument to
    another function, can return another function, and be assigned to a variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数可以被传递给另一个函数作为参数，可以返回另一个函数，并且可以被分配给一个变量时，我们称其为“一等函数”。
- en: In JavaScript, functions are first-class because they are objects. Because an
    object can be passed as an argument to another function, a function can return
    an object, and an object can be assigned to a variable, functions can be first-class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是一等函数，因为它们是对象。因为一个对象可以被传递给另一个函数，一个函数可以返回一个对象，一个对象可以被分配给一个变量，所以函数可以是一等函数。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What is the difference between a closure and a first-class function?**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包和一等函数之间的区别是什么？**'
- en: '**Closures** are the most misunderstood topic in JavaScript. In a nutshell,
    a closure is a function returned by another function, and when the function is
    invoked, it has access to the lexical scope in which it was defined. A function
    returned by a first-class function may or may not be a closure. Here is an example
    to demonstrate closures:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包**是JavaScript中最被误解的主题。简而言之，闭包是由另一个函数返回的函数，当该函数被调用时，它可以访问其定义的词法作用域。由一等函数返回的函数可能是一个闭包，也可能不是。以下是一个演示闭包的例子：'
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the function named `c` is a closure as it's returned by `a`, and when
    invoked, it has access to the variables declared inside `a`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，名为`c`的函数是一个闭包，因为它是由`a`返回的，并且在调用时可以访问`a`内部声明的变量。
- en: Functional programming helper functions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程辅助函数
- en: '**Functional programming languages** provide a lot of in-built functions called
    helper functions to make it easy to write functional code. For example, as we
    cannot use loops for iteration in functional code, we need some sort of function
    to take a collection and map each value of the collection to a function. Functional
    programming languages provide the `map` helper function for this purpose. Similarly,
    there are a lot of other helper functions for different purposes.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程语言**提供许多内置的函数，称为辅助函数，以简化函数式代码的编写。例如，由于我们不能在函数式代码中使用循环进行迭代，我们需要某种函数来接受一个集合并将集合中的每个值映射到一个函数。函数式编程语言提供`map`辅助函数来完成这个目的。同样，还有许多其他辅助函数用于不同的目的。'
- en: As JavaScript is not a functional programming language, it doesn't come with
    functional helper functions. However, ES6 introduced some helper functions, such
    as `Array.from()`, `Array.prototype.from()`, and `Array.prototype.find()`. Still,
    this list is not enough to write functional code. Therefore, developers use libraries
    such as `Underscore.js` to write functional code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript不是函数式编程语言，它没有内置函数式辅助函数。然而，ES6引入了一些辅助函数，例如`Array.from()`、`Array.prototype.from()`和`Array.prototype.find()`。尽管如此，这个列表还不够用来编写函数式代码。因此，开发者使用像`Underscore.js`这样的库来编写函数式代码。
- en: Getting started with FRP
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用FRP
- en: FRP is simply reactive programming using functional programming style.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: FRP简单来说就是使用函数式编程风格的响应式编程。
- en: EventStreams and properties (don't get these confused with object properties)
    are the building blocks of FRP. Let's look at an overview of what both these terms
    mean.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: EventStreams和属性（不要与对象属性混淆）是FRP的构建块。让我们来看看这两个术语的含义概述。
- en: EventStreams
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EventStreams
- en: An EventStream represents a stream of events. Events in an EventStream may happen
    at any time and need not occur synchronously.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: EventStream代表事件流。EventStream中的事件可能在任何时间发生，不需要同步发生。
- en: Let's understand EventStreams by comparing them to events in an event-driven
    pattern. Just like we subscribe to events in an event-driven pattern, we subscribe
    to EventStreams in FRP. Unlike events in event-driven programming, the power of
    EventStreams is that they can be merged, concatenated, combined, zipped, filtered,
    or transformed in any number of ways before you handle and act on the events.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将EventStream与事件驱动模式中的事件进行比较，让我们来理解EventStreams。就像我们在事件驱动模式中订阅事件一样，我们在FRP中订阅EventStreams。与事件驱动编程中的事件不同，EventStream的力量在于它们可以在你处理和操作事件之前以任何方式合并、连接、组合、连接、过滤或转换。
- en: In functional programming, data is immutable, so merging, concatenating, combining,
    zipping, filtering, or transforming an EventStream creates a new EventStream instead
    of modifying the existing one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，数据是不可变的，因此合并、连接、组合、连接、过滤或转换EventStream会创建一个新的EventStream，而不是修改现有的一个。
- en: 'Here is a diagram that shows how an EventStream representing the click event
    of a UI element would look:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个图表，展示了代表UI元素点击事件的EventStream看起来会是什么样子：
- en: '![EventStreams](img/B05154_07_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![EventStreams](img/B05154_07_01.jpg)'
- en: 'This EventStream can be merged with any other stream. Here is a diagram that
    shows how it looks when two EventStreams are merged:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个EventStream可以与任何其他流合并。下面是一个图表，展示了当两个EventStreams合并时的样子：
- en: '![EventStreams](img/B05154_07_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![EventStreams](img/B05154_07_02.jpg)'
- en: Merging can be useful when we want to apply the same action when an event occurs
    to two different EventStreams. Instead of subscribing and attaching a callback
    to two different EventStreams, we can now subscribe to a single EventStream, eliminating
    duplicate code and making it easy to update code. Merging can be useful in various
    other cases as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在两个不同的EventStreams上发生事件时应用相同的操作时，合并可能很有用。我们不再需要订阅和附加两个不同的EventStreams的回调，现在我们可以订阅一个单一的EventStream，消除重复代码，并使代码更新变得容易。合并在其他情况下也可能很有用。
- en: Properties
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: A property represents a value that changes over time. Properties can be used
    as an alternative to JavaScript variables whose values change in response to asynchronous
    activities and data updates. For example, you can use properties to represent
    the total number of times a button was clicked, the total number of logged-in
    users, and so on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 属性代表随时间变化的值。属性可以用作替代JavaScript变量的选择，这些变量的值会根据异步活动和数据更新而变化。例如，您可以使用属性来表示按钮被点击的总次数、登录用户总数等。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Properties are also called signals or behaviors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也被称为信号或行为。
- en: The advantage of using properties instead of JavaScript variables is that you
    can subscribe to properties, that is, whenever the value of a property changes,
    a callback is fired to update the parts of the system that depend on it. This
    prevents code duplication and has many other benefits.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性而不是JavaScript变量的优点是您可以订阅属性，也就是说，每当属性的值发生变化时，就会触发一个回调来更新依赖于它的系统部分。这可以防止代码重复，并具有许多其他优点。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can create a property from another property as well as merge, combine, zip,
    sample, filter, or transform properties.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从一个属性创建另一个属性，以及合并、组合、压缩、筛选或转换属性。
- en: We've just looked at the basics of FRP. Creating EventStreams and properties,
    their methods, and other things to work with them differ depending on the library
    we use to write functional reactive code. Now, let's explore how to write functional
    reactive code using the Bacon.js library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解了FRP的基础知识。创建EventStreams和属性，以及使用它们的方法和其他相关内容，这取决于我们用来编写函数式响应式代码的库。现在，让我们探索如何使用Bacon.js库来编写函数式响应式代码。
- en: FRP using Bacon.js
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bacon.js进行FRP
- en: '**Bacon.js** is a JavaScript library that helps us write functional reactive
    code in JavaScript. It can be used for both frontend and backend JavaScript. The
    official website of Bacon.js library is [https://baconjs.github.io/](https://baconjs.github.io/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bacon.js**是一个JavaScript库，它帮助我们用JavaScript编写函数式响应式代码。它可以用于前端和后端JavaScript。Bacon.js库的官方网站是[https://baconjs.github.io/](https://baconjs.github.io/)。'
- en: Let's create a basic website project to demonstrate FRP with Bacon.js.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的网站项目来演示使用Bacon.js的FRP。
- en: Setting up the project
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: Let's learn how to download and install Bacon.js for use with frontend and backend
    JavaScript. On the frontend, Bacon.js depends on jQuery.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何下载和安装Bacon.js，以便与前端和后端JavaScript一起使用。在前端，Bacon.js依赖于jQuery。
- en: Create a directory named `baconjs-example`. Inside it, create files called `package.json`
    and `app.js` and a directory called `public`. Inside the `public` directory, create
    directories called `html` and `js`. Inside the `html` directory, create a file
    called `index.html`. Finally, inside the `js` directory, create a file called
    `index.js`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`baconjs-example`的目录。在其内部，创建名为`package.json`和`app.js`的文件，以及一个名为`public`的目录。在`public`目录内部，创建名为`html`和`js`的目录。在`html`目录内部，创建一个名为`index.html`的文件。最后，在`js`目录内部，创建一个名为`index.js`的文件。
- en: Download the frontend Bacon.js library from [http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js](http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js)
    and jQuery from [https://code.jquery.com/jquery-2.2.0.min.js](https://code.jquery.com/jquery-2.2.0.min.js),
    and place them in the `js` directory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js](http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js)下载前端Bacon.js库和jQuery[https://code.jquery.com/jquery-2.2.0.min.js](https://code.jquery.com/jquery-2.2.0.min.js)，并将它们放置在`js`目录下。
- en: At the time of writing this book, 0.7.73 was the latest version of the frontend
    Bacon.js library, and 2.2.0 was the latest version of jQuery.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，0.7.73是前端Bacon.js库的最新版本，2.2.0是jQuery的最新版本。
- en: 'In the `index.html` file, place this code to enqueue jQuery and the frontend
    Bacon.js library:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，放置以下代码以排队jQuery和前端Bacon.js库：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `package.json` file, place this code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中，放置以下代码：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, run `npm install` inside the `baconjs-example` directory to download the
    npm packages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`baconjs-example`目录中运行`npm install`以下载npm包。
- en: At the time of writing this book, 0.7.83 was the latest version of backend Bacon.js
    library.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，0.7.83是后端Bacon.js库的最新版本。
- en: 'In the `app.js` file, place the following code to import the backend Bacon.js
    and Express modules. It also starts our webserver in order to serve the web page
    and static files:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`文件中，放置以下代码以导入后端Bacon.js和Express模块。它还启动我们的web服务器以提供网页和静态文件：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have now set up a basic Bacon.js project. Run `node app.js` to start the
    web server. Now, let's explore Bacon.js APIs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了一个基本的Bacon.js项目。运行`node app.js`以启动web服务器。现在，让我们探索Bacon.js API。
- en: Bacon.js APIs
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bacon.js API
- en: Bacon.js provides APIs to do almost anything that's possible using EventStreams
    and properties. The method of importing and downloading Bacon.js for the backend
    and frontend is different, but the APIs are the same for both. Let's look at the
    most important APIs provided by Bacon.js.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js提供了API来执行几乎可以使用事件流和属性完成的任何事情。后端和前端导入和下载Bacon.js的方法不同，但API对两者都是相同的。让我们看看Bacon.js提供的最重要的API。
- en: Creating EventStreams
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建事件流
- en: There are various ways of creating EventStreams, depending on how an asynchronous
    API is designed, that is, which pattern an asynchronous API follows. An asynchronous
    API follows the event-driven, promise, or callback pattern. We need to wrap these
    patterns with Bacon-provided APIs to connect their data updates or activity updates
    to event streams, that is, convert them to functional reactive patterns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据异步API的设计方式，即异步API遵循哪种模式，有各种创建EventStreams的方法。异步API遵循事件驱动、promise或回调模式。我们需要使用Bacon提供的API将这些模式包装起来，以便将它们的数据更新或活动更新连接到事件流，即转换为功能性响应式模式。
- en: 'If we want to create an EventStream for a UI element on a web page, we can
    use the `$.asEventStream()` method. Let''s look at an example of how it works.
    Place the following code in the `<body>` tag of the `index.html` file to create
    a button:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在网页上的UI元素上创建一个事件流，我们可以使用`$.asEventStream()`方法。让我们看看它是如何工作的示例。将以下代码放置在`index.html`文件的`<body>`标签中以创建一个按钮：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In an event-driven pattern, to print something whenever a button is clicked,
    we would write something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动模式中，每当按钮被点击时打印一些内容，我们会编写如下内容：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But in Bacon.js, we will write it this way. Place this code in the `index.js`
    file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Bacon.js中，我们将这样编写。将此代码放置在`index.js`文件中：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we use a jQuery selector to point to the button, and we then use the `$.asEventStream`
    method to connect its click events to an EventStream. The `$.asEventStream` method
    takes the name of the event as its first parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用jQuery选择器指向按钮，然后使用`$.asEventStream`方法将其点击事件连接到事件流。`$.asEventStream`方法接受事件名称作为其第一个参数。
- en: The `onValue` method is used to add subscribers to an EventStream. The `onValue`
    method of an EventStream takes a callback, which is executed every time a new
    event is added to the EventStream. The callback has a single parameter, which
    represents the current event that has been added to the EventStream. In this case,
    it's of the event interface. We can call the `onValue` method multiple times to
    add multiple callbacks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`onValue`方法用于向事件流添加订阅者。事件流的`onValue`方法接受一个回调，该回调在每次向事件流添加新事件时执行。回调有一个单一参数，表示已添加到事件流中的当前事件。在这种情况下，它是事件接口。我们可以多次调用`onValue`方法来添加多个回调。'
- en: A subscriber can be used to update the UI, perform logging, and so on. But the
    logic code for handling the event should be written using the helper functions
    and not be inside the subscriber. This is how functional reactive code is supposed
    to be written.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者可用于更新UI、执行日志记录等。但处理事件的逻辑代码应使用辅助函数编写，而不是在订阅者内部。这就是功能性响应式代码应该编写的方式。
- en: The subscriber callback will not be invoked for events that occurred before
    the subscriber was registered.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在订阅者注册之前发生的事件，订阅者回调不会被调用。
- en: 'Similarly, there are lots of other APIs provided by Bacon.js to create EventStreams.
    Here are a few of them:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Bacon.js提供了许多其他API来创建EventStreams。以下是一些：
- en: '`Bacon.fromPromise`: This is used to create an EventStream from a promise object.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromPromise`：此方法用于从promise对象创建事件流。'
- en: '`Bacon.fromEvent`: This is used to create an EventStream from events of an
    EventTarget or Node.js EventEmitter object.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromEvent`：此方法用于从EventTarget或Node.js EventEmitter对象的事件创建事件流。'
- en: '`Bacon.fromCallback`: This is used to create an EventStream from a function
    that accepts a callback.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromCallback`：这是用于从一个接受回调函数的函数创建事件流。'
- en: '`Bacon.fromNodeCallback`: This is the same as `Bacon.fromCallback`, but it
    requires the callback to be called in Node.js convention.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromNodeCallback`：这与`Bacon.fromCallback`相同，但它要求回调按照Node.js约定进行调用。'
- en: '`Bacon.fromBinder`: If none of the previous APIs are fitting well, then you
    can use this one.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromBinder`：如果前面的API都不太适合，那么你可以使用这个。'
- en: Creating properties
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建属性
- en: A property is created from an EventStream, that is, a stream whose events the
    value of the property depends on. Whenever an event occurs in the EventStream,
    a callback is executed to update the property value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是从事件流创建的，即属性的值依赖于其事件的流。每当事件流中发生事件时，都会执行一个回调来更新属性值。
- en: You can create a property for an EventStream using either the `toProperty` or
    `scan` methods. The `scan` method is used instead of `toProperty` when we want
    to give an initial value as well as an accumulator function to the property. You
    may or may not provide an initial value when creating a property using `toProperty`().
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`toProperty`或`scan`方法为事件流创建一个属性。当我们想要为属性提供一个初始值以及累加函数时，我们会使用`scan`方法而不是`toProperty`。在使用`toProperty`()创建属性时，你可能或可能不提供初始值。
- en: Calling `scan` or `toProperty` multiple times create multiple properties.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 多次调用`scan`或`toProperty`会创建多个属性。
- en: 'Let''s create a property to hold the total number of times a button is clicked.
    Here is the code to do this; place it in the `index.js` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个属性来保存按钮被点击的总次数。以下是实现这一功能的代码；将其放置在`index.js`文件中：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we created a property using the `scan` method and initialized it to `0`.
    The second argument is a callback, which is invoked to update the property value
    whenever an event happens in the EventStream to which the property is attached.
    This callback should return the new property value. The callback has two parameters,
    that is, the current value of the property and the event.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`scan`方法创建了一个属性，并将其初始化为`0`。第二个参数是一个回调函数，当属性附加的事件流中发生事件时，该回调函数会被调用以更新属性值。这个回调函数应该返回新的属性值。该回调函数有两个参数，即属性的当前值和事件。
- en: The `onValue` method of a property takes a callback that is executed every time
    the property value changes. We can call the `onValue` method multiple times to
    register multiple callbacks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的`onValue`方法接受一个回调函数，该函数在属性值每次变化时都会执行。我们可以多次调用`onValue`方法来注册多个回调。
- en: When we register a subscriber for a property, the subscriber is executed with
    the current value as soon as it's registered, but not for the values that occurred
    before it had been registered. If the property has not yet been assigned to anything,
    then the callback is not executed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为属性注册一个订阅者时，订阅者会立即以当前值执行，但不会为注册之前发生的事件值执行。如果属性尚未分配给任何东西，则不会执行回调。
- en: Here, whenever the property value changes, we log a statement informing us about
    the total number of times the button was clicked.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当属性值发生变化时，我们都会记录一条语句，告知我们按钮被点击的总次数。
- en: 'A property can also be created from another property. This is useful when a
    property''s value depends on another property. Let''s create a property from the
    previous property, which holds the time at which the property was last clicked
    and the button click count at that time. Here is the code to do this; place it
    in the `index.js` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个属性也可以从另一个属性创建。当属性值依赖于另一个属性时，这很有用。让我们从一个之前的属性创建一个属性，该属性保存了属性最后一次被点击的时间和当时按钮的点击次数。以下是实现这一功能的代码；将其放置在`index.js`文件中：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Everything here is self-explanatory. The only thing you need to know is that
    the second parameter of the second argument passed to the `scan` method represents
    the value of the property we used to create this property.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一切都是不言自明的。你需要知道的是，传递给`scan`方法的第二个参数代表了我们用来创建这个属性的属性值。
- en: A property holds a stream that has all of its previous and current values internally;
    therefore, we can also merge, combine, zip, sample, filter, and transform properties.
    Merging, combining, zipping, sampling, filtering, or transforming properties gives
    us new properties. This feature is useful for writing code for the more complex
    situation of a property's value depending on another property. For example, if
    we want to ignore some values of a property while calculating the value of another
    property based on it, then we can use filter feature.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 属性内部持有包含所有先前和当前值的流；因此，我们也可以合并、组合、连接、采样、过滤和转换属性。合并、组合、连接、采样、过滤或转换属性会给我们带来新的属性。这个特性对于编写一个属性的值依赖于另一个属性的情况下的代码非常有用。例如，如果我们想忽略属性的一些值，同时根据它计算另一个属性的值，那么我们可以使用过滤功能。
- en: Bacon.js also allows us to create EventStreams based on properties, that is,
    the events of an EventStream represent the values of a property. Events in these
    EventStreams occur when their respective property value is changed. This feature
    has many benefits, one of which is that it can prevent code duplication when we
    have to trigger the same action in response to several properties changing their
    values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js 还允许我们根据属性创建 EventStreams，也就是说，EventStream 中的事件代表属性的值。当相应属性的值发生变化时，这些
    EventStream 中的事件会发生。这个特性有很多好处，其中之一是当我们需要对多个属性值的变化触发相同动作时，它可以防止代码重复。
- en: To create EventStreams based on properties, we can use the `toEventStream` method
    of a property.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据属性创建 EventStreams，我们可以使用属性的 `toEventStream` 方法。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Retrieving the latest value of a property**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取属性的最新值**'
- en: There is no method to obtain the latest value of a property, and there will
    be. You obtain the value by subscribing to the property and handling the values
    in your callback. If you need the value of more than one source, use one of the
    `combine` methods. This is how functional reactive code using Bacon.js is supposed
    to be written.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 没有方法可以直接获取属性的最新值，但将来会有。你可以通过订阅属性并在回调中处理值来获取值。如果你需要多个来源的值，请使用 `combine` 方法之一。这就是使用
    Bacon.js 编写的函数式响应式代码应该被编写的方式。
- en: Merging, filtering, and transforming EventStreams and properties
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并、过滤和转换 EventStreams 和属性
- en: Bacon.js provides various helper functions to work with EventStreams and properties.
    Let's look at some of the most useful helper functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js 提供了各种辅助函数来处理 EventStreams 和属性。让我们看看一些最有用的辅助函数。
- en: Merging
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合并
- en: '**Merging** streams or properties gives us a new stream or property that delivers
    all the events or values of all the streams or properties. To merge EventStreams
    or properties, we can use their `Bacon.mergeAll` method instances. Here is some
    example code to demonstrate this. Place it in the `index.js` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并**流或属性会给我们一个新的流或属性，它传递所有流或属性的每个事件或值。要合并 EventStreams 或属性，我们可以使用它们的 `Bacon.mergeAll`
    方法实例。以下是一些示例代码，用于演示这一点。将其放置在 `index.js` 文件中：'
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we merge two properties. `Bacon.mergeAll` takes an array of either EventStreams
    or properties. Whenever the value of either of the two properties changes, the
    value is made the current value of the resultant property.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们合并了两个属性。`Bacon.mergeAll` 接收一个包含 EventStreams 或属性的数组。当这两个属性中的任何一个的值发生变化时，该值将成为结果属性的当前值。
- en: There are various other helper functions available for merging properties and
    EventStreams.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他各种辅助函数可用于合并属性和 EventStreams。
- en: Filtering
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤
- en: '**Filtering** is removing specific events or values from EventStreams or properties,
    respectively, that we don''t need.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤**是从 EventStreams 或属性中移除我们不需要的特定事件或值。'
- en: Bacon.js provides a lot of helper functions to filter EventStreams and properties,
    depending on what you want to filter. Let's look at the `filter` method for EventStreams
    and properties that lets us filter based on a predicate function; that is, if
    the function returns `true`, then the value is accepted; otherwise, it is rejected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js 提供了许多辅助函数来过滤 EventStreams 和属性，具体取决于您想要过滤的内容。让我们看看 EventStreams 和属性的
    `filter` 方法，它允许我们根据谓词函数进行过滤；也就是说，如果函数返回 `true`，则接受该值；否则，拒绝该值。
- en: 'Let''s look at example code to demonstrate this. In the `index.js` file, find
    this code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例代码来演示这一点。在 `index.js` 文件中，找到以下代码：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Replace that with this code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为以下代码：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are filtering all those click events in which we didn't press the *Shift*
    key. So, for the click event to be accepted, we need to press the *Shift* key
    while clicking on the button.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在过滤掉所有那些没有按下 *Shift* 键的点击事件。因此，为了使点击事件被接受，我们需要在点击按钮时按下 *Shift* 键。
- en: You can think of filtering as an alternative to using the `if…else` conditional.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将过滤视为使用 `if…else` 条件语句的替代方案。
- en: Transforming
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转换
- en: '**Transforming** is creating an EventStream or property from another EventStream
    or property, respectively, whose events are transformed to something else. For
    example, a property whose value represents a URL can be transformed to another
    property, whose value represents the response of the URL. Transforming EventStreams
    and properties actually creates new EventStreams and properties, respectively.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换**是从另一个 EventStream 或属性创建一个 EventStream 或属性，其事件被转换成其他东西。例如，一个表示 URL 的值的属性可以被转换成另一个表示
    URL 响应的属性。转换 EventStreams 和属性实际上创建了新的 EventStreams 和属性。'
- en: You can think of transforming as an alternative to loops, that is, to using
    `for` loops.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将转换视为循环的替代方案，即使用 `for` 循环。
- en: There are several helper functions provided by Bacon.js for transformation depending
    on how and what you want to transform.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js 提供了几个辅助函数，用于根据您想要如何以及转换什么来进行转换。
- en: 'One popular transformation function is `map()`, which maps events or values
    of EventStreams or properties to a function. Let''s look at a code sample to demonstrate
    this. Find this code in the `index.js` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的转换函数是 `map()`，它将事件或 EventStreams 或属性的值映射到一个函数。让我们通过一个代码示例来展示这一点。在 `index.js`
    文件中找到此代码：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace it with this code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为以下代码：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are using `map()` to transform the Unix timestamp to the HH:MM format,
    which is easy to understand.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `map()` 将 Unix 时间戳转换为 HH:MM 格式，这使得理解变得简单。
- en: 'There is another, vital transformation helper function provided by Bacon.js
    called `flatMap`. There are basically two differences between `flatMap` and `map`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js 还提供了一个名为 `flatMap` 的另一个重要转换辅助函数。`flatMap` 和 `map` 之间基本上有两个区别：
- en: The `flatMap` function always returns an EventStream regardless of whether it
    was called on a EventStream or property.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap` 函数始终返回一个 EventStream，无论它是在 EventStream 或属性上调用。'
- en: If the callback passed to `flatMap` returns an EventStream or property, then
    the events of the EventStream returned by the `flatMap` function are events and
    values of the streams and properties returned by the callback passed to `flatMap`.
    Whenever an event or value is added to the streams and properties returned by
    the callback passed to `flatMap`, the event and value will automatically be added
    to the EventStream returned by the `flatMap` function.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递给 `flatMap` 的回调返回一个 EventStream 或属性，那么 `flatMap` 函数返回的 EventStream 的事件就是回调传递给
    `flatMap` 的流和属性的值。每当回调传递给 `flatMap` 的流和属性中添加事件或值时，事件和值将自动添加到 `flatMap` 函数返回的 EventStream
    中。
- en: You need to use `flatMap` instead of `map` when retrieving the return value
    of a callback passed to a network, disk drive, or somewhere else asynchronous.
    For example, in the previous example, where I talked about transforming a URL
    to a URL response, we need to use `flatMap` instead of `map` as instead of a callback,
    we need to make an AJAX request, and its response will be captured as a stream,
    and the stream will be returned. When the AJAX request completes, the event will
    be put inside the stream returned by the `flatMap` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当从传递给网络、磁盘驱动器或其他异步位置传递的回调中检索返回值时，您需要使用 `flatMap` 而不是 `map`。例如，在上一个示例中，我提到将 URL
    转换为 URL 响应时，我们需要使用 `flatMap` 而不是 `map`，因为我们需要进行 AJAX 请求，其响应将被捕获为流，并且流将被返回。当 AJAX
    请求完成时，事件将被放入 `flatMap` 函数返回的流中。
- en: 'Let''s look at an implementation of this example. First, create an input text
    field and place it in the `index.html` file, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个示例的实现。首先，创建一个输入文本字段，并将其放置在 `index.html` 文件中，如下所示：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s write code using Bacon.js to log the output of the URL entered
    in the field when a user hits the *Enter* key. Here is the code to do this. Place
    it in the `index.js` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Bacon.js 编写代码来记录当用户按下 *Enter* 键时在字段中输入的 URL 的输出。以下是执行此操作的代码。将其放置在 `index.js`
    文件中：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is how the code works:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作原理：
- en: First, we create an EventStream for the `keyup` event.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个用于 `keyup` 事件的 EventStream。
- en: Then, we filter only *Enter*-key events because we will take action only if
    the *Enter* key is pressed.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们只过滤 *Enter* 键事件，因为我们只有在 *Enter* 键被按下时才会采取行动。
- en: Then, we create a variable to hold the value of the text field.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个变量来保存文本字段的值。
- en: Then, we use `flatMap` to fetch the response of the URL using jQuery AJAX. We
    are using `Bacon.fromPromise` to create an EventStream from a promise.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `flatMap` 通过 jQuery AJAX 获取 URL 的响应。我们使用 `Bacon.fromPromise` 将承诺创建为
    EventStream。
- en: When the AJAX request finishes, it adds the response to the EventStream returned
    by the callback passed to `flatMap`. Then, `flatMap` adds the same response to
    the EventStream returned by the `flatMap` function itself. As soon as it's added,
    we log the response using `onValue`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 AJAX 请求完成时，它将响应添加到传递给 `flatMap` 的回调函数返回的 EventStream 中。然后，`flatMap` 将相同的响应添加到
    `flatMap` 函数本身返回的 EventStream 中。一旦添加，我们就使用 `onValue` 记录响应。
- en: Here, if we had used `map` instead of `flatMap`, then we would have ended up
    logging EventStream objects instead of the events of the EventStream returned
    by the `map` function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们使用了 `map` 而不是 `flatMap`，那么我们最终会记录 EventStream 对象而不是 `map` 函数返回的 EventStream
    的事件。
- en: Although we can have both `url` and `response` properties directly created from
    the `enter_key_click_stream`, it is likely to cause code repetition and make the
    code difficult to understand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以直接从 `enter_key_click_stream` 中创建 `url` 和 `response` 属性，但这很可能会引起代码重复，并使代码难以理解。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you call a method to transform, filter, or do something else with EventStreams,
    then the events that occurred before the method call are not taken into account.
    However, in the case of a property, the current value is taken into account, but
    not the values that occurred before the method call. If the property has not yet
    been assigned to anything, nothing is taken into account.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个方法来转换、过滤或对 EventStreams 执行其他操作时，那么在方法调用之前发生的事件不会被考虑。然而，在属性的情况下，当前值会被考虑，但不会考虑方法调用之前发生的数据。如果属性尚未分配给任何东西，则不考虑任何内容。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We looked at reactive programming, functional programming, FRP, and finally
    an overview of Bacon.js. You should now be comfortable with writing basic functional
    reactive code and have a clear idea of its benefits.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了响应式编程、函数式编程、FRP，以及最终对 Bacon.js 的概述。你现在应该已经能够舒适地编写基本的函数式响应式代码，并对它的好处有清晰的认识。
- en: We will learn about more of the APIs provided by Bacon.js and build a real-world
    project using Bacon.js in the next chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多由 Bacon.js 提供的 API，并使用 Bacon.js 构建一个真实世界的项目。
