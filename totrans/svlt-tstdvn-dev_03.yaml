- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading Data into a Route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`/birthdays` route that we’ll work on in this chapter. Part of that routing
    is ensuring that the route has the data available to it. In this chapter, you’ll
    see how you can test-drive SvelteKit’s `load` function for pulling that data into
    a component.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also see how Playwright can be used to build an end-to-end test that
    proves all the various components of this system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Playwright to specify end-to-end behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding an approach to make the end-to-end test pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driving the load function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driving the page component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have test-driven a functioning SvelteKit route
    that you can view in your web browser, and you’ll have learned the key differences
    between Playwright end-to-end tests and Vitest unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start).
  prefs: []
  type: TYPE_NORMAL
- en: Using Playwright to specify end-to-end behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will write your first Playwright test and learn about the
    various function calls within it, and you’ll learn about differentiating between
    Playwright end-to-end tests and Vitest unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the test and watching it fail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The test we are going to write is entitled `lists all birthdays` and it will
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to the `/``birthdays` location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for the text `Hercules` and `Athena`, which it will take as evidence that
    the test has passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the test is in place, we’ll stop to think about how this `Hercules` and
    `Athena` data should get into our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `tests/birthdays.test.js` and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see some things here that are similar to the Vitest tests, such as the
    use of `expect` and the `toBeVisible` matcher.
  prefs: []
  type: TYPE_NORMAL
- en: However, some things are different. For a start, the test is marked as `async`
    and all the function calls (including the `expect` function calls) are marked
    with `await`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s necessary because Playwright is driving a headless browser, meaning
    it’s started a real browser process that runs in the background and is invisible
    to you. Playwright has no mechanism for determining when the browser has completed
    working, beyond waiting patiently and frequently checking the browser state. Therefore,
    most of its internal logic is driven by waits and timeouts: the browser is given
    a certain amount of time, generally a few seconds, to get things displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: The `page.goto` call is instructing this headless browser to navigate to the
    `/birthdays` endpoint. Playwright takes care of spinning up a real dev server
    in the background and ensuring that any relative URLs (such as `/birthdays`) are
    converted to absolute URLs pointing at this dev server (like `https://localhost:5173/birthdays`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run the test now, using the `npm test` shell command. You should
    see an almost immediate failure appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the test complete, let’s take a more detailed look at the difference between
    Vitest tests and Playwright tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between Vitest tests and Playwright tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are fundamental differences between how Vitest tests work and how Playwright
    tests work. Both play their part in TDD.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.1* shows how each type of test encompasses your code. Playwright
    tests are often referred to as end-to-end tests and they are high-level, with
    each test exercising a whole lot of code. Vitest tests are often called unit tests.
    They are very detailed and exercise just a small piece of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – End-to-end tests and unit tests in a SvelteKit project](img/Figure_3.1_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – End-to-end tests and unit tests in a SvelteKit project
  prefs: []
  type: TYPE_NORMAL
- en: Playwright tests are often a good starting point when embarking on building
    a new feature. They may even be written by project stakeholders who are not developers
    but still participate in defining features. In [*Chapter* *13*](B19611_13.xhtml#_idTextAnchor148),
    *Adding Cucumber Tests*, we’ll see how this can be done with plain English syntax
    rather than JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Playwright tests are often written against the browser UI. They exercise the
    whole system, including the web browser and any out-of-process resources such
    as databases. When working with a SvelteKit application, the Playwright test runner
    starts up the SvelteKit web server and executes all of the SvelteKit runtime code
    for managing routes.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the Vitest test runner does not load up the SvelteKit web server
    and does not execute any of its code. Instead, it loads your JavaScript files
    directly into the same Node process that Vitest and your test suites are loaded
    into.
  prefs: []
  type: TYPE_NORMAL
- en: While Playwright tests are good for focusing a team on what needs to be built,
    they often have nothing to say about the internal design of the software or even
    the architecture of the system as a whole. This is where Vitest unit tests come
    in. They can be used by developers to work out the *how* of a system.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways that unit tests help with design. For example, if
    a unit test is proving difficult to write, that’s sometimes a sign that the application
    design is too complex. Breaking apart the units in a different way can lead to
    the unit tests becoming much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Playwright tests are often kept low on specifics leaving the unit tests to cover
    the details. For example, in the test we just wrote, we are interested in the
    listing of the birthdays that the system knows about but notice that we only checked
    by looking for the names of people, and not the birthdays. We leave the complete
    birthday checks to the unit tests for the `Birthday` component, which we already
    wrote in [*Chapter 2*](B19611_02.xhtml#_idTextAnchor036), *Introducing the* *Red-Green-Refactor
    Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we end up with lots of low-level Vitest unit tests and a few higher-level
    Playwright tests. This is the classic test automation pyramid as described by
    Mike Cohn in the book *Succeeding with Agile*. It encourages a testing strategy
    that includes many unit tests, some service tests, and just a dollop of UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.2* shows how the test automated pyramid can be applied to SvelteKit
    projects. Playwright end-to-end tests can be written against both the UI and also
    against specific API endpoints, and your unit tests are written for the Vitest
    runner.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The testing pyramid as applied to SvelteKit projects](img/Figure_3.2_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The testing pyramid as applied to SvelteKit projects
  prefs: []
  type: TYPE_NORMAL
- en: One reason for structuring automated tests in this way is that unit tests are
    cheap to create and maintain, whereas UI tests are expensive in terms of time
    and energy put into them.
  prefs: []
  type: TYPE_NORMAL
- en: The service tests are like the UI tests in that they cover a whole flow through
    a system but avoid the UI. For example, they may call HTTP API endpoints directly.
    That can be helpful because the UI tends to be the most brittle component of the
    system, and driving a UI can take a while as you wait for the on-screen changes
    to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Modern web browser environments, together with modern test runners such as Playwright,
    have gotten much better at handling automated UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason the classic test automation pyramid makes sense is that unit
    tests are often very fast to execute. You can have many unit tests, each of which
    executes just a tiny fraction of the code surface. When one of those tests breaks,
    it’s very quick to read the test description or test code and figure out where
    in the application code the failure lies.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth remembering that unit tests serve to document all of the technical
    design decisions taken when writing the code, and this documentation is invaluable
    in understanding the history of a project.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep in mind that Vitest unit tests do not test the SvelteKit server-side
    runtime environment. That means, for example, that a Vitest unit test can test
    that you correctly defined a `load` function, but it cannot test that the route
    is hooked up correctly. For that, you need a Playwright test that compiles and
    runs your components and routes just as if it was a real browser environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding an approach to make the end-to-end test pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that all said, how do we begin writing Vitest unit tests now that we have
    a Playwright test that defines what we want?
  prefs: []
  type: TYPE_NORMAL
- en: The Playwright test looks for the names `Hercules` and `Athena`. The test makes
    an assumption that these two people have their birthdays listed in the system
    and that the page at `/birthdays` lists them. But how do we get them into the
    system in the first place?
  prefs: []
  type: TYPE_NORMAL
- en: In true TDD style, we can defer this decision and simply hardcode these two
    birthdays in the system. After all, the test doesn’t seem to care about how the
    data gets into the system, only about how it is presented.
  prefs: []
  type: TYPE_NORMAL
- en: We can come back to how the birthdays are added later. In fact, we’ll do this
    in [*Chapter 8*](B19611_08.xhtml#_idTextAnchor100), *Creating Matchers to Simplify
    Tests*. We can also make use of our `Birthday` component from [*Chapter 2*](B19611_02.xhtml#_idTextAnchor036),
    *Introducing the Red-Green-Refactor Workflow*, to display each birthday in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, what we need to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `load` function that returns hardcoded birthday data for Hercules and
    Athena. This needs to exist within the `src/routes/birthdays/+page.server.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `page` component that takes the data from `load` and displays a `Birthday`
    component for each of the birthdays given. This needs to exist as `src/routes/birthdays/+page.svelte`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SvelteKit takes care of matching the `/birthdays` route to our files in the
    `src/routes/birthdays` directory. After calling `load`, it will pass the result
    into the `data` prop in the `+``page.svelte` component.
  prefs: []
  type: TYPE_NORMAL
- en: That covers how to write a basic Playwright end-to-end test. We’ve discussed
    the differences between Playwright end-to-end and Vitest unit tests, and we’ve
    come up with a plan for the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers how to test-drive a basic, hardcoded version of our
    `load` function.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving the load function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve decided to implement a `load` function that returns hardcoded
    birthday data for Hercules and Athena, the actual change has become very simple.
  prefs: []
  type: TYPE_NORMAL
- en: The `load` function is a special SvelteKit function that will be invoked when
    a request comes in for the given route. So, when the user navigates to the `/birthdays`
    route, SvelteKit calls the `load` function in the `src/routes/birthdays/+page.server.js`
    file and then renders the component in the `src/routes/birthdays/+page.svelte`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create the `load` function using TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Vitest test file named `src/routes/birthdays/page.server.test.js`
    and start it off as shown. We are importing the `load` function from a `+page.server.js`
    file that doesn’t yet exist. We call the function in our test and store the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Naming describe blocks for load functions
  prefs: []
  type: TYPE_NORMAL
- en: I’ve named the `describe` block `/birthdays - load`, which demonstrates a standard
    naming pattern that can be used for the `load` functions for routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the test with the following expectation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One expectation per test
  prefs: []
  type: TYPE_NORMAL
- en: This entire test contains just a single call to `expect`. Generally, when writing
    tests, I find it’s useful to stick to just one expectation if possible. That helps
    to keep a strong link between the test description and the contents of the `expect`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: It’s often the case (as in this test) that you can stuff a whole lot of checks
    in a single expectation.
  prefs: []
  type: TYPE_NORMAL
- en: The `toEqual` matcher has a special *deep equality* mechanism that means each
    level of an object or array can be checked for its value, rather than its identity.
    And moreover, we can use constraint functions such as `objectContaining`, which
    we’ll see in [*Chapter 6*](B19611_06.xhtml#_idTextAnchor079), *Editing* *Form
    Data*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run the test with your Vitest test runner. This gives the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do as it suggests and create an empty file at the `src/routes/birthdays/+page.server.js`
    location, and then rerun your tests. You should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Okay, marvelous: `load is not a function`. Let’s create a basic `load` function,
    then, with absolutely nothing in it. Add this to the new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerun your tests. You’ll get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To fix the issue, all we need to do is fill in the hardcoded values. Update
    the code in `src/routes/birthdays/+page.server.js` to look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Plumbing and hardcoded values
  prefs: []
  type: TYPE_NORMAL
- en: It may feel a bit pointless doing this, but the value is in getting the plumbing
    into place. The test we’ve written here will serve as a useful regression test
    when we come to fill in the *real* implementation, which does more than simply
    return hardcoded data. (We’ll improve upon this implementation in [*Chapter 4*](B19611_04.xhtml#_idTextAnchor060),
    *Saving* *Form Data*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your tests again and you’ll see the test succeeds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes a working `load` function. You’ve now covered the basics of test-driving
    a route’s `load` function so that it meets SvelteKit’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can build the `page` component for the route.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving the page component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to create the `page` component that exists for the route. As ever,
    we’ll start with a test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `src/routes/birthdays/page.test.js` file and add the following imports.
    The last of these is for the `page` component itself. Because SvelteKit expects
    the component for a route to exist in a file named `+page.svelte`, we may as well
    give the component the name `Page` (that is what it is, after all):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s write out the test. The key part here is that `Page` gets passed
    a `data` prop, which needs to match the structure of our `load` function. In the
    actual runtime environment, SvelteKit will invoke the `load` function and then
    render the component in `+page.svelte` with the `data` prop set to the result
    of the `load` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test data fixtures
  prefs: []
  type: TYPE_NORMAL
- en: Even though they have the same values, there’s no connection between the `birthdays`
    value set here and the hardcoded values in the `load` function. The `load` function
    will eventually lose its *seeded* data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go ahead and run the test now, you should see the usual failure of the
    missing file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an empty file at `src/routes/birthdays/+page.svelte`, and then run tests
    again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s time for the real implementation. Copy the following code, which uses
    the `data` prop to display an `ol` element with a `li` for each birthday. We use
    the `Birthday` component from [*Chapter 2*](B19611_02.xhtml#_idTextAnchor036),
    *Introducing the Red-Green-Refactor Workflow*, to display the birthday for each
    item in the `data.birthdays` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using HTML lists for testability
  prefs: []
  type: TYPE_NORMAL
- en: When rendering *arrays* of items as we have here, it’s always a good idea to
    use either an `ol` element (for an ordered list) or a `ul` element (for an unordered
    list) as the parent container, and then use `li` elements for each item in the
    list. Using list elements increases the testability of your components because
    you can use locator functions that look specifically for the `listitem` role,
    which we’ll see in [*Chapter 6*](B19611_06.xhtml#_idTextAnchor079), *Editing*
    *Form Data*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that we’re using the `Birthday` component to make our tests pass.
    But our test didn’t explicitly request a `Birthday` component; the expectations
    looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You could argue that the simplest way to make this test pass would be to simply
    print out the name of the birthday. But that would be ignoring the intent of our
    testing, which is to display a list of `Birthday` components.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 12*](B19611_12.xhtml#_idTextAnchor134)*, Using Component Mocks
    to Clarify Tests*, we will look at how we can use component mocks to explicitly
    state that we want to use a `Birthday` component here.
  prefs: []
  type: TYPE_NORMAL
- en: With the implementation complete, you can now verify your passing tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Vitest test runner and you should see that the test is now passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now also run Playwright and see your passing test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add some styles to the `src/routes/birthdays/+page.svelte` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run the dev server with `npm run dev`. Make a note of the base URL
    for your application and then fire up your browser, and load the `/birthdays`
    URL to check out your work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working out the path to load
  prefs: []
  type: TYPE_NORMAL
- en: 'The route we’ve built will end up at a location such as `https://localhost:5173/birthdays`.
    But the port number is likely to be different for you: you’ll need to run the
    `npm run dev` command and look for the base URL that is marked with the `Local`
    label.'
  prefs: []
  type: TYPE_NORMAL
- en: This section has shown you how you can test-drive a `page` component in a file
    named `+page.svelte`, which SvelteKit will render for you when you browse to a
    known route.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has shown you how to write an end-to-end test with Playwright and
    use that as a scaffold for your Vitest unit tests. The Playwright tests check
    that all the units are working together, and the framework is doing its job. The
    Vitest tests check that you are satisfying the contract required from SvelteKit,
    such as the `load` function working in the correct fashion.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve also seen how TDD can be used to delay design decisions that aren’t immediately
    relevant, like how we hardcoded sample data rather than implement any kind of
    persisted database of birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll expand on the same ideas by implementing a SvelteKit
    form action, enabling you to add new birthdays to the list.
  prefs: []
  type: TYPE_NORMAL
