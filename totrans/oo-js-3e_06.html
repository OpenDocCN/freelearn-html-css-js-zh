<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Prototype"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Prototype</h1></div></div></div><p>In this chapter, you'll learn about the prototype property of the function objects. Understanding how the prototype works is an important part of learning the JavaScript language. After all, JavaScript is often classified as having a prototype-based object model. There's nothing particularly difficult about the prototype, but it's a new concept, and as such, may sometimes take a bit of time to sink in. Like closures (see <a class="link" href="ch03.html" title="Chapter 3. Functions">Chapter 3</a>, <span class="emphasis"><em>Functions</em></span>), the prototype is one of those things in JavaScript which, once you get, seem so obvious and make perfect sense. As with the rest of this book, you're strongly encouraged to type in and play around with the examples - this makes it much easier to learn and remember the concepts.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Every function has a <code class="literal">prototype</code> property and it contains an object</li><li class="listitem" style="list-style-type: disc">Adding properties to the prototype object</li><li class="listitem" style="list-style-type: disc">Using the properties added to the prototype</li><li class="listitem" style="list-style-type: disc">The difference between own properties and properties of the prototype</li><li class="listitem" style="list-style-type: disc">The <code class="literal">__proto__</code> property, the secret link every object keeps to its prototype</li><li class="listitem" style="list-style-type: disc">Methods such as <code class="literal">isPrototypeOf()</code>, <code class="literal">hasOwnProperty()</code>, and <code class="literal">propertyIsEnumerable()</code></li><li class="listitem" style="list-style-type: disc">Enhancing built-in objects, such as arrays or strings, and why that can be a bad idea</li></ul></div><div class="section" title="The prototype property"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>The prototype property</h1></div></div></div><p>The functions in JavaScript are objects, and they contain methods and properties. Some of the methods that you're already familiar with are <code class="literal">apply()</code> and <code class="literal">call()</code>, and some of the other properties are <code class="literal">length</code> and <code class="literal">constructor</code>. Another property of the function objects is <code class="literal">prototype</code>.</p><p>If you define a simple function, <code class="literal">foo()</code>, you can access its properties as you would do with any other object. Consider the following code:</p><pre class="programlisting">    &gt; function foo(a, b) { &#13;
        return a * b; &#13;
      } &#13;
    &gt; foo.length; &#13;
    2 &#13;
    &gt; foo.constructor; &#13;
    function Function() { [native code] } &#13;
</pre><p>The <code class="literal">prototype</code> property is a property that is available to you as soon as you define the function. Its initial value is an empty object:</p><pre class="programlisting">    &gt; typeof foo.prototype; &#13;
    "object" &#13;
</pre><p>It's as if you have added this property yourself, as follows:</p><pre class="programlisting">    &gt; foo.prototype = {}; &#13;
</pre><p>You can augment this empty object with properties and methods. They won't have any effect on the <code class="literal">foo()</code> function itself; they'll only be used if you call <code class="literal">foo()</code> as a constructor.</p><div class="section" title="Adding methods and properties using the prototype"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Adding methods and properties using the prototype</h2></div></div></div><p>In the previous chapter, you learned how to define constructor functions that you can use to create (construct) new objects. The main idea is that, inside a function invoked with <code class="literal">new</code>, you will have access to the <code class="literal">this</code> value, which refers to the object to be returned by the constructor. Augmenting, which is adding methods and properties to <code class="literal">this</code>, is how you can add functionality to the object being constructed.</p><p>Let's take a look at the constructor function, <code class="literal">Gadget()</code>, which uses <code class="literal">this</code> to add two properties and one method to the objects it creates, as follows:</p><pre class="programlisting">    function Gadget(name, color) { &#13;
      this.name = name; &#13;
      this.color = color; &#13;
      this.whatAreYou = function () { &#13;
        return 'I am a ' + this.color + ' ' + this.name; &#13;
      }; &#13;
    } &#13;
</pre><p>Adding methods and properties to the <code class="literal">prototype</code> property of the constructor function is another way to add functionality to the objects this constructor produces. Let's add two more properties, <code class="literal">price</code> and <code class="literal">rating</code>, as well as a <code class="literal">getInfo()</code> method. As <code class="literal">prototype</code> already points to an object, you can just keep adding properties and methods to it, as follows:</p><pre class="programlisting">    Gadget.prototype.price = 100; &#13;
    Gadget.prototype.rating = 3; &#13;
    Gadget.prototype.getInfo = function () { &#13;
      return 'Rating: ' + this.rating + &#13;
             ', price: ' + this.price; &#13;
    }; &#13;
</pre><p>Alternatively, instead of adding properties to the <code class="literal">prototype</code> object one by one, you can overwrite the <code class="literal">prototype</code> completely, replacing it with an object of your choice, as shown in the following example:</p><pre class="programlisting">    Gadget.prototype = { &#13;
      price: 100, &#13;
      rating: ...  /* and so on... */ &#13;
    }; &#13;
</pre></div></div></div>
<div class="section" title="Using the prototype's methods and properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Using the prototype's methods and properties</h1></div></div></div><p>All the methods and properties you have added to the <code class="literal">prototype</code> are available as soon as you create a new object using the constructor. If you create a <code class="literal">newtoy</code> object using the <code class="literal">Gadget()</code> constructor, you can access all the methods and properties that are already defined, as you can see in the following code:</p><pre class="programlisting">    &gt; var newtoy = new Gadget('webcam', 'black'); &#13;
    &gt; newtoy.name; &#13;
    "webcam" &#13;
    &gt; newtoy.color; &#13;
    "black" &#13;
    &gt; newtoy.whatAreYou(); &#13;
    "I am a black webcam" &#13;
    &gt; newtoy.price; &#13;
    100 &#13;
    &gt; newtoy.rating; &#13;
    3 &#13;
    &gt; newtoy.getInfo(); &#13;
    "Rating: 3, price: 100" &#13;
</pre><p>It's important to note that the <code class="literal">prototype</code> is live. Objects are passed by reference in JavaScript, and therefore, the <code class="literal">prototype</code> is not copied with every new object instance. What does this mean in practice? It means that you can modify the <code class="literal">prototype</code> at any time, and all the objects, even those created before the modification, will see the changes.</p><p>Let's continue the example by adding a new method to the <code class="literal">prototype</code>:</p><pre class="programlisting">    Gadget.prototype.get = function (what) { &#13;
      return this[what]; &#13;
    }; &#13;
</pre><p>Even though the <code class="literal">newtoy</code> object was created before the <code class="literal">get()</code> method was defined, the <code class="literal">newtoy</code> object still has access to the new method, which is as follows:</p><pre class="programlisting">    &gt; newtoy.get('price'); &#13;
    100 &#13;
    &gt; newtoy.get('color'); &#13;
    "black" &#13;
</pre><div class="section" title="Own properties versus prototype properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Own properties versus prototype properties</h2></div></div></div><p>In the preceding example, <code class="literal">getInfo()</code> was used internally to access the properties of the object. It could've also used <code class="literal">Gadget.prototype</code> to achieve the same output, as follows:</p><pre class="programlisting">    Gadget.prototype.getInfo = function () { &#13;
      return 'Rating: ' + Gadget.prototype.rating + &#13;
             ', price: ' + Gadget.prototype.price; &#13;
    }; &#13;
</pre><p>What's the difference? To answer this question, let's examine in detail how the <code class="literal">prototype</code> works.</p><p>Let's take the <code class="literal">newtoy</code> object again:</p><pre class="programlisting">    var newtoy = new Gadget('webcam', 'black'); &#13;
</pre><p>When you try to access a property of <code class="literal">newtoy</code>, say, <code class="literal">newtoy.name</code>, the JavaScript engine looks through all of the properties of the object searching for one called <code class="literal">name</code>, and if it finds it, it returns its value, as follows:</p><pre class="programlisting">    &gt; newtoy.name; &#13;
    "webcam" &#13;
</pre><p>What if you try to access the <code class="literal">rating</code> property? The JavaScript engine examines all of the properties of the <code class="literal">newtoy</code> object and doesn't find the one called <code class="literal">rating</code>. Then, the script engine identifies the <code class="literal">prototype</code> of the constructor function used to create this object (the same as if you do <code class="literal">newtoy.constructor.prototype</code>). If the property is found in the <code class="literal">prototype</code> object, the following property is used:</p><pre class="programlisting">    &gt; newtoy.rating; &#13;
    3 &#13;
</pre><p>You can do the same and access the <code class="literal">prototype</code> directly. Every object has a <code class="literal">constructor</code> property, which is a reference to the function that created the object, so in this case look at the following code:</p><pre class="programlisting">    &gt; newtoy.constructor === Gadget; &#13;
    true &#13;
    &gt; newtoy.constructor.prototype.rating; &#13;
    3 &#13;
</pre><p>Now, let's take this lookup one step further. Every object has a constructor. The <code class="literal">prototype</code> is an object, so it must have a constructor too, which, in turn, has a <code class="literal">prototype</code>. You can go up the prototype chain, and you will eventually end up with the built-in <code class="literal">Object()</code> object, which is the highest-level parent. In practice, this means that if you try <code class="literal">newtoy.toString()</code> and <code class="literal">newtoy</code> doesn't have its own <code class="literal">toString()</code> method, and its <code class="literal">prototype</code> doesn't either, in the end, you'll get the object's <code class="literal">toString()</code> method:</p><pre class="programlisting">    &gt; newtoy.toString(); &#13;
    "[object Object]" &#13;
</pre></div><div class="section" title="Overwriting a prototype's property with an own property"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Overwriting a prototype's property with an own property</h2></div></div></div><p>As the preceding discussion demonstrates, if one of your objects doesn't have a certain property of its own, it can use one, if it exists, somewhere up the prototype chain. What if the object does have its own property and the prototype also has one with the same name? Then, the own property takes precedence over the prototype's.</p><p>Consider a scenario where a property name exists as both an own property and a property of the <code class="literal">prototype</code> object:</p><pre class="programlisting">    &gt; function Gadget(name) { &#13;
        this.name = name; &#13;
      } &#13;
    &gt; Gadget.prototype.name = 'mirror'; &#13;
</pre><p>Creating a new object and accessing its <code class="literal">name</code> property gives you the object's own <code class="literal">name</code> property, as follows:</p><pre class="programlisting">    &gt; var toy = new Gadget('camera'); &#13;
    &gt; toy.name; &#13;
    "camera" &#13;
</pre><p>You can tell where the property was defined using <code class="literal">hasOwnProperty()</code>, which is as follows:</p><pre class="programlisting">    &gt; toy.hasOwnProperty('name'); &#13;
    true &#13;
</pre><p>If you delete the <code class="literal">toy</code> object's own <code class="literal">name</code> property, the prototype's property with the same name shines through:</p><pre class="programlisting">    &gt; delete toy.name; &#13;
    true &#13;
    &gt; toy.name; &#13;
    "mirror" &#13;
    &gt; toy.hasOwnProperty('name'); &#13;
    false &#13;
</pre><p>Of course, you can always recreate the object's own property as follows:</p><pre class="programlisting">    &gt; toy.name = 'camera'; &#13;
    &gt; toy.name; &#13;
    "camera" &#13;
</pre><p>You can play around with the <code class="literal">hasOwnProperty()</code> method to find out the origins of a particular property you're curious about. The <code class="literal">toString()</code> method was mentioned earlier. Where is it coming from?</p><pre class="programlisting">    &gt; toy.toString(); &#13;
    "[object Object]" &#13;
    &gt; toy.hasOwnProperty('toString'); &#13;
    false &#13;
    &gt; toy.constructor.hasOwnProperty('toString'); &#13;
    false &#13;
    &gt; toy.constructor.prototype.hasOwnProperty('toString'); &#13;
    false &#13;
    &gt; Object.hasOwnProperty('toString'); &#13;
    false &#13;
    &gt; Object.prototype.hasOwnProperty('toString'); &#13;
    true &#13;
</pre><div class="section" title="Enumerating properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec53"/>Enumerating properties</h3></div></div></div><p>If you want to list all the properties of an object, you can use a <code class="literal">for...in</code> loop. In <a class="link" href="ch02.html" title="Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions">Chapter 2</a>, <span class="emphasis"><em>Primitive Data Types, Arrays, Loops, and Conditions</em></span>, you saw that you can also loop through all the elements of an array with <code class="literal">for...in</code>, but as mentioned there, <code class="literal">for</code> is better suited for arrays and <code class="literal">for...in</code> for objects. Let's take an example of constructing a query string for a URL from an object:</p><pre class="programlisting">    var params = { &#13;
      productid: 666, &#13;
      section: 'products' &#13;
    }; &#13;
 &#13;
    var url = 'http://example.org/page.php?', &#13;
        i, &#13;
        query = []; &#13;
 &#13;
    for (i in params) { &#13;
        query.push(i + '=' + params[i]); &#13;
    } &#13;
 &#13;
    url += query.join('&amp;'); &#13;
</pre><p>This produces the <code class="literal">url</code> string as follows:</p><p>
<code class="literal">http://example.org/page.php?productid=666&amp;section=products</code>.</p><p>The following are a few details to be aware of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Not all properties show up in a <code class="literal">for...in</code> loop. For example, the length (for arrays) and constructor properties don't show up. The properties that do show up are called enumerable. You can check which ones are enumerable with the help of the <code class="literal">propertyIsEnumerable()</code> method that every object provides. In ES5, you can specify which properties are enumerable, while in ES3 you don't have that control.</li><li class="listitem" style="list-style-type: disc">Prototypes that come through the prototype chain also show up, provided they are enumerable. You can check whether a property is an object's own property or a prototype's property using the <code class="literal">hasOwnProperty()</code> method.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">propertyIsEnumerable()</code> method returns <code class="literal">false</code> for all of the prototype's properties, even those that are enumerable and show up in the <code class="literal">for...in</code> loop.</li></ul></div><p>Let's see these methods in action. Take this simplified version of <code class="literal">Gadget()</code>:</p><pre class="programlisting">    function Gadget(name, color) { &#13;
      this.name = name; &#13;
      this.color = color; &#13;
      this.getName = function () { &#13;
        return this.name; &#13;
      }; &#13;
    } &#13;
    Gadget.prototype.price = 100; &#13;
    Gadget.prototype.rating = 3; &#13;
</pre><p>Create a new object as follows:</p><pre class="programlisting">    var newtoy = new Gadget('webcam', 'black'); &#13;
</pre><p>Now, if you loop using a <code class="literal">for...in</code> loop, you can see all of the object's properties, including those that come from the prototype:</p><pre class="programlisting">    for (var prop in newtoy) {  &#13;
      console.log(prop + ' = ' + newtoy[prop]);  &#13;
    } &#13;
</pre><p>The result also contains the object's methods, as methods are just properties that happen to be functions:</p><pre class="programlisting">    name = webcam &#13;
    color = black &#13;
    getName = function () { &#13;
      return this.name; &#13;
    } &#13;
    price = 100 &#13;
    rating = 3 &#13;
</pre><p>If you want to distinguish between the object's own properties and the prototype's properties, use <code class="literal">hasOwnProperty()</code>. Try the following first:</p><pre class="programlisting">    &gt; newtoy.hasOwnProperty('name'); &#13;
    true &#13;
    &gt; newtoy.hasOwnProperty('price'); &#13;
    false &#13;
</pre><p>Let's loop again, but this time, showing only the object's own properties:</p><pre class="programlisting">    for (var prop in newtoy) {  &#13;
      if (newtoy.hasOwnProperty(prop)) { &#13;
        console.log(prop + '=' + newtoy[prop]);  &#13;
      } &#13;
    } &#13;
</pre><p>The result is as follows:</p><pre class="programlisting">    name=webcam &#13;
    color=black &#13;
    getName = function () { &#13;
      return this.name; &#13;
    } &#13;
</pre><p>Now, let's try <code class="literal">propertyIsEnumerable()</code>. This method returns <code class="literal">true</code> for the object's own properties that are not built in, for example:</p><pre class="programlisting">    &gt; newtoy.propertyIsEnumerable('name'); &#13;
    true &#13;
</pre><p>Most built-in properties and methods are not enumerable:</p><pre class="programlisting">    &gt; newtoy.propertyIsEnumerable('constructor'); &#13;
    false &#13;
</pre><p>Any properties coming down the prototype chain are not enumerable:</p><pre class="programlisting">    &gt; newtoy.propertyIsEnumerable('price'); &#13;
    false &#13;
</pre><p>However, not that such properties are enumerable if you reach the object contained in the <code class="literal">prototype</code> and invoke its <code class="literal">propertyIsEnumerable()</code> method. Consider the following code:</p><pre class="programlisting">    &gt; newtoy.constructor.prototype.propertyIsEnumerable('price'); &#13;
    true &#13;
</pre></div></div><div class="section" title="Using isPrototypeOf() method"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Using isPrototypeOf() method</h2></div></div></div><p>Objects also have the <code class="literal">isPrototypeOf()</code> method. This method tells you whether that specific object is used as a prototype of another object.</p><p>Let's take a simple object named <code class="literal">monkey</code>:</p><pre class="programlisting">    var monkey = {    &#13;
      hair: true,    &#13;
      feeds: 'bananas',    &#13;
      breathes: 'air'  &#13;
    }; &#13;
</pre><p>Now, let's create a <code class="literal">Human()</code> constructor function and set its <code class="literal">prototype</code> property to point to <code class="literal">monkey</code>:</p><pre class="programlisting">    function Human(name) { &#13;
      this.name = name; &#13;
    } &#13;
    Human.prototype = monkey; &#13;
</pre><p>Now, if you create a new <code class="literal">Human</code> object called <code class="literal">george</code> and ask If <code class="literal">monkey</code> the prototype of <code class="literal">george</code>?, you'll get <code class="literal">true</code>:</p><pre class="programlisting">    &gt; var george = new Human('George');  &#13;
    &gt; monkey.isPrototypeOf(george); &#13;
    true &#13;
</pre><p>Note that you have to know, or suspect, who the prototype is and then ask is it true that your prototype is <code class="literal">monkey</code>? in order to confirm your suspicion. But, what if you don't suspect anything, and you have no idea? Can you just ask the object to tell you its prototype? The answer is, you can't in all browsers, but you can in most of them. Most recent browsers have implemented the addition to ES5 called <code class="literal">Object.getPrototypeOf()</code>.</p><pre class="programlisting">    &gt; Object.getPrototypeOf(george).feeds; &#13;
    "bananas" &#13;
    &gt; Object.getPrototypeOf(george) === monkey; &#13;
    true &#13;
</pre><p>For some of the pre-ES5 environments that don't have <code class="literal">getPrototypeOf()</code>, you can use the special property, <code class="literal">__proto__</code>.</p></div><div class="section" title="The secret __proto__ link"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>The secret __proto__ link</h2></div></div></div><p>As you already know, the <code class="literal">prototype</code> property is consulted when you try to access a property that does not exist in the current object.</p><p>Consider another object called <code class="literal">monkey</code>, and use it as a prototype when creating objects with the <code class="literal">Human()</code> constructor:</p><pre class="programlisting">    &gt; var monkey = { &#13;
        feeds: 'bananas', &#13;
        breathes: 'air' &#13;
      }; &#13;
    &gt; function Human() {}  &#13;
    &gt; Human.prototype = monkey; &#13;
</pre><p>Now, let's create a <code class="literal">developer</code> object, and give it the following properties:</p><pre class="programlisting">    &gt; var developer = new Human(); &#13;
    &gt; developer.feeds = 'pizza'; &#13;
    &gt; developer.hacks = 'JavaScript'; &#13;
</pre><p>Now, let's access these properties (for example, <code class="literal">hacks</code> is a property of the <code class="literal">developer</code> object):</p><pre class="programlisting">    &gt; developer.hacks; &#13;
    "JavaScript" &#13;
</pre><p>The <code class="literal">feeds</code> property can also be found in the object, as follows:</p><pre class="programlisting">    &gt; developer.feeds; &#13;
    "pizza" &#13;
</pre><p>The <code class="literal">breathes</code> property doesn't exist as a property of the <code class="literal">developer</code> object, so the prototype is looked up, as if there is a secret link or passageway that leads to the <code class="literal">prototype</code> object:</p><pre class="programlisting">    &gt; developer.breathes; &#13;
    "air" &#13;
</pre><p>The secret link is exposed in most modern JavaScript environments as the <code class="literal">__proto__</code> property, the word <code class="literal">proto</code> with two underscores before and after:</p><pre class="programlisting">    &gt; developer.__proto__ === monkey; &#13;
    true &#13;
</pre><p>You can use this secret property for learning purposes, but it's not a good idea to use it in your real scripts because it does not exist in all browsers (notably IE), so your scripts won't be portable.</p><p>Be aware that <code class="literal">__proto__</code> is not the same as <code class="literal">prototype</code>, as <code class="literal">__proto__</code> is a property of the instances (objects), whereas <code class="literal">prototype</code> is a property of the constructor functions used to create those objects:</p><pre class="programlisting">    &gt; typeof developer.__proto__; &#13;
    "object" &#13;
    &gt; typeof developer.prototype; &#13;
    "undefined" &#13;
    &gt; typeof developer.constructor.prototype; &#13;
    "object" &#13;
</pre><p>Once again, you should use <code class="literal">__proto__</code> only for learning or debugging purposes. Or, if you're lucky enough and your code only needs to work in ES5-compliant environments, you can use <code class="literal">Object.getPrototypeOf()</code>.
</p></div></div>
<div class="section" title="Augmenting built-in objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Augmenting built-in objects</h1></div></div></div><p>The objects created by the built-in constructor functions, such as <code class="literal">Array</code>, <code class="literal">String</code>, and even <code class="literal">Object</code> and <code class="literal">Function</code>, can be augmented (or enhanced) through the use of prototypes. This means that you can, for example, add new methods to the <code class="literal">Array</code> prototype, and in this way you can make them available to all arrays. Let's see how to do this.</p><p>In PHP, there is a function called <code class="literal">in_array()</code>, which tells you whether a value exists in an array. In JavaScript, there is no <code class="literal">inArray()</code> method, although, in ES5, there's <code class="literal">indexOf()</code>, which you can use for the same purpose. So, let's implement it and add it to <code class="literal">Array.prototype</code>, as follows:</p><pre class="programlisting">    Array.prototype.inArray = function (needle) { &#13;
      for (var i = 0, len = this.length; i &lt; len; i++) { &#13;
        if (this[i] === needle) { &#13;
          return true; &#13;
        } &#13;
      } &#13;
      return false; &#13;
    }; &#13;
</pre><p>Now, all arrays have access to the new method. Let's test the following code:</p><pre class="programlisting">    &gt; var colors = ['red', 'green', 'blue']; &#13;
    &gt; colors.inArray('red'); &#13;
    true &#13;
    &gt; colors.inArray('yellow'); &#13;
    false &#13;
</pre><p>That was nice and easy! Let's do it again. Imagine your application often needs to spell words backward, and you feel there should be a built-in <code class="literal">reverse()</code> method for string objects. After all, arrays have <code class="literal">reverse()</code>. You can easily add a <code class="literal">reverse()</code> method to the <code class="literal">String</code> prototype by borrowing <code class="literal">Array.prototype.reverse()</code> (there was a similar exercise at the end of <a class="link" href="ch04.html" title="Chapter 4. Objects">Chapter 4</a>, <span class="emphasis"><em>Objects</em></span>):</p><pre class="programlisting">    String.prototype.reverse = function () { &#13;
      return Array.prototype.reverse. &#13;
               apply(this.split('')).join(''); &#13;
    }; &#13;
</pre><p>This code uses the <code class="literal">split()</code> method to create an array from a string, then calls the <code class="literal">reverse()</code> method on this array, which produces a reversed array. The resulting array is then turned back into a string using the <code class="literal">join()</code> method. Let's test the new method:</p><pre class="programlisting">    &gt; "bumblebee".reverse(); &#13;
      "eebelbmub"&#13;
</pre><div class="section" title="Augmenting built-in objects - discussion"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Augmenting built-in objects - discussion</h2></div></div></div><p>Augmenting built-in objects through the prototype is a powerful technique, and you can use it to shape JavaScript in any way you like. Because of its power, though, you should always thoroughly consider your options before using this approach.</p><p>The reason is that once you know JavaScript, you're expecting it to work the same way, no matter which third-party library or widget you're using. Modifying core objects can confuse the users and maintainers of your code and create unexpected errors.</p><p>JavaScript evolves and browser's vendors continuously support more features. What you consider a missing method today and decide to add to a core prototype could be a built-in method tomorrow. In this case, your method is no longer needed. Additionally, what if you have already written a lot of code that uses the method and your method is slightly different from the new built-in implementation?</p><p>The most common and acceptable use case to augment built-in prototypes is to add support for new features (ones that are already standardized by the ECMAScript committee and implemented in new browsers) to old browsers. One example will be adding an ES5 method to old versions of IE. These extensions are known as <span class="strong"><strong>shims</strong></span> or <span class="strong"><strong>polyfills</strong></span>.</p><p>When augmenting prototypes, you will first check if the method exists before implementing it yourself. This way, you can use the native implementation in the browser if one exists. For example, let's add the <code class="literal">trim()</code> method for strings, which is a method that exists in ES5 but is missing in older browsers:</p><pre class="programlisting">    if (typeof String.prototype.trim !== 'function') { &#13;
      String.prototype.trim = function () { &#13;
        return this.replace(/^\s+|\s+$/g,''); &#13;
      }; &#13;
    } &#13;
    &gt; " hello ".trim(); &#13;
    "hello" &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>
<span class="strong"><strong>Best practice</strong></span></p><p>If you decide to augment a built-in object, or its prototype with a new property, do check for the existence of the new property first.</p></div></div></div><div class="section" title="Prototype gotchas"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Prototype gotchas</h2></div></div></div><p>The following are the two important behaviors to consider when dealing with prototypes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The prototype chain is live, except for when you completely replace the <code class="literal">prototype</code> object</li><li class="listitem" style="list-style-type: disc">The <code class="literal">prototype.constructor</code> method is not reliable</li></ul></div><p>Let's create a simple constructor function and two objects:</p><pre class="programlisting">    &gt; function Dog() { &#13;
        this.tail = true; &#13;
      } &#13;
    &gt; var benji = new Dog(); &#13;
    &gt; var rusty = new Dog(); &#13;
</pre><p>Even after you've created the <code class="literal">benji</code> and <code class="literal">rusty</code> objects, you can still add properties to the prototype of <code class="literal">Dog()</code> and the existing objects will have access to the new properties. Let's throw in the <code class="literal">say()</code> method:</p><pre class="programlisting">    &gt; Dog.prototype.say = function () { &#13;
        return 'Woof!'; &#13;
      }; &#13;
</pre><p>Both objects have access to the new method:</p><pre class="programlisting">    &gt; benji.say(); &#13;
    "Woof!" &#13;
     rusty.say(); &#13;
    "Woof!" &#13;
</pre><p>Up to this point, if you consult your objects, asking which constructor function was used to create them, they'll report it correctly:</p><pre class="programlisting">    &gt; benji.constructor === Dog; &#13;
    true &#13;
    &gt; rusty.constructor === Dog; &#13;
    true &#13;
</pre><p>Now, let's completely overwrite the <code class="literal">prototype</code> object with a brand new object:</p><pre class="programlisting">    &gt; Dog.prototype = { &#13;
        paws: 4, &#13;
        hair: true &#13;
      }; &#13;
</pre><p>It turns out that the old objects do not get access to the new prototype's properties; they still keep the secret link pointing to the old prototype object, as follows:</p><pre class="programlisting">    &gt; typeof benji.paws; &#13;
    "undefined" &#13;
    &gt; benji.say(); &#13;
    "Woof!" &#13;
    &gt; typeof benji.__proto__.say; &#13;
    "function" &#13;
    &gt; typeof benji.__proto__.paws; &#13;
    "undefined" &#13;
</pre><p>Any new objects that you will create from now on will use the updated prototype, which is as follows:</p><pre class="programlisting">    &gt; var lucy = new Dog(); &#13;
    &gt; lucy.say(); &#13;
    TypeError: lucy.say is not a function &#13;
    &gt; lucy.paws; &#13;
    4 &#13;
</pre><p>The secret <code class="literal">__proto__</code> link points to the new prototype object, as shown in the following lines of code:</p><pre class="programlisting">    &gt; typeof lucy.__proto__.say; &#13;
    "undefined" &#13;
    &gt; typeof lucy.__proto__.paws; &#13;
    "number" &#13;
</pre><p>Now the <code class="literal">constructor</code> property of the new object no longer reports correctly. You will expect it to point to <code class="literal">Dog()</code>, but instead it points to <code class="literal">Object()</code>, as you can see in the following example:</p><pre class="programlisting">    &gt; lucy.constructor; &#13;
    function Object() { [native code] } &#13;
    &gt; benji.constructor; &#13;
    function Dog() { &#13;
      this.tail = true; &#13;
    } &#13;
</pre><p>You can easily prevent this confusion by resetting the <code class="literal">constructor</code> property after you overwrite the prototype completely, as follows:</p><pre class="programlisting">    &gt; function Dog() {} &#13;
    &gt; Dog.prototype = {}; &#13;
    &gt; new Dog().constructor === Dog; &#13;
    false &#13;
    &gt; Dog.prototype.constructor = Dog; &#13;
    &gt; new Dog().constructor === Dog; &#13;
    true &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>
<span class="strong"><strong>Best practice</strong></span></p><p>When you overwrite the prototype, remember to reset the <code class="literal">constructor</code> property.</p></div></div></div></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Exercises</h1></div></div></div><p>Lets practice the following exercise:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an object called <code class="literal">shape</code> that has the type <code class="literal">property</code> and a <code class="literal">getType()</code> method.</li><li class="listitem">Define a <code class="literal">Triangle()</code> constructor function whose prototype is <code class="literal">shape</code>. Objects created with <code class="literal">Triangle()</code> should have three own properties-<code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code>, representing the lengths of the sides of a triangle.</li><li class="listitem">Add a new method to the prototype called <code class="literal">getPerimeter()</code>.</li><li class="listitem">Test your implementation with the following code:<pre class="programlisting">        &gt; var t = new Triangle(1, 2, 3); &#13;
        &gt; t.constructor === Triangle; &#13;
               true &#13;
        &gt; shape.isPrototypeOf(t); &#13;
               true &#13;
        &gt; t.getPerimeter(); &#13;
               6 &#13;
        &gt; t.getType(); &#13;
               "triangle" &#13;
</pre></li><li class="listitem">Loop over <code class="literal">t</code>, showing only your own properties and methods, none of the prototype's.</li><li class="listitem">Make the following code work:<pre class="programlisting">        &gt; [1, 2, 3, 4, 5, 6, 7, 8, 9].shuffle(); &#13;
          [2, 4, 1, 8, 9, 6, 5, 3, 7] &#13;
</pre></li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Summary</h1></div></div></div><p>Let's summarize the most important topics you have learned in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All functions have a property called <code class="literal">prototype</code>. Initially, it contains an empty object-an object without any own properties.</li><li class="listitem" style="list-style-type: disc">You can add properties and methods to the <code class="literal">prototype</code> object. You can even replace it completely with an object of your choice.</li><li class="listitem" style="list-style-type: disc">When you create an object using a function as a constructor (with <code class="literal">new</code>), the object gets a secret link pointing to the prototype of the constructor and can access the prototype's properties.</li><li class="listitem" style="list-style-type: disc">An object's own properties take precedence over a prototype's properties with the same name.</li><li class="listitem" style="list-style-type: disc">Use the <code class="literal">hasOwnProperty()</code> method to differentiate between an object's own properties and <code class="literal">prototype</code> properties.</li><li class="listitem" style="list-style-type: disc">There is a prototype chain. When you execute <code class="literal">foo.bar</code>, and if your <code class="literal">foo</code> object doesn't have a property called <code class="literal">bar</code>, the JavaScript interpreter looks for a <code class="literal">bar</code> property in the prototype. If none is found, it keeps searching in the prototype's prototype, then the prototype of the prototype's prototype, and it will keep going all the way up to <code class="literal">Object.prototype</code>.</li><li class="listitem" style="list-style-type: disc">You can augment the prototypes of built-in constructor functions, and all objects will see your additions. Assign a function to <code class="literal">Array.prototype.flip</code> and all arrays will immediately get a <code class="literal">flip()</code> method, as in <code class="literal">[1,2,3].flip()</code>. But, do check whether the method/property you want to add already exists, so you can future-proof your scripts.</li></ul></div></div></body></html>