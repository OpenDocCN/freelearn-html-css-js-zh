- en: Inheritance and Composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和组合
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Extending a class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展一个类
- en: Assigning additional properties with constructor arguments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数参数分配额外的属性
- en: Overriding parent class instance methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖父类实例方法
- en: Overriding parent class static methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖父类静态方法
- en: Calling super methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用超类方法
- en: Using composition rather than inheritance to add behavior
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合而不是继承来添加行为
- en: Using mix-ins to add behavior
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混入（mix-ins）来添加行为
- en: Passing a class as an argument
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个类作为参数传递
- en: Checking class inheritance with Object.getPrototypeOf
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Object.getPrototypeOf 检查类继承
- en: Using throw to simulate abstract classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 throw 来模拟抽象类
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we saw how to use the new class syntax to implement
    behavior that was only slightly more difficult to implement directly with a prototype.
    A developer could be excused for thinking that this complexity of the language
    was not worth it. After all, it's only a line (or perhaps a character) or two
    extra to get the same behavior.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用新的类语法来实现仅比直接使用原型实现稍微复杂的行为。开发者可能会认为这种语言复杂度不值得，毕竟，仅多一行（或可能是一个字符）就能得到相同的行为。
- en: The real advantage of using the new ES6 class syntax to create object prototypes
    is revealed when more complicated structures and techniques are used. In essence,
    we'll see that it's much easier to understand code when the behavior is defined
    with keywords, rather than context-sensitive operators.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 ES6 类语法创建对象原型的真正优势在于使用更复杂结构和技术的过程中显现出来。本质上，我们将看到，当行为用关键字定义时，代码更容易理解，而不是用上下文敏感的操作符。
- en: In this chapter, we'll look at how to implement some more sophisticated behaviors
    using classes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用类实现一些更复杂的行为。
- en: Extending a class
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展一个类
- en: Extending classes can be used to allow for new behaviors, while adhering to
    common interfaces. While it's not always the best way to organize relationships
    between objects, there are many situations where extension (sometimes called inheritance)
    is the most effective way to structure behavior.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展类可以用来允许新的行为，同时遵循通用接口。虽然这并不是组织对象之间关系总是最好的方式，但在许多情况下，扩展（有时称为继承）是构建行为最有效的方法。
- en: In this recipe, we'll see a very simple example of extension.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将看到一个非常简单的扩展示例。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本例假设您已经有一个工作区，允许您在浏览器中创建和运行 ES 模块。如果您没有，请参阅前两章。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行应用程序并导航到您的 workspace。
- en: Create a new folder named `08-01-extending-classes`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `08-01-extending-classes` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件从 `main.js` 加载并运行一个 `main` 函数。
- en: 'Create a `main.js` file that defines a new class named `Rocket` that takes
    a constructor argument `name` and assigns it to an instance property:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，定义一个名为 `Rocket` 的新类，该类接受一个构造函数参数 `name` 并将其分配给实例属性：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a class named `InactiveRocket` that extends the `Rocket` class:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `InactiveRocket` 的类，它扩展了 `Rocket` 类：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a `main` function that creates instances of both classes and logs out
    their names:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数，创建两个类的实例并输出它们的名称：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'You will see output like the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](img/34960f81-4db0-4ab7-b4cf-59a0521933b9.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34960f81-4db0-4ab7-b4cf-59a0521933b9.png)'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `classInactiveRocket` extends `Rocket`. This means that all of the properties
    on the prototype of `Rocket` end up on the instance of `InactiveRocket` unless
    they are overridden. The constructor is special, but it is also a property on
    the `Rocket` prototype. Therefore, when the two instances are created, the `Rocket`
    class constructor is executed for both the `Rocket` and `InactiveRocket` instances.
    So, we see the `name` property assigned on both instances.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`classInactiveRocket` 扩展了 `Rocket`。这意味着除非被覆盖，否则 `Rocket` 原型上的所有属性最终都会出现在 `InactiveRocket`
    的实例上。构造函数是特殊的，但也是 `Rocket` 原型上的一个属性。因此，当创建两个实例时，`Rocket` 类的构造函数会为 `Rocket` 和 `InactiveRocket`
    实例执行。所以，我们看到两个实例上都分配了 `name` 属性。'
- en: We'll see how to override methods and other behaviors in future recipes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的食谱中了解如何覆盖方法和其他行为。
- en: Assigning additional properties with constructor arguments
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造函数参数分配额外的属性
- en: If we are extending a class, we'll want it to be a little bit different. Otherwise,
    what's the point of extending it? In this recipe we'll differentiate a child class
    by adding additional properties.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在扩展一个类，我们希望它有一些不同。否则，扩展它的意义何在？在本食谱中，我们将通过添加额外的属性来区分子类。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您已经有一个工作区，允许您在浏览器中创建和运行 ES 模块。如果您没有，请参阅前两章。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command line application and navigate to your workspace.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行应用程序并导航到您的 workspace。
- en: Create a new folder named `08-02-additional-constructor-args`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `08-02-additional-constructor-args` 的新文件夹。
- en: 'Create a `main.js` file that defines a new class named `Rocket` that takes
    a constructor argument `name` and assigns it to an instance property:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，定义一个名为 `Rocket` 的新类，该类接受一个构造函数参数 `name` 并将其分配给实例属性：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a class named `InactiveRocket` that extends the `Rocket` class, and
    assigns an additional `lastFlown` property in the constructor:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `InactiveRocket` 的类，该类扩展了 `Rocket` 类，并在构造函数中分配一个额外的 `lastFlown` 属性：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a `main` function that creates instances of both classes and logs out
    their names, and the `lastFlown` property of the `InactiveRocket`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数，该函数创建两个类的实例并输出它们的名称，以及 `InactiveRocket` 的 `lastFlown` 属性：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'You should see output like the following:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![](img/b8e2d1cd-fe69-487a-87a6-17e37c415772.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8e2d1cd-fe69-487a-87a6-17e37c415772.png)'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe differs from the previous simple extension example. By implementing
    a constructor on `InactiveRocket`, we are able to pass a different set of arguments.
    The `lastFlown` property is unique to `InactiveRocket`. Thus, we see that property
    on instances of `InactiveRocket`, but not on instances of `Rocket`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱与前面的简单扩展示例不同。通过在 `InactiveRocket` 上实现构造函数，我们能够传递一组不同的参数。`lastFlown` 属性是 `InactiveRocket`
    独有的。因此，我们在 `InactiveRocket` 的实例上看到该属性，但在 `Rocket` 的实例上没有看到。
- en: You'll notice that the `super` method is called in the constructor of `InactiveRocket`.
    This manually executes the `Rocket` constructor for the current instance. That
    is why the `name` property is also attached. If we did not execute `super`, then
    the `Rocket` constructor would not have been called.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在 `InactiveRocket` 的构造函数中调用了 `super` 方法。这手动执行了当前实例的 `Rocket` 构造函数。这就是为什么
    `name` 属性也被附加的原因。如果我们没有执行 `super`，那么 `Rocket` 构造函数就不会被调用。
- en: In this way, we've kept the properties from the parent class `Rocket` as well
    as adding an additional property to the `InactiveRocket` child class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们保留了父类 `Rocket` 的属性，并为 `InactiveRocket` 子类添加了一个额外的属性。
- en: Overriding parent class instance methods
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖父类实例方法
- en: Ideally, classes contain more than just properties. Well-designed classes also
    define behavior. Thus, sub-classes should also be extending behavior, not just
    adding additional properties.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，类不仅包含属性，还定义行为。因此，子类也应该扩展行为，而不仅仅是添加额外的属性。
- en: In this recipe, we'll see how to override methods from a parent class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将了解如何覆盖父类的方法。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您已经有一个工作区，允许您在浏览器中创建和运行 ES 模块。如果您没有，请参阅前两章。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command line application and navigate to your workspace.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行应用程序并导航到您的 workspace。
- en: Create a new folder named `08-03-defining-methods`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `08-03-defining-methods` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file that defines a new class named `Rocket`**.** Add a
    constructor that takes a constructor argument `name` and assigns it to an instance
    property. Then, define a simple `print` method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，定义一个名为 `Rocket` 的新类**。** 添加一个构造函数，该构造函数接受一个构造函数参数 `name` 并将其分配给实例属性。然后，定义一个简单的
    `print` 方法：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a class named `InactiveRocket` that extends the `Rocket` class and assigns
    an additional `lastFlow` property in the constructor. Then, override the `print`
    method to include the new property:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`InactiveRocket`的类，它扩展了`Rocket`类，并在构造函数中分配一个额外的`lastFlow`属性。然后，覆盖`print`方法以包含新属性：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a `main` function that creates instances of both classes and calls the
    `print` method of both:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main`函数，创建两个类的实例，并调用两个类的`print`方法：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Start you Python web server and open the following link in your browser:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see output like the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/ff3f5923-208c-480d-850d-71842d757873.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff3f5923-208c-480d-850d-71842d757873.png)'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Adding methods to the body of a class definition is the same as attaching properties
    to the prototype of a function, with functions as their values. This means that
    those properties are added as properties to the instance of the new object. When
    these methods are called, the context (the value of `this`) is the current instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义体中添加方法与将属性附加到函数的原型相同，其中函数是它们的值。这意味着这些属性被添加为新对象的实例属性。当调用这些方法时，上下文（`this`的值）是当前实例。
- en: This is similar to the *Defining function properties as methods on a plain object*
    recipe in [Chapter 6](0ff0c6a3-a324-4346-8ba5-37275e85aa1b.xhtml), *Plain Objects*.
    In that recipe, we overrode methods by direct assignment. By contrast, in this
    recipe, we are doing this on the prototype. That means that this override applies
    to every instance of the `InactiveRocket` subclass.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[第6章](0ff0c6a3-a324-4346-8ba5-37275e85aa1b.xhtml)中“在普通对象上定义函数属性作为方法”的菜谱类似，*普通对象*。在那个菜谱中，我们通过直接赋值来覆盖方法。相比之下，在这个菜谱中，我们在原型上这样做。这意味着这个覆盖适用于`InactiveRocket`子类的每个实例。
- en: Overriding parent class static methods
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖父类静态方法
- en: We've seen previously that behaviors are not limited to class instances but
    are also attached to the classes themselves. These `static` methods can also be
    overridden by subclasses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到，行为不仅限于类实例，也附加到类本身。这些`静态`方法也可以被子类覆盖。
- en: In this recipe, we'll see how to override static methods.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何覆盖静态方法。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open your command line application and navigate to your workspace.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `08-04-checking-with-instanceof`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`08-04-checking-with-instanceof`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`，它从`main.js`加载并运行一个`main`函数。
- en: 'Create two objects `rocketMap` and `inactiveRocketMap`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个对象`rocketMap`和`inactiveRocketMap`：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define a new class named `Rocket`. Add a constructor. Use the name to assign
    the instance to the `rocketMap` and define a simple `print` method:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`Rocket`的新类。添加一个构造函数。使用名称将实例分配给`rocketMap`，并定义一个简单的`print`方法：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a static `find` method that retrieves an instance from the `rocketMap`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个静态`find`方法，从`rocketMap`检索实例：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a class named `InactiveRocket` that extends the `Rocket` class and assigns
    an additional `lastFlow` property in the constructor. Use the `name` to assign
    the instance to the `inactiveRocketMap` and override the `print` method to include
    the new property:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`InactiveRocket`的类，它扩展了`Rocket`类，并在构造函数中分配一个额外的`lastFlow`属性。使用`name`将实例分配给`inactiveRocketMap`，并覆盖`print`方法以包含新属性：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a static `find` method that retrieves an instance from the `rocketMap`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个静态`find`方法，从`rocketMap`检索实例：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a `main` function that creates instances of both classes and try to
    retrieve the instances from the maps:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main`函数，创建两个类的实例，并尝试从映射中检索实例：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see output like the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/b9d04b51-a108-4f0f-876e-1d1103705a64.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9d04b51-a108-4f0f-876e-1d1103705a64.png)'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just like the instance methods, static methods defined on the child override
    those on the parent class. We created the `Rocket` class with a static method
    that locates a `Rocket` instance based on its name. We also created an `InactiveRocket`
    class with its own `find` method that searches in a different map. Because the
    `InactiveRocket` class calls `super` in its constructor, instances of both classes
    are added to the map used by the `Rocket` class's `find` method. While only instances
    of `InactiveRocket` are added to the map used in that class's `find` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像实例方法一样，在子类上定义的静态方法会覆盖父类上的方法。我们创建了一个带有静态方法的`Rocket`类，该方法根据其名称定位`Rocket`实例。我们还创建了一个具有自己的`find`方法的`InactiveRocket`类，该方法在另一个映射中搜索。因为`InactiveRocket`类在其构造函数中调用`super`，所以两个类的实例都被添加到`Rocket`类`find`方法使用的映射中。而只有`InactiveRocket`类的实例被添加到该类`find`方法使用的映射中。
- en: When we call `find` on the `Rocket` class we are able to retrieve instances
    of both classes. You'll notice that we are unable to locate instances of the `base`
    class using the `InactiveRocket` class's find method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`Rocket`类上调用`find`时，我们能够检索到两个类的实例。你会注意到，我们无法使用`InactiveRocket`类的`find`方法定位`base`类的实例。
- en: Calling super methods
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用super方法
- en: Overriding methods is awesome for extending behavior. However, we sometimes
    want to continue to use behavior from a parent class. This is possible by using
    the `super` keyboard to access parent class methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重写方法是扩展行为的好方法。然而，我们有时还想继续使用父类中的行为。通过使用`super`关键字来访问父类方法，这是可能的。
- en: In this recipe, we'll see how to use this keyword to access those methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看到如何使用这个关键字来访问这些方法。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open your command line application and navigate to your workspace.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `08-05-getters-read-only`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`08-05-getters-read-only`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`文件，该文件加载并运行来自`main.js`的`main`函数。
- en: 'Create a `main.js` file that defines a new class named `Rocket`. Add a constructor
    that takes a constructor argument `name` and assigns it to an instance property.
    Then, define a simple `print` method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.js`文件，定义一个名为`Rocket`的新类。添加一个接受构造函数参数`name`并将其分配给实例属性的构造函数。然后，定义一个简单的`print`方法：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a class named `InactiveRocket` that extends the `Rocket` class and assigns
    an additional `lastFlow` property in the constructor. Then, override the `print`
    method and call `super.print`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`InactiveRocket`的类，它扩展了`Rocket`类并在构造函数中分配一个额外的`lastFlow`属性。然后，重写`print`方法并调用`super.print`：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a `main` function that creates instances of both classes and calls their
    `print` method of both:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main`函数，创建两个类的实例并调用它们的`print`方法：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see output like the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/870ebdea-fff4-403e-bb04-7863f3868ccc.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/870ebdea-fff4-403e-bb04-7863f3868ccc.png)'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we overrode the `print` method in the `InactiveRocket` class, calling
    that method will execute the code defined in that class, rather than the parents.
    The `super` keyword allows us to reference the prototype of the parent class.
    So, when the `print` method is called on the `super` keyword, the method as defined
    on the parent prototype is executed. Thus, we see the output of both `print` methods
    for the `saturnV` instance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在`InactiveRocket`类中重写了`print`方法，调用该方法将执行该类中定义的代码，而不是父类。`super`关键字允许我们引用父类的原型。所以，当在`super`关键字上调用`print`方法时，将执行在父类原型上定义的方法。因此，我们可以看到`saturnV`实例的`print`方法的输出。
- en: Using composition rather than inheritance to add behavior
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合而不是继承来添加行为
- en: So far, we've seen how to use inheritance to add behavior and compose larger
    structures. This is not always the ideal approach. In many situations, it's better
    to use a method known as composition instead. This involves using distinct classes
    in connection without establishing a hierarchical relationship. The chief advantage
    here is code clarity and flexibility.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用继承来添加行为和组合更大的结构。这并不总是理想的方法。在许多情况下，使用一种称为组合的方法会更好。这涉及到使用没有建立层次关系的不同类进行连接。这里的主要优势是代码清晰度和灵活性。
- en: In this recipe, we'll see how to use composition.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用组合。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command line application and navigate to your workspace.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `08-06-using-composition-instead-of-inherritence`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `08-06-using-composition-instead-of-inherritence` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file that defines a new class named `Rocket`. Add a constructor
    that takes a constructor argument `name` and assigns it to an instance property.
    Then, define a simple `print` method:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，定义一个名为 `Rocket` 的新类。添加一个接受构造函数参数 `name` 并将其分配给实例属性的构造函数。然后，定义一个简单的
    `print` 方法：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a class named `InactiveRocket` that extends the `Rocket` class and assigns
    an additional `lastFlow` property in the constructor. Then, override the `print`
    method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `InactiveRocket` 的类，它扩展了 `Rocket` 类并在构造函数中分配一个额外的 `lastFlow` 属性。然后，重写
    `print` 方法：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a class named `Launcher` that takes a constructor argument `rocket`.
    Add a method, named `prepareForLaunch`, that aborts if the rocket is inactive:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Launcher` 的类，它接受一个构造函数参数 `rocket`。添加一个名为 `prepareForLaunch` 的方法，如果火箭不活跃则中止：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `main` function that creates two instances of `Launcher`; one for
    each class of rocket:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数，创建两个 `Launcher` 实例；每个火箭类一个：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see output like the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/b9830c81-fb99-498a-88f4-f0a8bf881308.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9830c81-fb99-498a-88f4-f0a8bf881308.png)'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we've added an instance of one class (one of the two `Rocket`
    classes) and used it within the instance of another class (`Launcher`), that isn't
    related via inheritance. It would be possible to add this launch functionality
    through a `LaunchableRocket` class, but that would become cumbersome as the kinds
    of rockets and their relationships change.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们添加了一个类的实例（两个 `Rocket` 类中的一个）并在另一个类的实例（`Launcher`）中使用它，这两个类之间没有通过继承相关联。通过一个
    `LaunchableRocket` 类添加这种发射功能是可能的，但随着火箭类型及其关系的变化，这会变得繁琐。
- en: In general, adding behaviors through inheritance is constricting; it should
    be limited to small changes and they should not differ in public interface. The
    **Dependency Inversion Principle **(**DIP**) is an important concept when considering
    inheritance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过继承添加行为是受限的；它应该限制在小的更改上，并且它们不应该在公共接口上有所不同。**依赖倒置原则（Dependency Inversion
    Principle）**（**DIP**）在考虑继承时是一个重要的概念。
- en: 'Visit the following link to learn more about the DIP: [https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下链接了解DIP（依赖倒置原则）的更多信息：[https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle).
- en: Using mix-ins to add behavior
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混入添加行为
- en: We've seen how to use inheritance and composition to add behavior. There is
    a different method of composition that appends behavior onto existing classes
    without inheritance. Using mix-ins attaches properties to an object instance at
    runtime.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用继承和组合来添加行为。还有一种不同的组合方法，它在不使用继承的情况下将行为附加到现有类上。使用混入（mix-ins）可以在运行时将属性附加到对象实例。
- en: In this recipe, we'll see how to use the mix-ins to add shared behavior to classes
    without inheritance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用混入（mix-ins）在不使用继承的情况下向类添加共享行为。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open your command line application and navigate to your workspace.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `08-08-using-mixins`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `08-08-using-mixins` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file that defines a new class named `Rocket`. In the constructor,
    extend the current instance with an object named `Launcher`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.js` 的文件，该文件定义了一个名为 `Rocket` 的新类。在构造函数中，使用名为 `Launcher` 的对象扩展当前实例：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a class named `InactiveRocket` that extends the `Rocket` class and assigns
    an additional `lastFlow` property in the constructor:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `InactiveRocket` 的类，该类继承自 `Rocket` 类，并在构造函数中分配一个额外的 `lastFlow` 属性：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create an object named `Launcher` that defines a method named `prepareForLaunch`,
    which aborts if the rocket is inactive:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Launcher` 的对象，该对象定义了一个名为 `prepareForLaunch` 的方法，如果火箭处于非活动状态，则该方法将终止：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a `main` function that creates instances of each class of `Rocket` and
    calls `prepareForLaunch` on each:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main` 的函数，该函数创建 `Rocket` 类的每个实例，并对每个实例调用 `prepareForLaunch` 方法：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see output like the following:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/7351290c-c83a-48a2-9cd7-8df703152dad.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7351290c-c83a-48a2-9cd7-8df703152dad.png)'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Object.assign` adds all the properties from one object to another. Assigning
    all of the properties from the `Launcher` onto the new instance makes those available
    after the object is created. Remember that methods on `this` are simply properties
    on the prototype with function values. So, adding methods this way is the equivalent
    of defining these methods on the prototype.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign` 将一个对象的所有属性添加到另一个对象中。将 `Launcher` 的所有属性分配给新实例，使得在对象创建后这些属性可用。记住，`this`
    上的方法只是具有函数值的原型上的属性。因此，以这种方式添加方法是定义这些方法在原型上的等效。'
- en: Thus, after applying this mix-in with `Object.assign` we can call methods defined
    as properties on `Launcher` as instance methods of  `Rocket` and `InactiveRocket`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在应用 `Object.assign` 混合后，我们可以调用在 `Launcher` 上定义的作为 `Rocket` 和 `InactiveRocket`
    的实例方法的属性。
- en: Passing a class as an argument
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递一个类作为参数
- en: Classes, like functions, are first class citizens in JavaScript. This means
    that they can be returned from functions or passed as arguments. In this recipe,
    we'll see how to use the latter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类，就像函数一样，是 JavaScript 的一等公民。这意味着它们可以从函数中返回或作为参数传递。在这个配方中，我们将看到如何使用后者。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open your command line application and navigate to your workspace.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `08-08-passing-class-as-an-argument`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `08-08-passing-class-as-an-argument` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file that defines a new class named `Rocket`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.js` 的文件，该文件定义了一个名为 `Rocket` 的新类：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a class named `InactiveRocket` that extends the `Rocket` class and assigns
    a `name` and a `lastFlow` property in the constructor:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `InactiveRocket` 的类，该类继承自 `Rocket` 类，并在构造函数中分配一个 `name` 和一个 `lastFlow`
    属性：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a function `isA` that takes an instance and a `klass` argument and returns
    `true` if the constructor is the passed class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `isA` 的函数，该函数接受一个实例和一个 `klass` 参数，如果构造函数是传递的类，则返回 `true`：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a `main` function that creates an instance of `InactiveRocket`. Call
    `isA` to compare the instance against both `Rocket` classes:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main` 的函数，该函数创建 `InactiveRocket` 的一个实例。调用 `isA` 方法来比较实例与两个 `Rocket`
    类：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see output like the following:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/721847f1-9c2f-413f-9dda-a7ab9f72ca3e.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/721847f1-9c2f-413f-9dda-a7ab9f72ca3e.png)'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `isA` function compares the identity of the `instance` constructor property
    against the passed `klass`. This will be `true` if the `instance` argument is
    an instance of `klass` (in this case we are comparing an instance of the `InactiveRocket`
    class). It will return `false` for any other class, including `Rocket`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`isA`函数比较`instance`构造函数属性与传递的`klass`的标识。如果`instance`参数是`klass`的实例（在这种情况下，我们正在比较`InactiveRocket`类的实例），则返回`true`。对于任何其他类，包括`Rocket`，它将返回`false`。'
- en: Because we are comparing the constructor to the class directly, inheritance
    is not taken into account. If we were to use `instanceOf`, the function would
    return `true` for `Rocket` as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们是直接将构造函数与类进行比较，所以不考虑继承。如果我们使用`instanceOf`，该函数将返回`true`对于`Rocket`。
- en: Checking class inheritance with Object.getPrototypeOf
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Object.getPrototypeOf`检查类继承
- en: We've seen how to check for inheritance and identity of the instantiated class
    as a Boolean expression. We might want to also see the full ancestry of an instance
    at once. In this recipe, we'll see how to do just that.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过布尔表达式检查实例化类的继承和身份。我们可能还想一次性查看实例的完整继承关系。在这个菜谱中，我们将看到如何做到这一点。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open your command line application and navigate to your workspace.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `08-09-checking-class-inheritance`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`08-09-checking-class-inheritance`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`，该文件加载并运行来自`main.js`的`main`函数。
- en: 'Create a `main.js` file that defines three new `Rocket` classes:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个定义三个新`Rocket`类的`main.js`文件：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a function `listInheritance` that takes an instance and uses `Object.getPrototypeOf`
    to get the names of all the classes until you reach the null type:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`listInheritance`的函数，它接受一个实例并使用`Object.getPrototypeOf`获取所有类直到达到null类型：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a `main` function that creates an instance of `OrbitingRocket` and lists
    its inheritance:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main`函数，该函数创建一个`OrbitingRocket`实例并列出其继承关系：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器并在浏览器中打开以下链接：`http://localhost:8000/`。
- en: 'You should see output like the following:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/1f1e5408-4f1d-407d-b95d-6d1880d722d8.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f1e5408-4f1d-407d-b95d-6d1880d722d8.png)'
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All JavaScript prototypes exist in a hierarchy. This means each prototype is
    extended from another, which in turn extends from another. At the top of the hierarchy
    is the null type. `Object.getPrototypeOf` traverses up this inheritance tree and
    climbs its way from the prototype of the instance, all the way to the null type.
    We can then use the `name` property of each, which will give us the name of that
    prototype (or class in our case).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有JavaScript原型都存在于一个层次结构中。这意味着每个原型都从一个另一个扩展而来，反过来又从另一个扩展而来。在层次结构的顶部是null类型。`Object.getPrototypeOf`沿着继承树向上遍历，从实例的原型一直爬到null类型。然后我们可以使用每个的`name`属性，这将给出该原型的名称（或在我们的情况下是类）。
- en: Using throw to simulate abstract classes
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`throw`来模拟抽象类
- en: So far, we've seen how to create and combine classes into a variety of different
    shapes. Sometimes, however, we want to be able to prevent the creation of a class
    and only allow instances of extending classes. Other languages provide a facility
    known as abstract classes. In this recipe, we'll see how to simulate this by throwing
    errors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何创建和组合类以形成各种不同的形状。然而，有时我们想要能够防止创建一个类，并且只允许扩展类的实例。其他语言提供了一个称为抽象类的功能。在这个菜谱中，我们将看到如何通过抛出错误来模拟这一点。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open your command line application and navigate to your workspace.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `08-10-use-throw-to-simulate-abstract-class`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`08-10-use-throw-to-simulate-abstract-class`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`，该文件加载并运行来自`main.js`的`main`函数。
- en: 'Create a `main.js` file that defines a new class named `Rocket`. In the constructor,
    check the constructor of the instance, if it''s `Rocket`, then throw an error:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.js`文件，该文件定义一个名为`Rocket`的新类。在构造函数中，检查实例的构造函数，如果是`Rocket`，则抛出错误：
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create two child classes of `Rocket`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Rocket`的两个子类：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a `main` function that creates instances of each class of rocket. Notice
    that the `Rocket` class can''t be instantiated:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main`函数，该函数创建每个火箭类实例。注意，`Rocket`类不能被实例化：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在你的浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see output like the following:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/3ea7105c-7f1f-424d-a82a-1518b25fecc9.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ea7105c-7f1f-424d-a82a-1518b25fecc9.png)'
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The goal of this was to force users of the class to extend the `Rocket` class,
    rather than instantiate it directly. However, we still want to be able to define
    behavior in the `base` class. In the constructor of the `Rocket` class you can
    see how this is done. By comparing the constructor property of the instance with
    `Rocket` we can see if this has been instantiated directly. If the class is extended,
    then this comparison will evaluate `false` and the error will not be throw. Thus,
    we can create `ActiveRocket` and `InactiveRocket` instances.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是强制用户扩展`Rocket`类，而不是直接实例化它。然而，我们仍然希望能够在`base`类中定义行为。在`Rocket`类的构造函数中，你可以看到这是如何实现的。通过比较实例的构造函数属性与`Rocket`，我们可以看到这个类是否被直接实例化。如果类被扩展，那么这个比较将评估为`false`，错误将不会抛出。因此，我们可以创建`ActiveRocket`和`InactiveRocket`实例。
- en: When creating an instance of `Rocket` directly, the constructor comparison evaluates
    to `true` and the error is thrown. Thus, we can't create instances of the `Rocket`
    class, only it's sub-classes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当直接创建`Rocket`实例时，构造函数比较结果为`true`，错误被抛出。因此，我们无法创建`Rocket`类的实例，只能创建它的子类实例。
