- en: Styling the User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have our running Aurelia application and know all the basic principles
    of JavaScript programming. Our Hello World! message appears on screen, but don''t
    you think it is a little simple and static? In this chapter, we will explore how
    to add style to our application using modern tools such as SASS and LESS. Also,
    we will talk about the most important styling libraries used nowadays such as
    Bootstrap, Semantic UI, and Material Design. Finally, with all this previous learning,
    let''s make our application look cool, awesome, and attractive by configuring
    our project to use the Aurelia-Materialize plugin. Some of the tools we are going
    to use for this purpose are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS preprocessors: SASS, LESS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Task automation tools: Gulp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSS libraries: Bootstrap, Material Design, Semantic UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sounds exciting? We know yes, first we need to start talking about CSS, have
    you heard about it before? Don't worry, we will explain it in a brief but consistent
    way. Just CSS is not so awesome, so we will introduce you to some tools to make
    your style sheets awesome! Tools such SASS and LESS are very useful to these purposes,
    but we need to run some commands each time we need to use it, so we will also
    talk about task automation tools. No more manual repetitive commands! Finally,
    we don't need to reinvent the wheel. We have CSS libraries with different design
    templates, each one oriented to different concepts and purposes. Last, but not
    least, we will practice configuring our previously created application with all
    these awesome tools to make our development process more friendly and interesting. We
    are sure you will find this chapter really interesting and useful, so let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Talking about CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basically, CSS is a language structure that describes the style of some HTML
    file (can also be used for XML), defining how it should be displayed. This structure
    allows developers to manage the behavior on one or multiple web pages; any change
    performed on some CSS element will be reflected in all HTML elements linked to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSS is based on rules. These rules are defined on `.css` files, called **style
    sheet**. Style sheets can be composed of one or more rules, applied to one HTML
    or XML document; the rule has two parts: selector and declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `h4` element is the selector, and `{ color : red }` is the declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: The selector works as a link between the document and the style, specifying
    the elements that will be affected by that declaration. The statement is the part
    of the rule that states what the effect will be. In the previous example, selector
    `h4` indicates that all elements `h4` will be affected by the declaration stating
    that the color property will have the network value (red) for all elements `h4`
    of the document or documents that are linked to that style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: We have three ways to link our style sheet with the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is to use the `<link>` element, on the `<head>` section of
    the HTML file. We just need to specify the absolute or relative path/URL of our
    style sheet to import into our web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the `<style>` element of the HTML file, generally in the `<head>`
    section too. It will be loaded when our file is called by the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can style the HTML directly using the `style` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Ready to add some cool style to our application? This is just the beginning!
  prefs: []
  type: TYPE_NORMAL
- en: Exploring SASS and LESS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We were reviewing some of the most basic CSS concepts, just to refresh our knowledge
    about the syntax and elements that compose a style sheet. In the real world, a
    style sheet could have more than 20 classes belonging to one HTML page; in extreme
    cases, these classes could be one hundred or more. In these cases, maybe you will
    find CSS syntax very primitive, not auto-explanatory, and incomplete in some cases.
    It's hard to implement inheritance on big systems and over time, it could become
    hard to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: You can apply different approaches in order to write better CSS code, you can
    define different classes for each web page and then import them on one single
    CSS file, or maybe you could define parent classes and apply inheritance to child
    elements, but, in both cases, you will need to deal with maintainability problems.
  prefs: []
  type: TYPE_NORMAL
- en: It's just for the reason that in order to write better CSS code, reuse code
    in an effective way, and add some extra approaches to make it more dynamic and
    understandable to any developer, CSS preprocessors become a very used tool for
    any developer, increasing their productivity and drastically reducing the amount
    of code in our style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: As we can expect, each CSS preprocessor has its own syntax, not too different
    and not hard to learn. All of them support classic CSS; the extra features will
    be explained as we move on using the two most used tools nowadays—SASS and LESS.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are coding the web page for your company; you define the style
    sheet, and, of course, you have a font standard color for all titles, body text,
    and so on. You are writing your CSS classes and notes that you need to repeat
    the same color value on more than one class definition. Okay, it’s not so hard
    to copy and paste the same value across my entire file. You finally present that
    web page to your UX designer and oh, surprise! That red doesn’t have to be so
    deep. You need to correct to the new color code. What does that mean? You will
    need to dive into your style sheet and manually change each color value for the
    new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other programming languages, with CSS preprocessors, we can define variables
    to reuse them across our style sheet, avoid repeating the same value, and save
    time when we need to adjust or change that same value. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SASS syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, LESS syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: They're pretty similar right? Let's explore other features!
  prefs: []
  type: TYPE_NORMAL
- en: Nesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nesting elements in pure CSS are a bad deal. They are not friendly, are hard
    to read, and make us write and repeat a lot of code. Using a CSS preprocessor,
    you will provide a more friendly reading to any developer; the code auto explains
    what the CSS is doing and how the classes inherit from others. Look at the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the SASS syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same in LESS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing you need to know is that the browser does not directly interpret
    the SASS or LESS syntax. Do you need to convert your code to normal CSS syntax,
    how could you perform it? In the case of SASS, just type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'They both export the same CSS output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, CSS preprocessors provide us a more friendly readability and
    quick understanding of what the code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Extends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you define various classes that share a common definition. With
    the `@extend` feature, you can define a common class and make others extend from
    it instead of copying the same code in each one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SASS example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'LESS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'CSS output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If/else statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oh, please, this is a really awesome feature! With this feature, you will be
    able to control the aspect of your page in a reactive way, based on determined
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'SASS example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In LESS, the things are not similar. You need to use CSS guards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These are not all the preprocessor features, but at this moment, they're enough
    to start working on our FIFA World Cup application!
  prefs: []
  type: TYPE_NORMAL
- en: Automating tasks with Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to use a CSS preprocessor and how to
    compile this SASS/LESS code into pure CSS to be interpreted by the browser. Note
    that each time you make a change, you will need to recompile the entire file,
    which means that you will need to type the same command and do the same task one,
    two, and several times. Yes, it's really boring. Fortunately, we have task automation
    tools. What does that mean? Some other tool will do the dirty job for us.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gulp is an open source JavaScript-based task runner, which uses code-over-configuration
    approach to define its tasks. These could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bundling and minifying libraries and style sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refreshing your browser when you save a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quickly running unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running code analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LESS/SASS to CSS compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying modified files to an output directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This tool uses the stream module of Node.js; first of all, we need to define
    what a stream is. It can be defined as a tool that allows data reading on one
    file and takes it to another place through pipes methods. The principal feature
    of Gulp.js is that it does not write files/folders into the hard drive, like other
    automation tools. That's a good feature, because we can configure several tasks,
    and it won't impact our computer performance.
  prefs: []
  type: TYPE_NORMAL
- en: How does Gulp.js work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said before, Gulp does not write anything on the hard drive. So, all operations
    are performed at the filesystem level. It observes the file preconfigured to check
    for any change (read) and after some edition, it will rewrite the compiled content
    linked with another file, or execute some preconfigured command.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/359d4fd5-2e1c-4812-a4db-fe9c1731a2df.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gulp is available on Windows, Linux, and macOS. The installation process is
    very similar in any of these operating systems, and the only difference is that
    you need to run the installation command as administrator on UNIX-based platforms.
    You need to have already installed Node and NPM on your PC. To install, type the
    next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wait some minutes after the installation process finishes and then verify
    that all its okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That's all! We now have Gulp installed and ready to automate tasks!
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you need to ensure that your web project is already configured
    to import `npm` modules; if no `package.json` file exists, you must create one
    with the `npm init` command. To start working with Gulp, just type the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will install gulp node module locally on your project. Remember that the
    `--save-dev` flag lets `npm` update its `package.json` file in the `devDependencies`
    section to be resolved only on development time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the `gulpfile`. This file will act as manifest to
    define the tasks we want to execute. All of them should be defined in this file;
    let''s go through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`require` is a node function to add a reference to a module. Since we are referencing
    the gulp module, we are able to use this task automation method.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we run the `gulp hello-world` command from the command line, the task
    automation tool will search on the `gulpfile` the task matching by name and execute
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gulp provides three primary task methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gulp.task`: To define a new task with a name, array dependencies, and the
    function to execute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gulp.src`: It sets the folder where the source files are located'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gulp.dest`: It sets the destination folder where build files will be placed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gulp can be configured to execute any task, such as image transformation, JavaScript
    files transpiling, concatenation, and case processing. Let's see some more advanced
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will configure an automated task to transform our created SCSS files into
    CSS. This code can be implemented in any web project (with gulp dependencies preconfigured,
    of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`gulp-sass` is a customized plugin for gulp to work with SASS files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing the `npm` modules into our project, let''s reference them into
    our `gulpfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create a new task. Let''s call it `process-styles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `pipe()` method to call any extra plugins between the `.src()`
    and the `.dest()` sections. The code is so self-explanatory, we are just passing
    the route where the `gulp` `task` will find the files to be converted, then configuring
    a fault behavior if some error is raised and if everything is okay, we just specify
    the route of our generated files.
  prefs: []
  type: TYPE_NORMAL
- en: Automating tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have some task compressed into a single file. All this compression
    will be performed when we run the `gulp` command. We can group the preconfigured
    task to be run into one single command. Suppose we have three tasks already defined:
    `process-styles`, `other-task`, and `some-other-task`. Now we just need to define
    all these tasks into a single new task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Save and press *Enter* the `gulp run` command line to execute all the tasks
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s great, but we still need to enter commands manually. Rumpelstiltskin,
    that was not part of the deal! Don''t worry, we have one last surprise for you—`gulp.watch()`.
    With this method, you could monitor your source files and execute some task when
    a change is detected. Let''s configure `watch` task into our `gulpfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, rather than running `gulp` `watch` task manually, let''s configure
    a default task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Save, and then just run the command `gulp` into your terminal. You will note
    that a `gulp` observer is always looking if any change is performed in the files
    preconfigured! Of course, it includes all your `.scss` files! Now you can change
    and add new styles and view it automatically reflected in your browser, without
    the need to execute some command by yourself. If you want to terminate this watch
    process, just type *Ctrl* + *C* to abort monitoring and return to the command
    line. Now you really have a strong task automation tool configured and ready for
    use! The Aurelia CLI preconfigures `gulp` `task` activities for you, but it's
    very important to know how it works behind the scenes; also, you are able to modify
    this configuration and add custom behavior if you consider it needed.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring CSS frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are ready to start writing our first HTML elements and add style to the
    application. There are common elements that can be repeated in more than one application:
    tables, grids, input tags, select, and so on. We can define our own, but you should
    keep in mind that all of these elements need to be standardized, and defining
    it from zero can become a difficult task. Today, we have many HTML libraries and
    templates to start developing our view layer and add custom behavior to satisfy
    our own needs. Let''s explore the three most used HTML, JS, and CSS libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bootstrap is one of the most popular and complete frontend libraries. It is
    composed of HTML templates, predefined CSS classes, and JavaScript files to add
    a more dynamic behavior to each component. Created by Mark Otto and Jacob Thornton
    at Twitter and then released as open source project in August 2011, Bootstrap
    was one of the first libraries providing custom elements and a grid system to
    design responsive webs. What does responsive mean? Responsive web design is about
    creating websites that automatically adjust themselves to look good on all devices,
    from small phones to large desktops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The grid is the most important aspect of this framework. It defines the bases
    in which the layout is created. Bootstrap implements five tiers or scales based
    on the screen width. Customize the size of your columns on extra small, small,
    medium, large, or extra large devices, however you see fit. For grids that are
    the same from the smallest of devices to the largest, use the `.col` and `.col-*`
    classes. Specify a numbered class when you need a particularly sized column; otherwise,
    feel free to stick to `.col`. Let''s look at an example for a small screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c39b813-4edf-47ef-8f74-ea9262c064ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, keep the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.col-sm-1` will fit 1/12 of the screen width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.col-sm-2` will fit 1/6 of the screen width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.col-sm-4` will fit 1/3 of the screen width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.col-sm-6` will fit 1/2 of the screen width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.col-sm-12` will fit the entire screen width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the same way, Bootstrap includes a vast variety of preconfigured classes
    to simplify the alignment of our HTML elements, making our web application look
    ordered and attractive. Another thing we really like about bootstrap is the high
    customization level. We can transform all their components, adding custom behavior
    or style, and it will not generate any conflict with the existing library. An
    advanced design with some elements customized could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b41b1682-e420-4fec-8eda-054a0965ba2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Doesn't care the purpose, Bootstrap is created to provide a highly customizable
    solution for any business need you might have. Let's explore more libraries!
  prefs: []
  type: TYPE_NORMAL
- en: Material Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Powered by Google, Material Design is more than just a CSS/JS library. It's
    a complete philosophy design, based on shapes, shadows, and transitions. Material
    Design is based on three main principles.
  prefs: []
  type: TYPE_NORMAL
- en: Material is the metaphor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider all the space around you as a motion system. You can touch it, you
    can feel it, and see how it can change their aspect when you interact. Plain surfaces,
    paper, and colors are common in our daily lifestyle, and Material uses these attributes
    to create an intuitive and familiar interface to the final user, providing a big
    superset of animations without breaking the rules of physics.
  prefs: []
  type: TYPE_NORMAL
- en: Bold, graphic, and intentional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pleasing to the eyes, Material Design is not intrusive or aggressive. It implements
    a hierarchy meaning based on colors, scales, and white spaces, inviting the user
    to interact with the web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Motion provides meaning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Motion respects and reinforces the user as the prime mover. Primary user actions
    are inflection points that initiate motion, transforming the whole design. Action
    and reaction rules, serving to focus attention and maintain continuity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said before, Material is not a library, but many libraries are based
    on Material, and one of the most used nowadays is Materialize. This library provides
    all features like others, such as grid systems, prebuilt components, and custom
    behavior, with the difference that all of it is created by following Material
    Design principles. Let''s look at an example of web pages developed using Materialize:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d034b647-eb59-4846-8399-b1e2832724d6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the Material interface is simple, clean, and self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new guy in the neighborhood, Semantic comes with tons of unique new features
    based on modals, accordion elements, 3D transformations, even ratings, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '"Semantic empowers designers and developers by creating a shared vocabulary
    for UI."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Semantic UI Team'
  prefs: []
  type: TYPE_NORMAL
- en: Why *Semantic*? It's because it provides class names that sound really natural
    in common English language instead of random class names, and, of course, it describes
    what the CSS classes are doing to the HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the implementation differs from other frontend libraries; on
    Bootstrap, the names of CSS classes are very friendly for humans to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Semantic UI library, classes use human words. That''s very friendly!
    Coding is more like writing regular text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Semantic UI comes with a lot of themes, and they are easy to configure. For
    example, the following screenshot shows a web page developed using Semantic UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d4eabda-922a-4cf1-ace2-5b7d9001100c.png)'
  prefs: []
  type: TYPE_IMG
- en: You can read more about this awesome library at [https://semantic-ui.com](https://semantic-ui.com).
  prefs: []
  type: TYPE_NORMAL
- en: All the mentioned libraries are mobile-first based. What does that mean? Let's
    keep exploring!
  prefs: []
  type: TYPE_NORMAL
- en: The mobile-first approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile-first is a relatively new way to design web pages, facilitating the responsiveness
    starting always by the small screen devices, such as mobile phones or tablets.
    When you start designing, you must have a close idea of where your product will
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to choose a frontend library to start creating our first project
    components. In our opinion, Material Design can give a more natural feel to the
    final user and looks great on mobile devices (Android UI is based on Material).
    Bootstrap can be a good option too, still looking like a common web page on small
    screens. The same goes for Semantic UI, but this one has transitions and animations
    that we will really miss. So, let's start configuring our project with Materialize
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our project with Aurelia-Materialize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said in the last section, Material Design is not a library. However, many
    libraries are based on Material philosophy, so we will choose Materialize CSS.
    Their components look very natural, and the best part is that Aurelia has its
    own implementation of this library called Aurelia-Materialize, which will facilitate
    us a lot in the development process and integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open our created FIFA World Cup application and set the Terminal into
    the root folder; then we need to install some dependencies. Execute the following
    commands in the next order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ au install jquery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ au install tslib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ au install materialize-amd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ au install aurelia-materialize-bridge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our `index.html` file, lets include the Material Design icons to be imported
    into our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in our `main.js` file, we need to configure our new plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aurelia.use.plugin(''aurelia-materialize-bridge'', b => b.useAll().preventWavesAttach());`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `b => b.useAll()` script allows us to load all Aurelia-materialize components
    into our project. If you only need a few of them, you can specify each one in
    the next way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add our generated `.css` to the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<link rel="stylesheet" href="styles/css/materialize.min.css">`'
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the Aurelia CLI installed from the previous chapter, we are using
    this feature to get the new dependencies. Make sure you have at least the `0.32.0`
    version.
  prefs: []
  type: TYPE_NORMAL
- en: You are done! We are finally ready to start developing our generated, configured,
    and running web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your application folder should contain the following (or similar)
    project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1e7d1c0-1af4-4b9d-a632-5d157486c63a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are using an earlier version of `Aurelia-CLI` (`0.33.1`), please read
    the following recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: Add  `node_modules/jquery/dist/jquery.js` to the `prepend` section of the `vendor-bundle.js`
    configuration in the `aurelia.json` file and remove `jquery` from dependencies
    section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add  `node_modules/materialize-amd/dist/js/materialize.amd.js`at the end of
    `prepend` section of the `vendor-bundle.js` configuration in the `aurelia.json` and remove
    the `materialize-amd` configuration from dependencies section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to style our Aurelia application using CSS.
    Also, we explored the two most popular CSS preprocessors—LESS and SASS. We saw
    how these preprocessors help us develop more powerful style sheets using variables
    and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how to automate tasks using Gulp. Gulp is used by the Aurelia CLI
    to execute all the tasks related to it.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we went through different CSS Frameworks and explored and configured
    Google's Material Design Framework. We used Material Design to create our example
    application and take advantage of the most common UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to apply testing in our code by adopting
    Test-Driven-Development in our development process. Keep reading!
  prefs: []
  type: TYPE_NORMAL
