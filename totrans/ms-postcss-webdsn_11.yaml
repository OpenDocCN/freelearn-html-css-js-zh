- en: Chapter 11. Manipulating Custom Syntaxes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。操作自定义语法
- en: Although many developers have moved on from using preprocessors to using PostCSS,
    it is important to note that PostCSS is not a replacement, just an alternative
    way of preprocessing CSS styles. To help with the transition, we're not forced
    to learn a new syntax. Using a handful of plugins, we can take advantage of the
    speed of PostCSS, while still using syntaxes that we're accustomed to, such as
    Less, SASS, or Stylus.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多开发者已经从使用预处理器转向使用PostCSS，但重要的是要注意，PostCSS并不是替代品，而是一种预处理CSS样式的替代方法。为了帮助过渡，我们不必学习新的语法。通过使用一些插件，我们可以利用PostCSS的速度，同时仍然使用我们习惯的语法，如Less、SASS或Stylus。
- en: In this chapter, we'll take a look at the plugins that make this possible, and
    work on some simple examples that show you how using a custom syntax that we're
    all familiar with is still possible when using PostCSS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使这成为可能的插件，并工作于一些简单的示例，展示在使用PostCSS时，我们仍然可以使用我们所有人都熟悉的自定义语法。
- en: 'This chapter will cover the following technical topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下技术主题：
- en: Introducing custom syntaxes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍自定义语法
- en: Implementing examples of custom syntax plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义语法插件的示例
- en: Parsing CSS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析CSS
- en: Converting content to strings with the API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API将内容转换为字符串
- en: Adding highlighting support to our code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的代码添加高亮支持
- en: Let's make a start!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Introducing custom syntaxes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍自定义语法
- en: 'W3Schools defines a CSS syntax as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: W3Schools将CSS语法定义为如下：
- en: '*"A CSS rule-set consists of a selector and a declaration block: The selector
    points to the HTML element you want to style. The declaration block contains one
    or more declarations separated by semicolons."*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一个CSS规则集由一个选择器和声明块组成：选择器指向你想要样式的HTML元素。声明块包含一个或多个由分号分隔的声明。"*'
- en: 'We as developers spend many hours crafting sites; this can be something small
    as a one-page contact card-type site, right through to a large e-commerce website.
    It does not matter which styles we decide to use, or how we get there: the key
    is that the final result must use the same standard syntax that we''ve grown to
    love over the years.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们花费许多小时来制作网站；这可以是从一个单页联系卡片型网站到大型电子商务网站的各种大小。我们决定使用哪种样式，或者我们如何到达那里，并不重要：关键是最终结果必须使用我们多年来一直喜爱的相同标准语法。
- en: This does not mean to say that our source should be standard CSS, in fact, it
    would be very restrictive if this were the only option! We could use libraries
    such as SASS or Less, but instead, how about using the API and custom syntax plugins
    to manipulate our styles directly? We touched on some of the principles back in
    [Chapter 8](ch08.html "Chapter 8. Creating PostCSS Plugins"), *Creating PostCSS
    Plugins*; it's time to revisit this and explore how we can begin to remove this
    restriction.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们的源应该使用标准的CSS，实际上，如果这是唯一的选择，这将非常受限！我们可以使用SASS或Less等库，但相反，为什么不直接使用API和自定义语法插件来操作我们的样式呢？我们之前在[第8章](ch08.html
    "第8章。创建PostCSS插件")中提到了一些原则，即*创建PostCSS插件*；现在是时候回顾一下，并探索我们如何开始消除这种限制。
- en: Why would we want to do this, I hear you ask? The answer's simple—let's assume
    for a moment you create themes for WordPress. WordPress' default themes are created
    using SASS (and PostCSS); this means a dependency on SASS in some form. We can
    mitigate this a little by using the `gulp-sass` plugin, but this still uses `libsass`
    to compile code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，我们为什么要这样做？答案很简单——让我们假设一下，你为WordPress创建主题。WordPress的默认主题是使用SASS（和PostCSS）创建的；这意味着以某种形式依赖于SASS。我们可以通过使用`gulp-sass`插件来稍微减轻这一点，但这仍然使用`libsass`来编译代码。
- en: 'What if we could turn this on its head, and use the API and custom syntax plugins
    that parses SASS code and converts it to PostCSS equivalent? Okay, granted, we
    may not be able to cover all styles; we can at least make a start on converting
    some, and reduce our dependency on using SASS. Let''s make a start. Before we
    get stuck into producing code, we have a simple administrative task to perform:
    we need to install a syntax highlighter first.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能将其颠倒过来，并使用解析SASS代码并将其转换为PostCSS等价的API和自定义语法插件，会怎样呢？好吧，承认吧，我们可能无法涵盖所有样式；但我们至少可以开始转换一些样式，并减少我们对SASS的依赖。让我们开始吧。在我们开始编写代码之前，我们有一个简单的管理任务要执行：我们需要首先安装一个语法高亮器。
- en: Preparing our environment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备我们的环境
- en: Throughout the course of this chapter, we will be working directly with the
    PostCSS API (or a plugin's individual API, if it has one). As we are working directly
    on CSS (and not simply through a plugin's configuration object), it makes sense
    to install a syntax highlighter that works with PostCSS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将直接与PostCSS API（或插件的个人API，如果有的话）进行工作。由于我们直接在CSS上工作（而不是简单地通过插件配置对象），安装一个与PostCSS兼容的语法高亮器是有意义的。
- en: 'Not every text editor has one, but if you happen to use Sublime Text, with
    the Package Control facility installed (and I am assuming this is the case for
    the demos in this book), then it has a highlighter available for PostCSS that
    we can install. The plugin is available at [https://github.com/hudochenkov/Syntax-highlighting-for-PostCSS](https://github.com/hudochenkov/Syntax-highlighting-for-PostCSS).
    Let''s get it installed using the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个文本编辑器都有，但如果你恰好使用Sublime Text，并且安装了Package Control功能（并且我假设这本书中的演示就是这样），那么它有一个适用于PostCSS的荧光笔可供安装。该插件可在[https://github.com/hudochenkov/Syntax-highlighting-for-PostCSS](https://github.com/hudochenkov/Syntax-highlighting-for-PostCSS)获取。让我们按照以下步骤安装它：
- en: Open up Sublime Text, then press *Cmd* + *Shift* + *P* (OS X) or *Ctrl* + *Shift*
    + *P* (Linux/Windows) to open the command palette.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Sublime Text，然后按*Cmd* + *Shift* + *P*（OS X）或*Ctrl* + *Shift* + *P*（Linux/Windows）以打开命令面板。
- en: 'From the list that appears, click on **Package Control: Install Package**.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从出现的列表中，点击**Package Control: Install Package**。'
- en: After a few moments, it will show a new list; start typing `Syntax Highlighting
    for PostCSS`:![Preparing our environment](img/BO5194_11_01.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，它将显示一个新的列表；开始键入`Syntax Highlighting for PostCSS`：![准备我们的环境](img/BO5194_11_01.jpg)
- en: When it appears, click on it to install; it takes a couple of moments to complete.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它出现时，点击它进行安装；完成需要几分钟。
- en: 'We can of course simply use a highlighter that works with JavaScript; this
    won''t be the same though: having a highlighter designed for PostCSS will make
    it easier to edit code!'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以简单地使用一个与JavaScript兼容的荧光笔；但这不会完全一样：有一个专为PostCSS设计的荧光笔将使编辑代码更容易！
- en: The syntax highlighter that we've just installed comes with its own theme. If
    you like to roll your own, then you can do so, using the Base16 site at [http://chriskempson.github.io/base16/](http://chriskempson.github.io/base16/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚安装的语法高亮器自带了一个主题。如果你喜欢自己动手，那么你可以这样做，使用Base16网站[http://chriskempson.github.io/base16/](http://chriskempson.github.io/base16/)。
- en: Okay, let's move on; it's time to get stuck into code. Let's begin by exploring
    some of the plugins available for parsing code in PostCSS.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续前进；是时候深入代码了。让我们先探索一些可用于在PostCSS中解析代码的插件。
- en: Implementing custom syntax plugins
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义语法插件
- en: 'The PostCSS ecosystem contains over 100 plugins at last count; this is on the
    increase. These plugins will all serve different needs, but will have one thing
    in common: the process they use to transform our code.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最后的统计，PostCSS生态系统包含超过100个插件；这个数字还在增加。这些插件将满足不同的需求，但它们有一个共同点：它们用来转换我们代码的过程。
- en: 'Now, we should be clear that this similarity is at a very high level; we are
    not referring to the technical details of each plugin! This aside, when creating
    our own custom syntax, we must follow a three-step process:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该清楚，这种相似性是在一个非常高的层面上；我们并不是指每个插件的详细技术细节！除此之外，当我们创建自己的自定义语法时，我们必须遵循一个三步过程：
- en: We first put our code through a parser.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过解析器处理我们的代码。
- en: We then transform it using anyone of a number of plugins.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用任何一种插件对其进行转换。
- en: We finally stringify it, or convert it to valid CSS in string format.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终将其转换为字符串，或者将其转换为字符串格式的有效CSS。
- en: 'We already have a handful of plugins that allow us to work with other syntaxes
    within a PostCSS environment; these include languages such as less or JavaScript:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一系列插件，允许我们在PostCSS环境中使用其他语法；这些包括如less或JavaScript等语言：
- en: '| Name of plugin | Purpose of plugin |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 插件名称 | 插件用途 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sugarss` | This plugin is an indent-based syntax like SASS or Stylus.Plugin
    is available from [https://github.com/postcss/sugarss](https://github.com/postcss/sugarss).
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `sugarss` | 这个插件是一个基于缩进的语法，类似于SASS或Stylus。插件可在[https://github.com/postcss/sugarss](https://github.com/postcss/sugarss)获取。
    |'
- en: '| `postcss-less` | We can use this plugin to transform less into valid CSS.
    Note: it does not compile code.Plugin is available from [https://github.com/webschik/postcss-less](https://github.com/webschik/postcss-less).
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `postcss-less` | 我们可以使用这个插件将less转换为有效的CSS。注意：它不会编译代码。插件可在[https://github.com/webschik/postcss-less](https://github.com/webschik/postcss-less)获取。
    |'
- en: '| `postcss-js` | Anyone working with JavaScript can use this plugin to write
    styles in JS or transform React Inline Styles, Radium, or JSS.Plugin is available
    from [https://github.com/postcss/postcss-js](https://github.com/postcss/postcss-js).
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `postcss-js` | 任何与 JavaScript 一起工作的人都可以使用这个插件用 JS 编写样式或转换 React 内联样式、Radium
    或 JSS。插件可以从 [https://github.com/postcss/postcss-js](https://github.com/postcss/postcss-js)
    获取。 |'
- en: '| `postcss-scss` | For those of you using SASS, this plugin is perfect for
    working with SASS code; it does *not* compile code to CSS.Plugin is available
    from [https://github.com/postcss/postcss-scss](https://github.com/postcss/postcss-scss).
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `postcss-scss` | 对于使用 SASS 的您，这个插件非常适合处理 SASS 代码；它不会将代码编译为 CSS。插件可以从 [https://github.com/postcss/postcss-scss](https://github.com/postcss/postcss-scss)
    获取。 |'
- en: '| `postcss-safe-parser` | This plugin is perfect for finding and fixing CSS
    syntax errors.It''s available to download from [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser).
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `postcss-safe-parser` | 这个插件非常适合查找和修复 CSS 语法错误。您可以从 [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser)
    下载。 |'
- en: '| `poststylus` | We can use this plugin to transform styles created using the
    Stylus library into valid CSS. Note: it does not compile code.Plugin is available
    from [https://github.com/seaneking/poststylus](https://github.com/seaneking/poststylus).
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `poststylus` | 我们可以使用这个插件将使用 Stylus 库创建的样式转换为有效的 CSS。注意：它不会编译代码。插件可以从 [https://github.com/seaneking/poststylus](https://github.com/seaneking/poststylus)
    获取。 |'
- en: 'Although all of these plugins serve a different purpose, they all follow the
    same principle: they parse the code and transform it, before converting it to
    a format that can be saved to file as a valid style sheet output.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些插件都服务于不同的目的，但它们都遵循相同的原理：解析代码并对其进行转换，然后再将其转换为可以保存为有效样式表输出的格式。
- en: 'Leaving aside which parser we use, there is one question though: why would
    we want to manipulate our code directly? There are a few reasons for needing to
    alter the code directly; here are a few:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们使用哪个解析器，但有一个问题：我们为什么要直接操作我们的代码呢？需要直接修改代码的原因有几个；以下是一些：
- en: We may want to create a report that details facts and figures about our code
    for reference purposes; it is true that there will be plugins or scripts available
    to do this already, but PostCSS can get us the basics during compilation, and
    not as a separate process.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想创建一份报告，详细说明有关我们代码的事实和数字，供参考之用；确实，已经有插件或脚本可以做到这一点，但 PostCSS 可以在编译期间为我们提供基本功能，而不是作为一个单独的过程。
- en: How about this for an idea? If you happen to use an application such as Adobe
    Color CC, then we can consider using the API to directly transform specific colors
    into valid RGB(A) or HEX equivalent values. We could use a plugin to achieve this,
    but performing this directly using the API allows us to retain flexibility with
    our choice of colors.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个想法怎么样？如果你恰好使用 Adobe Color CC 这样的应用程序，那么我们可以考虑使用 API 直接将特定颜色转换为有效的 RGB(A) 或
    HEX 等价值。我们可以使用一个插件来实现这一点，但直接使用 API 执行此操作可以让我们在颜色选择上保持灵活性。
- en: There is nothing stopping us from dissecting existing plugins, and rebasing
    the tasks they perform into something that we could add to a task runner file,
    and then adapt to our needs. We might ultimately consider creating a plugin, but
    if the steps required are very specific to our needs, then a plugin may not be
    a useful addition.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何阻止我们剖析现有插件，并将它们执行的任务重新基座为我们可以添加到任务运行器文件中的内容，然后根据我们的需求进行适配。我们最终可能会考虑创建一个插件，但如果所需的步骤非常具体，那么插件可能不是一个有用的补充。
- en: There are occasions when error handling can be lacking. The API contains some
    useful functionality that allows us to add suitably formatted messages on screen,
    if our process fails.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候错误处理可能会不足。API 包含一些有用的功能，允许我们在进程失败时在屏幕上添加适当格式的消息。
- en: These are just a few ideas to get started, in addition to manipulating existing
    non-PostCSS styles (such as those created using SASS, for example).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些启动想法，除了操作现有的非 PostCSS 样式（例如使用 SASS 创建的样式）之外。
- en: Enough talking, I feel a demo coming! We've met some of the plugins available,
    so it's time to put them to good use; two of particular interest are the `postcss-scss`
    and `postcss-safe-parser` plugins. Let's dive in and take a look at them in more
    detail, beginning with `postcss-safe-parser`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 谈得够多了，我感觉一个演示即将到来！我们已经遇到了一些可用的插件，所以是时候将它们用于实际用途了；其中两个特别有趣的是 `postcss-scss` 和
    `postcss-safe-parser` 插件。让我们深入探讨并更详细地查看它们，从 `postcss-safe-parser` 开始。
- en: Parsing content and fixing errors
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析内容和修复错误
- en: Over the next few pages, we'll touch on using a couple of parser plugins, to
    show how easy it is to transform our code. We will take a look at a plugin that
    removes the need for SASS (at least at a basic level); before we do so, let's
    first explore using the `postcss-safe-parser` plugin.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将简要介绍使用几个解析器插件，以展示如何轻松地转换我们的代码。我们将查看一个插件，它消除了对 SASS 的需求（至少在基本级别上）；在这样做之前，让我们首先探索使用
    `postcss-safe-parser` 插件。
- en: 'The `postcss-safe-parser` plugin, available from [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser),
    is perfect for finding and fixing CSS errors. It''s a simple plugin to use and
    install; let''s make a start:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可从 [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser)
    获取的 `postcss-safe-parser` 插件，非常适合查找和修复 CSS 错误。这是一个简单易用的插件，让我们开始使用它：
- en: We'll start by installing the plugin, so go ahead, and fire up a Node.js command
    prompt session, then change the working directory to the root of our project area.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先安装插件，所以请启动一个 Node.js 命令提示符会话，然后更改工作目录到我们的项目区域根目录。
- en: 'At the prompt, enter this command, then press *Enter* to install the plugin:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入以下命令，然后按 *Enter* 安装插件：
- en: '[PRE0]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, go ahead and extract a copy of the `T58 – parsing invalid content` folder
    from the code download that accompanies this book; save it to the root of our
    project area.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请从本书附带的代码下载中提取 `T58 – 解析无效内容` 文件夹的副本；将其保存到我们的项目区域根目录。
- en: Copy the `package.json` and `gulpfile.js` files from it to the root of our project
    area.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `package.json` 和 `gulpfile.js` 文件从其中复制到我们的项目区域根目录。
- en: Switch back to the NodeJS command prompt session, then at the prompt, enter
    `gulp` and press *Enter*.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回 NodeJS 命令提示符会话，然后在提示符下，输入 `gulp` 并按 *Enter*。
- en: 'If all is well, we should see a successful compilation: a file marked `output.css`
    will be created at the root of our project area.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到成功的编译：在项目区域根目录中创建一个标记为 `output.css` 的文件。
- en: 'Go ahead and open it. Even though our example only contained one malformed
    selector, the file contains the same selector, but this time with the missing
    closing parenthesis added. We can also see the results appear in the console log
    at the same time as seen in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，打开它。尽管我们的示例只包含一个格式错误的选择器，但文件中包含相同的选择器，但这次添加了缺失的闭合括号。我们还可以在下面的屏幕截图中所见的同时，在控制台日志中看到结果：
- en: '![Parsing content and fixing errors](img/BO5194_11_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![解析内容和修复错误](img/BO5194_11_02.jpg)'
- en: So what's going on here? Well, some of this will be familiar. We're using a
    standard format task in our Gulp file, along with references to some of the plugins
    that we've already met, such as `autoprefixer`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？嗯，其中一些可能很熟悉。我们在 Gulp 文件中使用标准格式任务，以及一些我们已遇到的插件的引用，例如 `autoprefixer`。
- en: 'The content that is of interest to us though, is in the default Gulp task as
    seen in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们感兴趣的内容在默认的 Gulp 任务中，如下面的屏幕截图所示：
- en: '![Parsing content and fixing errors](img/BO5194_11_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![解析内容和修复错误](img/BO5194_11_03.jpg)'
- en: The task may seem a little complex, but in reality, we're parsing our CSS, prior
    to manipulating it. We start by defining a `postcss` object (into which feeds
    a request to run `autoprefixer`). This then processes our CSS into an AST, using
    a parser to find and fix any issues, before piping it out on screen and into a
    file named `output.css` in our project area.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务可能看起来有点复杂，但实际上，我们在操作它之前解析了我们的 CSS。我们首先定义一个 `postcss` 对象（向其中发送一个运行 `autoprefixer`
    的请求）。然后，使用解析器找到并修复任何问题，将 CSS 处理成 AST，在屏幕上显示，并在我们的项目区域中创建一个名为 `output.css` 的文件。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Abstract Syntax Trees** (**AST**) are a graphical tree representation of
    the syntactic structure of our CSS style sheets or code.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象语法树**（**AST**）是我们 CSS 样式表或代码的语法结构的图形树表示。'
- en: Okay, our example was very simplistic, but this was intended to show you how
    the principle works. In this next example, the same principle has been used to
    convert standard SCSS code to valid CSS; note, though, that we're not calling
    SASS (as we have done before), but converting the SCSS code to valid CSS styles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的示例非常简单，但这是为了向您展示原理。在下一个示例中，使用了相同的原则将标准 SCSS 代码转换为有效的 CSS；请注意，但我们没有调用 SASS（如我们之前所做），而是将
    SCSS 代码转换为有效的 CSS 样式。
- en: Parsing SCSS content
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 SCSS 内容
- en: In our previous demo, we explored the use of PostCSS to parse our CSS and added
    the missing closing bracket as a fix for our code. It was a simplistic example;
    perfect if you're working with standard CSS, but what if your projects are using
    SASS?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的演示中，我们探讨了使用PostCSS解析我们的CSS，并添加了缺失的闭合括号作为修复代码的解决方案。这是一个简单的例子；如果你使用的是标准CSS，那就再合适不过了，但如果你项目使用的是SASS呢？
- en: 'Well, as part of our next example, we''ll prove that using a compiler is now
    old hat; we''ll use the `postcss-scss` plugin (from [https://github.com/postcss/postcss-scss](https://github.com/postcss/postcss-scss))
    to directly transform our SASS code, before unwrapping the nesting styles using
    the `postcss-nested` plugin (available from [https://github.com/postcss/postcss-nested](https://github.com/postcss/postcss-nested)):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，作为我们下一个示例的一部分，我们将证明使用编译器已经过时了；我们将使用`postcss-scss`插件（来自[https://github.com/postcss/postcss-scss](https://github.com/postcss/postcss-scss)）直接转换我们的SASS代码，在展开嵌套样式之前使用`postcss-nested`插件（可在[https://github.com/postcss/postcss-nested](https://github.com/postcss/postcss-nested)）：
- en: We'll start by installing the `postcss-scss` plugin. Go ahead and fire up a
    NodeJS command prompt session, then change the working directory to the root of
    our project area.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先安装`postcss-scss`插件。启动一个NodeJS命令提示符会话，然后更改工作目录到我们项目区域的根目录。
- en: 'At the prompt, enter this command, then press *Enter*:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中输入此命令，然后按*Enter*键：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Keep the session open when the plugin has completed installation:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 插件安装完成后，保持会话打开：
- en: '![Parsing SCSS content](img/BO5194_11_04.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![解析SCSS内容](img/BO5194_11_04.jpg)'
- en: From the downloaded code that accompanies this book, go ahead and extract a
    copy of the `package.json` file from the `T59 – Parsing SCSS content` folder.
    Save this to the root of our project area.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的下载代码中，从`T59 – 解析SCSS内容`文件夹中提取`package.json`文件的副本。将其保存到我们项目区域的根目录。
- en: From the same `T59 – Parsing SCSS` content folder, copy the contents of the
    `src` folder to the `src` folder at the root of our project area.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从相同的`T59 – 解析SCSS`内容文件夹中，将`src`文件夹的内容复制到我们项目区域根目录的`src`文件夹。
- en: 'In a new file, add the following code and save it as `gulpfile.js` in the `src`
    folder at the root of our project area:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码并将其保存为`gulpfile.js`，存放在我们项目区域的`src`文件夹中：
- en: '[PRE2]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The keen-eyed amongst you will spot the reference to `postcss-nested`. We cannot
    call PostCSS without specifying something, so we''ll use this plugin to unwrap
    the nested statements in our code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 眼尖的你们中的一些人会发现对`postcss-nested`的引用。我们不指定任何内容就不能调用PostCSS，所以我们将使用此插件来展开我们代码中的嵌套语句：
- en: 'Revert back to the NodeJS command prompt session, then add this command and
    press *Enter*:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回NodeJS命令提示符会话，然后输入以下命令并按*Enter*键：
- en: '[PRE3]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once Node has completed installing the plugin, enter `gulp` at the prompt then
    press *Enter*:![Parsing SCSS content](img/BO5194_11_05.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Node完成了插件的安装，在提示符中输入`gulp`然后按*Enter*键：![解析SCSS内容](img/BO5194_11_05.jpg)
- en: If all is well, we will see a compiled file appear in the `dest` folder:![Parsing
    SCSS content](img/BO5194_11_06.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将在`dest`文件夹中看到一个编译后的文件：![解析SCSS内容](img/BO5194_11_06.jpg)
- en: 'But hold on a moment: this is a valid *CSS* file, right? Absolutely. But…we''ve
    so far had to use a compiler to produce valid CSS code; how come we haven''t needed
    to add one now?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等：这是一个有效的*CSS*文件，对吧？绝对正确。但是……到目前为止，我们不得不使用编译器来生成有效的CSS代码；为什么现在我们不需要添加一个呢？
- en: Exploring what happened
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索发生了什么
- en: Well, the answer lies in the conversion process—traditionally we would have
    had to compile our code, even though standard SASS files are a superset of current
    CSS. Instead, we've simply *rewritten* our code using a syntax that translates
    a standard SCSS file to valid CSS.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，答案在于转换过程——传统上我们不得不编译我们的代码，尽管标准SASS文件是当前CSS的超集。相反，我们只是简单地使用一种语法来*重写*我们的代码，这种语法可以将标准SCSS文件转换为有效的CSS。
- en: If we take a look at our Gulp file in more detail, we can see references to
    the standard `gulp-postcss` plugin, along with declared instances of the `fs`,
    `autoprefixer`, `postcss-nested`, and `postcss-scss` plugins. The key for this
    demo starts on line 10, where we declare an instance of the `scss` variable, and
    use the **file system** (**fs**) plugin for Node to read the contents of the file
    into this variable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更详细地查看我们的Gulp文件，我们可以看到对标准`gulp-postcss`插件的引用，以及`fs`、`autoprefixer`、`postcss-nested`和`postcss-scss`插件的声明实例。这个演示的关键从第10行开始，在那里我们声明了`scss`变量的实例，并使用Node的**文件系统**（**fs**）插件将文件内容读入这个变量。
- en: Once into the task, we create an instance of PostCSS as an object, before feeding
    it the `autoprefixer` and `nested()` plugins (as variables). We then process our
    SASS code using the syntax that comes with the `postcss-scss` plugin, before piping
    out the contents as a file into the `dest` folder in our project area.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入任务，我们创建一个PostCSS实例作为对象，然后向它提供`autoprefixer`和`nested()`插件（作为变量）。然后我们使用`postcss-scss`插件附带的语法处理我们的SASS代码，然后将内容作为文件通过管道输出到我们的项目区域的`dest`文件夹。
- en: See? Nice and easy; not a SASS compiler in sight! This simple change removes
    the need for any dependency on a compiler, after all, SCSS files are just standard
    CSS text files, so why use a compiler? With all of this talk of parsing CSS (or
    SCSS for that matter), it's worth spending some time exploring what we mean by
    this, and how it is important to the whole process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看见了吗？简单又容易；周围没有SASS编译器！这个简单的更改消除了对编译器的任何依赖，毕竟，SCSS文件只是标准的CSS文本文件，所以为什么还要使用编译器呢？在所有关于解析CSS（或者SCSS）的讨论中，花些时间探索我们所说的含义以及它对整个过程的重要性是值得的。
- en: Parsing CSS
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析CSS
- en: 'At the heart of writing any custom syntax is the ability to parse content—it
    doesn''t matter whether this is CSS, JavaScript, or something else; we clearly
    need to understand what we''re working with, before we can make changes! At a
    basic level, these are the steps we must take to transform our CSS when working
    with PostCSS:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何自定义语法的核心是解析内容的能力——这无关紧要这是CSS、JavaScript还是其他什么；在我们能够做出更改之前，我们显然需要了解我们正在处理的内容！在基本层面上，当我们使用PostCSS处理CSS时，我们必须采取以下步骤来转换我们的CSS：
- en: '![Parsing CSS](img/BO5194_11_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![解析CSS](img/BO5194_11_07.jpg)'
- en: We begin with our source CSS (which comes with or without a source map), which
    we parse only once, but then put through any number of specified plugins (the
    example shows two, but we can easily use more). We then convert the output to
    a string using a stringifier; at this point, we can view the contents on screen
    or save them to disk.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从源CSS（可能带有或没有源映射）开始，我们只解析一次，但随后通过任何指定的插件（示例中显示两个，但我们可以轻松使用更多）。然后我们使用字符串化器将输出转换为字符串；在这个时候，我们可以在屏幕上查看内容或将它们保存到磁盘。
- en: 'Let''s for a moment take a look at parsing some example code. For this next
    example, we will use a single CSS rule and parse it using the `postcss-value-parser`
    plugin (from [https://github.com/TrySound/postcss-value-parser](https://github.com/TrySound/postcss-value-parser));
    the reason for this will become clear shortly:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时看看解析一些示例代码。在这个下一个示例中，我们将使用一个CSS规则，并使用`postcss-value-parser`插件（来自[https://github.com/TrySound/postcss-value-parser](https://github.com/TrySound/postcss-value-parser)）来解析它；原因很快就会变得清楚：
- en: From the code download that accompanies this book, extract and save copies of
    the `gulpfile.js` and `package.json` files from the `T60 – parsing color values`
    folder to the root of our project area; if you want to save any existing files
    from there, then please do so first.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码下载中，从“T60 – 解析颜色值”文件夹中提取并保存`gulpfile.js`和`package.json`文件的副本到我们的项目区域根目录；如果您想保存那里现有的任何文件，请先这样做。
- en: Fire up a NodeJS command prompt session then change the working folder to the
    root of our project area.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个NodeJS命令提示符会话，然后更改工作文件夹到我们的项目区域根目录。
- en: 'We need to install the `postcss-value-parser` plugin, so at the prompt, enter
    this command and press *Enter*:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要安装`postcss-value-parser`插件，所以在提示符下，输入以下命令然后按*Enter*：
- en: '[PRE4]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'NPM will now install the plugin; keep the session open when it has finished:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NPM现在将安装插件；在完成时保持会话打开：
- en: '![Parsing CSS](img/BO5194_11_08.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![解析CSS](img/BO5194_11_08.jpg)'
- en: At the prompt, type `gulp` then press *Enter*; gulp will now go away and display
    the contents, which will look something like this:![Parsing CSS](img/BO5194_11_09.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，键入`gulp`然后按*Enter*；现在gulp将消失并显示内容，看起来可能像这样：![解析CSS](img/BO5194_11_09.jpg)
- en: Yikes! What does that all mean? Don't worry, it looks worse than it really is;
    this is an example of an AST, which we discussed earlier in this chapter. This
    gives us in-depth information on the contents of our CSS, such as the values,
    types of values, and where they appear in the tree.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这一切意味着什么？别担心，看起来比实际情况更糟；这是一个AST的例子，我们之前在本章中讨论过。这为我们提供了关于CSS内容的深入信息，例如值、值的类型以及它们在树中的位置。
- en: The great thing, though, is that once we have all of this content, then we are
    free to query and manipulate the content at will. Once we have manipulated the
    content, we then need to convert it to string format, so it can be displayed on
    screen in a more intelligent format, or saved to disk.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，好的一点是，一旦我们有了所有这些内容，我们就可以随意查询和操作内容。一旦我们操作了内容，我们就需要将其转换为字符串格式，以便以更智能的格式在屏幕上显示，或者保存到磁盘。
- en: For this demo, we used the `postcss-value-parser` plugin to create our AST;
    we can also try using the `postcss-safe-` `parser` plugin (from [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser)),
    or the `postcss-selector-parser` plugin (from [https://github.com/postcss/postcss-selector-parser](https://github.com/postcss/postcss-selector-parser)),
    to achieve similar effects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们使用了 `postcss-value-parser` 插件来创建我们的抽象语法树（AST）；我们也可以尝试使用 `postcss-safe-`
    `parser` 插件（来自 [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser)），或者
    `postcss-selector-parser` 插件（来自 [https://github.com/postcss/postcss-selector-parser](https://github.com/postcss/postcss-selector-parser)），以实现类似的效果。
- en: And the reason why we only used one line of CSS code in our demo? Well, parsing
    CSS code can get very complex. The example shown in our demo is relatively straightforward;
    just imagine what it will be like with 2,000+ lines of code!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 至于为什么我们在演示中只使用了一行 CSS 代码？嗯，解析 CSS 代码可能会变得非常复杂。我们演示中的例子相对简单；想象一下如果有 2,000+ 行代码会是什么样子！
- en: Let's develop this theme further, and use it to replace some example RGBA values
    with equivalent HEX-based colors. We can easily do this through the use of the
    `postc` `ss-unrgba` plugin (from [https://github.com/jonathantneal/postcss-unrgba](https://github.com/jonathantneal/postcss-unrgba)),
    but it weighs in at almost 60 lines; our Gulp file is 43 lines, and a lot of that
    is comments!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步开发这个主题，并使用它来替换一些示例 RGBA 值为等效的基于十六进制的颜色。我们可以通过使用 `postc` `ss-unrgba` 插件（来自
    [https://github.com/jonathantneal/postcss-unrgba](https://github.com/jonathantneal/postcss-unrgba)）轻松做到这一点，但它有近
    60 行代码；我们的 Gulp 文件有 43 行，其中很多是注释！
- en: Replacing RGBA colors
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换 RGBA 颜色
- en: 'Our next example is a relatively straightforward search and replace; it is
    a perfect example of how it isn''t always necessary to use plugins, and that we
    can parse our code directly to achieve the same effect. Let''s make a start:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的例子是一个相对简单的搜索和替换；这是一个很好的例子，说明了并不总是需要使用插件，我们可以直接解析代码以实现相同的效果。让我们开始吧：
- en: We'll start by extracting a copy of the `T61 – changing colors` folder from
    the downloaded code that accompanies this book; save the folder to the root of
    our project area.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从本书附带的下载代码中提取 `T61 – 更改颜色` 文件夹的副本；将文件夹保存到我们的项目区域根目录。
- en: Copy the `gulpfile.js` and `package.json` files from the `T61 – changing colors`
    folder to the root of our project area.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `gulpfile.js` 和 `package.json` 文件从 `T61 – 更改颜色` 文件夹复制到我们的项目区域根目录。
- en: Copy the `src` folder from the `T61 – changing colors` folder to the root of
    our project area.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `src` 文件夹从 `T61 – 更改颜色` 文件夹复制到我们的项目区域根目录。
- en: Next, fire up a NodeJS command prompt session then change the working folder
    to the root of our project area.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动一个 NodeJS 命令提示符会话，然后更改工作文件夹到我们的项目区域根目录。
- en: We now need to install an additional plugin, `color-convert` (available from
    [https://github.com/qix-/color-convert](https://github.com/qix-/color-convert)),
    which we will use to change the color once we've sucked out the details from within
    the AST. For this, go ahead and fire up a NodeJS command prompt, then change the
    working folder to the root of our project area.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要安装一个额外的插件，`color-convert`（可在 [https://github.com/qix-/color-convert](https://github.com/qix-/color-convert)
    获取），我们将使用它从抽象语法树（AST）中提取细节后更改颜色。为此，请启动一个 NodeJS 命令提示符，然后更改工作文件夹到我们的项目区域根目录。
- en: At the prompt, enter `npm install color-convert --save-dev` and press *Enter*.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入 `npm install color-convert --save-dev` 并按 *Enter*。
- en: When the plugin has finished installing, go ahead and enter `gulp`, then press
    *Enter*. If all is well, we should see the, by now, familiar transformed style
    sheet appear in our destination folder:![Replacing RGBA colors](img/BO5194_11_10.jpg)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当插件安装完成后，请输入 `gulp` 并按 *Enter*。如果一切顺利，我们应能看到现在熟悉的转换后的样式表出现在目标文件夹中：![替换 RGBA
    颜色](img/BO5194_11_10.jpg)
- en: 'At this point, our style sheet has been transformed. If we preview the results
    in a text editor, we can confirm that HEX-equivalent values have indeed replaced
    the original RGBA colors, as shown in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的样式表已经发生了转换。如果我们在一个文本编辑器中预览结果，我们可以确认确实用十六进制等效值替换了原始的 RGBA 颜色，如下面的截图所示：
- en: '![Replacing RGBA colors](img/BO5194_11_11.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![替换 RGBA 颜色](img/BO5194_11_11.jpg)'
- en: 'Not convinced? Take a look at the same rule within the source file; here it
    shows the original RGBA value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还不放心？看看源文件中的相同规则；这里显示了原始的 RGBA 值：
- en: '![Replacing RGBA colors](img/BO5194_11_12.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![替换 RGBA 颜色](img/BO5194_11_12.jpg)'
- en: See how easy that was? There is one thing note; if we take a look at the Gulp
    file, it might at first glance look like we still have a few plugins in use. The
    key here is that three of these are part of Node (`fs`, `path`, and `util`), so
    we haven't had to install any new ones, over and above the `value-parser` and
    `color-convert` examples.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单？有一点需要注意；如果我们看一下 Gulp 文件，乍一看可能觉得我们还在使用几个插件。关键在于这三个都是 Node 的部分（`fs`、`path`和`util`），所以我们没有安装任何新的插件，除了`value-parser`和`color-convert`示例之外。
- en: Exploring how it all works
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索它是如何工作的
- en: It's worth taking the time to consider this code in more detail. This contains
    some useful techniques that will help get you started on the road to creating
    custom syntaxes, starting with retrieving the values we need.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花时间更详细地考虑这段代码。它包含了一些有用的技术，这些技术将帮助你开始创建自定义语法，从检索我们需要的值开始。
- en: We begin with reading the contents of our style sheet file, before parsing it
    through the `postcss-value-parser` plugin. We walk through each node within the
    AST, ignoring any that contain a `node.type` of function or a `node.value` of
    `rgba`. For any that remain, we collect any that have a node type of word, before
    mapping them into a single array value which we convert to a number.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取样式表文件的正文内容，然后通过`postcss-value-parser`插件对其进行解析。我们遍历AST中的每个节点，忽略任何包含`node.type`为函数或`node.value`为`rgba`的节点。对于剩下的节点，我们收集任何具有单词类型的节点，然后将它们映射到一个单一的数组值中，并将其转换为数字。
- en: This is then transformed from a function node to a word node, before we finally
    convert the value from an RGBA to HEX color. The contents are converted to a string,
    and saved to disk in the destination folder, with the same file name.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其从函数节点转换为单词节点，在我们最终将值从 RGBA 转换为 HEX 颜色之前。内容被转换为字符串，并保存到目标文件夹中的同一文件名。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Node types represent the type of selector we're working with—examples include
    `root`, `string`, `tag`, and `attribute`. In our example, we've used `node.type`
    to display a string representation of the selector type, which we can manipulate
    in code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 节点类型代表我们正在处理的选择器类型——例如包括`root`、`string`、`tag`和`attribute`。在我们的例子中，我们使用了`node.type`来显示选择器类型的字符串表示形式，我们可以在代码中对其进行操作。
- en: 'Okay, let''s move on: the key basis for working with custom syntaxes is to
    understand the content we need to work with; crack this and you are part of the
    way to transforming your styles into valid CSS. To help with the process, though,
    we will need to convert our content to a format that can be saved to disk. It''s
    time to take a look at how, using the PostCSS API.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续：使用自定义语法的关键基础是理解我们需要处理的内容；破解这一点，你就已经是在将你的样式转换为有效 CSS 的一部分了。不过，为了帮助这个过程，我们需要将我们的内容转换为可以保存到磁盘的格式。现在是时候看看如何使用
    PostCSS API 来实现了。
- en: Formatting the output with the API
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 API 格式化输出
- en: 'When parsing CSS, the output by default is going to resemble something as shown
    in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析 CSS 时，默认输出将类似于以下截图所示：
- en: '![Formatting the output with the API](img/BO5194_11_13.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![使用 API 格式化输出](img/BO5194_11_13.jpg)'
- en: 'It looks a really ugly mess, but is in fact the standard format for an AST
    tree. The trouble is, it''s not very helpful if we want to use details from it
    in our code! To get around this, we need to convert our content into a string
    format: the simplest method is to use the .`toString()` method, which is perfect
    for saving the content to disk.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来真的很乱，但实际上它是 AST 树的标准格式。问题是，如果我们想在代码中使用其中的细节，它并不太有帮助！为了解决这个问题，我们需要将我们的内容转换为字符串格式：最简单的方法是使用`.toString()`方法，这对于将内容保存到磁盘来说非常合适。
- en: All of the code for the next exercise is in the `T62 – adding a stringifier`
    folder in the code download that accompanies this book.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个练习的所有代码都包含在这本书附带的代码下载中的`T62 – 添加一个字符串化器`文件夹里。
- en: 'It''s a cinch to use in our Gulp file; let''s take a look as part of our next
    exercise:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Gulp文件中使用它非常简单；让我们在下一个练习中看看：
- en: 'We''ll start by creating a new Gulp task file. In your usual text editor of
    choice, add the following code; there is a reasonable amount involved, so we will
    go through it in sections, beginning with the declarations for the plugins used:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的Gulp任务文件。在你的首选文本编辑器中，添加以下代码；涉及的内容相当多，所以我们将分部分进行，从插件声明开始：
- en: '[PRE5]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We need to set up a few variables; these will be used to store values generated
    during the compilation process:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置一些变量；这些将在编译过程中生成值：
- en: '[PRE6]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next up is the start of our task. The first step is to parse some simple CSS,
    as a basis for our demo. We then get the first child in our code, and save it
    to the `decl` variable:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是任务的开头。第一步是解析一些简单的CSS，作为我们的演示的基础。然后我们获取代码中的第一个子元素，并将其保存到`decl`变量中：
- en: '[PRE7]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first piece of information we want is a selector count; this next block
    will count through each selector using `root.walkRules`, and push the value into
    the `selectors` array:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要的第一条信息是选择器数量；接下来的这个块将使用`root.walkRules`遍历每个选择器，并将值推入`selectors`数组：
- en: '[PRE8]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, we''re ready to pipe out a summary report of our code—we use
    `console.log` to display a number of different values on screen:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好输出代码的总结报告——我们使用`console.log`在屏幕上显示多个不同的值：
- en: '[PRE9]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re almost there—in this next block, we do the PostCSS equivalent of a search
    and replace to update our color from black to white:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了——在这个下一个块中，我们执行了PostCSS的搜索和替换操作，将我们的颜色从黑色更改为白色：
- en: '[PRE10]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can display our content on screen, but a more useful step is to save it
    to disk—for this, we can use the `fs` plugin from Node.js to create our transformed
    CSS file and associated source map:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在屏幕上显示我们的内容，但一个更有用的步骤是将它保存到磁盘上——为此，我们可以使用Node.js的`fs`插件来创建我们的转换后的CSS文件和相关的源映射：
- en: '[PRE11]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save the Gulp file to the root of our project area, then fire up a Node.js command
    prompt, and change the working directory to that of our project area.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Gulp文件保存到我们的项目区域的根目录，然后启动一个Node.js命令提示符，并将工作目录更改为我们的项目区域。
- en: At the prompt, type in `gulp`, then press *Enter* and let the compilation complete.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，键入`gulp`，然后按*Enter*键，等待编译完成。
- en: 'If all is well, we should see the results of step 6 appear on screen, like
    so:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在屏幕上看到第6步的结果，如下所示：
- en: '![Formatting the output with the API](img/BO5194_11_14.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用API格式化输出](img/BO5194_11_14.jpg)'
- en: 'The transformed CSS file and source map will be present in the `dest` folder:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转换后的CSS文件和源映射将出现在`dest`文件夹中：
- en: '![Formatting the output with the API](img/BO5194_11_15.jpg)'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用API格式化输出](img/BO5194_11_15.jpg)'
- en: So, how does this all help us? Well, the ability to parse our code directly
    opens up some real possibilities; let's pause for a moment to explore what has
    happened in our demo, and how we can take advantage of this functionality in future
    projects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切是如何帮到我们的呢？嗯，直接解析我们的代码的能力打开了一些真正的可能性；让我们暂停一下，看看我们的演示中发生了什么，以及我们如何在未来的项目中利用这个功能。
- en: Dissecting our example code
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析我们的示例代码
- en: Throughout the book, we've used a variety of plugins to transform our code.
    These will all make use of the PostCSS API in some form. However, we are not limited
    to simply using plugins; we can also transform our code directly using the API.
    At this point, it should be noted that we are not talking about creating a custom
    parser; indeed, this would easily form enough content for a short book in its
    own right!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用了各种插件来转换我们的代码。这些都会以某种形式使用PostCSS API。然而，我们不仅限于简单地使用插件；我们还可以直接使用API来转换我们的代码。此时，应该注意的是，我们不是在谈论创建一个自定义解析器；实际上，这很容易形成一个足够的内容，足以写一本短书！
- en: A look through the Gulp file might be enough to put some people off. It is true
    that creating a custom syntax to parse code created using Stylus or less is not
    easy, and falls outside the scope of this book. However, we can make use of some
    of the API to query our content. In our example, there are two blocks of code
    that are of interest.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下Gulp文件可能会让一些人望而却步。确实，创建一个自定义语法来解析使用Stylus或less创建的代码并不容易，并且超出了本书的范围。然而，我们可以利用一些API来查询我们的内容。在我们的示例中，有两个代码块值得关注。
- en: 'The first block parses each selector and keeps a running count. We can use
    the .`walkRules` method to iterate through each rule:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块解析每个选择器并保持计数。我们可以使用`.walkRules`方法遍历每个规则：
- en: '![Dissecting our example code](img/BO5194_11_16.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![分析我们的示例代码](img/BO5194_11_16.jpg)'
- en: 'Once we have that raw information, we can then stringify it (or convert it
    to a string), before displaying the content on screen:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了原始信息，我们就可以将其转换为字符串（或将其转换为字符串），然后再在屏幕上显示内容：
- en: '![Dissecting our example code](img/BO5194_11_17.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![剖析我们的示例代码](img/BO5194_11_17.jpg)'
- en: It's worth noting that the PostCSS API contains additional functionality to
    stringify our CSS and assemble it together. These are known as the Stringify and
    Builder commands; these are only meant for use when creating custom syntaxes.
    We've simply parsed our content using existing plugins designed for this purpose,
    so using `toString()` is sufficient for our needs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，PostCSS API 包含了将我们的 CSS 字符串化和组合在一起的功能。这些被称为 Stringify 和 Builder 命令；这些命令仅用于创建自定义语法时使用。我们只是简单地使用为这个目的设计的现有插件解析了我们的内容，所以使用
    `toString()` 对于我们的需求来说是足够的。
- en: Moving on—our example was kept deliberately simple to illustrate the process.
    We can easily add additional functionality. The API reference documentation at
    [https://github.com/postcss/postcss/blob/master/docs/api.md](https://github.com/postcss/postcss/blob/master/docs/api.md)
    is a good place to start. How about adding error-checking, for example? We've
    already added one option from it, in the form of source maps; let's briefly cover
    this in more detail.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进——我们的示例被故意保持简单，以说明这个过程。我们可以轻松地添加额外的功能。API 参考文档在 [https://github.com/postcss/postcss/blob/master/docs/api.md](https://github.com/postcss/postcss/blob/master/docs/api.md)
    是一个很好的起点。比如，添加错误检查怎么样？我们已经从其中添加了一个选项，以源映射的形式；让我们更详细地简要介绍这一点。
- en: Adding source maps
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加源映射
- en: 'Throughout many of our demos, we''ve incorporated a task that creates a source
    map of our CSS styling. It''s worked perfectly well so far, but it isn''t the
    final answer—we can do better! To see what is possible, take another look at the
    last block of code in the Gulp task file used in the previous demo (which should
    be around lines 33 to 36):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的大多数演示中，我们包含了一个创建 CSS 样式源映射的任务。到目前为止，它工作得非常好，但这并不是最终答案——我们可以做得更好！为了了解可能的情况，请再次查看上一个演示中使用的
    Gulp 任务文件中的最后一部分代码（应该在 33 到 36 行左右）：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we''re creating a version of our transformed code that can be saved to
    file `{inline: false}` prevents the creation of a source map directly in our code.
    Instead, we use NodeJS'' file system to create a source map based on `result.map`;
    this contains the content of our transformed code.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们正在创建一个版本的转换后的代码，可以保存到文件。`{inline: false}` 阻止在代码中直接创建源映射。相反，我们使用 NodeJS
    的文件系统根据 `result.map` 创建源映射；这包含了我们转换后的代码内容。'
- en: There are a few points to note when using this method; for more details, take
    a look at the main PostCSS site at [https://github.com/postcss/postcss/blob/master/docs/source-maps.md](https://github.com/postcss/postcss/blob/master/docs/source-maps.md).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法时有一些需要注意的点；更多细节，请查看主 PostCSS 网站 [https://github.com/postcss/postcss/blob/master/docs/source-maps.md](https://github.com/postcss/postcss/blob/master/docs/source-maps.md)。
- en: 'Time to change tack: so far we''ve concentrated on writing our code, but what
    about presentation? It''s not entirely necessary, but setting up highlighting
    has a twofold benefit: it makes it easier to edit our code, and we can also use
    it to provide a consistent theme when documenting our code electronically. After
    all, I''m sure you at least do the latter…don''t you?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候改变方向了：到目前为止，我们一直专注于编写代码，但关于展示呢？这并不是完全必要的，但设置突出显示有两个好处：它使我们的代码更容易编辑，我们还可以用它来在电子文档中提供一致的主题。毕竟，我相信您至少做了后者……不是吗？
- en: Highlighting our syntax code
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出显示我们的语法代码
- en: Throughout many of our demos, we've concentrated on using plugins, with minimal
    changes required to configure the code for use. There is nothing wrong with this,
    but as always, we can do better. How about installing support for highlighting?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的大多数演示中，我们专注于使用插件，对配置代码以供使用所需的更改很少。这并没有什么问题，但就像往常一样，我们可以做得更好。比如，安装支持突出显示怎么样？
- en: 'This is an easy way to make it easier to read our code, indeed, we should have
    installed something like this a long time ago! That aside, it''s easy enough to
    fix; support is available for a wide variety of editors. For the purposes of this
    chapter, I will assume you are using Sublime Text; this is an example of how it
    might look (the screenshot shows the Twilight Light theme in use):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一种使我们的代码更容易阅读的简单方法，我们确实应该很久以前就安装这样的东西！除此之外，修复起来也很容易；支持广泛的各种编辑器。为了本章节的目的，我将假设您正在使用
    Sublime Text；这是一个示例，看看它可能的样子（截图显示了正在使用的 Twilight Light 主题）：
- en: '![Highlighting our syntax code](img/BO5194_11_18.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![突出显示我们的语法代码](img/BO5194_11_18.jpg)'
- en: Let's dive in and take a look at how to get this set up, using Sublime Text's
    package manager.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨如何使用 Sublime Text 的包管理器来设置此环境。
- en: Installing themes
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装主题
- en: 'Adding theme support is a cinch when using an editor such as Sublime Text.
    Let''s work through the steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像 Sublime Text 这样的编辑器时，添加主题支持非常简单。让我们一步步来完成：
- en: 'We''ll start by opening a command prompt session. Go ahead and add this command,
    then press *Enter*:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先打开一个命令提示符会话。请继续添加此命令，然后按 *Enter* 键：
- en: '[PRE13]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, enter this command, then press *Enter*:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入此命令，然后按 *Enter* 键：
- en: '[PRE14]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Open Sublime Text. If all is well, we should see a new menu entry if we click
    on **Preferences** | **Color Scheme** | **User**:![Installing themes](img/BO5194_11_19.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Sublime Text。如果一切顺利，当我们点击 **首选项** | **颜色方案** | **用户** 时，我们应该看到一个新菜单项![安装主题](img/BO5194_11_19.jpg)
- en: An easy change to make, but a useful one; nevertheless, it's only part of what
    we can do! To really go to town (figuratively speaking), we can apply similar
    styling to our CSS styles. This makes it easier to read if we want to document
    our styles online. After all, color is clearly easier to read than black and white!
    Let's take a moment to explore what is required to apply a color theme to our
    documented code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的更改，但非常有用；尽管如此，这仅仅是我们能做的事情的一部分！如果我们想（字面上）大干一场，我们可以将类似的样式应用到我们的 CSS 样式中。如果我们想在线记录样式，这将使阅读变得更加容易。毕竟，颜色显然比黑白更容易阅读！让我们花点时间来探索将颜色主题应用到我们的文档代码中所需的内容。
- en: Creating a HTML display theme
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 HTML 显示主题
- en: A part of developing code is the need to document it. This is not only for our
    sanity, but also for future changes, should someone else need to alter our code!
    Creating printed documentation is now old hat, a better method is to create it
    online, where we can easily update it without too much fuss. At the same time,
    we can add some color to it, to make it visually more appealing and provide a
    more consistent format to our efforts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 开发代码的一部分是需要对其进行文档记录。这不仅是为了我们的理智，也是为了未来的更改，以防其他人需要修改我们的代码！创建打印文档现在已经过时，更好的方法是创建在线文档，这样我们可以轻松更新它而无需太多麻烦。同时，我们可以在其中添加一些颜色，使其在视觉上更加吸引人，并为我们的努力提供更一致的格式。
- en: We could create this code manually, but that is a resource-heavy process that
    is prone to error! Instead, we can use the Midas library (available from [http://midasjs.com](http://midasjs.com))
    to automate the creation of the basis for our documentation, and we can style
    it using one of the base16 themes we covered in the previous exercise.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动创建这段代码，但这是一个资源密集且容易出错的过程！相反，我们可以使用 Midas 库（可在 [http://midasjs.com](http://midasjs.com)
    获取）来自动化创建我们文档的基础，并且我们可以使用之前练习中提到的 base16 主题之一来对其进行样式化。
- en: 'Let''s make a start on installing that support:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始安装这个支持：
- en: We'll start by firing up a NodeJS command prompt, then changing the working
    folder to our project area.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先启动一个 NodeJS 命令提示符，然后更改工作文件夹到我们的项目区域。
- en: 'At the prompt, enter this command, then press *Enter*:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中，输入此命令，然后按 *Enter* 键：
- en: '[PRE15]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once it has finished installing, go ahead and extract the `src` folder and the
    `gulpfile.js` and `package.json` files from the `T63 – incorporating midas` folder,
    then save them to the root of our project area.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，请从 `T63 – incorporating midas` 文件夹中提取 `src` 文件夹以及 `gulpfile.js` 和 `package.json`
    文件，然后将它们保存到我们项目区域的根目录。
- en: Revert to the NodeJS command prompt, then enter `gulp` and press *Enter*.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 NodeJS 命令提示符，然后输入 `gulp` 并按 *Enter* 键。
- en: Gulp will go away and compile a HTML-based extract of our code as `styles.html`,
    which has been properly formatted with extra markup. The file will appear in the
    `dest` folder within our project area.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gulp 将退出并编译我们的代码的基于 HTML 的提取，生成 `styles.html` 文件，该文件已使用额外的标记进行了适当的格式化。该文件将出现在我们项目区域内的
    `dest` 文件夹中。
- en: 'At this point, if we were to view the contents of that file, it will look very
    plain; this is easy to fix! To do this, we will use the Brewer theme by Timothée
    Poisot, available from [https://github.com/chriskempson/base16-builder/blob/master/schemes/brewer.yml](https://github.com/chriskempson/base16-builder/blob/master/schemes/brewer.yml);
    there are a few steps involved to make this happen:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果我们查看该文件的目录，它看起来会很普通；这很容易解决！为此，我们将使用 Timothée Poisot 的 Brewer 主题，可在 [https://github.com/chriskempson/base16-builder/blob/master/schemes/brewer.yml](https://github.com/chriskempson/base16-builder/blob/master/schemes/brewer.yml)
    获取；要实现这一点，涉及几个步骤：
- en: Browse to [https://github.com/ben-eb/midas/blob/master/templates/template-light.css](https://github.com/ben-eb/midas/blob/master/templates/template-light.css),
    then save this as a CSS file within the `dest` folder of our project area.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到[https://github.com/ben-eb/midas/blob/master/templates/template-light.css](https://github.com/ben-eb/midas/blob/master/templates/template-light.css)，然后在我们的项目区域的`dest`文件夹中将其保存为CSS文件。
- en: Open it in a text editor; it contains a series of placeholders for the base16
    themes that are available for use. We would normally use Ruby to generate the
    CSS for one of these themes, but this isn't entirely necessary; instead, use your
    editor's search and replace to match up each placeholder with the appropriate
    color:![Creating a HTML display theme](img/BO5194_11_20.jpg)![Creating a HTML
    display theme](img/BO5194_11_21.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开它；它包含了一系列用于可用base16主题的占位符。我们通常会使用Ruby生成这些主题之一的CSS，但这并非完全必要；相反，使用您编辑器的搜索和替换功能，将每个占位符与相应的颜色匹配：![创建HTML显示主题](img/BO5194_11_20.jpg)![创建HTML显示主题](img/BO5194_11_21.jpg)
- en: Save the result; to make it work, we need to adjust the contents of the `styles.html`
    file to reference the new style sheet, so that it has the proper HTML structure.
    Once done, it will look something like this:![Creating a HTML display theme](img/BO5194_11_22.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存结果；为了使其工作，我们需要调整`styles.html`文件的内容，以便引用新的样式表，使其具有正确的HTML结构。一旦完成，它将看起来像这样：![创建HTML显示主题](img/BO5194_11_22.jpg)
- en: This looks far more appealing, I think you'll agree! Although it requires some
    work to create the initial theme, this will be a one-off process for each theme
    that you create. Any changes made to the CSS rules or declarations can be generated
    automatically, and the HTML result updates accordingly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这看起来更有吸引力，我相信你会同意！虽然创建初始主题需要一些工作，但这将是每个主题创建的一次性过程。对CSS规则或声明所做的任何更改都可以自动生成，并且HTML结果会相应更新。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We kicked off with a quick introduction to custom syntaxes, before preparing
    our environment for developing code. We then covered some of the plugins available
    for parsing content, before exploring some of the reasons as to why we might need
    to parse custom syntaxes or styles directly before implementing two as examples
    of how to manipulate our code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先快速介绍了自定义语法，然后为开发代码准备我们的环境。然后，我们介绍了一些可用于解析内容的插件，并在实施两个示例之前，探讨了为什么我们可能需要直接解析自定义语法或样式，以展示如何操作我们的代码。
- en: We then dived in and explored how most PostCSS plugins perform changes to our
    code. We then explored some of the techniques required to alter styles directly,
    before considering the effects of our changes on the code itself.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后深入研究了大多数PostCSS插件如何修改我们的代码。然后，我们在考虑我们的更改对代码本身的影响之前，探索了一些直接修改样式的技术。
- en: Next up, we examined how content can be formatted for screen or to a state ready
    for saving to disk (including the creation of source maps). We noted that whilst
    there are some specific methods available, these are reserved for custom syntax
    development, and that the options we used would suffice for initial manipulation
    of our code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了如何为屏幕或准备保存到磁盘的状态格式化内容（包括创建源映射）。我们注意到，尽管有一些特定的方法可用，但这些方法是为自定义语法开发保留的，而我们使用的选项足以满足对代码的初始操作。
- en: We then rounded out the chapter with a look at how we can add highlighting support
    to our projects—we examined the reasons for adding this, such as making code editing
    easier, and covered a quick demo that uses the Midas library to create properly
    laid out documentation for our projects.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过查看如何为我们的项目添加高亮支持来结束本章——我们探讨了添加此功能的原因，例如使代码编辑更容易，并展示了一个使用Midas库创建项目正确布局文档的快速演示。
- en: 'The use of different syntaxes is a great way to remove the need for rewriting
    existing code into valid CSS. There is one thing, though: what happens if we have
    a mix of both standard CSS and pre-processor code, such as from less or Stylus?
    Can we work with both at the same time? Absolutely! We will take a look at the
    Pleeease library, which supports this, in the next chapter.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的语法是一种很好的方法，可以消除将现有代码重写为有效CSS的需求。不过，有一个问题：如果我们混合了标准CSS和预处理器代码，比如来自less或Stylus的代码，会发生什么？我们能否同时处理这两种代码？当然可以！在下一章中，我们将探讨支持这一功能的Pleeease库。
