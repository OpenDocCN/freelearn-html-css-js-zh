- en: Chapter 11. Manipulating Custom Syntaxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although many developers have moved on from using preprocessors to using PostCSS,
    it is important to note that PostCSS is not a replacement, just an alternative
    way of preprocessing CSS styles. To help with the transition, we're not forced
    to learn a new syntax. Using a handful of plugins, we can take advantage of the
    speed of PostCSS, while still using syntaxes that we're accustomed to, such as
    Less, SASS, or Stylus.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll take a look at the plugins that make this possible, and
    work on some simple examples that show you how using a custom syntax that we're
    all familiar with is still possible when using PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following technical topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing custom syntaxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing examples of custom syntax plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting content to strings with the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding highlighting support to our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's make a start!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing custom syntaxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'W3Schools defines a CSS syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A CSS rule-set consists of a selector and a declaration block: The selector
    points to the HTML element you want to style. The declaration block contains one
    or more declarations separated by semicolons."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We as developers spend many hours crafting sites; this can be something small
    as a one-page contact card-type site, right through to a large e-commerce website.
    It does not matter which styles we decide to use, or how we get there: the key
    is that the final result must use the same standard syntax that we''ve grown to
    love over the years.'
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean to say that our source should be standard CSS, in fact, it
    would be very restrictive if this were the only option! We could use libraries
    such as SASS or Less, but instead, how about using the API and custom syntax plugins
    to manipulate our styles directly? We touched on some of the principles back in
    [Chapter 8](ch08.html "Chapter 8. Creating PostCSS Plugins"), *Creating PostCSS
    Plugins*; it's time to revisit this and explore how we can begin to remove this
    restriction.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we want to do this, I hear you ask? The answer's simple—let's assume
    for a moment you create themes for WordPress. WordPress' default themes are created
    using SASS (and PostCSS); this means a dependency on SASS in some form. We can
    mitigate this a little by using the `gulp-sass` plugin, but this still uses `libsass`
    to compile code.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we could turn this on its head, and use the API and custom syntax plugins
    that parses SASS code and converts it to PostCSS equivalent? Okay, granted, we
    may not be able to cover all styles; we can at least make a start on converting
    some, and reduce our dependency on using SASS. Let''s make a start. Before we
    get stuck into producing code, we have a simple administrative task to perform:
    we need to install a syntax highlighter first.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the course of this chapter, we will be working directly with the
    PostCSS API (or a plugin's individual API, if it has one). As we are working directly
    on CSS (and not simply through a plugin's configuration object), it makes sense
    to install a syntax highlighter that works with PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not every text editor has one, but if you happen to use Sublime Text, with
    the Package Control facility installed (and I am assuming this is the case for
    the demos in this book), then it has a highlighter available for PostCSS that
    we can install. The plugin is available at [https://github.com/hudochenkov/Syntax-highlighting-for-PostCSS](https://github.com/hudochenkov/Syntax-highlighting-for-PostCSS).
    Let''s get it installed using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up Sublime Text, then press *Cmd* + *Shift* + *P* (OS X) or *Ctrl* + *Shift*
    + *P* (Linux/Windows) to open the command palette.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the list that appears, click on **Package Control: Install Package**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a few moments, it will show a new list; start typing `Syntax Highlighting
    for PostCSS`:![Preparing our environment](img/BO5194_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it appears, click on it to install; it takes a couple of moments to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can of course simply use a highlighter that works with JavaScript; this
    won''t be the same though: having a highlighter designed for PostCSS will make
    it easier to edit code!'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax highlighter that we've just installed comes with its own theme. If
    you like to roll your own, then you can do so, using the Base16 site at [http://chriskempson.github.io/base16/](http://chriskempson.github.io/base16/).
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's move on; it's time to get stuck into code. Let's begin by exploring
    some of the plugins available for parsing code in PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom syntax plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PostCSS ecosystem contains over 100 plugins at last count; this is on the
    increase. These plugins will all serve different needs, but will have one thing
    in common: the process they use to transform our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should be clear that this similarity is at a very high level; we are
    not referring to the technical details of each plugin! This aside, when creating
    our own custom syntax, we must follow a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: We first put our code through a parser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then transform it using anyone of a number of plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We finally stringify it, or convert it to valid CSS in string format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We already have a handful of plugins that allow us to work with other syntaxes
    within a PostCSS environment; these include languages such as less or JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name of plugin | Purpose of plugin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sugarss` | This plugin is an indent-based syntax like SASS or Stylus.Plugin
    is available from [https://github.com/postcss/sugarss](https://github.com/postcss/sugarss).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `postcss-less` | We can use this plugin to transform less into valid CSS.
    Note: it does not compile code.Plugin is available from [https://github.com/webschik/postcss-less](https://github.com/webschik/postcss-less).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `postcss-js` | Anyone working with JavaScript can use this plugin to write
    styles in JS or transform React Inline Styles, Radium, or JSS.Plugin is available
    from [https://github.com/postcss/postcss-js](https://github.com/postcss/postcss-js).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `postcss-scss` | For those of you using SASS, this plugin is perfect for
    working with SASS code; it does *not* compile code to CSS.Plugin is available
    from [https://github.com/postcss/postcss-scss](https://github.com/postcss/postcss-scss).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `postcss-safe-parser` | This plugin is perfect for finding and fixing CSS
    syntax errors.It''s available to download from [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `poststylus` | We can use this plugin to transform styles created using the
    Stylus library into valid CSS. Note: it does not compile code.Plugin is available
    from [https://github.com/seaneking/poststylus](https://github.com/seaneking/poststylus).
    |'
  prefs: []
  type: TYPE_TB
- en: 'Although all of these plugins serve a different purpose, they all follow the
    same principle: they parse the code and transform it, before converting it to
    a format that can be saved to file as a valid style sheet output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Leaving aside which parser we use, there is one question though: why would
    we want to manipulate our code directly? There are a few reasons for needing to
    alter the code directly; here are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: We may want to create a report that details facts and figures about our code
    for reference purposes; it is true that there will be plugins or scripts available
    to do this already, but PostCSS can get us the basics during compilation, and
    not as a separate process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How about this for an idea? If you happen to use an application such as Adobe
    Color CC, then we can consider using the API to directly transform specific colors
    into valid RGB(A) or HEX equivalent values. We could use a plugin to achieve this,
    but performing this directly using the API allows us to retain flexibility with
    our choice of colors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is nothing stopping us from dissecting existing plugins, and rebasing
    the tasks they perform into something that we could add to a task runner file,
    and then adapt to our needs. We might ultimately consider creating a plugin, but
    if the steps required are very specific to our needs, then a plugin may not be
    a useful addition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are occasions when error handling can be lacking. The API contains some
    useful functionality that allows us to add suitably formatted messages on screen,
    if our process fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few ideas to get started, in addition to manipulating existing
    non-PostCSS styles (such as those created using SASS, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Enough talking, I feel a demo coming! We've met some of the plugins available,
    so it's time to put them to good use; two of particular interest are the `postcss-scss`
    and `postcss-safe-parser` plugins. Let's dive in and take a look at them in more
    detail, beginning with `postcss-safe-parser`.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing content and fixing errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the next few pages, we'll touch on using a couple of parser plugins, to
    show how easy it is to transform our code. We will take a look at a plugin that
    removes the need for SASS (at least at a basic level); before we do so, let's
    first explore using the `postcss-safe-parser` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `postcss-safe-parser` plugin, available from [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser),
    is perfect for finding and fixing CSS errors. It''s a simple plugin to use and
    install; let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by installing the plugin, so go ahead, and fire up a Node.js command
    prompt session, then change the working directory to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command, then press *Enter* to install the plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, go ahead and extract a copy of the `T58 – parsing invalid content` folder
    from the code download that accompanies this book; save it to the root of our
    project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `package.json` and `gulpfile.js` files from it to the root of our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to the NodeJS command prompt session, then at the prompt, enter
    `gulp` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If all is well, we should see a successful compilation: a file marked `output.css`
    will be created at the root of our project area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and open it. Even though our example only contained one malformed
    selector, the file contains the same selector, but this time with the missing
    closing parenthesis added. We can also see the results appear in the console log
    at the same time as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing content and fixing errors](img/BO5194_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So what's going on here? Well, some of this will be familiar. We're using a
    standard format task in our Gulp file, along with references to some of the plugins
    that we've already met, such as `autoprefixer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content that is of interest to us though, is in the default Gulp task as
    seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing content and fixing errors](img/BO5194_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The task may seem a little complex, but in reality, we're parsing our CSS, prior
    to manipulating it. We start by defining a `postcss` object (into which feeds
    a request to run `autoprefixer`). This then processes our CSS into an AST, using
    a parser to find and fix any issues, before piping it out on screen and into a
    file named `output.css` in our project area.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Abstract Syntax Trees** (**AST**) are a graphical tree representation of
    the syntactic structure of our CSS style sheets or code.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, our example was very simplistic, but this was intended to show you how
    the principle works. In this next example, the same principle has been used to
    convert standard SCSS code to valid CSS; note, though, that we're not calling
    SASS (as we have done before), but converting the SCSS code to valid CSS styles.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing SCSS content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our previous demo, we explored the use of PostCSS to parse our CSS and added
    the missing closing bracket as a fix for our code. It was a simplistic example;
    perfect if you're working with standard CSS, but what if your projects are using
    SASS?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, as part of our next example, we''ll prove that using a compiler is now
    old hat; we''ll use the `postcss-scss` plugin (from [https://github.com/postcss/postcss-scss](https://github.com/postcss/postcss-scss))
    to directly transform our SASS code, before unwrapping the nesting styles using
    the `postcss-nested` plugin (available from [https://github.com/postcss/postcss-nested](https://github.com/postcss/postcss-nested)):'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by installing the `postcss-scss` plugin. Go ahead and fire up a
    NodeJS command prompt session, then change the working directory to the root of
    our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Keep the session open when the plugin has completed installation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Parsing SCSS content](img/BO5194_11_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: From the downloaded code that accompanies this book, go ahead and extract a
    copy of the `package.json` file from the `T59 – Parsing SCSS content` folder.
    Save this to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the same `T59 – Parsing SCSS` content folder, copy the contents of the
    `src` folder to the `src` folder at the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, add the following code and save it as `gulpfile.js` in the `src`
    folder at the root of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The keen-eyed amongst you will spot the reference to `postcss-nested`. We cannot
    call PostCSS without specifying something, so we''ll use this plugin to unwrap
    the nested statements in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Revert back to the NodeJS command prompt session, then add this command and
    press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once Node has completed installing the plugin, enter `gulp` at the prompt then
    press *Enter*:![Parsing SCSS content](img/BO5194_11_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we will see a compiled file appear in the `dest` folder:![Parsing
    SCSS content](img/BO5194_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But hold on a moment: this is a valid *CSS* file, right? Absolutely. But…we''ve
    so far had to use a compiler to produce valid CSS code; how come we haven''t needed
    to add one now?'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring what happened
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, the answer lies in the conversion process—traditionally we would have
    had to compile our code, even though standard SASS files are a superset of current
    CSS. Instead, we've simply *rewritten* our code using a syntax that translates
    a standard SCSS file to valid CSS.
  prefs: []
  type: TYPE_NORMAL
- en: If we take a look at our Gulp file in more detail, we can see references to
    the standard `gulp-postcss` plugin, along with declared instances of the `fs`,
    `autoprefixer`, `postcss-nested`, and `postcss-scss` plugins. The key for this
    demo starts on line 10, where we declare an instance of the `scss` variable, and
    use the **file system** (**fs**) plugin for Node to read the contents of the file
    into this variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once into the task, we create an instance of PostCSS as an object, before feeding
    it the `autoprefixer` and `nested()` plugins (as variables). We then process our
    SASS code using the syntax that comes with the `postcss-scss` plugin, before piping
    out the contents as a file into the `dest` folder in our project area.
  prefs: []
  type: TYPE_NORMAL
- en: See? Nice and easy; not a SASS compiler in sight! This simple change removes
    the need for any dependency on a compiler, after all, SCSS files are just standard
    CSS text files, so why use a compiler? With all of this talk of parsing CSS (or
    SCSS for that matter), it's worth spending some time exploring what we mean by
    this, and how it is important to the whole process.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the heart of writing any custom syntax is the ability to parse content—it
    doesn''t matter whether this is CSS, JavaScript, or something else; we clearly
    need to understand what we''re working with, before we can make changes! At a
    basic level, these are the steps we must take to transform our CSS when working
    with PostCSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing CSS](img/BO5194_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We begin with our source CSS (which comes with or without a source map), which
    we parse only once, but then put through any number of specified plugins (the
    example shows two, but we can easily use more). We then convert the output to
    a string using a stringifier; at this point, we can view the contents on screen
    or save them to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s for a moment take a look at parsing some example code. For this next
    example, we will use a single CSS rule and parse it using the `postcss-value-parser`
    plugin (from [https://github.com/TrySound/postcss-value-parser](https://github.com/TrySound/postcss-value-parser));
    the reason for this will become clear shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: From the code download that accompanies this book, extract and save copies of
    the `gulpfile.js` and `package.json` files from the `T60 – parsing color values`
    folder to the root of our project area; if you want to save any existing files
    from there, then please do so first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire up a NodeJS command prompt session then change the working folder to the
    root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to install the `postcss-value-parser` plugin, so at the prompt, enter
    this command and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'NPM will now install the plugin; keep the session open when it has finished:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Parsing CSS](img/BO5194_11_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: At the prompt, type `gulp` then press *Enter*; gulp will now go away and display
    the contents, which will look something like this:![Parsing CSS](img/BO5194_11_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yikes! What does that all mean? Don't worry, it looks worse than it really is;
    this is an example of an AST, which we discussed earlier in this chapter. This
    gives us in-depth information on the contents of our CSS, such as the values,
    types of values, and where they appear in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The great thing, though, is that once we have all of this content, then we are
    free to query and manipulate the content at will. Once we have manipulated the
    content, we then need to convert it to string format, so it can be displayed on
    screen in a more intelligent format, or saved to disk.
  prefs: []
  type: TYPE_NORMAL
- en: For this demo, we used the `postcss-value-parser` plugin to create our AST;
    we can also try using the `postcss-safe-` `parser` plugin (from [https://github.com/postcss/postcss-safe-parser](https://github.com/postcss/postcss-safe-parser)),
    or the `postcss-selector-parser` plugin (from [https://github.com/postcss/postcss-selector-parser](https://github.com/postcss/postcss-selector-parser)),
    to achieve similar effects.
  prefs: []
  type: TYPE_NORMAL
- en: And the reason why we only used one line of CSS code in our demo? Well, parsing
    CSS code can get very complex. The example shown in our demo is relatively straightforward;
    just imagine what it will be like with 2,000+ lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: Let's develop this theme further, and use it to replace some example RGBA values
    with equivalent HEX-based colors. We can easily do this through the use of the
    `postc` `ss-unrgba` plugin (from [https://github.com/jonathantneal/postcss-unrgba](https://github.com/jonathantneal/postcss-unrgba)),
    but it weighs in at almost 60 lines; our Gulp file is 43 lines, and a lot of that
    is comments!
  prefs: []
  type: TYPE_NORMAL
- en: Replacing RGBA colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next example is a relatively straightforward search and replace; it is
    a perfect example of how it isn''t always necessary to use plugins, and that we
    can parse our code directly to achieve the same effect. Let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by extracting a copy of the `T61 – changing colors` folder from
    the downloaded code that accompanies this book; save the folder to the root of
    our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `gulpfile.js` and `package.json` files from the `T61 – changing colors`
    folder to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `src` folder from the `T61 – changing colors` folder to the root of
    our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, fire up a NodeJS command prompt session then change the working folder
    to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to install an additional plugin, `color-convert` (available from
    [https://github.com/qix-/color-convert](https://github.com/qix-/color-convert)),
    which we will use to change the color once we've sucked out the details from within
    the AST. For this, go ahead and fire up a NodeJS command prompt, then change the
    working folder to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, enter `npm install color-convert --save-dev` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the plugin has finished installing, go ahead and enter `gulp`, then press
    *Enter*. If all is well, we should see the, by now, familiar transformed style
    sheet appear in our destination folder:![Replacing RGBA colors](img/BO5194_11_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, our style sheet has been transformed. If we preview the results
    in a text editor, we can confirm that HEX-equivalent values have indeed replaced
    the original RGBA colors, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Replacing RGBA colors](img/BO5194_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Not convinced? Take a look at the same rule within the source file; here it
    shows the original RGBA value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Replacing RGBA colors](img/BO5194_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See how easy that was? There is one thing note; if we take a look at the Gulp
    file, it might at first glance look like we still have a few plugins in use. The
    key here is that three of these are part of Node (`fs`, `path`, and `util`), so
    we haven't had to install any new ones, over and above the `value-parser` and
    `color-convert` examples.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring how it all works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's worth taking the time to consider this code in more detail. This contains
    some useful techniques that will help get you started on the road to creating
    custom syntaxes, starting with retrieving the values we need.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with reading the contents of our style sheet file, before parsing it
    through the `postcss-value-parser` plugin. We walk through each node within the
    AST, ignoring any that contain a `node.type` of function or a `node.value` of
    `rgba`. For any that remain, we collect any that have a node type of word, before
    mapping them into a single array value which we convert to a number.
  prefs: []
  type: TYPE_NORMAL
- en: This is then transformed from a function node to a word node, before we finally
    convert the value from an RGBA to HEX color. The contents are converted to a string,
    and saved to disk in the destination folder, with the same file name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node types represent the type of selector we're working with—examples include
    `root`, `string`, `tag`, and `attribute`. In our example, we've used `node.type`
    to display a string representation of the selector type, which we can manipulate
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s move on: the key basis for working with custom syntaxes is to
    understand the content we need to work with; crack this and you are part of the
    way to transforming your styles into valid CSS. To help with the process, though,
    we will need to convert our content to a format that can be saved to disk. It''s
    time to take a look at how, using the PostCSS API.'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting the output with the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When parsing CSS, the output by default is going to resemble something as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting the output with the API](img/BO5194_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks a really ugly mess, but is in fact the standard format for an AST
    tree. The trouble is, it''s not very helpful if we want to use details from it
    in our code! To get around this, we need to convert our content into a string
    format: the simplest method is to use the .`toString()` method, which is perfect
    for saving the content to disk.'
  prefs: []
  type: TYPE_NORMAL
- en: All of the code for the next exercise is in the `T62 – adding a stringifier`
    folder in the code download that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a cinch to use in our Gulp file; let''s take a look as part of our next
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a new Gulp task file. In your usual text editor of
    choice, add the following code; there is a reasonable amount involved, so we will
    go through it in sections, beginning with the declarations for the plugins used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to set up a few variables; these will be used to store values generated
    during the compilation process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up is the start of our task. The first step is to parse some simple CSS,
    as a basis for our demo. We then get the first child in our code, and save it
    to the `decl` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first piece of information we want is a selector count; this next block
    will count through each selector using `root.walkRules`, and push the value into
    the `selectors` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we''re ready to pipe out a summary report of our code—we use
    `console.log` to display a number of different values on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re almost there—in this next block, we do the PostCSS equivalent of a search
    and replace to update our color from black to white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can display our content on screen, but a more useful step is to save it
    to disk—for this, we can use the `fs` plugin from Node.js to create our transformed
    CSS file and associated source map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the Gulp file to the root of our project area, then fire up a Node.js command
    prompt, and change the working directory to that of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, type in `gulp`, then press *Enter* and let the compilation complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If all is well, we should see the results of step 6 appear on screen, like
    so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Formatting the output with the API](img/BO5194_11_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The transformed CSS file and source map will be present in the `dest` folder:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Formatting the output with the API](img/BO5194_11_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: So, how does this all help us? Well, the ability to parse our code directly
    opens up some real possibilities; let's pause for a moment to explore what has
    happened in our demo, and how we can take advantage of this functionality in future
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting our example code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the book, we've used a variety of plugins to transform our code.
    These will all make use of the PostCSS API in some form. However, we are not limited
    to simply using plugins; we can also transform our code directly using the API.
    At this point, it should be noted that we are not talking about creating a custom
    parser; indeed, this would easily form enough content for a short book in its
    own right!
  prefs: []
  type: TYPE_NORMAL
- en: A look through the Gulp file might be enough to put some people off. It is true
    that creating a custom syntax to parse code created using Stylus or less is not
    easy, and falls outside the scope of this book. However, we can make use of some
    of the API to query our content. In our example, there are two blocks of code
    that are of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first block parses each selector and keeps a running count. We can use
    the .`walkRules` method to iterate through each rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dissecting our example code](img/BO5194_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have that raw information, we can then stringify it (or convert it
    to a string), before displaying the content on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dissecting our example code](img/BO5194_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's worth noting that the PostCSS API contains additional functionality to
    stringify our CSS and assemble it together. These are known as the Stringify and
    Builder commands; these are only meant for use when creating custom syntaxes.
    We've simply parsed our content using existing plugins designed for this purpose,
    so using `toString()` is sufficient for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on—our example was kept deliberately simple to illustrate the process.
    We can easily add additional functionality. The API reference documentation at
    [https://github.com/postcss/postcss/blob/master/docs/api.md](https://github.com/postcss/postcss/blob/master/docs/api.md)
    is a good place to start. How about adding error-checking, for example? We've
    already added one option from it, in the form of source maps; let's briefly cover
    this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Adding source maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout many of our demos, we''ve incorporated a task that creates a source
    map of our CSS styling. It''s worked perfectly well so far, but it isn''t the
    final answer—we can do better! To see what is possible, take another look at the
    last block of code in the Gulp task file used in the previous demo (which should
    be around lines 33 to 36):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re creating a version of our transformed code that can be saved to
    file `{inline: false}` prevents the creation of a source map directly in our code.
    Instead, we use NodeJS'' file system to create a source map based on `result.map`;
    this contains the content of our transformed code.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few points to note when using this method; for more details, take
    a look at the main PostCSS site at [https://github.com/postcss/postcss/blob/master/docs/source-maps.md](https://github.com/postcss/postcss/blob/master/docs/source-maps.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to change tack: so far we''ve concentrated on writing our code, but what
    about presentation? It''s not entirely necessary, but setting up highlighting
    has a twofold benefit: it makes it easier to edit our code, and we can also use
    it to provide a consistent theme when documenting our code electronically. After
    all, I''m sure you at least do the latter…don''t you?'
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting our syntax code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout many of our demos, we've concentrated on using plugins, with minimal
    changes required to configure the code for use. There is nothing wrong with this,
    but as always, we can do better. How about installing support for highlighting?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an easy way to make it easier to read our code, indeed, we should have
    installed something like this a long time ago! That aside, it''s easy enough to
    fix; support is available for a wide variety of editors. For the purposes of this
    chapter, I will assume you are using Sublime Text; this is an example of how it
    might look (the screenshot shows the Twilight Light theme in use):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Highlighting our syntax code](img/BO5194_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's dive in and take a look at how to get this set up, using Sublime Text's
    package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Installing themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding theme support is a cinch when using an editor such as Sublime Text.
    Let''s work through the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by opening a command prompt session. Go ahead and add this command,
    then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, enter this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open Sublime Text. If all is well, we should see a new menu entry if we click
    on **Preferences** | **Color Scheme** | **User**:![Installing themes](img/BO5194_11_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An easy change to make, but a useful one; nevertheless, it's only part of what
    we can do! To really go to town (figuratively speaking), we can apply similar
    styling to our CSS styles. This makes it easier to read if we want to document
    our styles online. After all, color is clearly easier to read than black and white!
    Let's take a moment to explore what is required to apply a color theme to our
    documented code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a HTML display theme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A part of developing code is the need to document it. This is not only for our
    sanity, but also for future changes, should someone else need to alter our code!
    Creating printed documentation is now old hat, a better method is to create it
    online, where we can easily update it without too much fuss. At the same time,
    we can add some color to it, to make it visually more appealing and provide a
    more consistent format to our efforts.
  prefs: []
  type: TYPE_NORMAL
- en: We could create this code manually, but that is a resource-heavy process that
    is prone to error! Instead, we can use the Midas library (available from [http://midasjs.com](http://midasjs.com))
    to automate the creation of the basis for our documentation, and we can style
    it using one of the base16 themes we covered in the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start on installing that support:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by firing up a NodeJS command prompt, then changing the working
    folder to our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once it has finished installing, go ahead and extract the `src` folder and the
    `gulpfile.js` and `package.json` files from the `T63 – incorporating midas` folder,
    then save them to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revert to the NodeJS command prompt, then enter `gulp` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gulp will go away and compile a HTML-based extract of our code as `styles.html`,
    which has been properly formatted with extra markup. The file will appear in the
    `dest` folder within our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, if we were to view the contents of that file, it will look very
    plain; this is easy to fix! To do this, we will use the Brewer theme by Timothée
    Poisot, available from [https://github.com/chriskempson/base16-builder/blob/master/schemes/brewer.yml](https://github.com/chriskempson/base16-builder/blob/master/schemes/brewer.yml);
    there are a few steps involved to make this happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [https://github.com/ben-eb/midas/blob/master/templates/template-light.css](https://github.com/ben-eb/midas/blob/master/templates/template-light.css),
    then save this as a CSS file within the `dest` folder of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it in a text editor; it contains a series of placeholders for the base16
    themes that are available for use. We would normally use Ruby to generate the
    CSS for one of these themes, but this isn't entirely necessary; instead, use your
    editor's search and replace to match up each placeholder with the appropriate
    color:![Creating a HTML display theme](img/BO5194_11_20.jpg)![Creating a HTML
    display theme](img/BO5194_11_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the result; to make it work, we need to adjust the contents of the `styles.html`
    file to reference the new style sheet, so that it has the proper HTML structure.
    Once done, it will look something like this:![Creating a HTML display theme](img/BO5194_11_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This looks far more appealing, I think you'll agree! Although it requires some
    work to create the initial theme, this will be a one-off process for each theme
    that you create. Any changes made to the CSS rules or declarations can be generated
    automatically, and the HTML result updates accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We kicked off with a quick introduction to custom syntaxes, before preparing
    our environment for developing code. We then covered some of the plugins available
    for parsing content, before exploring some of the reasons as to why we might need
    to parse custom syntaxes or styles directly before implementing two as examples
    of how to manipulate our code.
  prefs: []
  type: TYPE_NORMAL
- en: We then dived in and explored how most PostCSS plugins perform changes to our
    code. We then explored some of the techniques required to alter styles directly,
    before considering the effects of our changes on the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we examined how content can be formatted for screen or to a state ready
    for saving to disk (including the creation of source maps). We noted that whilst
    there are some specific methods available, these are reserved for custom syntax
    development, and that the options we used would suffice for initial manipulation
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: We then rounded out the chapter with a look at how we can add highlighting support
    to our projects—we examined the reasons for adding this, such as making code editing
    easier, and covered a quick demo that uses the Midas library to create properly
    laid out documentation for our projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of different syntaxes is a great way to remove the need for rewriting
    existing code into valid CSS. There is one thing, though: what happens if we have
    a mix of both standard CSS and pre-processor code, such as from less or Stylus?
    Can we work with both at the same time? Absolutely! We will take a look at the
    Pleeease library, which supports this, in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
