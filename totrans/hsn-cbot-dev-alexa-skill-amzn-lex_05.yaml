- en: Building Your First Amazon Lex Chatbot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的第一个Amazon Lex聊天机器人
- en: The preceding two chapters focused solely on Amazon Alexa and building Alexa
    Skills. The next three chapters will teach you how to build chatbots using Amazon
    Lex. In this chapter, we'll learn how to build and test a Lex chatbot and then
    we'll step things up by integrating S3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前两章仅关注Amazon Alexa和构建Alexa技能。接下来的三章将教你如何使用Amazon Lex构建聊天机器人。在本章中，我们将学习如何构建和测试一个Lex聊天机器人，然后我们将通过集成S3来提高难度。
- en: Amazon Lex is very similar to Amazon Alexa but the main difference is that Lex
    has been designed to primarily work as a typed interaction. This means that you
    can use Lex to power Facebook messenger bots, add functionality to Slack, or even
    send text messages to your users. This doesn't stop you from using Lex for voice
    interactions and it can be used to build voice-based chatbots outside of the Amazon
    Alexa ecosystem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Lex与Amazon Alexa非常相似，但主要区别在于Lex被设计成主要用于文本交互。这意味着你可以使用Lex来为Facebook messenger机器人提供动力，为Slack添加功能，甚至向用户发送短信。这并不会阻止你使用Lex进行语音交互，并且它可以用来在Amazon
    Alexa生态系统之外构建基于语音的聊天机器人。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a Lex chatbot with slots and built-in responses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用槽和内置响应创建Lex聊天机器人
- en: Creating an FAQ chatbot with Lambda fulfillment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lambda实现FAQ聊天机器人
- en: Retrieving answers from S3 storage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从S3存储中检索答案
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be creating a Lambda function for our skill, and we'll
    be creating and deploying it using the local development setup that we created
    in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting Started with
    AWS and Amazon CLI*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的技能创建一个Lambda函数，并使用我们在[第2章](ac448944-0559-408e-a9c4-972933a03611.xhtml)，*AWS和Amazon
    CLI入门*中创建的本地开发设置来创建和部署它。
- en: All of the code and data required for this chapter can be found at [http://bit.ly/chatbot-ch5](http://bit.ly/chatbot-ch5).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的所有代码和数据都可以在[http://bit.ly/chatbot-ch5](http://bit.ly/chatbot-ch5)找到。
- en: Creating an Amazon Lex chatbot
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Amazon Lex聊天机器人
- en: Creating a Lex chatbot is very similar to the process of creating an Alexa skill.
    We need to create intents with utterances, we can have slots with slot types on
    those intents, and we can then build a response to the user. Although Lex and
    Alexa are very similar, there are some key differences that we will look at as
    we go through this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Lex聊天机器人与创建一个Alexa技能的过程非常相似。我们需要创建带有表述的意图，我们可以在这些意图上设置带有槽类型的槽，然后我们可以构建一个对用户的响应。尽管Lex和Alexa非常相似，但它们之间有一些关键的区别，我们将在本章中探讨。
- en: Setting up the chatbot
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置聊天机器人
- en: 'To start creating our first Lex chatbot, we need to open the AWS console and
    search for *Lex*. Once on the Lex page, click Get Started to get to the bot setup
    page. You''ll be presented with the option to use one of three sample bots or
    to create a Custom bot. We''ll be creating a custom bot, so select that option.
    The other three options are sample bots. These have been built to showcase the
    applications that you can use a Lex chatbot for:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建我们的第一个Lex聊天机器人，我们需要打开AWS控制台并搜索“Lex”。一旦进入Lex页面，点击“开始”以进入机器人设置页面。您将看到使用三个样本机器人之一或创建自定义机器人的选项。我们将创建一个自定义机器人，因此请选择该选项。其他三个选项是样本机器人。这些机器人被构建来展示您可以使用Lex聊天机器人实现的应用程序：
- en: '![](img/3309227c-5fd2-4617-b8c8-28313e47c43f.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3309227c-5fd2-4617-b8c8-28313e47c43f.png)'
- en: Bot-creation options
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人创建选项
- en: Having selected Custom bot, we get to name our bot and set up a few other settings.
    All of these settings are editable later, so we can start with some defaults.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了自定义机器人后，我们可以为我们的机器人命名并设置一些其他设置。所有这些设置都可以稍后编辑，因此我们可以从一些默认设置开始。
- en: Select a voice for your chatbot. This is the voice that will be used if you
    want to set up your Lex bot for voice-based chatbots. As we are going to be using
    Lex for text-based interactions only, we could select None. We'll be building
    a text-based application, but you should still choose a voice so you can test
    with voice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的聊天机器人选择一个声音。如果您想为基于语音的聊天机器人设置Lex机器人，这将使用该声音。由于我们将仅使用Lex进行基于文本的交互，我们可以选择“无”。我们将构建一个基于文本的应用程序，但您仍然应该选择一个声音，以便您可以进行语音测试。
- en: 'The last two parts are to set a timeout; we can use the default of 5 minutes,
    and select No for the COPPA question. If you want to create a chatbot that will
    talk with children, ticking Yes will stop Lex from storing any of the conversations
    to comply with the Children''s Online Privacy Protection Act. Now that we''ve
    finished the settings, we can click Create. This takes us to the Lex dashboard:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5eac0fff-1d1c-4013-981d-960045e11548.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Lex dashboard
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The components and process of creating a Lex chatbot are very similar to the
    process of creating an Alexa skill. There are Intents, Utterances, Slots, and
    Slot types, and the creation of most of these is almost identical to their creation
    in Alexa.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Intent
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we want to do is Create intent. Unlike Alexa, we have the option
    to Create intent, Import intent, or Search existing intents. As this is our first
    intent in Lex, we need to Create intent. We are prompted for a name for our new
    intent; we should call our first intent `sayHello`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e54e9ca-0a2d-4439-b947-b93caaa2be7b.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: Intent screen
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add utterances so that the user can trigger the intent. We
    can add the utterances of `hi`, `hey`, and `hello`. These are not case-sensitive,
    and adding punctuation such as commas and full stops is unnecessary, although
    apostrophes are accepted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest differences between Lex and Alexa is that we can send responses
    without needing a Lambda. Scroll to the bottom of the page and you will see the
    Fulfillment and Response sections. The Fulfillment section lets you decide whether
    to send this intent to a Lambda. For now, we are going to keep that option on
    Return parameters to client.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Response section is where we can tell Lex what to send back to the
    user. Click the Add Message button and a message block will appear. In the text
    area, we can type the response we want to send back to the user. Add a response
    phrase such as `Hi there` and press *Enter*. Unlike the utterances, the response
    is case-sensitive and can contain any punctuation you want:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8d718c5-066f-4482-a6c7-c8e642b553d7.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Fulfillment and response
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We can actually add multiple response messages, and Lex will choose one of them
    at random. This makes multiple interactions with the chatbot feel more natural
    and less robotic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: With the utterances and the response completed, we can save the intent with
    the Save Intent button at the bottom of the intent. Once that has saved, we can
    build our bot.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Building the bot takes all of the utterances from your intents and adds them
    to a language model. Click the Build button in the upper-right corner of the screen
    and wait for the system to put the bot together.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Testing your chatbot
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Lex has finished building, you will get a notification and a new Test
    bot section will open on the right of your screen. This is a basic text chat interface
    where you can try out your bot. Try typing `Hi` into the chat and you should get
    a response of Hi there or Hey:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当Lex完成构建后，您将收到通知，屏幕右侧将打开一个新的测试机器人部分。这是一个基本的文本聊天界面，您可以在这里尝试您的机器人。尝试在聊天中输入“嗨”，您应该得到“嗨，”或“嘿：”的响应。
- en: '![](img/6e095239-4f81-4768-9917-c14e65785a24.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e095239-4f81-4768-9917-c14e65785a24.png)'
- en: Initial test
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 初始测试
- en: If you don't, check that you have added the utterances and responses, and rebuild
    the chatbot.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，请检查您是否已添加了话语和响应，并重新构建聊天机器人。
- en: You can also test your bot by speaking to it. Click the microphone symbol, say
    `Hello`, and then click the microphone again. You should see what you said, and
    get a spoken response as well as a text response. If you get an error about not
    having a selected voice, go to Settings | General and change the output voice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过与其对话来测试您的机器人。点击麦克风符号，说出“你好”，然后再次点击麦克风。您应该能看到您说的话，并获得语音响应以及文本响应。如果您收到关于未选择声音的错误，请转到设置
    | 通用并更改输出声音。
- en: Publishing your bot
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布您的机器人
- en: 'With a working chatbot, we can publish the bot. Clicking the Publish button
    opens a popup where we can select the alias that we want to publish to. This is
    useful when you want to test that a new version of the bot is fully functional
    without replacing the existing live version. You can create a development or test
    alias without overwriting the existing production bot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个工作聊天机器人，我们可以发布机器人。点击发布按钮会弹出一个窗口，我们可以选择要发布的别名。这在您想测试机器人新版本是否完全功能而不替换现有实时版本时很有用。您可以创建一个开发或测试别名，而不会覆盖现有的生产机器人：
- en: '![](img/7716aabd-8c90-4571-bb97-41caa3587f43.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7716aabd-8c90-4571-bb97-41caa3587f43.png)'
- en: Publishing your bot
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 发布您的机器人
- en: Once the Publish is complete, you can access this new alias from other services.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布完成，您就可以从其他服务访问这个新的别名。
- en: Using Slots
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用槽位
- en: As we saw with Alexa, having a set response is OK, but using slots to customize
    the interaction is much better. Go into the sayHello intent screen and scroll
    down to Slots. This is identical to the slot configuration in Alexa.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们与Alexa所看到的那样，有一个固定的响应是可以的，但使用槽位来自定义交互会更好。进入sayHello意图界面，向下滚动到槽位。这与Alexa中的槽位配置相同。
- en: Give a name to the slot you want to get; in this case, we can ask them for their
    name so we call the slot `usersName`. We have to select a slot type and we can
    choose either GB_FIRST_NAME or US_FIRST_NAME. The last thing we need to do is
    to configure the prompt. Enter a question that will get them to enter their name,
    such as `What is your name?`. To add this slot, we need to click the blue plus
    button at the end of the line.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 给您想要获取的槽位起一个名字；在这种情况下，我们可以要求他们提供他们的名字，所以我们称这个槽位为`usersName`。我们必须选择一个槽位类型，我们可以选择GB_FIRST_NAME或US_FIRST_NAME。最后一件我们需要做的事情是配置提示。输入一个将引导他们输入名字的问题，例如“你叫什么名字？”。要添加这个槽位，我们需要点击行末的蓝色加号按钮。
- en: 'When we see the new line created, we can check that the Required checkbox is
    ticked so Lex knows to ask the user for this slot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到创建的新行时，我们可以检查是否勾选了“必需”复选框，这样Lex就知道要询问用户这个槽位：
- en: '![](img/95db7d96-cdc5-45b4-a262-412b376f9707.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95db7d96-cdc5-45b4-a262-412b376f9707.png)'
- en: Slot creation
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 槽位创建
- en: Now that we have a slot, we need to use the answer in our response. To add the
    slot into a response, we can wrap the slot name in curly braces. This means our
    response becomes `Hi there {usersName}`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了槽位，我们需要在我们的响应中使用答案。要将槽位添加到响应中，我们可以将槽位名称用大括号括起来。这意味着我们的响应变为“嗨，{usersName}”。
- en: 'We can now save this intent again and rebuild the chatbot. Now we get a slightly
    longer conversation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以再次保存这个意图并重新构建聊天机器人。现在我们得到一个稍微长一点的对话：
- en: '![](img/506b7fe4-9381-4d3e-902f-bf162cf2ea24.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/506b7fe4-9381-4d3e-902f-bf162cf2ea24.png)'
- en: Test with name
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 测试带名字
- en: Creating an FAQ chatbot
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个FAQ聊天机器人
- en: Now that we've learned how to make a Lex chatbot, we can start to build something
    that you are more likely to see in the real world. FAQ chatbots are becoming more
    and more popular; they are relatively simple to create and are a great way to
    introduce a chatbot to a website or Facebook group.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何制作Lex聊天机器人，我们可以开始构建一些更可能在现实世界中看到的机器人。FAQ聊天机器人越来越受欢迎；它们相对简单易创建，是向网站或Facebook群组介绍聊天机器人的好方法。
- en: To start creating an FAQ chatbot, we need to find an FAQ page to base this on.
    Most company websites have an FAQ page now so you can find the FAQ page for a
    company that interests you, or follow along with me on CircleLoop ([circleloop.com](https://www.circleloop.com/)).
    This site was chosen because it is where I work and it has the questions in three
    groups. If you are only doing this for practice, you can use any website, but
    if you want to publish your chatbot, ask the permission of the company. You never
    know, they could end up paying you for it eventually!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建FAQ聊天机器人，我们需要找到一个FAQ页面作为基础。现在大多数公司网站都有FAQ页面，所以你可以找到一个你感兴趣公司的FAQ页面，或者跟随我在CircleLoop（[circleloop.com](https://www.circleloop.com/)）上的操作。这个网站被选中是因为我在那里工作，并且它将问题分为三组。如果你只是练习，你可以使用任何网站，但如果你想发布你的聊天机器人，请请求公司的许可。你永远不知道，他们最终可能会为此支付你费用！
- en: CircleLoop is also good as it has a total of 24 questions, which is a good amount
    – too many and it can take a very long time and Lex can mix up similar questions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CircleLoop也很好，因为它总共有24个问题，这是一个很好的数量——太多的话会花费很长时间，Lex可能会混淆类似的问题。
- en: Setting up Lex
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Lex
- en: As we did in the first half of this chapter, we need to create a new Lex chatbot.
    On the Lex console page there will be a list of all of your Lex chatbots, and
    above that will be a Create button.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的前半部分所做的那样，我们需要创建一个新的Lex聊天机器人。在Lex控制台页面上，将有一个所有Lex聊天机器人的列表，在其上方将有一个创建按钮。
- en: Follow the same process as before, selecting Custom bot, naming your chatbot,
    choosing a voice, selecting a five-minute timeout, and selecting *No* for the
    COPPA question. If you are making a chatbot that is designed for children under
    13, you should research COPPA and alter your answer accordingly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的过程，选择自定义机器人，给你的聊天机器人命名，选择声音，选择五分钟的超时时间，并对于COPPA问题选择*否*。如果你正在制作一个为13岁以下儿童设计的聊天机器人，你应该研究COPPA并根据你的答案进行修改。
- en: Gathering the data
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集数据
- en: All of the data files for this section are available at [https://bit.ly/chatbot-ch5](https://bit.ly/chatbot-ch5)
    in the `data` folder, but if you are using your own company, you'll have to follow
    this process with your company's FAQs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的所有数据文件都可在`data`文件夹中的[https://bit.ly/chatbot-ch5](https://bit.ly/chatbot-ch5)找到，但如果你使用的是自己的公司，你必须按照你公司的常见问题解答（FAQ）流程进行。
- en: Before we start creating intents, we need to get the data that we will be using.
    Go to the FAQ page of your choice and open up a new file called `faq-setup.json`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建意图之前，我们需要获取我们将要使用的数据。前往你选择的常见问题解答（FAQ）页面，并打开一个名为`faq-setup.json`的新文件。
- en: 'This file will contain a group of intents and answers in the following format:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将包含一组意图和答案，格式如下：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The intent names should be unique strings that describe what the question is
    asking. For example, if you are asking, "Where is the company based?", you might
    call the intent `companyLocation`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 意图名称应该是描述问题所询问内容的唯一字符串。例如，如果你问“公司在哪里？”你可能将意图命名为`companyLocation`。
- en: 'Go through all of the questions in the *Setting Up & Using CircleLoop* section
    of the site. Repeat the process with a new file for the *Users & Numbers* and
    *Other Questions* sections. You should end up with three JSON files that contain
    all of the answers on the website. Here is a section of one of the `faq-setup.json`
    files:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历网站中“设置与使用CircleLoop”部分的全部问题。为“用户与数字”和“其他问题”部分使用新文件重复此过程。你应该最终得到包含网站上所有答案的三个JSON文件。以下是`faq-setup.json`文件中的一个部分：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are now going to upload these three files into an S3 bucket so that our
    Lambda functions can access them. In your AWS console, navigate to S3 and click
    Create bucket. Give your bucket a unique name and continue through the configuration.
    We don''t need to add any extra permissions to this bucket for this project:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将这三个文件上传到S3存储桶，以便我们的Lambda函数可以访问它们。在你的AWS控制台中，导航到S3并点击创建存储桶。给你的存储桶起一个独特的名字并继续配置。对于这个项目，我们不需要为此存储桶添加任何额外的权限：
- en: '![](img/98b401c2-b1a4-47ad-baf2-e2529c66f9d0.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98b401c2-b1a4-47ad-baf2-e2529c66f9d0.png)'
- en: Upload files
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件
- en: Now that we've created the bucket, we can upload our FAQ files. Click into your
    newly created bucket and then click the Upload button. Again, we don't need to
    change any of the permissions from their defaults.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了存储桶，我们可以上传我们的FAQ文件。点击进入你刚创建的存储桶，然后点击上传按钮。同样，我们不需要从默认设置更改任何权限。
- en: Creating the Intents
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建意图
- en: 'Once we''ve created and uploaded the JSON files, we need to create the intents
    to match up. Go through your JSON files and create a new intent for each line.
    The intent names need to be exactly the same as the keys in the JSON file object.
    You can then use the questions from the FAQ page as the first utterance for that
    intent:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建并上传了 JSON 文件，我们需要创建意图以匹配它们。检查您的 JSON 文件，并为每一行创建一个新的意图。意图名称必须与 JSON 文件对象中的键完全相同。然后，您可以使用
    FAQ 页面的问题作为该意图的第一个表述：
- en: '![](img/6f5c4842-7128-4de9-aa66-0e5e47d31e73.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f5c4842-7128-4de9-aa66-0e5e47d31e73.png)'
- en: Intents
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 意图
- en: By the end of this process, you should have as many intents as you do rows in
    your JSON files. You should then go through and add more utterances to each intent.
    These new utterances should be other ways to phrase the same question. Expanding
    the list of utterances increases the chance that the user will get the correct
    answer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到此过程结束时，你应该有与你的 JSON 文件中的行数一样多的意图。然后你应该为每个意图添加更多的表述。这些新的表述应该是相同问题的其他表述方式。扩展表述列表增加了用户获得正确答案的机会。
- en: Creating the Lambda Handler
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Lambda 处理器
- en: Now that we have the intents—catching the user utterances—we need to create
    the responses to send to the user. Because we have three files, we can create
    three Lambdas.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了意图——捕捉用户的表述——我们需要创建发送给用户的响应。因为我们有三个文件，所以我们可以创建三个 Lambda。
- en: Each Lambda will deal with questions about one section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Lambda 将处理一个部分的问题。
- en: 'Create three folders in your main Lambda folder, called `CL-setup`, `CL-users`,
    and `CL-other`. Inside each of the folders, create an `index.js` file. Open up
    the `index.js` file inside `CL-setup` and we can start to program the handler,
    starting with an empty handler:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的主 Lambda 文件夹中创建三个文件夹，分别命名为 `CL-setup`、`CL-users` 和 `CL-other`。在每个文件夹中创建一个
    `index.js` 文件。打开 `CL-setup` 中的 `index.js` 文件，我们可以开始编写处理器，从一个空的处理器开始：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, we need to find out which intent triggered the Lambda. The structure
    of the data received from Lex is slightly different from the structure of the
    data received from Alexa:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出哪个意图触发了 Lambda。Lex 收到的数据结构与 Alexa 收到的数据结构略有不同：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have the intent name, we need to make a request to S3 to get the
    file that contains the answer. As we did in [Chapter 3](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml),
    *Creating Your First Alexa Skill*, we first need to require in AWS and create
    a new instance of S3\. Add this code at the very top of the file, just before
    `exports.handler`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了意图名称，我们需要向 S3 发送请求以获取包含答案的文件。正如我们在[第 3 章](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml)，*创建您的第一个
    Alexa 技能*中所做的那样，我们首先需要在 AWS 中要求并创建一个新的 S3 实例。在文件顶部，在 `exports.handler` 之前添加此代码：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To make a request to S3, we need to pass in some query parameters. This is an
    object containing the `Bucket` that contains our object and the `Key` of the object
    we want.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 S3 发送请求，我们需要传递一些查询参数。这是一个包含我们的对象所在的 `Bucket` 和我们想要的对象的 `Key` 的对象。
- en: 'Because we''re using Node 8.10 and an `async` function, we need to return a
    promised value. This means we need to create a `new Promise` and then `resolve`
    and `reject` our results. Back inside our handler function, we can add this code.
    Unlike in [Chapter 3](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml), *Creating Your
    First Alexa Skill*, we can set `Key` to a fixed value of `faq-setup.json` for
    this Lambda, as this Lambda is only going to be called for questions from the
    *Set Up & Using CircleLoop* section:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 Node 8.10 和 `async` 函数，我们需要返回一个承诺值。这意味着我们需要创建一个新的 `Promise` 并然后解析和拒绝我们的结果。回到我们的处理器函数中，我们可以添加此代码。与[第
    3 章](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml)，*创建您的第一个 Alexa 技能*不同，我们可以为这个
    Lambda 将 `Key` 设置为一个固定的值 `faq-setup.json`，因为这个 Lambda 只会被 *设置和使用 CircleLoop* 部分的问题调用：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can put our `s3.getObject()` code inside this `Promise`, resolving `handleS3Data()`
    and rejecting `handleS3Error()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的 `s3.getObject()` 代码放在这个 `Promise` 中，以便在 `handleS3Data()` 被解析时执行，在 `handleS3Error()`
    被拒绝时执行：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now need to create the two handlers for the S3 responses. These functions
    can be created after the handler:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建两个用于 S3 响应的处理程序。这些函数可以在处理器之后创建：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will start by creating the data-handler. Inside here, we first need to parse
    the body of the data. This is because it comes down as a *buffer* that needs to
    be turned into JSON before we can work with it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建数据处理器。在这里，我们首先需要解析数据的主体。这是因为它以 *buffer* 的形式下来，在我们能够处理它之前需要将其转换为 JSON：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the data in JSON format, we can now check that `intentName` is one of
    the keys in the object. If it isn''t, we need to return the `handleS3Error` function
    to send the user an error message:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON格式的数据中，我们现在可以检查`intentName`是否是对象中的一个键。如果不是，我们需要返回`handleS3Error`函数来发送错误消息给用户：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `handleS3Error`, we can `console.log` the error and then create an error
    response string. This should tell the user there was an error and ask them to
    try asking another question:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleS3Error`中，我们可以`console.log`错误并创建一个错误响应字符串。这应该告诉用户发生了错误，并要求他们尝试再问一个问题：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating a response
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建响应
- en: 'The way that you create a response in Lex is very different from how it''s
    done in Alexa. In Lex, there is an object structure that needs to be followed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lex中创建响应的方式与在Alexa中创建的方式非常不同。在Lex中，需要遵循一个对象结构：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because this is a bit of code that we may use multiple times, we can create
    functions for each of the types. Here is a function for finishing the last stage
    of a conversation flow. This can be added to the bottom of the `index.js` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一段我们可能会多次使用的代码，我们可以为每种类型创建函数。这里是一个用于完成对话流程最后阶段的函数。这个函数可以被添加到`index.js`文件的底部：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function uses default values for `sessionAttributes` and `fulfillmentState`
    as we won't be setting either of them in most cases, but it is good to be able
    to if we wanted to.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用默认值`sessionAttributes`和`fulfillmentState`，因为我们大多数情况下不会设置它们，但如果我们想设置的话，这也是好的。
- en: 'With this new function, we can now create responses in our handler functions.
    Inside our `handleS3Data` function, we can return this `lexClose` function with
    the answer from the file as the message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新函数，我们现在可以在我们的处理函数中创建响应。在我们的`handleS3Data`函数内部，我们可以返回这个`lexClose`函数，将文件中的答案作为消息：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also need to make a `lexElicitIntent` function at the bottom of the file
    for when we tell the user to ask another question. This tells Lex that it should
    be expecting an intent utterance as its next message:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在文件底部创建一个`lexElicitIntent`函数，以便当我们告诉用户再问一个问题的时候使用。这告诉Lex它应该期待一个意图表述作为其下一条消息：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `lexElicitIntent` can then be returned at the end of the `handleS3Error`
    function to tell the user to ask another question:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个`lexElicitIntent`可以在`handleS3Error`函数的末尾返回，告诉用户再问一个问题：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This file can be copied into the other two folders. We only need to change `key`
    in the params object and the text in the error console log and response. With
    those changes made, we can deploy our three Lambdas using our build script.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件可以被复制到其他两个文件夹中。我们只需要更改params对象中的`key`和错误控制台日志中的文本以及响应。做出这些更改后，我们可以使用我们的构建脚本来部署我们的三个Lambdas。
- en: With all three Lambdas deployed, we need to make sure their role includes permissions
    to access S3 buckets. Inside each of the Lambdas, scroll down to the Role section
    and we should be able to see the role of lambdaBasic. We should have updated this
    in [Chapter 3](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml), *Creating Your First
    Alexa Skill*, but we should check again. Navigate into the IAM service and make
    sure that lambdaBasic has S3 read permissions. If it doesn't, then attach AmazonS3ReadOnlyAcess
    to this role.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了所有三个Lambdas之后，我们需要确保它们的角色包括访问S3存储桶的权限。在每一个Lambdas中，向下滚动到角色部分，我们应该能看到lambdaBasic的角色。我们应该在[第3章](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml)，*创建您的第一个Alexa技能*中更新了这一点，但我们应该再次检查。导航到IAM服务并确保lambdaBasic有S3读取权限。如果没有，那么将AmazonS3ReadOnlyAcess附加到这个角色上。
- en: Lambda fulfillment
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda满足
- en: We can use Lambdas to create the response of our intents. This gives us a lot
    more control than just having a text response. The great thing about Lex is that
    each intent can have its own Lambda handler or multiple intents can share one
    Lambda.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Lambdas来创建我们意图的响应。这比仅仅有一个文本响应给我们更多的控制。Lex的伟大之处在于每个意图都可以有自己的Lambda处理程序，或者多个意图可以共享一个Lambda。
- en: With the three Lambdas deployed, we can use them to fulfill the intents. We're
    going to have all of the intents about the setup share the `CL-setup` Lambda,
    all intents about users and numbers will share the `CL-users` Lambda, and all
    other questions will share the `CL-other` Lambda.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了三个Lambdas之后，我们可以使用它们来满足意图。我们将把所有关于设置的意图都共享给`CL-setup` Lambda，所有关于用户和数字的意图都共享给`CL-users`
    Lambda，所有其他问题都共享给`CL-other` Lambda。
- en: Open up your Lambda console and go into your FAQ chatbot. Open an intent and
    scroll down to the Fulfillment section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的Lambda控制台并进入你的FAQ聊天机器人。打开一个意图并滚动到满足部分。
- en: 'There are two options:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种选择：
- en: AWS Lambda function
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda函数
- en: Return parameters to client
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回参数给客户端
- en: 'As we''ve created the Lambdas, we can select AWS Lambda function, which opens
    more menu items for us to select. The main one is the Lambda dropdown where we
    can select which Lambda will be triggered on the intent fulfillment:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经创建了Lambdas，我们可以选择AWS Lambda函数，这为我们打开了更多的菜单项供我们选择。主要的一个是Lambda下拉菜单，我们可以从中选择哪个Lambda会在意图满足时被触发：
- en: '![](img/629682ea-3204-4cdf-a1a4-6ddebe158ecc.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/629682ea-3204-4cdf-a1a4-6ddebe158ecc.png)'
- en: Intent fulfillment options
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Intent fulfillment options
- en: With the Lambda selected, we need to save the intent and move on to the next
    intent. This needs to be done for every intent in the chatbot, making sure to
    send the correct intents to the correct Lambdas.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Lambda之后，我们需要保存意图并继续下一个意图。这需要在聊天机器人中的每个意图上完成，确保将正确的意图发送到正确的Lambda。
- en: Building and testing
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Building and testing
- en: With all of the intents pointing to a fulfillment Lambda, we can build our chatbot
    and then test it. Click the Build button in the upper-right corner of the screen
    and wait until the build process has stopped. This may take a few minutes, and
    the *Test* section will open when the build process ends.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有意图都指向一个fulfillment Lambda时，我们可以构建我们的聊天机器人，然后测试它。点击屏幕右上角的构建按钮，等待构建过程停止。这可能需要几分钟，当构建过程结束时，*测试*部分将打开。
- en: 'To test our chatbot, type a question and you should receive the correct answer:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的聊天机器人，输入一个问题，你应该会收到正确的答案：
- en: '![](img/493b8dd5-39d9-4d96-9928-e804bb7b00db.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/493b8dd5-39d9-4d96-9928-e804bb7b00db.png)'
- en: FAQ tests
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: FAQ tests
- en: 'If you don''t get the correct answer, or don''t get an error at all, then there
    are a few things to check:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有得到正确的答案，或者完全没有得到错误，那么有几个地方需要检查：
- en: Look in the Lambda logs and check that the correct Lambda is being called. You
    should also be able to see a log with the error message, allowing you to pinpoint
    the error.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Lambda日志并检查是否调用了正确的Lambda。你也应该能看到一个包含错误信息的日志，这可以帮助你定位错误。
- en: Check that the Lambdas have permission to access the S3 buckets.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查Lambda是否有权限访问S3存储桶。
- en: Follow the Lambda debugging guide at the end of this book.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考本书末尾的Lambda调试指南。
- en: Lex responses
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lex responses
- en: 'We have just seen two of the different response types that can be returned
    to Lex. There are currently five different types of response that Lex can handle:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了Lex可以返回的两种不同类型的响应。目前Lex可以处理五种不同类型的响应：
- en: '`elicitSlot`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elicitSlot`'
- en: '`` `elicitIntent` ``'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `elicitIntent` ``'
- en: '`confirmIntent`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`confirmIntent`'
- en: '`close`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`'
- en: '`delegate`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delegate`'
- en: These can all be found at [http://bit.ly/chatbot-ch5](http://bit.ly/chatbot-ch5)
    in the `All-Lex-Responses.js` file. You can then copy them into your future projects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以在`All-Lex-Responses.js`文件中的[http://bit.ly/chatbot-ch5](http://bit.ly/chatbot-ch5)找到。然后你可以将它们复制到你的未来项目中。
- en: elicitSlot
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: elicitSlot
- en: The `elicitSlot` response type is very useful if you have been doing checks
    on your slot values and have found one of them to be incorrect. You can then ask
    the user to re-enter the value for that slot and make sure that Lex stores that
    in the correct slot.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对slot值进行检查并发现其中一个值不正确时，`elicitSlot`响应类型非常有用。然后你可以要求用户重新输入该slot的值，并确保Lex将其存储在正确的slot中。
- en: 'To call `elicitSlot`, you need to pass in a message, the slots (an object containing
    all of the slots and current values), a `slotToElicit` value, and `intentName`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`elicitSlot`，你需要传递一个消息、slots（一个包含所有slots和当前值的对象）、`slotToElicit`值和`intentName`：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we rebuilt the car helper bot in Lex, we would use the `lexElicitSlot` function
    when we validate the slot values. If there was an incorrect slot, then we would
    call this function like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Lex中重新构建了汽车助手机器人，当验证slot值时，我们会使用`lexElicitSlot`函数。如果有一个slot值不正确，我们会像这样调用这个函数：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: elicitIntent
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: elicitIntent
- en: 'We have already seen this Lex response, taking a message and session attributes.
    This is usually used to continue the conversation or to restart with a new intent:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了这个Lex响应，它接受消息和会话属性。这通常用于继续对话或以新的意图重新开始：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: confirmIntent
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: confirmIntent
- en: 'The `confirmIntent` response is used when you want to ask a user whether they
    want to do something. This could be used at the end of the FAQ bot to ask `Would
    you like to sign up?`, which would be a `confirmIntent` response for a *signUp*
    intent. You need to pass in `message`, `intentName`, and the `slots` for that
    intent. Any slots that you don''t want to pre-fill should have a value of `null`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想询问用户是否想要做某事时，会使用`confirmIntent`响应。这可以在FAQ机器人的末尾使用，例如询问`Would you like to
    sign up?`，这将是一个`confirmIntent`响应，用于*signUp*意图。你需要传递`message`、`intentName`和该意图的`slots`。任何你不想预先填充的slots应该有一个值为`null`：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: close
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: close
- en: 'This is the simplest and most-used Lex response. The only thing that you need
    to pass in is `message`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Lex 最简单且最常用的响应。您需要传递的唯一东西是 `message`：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: delegate
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委派
- en: 'The `delegate` response is where you want to leave Lex to decide what to send
    to the user. This is most likely used if you have validated an input and you want
    Lex to ask for the next slot or move into fulfillment. It takes just a `slots`
    object that contains all of the slots for the current intent:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegate` 响应是您希望 Lex 决定向用户发送什么内容的地方。这通常用于您已验证输入并且希望 Lex 请求下一个槽位或进入满足阶段。它只需要一个包含当前意图所有槽位的
    `slots` 对象：'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been an introduction to Amazon Lex. You've learned that Lex
    and Alexa are very similar in form and function, but there are a few differences
    in how they are built and how they work.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是 Amazon Lex 的介绍。你已经了解到 Lex 和 Alexa 在形式和功能上非常相似，但在构建方式和工作方式上存在一些差异。
- en: We can now create a Lex chatbot with intents, slots, and hardcoded responses.
    We can then increase the functionality by creating Lambdas to handle intent fulfillment.
    One advantage of Lex over Alexa is that we can use multiple Lambdas to handle
    different intents. To help us easily respond to Lex, we created a `Lex` class
    that maps values into the correct response format.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个具有意图、槽位和硬编码响应的 Lex 聊天机器人。然后我们可以通过创建 Lambda 来处理意图满足来增加其功能。Lex 相比于 Alexa
    的一个优点是我们可以使用多个 Lambda 来处理不同的意图。为了帮助我们更容易地响应 Lex，我们创建了一个将值映射到正确响应格式的 `Lex` 类。
- en: We used these skills to build an FAQ chatbot that gets data from S3 and uses
    that to generate a response.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些技能构建了一个从 S3 获取数据并用于生成响应的常见问题解答聊天机器人。
- en: In the next chapter we will take what we have learned in this chapter and build
    upon it by adding a database to our chatbot. We will use DynamoDB to store information
    about the chat, allowing us to make a more realistic chatbot conversation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用本章所学，通过向聊天机器人添加数据库来构建在它之上。我们将使用 DynamoDB 存储有关聊天信息，使我们能够进行更真实的聊天机器人对话。
- en: Questions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you create a Lex chatbot without using Lambdas?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否在不使用 Lambda 的情况下创建一个 Lex 聊天机器人？
- en: How do you include a slot in a response from Lex?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Lex 的响应中包含一个槽位？
- en: How does Lex use Lambdas differently from Alexa?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lex 与 Alexa 在使用 Lambda 方面有何不同？
- en: How many response types does Lex deal with?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lex 处理多少种响应类型？
- en: Can you name them all?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能全部列举出来吗？
- en: What is the name of the function to get data from S3?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 S3 数据的函数名称是什么？
