- en: Building Your First Amazon Lex Chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding two chapters focused solely on Amazon Alexa and building Alexa
    Skills. The next three chapters will teach you how to build chatbots using Amazon
    Lex. In this chapter, we'll learn how to build and test a Lex chatbot and then
    we'll step things up by integrating S3.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Lex is very similar to Amazon Alexa but the main difference is that Lex
    has been designed to primarily work as a typed interaction. This means that you
    can use Lex to power Facebook messenger bots, add functionality to Slack, or even
    send text messages to your users. This doesn't stop you from using Lex for voice
    interactions and it can be used to build voice-based chatbots outside of the Amazon
    Alexa ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lex chatbot with slots and built-in responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an FAQ chatbot with Lambda fulfillment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving answers from S3 storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating a Lambda function for our skill, and we'll
    be creating and deploying it using the local development setup that we created
    in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting Started with
    AWS and Amazon CLI*.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code and data required for this chapter can be found at [http://bit.ly/chatbot-ch5](http://bit.ly/chatbot-ch5).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Amazon Lex chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Lex chatbot is very similar to the process of creating an Alexa skill.
    We need to create intents with utterances, we can have slots with slot types on
    those intents, and we can then build a response to the user. Although Lex and
    Alexa are very similar, there are some key differences that we will look at as
    we go through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start creating our first Lex chatbot, we need to open the AWS console and
    search for *Lex*. Once on the Lex page, click Get Started to get to the bot setup
    page. You''ll be presented with the option to use one of three sample bots or
    to create a Custom bot. We''ll be creating a custom bot, so select that option.
    The other three options are sample bots. These have been built to showcase the
    applications that you can use a Lex chatbot for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3309227c-5fd2-4617-b8c8-28313e47c43f.png)'
  prefs: []
  type: TYPE_IMG
- en: Bot-creation options
  prefs: []
  type: TYPE_NORMAL
- en: Having selected Custom bot, we get to name our bot and set up a few other settings.
    All of these settings are editable later, so we can start with some defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Select a voice for your chatbot. This is the voice that will be used if you
    want to set up your Lex bot for voice-based chatbots. As we are going to be using
    Lex for text-based interactions only, we could select None. We'll be building
    a text-based application, but you should still choose a voice so you can test
    with voice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two parts are to set a timeout; we can use the default of 5 minutes,
    and select No for the COPPA question. If you want to create a chatbot that will
    talk with children, ticking Yes will stop Lex from storing any of the conversations
    to comply with the Children''s Online Privacy Protection Act. Now that we''ve
    finished the settings, we can click Create. This takes us to the Lex dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5eac0fff-1d1c-4013-981d-960045e11548.png)'
  prefs: []
  type: TYPE_IMG
- en: Lex dashboard
  prefs: []
  type: TYPE_NORMAL
- en: The components and process of creating a Lex chatbot are very similar to the
    process of creating an Alexa skill. There are Intents, Utterances, Slots, and
    Slot types, and the creation of most of these is almost identical to their creation
    in Alexa.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Intent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we want to do is Create intent. Unlike Alexa, we have the option
    to Create intent, Import intent, or Search existing intents. As this is our first
    intent in Lex, we need to Create intent. We are prompted for a name for our new
    intent; we should call our first intent `sayHello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e54e9ca-0a2d-4439-b947-b93caaa2be7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Intent screen
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add utterances so that the user can trigger the intent. We
    can add the utterances of `hi`, `hey`, and `hello`. These are not case-sensitive,
    and adding punctuation such as commas and full stops is unnecessary, although
    apostrophes are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest differences between Lex and Alexa is that we can send responses
    without needing a Lambda. Scroll to the bottom of the page and you will see the
    Fulfillment and Response sections. The Fulfillment section lets you decide whether
    to send this intent to a Lambda. For now, we are going to keep that option on
    Return parameters to client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Response section is where we can tell Lex what to send back to the
    user. Click the Add Message button and a message block will appear. In the text
    area, we can type the response we want to send back to the user. Add a response
    phrase such as `Hi there` and press *Enter*. Unlike the utterances, the response
    is case-sensitive and can contain any punctuation you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8d718c5-066f-4482-a6c7-c8e642b553d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Fulfillment and response
  prefs: []
  type: TYPE_NORMAL
- en: We can actually add multiple response messages, and Lex will choose one of them
    at random. This makes multiple interactions with the chatbot feel more natural
    and less robotic.
  prefs: []
  type: TYPE_NORMAL
- en: With the utterances and the response completed, we can save the intent with
    the Save Intent button at the bottom of the intent. Once that has saved, we can
    build our bot.
  prefs: []
  type: TYPE_NORMAL
- en: Building the bot takes all of the utterances from your intents and adds them
    to a language model. Click the Build button in the upper-right corner of the screen
    and wait for the system to put the bot together.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Lex has finished building, you will get a notification and a new Test
    bot section will open on the right of your screen. This is a basic text chat interface
    where you can try out your bot. Try typing `Hi` into the chat and you should get
    a response of Hi there or Hey:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e095239-4f81-4768-9917-c14e65785a24.png)'
  prefs: []
  type: TYPE_IMG
- en: Initial test
  prefs: []
  type: TYPE_NORMAL
- en: If you don't, check that you have added the utterances and responses, and rebuild
    the chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: You can also test your bot by speaking to it. Click the microphone symbol, say
    `Hello`, and then click the microphone again. You should see what you said, and
    get a spoken response as well as a text response. If you get an error about not
    having a selected voice, go to Settings | General and change the output voice.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your bot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a working chatbot, we can publish the bot. Clicking the Publish button
    opens a popup where we can select the alias that we want to publish to. This is
    useful when you want to test that a new version of the bot is fully functional
    without replacing the existing live version. You can create a development or test
    alias without overwriting the existing production bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7716aabd-8c90-4571-bb97-41caa3587f43.png)'
  prefs: []
  type: TYPE_IMG
- en: Publishing your bot
  prefs: []
  type: TYPE_NORMAL
- en: Once the Publish is complete, you can access this new alias from other services.
  prefs: []
  type: TYPE_NORMAL
- en: Using Slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw with Alexa, having a set response is OK, but using slots to customize
    the interaction is much better. Go into the sayHello intent screen and scroll
    down to Slots. This is identical to the slot configuration in Alexa.
  prefs: []
  type: TYPE_NORMAL
- en: Give a name to the slot you want to get; in this case, we can ask them for their
    name so we call the slot `usersName`. We have to select a slot type and we can
    choose either GB_FIRST_NAME or US_FIRST_NAME. The last thing we need to do is
    to configure the prompt. Enter a question that will get them to enter their name,
    such as `What is your name?`. To add this slot, we need to click the blue plus
    button at the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we see the new line created, we can check that the Required checkbox is
    ticked so Lex knows to ask the user for this slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95db7d96-cdc5-45b4-a262-412b376f9707.png)'
  prefs: []
  type: TYPE_IMG
- en: Slot creation
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a slot, we need to use the answer in our response. To add the
    slot into a response, we can wrap the slot name in curly braces. This means our
    response becomes `Hi there {usersName}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now save this intent again and rebuild the chatbot. Now we get a slightly
    longer conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/506b7fe4-9381-4d3e-902f-bf162cf2ea24.png)'
  prefs: []
  type: TYPE_IMG
- en: Test with name
  prefs: []
  type: TYPE_NORMAL
- en: Creating an FAQ chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned how to make a Lex chatbot, we can start to build something
    that you are more likely to see in the real world. FAQ chatbots are becoming more
    and more popular; they are relatively simple to create and are a great way to
    introduce a chatbot to a website or Facebook group.
  prefs: []
  type: TYPE_NORMAL
- en: To start creating an FAQ chatbot, we need to find an FAQ page to base this on.
    Most company websites have an FAQ page now so you can find the FAQ page for a
    company that interests you, or follow along with me on CircleLoop ([circleloop.com](https://www.circleloop.com/)).
    This site was chosen because it is where I work and it has the questions in three
    groups. If you are only doing this for practice, you can use any website, but
    if you want to publish your chatbot, ask the permission of the company. You never
    know, they could end up paying you for it eventually!
  prefs: []
  type: TYPE_NORMAL
- en: CircleLoop is also good as it has a total of 24 questions, which is a good amount
    – too many and it can take a very long time and Lex can mix up similar questions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Lex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we did in the first half of this chapter, we need to create a new Lex chatbot.
    On the Lex console page there will be a list of all of your Lex chatbots, and
    above that will be a Create button.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the same process as before, selecting Custom bot, naming your chatbot,
    choosing a voice, selecting a five-minute timeout, and selecting *No* for the
    COPPA question. If you are making a chatbot that is designed for children under
    13, you should research COPPA and alter your answer accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the data files for this section are available at [https://bit.ly/chatbot-ch5](https://bit.ly/chatbot-ch5)
    in the `data` folder, but if you are using your own company, you'll have to follow
    this process with your company's FAQs.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start creating intents, we need to get the data that we will be using.
    Go to the FAQ page of your choice and open up a new file called `faq-setup.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file will contain a group of intents and answers in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The intent names should be unique strings that describe what the question is
    asking. For example, if you are asking, "Where is the company based?", you might
    call the intent `companyLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go through all of the questions in the *Setting Up & Using CircleLoop* section
    of the site. Repeat the process with a new file for the *Users & Numbers* and
    *Other Questions* sections. You should end up with three JSON files that contain
    all of the answers on the website. Here is a section of one of the `faq-setup.json`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to upload these three files into an S3 bucket so that our
    Lambda functions can access them. In your AWS console, navigate to S3 and click
    Create bucket. Give your bucket a unique name and continue through the configuration.
    We don''t need to add any extra permissions to this bucket for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98b401c2-b1a4-47ad-baf2-e2529c66f9d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Upload files
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created the bucket, we can upload our FAQ files. Click into your
    newly created bucket and then click the Upload button. Again, we don't need to
    change any of the permissions from their defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''ve created and uploaded the JSON files, we need to create the intents
    to match up. Go through your JSON files and create a new intent for each line.
    The intent names need to be exactly the same as the keys in the JSON file object.
    You can then use the questions from the FAQ page as the first utterance for that
    intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f5c4842-7128-4de9-aa66-0e5e47d31e73.png)'
  prefs: []
  type: TYPE_IMG
- en: Intents
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this process, you should have as many intents as you do rows in
    your JSON files. You should then go through and add more utterances to each intent.
    These new utterances should be other ways to phrase the same question. Expanding
    the list of utterances increases the chance that the user will get the correct
    answer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda Handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the intents—catching the user utterances—we need to create
    the responses to send to the user. Because we have three files, we can create
    three Lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Each Lambda will deal with questions about one section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create three folders in your main Lambda folder, called `CL-setup`, `CL-users`,
    and `CL-other`. Inside each of the folders, create an `index.js` file. Open up
    the `index.js` file inside `CL-setup` and we can start to program the handler,
    starting with an empty handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to find out which intent triggered the Lambda. The structure
    of the data received from Lex is slightly different from the structure of the
    data received from Alexa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the intent name, we need to make a request to S3 to get the
    file that contains the answer. As we did in [Chapter 3](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml),
    *Creating Your First Alexa Skill*, we first need to require in AWS and create
    a new instance of S3\. Add this code at the very top of the file, just before
    `exports.handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To make a request to S3, we need to pass in some query parameters. This is an
    object containing the `Bucket` that contains our object and the `Key` of the object
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''re using Node 8.10 and an `async` function, we need to return a
    promised value. This means we need to create a `new Promise` and then `resolve`
    and `reject` our results. Back inside our handler function, we can add this code.
    Unlike in [Chapter 3](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml), *Creating Your
    First Alexa Skill*, we can set `Key` to a fixed value of `faq-setup.json` for
    this Lambda, as this Lambda is only going to be called for questions from the
    *Set Up & Using CircleLoop* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put our `s3.getObject()` code inside this `Promise`, resolving `handleS3Data()`
    and rejecting `handleS3Error()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create the two handlers for the S3 responses. These functions
    can be created after the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by creating the data-handler. Inside here, we first need to parse
    the body of the data. This is because it comes down as a *buffer* that needs to
    be turned into JSON before we can work with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With the data in JSON format, we can now check that `intentName` is one of
    the keys in the object. If it isn''t, we need to return the `handleS3Error` function
    to send the user an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In `handleS3Error`, we can `console.log` the error and then create an error
    response string. This should tell the user there was an error and ask them to
    try asking another question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating a response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way that you create a response in Lex is very different from how it''s
    done in Alexa. In Lex, there is an object structure that needs to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this is a bit of code that we may use multiple times, we can create
    functions for each of the types. Here is a function for finishing the last stage
    of a conversation flow. This can be added to the bottom of the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function uses default values for `sessionAttributes` and `fulfillmentState`
    as we won't be setting either of them in most cases, but it is good to be able
    to if we wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new function, we can now create responses in our handler functions.
    Inside our `handleS3Data` function, we can return this `lexClose` function with
    the answer from the file as the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to make a `lexElicitIntent` function at the bottom of the file
    for when we tell the user to ask another question. This tells Lex that it should
    be expecting an intent utterance as its next message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `lexElicitIntent` can then be returned at the end of the `handleS3Error`
    function to tell the user to ask another question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This file can be copied into the other two folders. We only need to change `key`
    in the params object and the text in the error console log and response. With
    those changes made, we can deploy our three Lambdas using our build script.
  prefs: []
  type: TYPE_NORMAL
- en: With all three Lambdas deployed, we need to make sure their role includes permissions
    to access S3 buckets. Inside each of the Lambdas, scroll down to the Role section
    and we should be able to see the role of lambdaBasic. We should have updated this
    in [Chapter 3](13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml), *Creating Your First
    Alexa Skill*, but we should check again. Navigate into the IAM service and make
    sure that lambdaBasic has S3 read permissions. If it doesn't, then attach AmazonS3ReadOnlyAcess
    to this role.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda fulfillment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use Lambdas to create the response of our intents. This gives us a lot
    more control than just having a text response. The great thing about Lex is that
    each intent can have its own Lambda handler or multiple intents can share one
    Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: With the three Lambdas deployed, we can use them to fulfill the intents. We're
    going to have all of the intents about the setup share the `CL-setup` Lambda,
    all intents about users and numbers will share the `CL-users` Lambda, and all
    other questions will share the `CL-other` Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your Lambda console and go into your FAQ chatbot. Open an intent and
    scroll down to the Fulfillment section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return parameters to client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we''ve created the Lambdas, we can select AWS Lambda function, which opens
    more menu items for us to select. The main one is the Lambda dropdown where we
    can select which Lambda will be triggered on the intent fulfillment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/629682ea-3204-4cdf-a1a4-6ddebe158ecc.png)'
  prefs: []
  type: TYPE_IMG
- en: Intent fulfillment options
  prefs: []
  type: TYPE_NORMAL
- en: With the Lambda selected, we need to save the intent and move on to the next
    intent. This needs to be done for every intent in the chatbot, making sure to
    send the correct intents to the correct Lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of the intents pointing to a fulfillment Lambda, we can build our chatbot
    and then test it. Click the Build button in the upper-right corner of the screen
    and wait until the build process has stopped. This may take a few minutes, and
    the *Test* section will open when the build process ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our chatbot, type a question and you should receive the correct answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/493b8dd5-39d9-4d96-9928-e804bb7b00db.png)'
  prefs: []
  type: TYPE_IMG
- en: FAQ tests
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t get the correct answer, or don''t get an error at all, then there
    are a few things to check:'
  prefs: []
  type: TYPE_NORMAL
- en: Look in the Lambda logs and check that the correct Lambda is being called. You
    should also be able to see a log with the error message, allowing you to pinpoint
    the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that the Lambdas have permission to access the S3 buckets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the Lambda debugging guide at the end of this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lex responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just seen two of the different response types that can be returned
    to Lex. There are currently five different types of response that Lex can handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elicitSlot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `elicitIntent` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`confirmIntent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delegate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can all be found at [http://bit.ly/chatbot-ch5](http://bit.ly/chatbot-ch5)
    in the `All-Lex-Responses.js` file. You can then copy them into your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: elicitSlot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `elicitSlot` response type is very useful if you have been doing checks
    on your slot values and have found one of them to be incorrect. You can then ask
    the user to re-enter the value for that slot and make sure that Lex stores that
    in the correct slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call `elicitSlot`, you need to pass in a message, the slots (an object containing
    all of the slots and current values), a `slotToElicit` value, and `intentName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rebuilt the car helper bot in Lex, we would use the `lexElicitSlot` function
    when we validate the slot values. If there was an incorrect slot, then we would
    call this function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: elicitIntent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen this Lex response, taking a message and session attributes.
    This is usually used to continue the conversation or to restart with a new intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: confirmIntent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `confirmIntent` response is used when you want to ask a user whether they
    want to do something. This could be used at the end of the FAQ bot to ask `Would
    you like to sign up?`, which would be a `confirmIntent` response for a *signUp*
    intent. You need to pass in `message`, `intentName`, and the `slots` for that
    intent. Any slots that you don''t want to pre-fill should have a value of `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: close
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the simplest and most-used Lex response. The only thing that you need
    to pass in is `message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delegate` response is where you want to leave Lex to decide what to send
    to the user. This is most likely used if you have validated an input and you want
    Lex to ask for the next slot or move into fulfillment. It takes just a `slots`
    object that contains all of the slots for the current intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been an introduction to Amazon Lex. You've learned that Lex
    and Alexa are very similar in form and function, but there are a few differences
    in how they are built and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a Lex chatbot with intents, slots, and hardcoded responses.
    We can then increase the functionality by creating Lambdas to handle intent fulfillment.
    One advantage of Lex over Alexa is that we can use multiple Lambdas to handle
    different intents. To help us easily respond to Lex, we created a `Lex` class
    that maps values into the correct response format.
  prefs: []
  type: TYPE_NORMAL
- en: We used these skills to build an FAQ chatbot that gets data from S3 and uses
    that to generate a response.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will take what we have learned in this chapter and build
    upon it by adding a database to our chatbot. We will use DynamoDB to store information
    about the chat, allowing us to make a more realistic chatbot conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you create a Lex chatbot without using Lambdas?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you include a slot in a response from Lex?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Lex use Lambdas differently from Alexa?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many response types does Lex deal with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you name them all?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the function to get data from S3?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
