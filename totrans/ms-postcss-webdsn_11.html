<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Manipulating Custom Syntaxes"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Manipulating Custom Syntaxes</h1></div></div></div><p>Although many developers have moved on from using preprocessors to using PostCSS, it is important to note that PostCSS is not a replacement, just an alternative way of preprocessing CSS styles. To help with the transition, we're not forced to learn a new syntax. Using a handful of plugins, we can take advantage of the speed of PostCSS, while still using syntaxes that we're accustomed to, such as Less, SASS, or Stylus.</p><p>In this chapter, we'll take a look at the plugins that make this possible, and work on some simple examples that show you how using a custom syntax that we're all familiar with is still possible when using PostCSS.</p><p>This chapter will cover the following technical topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing custom syntaxes</li><li class="listitem" style="list-style-type: disc">Implementing examples of custom syntax plugins</li><li class="listitem" style="list-style-type: disc">Parsing CSS</li><li class="listitem" style="list-style-type: disc">Converting content to strings with the API</li><li class="listitem" style="list-style-type: disc">Adding highlighting support to our code</li></ul></div><p>Let's make a start!</p><div class="section" title="Introducing custom syntaxes"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec90"/>Introducing custom syntaxes</h1></div></div></div><p>W3Schools<a id="id680" class="indexterm"/> defines a CSS syntax as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A CSS rule-set consists of a selector and a declaration block: The selector points to the HTML element you want to style. The declaration block contains one or more declarations separated by semicolons."</em></span></p></blockquote></div><p>We as developers spend many hours crafting sites; this can be something small as a one-page contact card-type site, right through to a large e-commerce website. It does not matter which styles we decide to use, or how we get there: the key is that the final result must use the same standard syntax that we've grown to love over the years.</p><p>This does not mean to say that our source should be standard CSS, in fact, it would be very restrictive if this were the only option! We could use libraries such as SASS or Less, but instead, how about using the API and custom syntax plugins to manipulate our styles directly? We touched on some of the principles back in <a class="link" href="ch08.html" title="Chapter 8. Creating PostCSS Plugins">Chapter 8</a>, <span class="emphasis"><em>Creating PostCSS Plugins</em></span>; it's time to revisit this and explore how we can begin to remove this restriction.</p><p>Why would we<a id="id681" class="indexterm"/> want to do this, I hear you ask? The answer's simple—let's assume for a moment you create themes for WordPress. WordPress' default themes are created using SASS (and PostCSS); this means a dependency on SASS in some form. We can mitigate this a little by using the <code class="literal">gulp-sass</code> plugin, but this still uses <code class="literal">libsass</code> to compile code.</p><p>What if we could turn this on its head, and use the API and custom syntax plugins that parses SASS code and converts it to PostCSS equivalent? Okay, granted, we may not be able to cover all styles; we can at least make a start on converting some, and reduce our dependency on using SASS. Let's make a start. Before we get stuck into producing code, we have a simple administrative task to perform: we need to install a syntax highlighter first.</p></div></div>
<div class="section" title="Preparing our environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec91"/>Preparing our environment</h1></div></div></div><p>Throughout the course<a id="id682" class="indexterm"/> of this chapter, we will be working directly with the PostCSS API (or a plugin's individual API, if it has one). As we are working directly on CSS (and not simply through a plugin's configuration object), it makes sense to install a syntax highlighter that works with PostCSS.</p><p>Not every text editor has one, but if you happen to use Sublime Text, with the Package Control facility installed (and I am assuming this is the case for the demos in this book), then it has a highlighter available for PostCSS that we can install. The plugin is available at <a class="ulink" href="https://github.com/hudochenkov/Syntax-highlighting-for-PostCSS">https://github.com/hudochenkov/Syntax-highlighting-for-PostCSS</a>. Let's get it installed using the<a id="id683" class="indexterm"/> following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open up Sublime Text, then press <span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>P</em></span> (OS X) or <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>P</em></span> (Linux/Windows) to open the command palette.</li><li class="listitem">From the list that appears, click on <span class="strong"><strong>Package Control: Install Package</strong></span>.</li><li class="listitem">After a few moments, it will show a new list; start typing <code class="literal">Syntax Highlighting for PostCSS</code>:<div class="mediaobject"><img src="graphics/BO5194_11_01.jpg" alt="Preparing our environment"/></div></li><li class="listitem">When it appears, click on it to install; it takes a couple of moments to complete.</li></ol></div><p>We can of course simply use a highlighter that works with JavaScript; this won't be the same though: having<a id="id684" class="indexterm"/> a highlighter designed for PostCSS will make it easier to edit code!</p><p>The syntax highlighter that we've just installed comes with its own theme. If you like to roll your own, then you can do <a id="id685" class="indexterm"/>so, using the Base16 site at <a class="ulink" href="http://chriskempson.github.io/base16/">http://chriskempson.github.io/base16/</a>.</p><p>Okay, let's move on; it's time to get stuck into code. Let's begin by exploring some of the plugins available for parsing code in PostCSS.</p></div>
<div class="section" title="Implementing custom syntax plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec92"/>Implementing custom syntax plugins</h1></div></div></div><p>The PostCSS ecosystem <a id="id686" class="indexterm"/>contains over 100 plugins at last count; this is on the increase. These plugins will all serve different needs, but will have one thing in common: the process they use to transform our code.</p><p>Now, we should be clear that this similarity is at a very high level; we are not referring to the technical details of each plugin! This aside, when creating our own custom syntax, we must follow a three-step process:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We first put our code through a parser.</li><li class="listitem">We then transform it using anyone of a number of plugins.</li><li class="listitem">We finally stringify it, or convert it to valid CSS in string format.</li></ol></div><p>We already have a handful of plugins that allow us to work with other syntaxes within a PostCSS environment; these include languages such as less or JavaScript:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name of plugin</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose of plugin</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">sugarss</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This plugin is<a id="id687" class="indexterm"/> an indent-based syntax like SASS or Stylus.</p>
<p>Plugin is<a id="id688" class="indexterm"/> available from <a class="ulink" href="https://github.com/postcss/sugarss">https://github.com/postcss/sugarss</a>. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">postcss-less</code>
</p>
</td><td style="text-align: left" valign="top">
<p>We can use<a id="id689" class="indexterm"/> this plugin to transform less into valid CSS. Note: it does not compile code.</p>
<p>Plugin is<a id="id690" class="indexterm"/> available from <a class="ulink" href="https://github.com/webschik/postcss-less">https://github.com/webschik/postcss-less</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">postcss-js</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Anyone working with JavaScript can use this plugin to write styles in JS or transform<a id="id691" class="indexterm"/> React Inline Styles, Radium, or <a id="id692" class="indexterm"/>JSS.</p>
<p>Plugin is available from <a class="ulink" href="https://github.com/postcss/postcss-js">https://github.com/postcss/postcss-js</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">postcss-scss</code>
</p>
</td><td style="text-align: left" valign="top">
<p>For those of you <a id="id693" class="indexterm"/>using SASS, this plugin is perfect for <a id="id694" class="indexterm"/>working with SASS code; it does <span class="emphasis"><em>not</em></span> compile code to CSS.</p>
<p>Plugin is available from <a class="ulink" href="https://github.com/postcss/postcss-scss">https://github.com/postcss/postcss-scss</a>. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">postcss-safe-parser</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This plugin<a id="id695" class="indexterm"/> is perfect for finding and<a id="id696" class="indexterm"/> fixing CSS syntax errors.It's available to download from <a class="ulink" href="https://github.com/postcss/postcss-safe-parser">https://github.com/postcss/postcss-safe-parser</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">poststylus</code>
</p>
</td><td style="text-align: left" valign="top">
<p>We can <a id="id697" class="indexterm"/>use this plugin to transform styles created<a id="id698" class="indexterm"/> using the Stylus library into valid CSS. Note: it does not compile code.</p>
<p>Plugin is available from <a class="ulink" href="https://github.com/seaneking/poststylus">https://github.com/seaneking/poststylus</a>.</p>
</td></tr></tbody></table></div><p>Although all of these plugins serve a different purpose, they all follow the same principle: they parse the code and transform it, before converting it to a format that can be saved to file as a valid style sheet output.</p><p>Leaving aside <a id="id699" class="indexterm"/>which parser we use, there is one question though: why would we want to manipulate our code directly? There are a few reasons for needing to alter the code directly; here are a few:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We may want to create a report that details facts and figures about our code for reference purposes; it is true that there will be plugins or scripts available to do this already, but PostCSS can get us the basics during compilation, and not as a separate process.</li><li class="listitem" style="list-style-type: disc">How about this for an idea? If you happen to use an application such as Adobe Color CC, then we can consider using the API to directly transform specific colors into valid RGB(A) or HEX equivalent values. We could use a plugin to achieve this, but performing this directly using the API allows us to retain flexibility with our choice of colors.</li><li class="listitem" style="list-style-type: disc">There is nothing stopping us from dissecting existing plugins, and rebasing the tasks they perform into something that we could add to a task runner file, and then adapt to our needs. We might ultimately consider creating a plugin, but if the steps required are very specific to our needs, then a plugin may not be a useful addition.</li><li class="listitem" style="list-style-type: disc">There are occasions when error handling can be lacking. The API contains some useful functionality that allows us to add suitably formatted messages on screen, if our process fails.</li></ul></div><p>These are just a few ideas to get started, in addition to manipulating existing non-PostCSS styles (such as those created using SASS, for example).</p><p>Enough talking, I <a id="id700" class="indexterm"/>feel a demo coming! We've met some of the plugins available, so it's time to put them to good use; two of particular interest are the <code class="literal">postcss-scss</code> and <code class="literal">postcss-safe-parser</code> plugins. Let's dive in and take a look at them in more detail, beginning with <code class="literal">postcss-safe-parser</code>.</p><div class="section" title="Parsing content and fixing errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec112"/>Parsing content and fixing errors</h2></div></div></div><p>Over the next<a id="id701" class="indexterm"/> few pages, we'll touch on using a couple of parser<a id="id702" class="indexterm"/> plugins, to show how easy it is to transform our code. We will take a look at a plugin that removes the need for SASS (at least at a basic level); before we do so, let's first explore using the<code class="literal"> postcss-safe-parser</code> plugin.</p><p>The <code class="literal">postcss-safe-parser</code>
<a id="id703" class="indexterm"/> plugin, available from <a class="ulink" href="https://github.com/postcss/postcss-safe-parser">https://github.com/postcss/postcss-safe-parser</a>, is perfect for finding and fixing CSS errors. It's a simple plugin to use and install; let's make a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by installing the plugin, so go ahead, and fire up a Node.js command prompt session, then change the working directory to the root of our project area.</li><li class="listitem">At the prompt, enter this command, then press <span class="emphasis"><em>Enter</em></span> to install the plugin:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-safe-parser --save-dev</strong></span>
</pre></div></li><li class="listitem">Next, go ahead and extract a copy of the <code class="literal">T58 – parsing invalid content</code> folder from the code download that accompanies this book; save it to the root of our project area.</li><li class="listitem">Copy the <code class="literal">package.json</code> and <code class="literal">gulpfile.js</code> files from it to the root of our project area.</li><li class="listitem">Switch back to the NodeJS command prompt session, then at the prompt, enter <code class="literal">gulp</code> and press <span class="emphasis"><em>Enter</em></span>.</li></ol></div><p>If all is well, we should see a successful compilation: a file marked <code class="literal">output.css</code> will be created at the root of our project area.</p><p>Go ahead and open it. Even though our example only contained one malformed selector, the file contains the same selector, but this time with the missing closing parenthesis added. We can also see the results appear in the console log at the same time as seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/BO5194_11_02.jpg" alt="Parsing content and fixing errors"/></div><p>So what's going<a id="id704" class="indexterm"/> on here? Well, some of this will be familiar. We're using a standard format task in our Gulp file, along with references to some <a id="id705" class="indexterm"/>of the plugins that we've already met, such as <code class="literal">autoprefixer</code>.</p><p>The content that is of interest to us though, is in the default Gulp task as seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/BO5194_11_03.jpg" alt="Parsing content and fixing errors"/></div><p>The task may seem a little complex, but in reality, we're parsing our CSS, prior to manipulating it. We start by defining a <code class="literal">postcss</code> object (into which feeds a request to run <code class="literal">autoprefixer</code>). This then processes our CSS into an AST, using a parser to find and fix any issues, before piping it out on screen and into a file named <code class="literal">output.css</code> in our project area.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>
<span class="strong"><strong>Abstract Syntax Trees</strong></span> (<span class="strong"><strong>AST</strong></span>) are a graphical tree representation of the syntactic structure of our<a id="id706" class="indexterm"/> CSS style sheets or code.</p></div></div><p>Okay, our example was very simplistic, but this was intended to show you how the principle works. In this next example, the same principle has been used to convert standard SCSS code to valid CSS; note, though, that we're not calling SASS (as we have done before), but converting the SCSS code to valid CSS styles.</p></div><div class="section" title="Parsing SCSS content"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec113"/>Parsing SCSS content</h2></div></div></div><p>In our previous <a id="id707" class="indexterm"/>demo, we explored the use of PostCSS to parse our CSS and added the missing closing bracket as a fix for our code. It was a simplistic example; perfect if you're working with standard CSS, but what if your projects are using SASS?</p><p>Well, as part of our next <a id="id708" class="indexterm"/>example, we'll prove that using a compiler is now old hat; we'll use the <code class="literal">postcss-scss</code> plugin (from <a class="ulink" href="https://github.com/postcss/postcss-scss">https://github.com/postcss/postcss-scss</a>) to directly transform our SASS code, before unwrapping the nesting<a id="id709" class="indexterm"/> styles using the <code class="literal">postcss-nested</code> plugin (available from <a class="ulink" href="https://github.com/postcss/postcss-nested">https://github.com/postcss/postcss-nested</a>):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by installing the <code class="literal">postcss-scss</code> plugin. Go ahead and fire up a NodeJS command prompt session, then change the working directory to the root of our project area.</li><li class="listitem">At the prompt, enter this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-scss --save-dev</strong></span>
</pre></div><p>Keep the session open when the plugin has completed installation:</p><div class="mediaobject"><img src="graphics/BO5194_11_04.jpg" alt="Parsing SCSS content"/></div></li><li class="listitem">From the downloaded code that accompanies this book, go ahead and extract a copy of the <code class="literal">package.json</code> file from the <code class="literal">T59 – Parsing SCSS content</code> folder. Save this to the root of our project area.</li><li class="listitem">From the same <code class="literal">T59 – Parsing SCSS</code> content folder, copy the contents of the <code class="literal">src</code> folder to the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">In a new file, add the following code and save it as <code class="literal">gulpfile.js</code> in the <code class="literal">src</code> folder at the root of our project area:<div class="informalexample"><pre class="programlisting">'use strict';
var gulp = require('gulp');
var postcss = require('postcss');
var fs = require('fs')
var autoprefixer = require('autoprefixer');
var nested = require('postcss-nested');

var scss = fs.readFileSync('src/styles.scss', 'utf-8');

gulp.task('default', function () {
  var syntax = require('postcss-scss');
  postcss([ autoprefixer, nested() ]).process(scss, { syntax: syntax }).then(function (result) {
    fs.writeFileSync('dest/styles.css', result.content);
  });
});</pre></div></li></ol></div><p>The keen-eyed <a id="id710" class="indexterm"/>amongst you will spot the reference to <code class="literal">postcss-nested</code>. We cannot call PostCSS without specifying something, so we'll use this plugin to unwrap the nested statements in our code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Revert back to the NodeJS command prompt session, then add this command and press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-nested --save-dev</strong></span>
</pre></div></li><li class="listitem">Once Node has completed installing the plugin, enter <code class="literal">gulp</code> at the prompt then press <span class="emphasis"><em>Enter</em></span>:<div class="mediaobject"><img src="graphics/BO5194_11_05.jpg" alt="Parsing SCSS content"/></div></li><li class="listitem">If all is well, we will see a compiled file appear in the <code class="literal">dest</code> folder:<div class="mediaobject"><img src="graphics/BO5194_11_06.jpg" alt="Parsing SCSS content"/></div></li></ol></div><p>But hold on a <a id="id711" class="indexterm"/>moment: this is a valid <span class="emphasis"><em>CSS</em></span> file, right? Absolutely. But…we've so far had to use a compiler to produce valid CSS code; how come we haven't needed to add one now?</p></div><div class="section" title="Exploring what happened"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec114"/>Exploring what happened</h2></div></div></div><p>Well, the answer<a id="id712" class="indexterm"/> lies in the conversion process—traditionally we would have had to compile our code, even though standard SASS files are a superset of current CSS. Instead, we've simply <span class="emphasis"><em>rewritten</em></span> our code using a syntax that translates a standard SCSS file to valid CSS.</p><p>If we take a look at our Gulp file in more detail, we can see references to the standard <code class="literal">gulp-postcss</code> plugin, along with declared instances of the <code class="literal">fs</code>, <code class="literal">autoprefixer</code>, <code class="literal">postcss-nested</code>, and <code class="literal">postcss-scss</code> plugins. The key for this demo starts on line 10, where we declare an instance of the <code class="literal">scss</code> variable, and <a id="id713" class="indexterm"/>use the <span class="strong"><strong>file system</strong></span> (<span class="strong"><strong>fs</strong></span>) plugin for Node to read the contents of the file into this variable.</p><p>Once into the task, we create an instance of PostCSS as an object, before feeding it the <code class="literal">autoprefixer</code> and <code class="literal">nested()</code> plugins (as variables). We then process our SASS code using the syntax that comes with the <code class="literal">postcss-scss</code> plugin, before piping out the contents as a file into the <code class="literal">dest</code> folder in our project area.</p><p>See? Nice and easy; not a SASS compiler in sight! This simple change removes the need for any dependency on a compiler, after all, SCSS files are just standard CSS text files, so why use a compiler? With all of this talk of parsing CSS (or SCSS for that matter), it's worth spending some time exploring what we mean by this, and how it is important to the whole process.</p></div></div>
<div class="section" title="Parsing CSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec93"/>Parsing CSS</h1></div></div></div><p>At the heart of <a id="id714" class="indexterm"/>writing any custom syntax is the ability to parse content—it doesn't matter whether this is CSS, JavaScript, or something else; we clearly need to understand what we're working with, before we can make changes! At a basic level, these are the steps we must take to transform our CSS when working with PostCSS:</p><div class="mediaobject"><img src="graphics/BO5194_11_07.jpg" alt="Parsing CSS"/></div><p>We begin with<a id="id715" class="indexterm"/> our source CSS (which comes with or without a source map), which we parse only once, but then put through any number of specified plugins (the example shows two, but we can easily use more). We then convert the output to a string using a stringifier; at this point, we can view the contents on screen or save them to disk.</p><p>Let's for a moment take <a id="id716" class="indexterm"/>a look at parsing some example code. For this next example, we will use a single CSS rule and parse it using the <code class="literal">postcss-value-parser</code> plugin (from <a class="ulink" href="https://github.com/TrySound/postcss-value-parser">https://github.com/TrySound/postcss-value-parser</a>); the reason for this will become clear shortly:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">From the code download that accompanies this book, extract and save copies of the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from the <code class="literal">T60 – parsing color values</code> folder to the root of our project area; if you want to save any existing files from there, then please do so first.</li><li class="listitem">Fire up a NodeJS command prompt session then change the working folder to the root of our project area.</li><li class="listitem">We need to install the <code class="literal">postcss-value-parser</code> plugin, so at the prompt, enter this command and press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-value-parser --save-dev </strong></span>
</pre></div><p>NPM will now install the plugin; keep the session open when it has finished:</p><div class="mediaobject"><img src="graphics/BO5194_11_08.jpg" alt="Parsing CSS"/></div></li><li class="listitem">At the <a id="id717" class="indexterm"/>prompt, type <code class="literal">gulp</code> then press <span class="emphasis"><em>Enter</em></span>; gulp will now go away and display the contents, which will look something like this:<div class="mediaobject"><img src="graphics/BO5194_11_09.jpg" alt="Parsing CSS"/></div></li></ol></div><p>Yikes! What does that all mean? Don't worry, it looks worse than it really is; this is an example of an AST, which we discussed earlier in this chapter. This gives us in-depth information on the contents of our CSS, such as the values, types of values, and where they appear in the tree.</p><p>The great thing, though, is that once we have all of this content, then we are free to query and manipulate the content at will. Once we have manipulated the content, we then need to convert it to string format, so it can be displayed on screen in a more intelligent format, or saved to disk.</p><p>For this demo, we <a id="id718" class="indexterm"/>used the <code class="literal">postcss-value-parser</code> plugin to create our AST; we can also try using the <code class="literal">postcss-safe-</code>
<code class="literal">parser</code> plugin (from <a class="ulink" href="https://github.com/postcss/postcss-safe-parser">https://github.com/postcss/postcss-safe-parser</a>), or the <code class="literal">postcss-selector-parser</code> plugin (from <a class="ulink" href="https://github.com/postcss/postcss-selector-parser">https://github.com/postcss/postcss-selector-parser</a>), to achieve <a id="id719" class="indexterm"/>similar effects.</p><p>And the reason why we only used one line of CSS code in our demo? Well, parsing CSS code can get very complex. The example shown in our demo is relatively straightforward; just imagine what it will be like with 2,000+ lines of code!</p><p>Let's develop<a id="id720" class="indexterm"/> this theme further, and use it to replace some example RGBA values with <a id="id721" class="indexterm"/>equivalent HEX-based colors. We can easily do this through the use of the <code class="literal">postc</code>
<code class="literal">ss-unrgba</code> plugin (from <a class="ulink" href="https://github.com/jonathantneal/postcss-unrgba">https://github.com/jonathantneal/postcss-unrgba</a>), but it weighs in at almost 60 lines; our Gulp file is 43 lines, and a lot of that is comments!</p><div class="section" title="Replacing RGBA colors"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec115"/>Replacing RGBA colors</h2></div></div></div><p>Our next example is <a id="id722" class="indexterm"/>a relatively straightforward search and replace; it is a perfect example of how it isn't always necessary to use plugins, and that we can parse our code directly to achieve the same effect. Let's make a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by extracting a copy of the <code class="literal">T61 – changing colors</code> folder from the downloaded code that accompanies this book; save the folder to the root of our project area.</li><li class="listitem">Copy the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from the <code class="literal">T61 – changing colors</code> folder to the root of our project area.</li><li class="listitem">Copy the <code class="literal">src</code> folder from the <code class="literal">T61 – changing colors</code> folder to the root of our project area.</li><li class="listitem">Next, fire up a NodeJS command prompt session then change the working folder to the root of our project area.</li><li class="listitem">We now need to install an <a id="id723" class="indexterm"/>additional plugin, <code class="literal">color-convert</code> (available from <a class="ulink" href="https://github.com/qix-/color-convert">https://github.com/qix-/color-convert</a>), which we will use to change the color once we've sucked out the details from within the AST. For this, go ahead and fire up a NodeJS command prompt, then change the working folder to the root of our project area.</li><li class="listitem">At the prompt, enter <code class="literal">npm install color-convert --save-dev</code> and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">When the plugin has finished installing, go ahead and enter <code class="literal">gulp</code>, then press <span class="emphasis"><em>Enter</em></span>. If all is well, we should see the, by now, familiar transformed style sheet appear in our destination folder:<div class="mediaobject"><img src="graphics/BO5194_11_10.jpg" alt="Replacing RGBA colors"/></div></li></ol></div><p>At this point, our<a id="id724" class="indexterm"/> style sheet has been transformed. If we preview the results in a text editor, we can confirm that HEX-equivalent values have indeed replaced the original RGBA colors, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/BO5194_11_11.jpg" alt="Replacing RGBA colors"/></div><p>Not convinced? Take<a id="id725" class="indexterm"/> a look at the same rule within the source file; here it shows the original RGBA value:</p><div class="mediaobject"><img src="graphics/BO5194_11_12.jpg" alt="Replacing RGBA colors"/></div><p>See how easy that was? There is one thing note; if we take a look at the Gulp file, it might at first glance look like we still have a few plugins in use. The key here is that three of these are part of Node (<code class="literal">fs</code>, <code class="literal">path</code>, and <code class="literal">util</code>), so we haven't had to install any new ones, over and above the <code class="literal">value-parser</code> and <code class="literal">color-convert</code> examples.</p></div><div class="section" title="Exploring how it all works"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec116"/>Exploring how it all works</h2></div></div></div><p>It's worth taking the time to<a id="id726" class="indexterm"/> consider this code in more detail. This contains some useful techniques that will help get you started on the road to creating custom syntaxes, starting with retrieving the values we need.</p><p>We begin with reading the contents of our style sheet file, before parsing it through the <code class="literal">postcss-value-parser</code> plugin. We walk through each node within the AST, ignoring any that contain a <code class="literal">node.type</code> of function or a <code class="literal">node.value</code> of <code class="literal">rgba</code>. For any that remain, we collect any that <a id="id727" class="indexterm"/>have a node type of word, before mapping them into a single array value which we convert to a number.</p><p>This is then transformed from a function node to a word node, before we finally convert the value from an RGBA to HEX color. The contents are converted to a string, and saved to disk in the destination folder, with the same file name.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note54"/>Note</h3><p>Node types represent the type of selector we're working with—examples include <code class="literal">root</code>, <code class="literal">string</code>, <code class="literal">tag</code>, and <code class="literal">attribute</code>. In our example, we've used <code class="literal">node.type</code> to display a string representation of the selector type, which we can manipulate in code.</p></div></div><p>Okay, let's move on: the key basis for working with custom syntaxes is to understand the content we need to work with; crack this and you are part of the way to transforming your styles into valid CSS. To help with the process, though, we will need to convert our content to a format that can be saved to disk. It's time to take a look at how, using the PostCSS API.</p></div></div>
<div class="section" title="Formatting the output with the API"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec94"/>Formatting the output with the API</h1></div></div></div><p>When parsing CSS, the<a id="id728" class="indexterm"/> output by default is going to resemble something as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/BO5194_11_13.jpg" alt="Formatting the output with the API"/></div><p>It looks a really ugly mess, but is in fact the standard format for an AST tree. The trouble is, it's not very helpful if we want to use details from it in our code! To get around this, we need to convert our content into a string format: the simplest method is to use the .<code class="literal">toString()</code> method, which is perfect for saving the content to disk.</p><p>All of the code for<a id="id729" class="indexterm"/> the next exercise is in the <code class="literal">T62 – adding a stringifier</code> folder in the code download that accompanies this book.</p><p>It's a cinch to use in our Gulp file; let's take a look as part of our next exercise:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by creating a new Gulp task file. In your usual text editor of choice, add the following code; there is a reasonable amount involved, so we will go through it in sections, beginning with the declarations for the plugins used:<div class="informalexample"><pre class="programlisting">'use strict';
var gulp = require('gulp');
var postcss = require('postcss');
var util = require('util');
var autoprefixer = require('autoprefixer');
var fs = require('fs');</pre></div></li><li class="listitem">We need to set up a few variables; these will be used to store values generated during the compilation process:<div class="informalexample"><pre class="programlisting">var newValue = 'white', result, selectors = [], root, decl;</pre></div></li><li class="listitem">Next up is the start of our task. The first step is to parse some simple CSS, as a basis for our demo. We then get the first child in our code, and save it to the <code class="literal">decl</code> variable:<div class="informalexample"><pre class="programlisting">gulp.task('default', function () {
  root = postcss.parse('a { color: black }');
  decl = root.first.first;</pre></div></li><li class="listitem">The first piece of information we want is a selector count; this next block will count through each selector using <code class="literal">root.walkRules</code>, and push the value into the <code class="literal">selectors</code> array:<div class="informalexample"><pre class="programlisting">  // get a selector count
  selectors = [];
  root.walkRules(function (rule) {
    selectors.push(rule.selector);
  });</pre></div></li><li class="listitem">At this point, we're ready to pipe out a summary report of our code—we use <code class="literal">console.log</code> to display a number of different values on screen:<div class="informalexample"><pre class="programlisting">  console.log("\nThe declaration type is: " + decl.type);
  console.log("The value of this declaration is: " + decl.toString());
  console.log("Number of nodes in this CSS: " + root.nodes.length);
  console.log("Selectors used in this CSS: " + selectors.toString());</pre></div></li><li class="listitem">We're almost<a id="id730" class="indexterm"/> there—in this next block, we do the PostCSS equivalent of a search and replace to update our color from black to white:<div class="informalexample"><pre class="programlisting">  // Replace color black with white
  root.walkDecls(function (decl) {
    if ( decl.value.match(/^black/) ) {
      decl.value = 'white';
    }
  });</pre></div></li><li class="listitem">We can display our content on screen, but a more useful step is to save it to disk—for this, we can use the <code class="literal">fs</code> plugin from Node.js to create our transformed CSS file and associated source map:<div class="informalexample"><pre class="programlisting">  // display content on screen and save to file
  result = root.toResult({ to: 'all.css', map: { inline: false } });
  console.log("Updated color value: " + decl.value.toString() + "\n");
  fs.writeFileSync('dest/styles.css', result.css);
  fs.writeFileSync('dest/styles.css.map', result.map);
});</pre></div></li><li class="listitem">Save the Gulp file to the root of our project area, then fire up a Node.js command prompt, and change the working directory to that of our project area.</li><li class="listitem">At the prompt, type in <code class="literal">gulp</code>, then press <span class="emphasis"><em>Enter</em></span> and let the compilation complete.<p>If all is well, we should see the results of step 6 appear on screen, like so:</p><div class="mediaobject"><img src="graphics/BO5194_11_14.jpg" alt="Formatting the output with the API"/></div><p>The transformed CSS file and source map will be present in the <code class="literal">dest</code> folder:</p><div class="mediaobject"><img src="graphics/BO5194_11_15.jpg" alt="Formatting the output with the API"/></div></li></ol></div><p>So, how does this <a id="id731" class="indexterm"/>all help us? Well, the ability to parse our code directly opens up some real possibilities; let's pause for a moment to explore what has happened in our demo, and how we can take advantage of this functionality in future projects.</p><div class="section" title="Dissecting our example code"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec117"/>Dissecting our example code</h2></div></div></div><p>Throughout the<a id="id732" class="indexterm"/> book, we've used a variety of plugins to transform our code. These will all make use of the PostCSS API in some form. However, we are not limited to simply using plugins; we can also transform our code directly using the API. At this point, it should be noted that we are not talking about creating a custom parser; indeed, this would easily form enough content for a short book in its own right!</p><p>A look through the Gulp file might be enough to put some people off. It is true that creating a custom syntax to parse code created using Stylus or less is not easy, and falls outside the scope of this book. However, we can make use of some of the API to query our content. In our example, there are two blocks of code that are of interest.</p><p>The first block <a id="id733" class="indexterm"/>parses each selector and keeps a running count. We can use the .<code class="literal">walkRules</code> method to iterate through each rule:</p><div class="mediaobject"><img src="graphics/BO5194_11_16.jpg" alt="Dissecting our example code"/></div><p>Once we have that raw information, we can then stringify it (or convert it to a string), before displaying the content on screen:</p><div class="mediaobject"><img src="graphics/BO5194_11_17.jpg" alt="Dissecting our example code"/></div><p>It's worth noting that the PostCSS API contains additional functionality to stringify our CSS and assemble it together. These are known as the Stringify and Builder commands; these are only meant for use when creating custom syntaxes. We've simply parsed our content using existing plugins designed for this purpose, so using <code class="literal">toString()</code> is sufficient for our needs.</p><p>Moving on—our example was kept<a id="id734" class="indexterm"/> deliberately simple to illustrate the process. We can easily add additional functionality. The API reference documentation at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/api.md">https://github.com/postcss/postcss/blob/master/docs/api.md</a> is a good place to start. How about adding error-checking, for example? We've already added one option from it, in the form of source maps; let's briefly cover this in more detail.</p></div><div class="section" title="Adding source maps"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec118"/>Adding source maps</h2></div></div></div><p>Throughout <a id="id735" class="indexterm"/>many of our demos, we've incorporated a task that creates a source map of our CSS styling. It's worked perfectly well so far, but it isn't the final answer—we can do better! To see what is possible, take another look at the last block of code in the Gulp task file used in the previous demo (which should be around lines 33 to 36):</p><div class="informalexample"><pre class="programlisting">// display content on screen and save to file
result = root.toResult({ to: 'all.css', map: { inline: false } });
...
fs.writeFileSync('dest/styles.css', result.css);
fs.writeFileSync('dest/styles.css.map', result.map);</pre></div><p>Here, we're creating a version of our transformed code that can be saved to file <code class="literal">{inline: false}</code> prevents the creation of a source map directly in our code. Instead, we use NodeJS' file system to create a source map based on <code class="literal">result.map</code>; this contains the content of our transformed code.</p><p>There are a few <a id="id736" class="indexterm"/>points to note when using this method; for more details, take a look at the main PostCSS site at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/source-maps.md">https://github.com/postcss/postcss/blob/master/docs/source-maps.md</a>.</p><p>Time to change <a id="id737" class="indexterm"/>tack: so far we've concentrated on writing our code, but what about presentation? It's not entirely necessary, but setting up highlighting has a twofold benefit: it makes it easier to edit our code, and we can also use it to provide a consistent theme when documenting our code electronically. After all, I'm sure you at least do the latter…don't you?</p></div></div>
<div class="section" title="Highlighting our syntax code"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec95"/>Highlighting our syntax code</h1></div></div></div><p>Throughout many of our demos, we've concentrated on using plugins, with minimal changes required to<a id="id738" class="indexterm"/> configure the code for use. There is nothing wrong with this, but as always, we can do better. How about installing support for highlighting?</p><p>This is an easy way to make it easier to read our code, indeed, we should have installed something like this a long time ago! That aside, it's easy enough to fix; support is available for a wide variety of editors. For the purposes of this chapter, I will assume you are using Sublime Text; this is an example of how it might look (the screenshot shows the Twilight Light theme in use):</p><div class="mediaobject"><img src="graphics/BO5194_11_18.jpg" alt="Highlighting our syntax code"/></div><p>Let's dive in and<a id="id739" class="indexterm"/> take a look at how to get this set up, using Sublime Text's package manager.</p><div class="section" title="Installing themes"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec119"/>Installing themes</h2></div></div></div><p>Adding theme<a id="id740" class="indexterm"/> support is a cinch when using an editor such as Sublime Text. Let's work through the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by opening a command prompt session. Go ahead and add this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>cd %APPDATA%\Sublime Text 3\Packages\User</strong></span>
</pre></div></li><li class="listitem">Next, enter this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>git clone git://github.com/chriskempson/base16-textmate.git Base16</strong></span>
</pre></div></li><li class="listitem">Open Sublime Text. If all is well, we should see a new menu entry if we click on <span class="strong"><strong>Preferences</strong></span> | <span class="strong"><strong>Color Scheme</strong></span> | <span class="strong"><strong>User</strong></span>:<div class="mediaobject"><img src="graphics/BO5194_11_19.jpg" alt="Installing themes"/></div></li></ol></div><p>An easy change to make, but a useful one; nevertheless, it's only part of what we can do! To really go to town (figuratively speaking), we can apply similar styling to our CSS styles. This makes<a id="id741" class="indexterm"/> it easier to read if we want to document our styles online. After all, color is clearly easier to read than black and white! Let's take a moment to explore what is required to apply a color theme to our documented code.</p></div><div class="section" title="Creating a HTML display theme"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec120"/>Creating a HTML display theme</h2></div></div></div><p>A part of developing <a id="id742" class="indexterm"/>code is the need to document it. This is not only for our sanity, but also for future changes, should someone else need to alter our code! Creating printed documentation is now old hat, a better method is to create it online, where we can easily update it without too much fuss. At the same time, we can add some color to it, to make it visually more appealing and provide a more consistent format to our efforts.</p><p>We could create this code<a id="id743" class="indexterm"/> manually, but that is a resource-heavy process that is prone to error! Instead, we can use the Midas library (available from <a class="ulink" href="http://midasjs.com">http://midasjs.com</a>) to automate the creation of the basis for our documentation, and we can style it using one of the base16 themes we covered in the previous exercise.</p><p>Let's make a start on installing that support:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by firing up a NodeJS command prompt, then changing the working folder to our project area.</li><li class="listitem">At the prompt, enter this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install midas --save-dev </strong></span>
</pre></div></li><li class="listitem">Once it has finished installing, go ahead and extract the <code class="literal">src</code> folder and the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from the <code class="literal">T63 – incorporating midas</code> folder, then save them to the root of our project area.</li><li class="listitem">Revert to the NodeJS command prompt, then enter <code class="literal">gulp</code> and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">Gulp will<a id="id744" class="indexterm"/> go away and compile a HTML-based extract of our code as <code class="literal">styles.html</code>, which has been properly formatted with extra markup. The file will appear in the <code class="literal">dest</code> folder within our project area.</li></ol></div><p>At this point, if we were to view the contents of that file, it will look very plain; this is easy to fix! To do this, we <a id="id745" class="indexterm"/>will use the Brewer theme by Timothée Poisot, available from <a class="ulink" href="https://github.com/chriskempson/base16-builder/blob/master/schemes/brewer.yml">https://github.com/chriskempson/base16-builder/blob/master/schemes/brewer.yml</a>; there are a few steps involved to make this happen:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Browse to <a class="ulink" href="https://github.com/ben-eb/midas/blob/master/templates/template-light.css">https://github.com/ben-eb/midas/blob/master/templates/template-light.css</a>, then save this as a CSS file <a id="id746" class="indexterm"/>within the <code class="literal">dest</code> folder of our project area.</li><li class="listitem">Open it in a text editor; it contains a series of placeholders for the base16 themes that are available for use. We would normally use Ruby to generate the CSS for one of these themes, but this isn't entirely necessary; instead, use your editor's search and replace to match up each placeholder with the appropriate color:<div class="mediaobject"><img src="graphics/BO5194_11_20.jpg" alt="Creating a HTML display theme"/></div><div class="mediaobject"><img src="graphics/BO5194_11_21.jpg" alt="Creating a HTML display theme"/></div></li><li class="listitem">Save the result; to make it work, we need to adjust the contents of the <code class="literal">styles.html</code> file to reference the new style sheet, so that it has the proper HTML structure. Once done, it will look something like this:<div class="mediaobject"><img src="graphics/BO5194_11_22.jpg" alt="Creating a HTML display theme"/></div></li></ol></div><p>This looks far more <a id="id747" class="indexterm"/>appealing, I think you'll agree! Although it requires some work to create the initial theme, this will be a one-off process for each theme that you create. Any changes made to the CSS rules or declarations can be generated automatically, and the HTML result updates accordingly.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec96"/>Summary</h1></div></div></div><p>We kicked off with a quick introduction to custom syntaxes, before preparing our environment for developing code. We then covered some of the plugins available for parsing content, before exploring some of the reasons as to why we might need to parse custom syntaxes or styles directly before implementing two as examples of how to manipulate our code.</p><p>We then dived in and explored how most PostCSS plugins perform changes to our code. We then explored some of the techniques required to alter styles directly, before considering the effects of our changes on the code itself.</p><p>Next up, we examined how content can be formatted for screen or to a state ready for saving to disk (including the creation of source maps). We noted that whilst there are some specific methods available, these are reserved for custom syntax development, and that the options we used would suffice for initial manipulation of our code.</p><p>We then rounded out the chapter with a look at how we can add highlighting support to our projects—we examined the reasons for adding this, such as making code editing easier, and covered a quick demo that uses the Midas library to create properly laid out documentation for our projects.</p><p>The use of different syntaxes is a great way to remove the need for rewriting existing code into valid CSS. There is one thing, though: what happens if we have a mix of both standard CSS and pre-processor code, such as from less or Stylus? Can we work with both at the same time? Absolutely! We will take a look at the Pleeease library, which supports this, in the next chapter.</p></div></body></html>