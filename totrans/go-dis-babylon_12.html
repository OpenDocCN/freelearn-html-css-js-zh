<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer129">
<h1 class="chapter-number" id="_idParaDest-245"><a id="_idTextAnchor248"/>12</h1>
<h1 id="_idParaDest-246"><a id="_idTextAnchor249"/>Measuring and Optimizing Performance</h1>
<p>In software engineering circles, it’s common to hear the expression “premature optimization is the root of all evil.” This is usually bestowed very knowingly from a more Senior developer to a more Junior one. Stroking of the chin – whether a beard is present or not – is almost always required to attain the Solemn Air of Pronouncement accompanying such declarations. Strange delivery or not, it is good advice to follow. </p>
<p>There aren’t many worse ways to approach software design than by starting to make performance-related changes while that software is still largely being built. That, in turn, is because the optimization of a code base is inversely related to the code’s readability, its maintainability, and ultimately the facility to which new features and changes can be introduced. To put it another way, the more optimized a code base tends to be, the harder it is for someone to understand the code and subsequently make changes to that code.</p>
<p>At this point in our journey, we have established a full end-to-end application experience. Though there may still be some rough edges, all the major features have been implemented in the application, making this an ideal time to examine our application’s performance. At the same time, though, we don’t have much insight into how <em class="italic">Space-Truckers</em> performs at really any other level than the bare basics. Our first task is clear: we must capture a baseline performance profile, or rather one profile each for both the Route Planning and Driving phases.</p>
<p>The Babylon.js <strong class="bold">Real-time performance viewer</strong> can <a id="_idIndexMarker935"/>record real-time performance statistics across a wide range of metrics relevant to a Babylon.js Scene. With these tools in hand, we’ll be able to identify “hotspots” in the Space-Truckers code base that we can then target for selective performance enhancements, but that doesn’t tell us anything about how we can improve the performance or what to look for in our tooling. Not yet at least!</p>
<p>Something we haven’t discussed so far has been how the very breadth and reach of a web application also means a greater number of different potential hardware and software configurations that must then be supported by you, the developer. How do we avoid having to go down the rabbit hole of testing, verifying, and fixing functionality for every combination of device, software, and display? By knowing what areas or scenarios in a Scene put the most stress on which part of the system, we can defer the optimization from design time to runtime and handle it in real time. The Babylon.js <strong class="bold">Scene Optimizer</strong> is the<a id="_idIndexMarker936"/> ideal solution to dynamically balance performance and render quality with its ability to turn on and off different performance optimizations based on the <a id="_idIndexMarker937"/>difference between a target and the current frame rates, or <strong class="bold">frames per second</strong> (<strong class="bold">FPS</strong>).</p>
<p>Aside from the runtime <strong class="bold">Scene Optimizer</strong>, there are other things we can do to improve an application’s performance in Babylon.js. We’ll continue to use and re-measure the impact of any changes we make, first individually, then all together, because how can you know if any improvement has been made if you don’t have something for comparison? The rhetorical answer is that you can’t – not unless you are consistent in your measurement procedure and capturing measurements, but as the fastidious and methodical creator of Software That Does Magic™, you’ve already got that part down!</p>
<p class="callout-heading">Important note</p>
<p class="callout">Levity aside, something that will help enforce and facilitate this kind of development work greatly is to leverage the mighty power of Git. Any time you save a change to a source code file, consider at least staging that change, if not committing it. Revert commits that don’t work instead of plowing ahead. In other words, by working with, not against, Source Control, you might be amazed at how fast you can get things done!</p>
<p>Our last port of call for this, the penultimate stage of our Babylon.js long-haul, will be looking at the network performance of our app. Specifically, we’ll see how our asset and data resources affect both loading time and bandwidth usage. Today’s web browsers almost all support both robust caching functionality, as well as local storage mechanisms such<a id="_idIndexMarker938"/> as <strong class="bold">IndexedDb</strong>, which is a mini SQL server made available by the browser to scripts running inside it. Why is this relevant? </p>
<p class="callout-heading">Note</p>
<p class="callout">In case you missed it, rhetorical questions are back in style! </p>
<p>The relevance of <strong class="bold">IndexedDB</strong> is that we can use it to stuff all our assets – textures, sounds, JSON, and more. Instead of having to download everything from the server, we store resources locally on the browser. It’s a great place to cache assets. This positions us well for<a id="_idIndexMarker939"/> the next chapter’s look at making Space-Truckers into an installable publishable <strong class="bold">Progressive Web Application</strong> (<strong class="bold">PWA</strong>). But first things first, let’s go over the topics covered in this chapter and some technical requirements and recommendations. </p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Knowing What To Measure</li>
<li>Measuring Performance and Identifying Bottlenecks</li>
<li>Improving Runtime Performance with the Scene Optimizer</li>
</ul>
<h1 id="_idParaDest-247"><a id="_idTextAnchor250"/>Technical Requirements</h1>
<p>Most of the requirements in this chapter are the same as they have been for the previous chapters, but some new tools can be incredibly useful for performance measurement and improvement. Here are the tools that are new and/or specific to this chapter:</p>
<ul>
<li>This is not a requirement, but it is very helpful to have multiple displays available while working on performance captures. Accurate and consistent measurements can be tough enough – don’t add more variables into the mix if you can help it!</li>
<li>The Scene Optimizer: <a href="https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer">https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer</a></li>
<li>Optimizing with Octrees: <a href="https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees">https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees</a></li>
<li>BVH article/information link</li>
</ul>
<h1 id="_idParaDest-248"><a id="_idTextAnchor251"/>Knowing What To Measure</h1>
<p>Quantum Mechanics has a concept called <a id="_idIndexMarker940"/>the <strong class="bold">Uncertainty Principle</strong>. Named after physicist Werner Heisenberg, the principle can be summarized for our purposes as the act of measuring some quantity itself affecting the observed value of that quantity. Although merely an analogy for us currently bound to non-quantum systems, it serves as a useful warning as we take our measures and metrics: don’t let the instrumentation impact the measurements that are being taken for our app’s performance.</p>
<p>Starting with some general guidelines, we’ll look at some key factors that need to be attended to and accounted for to gather meaningful test data. Using those guidelines to establish a basic context, we’ll start learning some key terminology that will allow us to get into more specifics in future sections of this chapter.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor252"/>General Guidelines</h2>
<p>As we review<a id="_idIndexMarker941"/> and examine the various means and procedures for taking our performance profile, we’ll go over the tooling-specific steps as they come up. But first, let’s look at a few guidelines that generally apply.</p>
<h3>Keep External Factors To a Minimum</h3>
<p>Computers are quite good at sharing slices of computing time between processes, but we’re better off closing all our other browser windows and shutting down any other non-essential programs that may compete with ours for resources. No, it’s not as “real world” as might be expected, but the goal here is to gather clean, consistent data, and that doesn’t have to stick to the “real world” rules. Rebel.</p>
<h3>Choose a Target Resolution and Stick To It</h3>
<p>This is a bit trickier than it might seem. Simply going with the highest resolution possible and putting on the highest pixel-dense display is certainly a good way to stress-test a graphical application, but it won’t yield a very useful performance profile. Too low of a resolution and the GPU won’t break a sweat, also not yielding a very useful profile. Going for a Veruca Salt-meets-goldilocks approach, select a value somewhere in the upper-middle range that avoids “redlining” either CPU or GPU but still makes those components work for their electrons!</p>
<h3>Compare Apples to Apples</h3>
<p>Always make sure your comparisons are equivalent, all other things considered. Follow the same testing procedure – resist the urge to “improve” or take shortcuts – and collect data in the same fashion between test runs. If methodologies differ, then there’s a good possibility that your results won’t tell you what you think they say.</p>
<h3>Change Only One Thing Between Measurements</h3>
<p>One of the less helpful things you might do to yourself is put off re-measuring after making one set of changes. For example, say you refactor one method, then make another set of changes somewhere else in the application. Repeat this a few times, and you’ve now lost the ability to definitively say whether your change has improved anything – regardless of whether the app performs better or worse! This is also a poor situation to be in because you’re also restrained in the changes you can safely make in the future without risking regression in the code you’re trying to change. Avoid getting into this in the first place by committing each cohesive set of changes together, and by re-measuring after each major change to validate your assumptions about how the code behaves.</p>
<p>The preceding guidelines aren’t rules set in stone – they’re pieces of advice aimed at helping you proactively avoid arriving at false conclusions and the resulting consequences. This<a id="_idIndexMarker942"/> is surely helpful, but not directly so. To help connect this advice to a useful context, we’ll first look at what sorts of metrics are important. Then, we’ll look at the tools that collect this data. Finally, we’ll apply what we’ve learned to find and fix performance bottlenecks and resource pressures that lurk in the Space-Truckers code base.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor253"/>Performance-Related Terminology</h2>
<p>“<em class="italic">I Wanna Go Fast!</em>”</p>
<p>Yes, Ricky Bobby, so<a id="_idIndexMarker943"/> do we all. When referring to cars or racing, the meaning of the phrase is clear, but what does “[going] Fast!” mean for a 3D application? Sure, it cannot be a good thing for a laptop to suddenly take off in a cloud of burning plastic at 200 kph! At least, not a laptop without wheels. Brakes too – those are also important.</p>
<p>The equivalent measure <a id="_idIndexMarker944"/>for 3D applications and games is, of course, the Frame Rate, or <strong class="bold">Frames Per Second</strong> (<strong class="bold">FPS</strong>). </p>
<p class="callout-heading">Note</p>
<p class="callout">Positioned unfortunately close in proximity<a id="_idIndexMarker945"/> to a <strong class="bold">First-Person Shooter</strong> (<strong class="bold">FPS</strong>), noting that the two are not directly related is yet another reminder that context is important.</p>
<p>Similar to how a speed limit posted on a highway serves to limit (in theory, at least) the top speed of drivers on the road, the number of frames that can be rendered every second is limited at the end by an intrinsic maximum that matches the refresh rate of the display device or monitor doing the rendering. In the Old Days, this was limited by the speed at which the electron<a id="_idIndexMarker946"/> gun of a <strong class="bold">Cathode Ray Tube</strong> (<strong class="bold">CRT</strong>) display could traverse the width and height of the screen. Barbarian times, they were. In today’s era of more Enlightened Display Technologies, <strong class="bold">Light Emitting Diode</strong> (<strong class="bold">LED</strong>) displays <a id="_idIndexMarker947"/>can switch on or off with incredible speed. Here are some typical FPS values and examples that you may <a id="_idIndexMarker948"/>recognize from the real world:</p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<img alt="" height="615" src="image/Table_12.01_B17266.jpg" width="1561"/>
</div>
</div>
<p>FPS is a convenient metric because it is almost completely unambiguous – higher values are almost always better. The only real exception to this is in scenarios where power consumption is a higher priority than maintaining a high frame rate. Because that deals with actions taken at runtime, we’re going to look at how to approach a scenario like that later in this chapter in the <em class="italic">Improving Runtime Performance with the Scene Optimizer</em> section. The ugly downside of a higher FPS is that there’s less time to get all the needed inter-frame processing that goes on, whether inside the GPU or in the CPU.</p>
<p>This <strong class="bold">Frame Budget</strong>, depicted<a id="_idIndexMarker949"/> in the second-to-left-most column in the previous table, dictates what can happen during the inter-frame time. Go over the budget and the frame rate drops. Go too much under budget and time is being wasted that could be rendering additional frames or running other processing tasks. Performance management can be approached by either reducing the CPU Frame Time or by reducing the GPU Frame Time. Sometimes, there’s crossover between the two – a good example of this is the Thin Instances used for the Route Planning phases’ asteroid belt (see the <em class="italic">A Detour into Particle Systems</em> section of <a href="B17266_07_Final_AM.xhtml#_idTextAnchor142"><em class="italic">Chapter 7</em></a>, <em class="italic">Processing Route Data</em>, for more).</p>
<p>Every frame, the <a id="_idIndexMarker950"/>asteroid’s rotation and position matrices are updated by code running on the CPU, which is then copied over into the GPU. These matrixes are then passed into the vertex and fragment shaders, which apply them during a single Draw call to every instance in the Scene. While this is an extremely fast process, there is one potential bottleneck on the CPU, and that’s the loop over each Thin Instance that recalculates the two matrices. Any improvements there would theoretically improve either the performance or the maximum number of asteroids that can be rendered without severe performance degradation.</p>
<p>Shifting over to the GPU, bottlenecks can occur when the device is tasked with too many (or fewer, slower) shader programs competing for the same limited frame budget. The raw number of shader executions is expressed as the number of <strong class="bold">Draw</strong> calls made in each second and serves as a complement to the GPU intra-frame time spent executing shaders. As each Draw call is associated with a single material (some materials will make multiple calls to Draw), the number of different materials in a Scene is directly related to the number of times the GPU is being asked to switch contexts to run that material’s shader programs every second. </p>
<p>Switching the GPU between contexts (shaders) has been brutally optimized in hardware, but it isn’t completely free. Each shift carries a small amount of overhead, and though trivial individually, this can add up to substantial losses with large numbers. Thus, reducing the number of draw calls can improve performance directly from the reduced context switches and indirectly through the shader code that is no longer being invoked.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The fastest code is code that doesn’t exist. Think about that.</p>
<p>There are a few other metrics that are worth defining but are most obvious from their name or context. One exception, though, is Absolute FPS. Absolute FPS is the number of frames that can be processed each second, not counting any actual render timings. This is a measure of how well the CPU side of things is performing through its update loop.</p>
<p>As with most of <a id="_idIndexMarker951"/>the content in this book, the preceding terms aren’t a comprehensive survey of the 3D performance programming landscape, but as a primer for what comes next, it is as comprehensive as needed. A comfortably high frame rate – one at or above 60 FPS – carries a frame budget of around 16 milliseconds, during which all processing needed to process a simulation and prepare it for the next frame must be completed. GPUs are screamingly fast at doing this type of thing, but just as an overburdened CPU can spin and churn trying to service too many competing processes, so can a GPU become overburdened by shader programs. </p>
<p>To help us understand what all of that talk about CPUs, GPUs, burdens, and everything else that plays out in an actual scenario, we need to learn about how and what to measure. Simply measuring things is rarely enough. Like chemistry students planning their lab procedures out in their notebooks, we’ll need to learn how to plan our testing strategies, as well as how to interpret the results. In the next section, we’re going to take on the tasks of planning out, executing, and interpreting a performance test, but not before we <a id="_idIndexMarker952"/>learn more about the tools that will help accomplish those tasks for us.</p>
<h1 id="_idParaDest-251"><a id="_idTextAnchor254"/>Measuring Performance and Identifying Bottlenecks</h1>
<p>Effective problem-solving<a id="_idIndexMarker953"/> starts by clearly defining the<a id="_idIndexMarker954"/> problem that needs to be solved. Sometimes, this is less than obvious, or sometimes, there’s more than one problem that appears to be front and center. Oftentimes, the thing that makes defining a problem difficult is that it is presented as a qualitative statement, like this one: “The Route Planning Screen doesn’t perform well.”</p>
<p>A statement such as that one is unambiguIus in one sense – there’s no doubt as to its meaning – but it is completely opaque in another, for we have no understanding to what degree the performance is poor. That’s the basic difference between having qualitative data and having specific, qualitative measures. Without the former, there’s no understanding of the overall picture, and without the latter, there’s no way to know whether any actions have been resolved, mitigated, or even made worse. So, gathering quantitative data on how the Route Planning screen performs is the first step we need to take so that we can better define our conditions for victory, as it were. </p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor255"/>Inspecting the Performance of Route Planning</h2>
<p>The Babylon.js<a id="_idIndexMarker955"/> Inspector <a id="_idIndexMarker956"/>is a Swiss-army knife of<a id="_idIndexMarker957"/> useful goodness. If you’re as-yet-unfamiliar with the Inspector, now wouldn’t be a bad time to check out the docs at <a href="https://doc.babylonjs.com/toolsAndResources/tools/inspector">https://doc.babylonjs.com/toolsAndResources/tools/inspector</a>, as well as take another refresher through <a href="B17266_02_Final_AM.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Ramping up On Babylon.js</em>, to set you straight. The Inspector has long had a <strong class="bold">Performance</strong> tab that displays all manner of statistics regarding the currently running Scene, but until the Babylon.js v5.0 release, there wasn’t an easy way to capture and analyze those metrics as they progress over time. The <strong class="bold">Performance Profiler</strong> is an <a id="_idIndexMarker958"/>extensible tool that has two similar concepts but different practice modes: headless and real time. </p>
<p class="callout-heading">Important note</p>
<p class="callout">In case you don’t recall, the keyboard shortcut for bringing up the Inspector when running Space-Truckers is <em class="italic">Shift</em> + <em class="italic">Alt</em> + <em class="italic">I</em>. </p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor256"/>Real-Time Performance Viewer Metrics</h2>
<p>When running in <a id="_idIndexMarker959"/>Real Time mode, a live graph is <a id="_idIndexMarker960"/>rendered showing the selected metrics from a list of the available metrics. Headless mode, in contrast, displays nothing but captures data that can later be exported to CSV format for further analysis. All three of these options (Start/Stop, Real Time, Headless, and Import/Export to CSV) are covered in more detail in the BJS docs at <a href="https://doc.babylonjs.com/toolsAndResources/tools/performanceProfiler">https://doc.babylonjs.com/toolsAndResources/tools/performanceProfiler</a>. The following table lists the out-of-the-box metrics collected by the Performance Profiler, along with a basic explanation of these metrics:</p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<img alt="" height="1096" src="image/Table_12.02_B17266.jpg" width="1628"/>
</div>
</div>
<p>The specific<a id="_idIndexMarker961"/> values for each of the preceding metrics will <a id="_idIndexMarker962"/>depend on the hardware and software environment, so specific target values aren’t very useful. The different property groupings of metrics tend to reflect the dimension or unit that values assume. The top section focuses on counted metrics – things such as the number of meshes, vertices, textures, and more. After that, there are timing metrics, which show the amount of time that specific parts of the scene are consuming during and in-between frames. It’s<a id="_idIndexMarker963"/> this base set of metrics that the Performance Profiler captures and displays in a visual graph. Let’s move on and look at what a procedure looks like for our profiling.</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor257"/>Defining the Testing Procedure</h2>
<p>Following the<a id="_idIndexMarker964"/> guidelines laid out previously in this chapter, we <a id="_idIndexMarker965"/>need to define a repeatable procedure for profiling the application. There’s no need to over-complicate this, so let’s do the Simplest Thing That Could Possibly Work. We want to refresh the web page for the application to reset and clear memory and such, and then we want to let the application settle for a bit and find its groove before we launch some cargo and take some more measurements. The last part is to save our performance profile to a CSV file for posterity before loading it into the Performance Viewer for basic analysis.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Unless there’s a specific reason to not do it, always evaluate performance and capture metrics against code built in Production environment mode!</p>
<p>Here’s what our testing procedure looks like. Remember, we want to repeat this same series of steps every time we make a significant change to the code so that we can understand the impact of that change:</p>
<ol>
<li>Refresh the browser, launch the game, and navigate to route planning</li>
<li>Allow game to stabilize for 10s</li>
<li>Begin capture</li>
<li>Allow 10 seconds to stabilize and establish a baseline</li>
<li>Launch cargo unit into an empty space</li>
<li>Collect data for 10 seconds</li>
<li>Stop capture and export to CSV</li>
</ol>
<p>A more thorough testing procedure would also want to include camera panning and zooming, but this procedure will serve our purposes adequately. At this point in this book, <em class="italic">Step 1</em> shouldn’t need further elaboration. <em class="italic">Step 2</em> is also straightforward and to the point. It is <em class="italic">Step 3</em> where we need to pause to get into the details of what the step entails.</p>
<p>Before we start capturing our profile, we need to launch the BJS Inspector by pressing the <em class="italic">Shift</em> + <em class="italic">Alt</em> + <em class="italic">I</em> key combination. The <strong class="bold">Statistics</strong> tab in the right-hand pane contains our target information, but first, detach the <strong class="bold">Inspector</strong> panes from the browser window (you can close the Scene Explorer instead if desired) so that they do not take up or cover up any part of the app window. If you’re using multiple monitors, it can be convenient to dedicate one monitor to the browser window, but it’s not required. Just remember the Guideline About Using the Same Screen Size and Resolution! When you’re ready, press the <strong class="bold">Begin Recording</strong> button <a id="_idIndexMarker966"/>circled in the following <a id="_idIndexMarker967"/>screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<img alt="Figure 12.1 – The Statistics tab of the Inspector contains controls for starting, stopping, exporting, and viewing Performance Profile data&#13;&#10;" height="464" src="image/Figure_12.01_B17266.jpg" width="460"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The Statistics tab of the Inspector contains controls for starting, stopping, exporting, and viewing Performance Profile data</p>
<p>By clicking the <strong class="bold">Begin Recording</strong> button, we can initiate a performance profile in Headless mode. This gives us better accuracy because, in a nod to Dr. Heisenberg, our measurements won’t be affecting the application’s execution to as much of a degree.</p>
<p><em class="italic">Step 4</em> involves the difficult task of waiting – without touching anything – for 10 seconds to allow stabilization to occur in the application. These first 10 seconds also help establish a runtime baseline profile that we can use to compare different actions taken during a test. When the allotted time has passed, <em class="italic">Step 5</em> is to point the launcher toward an empty patch of space and fire away – we want to capture the behavior of the game during flight. After letting the Cargo Unit cruise for another 10 seconds, <em class="italic">Step 6</em> has been completed, and thus <em class="italic">Step 7</em> comes, where we click the <strong class="bold">Stop Recording</strong> button, followed by the <strong class="bold">Export Perf to CSV</strong> button, to download it. Now that we’ve finished <a id="_idIndexMarker968"/>capturing <a id="_idIndexMarker969"/>our profile, it’s time to examine it.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor258"/>Viewing and Analyzing a Captured Profile</h2>
<p>The fastest <a id="_idIndexMarker970"/>way <a id="_idIndexMarker971"/>to view a <a id="_idIndexMarker972"/>performance <a id="_idIndexMarker973"/>profile is to choose <strong class="bold">Load Perf Viewer</strong> using the <strong class="bold">CSV</strong> button, then select the freshly downloaded CSV file previously captured to launch the Perf Viewer.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Depending on whether you’re doing this locally or against a deployed environment, your browser’s pop-up blocker may engage and prevent the <strong class="bold">Realtime Performance Viewer</strong> window from showing. Make sure you disable or add exceptions to your blocker rules to allow the window to appear!</p>
<p>Your first impression of the performance graph might be that someone spilled a box of colored spaghetti or perhaps Pick-up-Stix and now it’s going to need to be cleaned up. That’s because all metrics are selected for display at the time of load. Click the master toggles on the group headers to disable all the Count items, leaving FPS. Selectively remove items that have very small values – if something is taking less than a millisecond to complete, there are better things to worry about! The graph is a lot easier to comprehend now! Zoom in and out with the mouse wheel, while panning across the timeline by dragging.</p>
<p>This will<a id="_idIndexMarker974"/> transition us from looking at a larger overall<a id="_idIndexMarker975"/> picture to a progressively more granular view of things, where there are a few things of interest to note.</p>
<h3>Initial Assessments</h3>
<p>Notice how the<a id="_idIndexMarker976"/> Inter-frame time seems to correlate inversely with FPS? That is, if you look carefully at the two data series, you’ll see how the FPS drops dramatically any time there is a similar shift in the opposite direction by the Inter-frame time. Something else obvious to see in this format is the statement that whenever it takes more time between frames, there are fewer frames as a result. </p>
<p>If we add the GPU frame time to this graph, a more nuanced picture starts to emerge. Although there are exceptions and outliers, in most of the areas where Inter-frame time increases (followed immediately by a drop in FPS), there is a corresponding <em class="italic">decrease</em> in GPU frame time:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<img alt="Figure 12.2 – A snapshot of a portion of a performance profile&#13;&#10;" height="892" src="image/Figure_12.02_B17266.jpg" width="1130"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – A snapshot of a portion of a performance profile</p>
<p>In the preceding figure, the darker line at the top initially is the FPS, while the bottom-most line is the Inter-frame time. In the middle is the GPU frame time.</p>
<p>If the GPU frame time is improving, why is the FPS dropping? Without knowledge of the Space-Truckers application and how it’s put together, it might take an expert a bit of time to puzzle out the source of this strange connection, but seasoned coders of the Space-Highways<a id="_idIndexMarker977"/> followers of this book will likely already know exactly what this means and what’s causing it.</p>
<h3>Integrating External Knowledge</h3>
<p>Even though <a id="_idIndexMarker978"/>the CPU and the GPU operate pretty much independently from each other, events or conditions affecting one can still indirectly affect the other. In the case of our <strong class="bold">Route Planning Screen</strong>, we <a id="_idIndexMarker979"/>can infer that the GPU frame time drops because it is waiting to be told what to do by the CPU. Therefore, it is the increase in the Inter-frame time that is the proximate cause of both the FPS drop and the GPU frame time decrease. </p>
<p>Reach back into your memories of <a href="B17266_06_Final_AM.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Game Mechanics</em>, and recall how we went about implementing the asteroid belt in the <em class="italic">Building the Asteroid Belt</em> section. The belt is comprised of many hundreds of individual rock meshes that have been procedurally generated as a <a id="_idIndexMarker980"/>set of <strong class="bold">Thin Instances</strong>. Note that as we discussed in <a href="B17266_07_Final_AM.xhtml#_idTextAnchor142"><em class="italic">Chapter 7</em></a>, <em class="italic">Processing Route Data</em>, Thin Instances are blazing fast because they run on the GPU.</p>
<p>Checking the Particle frame steps timing tends to support that assertion as the amount of time the CPU spends managing particles is small enough that it is unlikely to account for the two distinctly different systems in use in the Scene (the Sun Particle System is also a GPU-based <strong class="bold">ParticleSystem</strong>, with <a id="_idIndexMarker981"/>the asteroid <strong class="bold">Thin Instances</strong> being the other). Why, then, focus on the asteroid belt as the source of our high Inter-frame bottleneck? This is because our Thin Instances are not statically held in place – they individually rotate. To accomplish this rotation, we implemented a scheme wherein we stored a set of rotation, position, and scaling data locally on the CPU. Every frame, we looped through the set of asteroids and adjusted the rotation values for each asteroid, updating their matrices before signaling to the GPU that it should refresh the <strong class="bold">Thin Instance Buffer</strong> to<a id="_idIndexMarker982"/> update the objects on screen:</p>
<pre class="source-code">&#13;
Ior (lIt i = 0; i &lt; this.numAsteroids; ++i) {&#13;
    this.rotations[i].x += Math.random() * 0.01;&#13;
    this.rotations[i].y += Math.random() * 0.02;&#13;
    this.rotations[i].z += Math.random() * 0.01;&#13;
}&#13;
this.updateMatrices();&#13;
this.mesh.thinInstanceBuf"erUpda"ed("matrix");</pre>
<p><strong class="source-inline">gameData</strong> for the Route Planning screen contains an <strong class="source-inline">asteroidBeltOptions</strong> configuration object, which, in turn, contains the number property that controls the number of asteroids (<strong class="bold">Thin Instances</strong>) to create and manage. Next, it’s time to test our hypothesis by<a id="_idIndexMarker983"/> running an experiment.</p>
<h3>Validating Assumptions</h3>
<p>Change the<a id="_idIndexMarker984"/> number of asteroids to about 75% percent of its current value, then re-run the performance profile. It should be immediately apparent that the Inter-frame time improves, along with the overall FPS. As we are hoping to see, the GPU frame time either stays constant or trends upwards, supporting our conjecture about the GPU waiting for work from an over-taxed CPU. </p>
<p>If you wish to be extra thorough (and you should if you’re still learning!), change the asteroid count again, but this time in the opposite direction, re-doing the test afterward. The results, once again, should support our proposed explanation that the number of asteroids is inversely correlated to the FPS, and the degree to which it correlates should be consistent between runs as well, showing both quantitative and qualitative sides of the story.</p>
<p>Be sure to revert the change to the asteroid count since this is a situation where one size doesn’t fit all – different CPUs will be able to support a varying number of asteroids without tanking performance. We need to be able to dynamically change the asteroid count at runtime based on how well the app is performing. Once again Babylon.js has the perfect tool for the job – the Scene <a id="_idIndexMarker985"/>Optimizer. The <strong class="bold">Babylon.js Inspector</strong> is the launching pad for engaging in performance analysis and improvement. The <strong class="bold">Statistics</strong> tab contains a whole set of aggregated Counts – textures, meshes, and more – and timings, such as GPU time and FPS. Supplementing that, the metric display is the new Real-time Performance Viewer, which uses the same metrics to draw a time-evolving graph of performance. It can run in Real-Time and Headless mode, but Headless will have the least impact on performance. </p>
<p>Capturing and exporting performance data to CSV can be done with a click of the button but having a testing procedure in place is just as crucial as the data collected (if not more!). After defining our procedure, we saw how to execute it to capture a performance profile. Upon analysis of the profile, a trend appeared to emerge that indicated there might be a bottleneck in the CPU due to the number of asteroid Thin Instances involved in the Scene. Because it’s so easy to capture profiles – changing the number of asteroids and re-running the test doesn’t take long, and the results appear to confirm our assertion of connecting the number of asteroids to the overall frame rate.</p>
<p>Improving this situation isn’t as simple as just lowering the number of asteroids, though. Because this is so heavily bound to the CPU’s ability to chug through the various matrix calculations, different CPUs are going to have different responses to the same variables. A dynamically set number of asteroids, matching the number the CPU can handle, would be the perfect <a id="_idIndexMarker986"/>solution. In the next section, we’ll learn all about how to use the Scene Optimizer in both its vanilla, out-of-the-box configuration and with a custom stratagem.</p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor259"/>Improving Runtime Performance with the Scene Optimizer</h1>
<p>Developing<a id="_idIndexMarker987"/> games for a given platform<a id="_idIndexMarker988"/> comes with its own set of unique challenges and benefits. Console games have the benefit of having standard hardware specifications and drivers to target, but at the expense of those same hardware specifications creating severe limitations in other areas, such as RAM<a id="_idIndexMarker989"/> or <strong class="bold">video RAM</strong> (<strong class="bold">vRAM</strong>). Browser-based games have their own bag of double-edged swords too – the ubiquitous nature of JavaScript and the web brings similar problems to console developers with restricted hardware specs, and some of the same problems that PC developers must face with a wide variety of hardware combinations.</p>
<p>Using the tools and lessons from this chapter and the preceding chapters of this book, it’s easy to imagine writing some code – a coroutine perhaps – that monitors the real-time performance of the application and makes tweaks to various settings in response to bring frame rates up to target. However, it is easy to imagine and probably easy to prototype or create a proof-of-concept that works in a few limited situations. The devil is always in the details though, and considerable time and effort would have to be expended that could otherwise be put to other uses. </p>
<p>Fortunately, and hopefully getting somewhat repetitive to hear at this point, is that Babylon.js has got you covered with <strong class="bold">SceneOptimizer</strong> (<a href="https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer">https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer</a>). Every time the specified sampling interval passes (by default, every 2,000 ms), <strong class="bold">SceneOptimizer</strong> checks the current frame rate, and if it isn’t close to or at the target, the next optimization in the queue is applied. If the optimization is capable of further action, it remains in the queue until it reports it can’t help any longer. </p>
<p>Through the <strong class="source-inline">SceneOptimizerOptions</strong> object, <strong class="bold">SceneOptimizer</strong> works from a queue of strategies that each offer a different type of performance optimization, allowing<a id="_idIndexMarker990"/> for <a id="_idIndexMarker991"/>graceful degradation of scene quality while maintaining a stable frame rate.</p>
<p>Some examples of operations that the built-in optimization strategies can perform are as follows:</p>
<ul>
<li>Merging multiple similar meshes into a single mesh</li>
<li>Disabling shadows and/or post-processes</li>
<li>Reducing texture resolution or hardware scaling</li>
<li>Particle count reductions</li>
</ul>
<p>Each specific <strong class="bold">Optimization</strong> has a priority value assigned to it, with lower valued optimizations being applied first. To make it more convenient, <strong class="bold">SceneOptimizerOptions</strong> has <a id="_idIndexMarker992"/>a set of static factory methods that allow you to specify a set of optimizations according to the amount of visual degradation you’re willing to allow in the scene – low, moderate, or high. See the docs at the link mentioned previously for more details on the specifics of which optimizations are used for what degradation level. Interestingly, <strong class="bold">SceneOptimizer</strong> can be configured to run in the opposite direction – instead of degrading scene quality, it will enable or apply effects until the point where the FPS drops to or below the target. This is useful in power-limited scenarios where energy usage is an important consideration but isn’t an area that we’re going to cover here (see <em class="italic">Extended Topics</em> for more though!). </p>
<p>In addition to the built-in optimization strategies, it’s possible to define custom optimization strategies. This is quite useful for our salient purpose and doesn’t require more than a line or two of JavaScript. We’re going to use this to create a custom strategy later in the <em class="italic">Creating a Custom Optimization Strategy for the Asteroid Belt</em> section, but first, let’s learn to crawl before we walk by learning a bit about <strong class="bold">SceneOptimizer</strong> on <a id="_idIndexMarker993"/>its<a id="_idIndexMarker994"/> own. Don’t be fooled by the tall Section Headers – it’s quite simple when we look at the mechanics of it!</p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor260"/>Understanding the Scene Optimizer and its Operating Modes</h2>
<p>The Babylon.js Scene<a id="_idIndexMarker995"/> Optimizer executes in one of two modes: Improvement <a id="_idIndexMarker996"/>and… <strong class="source-inline">!isInImprovementMode</strong>. That’s a bit of an insider joke because that’s the property set by the last parameter to the <strong class="bold">SceneOptimizer</strong> constructor and it can be easy to mix up their operational behaviors. Whenever the default value of <strong class="source-inline">true</strong> is set, optimizations are applied until the target frame rate has been reached or we run out of strategies to apply. When <strong class="source-inline">false</strong>, it does the opposite or enhances the visuals while the frame rate is <em class="italic">above</em> the target. Each Optimization (even Custom ones) adapts its behavior to whichever mode is set, so a strategy that tries to increase frame rate might turn off shadows when in optimization mode and turn them on when in enhancement mode. </p>
<p>The list of optimization/enhancement strategies used by <strong class="bold">SceneOptimizer</strong> is managed by the <strong class="source-inline">SceneOptimizerOptions</strong> module. Although it’s possible to start with a blank set of options and manually create and add strategies, a set of static factory methods for <strong class="source-inline">SceneOptimizerOptions</strong> are available that will create a pre-defined set of strategies based on how aggressive or extensive the actions are. The three methods range from <strong class="source-inline">LowDegradationAllowed</strong> to <strong class="source-inline">HighDegradationAllowed</strong> (see <a href="https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer#options">https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer#options </a>for more on the specific strategies included in each). </p>
<p class="callout-heading">Important note</p>
<p class="callout">Changing the value of <strong class="source-inline">isInImprovementMode</strong> will not affect the behavior of <strong class="bold">SceneOptimizer</strong>– the only place that it can be set is in the constructor!</p>
<p>Once you’ve set up <strong class="bold">SceneOptimizerOptions</strong> and <strong class="bold">SceneOptimizer</strong>, things get kicked off with a call to <strong class="source-inline">sceneOptimizer.start()</strong> and halted with <strong class="source-inline">sceneOptimizer.stop()</strong>. To help with debugging and troubleshooting (among other potential uses), <strong class="bold">SceneOptimizer</strong> has a set of three Observables that are triggered whenever an optimization is applied, succeeds, or fails, respectively.</p>
<p>Any Optimizer (that is, a Strategy for those who like Code Patterns) that is to be used with <strong class="bold">SceneOptimizer</strong> must implement two specific JavaScript methods to fulfill its software design contract: <strong class="source-inline">apply</strong> and <strong class="source-inline">getDescription</strong>. The <strong class="source-inline">apply(scene, optimizer)</strong> method is called against each Optimization with a <strong class="source-inline">priority</strong> matching the current <strong class="source-inline">priority</strong> of <strong class="bold">SceneOptimizer</strong>, while <strong class="source-inline">getDescription</strong> is responsible for returning a human-readable textual description of what the Optimization does to the given Scene. That’s all <a id="_idIndexMarker997"/>there is to it at a basic level – simple as promised! Building<a id="_idIndexMarker998"/> from this simple foundation, and now that we’re ready for it, let’s focus on that custom Optimization hinted at earlier.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor261"/>Creating a Custom Optimization Strategy for the Asteroid Belt</h2>
<p>Earlier in this <a id="_idIndexMarker999"/>chapter, we <a id="_idIndexMarker1000"/>used <a id="_idIndexMarker1001"/>the <strong class="bold">Realtime Performance Viewer</strong> to identify and verify a performance bottleneck. We discovered that during the Route Planning phase, the number of asteroids has a direct relationship to the FPS for the Scene. Since changing the number <a id="_idIndexMarker1002"/>of <strong class="bold">Thin Instances</strong> (<strong class="bold">TIs</strong>) is a simple matter of setting the mesh’s <strong class="source-inline">thinInstanceCount</strong> property, this seems like a good candidate for a custom Optimization Strategy.</p>
<p>Though several different ways exist to define an <strong class="bold">Optimization</strong>, the quickest and easiest way is to call the <strong class="source-inline">sceneOptimizerOptions.addCustomOptimization</strong> method. This function takes three parameters – callbacks for <strong class="source-inline">apply</strong> and <strong class="source-inline">getDescription</strong> and a value for <strong class="source-inline">priority</strong> that, by not-much-of-a-coincidence, happens to be the interface contract for an <strong class="bold">Optimizer</strong> that we so recently discussed!</p>
<p>The Playground at <a href="https://playground.babylonjs.com/%2317ZX41%2310">https://playground.babylonjs.com/#17ZX41#10</a> is a modified and stripped-down version of some earlier PGs that we looked at during <a href="B17266_06_Final_AM.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Game Mechanics</em>. This PG just contains the central star and the TI asteroid belt. Play with <strong class="source-inline">asteroidBeltOptions.number</strong> until you get a value that gives you a low-ish frame rate, then click the <strong class="bold">MAKE ME GO FAST</strong> button to start <strong class="source-inline">fastOptimizer</strong> to see <strong class="bold">SceneOptimizer</strong> in action as part of the bottom-most <strong class="source-inline">createScene</strong> method body. Most of this should be easy to understand, but one potential head-scratcher is this line of code:</p>
<pre class="source-code">&#13;
optimizerOptions.optimizations.forEach(o =&gt; o.priority += 1);</pre>
<p>What’s happening here? Well, we want our TI Optimizer to run first before any other Optimizers do. Yes, it’s like we’re an only or a first-born child – incredibly selfish and self-centered – but this is our application, and we know what we’re doing. For the most part. But we also can’t allow other Optimizations to run at the same priority because we don’t want to change anything except for the TI count before trying anything else to improve things. So, we loop over every existing priority in the <strong class="source-inline">optimizerOptions</strong> object and bump its priority to be one greater than whatever it previously was at (the default value is zero). That way, in the very next line, when we call <strong class="source-inline">addCustomOptimization</strong> with a priority of <strong class="source-inline">0</strong>, we know our stuff comes first. Take that, younger Sibs! The custom optimization definition can account for either mode of operation, and in<a id="_idIndexMarker1003"/> its <a id="_idIndexMarker1004"/>full version, it is capable of automatically computing min and max values for the instance count based on degradation requirements. The following code has been abridged for brevity and clarity but otherwise, it is the same as its big brother at <a href="https://github.com/jelster/space-truckers/blob/ch12/src/thinInstanceCountOptimization.js">https://github.com/jelster/space-truckers/blob/ch12/src/thinInstanceCountOptimization.js</a>:</p>
<pre class="source-code">&#13;
let optimizerOptions = new SceneOptimizerOptions(targetFps,&#13;
  2000);&#13;
optimizerOptions.addCustomOptimization((scene, opt) =&gt; {&#13;
    let currTI = mesh.thinInstanceCount;&#13;
    if (!opt.isInImprovementMode) {&#13;
        if (currTI &lt;= MIN_INSTANCE_COUNT) {&#13;
            return true;&#13;
        }&#13;
        mesh.thinInstanceCount = Math.ceil(currTI * 0.91);&#13;
    }&#13;
    else {&#13;
        if (currTI &gt;= MAX_INSTANCE_COUNT) {&#13;
            return true;&#13;
        }&#13;
        mesh.thinInstanceCount = Math.ceil(currTI * 1.09);&#13;
    }&#13;
    return false"&#13;
}, () =&gt; "Change thin ins"ance count");</pre>
<p>The interesting thing in the preceding code is that instead of changing the TI count by a fixed, set amount, we are changing it in increments of roughly 9%. This allows designers and developers<a id="_idIndexMarker1005"/> to<a id="_idIndexMarker1006"/> make changes more freely to the base asteroid count without needing to make other changes to accommodate different scales of values. Hopefully, it’s easy to see how easy it can be to make runtime adaptations to an application’s visual quality to meet a target frame rate, because that’s the extent of what we’re going to be covering in this topic, at least for this edition of this book. </p>
<p>There’s nothing magical about <strong class="bold">SceneOptimizer</strong>, even though the effect it has of saving developers’ time certainly can be that way. With the incredible number of individual performance characteristics accessible to web applications, the amount of hand-optimization that is possible or practical becomes more difficult and expensive. Balancing performance optimizations done at design time with ones dynamically applied at runtime can be the key to getting beautiful and smooth visuals for the widest possible range of audiences. </p>
<p><strong class="bold">SceneOptimizer</strong> is created by passing in a <strong class="source-inline">SceneOptimizerOptions</strong> object that defines the set of Optimizations that will be executed and whether they should be run to improve the frame rate to improve the visuals. Many built-in optimizations are provided and can be quickly created with <strong class="source-inline">SceneOptimizerOptions.LowDegradationAllowed</strong> and its companion methods, but custom Optimizations are almost as quick and easy to use too. Our custom optimizer changes the number of TIs until the target frame rate has been achieved. By adding it to the Optimization collection by passing an <strong class="source-inline">apply</strong> function, a <strong class="source-inline">getDescription</strong> function, and a priority number to <strong class="source-inline">optimizerOptions.addCustomOptimization</strong>, the custom optimizer is intended to run solo. Therefore, before we even do that, we must nudge the existing Optimization<a id="_idIndexMarker1007"/> priorities up to keep <a id="_idIndexMarker1008"/>ours both first and on its own in the queue.</p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor262"/>Summary</h1>
<p>When condensed down to an outline form, it may not seem like we covered a whole lot of ground in this chapter, but nothing could be further from the truth! Sure, there has been little to no mention of many important areas of performance optimization and measurement. We’ve covered nothing about the use of <strong class="bold">Octtrees</strong> to speed up collisions and mesh selection (<a href="https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees">https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees</a>), toggling various convenience caches to reduce memory footprints (<a href="https://doc.babylonjs.com/divingDeeper/scene/reducingMemoryUsage">https://doc.babylonjs.com/divingDeeper/scene/reducingMemoryUsage</a>), or any other of the almost two-dozen specific optimization heuristics (<a href="https://doc.babylonjs.com/divingDeeper/scene/optimize_your_scene">https://doc.babylonjs.com/divingDeeper/scene/optimize_your_scene</a>) that constitute “low-hanging fruit” areas for improvement. That’s OK, though. This book’s title starts with <em class="italic">Going the Distance</em>, not <em class="italic">Plumbing the Depths</em>, and we can always detour into those details in the Second Edition (should there ever be one!).</p>
<p>What we have covered are the basics of how to approach thinking and learning about performance testing and profiling, starting with general guidelines and advice before progressing to the <strong class="bold">Real-Time Performance Viewer</strong> tool new to Babylon.js v5. Using those skills, we took a capture of our application and used it to identify factors that show that performance is sensitive to changes, such as the number of asteroids rendered in the Route Planning Asteroid Belt. Finally, we saw how easy basic scene optimization at runtime can be with <strong class="bold">SceneOptimizer</strong>. We solved the previously identified performance bottleneck with a custom optimization strategy that will gradually lower the number of thin instances until the frame rate reaches acceptable levels. </p>
<p>In the next chapter, we’ll learn how to enhance our game and level it up from a regular web application to a Progressive Web Application. This will be the final step of making our game fully playable and accessible to everyone at any time; by the end of the next chapter, we’ll have an application ready to run offline and be published to the major app stores! </p>
<h1 id="_idParaDest-260"><a id="_idTextAnchor263"/>Extended Topics</h1>
<p>As always, there’s more to learn and explore in the topics we’ve looked at in this chapter. The following are ways you can engage further and practice the knowledge you’ve gained in the chapter. Don’t forget to post your questions and share your accomplishments on the Babylon.js forums or in the Space-Truckers discussion boards at <a href="https://forum.babylonjs.com">https://forum.babylonjs.com</a> and <a href="https://github.com/jelster/space-truckers/discussions">https://github.com/jelster/space-truckers/discussions</a>:</p>
<ul>
<li>Perform a more comprehensive quantitative analysis of the asteroid belt data to extract the precise relationship between the FPS and asteroid count. What is the specific FPS to asteroid ratio? Having the CSV file is handy here because spreadsheet tools such as Excel, Sheets, and Google Sheets are the best way to compare and calculate these figures.</li>
<li>Are there ways to rewrite the <strong class="source-inline">AsteroidBelt.update</strong> method to reduce the CPU inter-frame time? Maybe it isn’t necessary to loop through every asteroid individually if they could be addressed in bundles or batches…</li>
<li>Along the lines of the previous bullet point, is it possible to refactor the Asteroid Belt so that it behaves identically to how it does currently, but happen entirely on the GPU? Given what we learned about Shaders and Node Materials in the previous chapter, the answer should be an enthusiastic “YES!”. Now go prove it by making it happen!</li>
<li>Invert the custom asteroid scene optimization strategy to add thin instances instead of removing them. Integrate this with the application so that the scene tries to maintain a comfortable FPS range between 24 and 60.</li>
<li>Add the ability for users to configure an overall graphics quality preference setting. Their choice could influence the specific <strong class="source-inline">SceneOptimizerOptions</strong> that are included to either improve visuals or performance.</li>
</ul>
</div>
<div>
<div id="_idContainer130">
</div>
</div>
</div></body></html>