- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're developing an application, it will eventually form a structure and
    evolve into a stable product that you can use in production and sell to your customers.
    In the beginning, everything may seem simple and many tend to postpone the construction
    of a proper test suite.
  prefs: []
  type: TYPE_NORMAL
- en: '"Debugging is twice as hard as writing the code in the first place."'
  prefs: []
  type: TYPE_NORMAL
- en: '*—Brian W. Kernighan and P. J. Plauger in* The Elements of Programming Style'
  prefs: []
  type: TYPE_NORMAL
- en: Later on, the application may become just sufficiently complex for you to hesitate
    to begin testing. You may eventually give up and never test your application.
    It may be frustrating, especially if you have never seen or used any test suite
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proper testing gives you more than a little bit of quality assurance. Proper
    testing gives you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predictability**: This means that your code execution, no matter if it''s
    an application or just a module, will have an expected result. As you evolve the
    tests and introduce different test cases, you begin to fulfill all the uses for
    your code, and you ensure its results were as intended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature coverage**: This means that you can measure what parts of your code
    are tested or not. There are plenty of tools to inspect your code and tell you
    what parts of it haven''t been used in your test suite, which helps you create
    specific tests for specific parts of the code that are not yet covered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safe evolution**: This is a side effect. When your code gets complex, if
    your test suite has good code coverage, you can make changes and add features
    without compromising stability, as you can continuously run the test suite and
    see if it breaks anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a developing methodology that involves first creating a test for a new
    feature and then making sure the test passes. This way, you can focus on how you
    think your code should be used (in the new test) and then evolve it (actually
    develop it) so the test stops failing and gives proper results.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how code coverage can help in the testing process. Finally, we'll
    look at how you can mock parts of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create our first integration tests. Each of our tests will run separately,
    meaning they should not depend on any other test and should follow a predictable
    workflow. First, we need to change our `run.js` file to run all test files. For
    that, we''ll use `mocha` and add all files found in the `integration` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create the `integration` folder inside our `test` folder, and
    let''s create our first test file, called `image-upload.js`. Add this content
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the tests again, we should see the default `mocha` response with
    no tests passing and no tests failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid repeating code, let''s create a `tools.js` file inside the `test`
    folder, so we can export common tasks that every test file can use. Out of the
    box, I''m thinking about our microservice location and a sample image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Create a `sample.png` image in the `test` folder. When a test needs to upload
    an image, it will use that sample. In the future, we could have different kinds
    of samples, such as huge images, to test performance and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Using chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also need to make a little change to our microservice. We need to export
    its app so that the HTTP plugin from `chai` can load it and were able to test
    it without the need to run in a separate console. Add this to the end of our microservice
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have a folder hierarchy similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/618c9422-7b6e-4442-80be-bcda48e204ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We should now change our `image-upload.js` test file to create our first real
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by first including the `chai` modules and our `tools` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we describe our test file as `Uploading image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We'll add the different use cases we can think of, related to the uploading
    of images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside, we use `beforeEach`, which is a `mocha` method that will be called
    before every test in this file. Remember, we want our tests to be consistent,
    so we add this method to remove our image before running every test. We don''t
    care whether the image exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Look how we use the `tools.service`, which points to our microservice. If, later
    on, we change the name or somehow make it more complex, we just need to change
    the `tools` file, and everything should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add our first `integration` file''s test – a simple image upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It checks whether the HTTP response code is `200` and if the response body,
    which is a JSON structure, has the status property set to `ok`. And we're done!
  prefs: []
  type: TYPE_NORMAL
- en: Let's run our test suite again and see how it goes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c66ba039-aeab-40c5-b50d-244fbe83dd63.png)'
  prefs: []
  type: TYPE_IMG
- en: Covering all code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, let's focus on adding coverage to our code. It's important to have
    it covered as much as possible when it's still just a small service. If we start
    adding tests and coverage when it's already big, you'll be frustrated, and it
    will be hard to find the motivation to cover it all.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you'll find it rewarding to cover it in the beginning and keep the
    coverage percentage as high as possible along with code evolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to our image upload test, and add another test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will upload the same image twice in a row and we should receive an error
    from the database saying there''s a duplicate. Let''s run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57c1f00d-fe1e-45eb-9108-2e0099655ebd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s open the initial page  of the coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dea63b8-dc21-4397-8f1d-578c481602a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that our file is no longer in a red background. This means the statement
    coverage has reached *50%*. Let''s click on our file and see how our image upload
    method is covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cac710e1-c7a0-4606-baab-c61c84cce671.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s complete! We can now move on. Just a reminder before we move to another
    method: having full coverage does not mean there are no bugs. That''s something
    you need to understand. You might have a use case that you''re not expecting,
    and so, you have no code for it, so there''s no obvious coverage.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `bodyparser` module will not limit the type of content. If
    we upload a text file with an image name on it, our code will accept it and store
    it in the database without noticing. Think of this use case as your homework,
    and try to create a test to cover that use case and then fix the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move to the next method we see after our upload method: the image check
    on *line 67*. Let''s create a new integration test file called `image-check.js`,
    and add a simple test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4309bf36-5162-41b3-befb-d5c6f82a7ab7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see our console report is getting bigger. As we''re creating new integration
    test files and having a description for each one, `mocha` writes a nice tree view
    showing how the tests run. On the bottom, we can see the coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd63eccf-479c-4101-b6ce-333f96949c63.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the check method, we see it's now fully covered. This one was very
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: We're still in the middle of statement coverage as our top method; the image
    manipulation one is almost half of our code. This means that when we start covering
    it, the coverage will significantly rise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `integration` test for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Before each test, we're deleting the image (if it exists) and then uploading
    a fresh sample one. Then, for each test, we'll download it and test the output
    according to what we asked for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/280f19a6-d82f-4a90-80d9-90ee36f3d1ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, that was unexpected. The test fails because our length check does not
    match. This is actually a good example of something we just notice when we start
    to execute testing.
  prefs: []
  type: TYPE_NORMAL
- en: What happens is that, when we request an image, we use the `sharp` module to
    make any manipulation on the image, according to query parameters. In this case,
    we're not asking for any manipulation, but when we output the image (through `sharp`),
    it actually returns the same image in size, but perhaps with a little bit less
    quality, or maybe it just knows how to better encode our image and remove data
    from the file that is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t know exactly, but let''s assume we want the original image, untouched.
    We need to change our download method. Let''s assume that if no query parameters
    are defined at all, we just return the original image. Let''s add a condition
    to the top of our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run  it now, we should have no failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/352b4409-20b4-4d2e-b195-03270611ab1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our statement coverage did not rise much because we actually created a condition
    on top of the method and returned immediately, so our previous method is still
    untested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31f51911-414b-4152-b68a-182436f3abf6.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at *line 78,* you should see a new mark, an `E` that means that the
    condition in that line never executed the `else` statement, which is the rest
    of our code. Let's add a test to this integration and resize our image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need `sharp` to help us check whether the results are correct. Let''s
    include it on the top of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a resize test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d947fad9-1cc1-4db9-b3eb-482e75f78d37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It now looks very good. From the console report, we can see some green. Let''s
    look at the front page of the coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6581e47d-6b3c-47b5-b3c3-9f70f6f8e583.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We see green here as well. Having more than *80%* coverage is good, but we
    can still go further. Let''s see the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3ff1101-6b82-4765-86ab-f6f784086d7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s more or less covered. We still need to cover all the effects. We can
    actually run them all at once. The first two conditions also have an `E` marker,
    but that should disappear after adding a test without resizing. Let''s add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at our report now, we see the coverage is almost complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58b6d4de-05c0-40e3-8df5-50e38d241898.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To cover those yellow nulls there, we need to resize the image with only `width`
    or `height`. We can add two tests for those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a similar one for the `height`, and run the test suite. You should not
    see the statement coverage go up, only the branch coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f13bae9-3dae-49e6-8f9d-0f27711e67e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only method missing is the statistics method. This one is simple. We could
    eventually run a more specific test, by asking statistics, making a change such
    as an upload, and asking for statistics again to compare. I''ll leave that to
    you. Let''s just add a simple request test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, running our test suite should give all green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7410c16-009c-45b0-b94e-7630e2685d0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We see there are only two lines uncovered: `29.121`. The first one is our timer
    and the second one is on the statistics method. Let''s refresh our HTML report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63b758d2-a4e9-422c-bb9e-815b5e3bb32e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is rewarding; we have almost *100%* coverage. There's only one function
    not covered, which is our timer. And, there are only tree statements, which also
    represent the three branches, that aren't covered, but those aren't actually that
    important.
  prefs: []
  type: TYPE_NORMAL
- en: What is important is to keep this high coverage mark during the course of our
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking our services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not at all uncommon to have parts of your service that are harder to test.
    Some, or most, of those parts are error-related conditions, where it's hard to
    make an external service such as a database engine return an error that will rarely
    occur during normal execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to test, or at least simulate these kinds of events, we need to
    mock our services. There are a couple of options around, and Sinon is the most
    commonly used one in the Node.js ecosystem. This framework provides more than
    mocking; it also provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spies**: Which monitor function calls and record arguments passed, the returned value and
    other properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stubs**: Which are enhanced spies with a pre-programmed behavior, helping
    us drive the execution into a pre-determined path (allowing us to mock a behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sinon also allows us to bend time, by virtually changing the service perception of
    time, and to be able to test timed interval calls (remember our interval timer?).
    With this in mind, let's see if we can make our microservice reach *100%* test
    coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by installing the framework, as we did with `chai`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a test for the image deletion. This method is tested through
    the other tests and that''s why we didn''t need to add it before, but now that
    we want to fully test it, let''s add a basic test file called `image-delete.js`,
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I added the Sinon dependency on top, although I'm not using it just
    yet. You may run the tests again, but you shouldn't notice any difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to change the database behavior, so let''s export a reference to
    it, so as to be able to access it from the tests. Add the following line in our
    microservice file before connecting to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add another test to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing is uploading an image, but, before requesting to delete it,
    we create a `stub` on the `db.query` method. We then inform Sinon that when the
    `stub` is called with the first argument with `DELETE`, we want it to asynchronously
    call the third argument (counting starts at 0) with a fake error. For any other
    call, we want it to just pass through.
  prefs: []
  type: TYPE_NORMAL
- en: Then, after deleting the image, we check that we received an HTTP `500` error
    code and restore the `stub` to the original function, ensuring that the other
    tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: We're able to test this because `mocha` runs tests in serial; otherwise, we
    would need to do some gymnastics to ensure that we wouldn't interfere with the
    other tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the previously created test file, `image-stats.js`, include Sinon on
    the top, and add the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now over 97% coverage. Let''s bend time and test our timer. Create a
    new test file called `image-delete-old.js`, and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we're replacing the global timer functions (`setTimeout`and `setInterval`)
    with fake timers. We then make a simple call to statistics, and then advance time
    by one hour (the tick call), and then finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the tests and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b344f959-c4d5-4473-97e7-f295bc1f4cce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now reach *100% coverage* on functions and lines. There''s only one branch,
    with one statement missing. It''s the possibility of a connection error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87727f4f-fbfb-42a5-b895-b80a691133ac.png)'
  prefs: []
  type: TYPE_IMG
- en: I'll leave it to you to figure it out how to mock that.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that if you successfully mock the `connect` method, you'll also need
    to handle the throw.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests allow us to ensure a certain code quality level. It's very important to
    include tests from the very beginning, while the code is simple, to ensure that
    we keep tests updated and avoid regressions to the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: It's very rewarding when we see that our code has a very high test coverage.
    This feeling forces you to keep that high mark and indirectly maintains good code
    quality.
  prefs: []
  type: TYPE_NORMAL
