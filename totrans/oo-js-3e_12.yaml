- en: Chapter 12. Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 测试和调试
- en: 'As you write JavaScript applications, you will soon realize that having a sound
    testing strategy is indispensable. In fact, not writing enough tests is almost
    always a bad idea. It is essential to cover all nontrivial functionality of your
    code to make sure of the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写JavaScript应用程序时，你很快就会意识到拥有一个合理的测试策略是必不可少的。实际上，没有编写足够的测试几乎总是个坏主意。确保以下要点至关重要，即覆盖你代码的所有非平凡功能：
- en: Existing code behaves as per the specifications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有代码的行为符合规范
- en: Any new code does not break the behavior defined by the specifications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何新的代码都不会破坏由规范定义的行为
- en: Both these points are very important. Many engineers consider only the first
    point as the sole reason to cover your code with enough tests. The most obvious
    advantage of test coverage is to really make sure that the code being pushed to
    production system is mostly error free. Writing test cases to smartly cover maximum
    functional areas of the code, generally gives good indication around the overall
    quality of the code. There should be no arguments or compromises around this point.
    Although, it is unfortunate that many production systems are still bereft of adequate
    code coverage. It is very important to build an engineering culture where developers
    think about writing tests as much as they think about writing code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这两点都非常重要。许多工程师认为只有第一个点是覆盖足够测试的唯一原因。测试覆盖的最明显优势是确保推送到生产系统的代码基本上是错误的。编写测试用例来智能地覆盖代码的最大功能区域，通常可以很好地反映代码的整体质量。在这方面不应该有任何争论或妥协。尽管如此，许多生产系统仍然缺乏足够的代码覆盖，这是非常不幸的。建立一种工程师将编写测试视为与编写代码一样重要的工程文化非常重要。
- en: The second point is even more important. Legacy systems are usually very difficult
    to manage. When you are working on code, either written by someone else or written
    by a large distributed team, it is fairly easy to introduce bugs and break things.
    Even the best engineers make mistakes. When you are working on a large code base
    you are unfamiliar with, if there is no sound test coverage to help you, you will
    introduce bugs. As you won't have the confidence in the changes you are making,
    because there are no test cases to confirm your changes, your code releases will
    be shaky, slow, and obviously full of hidden bugs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点甚至更重要。遗留系统通常很难管理。当你正在编写代码时，无论是别人写的还是由大型分布式团队写的，很容易引入错误并破坏东西。即使是最好的工程师也会犯错误。当你在一个你不太熟悉的代码库上工作时，如果没有合理的测试覆盖来帮助你，你会引入错误。由于没有测试用例来确认你的更改，你不会对你的更改有信心，因此你的代码发布将会不稳定、缓慢，并且显然充满了隐藏的错误。
- en: You will refrain from refactoring or optimizing your code, because you won't
    be really sure what changes to the code base would potentially break something
    (again, because there are no test case to confirm your changes); all this is a
    vicious circle. It's like a civil engineer saying-although I have constructed
    this bridge, I have no confidence on the quality of the construction. It may collapse
    immediately or never. Although this may sound like an exaggeration, I have seen
    a lot of high impact production code being pushed with no test coverage. This
    is risky and should be avoided. When you are writing enough test cases to cover
    majority of your functional code, when you make change to those pieces, you will
    immediately realize if there is a problem with this new change. If your changes
    make the test case fail, you will realize the problem. If your refactor breaks
    the test scenario, you will realize the problem; all of this happens much before
    the code is pushed to production.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将避免重构或优化你的代码，因为你不会真正确定对代码库的哪些更改可能会破坏某些东西（再次强调，因为没有测试用例来确认你的更改）；所有这些都是一个恶性循环。这就像一个土木工程师说——虽然我建造了这座桥，但我对施工质量没有信心。它可能立即倒塌，也可能永远不会。虽然这听起来可能有些夸张，但我看到很多影响很大的生产代码被推送到生产环境而没有测试覆盖。这是有风险的，应该避免。当你编写足够的测试用例来覆盖大多数功能代码时，当你对这些部分进行更改时，你会立即意识到这个新更改是否有问题。如果你的更改使测试用例失败，你就会发现问题。如果你的重构破坏了测试场景，你就会发现问题；所有这些都在代码推送到生产之前发生。
- en: In recent years, ideas like test-driven development and self-testing code are
    gaining prominence, especially in agile methodology. These are fundamentally sound
    ideas and will help you write robust code - the code you are confident of. We
    will discuss all these ideas in this chapter. We will understand how to write
    good test cases in modern JavaScript. We will also look at several tools and methods
    to debug your code. JavaScript was traditionally a bit difficult to test and debug,
    primarily due to lack of tools, but modern tools make both of these easy and natural.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，像测试驱动开发和自测试代码这样的想法越来越受到重视，尤其是在敏捷方法中。这些想法在本质上都是合理的，并将帮助你编写健壮的代码——你自信的代码。我们将在本章中讨论所有这些想法。我们将了解如何在现代
    JavaScript 中编写好的测试用例。我们还将探讨几个用于调试代码的工具和方法。JavaScript 传统的测试和调试有点困难，主要是因为缺乏工具，但现代工具使得这两者都变得容易且自然。
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: When we talk about test cases, we mostly mean unit tests. It is incorrect to
    assume that the unit we want to test is always a function. The unit, or unit of
    work, is a logical unit that constitutes single behavior. This unit should be
    able to be invoked via a public interface and should be testable independently.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论测试用例时，我们主要指的是单元测试。假设我们想要测试的单元总是函数是不正确的。单元，或工作单元，是一个构成单个行为的逻辑单元。这个单元应该能够通过公共接口调用，并且应该能够独立进行测试。
- en: 'Thus, a unit test can perform the following functions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，单元测试可以执行以下功能：
- en: It tests a single logical function
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它测试单个逻辑函数
- en: It can run without a specific order of execution
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以无特定执行顺序地运行
- en: It takes care of its own dependencies and mock data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它负责自己的依赖和模拟数据
- en: It always returns the same result for the same input
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它总是对相同的输入返回相同的结果
- en: It should be self-explanatory, maintainable, and readable
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是自我解释的、可维护的和可读的
- en: Martin Fowler advocates the *Test Pyramid* ([http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html))
    strategy to make sure we have a high number of unit tests to ensure maximum code
    coverage. There are two important testing strategies that we will discuss in this
    chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒提倡使用 *测试金字塔* ([http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html))
    策略，以确保我们有大量的单元测试来确保最大的代码覆盖率。在本章中，我们将讨论两种重要的测试策略。
- en: Test Driven Development
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test driven development** (**TDD**) has gained a lot of prominence in the
    last few years. The concept was first proposed as part of the extreme programming
    methodology. The idea is to have short repetitive development cycles where the
    focus is on writing the test cases first. The cycle looks like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发** (**TDD**) 在过去几年中获得了很大的关注。这个概念最初是在极限编程方法中作为一部分被提出的。想法是拥有短而重复的开发周期，其中重点在于首先编写测试用例。周期看起来如下：'
- en: Add a test case as per the specifications for the specific unit of code.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据特定代码单元的规范添加测试用例。
- en: Run existing suite of test cases to see if the new test case you wrote fails;
    it should, because there is no code for that unit yet. This step ensures that
    the current test harness works well.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行现有的测试用例套件，看看你编写的新测试用例是否失败；它应该会失败，因为该单元还没有代码。这一步确保当前的测试框架运行良好。
- en: Write the code that mainly serves to confirm to the test case. This code is
    not optimized, refactored, or even entirely correct. However, this is fine at
    this moment.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写主要服务于确认测试用例的代码。这段代码没有经过优化、重构，甚至可能完全不正确。然而，在这个阶段这是可以接受的。
- en: Rerun tests and see if all the test cases pass. After this step, you are confident
    that the new code is not breaking anything.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试，看看所有测试用例是否通过。完成这一步后，你可以确信新代码没有破坏任何东西。
- en: Refactor code to make sure you are optimizing the unit and handling all corner
    cases
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构代码以确保你正在优化单元并处理所有边界情况
- en: These steps are repeated for any new code you add. This is an elegant strategy
    that works really well for agile methodology. TDD will be successful only if the
    testable units of code are small and confirms only to the test case.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤会重复应用于你添加的任何新代码。这是一种优雅的策略，非常适合敏捷方法。只有当代码的可测试单元很小，并且仅确认测试用例时，TDD 才会成功。
- en: Behavior Driven Development
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: A very common problem while trying to follow TDD is vocabulary and the definition
    of correctness. BDD tries to introduce a ubiquitous language while writing the
    test cases when you are following TDD. This language makes sure that both the
    business and the engineering are talking about the same thing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试遵循TDD（测试驱动开发）时，一个很常见的问题是词汇和正确性的定义。BDD（行为驱动开发）试图在遵循TDD编写测试用例时引入一种通用语言。这种语言确保业务和工程都在谈论同一件事情。
- en: We will use Jasmine as the primary BDD framework and explore various testing
    strategies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Jasmine作为主要的BDD（行为驱动开发）框架，并探索各种测试策略。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can install Jasmine by downloading the standalone package from [https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip](https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从[https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip](https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip)下载独立包来安装Jasmine。
- en: 'When you unzip this package, you will see the following directory structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你解压这个包时，你会看到以下目录结构：
- en: '![Behavior Driven Development](img/image_12_001.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![行为驱动开发](img/image_12_001.jpg)'
- en: 'The `lib` directory contains the JavaScript files that you need in your project
    to start writing Jasmine test cases. If you open `SpecRunner.html`, you will find
    the following JavaScript files included in it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib`目录包含你在项目中需要编写Jasmine测试用例的JavaScript文件。如果你打开`SpecRunner.html`，你会在其中找到以下JavaScript文件：'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first three are Jasmine's own framework files. The next section includes
    the source files we want to test and the actual test specifications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个是Jasmine自己的框架文件。下一部分包括我们想要测试的源文件和实际的测试规范。
- en: 'Let''s experiment with Jasmine via a very ordinary example. Create a `bigfatjavascriptcode.js`
    file and place it in the `src/` directory. The function we will test is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个非常普通的例子来实验一下Jasmine。创建一个`bigfatjavascriptcode.js`文件，并将其放置在`src/`目录中。我们将要测试的函数如下：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple function that does one single thing. It receives a string and
    returns a capitalized string. We will test various scenarios around this function.
    This is the unit of code, which we discussed earlier.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，它只做一件事情。它接收一个字符串并返回一个大写字符串。我们将测试围绕这个函数的各种场景。这是之前讨论过的代码单元。
- en: 'Next, create the test specifications. Create one JavaScript file, `test.spec.js`,
    and place it in the `spec/` directory. You will need to add the following two
    lines into your `SpecRunner.html`: The file should contain the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建测试规范。创建一个JavaScript文件，`test.spec.js`，并将其放置在`spec/`目录中。你需要在你的`SpecRunner.html`中添加以下两行：文件应包含以下内容：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The order of this inclusion does not matter. When we run `SpecRunner.html`,
    you will see something like the following image:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的顺序并不重要。当我们运行`SpecRunner.html`时，你会看到如下所示的图像：
- en: '![Behavior Driven Development](img/image_12_002.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![行为驱动开发](img/image_12_002.jpg)'
- en: 'This is the Jasmine report that shows details about the number of tests that
    were executed and the count of failures and successes. Now, let''s make the test
    case fail. We want to test a case where an `undefined` variable is passed to the
    function. Let''s add one more test case, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Jasmine报告，显示了已执行的测试数量以及失败和成功的计数。现在，让我们让测试用例失败。我们想要测试一个传递给函数的`undefined`变量的情况。让我们添加一个额外的测试用例，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when you run `SpecRunner`, you will see the following result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行`SpecRunner`时，你会看到以下结果：
- en: '![Behavior Driven Development](img/image_12_003.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![行为驱动开发](img/image_12_003.jpg)'
- en: 'As you can see, the failure is displayed for this test case in a detailed error
    stack. Now, we will go about fixing this. In your original JS code, handle undefined
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个测试用例的失败在详细的错误堆栈中显示。现在，我们将着手修复这个问题。在你的原始JS代码中，可以这样处理`undefined`：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this change, your test case will pass, and you will see the following
    result in the Jasmine report:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，你的测试用例将通过，你将在Jasmine报告中看到以下结果：
- en: '![Behavior Driven Development](img/image_12_004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![行为驱动开发](img/image_12_004.jpg)'
- en: This is very similar to what a test-driven development would look like. You
    write test cases and then fill the necessary code to confirm to the specifications
    and rerun the test suite. Let's understand the structure of the Jasmine tests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这与测试驱动开发的样子非常相似。你编写测试用例，然后填写必要的代码以符合规范，并重新运行测试套件。让我们了解Jasmine测试的结构。
- en: 'Our test specification looks like the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试规范看起来像以下代码片段：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `describe("TestStringUtilities"` is what a test suite is. The name of the
    test suite should describe the unit-of-code we are testing; this can be a function
    or a group of related functionality. Inside the specs, you will call the global
    Jasmine function,`it`, to which you will pass the title of the spec and the function
    that validates the condition of the testcase This function is the actual test
    case. You can catch one or more assertions or the general expectations using the
    `expect` function. When all expectations are `true`, your spec is passed. You
    can write any valid JavaScript code inside `describe` and `it` functions. The
    values you verify as part of the expectations are matched using a matcher. In
    our example, `toEqual` is the matcher that matches two values for equality. Jasmine
    contains a rich set of matches to suit most of the common use cases. Some common
    matchers supported by Jasmine are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe("TestStringUtilities"` 是测试套件。测试套件的名字应该描述我们正在测试的代码单元；这可以是一个函数或一组相关功能。在规格说明中，你将调用全局Jasmine函数`it`，并将传递规格的标题和验证测试用例条件的函数。这个函数是实际的测试用例。你可以使用`expect`函数捕获一个或多个断言或一般期望。当所有期望都为`true`时，你的规格通过。你可以在`describe`和`it`函数内部编写任何有效的JavaScript代码。你验证作为期望一部分的值是通过匹配器进行匹配的。在我们的例子中，`toEqual`是匹配两个值相等的匹配器。Jasmine包含丰富的匹配器，以适应大多数常见用例。以下是一些Jasmine支持的常见匹配器：'
- en: '`toBe`: This matcher checks if two objects being compared are equal. This is
    same as the `===` comparison. For example, check out the following code snippet:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toBe`: 这个匹配器检查两个被比较的对象是否相等。这等同于`===`比较。例如，查看以下代码片段：'
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`not`: You can negate a matcher with a not prefix. For example, `expect(1).not.toEqual(2);`
    will negate the match made by `toEqual()`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`: 你可以使用not前缀来否定一个匹配器。例如，`expect(1).not.toEqual(2);`将否定`toEqual()`所做的匹配。'
- en: '`toContain`: This checks if an element is part of an array. It is not an exact
    object match as `toBe`. For example, take a look at the following lines of code:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toContain`: 这用于检查一个元素是否是数组的一部分。它并不像`toBe`那样进行精确的对象匹配。例如，看看以下代码行：'
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`toBeDefined` and `toBeUndefined`: These two matches are handy to check whether
    a variable is `undefined` or not.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toBeDefined` 和 `toBeUndefined`: 这两个匹配器便于检查变量是否为`undefined`。'
- en: '`toBeNull`: This checks if a variable''s value is `null`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toBeNull`: 这用于检查变量的值是否为`null`。'
- en: '`toBeGreaterThan` and `toBeLessThan`: These matcher performs numeric comparison
    (works on strings too). For example, consider the following piece of code:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toBeGreaterThan` 和 `toBeLessThan`: 这些匹配器执行数值比较（也适用于字符串）。例如，考虑以下代码片段：'
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An interesting feature of Jasmine is the spies. When you are writing a large
    system, it is not possible to make sure that all systems are always available
    and correct. At the same time, you don''t want your unit tests to fail due to
    a dependency that may be broken or unavailable. To simulate a situation where
    all dependencies are available for a unit of code we want to test, we will mock
    this dependency to always give the response we expect. Mocking is an important
    aspect of testing, and most testing frameworks provide support for mocking. Jasmine
    allows mocking using a feature called a **Spy**. Jasmine spies essentially stubs
    the functions we may not have ready at the time of writing the test case, but
    as part of the functionality, we will need to track that we are executing those
    dependencies and not ignoring them. Consider the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine的一个有趣特性是间谍。当你编写一个大型系统时，你不可能确保所有系统总是可用且正确。同时，你也不想因为某个可能损坏或不可用的依赖而导致单元测试失败。为了模拟一个所有依赖都可用于我们想要测试的单元代码的情况，我们将模拟这个依赖以始终给出我们期望的响应。模拟是测试的重要方面，大多数测试框架都提供了对模拟的支持。Jasmine允许使用一个称为**间谍**的功能进行模拟。Jasmine间谍本质上是对我们在编写测试用例时可能没有准备好的函数进行存根，但作为功能的一部分，我们需要跟踪我们是否正在执行这些依赖而不是忽略它们。考虑以下示例：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, while we are writing this test case, we either don't have the
    real implementation of the dependency, `configurator.submitPOSTRequest()`, or
    someone is fixing this particular dependency; in any case, we don't have it available.
    For our test to work, we will need to mock it. Jasmine spies allow us to replace
    a function with its mock and allows us to track its execution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们编写这个测试用例时，我们可能没有依赖的真实实现，`configurator.submitPOSTRequest()`，或者有人在修复这个特定的依赖；无论如何，我们都没有它可用。为了使我们的测试工作，我们需要模拟它。Jasmine间谍允许我们用一个模拟替换一个函数，并允许我们跟踪其执行。
- en: In this case, we will need to ensure that we called the dependency. When the
    actual dependency is ready, we will revisit this test case to make sure it fits
    the specifications; however, at this time, all we need to ensure that the dependency
    is called. Jasmine function `tohaveBeenCalled()` lets us track the execution of
    a function that may be a mock. We can use `toHaveBeenCalledWith()`, which allows
    us to determine if the stub function was called with correct parameters. There
    are several other interesting scenarios you can create using Jasmine spies. The
    scope of this chapter won't permit us to cover them all, but I would encourage
    you to discover those areas on your own.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要确保调用了依赖项。当实际的依赖项准备好时，我们将重新访问这个测试用例以确保它符合规范；然而，此时我们只需要确保调用了依赖项。Jasmine函数`tohaveBeenCalled()`让我们跟踪可能是一个模拟的函数的执行。我们可以使用`toHaveBeenCalledWith()`，这允许我们确定占位函数是否以正确的参数被调用。你可以使用Jasmine
    spies创建几个其他有趣的场景。由于本章的范围不允许我们涵盖所有这些内容，但我鼓励你自己去发现这些领域。
- en: Mocha, Chai and Sinon
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocha、Chai和Sinon
- en: 'Though Jasmine is the most prominent JavaScript testing framework, mocha and
    chai are gaining prominence in the `Node.js` environment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Jasmine是最突出的JavaScript测试框架，但mocha和chai在`Node.js`环境中越来越受欢迎：
- en: Mocha is the testing framework used to describe and run test cases
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha是用于描述和运行测试用例的测试框架
- en: Chai is the assertion library supported by Mocha
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chai是Mocha支持的断言库
- en: Sinon comes in handy while creating mocks and stubs for your tests
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sinon在创建测试的模拟和占位符时很有用
- en: We won't discuss these frameworks in this book; however, experience on Jasmine
    will be handy if you want to experiment with these frameworks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中讨论这些框架；然而，如果你想要尝试这些框架，Jasmine的经验将很有用。
- en: JavaScript debugging
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript调试
- en: If you are not a completely new programmer, I am sure you must have spent some
    amount of time debugging your or someone else's code. Debugging is almost like
    an art form. Every language has different methods and challenges around the debugging.
    JavaScript is traditionally a difficult language to debug. I have spent days and
    nights in misery, trying to debug badly written JavaScript code using `alert()`
    functions. Fortunately, modern browsers, such as Mozilla, Firefox, and Google
    Chrome, have excellent **Developer Tools** to help debug JavaScript in the browser.
    There are IDEs like IntelliJ IDEA and WebStorm with great debugging support for
    JavaScript and Node.js. In this chapter, we will focus primarily on Google Chrome's
    built-in developer tool. Firefox also supports Firebug extension and has excellent
    built-in developer tools, but as they behave more or less the same as Google Chrome's
    **Developer Tools**, we will discuss common debugging approaches that work in
    both of these tools.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是一个完全的新程序员，我敢肯定你一定花了一些时间调试你或别人的代码。调试几乎就像是一种艺术形式。每种语言都有不同的调试方法和挑战。JavaScript传统上是一种难以调试的语言。我曾经花费了无数个日夜在痛苦中尝试使用`alert()`函数调试糟糕的JavaScript代码。幸运的是，现代浏览器，如Mozilla、Firefox和Google
    Chrome，都有优秀的**开发者工具**来帮助在浏览器中调试JavaScript。有一些IDE，如IntelliJ IDEA和WebStorm，提供了对JavaScript和Node.js的出色调试支持。在本章中，我们将主要关注Google
    Chrome内置的开发者工具。Firefox也支持Firebug扩展，并拥有出色的内置开发者工具，但由于它们的行为与Google Chrome的**开发者工具**大致相同，我们将讨论在这两种工具中都适用的常见调试方法。
- en: Before we talk about the specific debugging techniques, let's understand the
    type of errors we would be interested in while we try to debug our code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论具体的调试技术之前，让我们了解在尝试调试代码时我们感兴趣的错误类型。
- en: Syntax errors
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法错误
- en: 'When your code has something that does not confirm to the JavaScript language
    grammar, the interpreter rejects that piece of code. These are easy to catch if
    your IDE is helping you with syntax checking. Most modern IDEs help with these
    errors. Earlier, we discussed the usefulness of tools, such as JSLint and JSHint,
    around catching syntax issues with your code. They analyze the code and flag errors
    in the syntax. The JSHint output can be very illuminating. For example, the following
    output shows up so many things we can change in the code. The following code snippet
    is from one of my existing projects:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码中有不符合JavaScript语言语法的内容时，解释器会拒绝这段代码。如果你的IDE在语法检查方面提供帮助，这些错误很容易被发现。大多数现代IDE都帮助处理这些错误。之前，我们讨论了使用JSLint和JSHint等工具来捕获代码中的语法问题的实用性。它们分析代码并标记语法错误。JSHint的输出可以非常启发人心。例如，以下输出显示了我们可以更改代码中的许多内容。以下代码片段来自我的一个现有项目：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using strict
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用严格模式
- en: 'We briefly discussed the strict mode in earlier chapters. When you enable strict
    mode, JavaScript stops being accepting of syntactical errors in your code. Rather
    than silently failing, strict mode makes these failure throw errors instead. It
    also helps you convert mistakes into actual errors. There are two ways of enforcing
    strict mode. If you want the strict mode for the entire script, you can just add
    the `use strict` statement (with the quotes) as the first line of your JavaScript
    program. If you want a specific function to confirm to strict mode, you can add
    the directive as the first line of a function. For example, take a look at the
    following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中简要讨论了严格模式。当你启用严格模式时，JavaScript 将不再接受代码中的语法错误。严格模式不会静默失败，而是将这些失败抛出错误。它还有助于将错误转换为实际错误。有两种方法可以强制执行严格模式。如果你想为整个脚本启用严格模式，你只需将
    `use strict` 语句（带引号）作为你的 JavaScript 程序的第一行即可。如果你想使一个特定的函数符合严格模式，你可以将该指令作为函数的第一行。例如，看看以下代码片段：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Runtime exceptions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时异常
- en: 'These errors appear when you execute the code, try to refer to an `undefined`
    variable, or try to process a `null`. When a runtime exception occurs, any code
    after that particular line, which caused the exception, does not get executed.
    It is essential to correctly handle such exceptional scenarios in the code. While
    exception handling can help prevent crashes, they also aid in debugging. You can
    wrap the code that may encounter a runtime exception into a `try{ }` block. When
    any code inside this block generates a runtime exception, a corresponding handler
    captures it. The handler is defined by a `catch(exception){}` block. Let''s clarify
    this using the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误在你执行代码、尝试引用一个 `undefined` 变量或尝试处理一个 `null` 时出现。当运行时异常发生时，导致异常的特定行之后的任何代码都不会被执行。在代码中正确处理这样的异常情况至关重要。虽然异常处理可以帮助防止崩溃，但它们也有助于调试。你可以将可能遇到运行时异常的代码包裹在一个
    `try{ }` 块中。当这个块内的任何代码生成运行时异常时，相应的处理器会捕获它。处理器由一个 `catch(exception){}` 块定义。让我们通过以下示例来澄清这一点：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, the `var a = doesnotexist` line tries to assign an `undefined`
    variable, `doesnotexist`, to another variable `a`. This causes a runtime exception.
    When we wrap this problematic code into `try{}catch(){}` block or when the exception
    occurs (or is thrown), the execution stops in the `try{}` block and goes directly
    to the `catch() {}` handler. The catch handler is responsible for handling the
    exceptional scenario. In this case, we are displaying the error message on the
    console for debugging purposes. You can explicitly throw an exception to trigger
    an unhandled scenario in the code. Consider the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`var a = doesnotexist` 这一行尝试将一个 `undefined` 变量 `doesnotexist` 赋值给另一个变量
    `a`。这会导致运行时异常。当我们将这段有问题的代码包裹在 `try{}catch(){}` 块中，或者当异常发生（或抛出）时，执行将停止在 `try{}`
    块中，并直接跳转到 `catch() {}` 处理器。捕获处理器负责处理异常情况。在这种情况下，我们将在控制台上显示错误信息以进行调试。你可以显式地抛出一个异常来触发代码中的未处理情况。考虑以下示例：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we are handling valid states of a gear shift: `R`, `N`, and
    `D`; however, when we receive an invalid state, we are explicitly throwing an
    exception clearly stating the reason. When we call the function which we think
    may throw an exception, we will wrap the code in the `try{}` block and attach
    a `catch(){}` handler with it. When the exception is caught by the `catch()` block,
    we will handle the exceptional condition appropriately.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在处理齿轮换挡的有效状态：`R`、`N` 和 `D`；然而，当我们收到一个无效状态时，我们会明确地抛出一个异常，清楚地说明原因。当我们调用我们认为可能会抛出异常的函数时，我们将代码包裹在
    `try{}` 块中，并附上一个 `catch(){}` 处理器。当异常被 `catch()` 块捕获时，我们将适当地处理异常情况。
- en: Console.log and asserts
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Console.log 和断言
- en: Displaying the state of execution on console can be very useful while debugging.
    Although, modern developer tools allow you to put breakpoints and halt execution
    to inspect a particular value during runtime. You can quickly detect small issues
    by logging some variable state on the console.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，在控制台上显示执行状态非常有用。尽管如此，现代的开发者工具允许你在运行时设置断点并暂停执行以检查特定的值。你可以通过在控制台上记录一些变量状态来快速检测小问题。
- en: With these concepts with us, let's see how we can use Chrome **Developer Tools**
    to debug JavaScript code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些概念，让我们看看如何使用 Chrome **开发者工具** 来调试 JavaScript 代码。
- en: Chrome Developer Tools
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chrome 开发者工具
- en: 'You can start Chrome **Developer Tools** by clicking **menu** | **More tools**
    | **Developer Tools**. Take a look at the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击**菜单** | **更多工具** | **开发者工具**来启动Chrome **开发者工具**。请参考以下截图：
- en: '![Chrome Developer Tools](img/image_12_005.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_005.jpg)'
- en: 'Chrome developer tool opens up on the lower pane of your browser and has a
    bunch of very useful sections. Consider the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具位于浏览器底部的面板，包含许多非常有用的部分。请参考以下截图：
- en: '![Chrome Developer Tools](img/image_12_006.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_006.jpg)'
- en: The **Elements** panel helps you inspect and monitor the DOM tree and associated
    style sheet for each of these components.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**元素**面板帮助你检查和监控每个组件的DOM树和关联样式表。'
- en: The **Network** panel is useful to understand network activity. For example,
    you can monitor the resources being downloaded over the network in real time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络**面板有助于理解网络活动。例如，你可以实时监控通过网络下载的资源。'
- en: 'The most important pane for us is the **Sources** pane. This pane is where
    the JavaScript and the debugger are displayed. Let''s create a sample HTML with
    the following content:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，最重要的面板是**源**面板。这个面板是显示JavaScript和调试器的位置。让我们创建一个包含以下内容的示例HTML：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Save this HTML file and open it in Google Chrome. Open **Developer Tools**
    in the browser, and you will see the following screen:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此HTML文件，并在Google Chrome中打开它。在浏览器中打开**开发者工具**，你会看到以下屏幕：
- en: '![Chrome Developer Tools](img/image_12_007.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_007.jpg)'
- en: This is the view of the **Sources** panel. You can see the HTML and embedded
    JavaScript source in this panel. You can see the **Console** window as well, and
    you can see that the file is executed and the output is displayed on console.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**源**面板的视图。你可以看到在这个面板中HTML和嵌入的JavaScript源代码。你还可以看到**控制台**窗口，并且可以看到文件正在执行，输出显示在控制台上。
- en: 'On the right side, you will see the debugger window, as shown in the following
    screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，你会看到调试器窗口，如下截图所示：
- en: '![Chrome Developer Tools](img/image_12_008.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_008.jpg)'
- en: 'In the **Sources** panel, click on the line numbers **8** and **15** to add
    a breakpoint. The breakpoints allow you to stop execution of the script at the
    specified point. Consider the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在**源**面板中，点击行号**8**和**15**以添加断点。断点允许你在指定的点停止脚本的执行。请参考以下截图：
- en: '![Chrome Developer Tools](img/5239_12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/5239_12.jpg)'
- en: 'In the debug pane, you can see all existing breakpoints. Take a look at the
    following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试面板中，你可以看到所有现有的断点。请参考以下截图：
- en: '![Chrome Developer Tools](img/image_12_010.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_010.jpg)'
- en: 'Now, when you rerun the same page, you will see that the execution stops at
    the debug point. Consider the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你重新运行同一页面时，你会看到执行在调试点处停止。请参考以下截图：
- en: '![Chrome Developer Tools](img/image_12_011.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_011.jpg)'
- en: 'This window now has all the action. You can see that the execution is paused
    on line **15**. In the debug window, you can see which breakpoint is being triggered.
    You can also see the **Call Stack** and resume execution in several ways. The
    debug command window has a bunch of actions. Take a look at the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口现在有了所有动作。你可以看到执行在行**15**处暂停。在调试窗口中，你可以看到哪个断点被触发。你还可以看到**调用栈**并以多种方式恢复执行。调试命令窗口包含许多操作。请参考以下截图：
- en: '![Chrome Developer Tools](img/image_12_012.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_012.jpg)'
- en: 'You can resume execution, which will execute until the next breakpoint, by
    clicking on the following button:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击以下按钮来恢复执行，这将执行到下一个断点：
- en: '![Chrome Developer Tools](img/image_12_013.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_013.jpg)'
- en: 'When you do that, the execution continues until the next breakpoint is encountered.
    In our case, we will halt at line **8**. Consider the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，执行将继续，直到遇到下一个断点。在我们的例子中，我们将暂停在行**8**。请参考以下截图：
- en: '![Chrome Developer Tools](img/image_12_014.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome 开发者工具](img/image_12_014.jpg)'
- en: You can observe that the **Call Stack** window shows how we arrived at line
    **8**. The **Scope** panel shows the **Local** scope where you can see the variables
    in the scope when the breakpoint was arrived at. You can also Step-Into or Step-over
    the next function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到**调用栈**窗口显示了如何到达行**8**。**作用域**面板显示了断点到达时的**局部**作用域，你可以看到作用域中的变量。你还可以单步进入或单步跳过下一个函数。
- en: There are other very useful mechanisms to debug and profile your code using
    Chrome **Developer Tools**. I would suggest you to experiment with the tool and
    make it a part of your regular development flow.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chrome **开发者工具**调试和性能分析你的代码还有其他非常实用的机制。我建议你尝试使用这个工具，并将其作为你常规开发流程的一部分。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Both testing and debugging phases are essential to developing robust JavaScript
    code. TDD and BDD are approaches closely associated with the agile methodology
    and is widely embraced by the JavaScript developer community. In this chapter,
    we reviewed best practices around TDD and the usage of Jasmine as the testing
    framework. Additionally, we saw various methods of debugging JavaScript using
    Chrome **Developer Tools**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试阶段对于开发健壮的JavaScript代码至关重要。TDD和BDD是与敏捷方法紧密相关的方法，并且被JavaScript开发者社区广泛接受。在本章中，我们回顾了关于TDD和Jasmine作为测试框架的使用最佳实践。此外，我们还看到了使用Chrome
    **开发者工具**调试JavaScript的各种方法。
- en: In the next chapter, we will explore the new and exciting world of ES6, DOM
    Manipulation and cross-browser strategies.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索ES6、DOM操作和跨浏览器策略这个新颖而激动人心的世界。
