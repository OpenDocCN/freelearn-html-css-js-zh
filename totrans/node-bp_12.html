<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12" class="calibre1"/>Chapter 12. Developing Desktop Apps with Node.js</h1></div></div></div><p class="calibre7">In the previous chapter, we implemented a REST API and built a server that processes various requests. Most of the chapters in this book present web technologies, applications that work in a browser with the HTTP protocol. It's interesting that Node.js can be used to produce desktop programs, and we don't have to learn a new language or use a new tool. We can continue using HTML, CSS, and JavaScript. This is a great benefit because these technologies are easy to learn and develop. Node.js is also really fast: We save a lot of time when dealing with large amounts of written modules because we don't have to deal with trivial problems. In this chapter, we will write a file browser. Our application will perform the following:</p><div><ul class="itemizedlist"><li class="listitem">Run as a desktop program</li><li class="listitem">Read the files from our hard drive and display them on the screen</li><li class="listitem">Display images</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch12lvl1sec77" class="calibre1"/>Using node-webkit</h1></div></div></div><p class="calibre7">There are several tools <a id="id631" class="calibre1"/>available to write desktop apps. We will use <a id="id632" class="calibre1"/>node-webkit (<a class="calibre1" href="https://github.com/rogerwang/node-webkit">https://github.com/rogerwang/node-webkit</a>). It's an app runtime based on Chromium and Node.js. It's distributed as a binary program we run to see the result of our code. It is available for all the major operating systems—Linux, Windows, and Mac. So during the development, we will use the <code class="email">nw</code> executable file, which is the same as using the <code class="email">node</code> executable to run Node.js scripts. The <code class="email">nw</code> file can be downloaded from the official repository of the tool in GitHub.</p><p class="calibre7">Every desktop application written with node-webkit must contain at least two files: <code class="email">package.json</code> and the main HTML file. Similar to the modules we wrote so far, the <code class="email">package.json</code> file holds the configuration of our application. The following is a simple example:</p><div><pre class="programlisting">{
  "name": "nw-demo",
  "main": "index.html"
}</pre></div><p class="calibre7">It's important that we set a value for the <code class="email">main</code> property. It should point to the main HTML file of our file browser. The path is relative to the location of the <code class="email">package.json</code> file. The content of <code class="email">index.html</code> will be something like the following:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
    We are using node.js &lt;script&gt;document.write(process.version)&lt;/script&gt;.
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">This is just a regular HTML page, except for the code placed between the <code class="email">script</code> tags. The <code class="email">document.write</code> method is available in every modern browser. However, <code class="email">process</code> is a Node.js global object. The example is a simple one, but we can see the power of node-webkit. In practice, we can mix the client-side JavaScript with a server-side JavaScript, which is run in the context of our machine. We can code like we do in the Node.js environment while still having access to the DOM of the page.</p><p class="calibre7">The following are<a id="id633" class="calibre1"/> two ways to run the app:</p><div><ul class="itemizedlist"><li class="listitem">We can navigate to the directory that contains the files and run <code class="email">nw ./</code></li><li class="listitem">We can zip the two files to <code class="email">myapp.zip</code> for example, rename the archive to <code class="email">myapp.nw</code>, and run <code class="email">nw myapp.nw</code></li></ul></div><p class="calibre7">Once we are <a id="id634" class="calibre1"/>done programming, we can pack it along with the node-webkit executable. For end-users, this means not having to install additional software or download node-webkit separately. This makes the distribution much easier. There are some rules that we as developers should follow, for example, ship few <code class="email">.dll</code> file (under Windows OS) and license files. However, it's good to know that it is possible to pack the project and run it on other machines without installing dependencies. </p><p class="calibre7">The steps to do this depend on the operating system and are well-defined in the official <a id="id635" class="calibre1"/>documentation (<a class="calibre1" href="https://github.com/rogerwang/node-webkit">https://github.com/rogerwang/node-webkit</a>). As mentioned, node-webkit is based on Chromium. Generally, when we write a client-side JavaScript or CSS, we deal with a lot of problems because there are differences between the browsers. However, here we have only one browser and don't have to think about tricky workarounds. All we have to do is write code that works under Webkit. We can also use almost the same developer tools panel that we have in Google Chrome. After launching our application, we will see the following window— that is, a window produced by node-webkit:</p><div><img src="img/00070.jpeg" alt="Using node-webkit" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">There is a small <a id="id636" class="calibre1"/>button in the upper-right corner, which gives us access to the <strong class="calibre8">Elements</strong>, <strong class="calibre8">Network</strong>, <strong class="calibre8">Sources</strong>, <strong class="calibre8">Timeline</strong>, <strong class="calibre8">Profiles</strong>, <strong class="calibre8">Resources</strong>, <strong class="calibre8">Audits</strong>, and <strong class="calibre8">Console</strong> panels. When we click the button we will see a window like the one in the following screenshot:</p><div><img src="img/00071.jpeg" alt="Using node-webkit" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Having the same instruments simplifies the debugging and testing processes. As we pointed out at the beginning of this chapter, we don't have to learn a new language or use different technologies. We can stick to the usual HTML, CSS, and JavaScript.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec78" class="calibre1"/>Writing the base of the application</h1></div></div></div><p class="calibre7">Before starting the actual<a id="id637" class="calibre1"/> implementation of our file browser, we must prepare the HTML layout, the base of the JavaScript part, and the <code class="email">package.json</code> file.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec89" class="calibre1"/>Writing the package.json file</h2></div></div></div><p class="calibre7">The <code class="email">package.json</code> file should <a id="id638" class="calibre1"/>be placed in the main path of the project. It's a file <a id="id639" class="calibre1"/>with content similar to the following code:</p><div><pre class="programlisting">{
  "name": "FileBrowser",
  "main": "index.html",
  "window": {
    "toolbar": true,
    "width": 1024,
    "height": 800
  }
}</pre></div><p class="calibre7">We already discussed the <code class="email">name</code> and <code class="email">main</code> properties. The <code class="email">window</code> object is a desktop-specific setting; it tells node-webkit how the main application's window should look. In the preceding code, we set only three properties. The <code class="email">width</code> and <code class="email">height</code> properties defines the window size and <code class="email">toolbar</code> hides or shows the uppermost panel, the one that makes our program look like a browser. Usually, we don't need it and at the end of the development cycle, we set <code class="email">toolbar</code> to <code class="email">false</code>. There are few other options we can apply, for example, <code class="email">title</code> or <code class="email">icon</code>. We can even hide the close, maximize, and minimize buttons.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec90" class="calibre1"/>Preparing the HTML layout</h2></div></div></div><p class="calibre7">The HTML <a id="id640" class="calibre1"/>code we start<a id="id641" class="calibre1"/> with preparing the layout is as follows:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;FileBrowser&lt;/title&gt;
        &lt;link rel="stylesheet" href="css/styles.css"&gt;
        &lt;link rel="stylesheet" href="css/font-awesome-4.0.3/css/font-awesome.min.css"&gt;
        &lt;script src="img/scripts.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;section class="tree-area"&gt;
        &lt;div class="current-location"&gt;&lt;/div&gt;
        &lt;div class="tree"&gt;&lt;/div&gt;
      &lt;/section&gt;
        &lt;section class="file-info"&gt;&lt;/section&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">There are two CSS files. The first one, <code class="email">styles.css</code>, contains the styles written specifically for our application and the second one, uses the cool font icons from <code class="email">font-awesome</code>, icons that are represented by a font and not an image. The exact content of this resource is not included in this chapter, but you can find it in the additional material provided with the book.</p><p class="calibre7">Also, a <code class="email">scripts.js</code> file will host the JavaScript logic of the file browser.</p><p class="calibre7">The application<a id="id642" class="calibre1"/> has the <a id="id643" class="calibre1"/>following two parts:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre8">tree</strong>: This is where we will show the current directory's name and its content (files and folders)</li><li class="listitem"><strong class="calibre8">file info</strong>: If a file is selected, this area will show some of its characteristics and the buttons to copy, move, and delete</li></ul></div><p class="calibre7">If we run node-webkit with the preceding code, the result will be as follows:</p><div><img src="img/00072.jpeg" alt="Preparing the HTML layout" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec91" class="calibre1"/>Designing the JavaScript base</h2></div></div></div><p class="calibre7">Let's open <a id="id644" class="calibre1"/>the <code class="email">scripts.js</code> file and<a id="id645" class="calibre1"/> see how to structure the JavaScript code. At the beginning of the file, we define the required Node.js modules and a global variable, <code class="email">root</code>:</p><div><pre class="programlisting">var fs = require('fs');
var path = require('path');
var root = path.normalize(process.cwd());</pre></div><p class="calibre7">We use the <code class="email">fs</code> module for all filesystem-related operations. The <code class="email">path</code> module contains utility methods used to work with file paths. There are some differences between the operating systems for example, in Windows, the paths are written with a backslash, whereas in Linux, it uses a forward slash. The <code class="email">path.normalize</code> method takes care of this by correcting the string to it proper format depending on the OS.</p><p class="calibre7">The first folder we are going to read will be the directory the application is started in. Thus, we are use <code class="email">process.cwd()</code> to get the current working directory.</p><p class="calibre7">It's not a good practice to work in the global scope, so we will create a JavaScript class called <code class="email">Tree</code> using the following code:</p><div><pre class="programlisting">var Tree = function() {

  var api = {},
      el,
      currentLocationArea,
      treeArea,
      fileArea

  api.cwd = root;
  api.csf = null;

  api.init = function(selector) {
    el = document.querySelector(selector);
    currentLocationArea = el.querySelector('.current-location');
    treeArea = el.querySelector('.tree');
    fileArea = document.querySelector('.file-info');
    return api;
  }

  return api;
}</pre></div><p class="calibre7">The definition in the <a id="id646" class="calibre1"/>preceding code uses the revealing module <a id="id647" class="calibre1"/>pattern, which is a great pattern to encapsulate the JavaScript logic. The <code class="email">api</code> object is the public interface of the class and is returned at the end. The variables <code class="email">el</code>, <code class="email">currentLocationArea</code>, <code class="email">treeArea</code>, and <code class="email">fileArea</code> are private variables and represent the DOM elements on the page. They are initialized in the <code class="email">init</code> method. It's a good practice to cache the queries to the DOM. By storing the elements' references in local variables, we avoid the additional <code class="email">querySelector</code> calls.</p><p class="calibre7">There are two public properties: <code class="email">cwd</code> (current working directory) and <code class="email">csf</code> (current selected file). We make them public because we may need them outside the module. In the beginning, there is no selected file and the value of <code class="email">csf</code> is <code class="email">null</code>.</p><p class="calibre7">Similar to the development in the browser, we need an entry point. Our code is run in Chromium, so using <code class="email">window.onload</code> looks like a good choice. We will put our initializing code inside the <code class="email">onload</code> handler as follows:</p><div><pre class="programlisting">var FileBrowser;
window.onload = function() {
  FileBrowser = Tree().init('.tree-area');
}</pre></div><p class="calibre7">We simply create an<a id="id648" class="calibre1"/> instance of our class and call the <code class="email">init</code> method. We <a id="id649" class="calibre1"/>are passing the <code class="email">.tree-area</code> parameter, the selector of the <code class="email">&lt;section&gt;</code> tag, which will display the files.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec79" class="calibre1"/>Displaying and using the working directory</h1></div></div></div><p class="calibre7">In this section, we will cover the <a id="id650" class="calibre1"/>main features of our file browser. At the end, our <a id="id651" class="calibre1"/>application will read the current working directory. It will show its content and the user will be able to navigate between the shown folders.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec92" class="calibre1"/>Displaying the current working directory</h2></div></div></div><p class="calibre7">We put the <a id="id652" class="calibre1"/>value of <code class="email">api.cwd</code> in the div with the <code class="email">currentLocation</code> class. It is<a id="id653" class="calibre1"/> represented by the <code class="email">currentLocationArea</code> private variable. We only need a function that sets the <code class="email">innerHTML</code> property of the element:</p><div><pre class="programlisting">var updateCurrentLocation = function() {
  currentLocationArea.innerHTML = api.cwd;
}</pre></div><p class="calibre7">This is probably the simplest function of our class. We will call it every time we change the directory, which can happen pretty often. It's a good idea to delegate this calling to another method. Along with updating the current location area, we will refresh the files area too. So, it makes sense to write a <code class="email">render</code> function. At the moment, the method calls only <code class="email">updateCurrentLocation</code>, but we will add more functions later:</p><div><pre class="programlisting">var render = function() {
  updateCurrentLocation();
}
api.init = function(selector) {
  ...
  render();
  return api;
}</pre></div><p class="calibre7">Of course, we should call this <code class="email">render</code> function inside the <code class="email">init</code> method, which gives us the result as follows:</p><div><img src="img/00073.jpeg" alt="Displaying the current working directory" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Note that now our file <a id="id654" class="calibre1"/>browser shows the directory where the process <a id="id655" class="calibre1"/>starts from.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec93" class="calibre1"/>Showing the files and folders</h2></div></div></div><p class="calibre7">In this part of the chapter, we will <a id="id656" class="calibre1"/>create a function that shows all the files and<a id="id657" class="calibre1"/> folders placed inside the current <a id="id658" class="calibre1"/>working directory. This may sound like an excellent feature, but it <a id="id659" class="calibre1"/>comes with its own problems. The major one is if we go to the root of our filesystem, we have to show a large number of the items on the screen. So, instead of building a giant tree, we will stop at the third level of nesting. Let's add two new private variables:</p><div><pre class="programlisting">var html = '';
var maxLevels = 3;</pre></div><p class="calibre7">The <code class="email">html</code> variable will keep the string we apply to the <code class="email">innerHTML</code> property of the <code class="email">treeArea</code> element.</p><p class="calibre7">Our browser will process the files and the directories differently. If the user selects a file, then it should display information about it such as when was the file created, its size, and so on. Along with that our program will provide few buttons for operations such as copying, moving, or deleting the file. If a folder is clicked, then the <code class="email">api.cwd</code> variable should be changed and the <code class="email">render</code> method should be fired. The visual representation should also be different. The following function will add a new item to the tree:</p><div><pre class="programlisting">var addItem = function(itemPath, fullPath, isFile, indent) {
  itemPath = path.normalize(itemPath).replace(root, '');
  var calculateIndent = function() {
    var tab = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;', str = '';
    for(var i=0; i&lt;indent; i++) {
      str += tab;
    }
    return str;
  }
  if(isFile) {
    html += '&lt;a href="#" class="file" data-path="' + fullPath + '"&gt;';
    html += calculateIndent(indent) + '&lt;i class="fa fa-file-o"&gt;&lt;/i&gt; ' + itemPath + '&lt;/a&gt;';
  } else {
    html += '&lt;a href="#" class="dir" data-path="' + fullPath + '"&gt;';
    html += calculateIndent(indent) + '&lt;i class="fa fa-folder-o"&gt;&lt;/i&gt; ' + itemPath + '&lt;/a&gt;';
  }
}</pre></div><p class="calibre7">The <code class="email">itemPath</code> argument <a id="id660" class="calibre1"/>contains only the name of the file or directory, while <code class="email">fullPath</code> shows the absolute path to the item. Based on the <code class="email">isFile</code> parameter, <a id="id661" class="calibre1"/>the icon of the appended link is properly<a id="id662" class="calibre1"/> chosen. The latest <code class="email">indent</code> argument is needed to define the visual <a id="id663" class="calibre1"/>look of the tree. Without this, all the links will start from the left-hand side of the window. Note that we add the full path to the file or folder in a <code class="email">data-path</code> attribute. We do this because later any link can be clicked and we need to know what is selected.</p><p class="calibre7">Now, we need a function that uses the <code class="email">addItem</code> function, which accepts a path and goes through all the files and subdirectories. We also need some kind of recursive calling of the method so that we can produce a tree. As we can see in the following code, there is a check if we are reading directory and if yes then again the walk function is executed:</p><div><pre class="programlisting">var walk = function(dir, level, done) {
  if(level === maxLevels) {
    done(); 
    return;
  }
    fs.readdir(dir, function(err, list) {
      if (err) return done(err);
      var i = 0;
      (function next() {
          var file = list[i++];
          if(!file) return done();
        var filePath = dir + '/' + file;
        fs.stat(filePath, function(err, stat) {
            if (stat &amp;&amp; stat.isDirectory()) {
              addItem(file, filePath, false, level);
                walk(filePath, level + 1, function() {                      
                  next();
                });
            } else {
              if(level === 0) {
                  addItem(file, filePath, true, level);
                }
                next();
            }
        });
      })();
    });
};</pre></div><p class="calibre7">Because the <code class="email">walk</code> function will be called repeatedly, we need to check whether it reaches the maximum level of nesting (which in our case is set to <code class="email">3</code>); this is the purpose of the first few lines. Immediately after, the <code class="email">fs.readdir</code> function is called. This is an asynchronous Node.js native function <a id="id664" class="calibre1"/>that returns the content in a passed directory. In the closure, which<a id="id665" class="calibre1"/> receives the data, we will go through every result and check whether the item is a file or folder. If it is a folder, then the <code class="email">walk</code> function is called again. Note that we are passing the level and it is incremented on every call.</p><p class="calibre7">At the end, we just <a id="id666" class="calibre1"/>need to run the <code class="email">walk</code> method and populate the <code class="email">html</code> variable <a id="id667" class="calibre1"/>with an initial value as it is done in the following code:</p><div><pre class="programlisting">var updateFiles = function() {
  html = '&lt;a href="#" class="dir" data-path="' + path.normalize(api.cwd + '/../') + '"&gt;&lt;i class="fa fa-level-up"&gt;&lt;/i&gt; ..&lt;/a&gt;';
  walk(api.cwd, 0, function() {
    treeArea.innerHTML = html;
  });
}</pre></div><p class="calibre7">At the top of the file's tree, we added a link that points to the parent directory. This is how the user can move upward in the filesystem.</p><p class="calibre7">The updated render method is as follows:</p><div><pre class="programlisting">var render = function() {
  updateCurrentLocation();
  updateFiles();
}</pre></div><p class="calibre7">As we can see, the <code class="email">updateFiles</code> method is called pretty often. It's kind of an expensive process because it runs the <code class="email">walk</code> function. This is also one of the reasons behind limiting the folder's nesting. If we launch the application now, we should see the current directory at the top of the screen and its content in the <code class="email">treeArea</code> element. The following screenshot is how this looks on the screen:</p><div><img src="img/00074.jpeg" alt="Showing the files and folders" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec94" class="calibre1"/>Changing the current directory</h2></div></div></div><p class="calibre7">Our file browser <a id="id668" class="calibre1"/>successfully shows the files located on our hard disk. The next<a id="id669" class="calibre1"/> thing we want to do is to jump from one folder to another. Because we carefully designed our class, it is easy to implement this feature. The following two steps will change the directory:</p><div><ul class="itemizedlist"><li class="listitem">Update the <code class="email">api.cwd</code> variable</li><li class="listitem">Call the <code class="email">render</code> method</li></ul></div><p class="calibre7">These two actions should be executed when the user clicks on some of the items in the tree. The very popular approach is to attach a <code class="email">click</code> handler on every link and listen for user interaction. However, this will lead to some problems. We have to reassign the listeners every time the tree is updated; this is because the elements that the listeners are attached to have been replaced and are no longer in the DOM. A much better approach is to add only one handler on the <code class="email">treeArea</code> element. When its children produce the <code class="email">click</code> event, by default, it is bubbled upwards over the DOM. Moreover, because we do not catch it, it reaches the handler of the <code class="email">treeArea</code> element. So the following <code class="email">setEvents</code> function listens for the click events triggered in the <code class="email">treeArea</code> object:</p><div><pre class="programlisting">var setEvents = function() {
  treeArea.addEventListener('click', function(e) {
    e.preventDefault();
    if(e.target.nodeName !== 'A' &amp;&amp; e.target.nodeName !== 'I') return;
    var link = e.target.nodeName === 'A' ? e.target : e.target.parentNode;
    var itemPath = path.normalize(link.getAttribute('data-path'));
    var isFile = link.getAttribute('class') === 'file';
    if(isFile) {
      updateFileArea(itemPath);  
    } else {
      api.cwd = itemPath;
      render();
    }
  });
}</pre></div><p class="calibre7">The calling of <code class="email">e.preventDefault</code> is needed because we don't want the default link behavior. The <code class="email">href</code> attribute of all the <code class="email">&lt;a&gt;</code> tags is set to <code class="email">#</code>. Normally, this will scroll the page up to the top. However, we don't want this to happen, so we call <code class="email">e.preventDefault</code>. The <a id="id670" class="calibre1"/>next check guarantees that the <code class="email">click</code> event comes<a id="id671" class="calibre1"/> from the right element. This is actually really important because the user may click on some other element, which is still the child of <code class="email">treeArea</code>. We expect to get the <code class="email">&lt;a&gt;</code> or <code class="email">&lt;i&gt;</code> (the icon inside the link) tag. The path to the file or folder is from the <code class="email">data-path</code> attribute. To determine whether the currently selected item is a file, we check the value of its <code class="email">class</code> attribute. On the other hand, if the user clicks on a folder, we simple trigger the <code class="email">render</code> method; otherwise, a new function, <code class="email">updateFileArea</code>, is called.</p><p class="calibre7">The function we just discussed (<code class="email">setEvents</code>) is fired only once, and a proper place to do this is the <code class="email">init</code> method:</p><div><pre class="programlisting">api.init = function(selector) {
  ...
  setEvents();
  return api;
}</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec95" class="calibre1"/>Copying, moving, and deleting files</h2></div></div></div><p class="calibre7">We implemented the<a id="id672" class="calibre1"/> folder switching, and the last thing to do is file <a id="id673" class="calibre1"/>processing. We already mentioned <a id="id674" class="calibre1"/>calling the <code class="email">updateFileArea </code>function. It <a id="id675" class="calibre1"/>should<a id="id676" class="calibre1"/> accept the <a id="id677" class="calibre1"/>file path. The following code is the body of the function:</p><div><pre class="programlisting">var updateFileArea = function(itemPath) {
  var html = '';
  api.csf = itemPath;
  if(itemPath) {
    fs.stat(itemPath, function(err, stat) {
      html += '&lt;h3&gt;' + path.basename(itemPath) + '&lt;/h3&gt;';
      html += '&lt;p&gt;path: ' + path.dirname(itemPath) + '&lt;/p&gt;';
      html += '&lt;p class="small"&gt;size: ' + stat.size + ' bytes&lt;/p&gt;';
      html += '&lt;p class="small"&gt;last modified: ' + stat.mtime + '&lt;/p&gt;';
      html += '&lt;p class="small"&gt;created: ' + stat.ctime + '&lt;/p&gt;';
      html += '&lt;a href="javascript:FileBrowser.copy()"&gt;&lt;i class="fa fa-copy"&gt;&lt;/i&gt; Copy&lt;/a&gt;';
      html += '&lt;a href="javascript:FileBrowser.move()"&gt;&lt;i class="fa fa-share"&gt;&lt;/i&gt; Move&lt;/a&gt;';
      html += '&lt;a href="javascript:FileBrowser.del()"&gt;&lt;i class="fa fa-times"&gt;&lt;/i&gt; Delete&lt;/a&gt;';
      fileArea.innerHTML = html;  
    });  
  } else {
    fileArea.innerHTML = '';
  }
}</pre></div><p class="calibre7">The function of the <a id="id678" class="calibre1"/>method is to fill the <code class="email">fileArea</code> element <a id="id679" class="calibre1"/>with information about the file. We will use the <a id="id680" class="calibre1"/>same function to clear the <code class="email">fileArea</code> element <a id="id681" class="calibre1"/>when the user clicks on a folder. So, if <code class="email">updateFileArea</code> is <a id="id682" class="calibre1"/>called without any parameter, the information block becomes empty. The file size and created and modified time are available because of the native Node.js <a id="id683" class="calibre1"/>function <code class="email">fs.stat</code>. Below the file's characteristics, we place three buttons. Every button calls a method of the global <code class="email">FileBrowser</code> object, which is an instance of our <code class="email">Tree</code> class. Note that we do not pass the path to the file. The <code class="email">copy</code>, <code class="email">move</code>, and <code class="email">del</code> functions will get this information from the <code class="email">api.csf</code> variable that we filled earlier. The following method will be used to copy a file from one place to another:</p><div><pre class="programlisting">api.copy = function() {
  if(!api.csf) return;
    getFolder(function(dir) {
      var file = path.basename(api.csf);
      fs.createReadStream(api.csf).pipe(fs.createWriteStream(dir + '/' + file));
      api.csf = null;
      updateFileArea();
      alert('File: ' + file + ' copied.');
    });
}</pre></div><p class="calibre7">So, we know the file we want to copy, move, or delete and its absolute path. It is stored in <code class="email">api.csf</code>. To copy and move, we need a destination path. The user should be able to pick a directory on the hard disk, and because this process occurs in two locations, it is a good idea to wrap it in a function—<code class="email">getFolder</code>. Once this method returns the destination, we simply get the content as a stream and save it to another place. The following is the body of the <code class="email">getFolder</code> helper:</p><div><pre class="programlisting">var getFolder = function(callback) {
   var event = new MouseEvent('click', {
      'view': window,
      'bubbles': true,
       'cancelable': true
   });
    var input = document.createElement('INPUT');
    input.setAttribute('type', 'file');
    input.setAttribute('webkitdirectory', 'webkitdirectory');
    input.addEventListener('change', function (e) {
      callback(this.value);
  });
    input.dispatchEvent(event);
}</pre></div><p class="calibre7">Normally, the <a id="id684" class="calibre1"/>dialog to select a directory cannot be opened <a id="id685" class="calibre1"/>without user interaction. However, in node-webkit this is possible. As we can see in the preceding code, we create a new <code class="email">MouseEvent</code> event <a id="id686" class="calibre1"/>and a new <code class="email">&lt;input&gt;</code> element to dispatch this event. The <a id="id687" class="calibre1"/>key factor here is the <code class="email">webkitdirectory </code>attribute, which is node-webkit <a id="id688" class="calibre1"/>specific, and it transforms the element from  a file selector to a folder selector. The <code class="email">getFolder</code> function accepts a <code class="email">callback</code> function, which is called <a id="id689" class="calibre1"/>once the user selects a directory.</p><p class="calibre7">The function that deletes a file looks like following code snippet:</p><div><pre class="programlisting">api.del = function() {
  if(!api.csf) return;
  fs.unlink(api.csf, function() {
      alert('File: ' + path.basename(api.csf) + ' deleted.');
      render();
       api.csf = null;
    });
}</pre></div><p class="calibre7">The function that deletes the file is almost the same, except that it uses <code class="email">fs.unlink</code> to remove the file from the OS. At the end, the method that moves the file, combines both the <code class="email">copy</code> and <code class="email">del</code> functions.</p><div><pre class="programlisting">api.move = function() {
  if(!api.csf) return;
    getFolder(function(dir) {
      var file = path.basename(api.csf);
      fs.createReadStream(api.csf).pipe(fs.createWriteStream(dir + '/' + file));
      fs.unlink(api.csf, function() {
          alert('File: ' + file + ' moved.');
          render();
          api.csf = null;
      });
    });
}</pre></div><p class="calibre7">We need to copy the<a id="id690" class="calibre1"/> file<a id="id691" class="calibre1"/> and then delete it from the original location. With this last<a id="id692" class="calibre1"/> addition, our file browser is finished. The <a id="id693" class="calibre1"/>following <a id="id694" class="calibre1"/>screenshot shows how it looks when a file is <a id="id695" class="calibre1"/>selected:</p><div><img src="img/00075.jpeg" alt="Copying, moving, and deleting files" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec80" class="calibre1"/>Extending the application</h1></div></div></div><p class="calibre7">Our file browser looks good so <a id="id696" class="calibre1"/>far. We can see the folders and files on our machine and can copy, move, or delete them. Also, we did all this with only HTML, CSS, and JavaScript. Let's continue and add a new feature. The application we wrote is run by Chromium. In other words, our HTML and CSS are rendered by the browser, so we can easily show images in it. In the next few pages, we will create a program picture viewer.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec96" class="calibre1"/>Tweaking the updateFileArea function</h2></div></div></div><p class="calibre7">The first thing to do is find<a id="id697" class="calibre1"/> out whether the currently selected file is an image. We <a id="id698" class="calibre1"/>will display the JPEG and PNG files, so we should check whether the file matches one of these extensions. Before populating the <code class="email">html</code> variable with the markup, we will extract the file's extension as it is done in the code below:</p><div><pre class="programlisting">var updateFileArea = function(itemPath) {
  var html = '';
  api.csf = itemPath;
  if(itemPath) {
    fs.stat(itemPath, function(err, stat) {
      var ext = path.extname(itemPath).toLowerCase();
      var isImage = ext === '.jpg' || ext === '.jpeg' || ext === '.png';
      html += '&lt;h3&gt;' + path.basename(itemPath) + '&lt;/h3&gt;';
      html += '&lt;p&gt;path: ' + path.dirname(itemPath) + '&lt;/p&gt;';
      html += '&lt;p class="small"&gt;size: ' + stat.size + ' bytes&lt;/p&gt;';
      html += '&lt;p class="small"&gt;last modified: ' + stat.mtime + '&lt;/p&gt;';
      html += '&lt;p class="small"&gt;created: ' + stat.ctime + '&lt;/p&gt;';
      if(isImage) {
        html += '&lt;a href="javascript:FileBrowser.viewImage()"&gt;&lt;i class="fa fa-picture-o"&gt;&lt;/i&gt; View image&lt;/a&gt;';  
      }
      html += '&lt;a href="javascript:FileBrowser.copy()"&gt;&lt;i class="fa fa-copy"&gt;&lt;/i&gt; Copy&lt;/a&gt;';
      html += '&lt;a href="javascript:FileBrowser.move()"&gt;&lt;i class="fa fa-share"&gt;&lt;/i&gt; Move&lt;/a&gt;';
      html += '&lt;a href="javascript:FileBrowser.del()"&gt;&lt;i class="fa fa-times"&gt;&lt;/i&gt; Delete&lt;/a&gt;';
      fileArea.innerHTML = html;  
    });  
  } else {
    fileArea.innerHTML = '';
  }
}</pre></div><p class="calibre7">The next addition to the function is a button that is shown only if a picture is selected. At this point (when we have four buttons), it is good to make some changes in the layout to get all the buttons in one line. So far, the links were the <code class="email">block</code> elements and making them <code class="email">inline-block</code> solves the <a id="id699" class="calibre1"/>problem. The following screenshot<a id="id700" class="calibre1"/> shows the result:</p><div><img src="img/00076.jpeg" alt="Tweaking the updateFileArea function" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec97" class="calibre1"/>Loading a new page for the selected image</h2></div></div></div><p class="calibre7">Similar to the other three links, the <a id="id701" class="calibre1"/>new one calls a function of the global <code class="email">FileBrowser</code> object—<code class="email">FileBrowser.viewImage</code>:</p><div><pre class="programlisting">api.viewImage = function() {
  window.open('image.html?file=' + api.csf, '_blank', 'width=600,height=400');
}</pre></div><p class="calibre7">Preferably, open the image in a new window. To do this, use the <code class="email">window.open</code> method. This function is available in every browser. It simply loads a specific file/URL in a newly created pop up. As shown in the preceding code, the page that will be shown is stored in file called <code class="email">image.html</code>. Also the picture's path is sent as a <code class="email">GET</code> parameter and we will read it later. The following is the code in the new file:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;FileBrowser&lt;/title&gt;
        &lt;link rel="stylesheet" href="css/styles.css"&gt;
        &lt;script src="img/imageviewer.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;div class="image-viewer"&gt;
            &lt;img src="" /&gt;
            &lt;div class="dimension"&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">There are only two things on the page. An empty <code class="email">&lt;img&gt;</code> tag and an empty <code class="email">&lt;div&gt;</code> tag, which will display the dimensions of the picture. We should mention that this new page has nothing to do with the <code class="email">index.html</code> file and the <code class="email">Tree</code> class, which we used so far. It's a completely new <a id="id702" class="calibre1"/>section controlled by another JavaScript file—<code class="email">imageviewer.js</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec98" class="calibre1"/>Showing the image and its dimensions</h2></div></div></div><p class="calibre7">There are two <a id="id703" class="calibre1"/>difficulties we have to solve. They<a id="id704" class="calibre1"/> are as follows:</p><div><ul class="itemizedlist"><li class="listitem">The picture's path is sent via the page's URL, so we should get it from there.</li><li class="listitem">The picture's dimensions can be read from a client-side JavaScript, but only if the image is fully loaded. So, we will use Node.js.</li></ul></div><p class="calibre7">The <code class="email">imageviewer.js</code> file will contain a class similar to the <code class="email">scripts.js</code> file.</p><div><pre class="programlisting">var sizeOf = require('image-size'),
    fs = require('fs'),
    path = require('path');

var ImageViewer = function() {
  var api = {};
   // ...
  return api;
}

var Viewer;
window.onload = function() {
  Viewer = ImageViewer();
}</pre></div><p class="calibre7">At the start of the file, we defined the Node.js modules we are going to use, <code class="email">fs</code> and <code class="email">path</code>, which have been discussed throughout this chapter. However, <code class="email">image-size</code> is a new module. It accepts an image path and returns its width and height. It's not a native Node.js module, so we have to include it in our <code class="email">package.json</code> file.</p><div><pre class="programlisting">{
  "name": "FileBrowser",
  "main": "index.html",
  "window": {
    "toolbar": true,
    "width": 690,
    "height": 900
  },
  "dependencies": {
    "image-size": "0.2.3"
  }
}</pre></div><p class="calibre7">The node-webkit app runtime uses the same dependency format, and we have to call <code class="email">npm install</code> to get the module installed in a local <code class="email">node_modules</code> directory. Also, keep in mind that the application's packing at the end should include the <code class="email">node_modules</code> folder. Once everything is set up, we are ready to show the selected picture. That's achieved with the following code:</p><div><pre class="programlisting">var filePath = decodeURI(location.search.split('file=')[1]);
if(fs.existsSync(path.normalize(filePath))) {
  var img = document.querySelector('.image-viewer img');
  img.setAttribute('src', 'file://' + filePath);
  var dimensions = sizeOf(filePath);
  document.querySelector('.dimension').innerHTML = 'Dimension: ' + dimensions.width + 'x' + dimensions.height;
}</pre></div><p class="calibre7">The <code class="email">location.search</code> function returns the current URL of the page. We know that there is only<a id="id705" class="calibre1"/> one parameter called <code class="email">file</code>, so we can<a id="id706" class="calibre1"/> split the string and use only the second element of the array, the parameter we are interested in. We have to use <code class="email">decodeURI</code> because the path is URL encoded and we could receive a wrong value. For example, the interval is normally replaced by <code class="email">%20</code>.</p><p class="calibre7">We check whether the file actually exists and determine its dimensions. The rest involves showing the image and displaying the size as a text below the <code class="email">&lt;img&gt;</code> tag. The following screenshot shows how the window may look like:</p><div><img src="img/00077.jpeg" alt="Showing the image and its dimensions" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec99" class="calibre1"/>Removing the toolbar</h2></div></div></div><p class="calibre7">The final <a id="id707" class="calibre1"/>thing we to do is hide the node-webkit toolbar. The user should not be able to see the currently opened file. We can do that by changing the <code class="email">package.json</code> file using the following code:</p><div><pre class="programlisting">{
  "name": "FileBrowser",
  "main": "index.html",
  "window": {
    "toolbar": false,
    "width": 690,
    "height": 900
  },
  "dependencies": {
    "image-size": "0.2.3"
  }
}</pre></div><p class="calibre7">Setting the <code class="email">toolbar</code> property to <code class="email">false</code> changes our application and now it looks more like a desktop program, as shown in the following screenshot:</p><div><img src="img/00078.jpeg" alt="Removing the toolbar" class="calibre10"/></div><p class="calibre11"> </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec81" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this last chapter of the book, you learned how to build a desktop file browser with Node.js. The most interesting aspect is that we used only HTML, CSS, and JavaScript. This is because, more often than not, Node.js is used in backend development. We explored a realm of possibilities that this wonderful technology offers. It works as a command-line tool, task runner, or even wrapper for desktop applications. The big open-source community and the well-made package manager make Node.js a powerful instrument for developers around the world.</p></div></body></html>