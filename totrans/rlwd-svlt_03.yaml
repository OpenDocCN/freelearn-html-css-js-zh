- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Managing Props and State
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理属性和状态
- en: In the world of web development, managing data effectively is crucial. Whether
    it’s the information that flows between components or the internal state of a
    component, proper data management is the backbone of a functional and responsive
    web application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发的世界里，有效地管理数据至关重要。无论是组件之间的信息流还是组件的内部状态，适当的数据管理是功能性和响应式网络应用程序的基石。
- en: In this chapter, we will delve into the core concepts of managing props and
    state within a Svelte application. First, we’ll clarify what props and states
    in Svelte are, laying the groundwork for understanding more advanced topics. We
    then explore the concept of bindings, a feature in Svelte for keeping state and
    element values or component props in sync.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究在 Svelte 应用程序中管理属性和状态的核心概念。首先，我们将明确 Svelte 中的属性和状态是什么，为理解更高级的主题打下基础。然后，我们将探讨绑定的概念，这是
    Svelte 中用于保持状态和元素值或组件属性同步的功能。
- en: We’ll then explore data flow within components, highlighting the differences
    between one-way data flow and two-way data flow and why they matter. Moving on,
    we’ll discuss how to derive state from props using Svelte’s reactive declarations.
    To conclude, we’ll offer tips for managing complex derived states and explain
    how to update props based on those derived states.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨组件内的数据流，突出单向数据流和双向数据流之间的差异以及它们为什么重要。接下来，我们将讨论如何使用 Svelte 的响应式声明从属性派生状态。最后，我们将提供管理复杂派生状态的技巧，并解释如何根据这些派生状态更新属性。
- en: By the end of the chapter, you’ll have a solid understanding of how to manage
    data within a Svelte component, being equipped with practical tips and strategies
    to tackle common challenges effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将牢固地理解如何在 Svelte 组件中管理数据，并掌握实用的技巧和策略来有效地应对常见挑战。
- en: 'In this chapter, you will learn the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Defining props and state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义属性和状态
- en: Understanding bindings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解绑定
- en: One-way versus two-way data flow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向与双向数据流
- en: Deriving states from props with a reactive declaration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式声明从属性派生状态
- en: Managing complex derived states
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理复杂的派生状态
- en: Updating props using derived states
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用派生状态更新属性
- en: Before we start to talk about props and state, let’s first define what props
    and state are in Svelte.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论属性和状态之前，让我们首先定义在 Svelte 中属性和状态是什么。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find all the code samples used in this chapter on GitHub at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章中使用的所有代码示例：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03)
- en: Defining props and state
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义属性和状态
- en: In Svelte, both props and state are used to manage data within components. Props
    are a way to pass data from a parent component to a child component. This makes
    the child component flexible and reusable, as it can get different data from the
    parent as needed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Svelte 中，属性和状态都用于在组件内管理数据。属性是一种将数据从父组件传递到子组件的方式。这使得子组件更加灵活和可重用，因为它可以根据需要从父组件获取不同的数据。
- en: On the other hand, state is data that is initialized and managed internally
    within a component, unlike props, which are received from an external source.
    State allows a component to be self-contained and modular.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，状态是在组件内部初始化和管理的内部数据，与从外部来源接收的属性不同。状态允许组件自包含和模块化。
- en: Defining props
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义属性
- en: Let’s start with props. Props in Svelte are defined using the `export` keyword.
    When you export a variable in a Svelte component, it becomes a prop that you can
    pass data to from a parent component.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从属性开始。在 Svelte 中，属性使用 `export` 关键字定义。当你在一个 Svelte 组件中导出一个变量时，它就变成了一个可以传递数据的属性，你可以从父组件传递数据。
- en: 'Here is a simple example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code snippet, we defined a Svelte component in a file named
    `Child.svelte`. In the Svelte component, `message` is a prop. You can pass data
    to `message` from a parent component like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在名为 `Child.svelte` 的文件中定义了一个 Svelte 组件。在 Svelte 组件中，`message` 是一个属性。你可以从父组件传递数据到
    `message`，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code snippet, we define another Svelte component in a file
    named `Parent.svelte`. In the component, we import and use the `Child` component
    from `Child.svelte`. As the `Parent` component includes the `Child` component,
    the `Parent` component is considered the parent component of the imported `Child`
    component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在名为 `Parent.svelte` 的文件中定义了另一个 Svelte 组件。在这个组件中，我们导入并使用来自 `Child.svelte`
    的 `Child` 组件。由于 `Parent` 组件包含了 `Child` 组件，因此 `Parent` 组件被认为是导入的 `Child` 组件的父组件。
- en: In the parent component, you can set the `message` props of the child component
    to the value `"Hello, World!"` by passing `"Hello, World!"` through the `message`
    attribute of the `<Child />` component, as shown in the preceding code snippet.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在父组件中，你可以通过 `<Child />` 组件的 `message` 属性传递 `"Hello, World!"` 来设置子组件的 `message`
    道具，如前面的代码片段所示。
- en: In summary, props are defined using the `export` keyword, and their values are
    passed from the parent component to the child component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，道具是通过 `export` 关键字定义的，它们的值是从父组件传递到子组件的。
- en: Defining state
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义状态
- en: Next, let’s look at the state. State is any data that is used and managed within
    a component. It is not passed in from a parent component like props. Instead,
    it is defined within the component itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看状态。状态是任何在组件内部使用和管理的数据。它不像道具那样从父组件传递进来。相反，它是在组件内部定义的。
- en: 'Here’s an example that illustrates state:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个说明状态的例子：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `count` is a state variable. It’s not passed in as a prop but
    is defined and managed within the `Counter` component. When you click the button,
    the `increment` function is called, which modifies the `count` state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`count` 是一个状态变量。它不是作为道具传递的，而是在 `Counter` 组件内部定义和管理的。当你点击按钮时，会调用 `increment`
    函数，该函数修改 `count` 状态。
- en: In summary, props are variables that are passed into a component from a parent
    component, whereas the state is data that is managed within a component itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，道具是从父组件传递到组件的变量，而状态是组件内部管理的数据。
- en: Props versus state
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 道具与状态
- en: If you look closely, both props and state represent data. The difference between
    them depends on the context of the component you are considering.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，道具和状态都代表数据。它们之间的区别取决于你考虑的组件的上下文。
- en: For example, let’s consider two components, component `A` and component `B`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑两个组件，组件 `A` 和组件 `B`。
- en: 'Let’s begin with component `A`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从组件 `A` 开始：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In component `A`, we define a props called `height`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件 `A` 中，我们定义了一个名为 `height` 的道具。
- en: 'Now take a look at component `B`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看组件 `B`：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In component `B`, we define a state called `height` and pass its value as a
    prop to component `A`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件 `B` 中，我们定义了一个名为 `height` 的状态，并将其值作为道具传递给组件 `A`。
- en: From the perspective of component `B`, `height` is considered a state, but from
    the viewpoint of component `A`, it’s considered a prop. Whether a variable is
    a prop or a state depends on the context of the component in which it is being
    viewed. At their core, they are essentially the same thing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从组件 `B` 的角度来看，`height` 被视为状态，但从组件 `A` 的角度来看，它被视为道具。一个变量是道具还是状态取决于它被查看的组件的上下文。在本质上，它们基本上是同一件事。
- en: In this example, due to the way JavaScript passes primitive variables by value,
    it may not be immediately obvious that the `height` variable in both component
    `A` and component `B` refers to the same thing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于 JavaScript 以值的方式传递原始变量，可能不会立即明显地看出组件 `A` 和组件 `B` 中的 `height` 变量指向同一件事。
- en: However, if we define an object as state and pass it to another component through
    props, it becomes clear that both the state in one component and the props in
    the other component refer to the same object reference.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们定义一个对象作为状态并通过道具传递给另一个组件，那么就会变得明显，一个组件中的状态和另一个组件中的道具都指向同一个对象引用。
- en: 'Let’s modify our example to illustrate this point:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的例子来说明这一点：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code snippet, I’ve added a `setInterval` function to print out the value
    of the `height` variable every second in both components. In component `B`, I’ve
    modified the state `height` to be an object. Because objects in JavaScript are
    passed by reference, the state `height` in component `B` that is passed as a prop
    to component `A` is passed by reference as well. This means the `height` prop
    in component `A` is referencing the same object as the state `height` in component
    `B`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我添加了一个 `setInterval` 函数，每秒钟在两个组件中打印出 `height` 变量的值。在组件 `B` 中，我将状态 `height`
    修改为对象。因为 JavaScript 中的对象是通过引用传递的，所以作为属性传递给组件 `A` 的组件 `B` 中的状态 `height` 也是通过引用传递的。这意味着组件
    `A` 中的 `height` 属性引用的是与组件 `B` 中的状态 `height` 相同的对象。
- en: 'If we add a `<button>` element in component `B` to mutate the `height` object,
    as shown here, you’ll be able to see that both component `A` and component `B`
    print out the same updated value of the `height` variable in the console. This
    is because they are printing out the value of the same object reference:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在组件 `B` 中添加一个 `<button>` 元素来修改 `height` 对象，如下所示，你将能够看到组件 `A` 和 `B` 都会在控制台中打印出相同的更新后的
    `height` 变量值。这是因为它们打印的是相同对象引用的值：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Clicking on the button from the preceding code snippet will result in the console
    printing out `A: { value: 110 }` and `B: { value: 110 }`. This demonstrates that
    the `height` variable in both components `A` and `B` refer to the same object
    reference. When `height.value` is changed to `110` in component `B`, the change
    is also reflected in the `height` variable in component `A`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '点击前面代码片段中的按钮会导致控制台打印出 `A: { value: 110 }` 和 `B: { value: 110 }`。这表明组件 `A` 和
    `B` 中的 `height` 变量引用的是相同的对象引用。当组件 `B` 中的 `height.value` 更改为 `110` 时，这个变化也会反映在组件
    `A` 中的 `height` 变量上。'
- en: Now that we understand what props and state are in Svelte, let’s talk about
    bindings next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Svelte 中的 props 和状态是什么，接下来让我们谈谈绑定。
- en: Understanding bindings
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解绑定
- en: Bindings in Svelte allow you to keep the value of a component’s state in sync
    with the value of an `<input />` element. If the state changes, the input updates;
    conversely, if the input changes, the state updates as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 中的绑定允许你保持组件状态值与 `<input />` 元素值的同步。如果状态发生变化，输入会更新；反之，如果输入发生变化，状态也会更新。
- en: 'The following code snippet is an example of creating a binding in Svelte:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是创建 Svelte 中绑定的一个示例：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bindings are created through the `bind:` directive. In the preceding code snippet,
    the input element’s value is bound to the `name` variable. When you type in the
    input, the `name` variable will update automatically. Conversely, when you change
    the value of the `name` variable, the input element’s value will also automatically
    update.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是通过 `bind:` 指令创建的。在前面代码片段中，输入元素的值被绑定到 `name` 变量。当你输入时，`name` 变量将自动更新。反之，当你更改
    `name` 变量的值时，输入元素的值也会自动更新。
- en: As demonstrated, bindings create a two-way data flow, enabling data changes
    to propagate from the element to the component state, and from the component state
    into the element.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，绑定创建了一个双向数据流，使得数据变化可以从元素传播到组件状态，以及从组件状态传播到元素。
- en: 'The previous example demonstrates binding on elements, but bindings can also
    work on components. You can use the `bind:` directive to link the props of a component
    with your component’s state, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子演示了在元素上的绑定，但绑定也可以在组件上工作。你可以使用 `bind:` 指令将组件的属性与你的组件状态链接起来，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code snippet, we bind the `username` props of the `<Profile>`
    component to the `name` state variable. When you update the `name` state variable,
    the value of the `username` prop will automatically reflect the new value; conversely,
    if you update the value of the `username` prop from within the `<Profile>` component,
    the value of the `name` state variable will automatically update to match.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `<Profile>` 组件的 `username` 属性绑定到 `name` 状态变量。当你更新 `name` 状态变量时，`username`
    属性的值将自动反映新的值；反之，如果你在 `<Profile>` 组件内部更新 `username` 属性的值，`name` 状态变量的值也会自动更新以匹配。
- en: 'To further demonstrate this behavior, let’s make a slight modification to the
    code. Here’s the updated version of the component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步演示这种行为，让我们对代码进行一些小的修改。这是组件的更新版本：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <script>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: export let username;
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: export let username;
- en: </script>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: '<p>Name in Profile: {username}</p>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <p>Profile 中的名称：{username}</p>
- en: <button on:click={() => username = "World"}>Update from Profile</button>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<!-- filename: B.svelte -->'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<!-- filename: A.svelte -->'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: import B from './B.svelte';
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: let data;
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <B value={data} />
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<!-- filename: D.svelte -->'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<!-- filename: C.svelte -->'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: import D from './D.svelte';
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: let data;
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: <D bind:value={data} />
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <DateLabel date={new Date(2023,5,5)} />
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<!-- filename: DateLabel.svelte -->'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: export let date;
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: // Deriving the 'label' variable from the 'date' prop
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: let label = date.toLocaleDateString();
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: <label>{label}</label>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<!-- filename: DateLabel.svelte -->'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: export let date;
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: // Deriving the 'label' variable from the 'date' prop
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '$: label = date.toLocaleDateString();'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <DateLabel date={new Date(2023, 5, 5)} locale="de-DE" />
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <script>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: export let date;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: export let locale;
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: // Reactive declaration with multiple dependencies
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '$: label = date.toLocaleDateString(locale);'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: <label>{label}</label>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <script>
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let valueA;
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let valueB;
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: valueC = valueA + 5;'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: valueD = valueB + valueC;'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: valueC = Math.min(valueC, valueD / 2);'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Upon observing the data flow, we can see that valueC depends on valueA, valueD
    depends on both valueB and valueC, and then valueC in turn depends on valueD.
    Consequently, it’s unclear how valueC is actually calculated, it could be either
    valueA + 5 or the minimum of valueC and valueD / 2. Such complexity makes the
    code hard to understand and increases the likelihood of bugs.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <script>
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let a;
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: b = a * 2;'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: c = b * 2;'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b is declared reactively before c. However, it behaves identically to the following
    snippet, where c is declared before b. Let’s look at the next one:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <script>
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let a;
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: c = b * 2;'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: b = a * 2;'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <script>
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let data;
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: data = data ?? 100;'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead, it’s better to declare a new state variable to manage this behavior:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <script>
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let data;
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: dataWithDefault = data ?? 100;'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <script>
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let value;
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: double = value * 2;'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: triple = value * 3;'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <input bind:value={double} type="number" />
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <input bind:value={triple} type="number" />
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <script>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '$: double = value * 2;'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '$: triple = value * 3;'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '$: value = double / 2;'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '$: value = triple / 3;'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <input bind:value={double} type="number" />
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: <input bind:value={triple} type="number" />
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <script>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '$: double = value * 2;'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '$: triple = value * 3;'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '$: updateValueFromDouble(double);'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '$: updateValueFromTriple(triple);'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: function updateValueFromDouble(double) {
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: value = double / 2;
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: function updateValueFromTriple(triple) {
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: value = triple / 3;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: <input bind:value={double} type="number" />
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: <input bind:value={triple} type="number" />
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <script>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '$: double = value * 2;'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '$: triple = value * 3;'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: function updateValueFromDouble(double) {
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: value = double / 2;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: function updateValueFromTriple(triple) {
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: value = triple / 3;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: <input value={double} type="number" on:change={e => updateValueFromDouble(e.target.value)}
    />
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input value={double} type="number" on:change={e => updateValueFromDouble(e.target.value)}
    />`'
- en: <input value as the sole source of truth. Instead of binding the input elements
    directly to double and triple, we’ve added event listeners that update value based
    on user input. This change automatically updates double and triple through reactive
    declarations, which then refresh the displayed values in the input fields.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input value as the sole source of truth. Instead of binding the input elements
    directly to double and triple, we’ve added event listeners that update value based
    on user input. This change automatically updates double and triple through reactive
    declarations, which then refresh the displayed values in the input fields.`'
- en: 'With the updated code, the data flow is now streamlined, as shown in the following
    diagram:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新的代码，数据流现在已简化，如下面的图所示：
- en: '![](img/B18887_03_5.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18887_03_5.jpg)'
- en: 'Figure 3.5: Data flows between props, states, and the input elements'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：props、states和输入元素之间的数据流
- en: The values for `double` and `triple` are directly derived from `value`, which
    then populates the input fields. When you modify the input, it alters `value`
    directly, which in turn automatically updates both `double` and `triple`, as well
    as the input fields themselves.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`和`triple`的值直接从`value`派生，然后填充输入字段。当你修改输入时，它会直接改变`value`，进而自动更新`double`和`triple`，以及输入字段本身。'
- en: So, this is how you maintain synchronized states for `value`, `double`, and
    `triple`, by focusing on the data flow and keeping a single source of truth.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是通过关注数据流并保持单一事实来源来维护`value`、`double`和`triple`同步状态的方法。
- en: Summary
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: Understanding how to handle props and state effectively is crucial for creating
    robust Svelte apps. This chapter has shown you how Svelte uses props, bindings,
    and reactive declarations to facilitate data passing and state changes across
    components.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何有效地处理props和state对于创建健壮的Svelte应用至关重要。本章向您展示了Svelte如何使用props、bindings和reactive
    declarations来促进组件间的数据传递和状态变化。
- en: It’s crucial to keep an eye on data flow within a component. Having a unified
    and organized data flow makes the code easier to follow and debug. Good data management
    paves the way for building more intricate and dynamic apps with ease.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部关注数据流至关重要。拥有统一和有序的数据流使得代码更容易跟踪和调试。良好的数据管理为轻松构建更复杂和动态的应用铺平了道路。
- en: In the next chapter, we’ll explore how to compose Svelte components to construct
    more complex applications.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何组合Svelte组件来构建更复杂的应用。
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
