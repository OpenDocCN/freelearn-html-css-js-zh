- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Props and State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of web development, managing data effectively is crucial. Whether
    it’s the information that flows between components or the internal state of a
    component, proper data management is the backbone of a functional and responsive
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the core concepts of managing props and
    state within a Svelte application. First, we’ll clarify what props and states
    in Svelte are, laying the groundwork for understanding more advanced topics. We
    then explore the concept of bindings, a feature in Svelte for keeping state and
    element values or component props in sync.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll then explore data flow within components, highlighting the differences
    between one-way data flow and two-way data flow and why they matter. Moving on,
    we’ll discuss how to derive state from props using Svelte’s reactive declarations.
    To conclude, we’ll offer tips for managing complex derived states and explain
    how to update props based on those derived states.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have a solid understanding of how to manage
    data within a Svelte component, being equipped with practical tips and strategies
    to tackle common challenges effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining props and state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-way versus two-way data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deriving states from props with a reactive declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing complex derived states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating props using derived states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start to talk about props and state, let’s first define what props
    and state are in Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find all the code samples used in this chapter on GitHub at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter03)
  prefs: []
  type: TYPE_NORMAL
- en: Defining props and state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Svelte, both props and state are used to manage data within components. Props
    are a way to pass data from a parent component to a child component. This makes
    the child component flexible and reusable, as it can get different data from the
    parent as needed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, state is data that is initialized and managed internally
    within a component, unlike props, which are received from an external source.
    State allows a component to be self-contained and modular.
  prefs: []
  type: TYPE_NORMAL
- en: Defining props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with props. Props in Svelte are defined using the `export` keyword.
    When you export a variable in a Svelte component, it becomes a prop that you can
    pass data to from a parent component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we defined a Svelte component in a file named
    `Child.svelte`. In the Svelte component, `message` is a prop. You can pass data
    to `message` from a parent component like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we define another Svelte component in a file
    named `Parent.svelte`. In the component, we import and use the `Child` component
    from `Child.svelte`. As the `Parent` component includes the `Child` component,
    the `Parent` component is considered the parent component of the imported `Child`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: In the parent component, you can set the `message` props of the child component
    to the value `"Hello, World!"` by passing `"Hello, World!"` through the `message`
    attribute of the `<Child />` component, as shown in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, props are defined using the `export` keyword, and their values are
    passed from the parent component to the child component.
  prefs: []
  type: TYPE_NORMAL
- en: Defining state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let’s look at the state. State is any data that is used and managed within
    a component. It is not passed in from a parent component like props. Instead,
    it is defined within the component itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that illustrates state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `count` is a state variable. It’s not passed in as a prop but
    is defined and managed within the `Counter` component. When you click the button,
    the `increment` function is called, which modifies the `count` state.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, props are variables that are passed into a component from a parent
    component, whereas the state is data that is managed within a component itself.
  prefs: []
  type: TYPE_NORMAL
- en: Props versus state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look closely, both props and state represent data. The difference between
    them depends on the context of the component you are considering.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s consider two components, component `A` and component `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with component `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In component `A`, we define a props called `height`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at component `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In component `B`, we define a state called `height` and pass its value as a
    prop to component `A`.
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of component `B`, `height` is considered a state, but from
    the viewpoint of component `A`, it’s considered a prop. Whether a variable is
    a prop or a state depends on the context of the component in which it is being
    viewed. At their core, they are essentially the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, due to the way JavaScript passes primitive variables by value,
    it may not be immediately obvious that the `height` variable in both component
    `A` and component `B` refers to the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we define an object as state and pass it to another component through
    props, it becomes clear that both the state in one component and the props in
    the other component refer to the same object reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our example to illustrate this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, I’ve added a `setInterval` function to print out the value
    of the `height` variable every second in both components. In component `B`, I’ve
    modified the state `height` to be an object. Because objects in JavaScript are
    passed by reference, the state `height` in component `B` that is passed as a prop
    to component `A` is passed by reference as well. This means the `height` prop
    in component `A` is referencing the same object as the state `height` in component
    `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add a `<button>` element in component `B` to mutate the `height` object,
    as shown here, you’ll be able to see that both component `A` and component `B`
    print out the same updated value of the `height` variable in the console. This
    is because they are printing out the value of the same object reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on the button from the preceding code snippet will result in the console
    printing out `A: { value: 110 }` and `B: { value: 110 }`. This demonstrates that
    the `height` variable in both components `A` and `B` refer to the same object
    reference. When `height.value` is changed to `110` in component `B`, the change
    is also reflected in the `height` variable in component `A`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what props and state are in Svelte, let’s talk about
    bindings next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bindings in Svelte allow you to keep the value of a component’s state in sync
    with the value of an `<input />` element. If the state changes, the input updates;
    conversely, if the input changes, the state updates as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is an example of creating a binding in Svelte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Bindings are created through the `bind:` directive. In the preceding code snippet,
    the input element’s value is bound to the `name` variable. When you type in the
    input, the `name` variable will update automatically. Conversely, when you change
    the value of the `name` variable, the input element’s value will also automatically
    update.
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated, bindings create a two-way data flow, enabling data changes
    to propagate from the element to the component state, and from the component state
    into the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example demonstrates binding on elements, but bindings can also
    work on components. You can use the `bind:` directive to link the props of a component
    with your component’s state, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we bind the `username` props of the `<Profile>`
    component to the `name` state variable. When you update the `name` state variable,
    the value of the `username` prop will automatically reflect the new value; conversely,
    if you update the value of the `username` prop from within the `<Profile>` component,
    the value of the `name` state variable will automatically update to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further demonstrate this behavior, let’s make a slight modification to the
    code. Here’s the updated version of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let username;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: '<p>Name in Profile: {username}</p>'
  prefs: []
  type: TYPE_NORMAL
- en: <button on:click={() => username = "World"}>Update from Profile</button>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<!-- filename: B.svelte -->'
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<!-- filename: A.svelte -->'
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: import B from './B.svelte';
  prefs: []
  type: TYPE_NORMAL
- en: let data;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <B value={data} />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<!-- filename: D.svelte -->'
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<!-- filename: C.svelte -->'
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: import D from './D.svelte';
  prefs: []
  type: TYPE_NORMAL
- en: let data;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <D bind:value={data} />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <DateLabel date={new Date(2023,5,5)} />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<!-- filename: DateLabel.svelte -->'
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let date;
  prefs: []
  type: TYPE_NORMAL
- en: // Deriving the 'label' variable from the 'date' prop
  prefs: []
  type: TYPE_NORMAL
- en: let label = date.toLocaleDateString();
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <label>{label}</label>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<!-- filename: DateLabel.svelte -->'
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let date;
  prefs: []
  type: TYPE_NORMAL
- en: // Deriving the 'label' variable from the 'date' prop
  prefs: []
  type: TYPE_NORMAL
- en: '$: label = date.toLocaleDateString();'
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <DateLabel date={new Date(2023, 5, 5)} locale="de-DE" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let date;
  prefs: []
  type: TYPE_NORMAL
- en: export let locale;
  prefs: []
  type: TYPE_NORMAL
- en: // Reactive declaration with multiple dependencies
  prefs: []
  type: TYPE_NORMAL
- en: '$: label = date.toLocaleDateString(locale);'
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <label>{label}</label>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let valueA;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let valueB;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: valueC = valueA + 5;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: valueD = valueB + valueC;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: valueC = Math.min(valueC, valueD / 2);'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Upon observing the data flow, we can see that valueC depends on valueA, valueD
    depends on both valueB and valueC, and then valueC in turn depends on valueD.
    Consequently, it’s unclear how valueC is actually calculated, it could be either
    valueA + 5 or the minimum of valueC and valueD / 2. Such complexity makes the
    code hard to understand and increases the likelihood of bugs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let a;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: b = a * 2;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: c = b * 2;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b is declared reactively before c. However, it behaves identically to the following
    snippet, where c is declared before b. Let’s look at the next one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let a;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: c = b * 2;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: b = a * 2;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let data;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: data = data ?? 100;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead, it’s better to declare a new state variable to manage this behavior:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let data;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: dataWithDefault = data ?? 100;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export let value;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: double = value * 2;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '$: triple = value * 3;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <input bind:value={double} type="number" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <input bind:value={triple} type="number" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  prefs: []
  type: TYPE_NORMAL
- en: '$: double = value * 2;'
  prefs: []
  type: TYPE_NORMAL
- en: '$: triple = value * 3;'
  prefs: []
  type: TYPE_NORMAL
- en: '$: value = double / 2;'
  prefs: []
  type: TYPE_NORMAL
- en: '$: value = triple / 3;'
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <input bind:value={double} type="number" />
  prefs: []
  type: TYPE_NORMAL
- en: <input bind:value={triple} type="number" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  prefs: []
  type: TYPE_NORMAL
- en: '$: double = value * 2;'
  prefs: []
  type: TYPE_NORMAL
- en: '$: triple = value * 3;'
  prefs: []
  type: TYPE_NORMAL
- en: '$: updateValueFromDouble(double);'
  prefs: []
  type: TYPE_NORMAL
- en: '$: updateValueFromTriple(triple);'
  prefs: []
  type: TYPE_NORMAL
- en: function updateValueFromDouble(double) {
  prefs: []
  type: TYPE_NORMAL
- en: value = double / 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function updateValueFromTriple(triple) {
  prefs: []
  type: TYPE_NORMAL
- en: value = triple / 3;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <input bind:value={double} type="number" />
  prefs: []
  type: TYPE_NORMAL
- en: <input bind:value={triple} type="number" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let value;
  prefs: []
  type: TYPE_NORMAL
- en: '$: double = value * 2;'
  prefs: []
  type: TYPE_NORMAL
- en: '$: triple = value * 3;'
  prefs: []
  type: TYPE_NORMAL
- en: function updateValueFromDouble(double) {
  prefs: []
  type: TYPE_NORMAL
- en: value = double / 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function updateValueFromTriple(triple) {
  prefs: []
  type: TYPE_NORMAL
- en: value = triple / 3;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <input value={double} type="number" on:change={e => updateValueFromDouble(e.target.value)}
    />
  prefs: []
  type: TYPE_NORMAL
- en: <input value as the sole source of truth. Instead of binding the input elements
    directly to double and triple, we’ve added event listeners that update value based
    on user input. This change automatically updates double and triple through reactive
    declarations, which then refresh the displayed values in the input fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the updated code, the data flow is now streamlined, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18887_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Data flows between props, states, and the input elements'
  prefs: []
  type: TYPE_NORMAL
- en: The values for `double` and `triple` are directly derived from `value`, which
    then populates the input fields. When you modify the input, it alters `value`
    directly, which in turn automatically updates both `double` and `triple`, as well
    as the input fields themselves.
  prefs: []
  type: TYPE_NORMAL
- en: So, this is how you maintain synchronized states for `value`, `double`, and
    `triple`, by focusing on the data flow and keeping a single source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to handle props and state effectively is crucial for creating
    robust Svelte apps. This chapter has shown you how Svelte uses props, bindings,
    and reactive declarations to facilitate data passing and state changes across
    components.
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial to keep an eye on data flow within a component. Having a unified
    and organized data flow makes the code easier to follow and debug. Good data management
    paves the way for building more intricate and dynamic apps with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore how to compose Svelte components to construct
    more complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
