<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor072"/>5</h1>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>Deep Dive into Data Loading</h1>
<p>Every application ever created has been driven by data. Without data to process, an application is effectively useless. That’s why it’s very important for developers to have a firm understanding of how to manage the retrieval of that data for their application. When working with SvelteKit, this is done by exporting a <code>load()</code> function in page or layout files.</p>
<p>In the previous chapter, we briefly touched on <code>load()</code>. In this chapter, we’ll analyze it further by discussing how it works and by looking at more practical, real-world examples of making use of it. We’ll create an example of forcing <code>load()</code> in the client only as well as covering some key details to remember when using <code>load()</code>. We’ll also use <code>load()</code> in layouts to showcase how it can make data portable across our application. Finally, we’ll look at an example of making use of some of the data provided in a server <code>load()</code> function that is unavailable in universal <code>load()</code> functions.</p>
<p>We’re going to cover the following topics in this chapter:</p>
<ul>
<li>Loading in Clients</li>
<li>Loading in Layouts</li>
<li>Destructuring RequestEvent</li>
</ul>
<p>By the time you’ve finished this chapter, you’ll be comfortable with all the various ways you can load data in your SvelteKit application.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter05">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter05</a>.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/>Loading in Clients</h1>
<p>While discussing<a id="_idIndexMarker096"/> <em class="italic">Creating Server Pages</em> in the previous chapter, we covered how a <code>load()</code> function exported from <code>+page.js</code> will run on both the client and the server. When we want to ensure load is only run on the server, we move it to <code>+page.server.js</code>. But what if you’re trying to build an offline-ready application? You may be <a id="_idIndexMarker097"/>building a <code>load()</code> functions to run on the client and not on the server. How can we do that when a <code>load()</code> function from <code>+page.js</code> runs in both environments?</p>
<p>Again, think back to the <em class="italic">Creating Server Pages</em> section in the previous chapter where we discussed page options, and you’ll remember the <code>ssr</code> option. When exported, this constant will disable or enable <code>load()</code> function in <code>+page.js</code> run only in the client, we can add <code>export const ssr = false;</code>. Let’s go back to our <code>fetch</code> example from <a href="B19024_03_Final_AM.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a> and modify it to demonstrate this.</p>
<p>Before making this adjustment, ensure the <code>console.log('got response')</code> function still exists. Open the <code>/fetch </code>route in your browser and confirm the output is shown in both the browser console and your development server. Once you’ve done so, disable SSR on the page by exporting the <code>ssr</code> page option:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/fetch/+page.js</p>
<pre class="source-code">
const key = 'DEMO_KEY'; // your API key here
export const ssr = false;
export function load() {
  const pic = fetch(`https://api.nasa.gov/planetary/apod?api_key=${key}`)
    .then(response =&gt; {
      console.log('got response');
      return response.json();
    });
  return {pic};
}</pre>
<p>This example is identical to when we saw it earlier, except that on line 3, we’ve added <code>export const ssr = false;</code>. This page option effectively disables SSR for the page, meaning that <code>load()</code> is only ever run in the client. You’ll notice the <code>console.log()</code> call isn’t output to the development server anymore but does show in the browser console.</p>
<p>From <a id="_idIndexMarker099"/>here on out, we’ll differentiate <code>load()</code> functions as either <code>load()</code> functions are run on the server in <code>+page.server.js</code>, which means that universal <code>load()</code> functions are run from <code>+page.js</code>. At a high level, they are functionally identical. But there are a few idiosyncrasies to mention:</p>
<ul>
<li>Both universal and server <code>load()</code> functions can access data related to the request that called it.</li>
<li>A server <code>load()</code> function will have access to more request data, such as cookies and the client IP address.</li>
<li>Universal <code>load()</code> functions always return an object. The values of that object may be nearly anything.</li>
<li>Server <code>load()</code> functions <em class="italic">must</em> return data that can be serialized by the <code>devalue</code> package (essentially, anything that can be converted into JSON). Find out more about <code>devalue</code> at <a href="https://github.com/rich-harris/devalue">https://github.com/rich-harris/devalue</a>.</li>
</ul>
<p class="callout-heading">Universal Load Timing</p>
<p class="callout">It should be<a id="_idIndexMarker100"/> mentioned that on the first render, <code>load()</code> will execute on the server and client. Each subsequent request will then be executed in the client only. To demonstrate this behavior, navigate your browser to a route that has <code>load()</code> run from a <code>+page.js</code> file, like our <code>/fetch</code> example from <a href="B19024_03_Final_AM.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>. Observe the console output in the server as well as the client when initially opening the <code>/fetch</code> page in your browser. Navigating to another route and back will show the output only in the client.</p>
<p>One final note about calling <code>load()</code>; it will always be invoked at runtime unless you have specified that the page should be prerendered by way of page options. If you have decided to prerender the page, then <code>load()</code> will be called at build time. Remember that pages should only be prerendered if the static HTML shown should be the same for each user to access the page.</p>
<p>We’ve just <a id="_idIndexMarker101"/>covered how <code>load()</code> can be forced to run only on the client and some details about how it works. With all of this new information as well as the information from previous chapters, you should feel relatively comfortable about the fundamentals of <code>load()</code>. Let’s expand on it and take a look at how it might be used in a layout template.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor076"/>Loading in Layouts</h1>
<p>So far, we’ve only<a id="_idIndexMarker102"/> looked at <code>load()</code> being used in <code>+page.js</code> or <code>+page.server.js</code> files, but it can also be utilized in <code>+layout.js</code> or <code>+layout.server.js</code> files. While layouts cannot export actions, they are otherwise functionally identical to page files. This means that previously mentioned page options (such as <code>ssr</code>) and <code>load()</code> functions will apply to any components nested inside of the layout. Another important quality to understand about <code>load()</code> functions is that because they are run concurrently within SvelteKit, a single page will not render until all requests have completed. Having a <code>load()</code> function on a page as well as a layout will prevent rendering until both have completed. But because they will be run simultaneously, any delays should be negligible.</p>
<p>When loading data in a layout, the most obvious advantage of doing so is the ability to access that data in sibling and child pages. This means that any data loaded by a layout can then be accessed within an inherited <code>+page.svelte</code> file when it has exported the <code>data</code> variable. SvelteKit will also keep track of data loaded across the application and only trigger <code>load()</code> when it believes it to be absolutely necessary. In instances where we want to force data to be reloaded, we can import the <code>invalidate</code> or <code>invalidateAll</code> modules provided by <code>$app/navigation</code>.</p>
<p>To demonstrate these concepts, let’s create a component alongside the navigation that can alert the user to unread notifications. The component will persist across the application header so it may be easily accessed. This makes for an ideal scenario showcasing loading data from a layout. We’ll also create another page that shows the full list of notifications to demonstrate how data loaded from a layout can be used in a child component.</p>
<p>Let’s start <a id="_idIndexMarker103"/>with the <code>load()</code> function in <code>+layout.js</code>. For simplicity’s sake, we’ll return the data directly within the function call instead of making a call to an imaginary database or API:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+layout.js</p>
<pre class="source-code">
export function load() {
  console.log('notifications loaded');
  return {
    notifications: {
      count: 3,
      items: [
        {
          type: `comment`,
          content: `Hi! I'm Dylan!`
        },
        {
          type: `comment`,
          content: `Hi Dylan. Nice to meet you!`
        },
        {
          type: `comment`,
          content: `Welcome to the chapter about load()!`
        }
      ]
    },
  }
}</pre>
<p>This file<a id="_idIndexMarker104"/> consists only of the exported <code>load()</code> function, which returns an object containing another <code>notifications</code> object. Remember that universal <code>load()</code> functions can export anything so long as it resides inside an object. The <code>notifications</code> object is quite simple as it consists of two properties; a <code>count</code> property with the value of <code>3</code> and another property labeled <code>items</code>, which is just an array of three other objects. To show how the data isn’t loaded every time we navigate to a new page, we’ve included a <code>console.log()</code> call that outputs the text <code>notifications loaded</code>.</p>
<p>Next, we’ll make some changes to our root layout template so it can actually use our freshly loaded data. For the most part, it will stay the same, but we’ll need to add some markup that can show the data as well as minimal styling to convey the <a id="_idIndexMarker105"/>concept of a <strong class="bold">notification badge</strong>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+layout.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import Nav from '$lib/Nav.svelte';
  import Notify from '$lib/Notify.svelte';
  export let data;
&lt;/script&gt;
&lt;div class='wrapper'&gt;
  &lt;div class='nav'&gt;
    &lt;div class='menu'&gt;
      &lt;Nav /&gt;
    &lt;/div&gt;
    &lt;div class='notifications'&gt;
      &lt;Notify count={data.notifications.count}/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class='content'&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
  &lt;div class='footer'&gt;
    This is my footer
  &lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
  .wrapper {
    min-height: 100vh;
    display: grid;
    grid-template-rows: auto 1fr auto;
  }
  .footer {
    text-align: center;
    margin: 20px 0;
  }
  .nav {
    text-align: center;
  }
  .menu {
    display: inline-block;
  }
  .notifications {
    float: right;
  }
&lt;/style&gt;</pre>
<p>Here are some<a id="_idIndexMarker106"/> important changes to make note of in this version of <code>+layout.svelte</code>:</p>
<ul>
<li>A new <code>Notify</code> component is imported (shown next).</li>
<li>We exported the <code>data</code> variable to make use of the data returned from <code>src/routes/+layout.js</code>.</li>
<li>The <code>notifications</code> <code>count</code> property is sent to the <code>Notify</code> component.</li>
<li>The markup for the <code>.menu</code> and <code>.notifications</code> elements are added to the <code>.nav</code> div element. This allows us to show the <code>Notify</code> component in the top-right corner of the page.</li>
<li>New styles for elements with the <code>.nav</code>, <code>.menu</code>, and <code>.notifications</code> classes are added to style our new markup.</li>
</ul>
<p>Next, let’s look at the <code>Notify</code> component we just imported. This component will contain the markup that shows our notification count and links to the <code>/</code><code>notification</code> route:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/lib/Notify.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let count = 0;
&lt;/script&gt;
&lt;a href='/notifications'&gt;
  {count}
&lt;/a&gt;
&lt;style&gt;
  a {
    padding: 15px;
    color: white;
    text-decoration: none;
    background-color: #ea6262;
  }
&lt;/style&gt;</pre>
<p>This<a id="_idIndexMarker107"/> component is relatively simple. Firstly, it exports the <code>count</code> variable and gives it a default value of <code>0</code>. This is necessary because, while this component is used inside the layout, it does not exist underneath or alongside the <code>+layout.js</code> file we created earlier and so it does not have access to the information provided by the layout <code>load()</code> function. Next, this component creates a link tag to contain the <code>count</code> variable. And finally, it contains spartan styling to decorate our notification badge.</p>
<p>Finally, let’s look at the notifications page. Because this file exists underneath the hierarchy of <code>+layout.js</code>, we can access <code>data</code> as if it were loaded from a <code>+page.js</code> file that existed alongside it:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/notifications/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let data;
&lt;/script&gt;
{#if data.notifications.count &gt; 0}
  &lt;ul&gt;
  {#each data.notifications.items as item}
    &lt;li&gt;{item.content}&lt;/li&gt;
  {/each}
  &lt;/ul&gt;
{/if}</pre>
<p>This <a id="_idIndexMarker108"/>page makes use of Svelte directives: <code>{#if}</code> and <code>{#each}</code>. Since we exported the <code>data</code> variable at the top of the component, we can use data loaded from <code>src/routes/+layout.js</code> within this component. If the <code>count</code> property of the <code>notifications</code> objects is greater than zero, it will create the markup necessary for an unordered list. It then outputs the <code>content</code> property of each comment item inside a list item.</p>
<p>Now, when you open your project in your browser, you should see a new notification badge displayed in the top-right corner of the app showing the value of the <code>count</code> property from the <code>notification</code> object. Try selecting some of the items in the navigation menu and see how the text <strong class="bold">notifications loaded</strong> isn’t output every time you click a link. It is shown on the initial load in both the development server as well as the browser console but not run again. That is because the data being loaded has yet to change, and SvelteKit recognizes this.</p>
<p>Let’s look at forcing the data to be reloaded when we click on the notification badge. We can do this by using <code>invalidateAll</code> imported from <code>$app/navigation</code>. If the <code>load()</code> function used <code>fetch()</code>, it would make sense to use the <code>invalidate</code> module instead. In that instance, we would force the reload by passing the URL specified inside of the <code>fetch()</code> call to <code>invalidate()</code>. Since we’re simply returning an object, we’ll need to use <code>invalidateAll()</code> to trigger the reload:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/lib/Notify.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import { invalidateAll } from '$app/navigation';
  export let count = 0;
&lt;/script&gt;
&lt;a href='/notifications' on:click={() =&gt; invalidateAll()}&gt;
  {count}
&lt;/a&gt;</pre>
<p>In the <code>Notify.svelte</code> component, we’ve added the import of <code>invalidateAll</code>. When the notification link badge is clicked, it calls <code>invalidateAll()</code>, informing SvelteKit to rerun all <code>load()</code> functions within the context. Now, when you click the notification link at the top of the page, you should see the browser console output <strong class="bold">notifications loaded</strong>. Navigating to other pages such as <strong class="bold">About</strong>, <strong class="bold">News</strong>, or <strong class="bold">Home</strong> will not produce the output.</p>
<p>In the future, should<a id="_idIndexMarker109"/> you find yourself building components that will be showing dynamic data across an application’s interface, consider the concepts we’ve just covered. By loading data in layout files, you can reduce the number of HTTP requests or database queries made, which can significantly improve the experience of the application for your users. And should you need to force that data to be reloaded, you’ll know how to go about invalidating data so SvelteKit will re-run the appropriate <code>load()</code> functions. Next, let’s take a look at how <code>load()</code> can be leveraged further to build more advanced functionality.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Destructuring RequestEvent</h1>
<p>When it <a id="_idIndexMarker110"/>comes to <code>load()</code>, the server seems to have more information available to it than the client does. With so much data, it can be hard to know exactly all the information that is available. In short, server <code>load()</code> functions are called with a SvelteKit-specific <code>RequestEvent</code>. Here’s a quick breakdown of the properties (<code>prop</code>) and functions (<code>fn</code>) available from that object:</p>
<ul>
<li><code>cookies</code> (<code>prop</code>) – The cookies sent during the request.</li>
<li><code>fetch</code> (<code>fn</code>) – A compatible variant of the Web API <code>fetch()</code> function discussed in <a href="B19024_03_Final_AM.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>. It comes with the added benefit of allowing requests based on relative routes as well as passing cookies and headers through when on the same server.</li>
<li><code>getClientAddress</code> (<code>fn</code>) – Returns the client’s IP address.</li>
<li><code>locals</code> (<code>prop</code>) – Any custom data inserted into the request via SvelteKit’s <code>handle()</code> hook. We’ll cover that in a later chapter.</li>
<li><code>params</code> (<code>prop</code>) – Parameters specific to the current route, such as the article slug passed to the news example in the previous chapter.</li>
<li><code>platform</code> (<code>prop</code>) – Data added by the environment adapter.</li>
<li><code>request</code> (<code>prop</code>) – The actual request data represented as an object.</li>
<li><code>route</code> (<code>prop</code>) – The identifier of the requested route.</li>
<li><code>setHeaders</code> (<code>fn</code>) – Allows for the manipulation of headers in the returned <code>Response</code> object.</li>
<li><code>url</code> (<code>prop</code>) – Data about the requested URL, which we covered in <a href="B19024_03_Final_AM.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>.</li>
</ul>
<p class="callout-heading">RequestEvent demo</p>
<p class="callout">To see this information for yourself, create the <code>src/routes/+layout.server.js</code> file with a <code>console.log()</code> function outputting a single passed-in argument to <code>load()</code>. By creating it in the root layout, you’ll be able to see how properties change based on the different routes accessed from your browser. The data will then be shown in your development console.</p>
<p>A practical <a id="_idIndexMarker111"/>example where you may find yourself needing to utilize this data is in the case of user authentication. Normally, after a user has authenticated, they are given a cookie (<em class="italic">for doing such a good job entering their password – pun intended</em>) to store on their device, which ensures their authentication will persist for the duration of their visit. If they leave the application, it can later be used to confirm their identity so they aren’t required to authenticate yet again. Let’s observe how this might be accomplished with SvelteKit. Since this chapter is about <code>load()</code>, we’ll build the actual form and discuss how to set the cookies in the next chapter. For now, we’ll simply check whether the user has a cookie set and set one manually in the browser.</p>
<p>To begin, let’s rename <code>src/routes/+layout.js</code> to <code>src/routes/+layout.server.js</code>. If we’re going to access cookie data, we’ll need access to the data provided by <code>RequestEvent</code>. By adding the logic to our root server layout, we have the added benefit of keeping the authentication checks in place across the entire application:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+layout.server.js</p>
<pre class="source-code">
export function load({ cookies }) {
  const data = {
    notifications: {
      count: 3,
      items: [
        {
          type: `comment`,
          content: `Hi! I'm Dylan!`
        },
         …
      ]
    }
  };
  if(cookies.get('identity') === '1') {
    // lookup user ID in database
    data.user = {
      id: 1,
      name: 'Dylan'
    }
  }
  return data;
}</pre>
<p>In this new <a id="_idIndexMarker112"/>version of the root layout logic, we’ve destructured the argument passed to <code>load()</code> since we currently only need access to the <code>cookies</code> property. We kept the <code>notifications</code> object we created earlier but put it inside a new variable called <code>data</code>. This text also omits a couple of entries for the sake of brevity. From there, we check whether the request sent to our application contained a cookie by the name of <code>user</code> with the value of <code>1</code>. If it did, we insert some fake user information into the <code>user</code> property of the <code>data</code> object. Normally at this point, we would check the cookie value against valid sessions in a database, and if one was found, we would then <a id="_idIndexMarker113"/>retrieve the appropriate user data and send that back to the client, but we’re trying to keep it simple. After all of that, the <code>data</code> object is returned from <code>load()</code>.</p>
<p>Next, we’ll need to actually show that the user has been successfully authenticated. To do this, we’ll create a new route where our user can log in:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/login/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let data;
&lt;/script&gt;
{#if data.user}
  &lt;p&gt;
    Welcome, {data.user.name}!
  &lt;/p&gt;
{/if}</pre>
<p>As we covered in the last section, the data returned from <code>+layout.js</code> or <code>+layout.server.js</code> is made available in child components by exporting the <code>data</code> variable. Once that is done, we use the Svelte <code>{#if}</code> directive to check whether we have the <code>user</code> property set. If found, we then display the <code>name</code> property of <code>data.user</code>.</p>
<p>Of course, nowhere in this example do we ever set a cookie. We’ll cover that in the next chapter so, for now, let’s manually create the cookie in our browser. Before doing so, navigate to the <code>/login</code> route and verify that nothing is shown on the page. Once you have confirmed it is a blank page, go ahead and create the cookie using the following steps for your<a id="_idIndexMarker114"/> browser:</p>
<ul>
<li><code>identity</code>.</li><li>Double-click the <code>1</code>.</li><li>Ensure the <code>/</code> using the same steps.</li></ol></li>
<li><code>identity</code>.</li><li>Select the <code>1</code>.</li><li>Ensure the <code>/</code> using the same steps.</li></ol></li>
</ul>
<p>Having<a id="_idIndexMarker120"/> followed these steps, you should now have the correct cookie in your browser. After doing so, refresh the <code>/login</code> page in your browser and you’ll see a message welcoming the user with the value from the <code>name</code> property specified. This example is quite simple and actual cookie-based login systems are functionally slightly more complicated; however, the concepts remain the same.</p>
<p>While the example we covered only made use of the <code>cookies</code> property from <code>RequestEvent</code>, we saw how trivial it would be to access any of the other properties such as <code>url</code> and <code>params</code>, or even to set our own headers with the <code>setHeaders</code> function. With all of that data <a id="_idIndexMarker121"/>available to us, the possibilities of what could be built into our application are nearly limitless.</p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>Summary</h1>
<p>In this chapter, we covered a lot of information about <code>load()</code>. We first discussed how it can be done only in the client and then moved on to some finer details about how it works. After that, we looked at using <code>load()</code> in layouts to minimize the number of requests made for each page load and maximize convenient access to data that may be needed application-wide. We also looked at invalidating data in cases where we would want data to be reloaded. Finally, we covered how server <code>load()</code> functions are called by <code>RequestEvent</code>, which gives us access to so much more valuable information. That information can enable us to build cookie-based login functionality for our application.</p>
<p>Having spent this chapter learning about some of the finer details behind <code>load()</code>, you should feel comfortable taking a load off and relaxing. If you have any baked cookies to hand, I suggest you take a break from the book and treat yourself to some. You’ve earned it.</p>
<p>But do come back because, in the next chapter, we’ll cover more of the finer details behind receiving data from users through the use of forms, making the forms fun, and reducing the friction of data entry by utilizing snapshots.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/>Resources</h1>
<p>devalue: <a href="https://github.com/rich-harris/devalue">https://github.com/rich-harris/devalue</a></p>
</div>
</body></html>