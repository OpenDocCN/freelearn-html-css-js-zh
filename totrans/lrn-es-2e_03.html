<html><head></head><body>
        

                            
                    <h1 class="header-title">Using Iterators</h1>
                
            
            
                
<p class="mce-root">ES8 and earlier versions introduced new object interfaces and loops for iteration. The addition of the new iteration protocols opens up a new world of algorithms and abilities for JavaScript. We will start the chapter by introducing the symbols and various properties of the <kbd>Symbol</kbd> object. We will also learn how execution stacks are created for the nested function calls, their impacts, and how to optimize their performance and memory usage.<br/>
Although symbols are a separate topic to iterators, we will still be covering symbols in this chapter, because to implement the iterable protocol, you need to use symbols.<br/>
In this chapter, we'll cover:</p>
<ul>
<li class="mce-root">Using symbols as the object property keys</li>
<li class="mce-root">Implementing the iteration protocols in objects</li>
<li class="mce-root">Creating and using the <kbd>generator</kbd> object</li>
<li class="mce-root">Using the <kbd>for…of</kbd> loop for iterating</li>
<li class="mce-root">The tail call optimization</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Symbols – primitive data type</h1>
                
            
            
                
<p><strong>Symbols</strong> are a primitive type that was first introduced in ES6. A symbol is a unique and immutable value. Here is an example that shows how to create a symbol:</p>
<pre>const s = Symbol();</pre>
<p>Symbols don't have a literal form; therefore, we need to use the <kbd>Symbol()</kbd> function to create a symbol. The <kbd>Symbol()</kbd> function returns a unique symbol every time it is called.</p>
<p>The <kbd>Symbol()</kbd> function takes an optional string parameter that represents the description of the symbol. A description of a symbol can be used for debugging, but not to access the symbol itself. Two symbols with the same description are not equal at all. Here is an example to demonstrate this:</p>
<pre>let s1 = Symbol("My Symbol");<br/>let s2 = Symbol("My Symbol");<br/>console.log(s1 === s2); // Outputs false</pre>
<p>From the preceding example, we can also say that a symbol is a string-like value that can't clash with any other value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The typeof operator</h1>
                
            
            
                
<p>The <kbd>typeof</kbd> operator is used to determine the type of value a particular variable/constant is held for <kbd>Symbol</kbd>, <kbd>typeof</kbd> outputs <kbd>symbol</kbd>. Here is an example to demonstrate the same:</p>
<pre>const s = Symbol();<br/>console.log(typeof s); //Outputs "symbol"</pre>
<p>Using the <kbd>typeof</kbd> operator is the only way to identify whether a variable holds a symbol.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The new operator</h1>
                
            
            
                
<p>You cannot apply the <kbd>new</kbd> operator to the <kbd>Symbol()</kbd> function. The <kbd>Symbol()</kbd> function detects whether it's being used as a constructor, and if <kbd>true</kbd>, it then throws an exception.<br/>
Here is an example to demonstrate this:</p>
<pre>try {<br/>  let s = new Symbol(); //"TypeError" exception<br/>}<br/>catch(e) {<br/>  console.log(e.message); //Output "Symbol is not a constructor"<br/>}</pre>
<p>But the JavaScript engine can use the <kbd>Symbol()</kbd> function internally as a constructor to wrap a symbol in an object. Therefore, <kbd>s</kbd> will be equal to object(s).</p>
<p>All primitive types introduced from ES6 onward will not allow their constructors to be invoked manually.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using symbols as the object property keys</h1>
                
            
            
                
<p>Until ES5, the JavaScript object property keys had to be string type. But since ES6, the JavaScript object property keys can be strings or symbols. Here is an example that demonstrates how to use a symbol as an object property key:</p>
<pre>let obj = null;<br/>let s1 = null;<br/>(function(){<br/> let s2 = Symbol();<br/> s1 = s2;<br/> obj = {[s2]: "mySymbol"}<br/> console.log(obj[s2]);<br/> console.log(obj[s2] == obj[s1]);<br/>})();<br/>console.log(obj[s1]);</pre>
<p>The output is:</p>
<pre><strong>mySymbol</strong><br/><strong>true</strong><br/><strong>mySymbol</strong></pre>
<p>From the preceding code, you can see that in order to create or retrieve a property key using symbols, you need to use the <kbd>[]</kbd> token. We saw the <kbd>[]</kbd> token while discussing the computed property names in <a href="1240cafe-4f1d-4e0f-bc46-6c2ed8bb3efe.xhtml">Chapter 2</a>, <em>Knowing Your Library</em>.</p>
<p>To access a symbol property key, we need the symbol. In the previous example, both <kbd>s1</kbd> and <kbd>s2</kbd> hold the same symbol value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Object.getOwnPropertySymbols() method</h1>
                
            
            
                
<p>The <kbd>Object.getOwnPropertyNames()</kbd> method cannot retrieve the symbol properties. Therefore, ES6 introduced <kbd>Object.getOwnPropertySymbols()</kbd> to retrieve an array of symbol properties of an object. Here is an example to demonstrate this:</p>
<pre>let obj = {a: 12};<br/>let s1 = Symbol("mySymbol");<br/>let s2 = Symbol("mySymbol");<br/>Object.defineProperty(obj, s1, {<br/>enumerable: false<br/>});<br/>obj[s2] = "";<br/>console.log(Object.getOwnPropertySymbols(obj));</pre>
<p>The output is as follows:</p>
<pre class="mce-root"><strong>Symbol(mySymbol),Symbol(mySymbol)</strong></pre>
<p class="mce-root">From the previous example, you can see that the <kbd>Object.getOwnPropertySymbols()</kbd> method can also retrieve the non-enumerable symbol properties.</p>
<p>The <kbd>in</kbd> operator can find the symbol properties in an object, whereas the <kbd>for…in</kbd> loop and <kbd>Object.getOwnPropertyNames()</kbd> cannot find the symbol properties in an object for the sake of backward compatibility.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Symbol.for(string) method</h1>
                
            
            
                
<p>The <kbd>Symbol</kbd> object maintains a registry of the key/value pairs, where the key is the symbol description, and the value is the symbol. Whenever we create a symbol using the <kbd>Symbol.for()</kbd> method, it gets added to the registry and the method returns the symbol. If we try to create a symbol with a description that already exists, then the existing symbol will be retrieved.<br/>
The advantage of using the <kbd>Symbol.for()</kbd> method instead of the <kbd>Symbol()</kbd> method to create symbols is that while using the <kbd>Symbol.for()</kbd> method, you don't have to worry about making the symbol available globally, because it's always available globally. Here is an example to demonstrate this:</p>
<pre>let obj = {};<br/>(function(){<br/> let s1 = Symbol("name");<br/> obj[s1] = "Eden";<br/>})();<br/>//obj[s1] cannot be accessed here<br/>(function(){<br/> let s2 = Symbol.for("age");<br/> obj[s2] = 27;<br/>})();<br/>console.log(obj[Symbol.for("age")]); //Output "27"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Well-known symbols</h1>
                
            
            
                
<p>In addition to your own symbols, ES6 comes up with a built-in set of symbols, known as well-known symbols. Here is a list of properties, referencing some important built-in symbols:</p>
<ul>
<li><kbd>Symbol.iterator</kbd></li>
<li><kbd>Symbol.match</kbd></li>
<li><kbd>Symbol.search</kbd></li>
<li><kbd>Symbol.replace</kbd></li>
<li><kbd>Symbol.split</kbd></li>
<li><kbd>Symbol.hasInstanceSymbol.species</kbd></li>
<li><kbd>Symbol.unscopables</kbd></li>
<li><kbd>Symbol.isContcatSpreadable</kbd></li>
<li><kbd>Symbol.toPrimitive</kbd></li>
</ul>
<p>You will come across the use of these symbols in various chapters of this book.</p>
<p>When referring to the well-known symbols in the text, we usually prefix them using the <kbd>@@</kbd> notation. For example, the <kbd>Symbol.iterator</kbd> symbol is referred to as the <kbd>@@iterator</kbd> method. This is done to make it easier to refer to these symbols in the text.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The iteration protocol</h1>
                
            
            
                
<p>An iteration protocol is a set of rules that an object needs to follow for implementing the interface. When this protocol is used, a loop or a construct can iterate over a group of values of the object.</p>
<p>JavaScript has two iteration protocols known as the <strong>iterator</strong><strong> protocol</strong> and the <strong>iterable protocol</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The iterator protocol</h1>
                
            
            
                
<p>Any object that implements the iterator protocol is known as an <strong>iterator</strong>. According to the iterator protocol, an object needs to provide a <kbd>next()</kbd> method that returns the next item in the sequence of a group of items.<br/>
Here is an example to demonstrate this:</p>
<pre>let obj = {<br/> array: [1, 2, 3, 4, 5],<br/> nextIndex: 0,<br/> next: function() {<br/>         return this.nextIndex &lt; this.array.length ? {value: this.array[this.nextIndex++], done: false} : {done: true}<br/>       }<br/>};<br/>console.log(obj.next().value);<br/>console.log(obj.next().value);<br/>console.log(obj.next().value);<br/>console.log(obj.next().value);<br/>console.log(obj.next().value);<br/>console.log(obj.next().done);</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong><br/><strong>4</strong><br/><strong>5</strong><br/><strong>true</strong></pre>
<p>If you look closely, you'll realize that the <kbd>next</kbd> method inside the <kbd>obj</kbd> object is as follows:</p>
<pre>return this.nextIndex &lt; this.array.length ? {value: this.array[this.nextIndex++], done: false} : {done: true}</pre>
<p>This can be written as follows:</p>
<pre>if(this.nextIndex &lt; this.array.length) {<br/>  this.nextIndex++;<br/>  return { value: this.array[this.nextIndex], done: false }<br/>} else {<br/>  return { done: true }<br/>}</pre>
<p>This clearly tells us that we'll increment <kbd>nextIndex</kbd> and send the next element from the <kbd>array</kbd> in the object <kbd>obj</kbd> if a new element exists there. When there's no element left, we return <kbd>{ done: true }</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The iterable protocol</h1>
                
            
            
                
<p>Any object that implements the <strong>iterable protocol</strong> is known as an iterable. According to the iterable protocol, an object needs to provide the <kbd>@@iterator</kbd> method; that is, it must have the <kbd>Symbol.iterator</kbd> symbol as a property key. The <kbd>@@iterator</kbd> method must return an iterator object.<br/>
Here is an example to demonstrate this:</p>
<pre>let obj = {<br/>  array: [1, 2, 3, 4, 5],<br/>  nextIndex: 0,<br/>  [Symbol.iterator]: function(){<br/>    return {<br/>     array: this.array,<br/>     nextIndex: this.nextIndex,<br/>     next: function(){<br/>       return this.nextIndex &lt; this.array.length ?<br/>          {value: this.array[this.nextIndex++], done: false} :<br/>          {done: true};<br/>     }<br/>    }<br/>  }<br/>};<br/>let iterable = obj[Symbol.iterator]()<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().done);</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong><br/><strong>4</strong><br/><strong>5</strong><br/><strong>true</strong></pre>
<p>This is all well and good, but what is the use of doing it?</p>
<p>The preceding two code blocks show you how to implement the iterable protocol on your own. However, things such as <strong>arrays</strong> come with the iterable protocol (that is, their <kbd>__proto__</kbd> chain implements the <kbd>Symbol.iterator</kbd> method), which is implemented by default thus saving a developer's time. Let's take a look at an example:</p>
<pre>const arr = [1, 2]<br/>const iterator = arr[Symbol.iterator](); // returns you an iterator<br/>console.log(iterator.next())<br/>console.log(iterator.next())<br/>console.log(iterator.next())</pre>
<p>Based on what we've learned so far, what do you think the output should be?</p>
<p>The output is as follows:</p>
<pre><strong>{ value: 1, done: false }</strong><br/><strong>{ value: 2, done: false }</strong><br/><strong>{ value: undefined, done: true }</strong></pre>
<p>Let us now take a look at generators, which are more or less, similar to iterators.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generator function</h1>
                
            
            
                
<p>A <kbd>generator</kbd> is a normal function, but instead of returning a single value, it returns multiple values one by one. Calling a <kbd>generator</kbd> function doesn't execute its body immediately, but rather returns a new instance of the <kbd>generator</kbd> object (that is, an object that implements both, iterable and iterator protocols).</p>
<p>Every <kbd>generator</kbd> object holds a new execution context of the <kbd>generator</kbd> function. When we execute the <kbd>next()</kbd> method of the <kbd>generator</kbd> object, it executes the <kbd>generator</kbd> function's body until the <kbd>yield</kbd> keyword is encountered. It returns the yielded value and pauses the function. When the <kbd>next()</kbd> method is called again, it resumes the execution and then returns the next yielded value. The <kbd>done</kbd> property is <kbd>true</kbd> when the <kbd>generator</kbd> function doesn't yield any value.</p>
<p>A <kbd>generator</kbd> function is written using the <kbd>function*</kbd> expression. Here is an example to demonstrate this:</p>
<pre>function* generator_function(){ <br/>  yield 1; <br/>  yield 2; <br/>  yield 3;<br/>  yield 4; <br/>  yield 5;<br/>}<br/>let generator = generator_function();<br/>console.log(generator.next().value);<br/>console.log(generator.next().value);<br/>console.log(generator.next().value);<br/>console.log(generator.next().value);<br/>console.log(generator.next().value);<br/>console.log(generator.next().done);<br/><br/>generator = generator_function();<br/><br/>let iterable = generator[Symbol.iterator]();<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().value);<br/>console.log(iterable.next().done);</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong><br/><strong>4</strong><br/><strong>5</strong><br/><strong>true</strong><br/><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong><br/><strong>4</strong><br/><strong>5</strong><br/><strong>true</strong></pre>
<p>There is an expression following the <kbd>yield</kbd> keyword. The value of the expression is what is returned by the <kbd>generator</kbd> function via the iterable protocol. If we omit the expression, then <kbd>undefined</kbd> is returned. The value of the expression is what we call, the yielded value.</p>
<p>We can also pass an optional argument to the <kbd>next()</kbd> method. This argument becomes the value returned by the <kbd>yield</kbd> statement, where the <kbd>generator</kbd> function is currently paused. Here is an example to demonstrate this:</p>
<pre>function* generator_function(){ <br/>  const a = yield 12;<br/>  const b = yield a + 1; <br/>  const c = yield b + 2; <br/>  yield c + 3; // Final Line<br/>}<br/>const generator = generator_function();<br/>console.log(generator.next().value);<br/>console.log(generator.next(5).value);<br/>console.log(generator.next(11).value);<br/>console.log(generator.next(78).value);<br/>console.log(generator.next().done);</pre>
<p>The output is as follows:</p>
<pre><strong>12</strong><br/><strong>6</strong><br/><strong>13</strong><br/><strong>81</strong><br/><strong>true</strong></pre>
<p>Here's the explanation of this output:</p>
<ol>
<li>On the first <kbd>generator.next()</kbd> call, <kbd>yield 12</kbd> is called and the value <kbd>12</kbd> is returned.</li>
<li>On the second <kbd>generator.next(5)</kbd> call, the previous yield (which was stored in <kbd>const a</kbd>) gets the passed value (that is, <kbd>5</kbd>), and then the second yield (<kbd>a + 1</kbd>). Then, <kbd>yield 5 + 1</kbd> is called and the value <kbd>6</kbd> is returned (careful: <kbd>a</kbd> is not <kbd>12</kbd> here).</li>
<li>On the third <kbd>generator.next(11)</kbd> call, <kbd>const b</kbd> becomes <kbd>11</kbd>, and then because it's the sum of  <em>11 + 2</em>, <kbd>13</kbd> is yielded.</li>
<li>This is followed till the last process, that is, until the line <kbd>Final Line</kbd>, as mentioned in the example.</li>
<li>As <kbd>yield</kbd> finally returns a value and its <kbd>done</kbd> status, after executing <kbd>yield c + 3</kbd>, there is apparently no value to yield. Hence, the value returned is <kbd>undefined</kbd> and <kbd>done</kbd> is <kbd>true</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">The return(value) method</h1>
                
            
            
                
<p>You can end a <kbd>generator</kbd> function any time before it has yielded all the values by using the <kbd>return()</kbd> method of the <kbd>generator</kbd> object. The <kbd>return()</kbd> method takes an optional argument, representing the final value to return.</p>
<p>Here is an example demonstrating this:</p>
<pre>function* generator_function(){ <br/> yield 1; <br/> yield 2; <br/> yield 3;<br/>}<br/>const generator = generator_function();<br/>console.log(generator.next().value);<br/>console.log(generator.return(22).value);<br/>console.log(generator.next().done);</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>22</strong><br/><strong>true</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The throw(exception) method</h1>
                
            
            
                
<p>You can manually trigger an exception inside a <kbd>generator</kbd> function using the <kbd>throw()</kbd> method of the <kbd>generator</kbd> object. You must pass an exception to the <kbd>throw()</kbd> method that you want to throw. Here is an example to demonstrate this:</p>
<pre>function* generator_function(){ <br/>try { <br/> yield 1; <br/>} catch(e) { <br/> console.log("1st Exception"); <br/>} <br/>try { <br/> yield 2; <br/>} catch(e) { <br/> console.log("2nd Exception"); <br/>}<br/>}<br/>const generator = generator_function();<br/>console.log(generator.next().value);<br/>console.log(generator.throw("exception string").value);<br/>console.log(generator.throw("exception string").done);</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>1st Exception</strong><br/><strong>2</strong><br/><strong>2nd Exception</strong><br/><strong>true</strong></pre>
<p>In the preceding example, you can see that the exception is thrown where the function was last paused. After the exception is handled, the <kbd>throw()</kbd> method continues execution, and returns the next yielded value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The yield* keyword</h1>
                
            
            
                
<p>The <kbd>yield*</kbd> keyword inside a <kbd>generator</kbd> function takes an iterable object as the expression and iterates it to yield its values. Here is an example to demonstrate this:</p>
<pre>function* generator_function_1(){ <br/> yield 2; <br/> yield 3;<br/>}<br/>function* generator_function_2(){<br/> yield 1; <br/> yield* generator_function_1(); <br/> yield* [4, 5];<br/>}<br/>const generator = generator_function_2();<br/>console.log(generator.next().value);<br/>console.log(generator.next().value);<br/>console.log(generator.next().value);<br/>console.log(generator.next().value);<br/>console.log(generator.next().value);<br/>console.log(generator.next().done);</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong><br/><strong>4</strong><br/><strong>5</strong><br/><strong>true</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The for…of loop</h1>
                
            
            
                
<p>Until now, we have been iterating over an iterable object using the <kbd>next()</kbd> method, which is a cumbersome task. ES6 introduced the <kbd>for…of</kbd> loop to make this easier.</p>
<p>The <kbd>for…of</kbd> loop was introduced to iterate over the values of an iterable object. Here is an example to demonstrate this:</p>
<pre>function* generator_function(){ <br/> yield 1; <br/> yield 2; <br/> yield 3; <br/> yield 4; <br/> yield 5;<br/>}<br/>let arr = [1, 2, 3];<br/>for(let value of generator_function()){ <br/> console.log(value);<br/>}<br/>for(let value of arr){ <br/> console.log(value);<br/>}</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong><br/><strong>4</strong><br/><strong>5</strong><br/><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Tail call optimization</h1>
                
            
            
                
<p>Whenever a function call is made, an execution stack is created in the stack memory to store the variables of the function. <strong>Tail call optimization</strong> basically means that you reuse the allocated stack in memory if there's no information in that stack that is required later in the code execution sequence.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why tail call optimization?</h1>
                
            
            
                
<p>When a function call is made inside another function call, a new execution stack is created for the inner function call. However, the problem is that the inner function execution stack takes up some extra memory--that is, it stores an extra address, representing where to resume the execution when this function finishes executing. Switching and creating the execution stacks also takes some additional CPU time. This problem is not noticeable when there are a couple  of hundred, nested levels of calls, but it's noticeable when there are thousands or more nested levels of calls--that is, the JavaScript engines throw the <kbd>RangeError: Maximum call stack size exceeded</kbd> exception. You might have, at some point, experienced the <kbd>RangeError</kbd> exception while creating a recursive function.</p>
<p>A tail call is a function call that is performed optionally at the very end of a function with the <kbd>return</kbd> statement. If a tail call leads to the same function call again and again, then it's called a <strong>tail-recursion</strong>, which is a special case of recursion. What's special about tail calls is that there is a way to actually prevent the extra CPU-time and memory usage while making the tail calls, and that is by reusing the stack of the out function, instead of creating a new execution stack. Reusing the execution stack while making a tail call is called tail call optimization.</p>
<p>JavaScript supports tail call optimization in specific browsers if the script is written in the <kbd>"use strict"</kbd> mode. Let's see an example of a tail call:</p>
<pre>"use strict";<br/>function _add(x, y){ <br/>    return x + y;<br/>}<br/>function add1(x, y){ <br/>    x = parseInt(x); <br/>    y = parseInt(y); //tail call <br/>    return _add(x, y);<br/>}<br/>function add2(x, y) {<br/>    x = parseInt(x);<br/>    y = parseInt(y);<br/>    //not tail call<br/>    return 0 + _add(x, y);<br/>}<br/>console.log(add1(1, '1')); //2<br/>console.log(add2(1, '2')); //3</pre>
<p>Here, the <kbd>_add()</kbd> call in the <kbd>add1()</kbd> function is a tail call, as it's the final action of the <kbd>add1()</kbd> function. However, the <kbd>_add()</kbd> call in the <kbd>add2()</kbd> function is not a tail call, as it's not the final act; adding <kbd>0</kbd> to the result of <kbd>_add()</kbd> is the final act.</p>
<p>The <kbd>_add()</kbd> call in <kbd>add1()</kbd> doesn't create a new execution stack. Instead, it reuses the <kbd>add1()</kbd> function's execution stack; in other words, the tail call optimization occurs.</p>
<p>Tail call optimization spec is <strong>not actively</strong> being developed for Chrome and is only implemented in Safari as of now. Hence, you can only use TCO in Safari.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting non-tail calls into tail calls</h1>
                
            
            
                
<p>As tail calls are optimized, you must use tail calls whenever possible, instead of non-tail calls. You can optimize your code by converting the non-tail calls into tail calls.<br/>
Let's see an example of this, which is similar to the previous one:</p>
<pre>"use strict";<br/>function _add(x, y) {<br/>    return x + y; <br/>}<br/><br/>function add(x, y) {<br/> x = parseInt(x);<br/> y = parseInt(y);<br/> const result = _add(x, y);<br/> return result;<br/>}<br/><br/>console.log(add(1, '1'));</pre>
<p>In the previous code, the <kbd>_add()</kbd> call was not a tail call, and therefore, two execution stacks were created. We can convert it into a tail call in this way:</p>
<pre>function add(x, y){ <br/>    x = parseInt(x); <br/>    y = parseInt(y); <br/>    return _add(x, y);<br/>}</pre>
<p>Here, we omitted the use of the <kbd>result</kbd> variable and instead lined up the function call with the <kbd>return</kbd> statement. There are many other similar strategies to convert non-tail calls into tail calls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned a new way of creating the object property keys using symbols. We saw the iterator and iterable protocols and learned how to implement these protocols in custom objects. Then, we learned how to iterate over an iterable object using the <kbd>for…of</kbd> loop. Finally, we ended the chapter by learning what tail calls are, and how they are optimized.</p>
<p>In the next chapter, we will learn about how to do asynchronous programming with Promises and the recently launched async/await feature in ES8, which makes asynchronous code look much more like synchronous code. Let's go!</p>


            

            
        
    </body></html>