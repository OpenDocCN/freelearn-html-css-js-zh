<html><head></head><body>


<h1 class="chap2"><a id="page282" class="calibre6"/><a href="toc.xhtml#c08" class="calibre6">C<small class="calibre8">HAPTER</small> 8</a></h1>
<h1 class="subchap"><a href="toc.xhtml#c08" class="calibre6">Notification Module</a></h1>

<h1 class="sec" id="s217"><a href="toc.xhtml#s217a" class="calibre6">Introduction</a></h1>
<p class="nonindent">Communication is the heart of a process which involves teamwork.</p>
<p class="nonindent">Whenever any activity happens in the project, a notification is sent to the respective users. A developer gets a notification of a task being assigned. A tester gets a notification when the task is moved to testing. A notification is sent to all users watching a particular task whenever a new comment is added to it.</p>
<p class="nonindent">Notifications can be of several types. Email, SMS, and inside user-interface are the most common. This chapter will continue our development path to add a notification module.</p>
<h1 class="sec" id="s218"><a href="toc.xhtml#s218a" class="calibre6">Structure</a></h1>
<p class="nonindent">In this chapter, we will discuss the following topics:</p>
<ul class="bull">
<li class="calibre9">Understanding Notification Module</li>
<li class="calibre9">Implementing Queue</li>
<li class="calibre9">Notifying about the New Task</li>
</ul>
<h1 class="sec" id="s219"><a href="toc.xhtml#s219a" class="calibre6">Understanding Notification Module</a></h1>
<p class="nonindent">Notifications serve as a critical element throughout the lifecycle of the project, informing the respective stakeholders about the ongoing changes and activities. When a new task is assigned to a developer, an email notification can alert with highlights of the task, ensuring that the developer is informed and updated timely. A QA team member can receive an email about a task being moved to the testing phase.</p>
<p class="nonindent">A notification plays an important role in a project’s progress. A notification that is received timely, speeds up the communication among the teams.</p>
<p class="nonindent">The medium of notification can depend on many factors, such as urgency, criticality of communication, nature of the project, and so on.</p>
<p class="nonindent">Typically, there are three types of notifications: Email, SMS, and in-app or inside the user interface notification (in case of websites). In this chapter, we will focus on Emails but the process will also lay down the foundation for implementation of other types of notifications.</p>
<p class="nonindent"><a id="page283"/>Let us start the implementation by creating a new file in <code class="calibre7"><strong class="calibre3">src/util</strong></code> as <code class="calibre7"><strong class="calibre3">notification_util.ts</strong></code>. This file would contain a class which will hold utility methods to send notifications.</p>
<p class="code"><code class="calibre7">// Path: src/utils/notification_util.ts</code></p>
<p class="code1"><code class="calibre7">export class NotificationUtil {</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">This class will be our single point from where all types of notifications can be sent. From anywhere in the code, we can simply make a call to this class. Let us add the functionality for sending an email. We already implemented a function in the <code class="calibre7"><strong class="calibre3">email_util.ts</strong></code> class. That function can act as a reference.</p>
<p class="nonindent">For sending an email, we will use a node package, <code class="calibre7">nodemailer</code>.</p>
<p class="code"><code class="calibre7">import * as nodemailer from 'nodemailer';</code></p>
<p class="nonindent">Let us add the constructor to the util <code class="calibre7"><strong class="calibre3">NotificationUtil</strong></code> as:</p>
<p class="code"><code class="calibre7">// Path: src/utils/notification_util.ts</code></p>
<p class="code1"><code class="calibre7">import * as nodemailer from 'nodemailer';</code></p>
<p class="code1"><code class="calibre7">export class NotificationUtil {</code></p>
<p class="code2"><code class="calibre7">// nodemailer transporter instance</code></p>
<p class="code2"><code class="calibre7">private static transporter;</code></p>
<p class="code2a"><code class="calibre7">constructor(config) {</code></p>
<p class="code3"><code class="calibre7">if (!config) {</code></p>
<p class="code4"><code class="calibre7">throw new Error('Config not provided');</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">if (!NotificationUtil.transporter) {</code></p>
<p class="code4"><code class="calibre7">NotificationUtil.transporter = nodemailer.createTransport({</code></p>
<p class="code5"><code class="calibre7">service: 'gmail',</code></p>
<p class="code5"><code class="calibre7">auth: {</code></p>
<p class="code6"><code class="calibre7">user: config.email_config.user,</code></p>
<p class="code6"><code class="calibre7">pass: config.email_config.password</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7">});</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page284"/>In the preceding code, we have a constructor which takes a config object as the only argument. We will use this config to retrieve the necessary config for sending an email such as SMTP server username, password, and so on.</p>
<p class="nonindent">We have created a transporter object as a private static member of the class. In the context of Node.js and <code class="calibre7"><strong class="calibre3">nodemailer</strong></code>, a transporter is an object which encapsulates the email sending functionality. Simply put, it is a way to send email using Node.js in which we do not have to worry about the low level details of the process. A transporter object is usually created once and reused. Hence, we have the object created at class level. In the constructor, we first check if this is already initialized or not. If the object is not initialized, we do it.</p>
<p class="nonindent">In our case, we are using gmail as a server but other providers and generic SMTP servers can also be used. To know more about the <code class="calibre7"><strong class="calibre3">nodemailer</strong></code>, visit the website <a href="https://nodemailer.com/">https://nodemailer.com/</a>.</p>
<p class="nonindent">Further, we can add our function to send emails. For sending an email, we need the sender email address, recipient email address, subject, email body. Since the sender’s email address is unlikely to be changed for every email, let us add that as a private static variable of the class and we can set that inside the constructor.</p>
<p class="code"><code class="calibre7">private static from: string;</code></p>
<p class="nonindent">In the constructor, we can add the following line after creating the transporter :</p>
<p class="code"><code class="calibre7">NotificationUtil.from = config.email_config.from;</code></p>
<p class="nonindent">Let us define our function to receive these values as arguments.</p>
<p class="code"><code class="calibre7">public async sendEmail(to: string, subject: string, body: string) {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7">const mailOptions = {</code></p>
<p class="code5"><code class="calibre7">from: NotificationUtil.from,</code></p>
<p class="code5"><code class="calibre7">to: to,</code></p>
<p class="code5"><code class="calibre7">subject: subject,</code></p>
<p class="code5"><code class="calibre7">html: body</code></p>
<p class="code4"><code class="calibre7">};</code></p>
<p class="code4a"><code class="calibre7">const status = await</code></p>
<p class="code1"><code class="calibre7">NotificationUtil.transporter.sendMail(mailOptions);</code></p>
<p class="code4"><code class="calibre7">if (status?.messageId) {</code></p>
<p class="code5"><code class="calibre7">return status.messageId;</code></p>
<p class="code4"><code class="calibre7">} else {</code></p>
<p class="code5"><code class="calibre7">return false;</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><code class="calibre7">console.log(`Error while sendEmail =&gt; ${error.message}`);</code></p>
<p class="code4"><code class="calibre7">return false;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page285"/>For the <code class="calibre7"><strong class="calibre3">sendEmail</strong></code> function, we receive just what we need — <code class="calibre7"><strong class="calibre3">to</strong></code> (recipient email address), <code class="calibre7"><strong class="calibre3">subject</strong></code>, and <code class="calibre7"><strong class="calibre3">body</strong></code> of the email. We create an object <code class="calibre7"><strong class="calibre3">mailOptions</strong></code> using these four values and finally send email using <code class="calibre7"><strong class="calibre3">transporter.sendEmail()</strong></code>. If this function successfully sends an email, we will receive a message Id which we can return, otherwise, we will return a <code class="calibre7"><strong class="calibre3">false</strong></code> boolean value indicating that something did not go right.</p>
<p class="nonindent">This completes our email sending feature with the help of <code class="calibre7"><strong class="calibre3">NotificationUtil</strong></code>. We can now use this function instead of the <code class="calibre7"><strong class="calibre3">sendMail</strong></code> function from <code class="calibre7"><strong class="calibre3">email_util.ts</strong></code>.</p>
<p class="nonindent">We are using the <code class="calibre7"><strong class="calibre3">sendMail</strong></code> function from <code class="calibre7"><strong class="calibre3">email_util</strong></code> for the <code class="calibre7"><strong class="calibre3">forgotPassword</strong></code> function in <code class="calibre7"><strong class="calibre3">UserController</strong></code>. Let us change that to use <code class="calibre7"><strong class="calibre3">NotificationUtil</strong></code> by importing the <code class="calibre7"><strong class="calibre3">util</strong></code> in <code class="calibre7"><strong class="calibre3">UserController</strong></code>.</p>
<p class="code"><code class="calibre7">import { NotificationUtil } from '../../utils/notification_util';</code></p>
<p class="nonindent">Now, we can modify the <code class="calibre7"><strong class="calibre3">forgotPassword</strong></code> function to use notification <code class="calibre7"><strong class="calibre3">util</strong></code>. We need to replace the following line:</p>
<p class="code"><code class="calibre7">const emailStatus = await sendMail(mailOptions.to, mailOptions.subject, mailOptions.html);</code></p>
<p class="nonindent">The line replacing would be as follows:</p>
<p class="code"><code class="calibre7">const emailStatus = await NotificationUtil.sendEmail(mailOptions.to, mailOptions.subject, mailOptions.html);</code></p>
<p class="nonindent">Instead of <code class="calibre7"><strong class="calibre3">sendMail</strong></code>, we are using <code class="calibre7"><strong class="calibre3">NotificationUtil.sendEmail</strong></code> function. Rest everything remains the same.</p>
<p class="nonindent">We can also remove the unused <code class="calibre7"><strong class="calibre3">import</strong></code></p>
<p class="code"><code class="calibre7">import { sendMail } from '../../utils/email_util';</code></p>
<p class="nonindent">We also need to initialize the <code class="calibre7"><strong class="calibre3">NotificationUtil</strong></code> from our <code class="calibre7"><strong class="calibre3">main.ts</strong></code> file.</p>
<p class="code"><code class="calibre7">new NotificationUtil(config);</code></p>
<p class="nonindent">The config can be imported as:</p>
<p class="code"><code class="calibre7">import * as config from '../server_config.json';</code></p>
<h1 class="sec" id="s220"><a href="toc.xhtml#s220a" class="calibre6">Implementing Queue</a></h1>
<p class="nonindent">In a large organization there would be a good number of people using project <a id="page286"/>management software. From each user, there would be tons of activities and some of those activities would require an email notification to be sent to other users. If there are a lot of emails to be sent, it is better to handle the communication using a queue. A queue is a mechanism where each call to send email would be added and the queue will be processed separately along with a failure mechanism.</p>
<p class="nonindent">Using a queue in this manner is a good approach for the following reasons:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Improved performance and efficiency</strong>: Sending an email directly can be resource-intensive and may slow down the primary operation. A queue would allow decoupled handling of the email sending process and the response times would be faster.</li>
<li class="calibre9"><strong class="calibre3">Scalability:</strong> As the number of users grows, activities and number of emails to be sent would grow significantly. A queue can handle the increased load. There can be different strategies to handle a queue, for example, separate notification server, separate worker, and so on.</li>
<li class="calibre9"><strong class="calibre3">Reliability:</strong> If an email fails to send, we can easily retry after sometime, if this is carried out through a queue. The failure can be due to many reasons such as server issues and network problems. The queue can be designed to handle failures and be equipped with a mechanism to retry.</li>
<li class="calibre9"><strong class="calibre3">Asynchronous processing:</strong> Queues can be made asynchronous so that the application does not have to wait while email is being sent and we receive a response from the email server.</li>
</ul>
<p class="nonindent">These are some of the few key reasons why it is a good idea to use queues for sending emails.</p>
<p class="nonindent">There can be incidents when we need immediate response to an email sending call and without that we cannot ensure reliability. One such example is the <code class="calibre7"><strong class="calibre3">forgotPassword</strong></code> function which we implemented. In this case, as soon as the user provides their email, we verify things at the backend and send an email. The user would expect an email immediately in his/her mailbox.</p>
<p class="nonindent">In such cases, we can also use hybrid methods for email notifications. In our application, we will also do the same thing. For actions needing immediate email, we will use the <code class="calibre7"><strong class="calibre3">sendEmail</strong></code> function from <code class="calibre7"><strong class="calibre3">NotificationUtil</strong></code> and for the actions which can wait, such as notifying users about a new comment on the task, or when a new task is created, or when a task is moved in the workflow (for example, <code class="calibre7"><strong class="calibre3">Backlog → ToDo → Dev-Complete → Ready-to-test → Closed</strong></code>), and so on, we will use the queue.</p>
<p class="nonindent">Let us move to implement the queue in our <code class="calibre7"><strong class="calibre3">NotificationUtil</strong></code>. For the queue, we need to store the queued objects somewhere outside of the application so that if for any reason the application fails, we do not lose the objects in the queue. For this purpose, we can use Redis.</p>
<h1 class="sec" id="s221"><a id="page287" class="calibre6"/><a href="toc.xhtml#s221a" class="calibre6">Using Redis for Queue</a></h1>
<p class="nonindent">Redis is a powerful in-memory data store that supports necessary data structures and features to implement a basic queue system. The following code snippet shows how a queue can be implemented and used:</p>
<p class="code"><code class="calibre7">const redis = require('redis');</code></p>
<p class="code1"><code class="calibre7">const client = redis.createClient();</code></p>
<p class="code"><code class="calibre7">// Adding a job to the queue</code></p>
<p class="code1"><code class="calibre7">client.lpush('emailQueue', JSON.stringify({</code></p>
<p class="code2"><code class="calibre7">from: 'pms-support@pms.com',</code></p>
<p class="code2"><code class="calibre7">to: 'pmsbook2023@gmail.com',</code></p>
<p class="code2"><code class="calibre7">subject: 'Welcome to PMS',</code></p>
<p class="code2"><code class="calibre7">text: 'Welcome to PMS. We are happy to have you on board.'</code></p>
<p class="code1"><code class="calibre7">}));</code></p>
<p class="code"><code class="calibre7">// Processing jobs from the queue</code></p>
<p class="code1"><code class="calibre7">const processJob = () =&gt; {</code></p>
<p class="code2"><code class="calibre7">client.brpop('emailQueue', 0, (err, reply) =&gt; {</code></p>
<p class="code3"><code class="calibre7">if (err) {</code></p>
<p class="code4"><code class="calibre7">// Handle error</code></p>
<p class="code3"><code class="calibre7">} else {</code></p>
<p class="code4"><code class="calibre7">const job = JSON.parse(reply[1]);</code></p>
<p class="code4"><code class="calibre7">// Process job</code></p>
<p class="code4"><code class="calibre7">console.log('Processing job:', job);</code></p>
<p class="code4"><code class="calibre7">// Continue processing next job</code></p>
<p class="code4"><code class="calibre7">processJob();</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">};</code></p>
<p class="code"><code class="calibre7">// Start processing</code></p>
<p class="code1"><code class="calibre7">processJob();</code></p>
<p class="nonindent"><a id="page288"/>In this code, we created a client using <code class="calibre7"><strong class="calibre3">redis.createClient()</strong></code> at first. This client can be used to push jobs to the queue using <code class="calibre7"><strong class="calibre3">lpush</strong></code>. This call will maintain the records for our processing later. While processing the jobs, we can fetch the items from the same queue using <code class="calibre7"><strong class="calibre3">brpop</strong></code> and process. This can be used in any functionality and not just for sending email. The <code class="calibre7"><strong class="calibre3">lpush</strong></code> and <code class="calibre7"><strong class="calibre3">brpop</strong></code> functions are specific to Redis.</p>
<p class="nonindent">In the preceding code, there is a comment added for handling the error. There can be many ways to handle the error while processing the queue. Once we use <code class="calibre7"><strong class="calibre3">client.brpop</strong></code> it will remove the message from the queue and make it available for processing. If processing of the removed message was a failure, it must be handled in a proper manner.</p>
<p class="nonindent">One way to handle this situation can be to retry the processing again after some time. In this case, we need to save the failed message somewhere so that it can be processed later. Another way can be to simply add a log using console.log and notify the respective stakeholder. If there is an alarm system in place an alert can also be raised.</p>
<p class="nonindent">The approach is simple, we queue something using <code class="calibre7"><strong class="calibre3">lpush</strong></code> and retrieve using <code class="calibre7"><strong class="calibre3">brpop</strong></code> for processing. This implementation helps us to process emails but lacks error handling, retries, maintenance, and much more of what a sophisticated node package such as Bull can provide.</p>
<p class="nonindent">We will use the Bull node package for our implementation. Bull is a popular Node.js library used for handling background jobs and job queues. Bull is built on top of Redis.</p>
<p class="nonindent">Some of the key features of Bull are robustness, job scheduling, concurrency control, retry mechanism, event driven, rate limiting, persistence using redis, and so on. Further information about the package is available at <a href="https://optimalbits.github.io/bull/">https://optimalbits.github.io/bull/</a> .</p>
<p class="nonindent">For our use case, where we want to queue emails, process the queue, handle failures, and improve efficiency, Bull is an excellent choice. Let us start with the implementation by installing and then adding Bull to our application.</p>
<p class="code"><code class="calibre7">npm install bull</code></p>
<p class="nonindent">After installing Bull, we can import it in the <code class="calibre7"><strong class="calibre3">NotificationUtil</strong></code>.</p>
<p class="code"><code class="calibre7">import Queue from 'bull';</code></p>
<p class="nonindent">We need to create a <code class="calibre7"><strong class="calibre3">queue</strong></code> for emails:</p>
<p class="code"><code class="calibre7">private static emailQueue = new Queue('emailQueue', 'redis://127.0.0.1:6379');</code></p>
<p class="nonindent">We also need to add a function which can be called from other parts of the application to enqueue an email job.</p>
<p class="code"><a id="page289"/><code class="calibre7">// Function to enqueue email tasks</code></p>
<p class="code1"><code class="calibre7">public static async enqueueEmail(to: string, subject: string, body: string) {</code></p>
<p class="code2"><code class="calibre7">// Enqueue the email task</code></p>
<p class="code2"><code class="calibre7">await NotificationUtil.emailQueue.add({</code></p>
<p class="code3"><code class="calibre7">to,</code></p>
<p class="code3"><code class="calibre7">subject,</code></p>
<p class="code3"><code class="calibre7">body</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">This is all for enqueuing an email. We just need to use the <code class="calibre7"><strong class="calibre3">emailQueue.add()</strong></code> function to add the object which contains necessary information we need while sending the email.</p>
<p class="nonindent">We need to add logic to process the queue asynchronously. For smaller applications the logic to handle the queue can be part of the application itself. However, when applications grow bigger it is better to put the queue handling as a separate <code class="calibre7"><strong class="calibre3">worker/process</strong></code>.</p>
<p class="nonindent">Let us add a new file for queue workers as <code class="calibre7"><strong class="calibre3">queue_worker.ts</strong></code> in a new directory workers. File path would be <code class="calibre7"><strong class="calibre3">src/workers/queue_worker.ts</strong></code>.</p>
<p class="code"><code class="calibre7">import Queue from 'bull';</code></p>
<p class="code1"><code class="calibre7">import { NotificationUtil } from '../utils/notification_util';</code></p>
<p class="code"><code class="calibre7">export class QueueWorker {</code></p>
<p class="code2"><code class="calibre7">private static emailQueue = new Queue('emailQueue', 'redis://127.0.0.1:6379');</code></p>
<p class="code2"><code class="calibre7">constructor() {</code></p>
<p class="code3"><code class="calibre7">console.log('Initializing QueueWorker');</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">public beginProcessing() {</code></p>
<p class="code3"><code class="calibre7">QueueWorker.emailQueue.process(async (job) =&gt; {</code></p>
<p class="code4"><code class="calibre7">try {</code></p>
<p class="code5"><code class="calibre7">const { to, subject, body } = job.data;</code></p>
<p class="code5"><code class="calibre7">const responseEmail = await NotificationUtil.sendEmail(to, subject, body);</code></p>
<p class="code5"><code class="calibre7">if (!responseEmail) {</code></p>
<p class="code6"><code class="calibre7">// handle error</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code5"><code class="calibre7">console.log(`Email sent to ${to}`);</code></p>
<p class="code4"><code class="calibre7">} catch (error) {</code></p>
<p class="code5"><code class="calibre7">// handle error</code></p>
<p class="code5"><code class="calibre7">console.error(`Failed to send email: ${error.message}`);</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page290"/>The preceding class defines a function to begin processing of the <code class="calibre7"><strong class="calibre3">emailQueue</strong></code> defined as a static member of the class. In the class, while processing jobs to send email we just make a call to <code class="calibre7"><strong class="calibre3">NotificationUtil.sendEmail()</strong></code> function.</p>
<h1 class="sec" id="s222"><a href="toc.xhtml#s222a" class="calibre6">Handling Failures</a></h1>
<p class="nonindent">It can happen that sometimes emails are not sent and we need to retry. The <code class="calibre7"><strong class="calibre3">QueueWorker</strong></code> should be capable of handling such incidents. Let us modify the <code class="calibre7"><strong class="calibre3">beginProcessing</strong></code> function to add support for failed jobs.</p>
<p class="code"><code class="calibre7">public beginProcessing() {</code></p>
<p class="code2"><code class="calibre7">QueueWorker.emailQueue.process(async (job) =&gt; {</code></p>
<p class="code3"><code class="calibre7">// existing logic ..</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code2a"><code class="calibre7">QueueWorker.emailQueue.on('failed', async (job, err) =&gt; {</code></p>
<p class="code3"><code class="calibre7"> // Retry the job</code></p>
<p class="code3"><code class="calibre7"> console.log(`Retrying job for ${job.data.to}`);</code></p>
<p class="code3"><code class="calibre7"> await job.retry();</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">QueueWorker.emailQueue.on</strong></code> function call with <code class="calibre7">'<strong class="calibre3">failed</strong>'</code> status gets executed whenever there is a failed job. In this case, we can retry the job using <code class="calibre7"><strong class="calibre3">job.retry()</strong></code>.</p>
<p class="nonindent">There can be cases, when a failed job fails many more times. Basically, it is never going to succeed. Such cases should be handled with a check on how many attempts were made to run the same task. To fix this, we first need to define a max attempt count.</p>
<p class="code"><code class="calibre7">private static MAX_ATTEMPTS = 4;</code></p>
<p class="nonindent"><a id="page291"/>Now, we need to modify the function again to check if the number of attempts made by a job exceeds the <code class="calibre7"><strong class="calibre3">MAX_ATTTEMPTS</strong></code> or not.</p>
<p class="code"><code class="calibre7">QueueWorker.emailQueue.on('failed', async (job, err) =&gt; {</code></p>
<p class="code2"><code class="calibre7">if (job.attemptsMade &gt;= QueueWorker.MAX_ATTEMPTS) {</code></p>
<p class="code3"><code class="calibre7">// Handle the final failure</code></p>
<p class="code3"><code class="calibre7">console.error(`Job permanently failed for ${job.data.to}: ${err.message}`);</code></p>
<p class="code2"><code class="calibre7">}else {</code></p>
<p class="code3"><code class="calibre7">// Retry the job</code></p>
<p class="code3"><code class="calibre7">console.log(`Retrying job for ${job.data.to}`);</code></p>
<p class="code3"><code class="calibre7">await job.retry();</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">This will retry the failed job for four times and then exit if it does not succeed in four attempts. We should handle the case when the job finally fails. This can be done by some other kind of notification, proper reporting in logs, or recording the incident in a persisted mode, for example, in a database table.</p>
<h1 class="sec" id="s223"><a href="toc.xhtml#s223a" class="calibre6">Notifying About the New Task</a></h1>
<p class="nonindent">Till this point, we have a basic implementation of the queue for email notifications. We can now use it for other parts of the application. As an example, let us try to add notifications for all members of a project whenever there is a new task created.</p>
<p class="nonindent">Let us first add the following function in <code class="calibre7"><strong class="calibre3">ProjectsUtil</strong></code> :</p>
<p class="code"><code class="calibre7">public static async getProjectByProjectId(project_id: string) {</code></p>
<p class="code3"><code class="calibre7">const projectService = new ProjectsService();</code></p>
<p class="code3"><code class="calibre7">const project = await projectService.findOne(project_id);</code></p>
<p class="code3"><code class="calibre7">return project.data;</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">To send a notification, we need to first get the users of the project and we can get it from the project object. After this, let us update the <code class="calibre7"><strong class="calibre3">addHandler()</strong></code> in <code class="calibre7"><strong class="calibre3">TaskController</strong></code> inside <code class="calibre7"><strong class="calibre3">task_controller.ts</strong></code> file.</p>
<p class="code"><code class="calibre7">public async addHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2a"><code class="calibre7">if (!hasPermission(req?.user?.rights, 'add_task')) {</code></p>
<p class="code3"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });</code></p>
<p class="code3"><code class="calibre7"><a id="page292"/>return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2a"><code class="calibre7">try {</code></p>
<p class="code3"><code class="calibre7">// Create an instance of the TaskService</code></p>
<p class="code3"><code class="calibre7">const service = new TasksService();</code></p>
<p class="code3a"><code class="calibre7">// Extract task data from the request body</code></p>
<p class="code3"><code class="calibre7">const task = req.body;</code></p>
<p class="code3a"><code class="calibre7">// Get the project</code></p>
<p class="code3"><code class="calibre7">const project = await ProjectsUtil.getProjectByProjectId(task.project_id);</code></p>
<p class="code3a"><code class="calibre7">//check if the provided project_id is valid</code></p>
<p class="code3"><code class="calibre7">const isValidProject = project ? true : false;</code></p>
<p class="code3"><code class="calibre7">if (!isValidProject) {</code></p>
<p class="code4"><code class="calibre7">// If user_ids are invalid, send an error response</code></p>
<p class="code4"><code class="calibre7">res.status(400).json({ statusCode: 400, status: 'error', message: 'Invalid project_id' });</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3a"><code class="calibre7">// Check if the provided user_id is valid</code></p>
<p class="code3"><code class="calibre7">const isValidUser = await UsersUtil.checkValidUserIds([task.user_id]);</code></p>
<p class="code3a"><code class="calibre7">if (!isValidUser) {</code></p>
<p class="code4"><code class="calibre7">// If user_ids are invalid, send an error response</code></p>
<p class="code4"><code class="calibre7">res.status(400).json({ statusCode: 400, status: 'error', message: 'Invalid user_id' });</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3a"><code class="calibre7">// If user_ids are valid, create the task</code></p>
<p class="code3"><code class="calibre7">const createdTask = await service.create(task);</code></p>
<p class="code3"><code class="calibre7">res.status(201).json(createdTask);</code></p>
<p class="code3a"><a id="page293"/><code class="calibre7">// task is created, now send email to the user</code></p>
<p class="code3"><code class="calibre7">const userIds = project.user_ids;</code></p>
<p class="code3a"><code class="calibre7">// for each user_id, enqueue an email task</code></p>
<p class="code3"><code class="calibre7">for (const userId of userIds) {</code></p>
<p class="code4"><code class="calibre7">const user = await UsersUtil.getUserById(userId);</code></p>
<p class="code4"><code class="calibre7">if (user) {</code></p>
<p class="code6"><code class="calibre7">await NotificationUtil.enqueueEmail(</code></p>
<p class="code6"><code class="calibre7">user.email,</code></p>
<p class="code6"><code class="calibre7">'New Task Created',</code></p>
<p class="code6"><code class="calibre7">`A new task has been created with the title ${task.title} and description ${task.description}`);</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2a"><code class="calibre7">} catch (error) {</code></p>
<p class="code3"><code class="calibre7">// Handle errors and send an appropriate response</code></p>
<p class="code3"><code class="calibre7">console.error(`Error while addUser =&gt; ${error.message}`);</code></p>
<p class="code3"><code class="calibre7">res.status(500).json({ statusCode: 500, status: 'error', message: 'Internal server error' });</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The function we need at <code class="calibre7">UserUtil</code> to get user by user_id is -</p>
<p class="code"><code class="calibre7">public static async getUserById(user_id: string) {</code></p>
<p class="code2"><code class="calibre7">const userService = new UsersService();</code></p>
<p class="code2a"><code class="calibre7">const queryResult = await userService.findOne(user_id);</code></p>
<p class="code2"><code class="calibre7">if (queryResult.statusCode === 200) {</code></p>
<p class="code3"><code class="calibre7">const user = queryResult.data;</code></p>
<p class="code3"><code class="calibre7">return user;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">return null;</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page294"/>The logic of sending email can also be moved to a separate function. We can add a <code class="calibre7"><strong class="calibre3">utility</strong></code> class for Tasks inside <code class="calibre7"><strong class="calibre3">tasks_controller.ts</strong></code> similar to projects and users.</p>
<p class="code"><code class="calibre7">export class TaskUtil {</code></p>
<p class="code2a"><code class="calibre7">// Notify the users of the project that a change</code></p>
<p class="code2"><code class="calibre7">public static async notifyUsers(project, task) {</code></p>
<p class="code3"><code class="calibre7">if (project) {</code></p>
<p class="code4"><code class="calibre7">const userIds = project.user_ids;</code></p>
<p class="code4"><code class="calibre7">for (const userId of userIds) {</code></p>
<p class="code5"><code class="calibre7">const user = await UsersUtil.getUserById(userId);</code></p>
<p class="code5"><code class="calibre7">if (user) {</code></p>
<p class="code6"><code class="calibre7">await NotificationUtil.enqueueEmail(</code></p>
<p class="code7"><code class="calibre7">user.email,</code></p>
<p class="code7"><code class="calibre7">'New Task Created',</code></p>
<p class="code7"><code class="calibre7">`A new task has been created with the title ${task.title} and description ${task.description}`</code></p>
<p class="code6"><code class="calibre7">);</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The preceding function takes a project and task object and notifies all users. We can make a call to this function from the <code class="calibre7"><strong class="calibre3">addHandler</strong></code>. The updated <code class="calibre7"><strong class="calibre3">addHandler()</strong></code> function would be:</p>
<p class="code"><code class="calibre7">public async addHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3a"><code class="calibre7">if (!hasPermission(req?.user?.rights, 'add_task')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3a"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7">// Create an instance of the TaskService</code></p>
<p class="code4"><code class="calibre7">const service = new TasksService();</code></p>
<p class="code4a"><a id="page295"/><code class="calibre7">// Extract task data from the request body</code></p>
<p class="code4"><code class="calibre7">const task = req.body;</code></p>
<p class="code4a"><code class="calibre7">// Get the project</code></p>
<p class="code4"><code class="calibre7">const project = await</code></p>
<p class="code1"><code class="calibre7">ProjectsUtil.getProjectByProjectId(task.project_id);</code></p>
<p class="code4a"><code class="calibre7">//check if the provided project_id is valid</code></p>
<p class="code4"><code class="calibre7">const isValidProject = project ? true : false;</code></p>
<p class="code4"><code class="calibre7">if (!isValidProject) {</code></p>
<p class="code5"><code class="calibre7">// If user_ids are invalid, send an error response</code></p>
<p class="code5"><code class="calibre7">res.status(400).json({ statusCode: 400, status: 'error', message: 'Invalid project_id' });</code></p>
<p class="code5"><code class="calibre7">return;</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code4a"><code class="calibre7">// Check if the provided user_id is valid</code></p>
<p class="code4"><code class="calibre7">const isValidUser = await UsersUtil.checkValidUserIds([task.user_id]);</code></p>
<p class="code4a"><code class="calibre7">if (!isValidUser) {</code></p>
<p class="code5"><code class="calibre7">// If user_ids are invalid, send an error response</code></p>
<p class="code5"><code class="calibre7">res.status(400).json({ statusCode: 400, status: 'error', message: 'Invalid user_id' });</code></p>
<p class="code5"><code class="calibre7">return;</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code4a"><code class="calibre7">// If user_ids are valid, create the task</code></p>
<p class="code4"><code class="calibre7">const createdTask = await service.create(task);</code></p>
<p class="code4"><code class="calibre7">res.status(201).json(createdTask);</code></p>
<p class="code4a"><code class="calibre7">// Notify the users of the project that a new task has been created</code></p>
<p class="code4"><code class="calibre7">await TaskUtil.notifyUsers(project, task);</code></p>
<p class="code3a"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><a id="page296"/><code class="calibre7">// Handle errors and send an appropriate response</code></p>
<p class="code4"><code class="calibre7">console.error(`Error while addUser =&gt; ${error.message}`);</code></p>
<p class="code4"><code class="calibre7">res.status(500).json({ statusCode: 500, status: 'error', message: 'Internal server error' });</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">We can re-use the same function for update and delete handlers by a simple modification. We can pass an argument `<code class="calibre7"><strong class="calibre3">action</strong></code>` which takes one value out of <code class="calibre7"><strong class="calibre3">add</strong></code>, <code class="calibre7"><strong class="calibre3">update</strong></code>, <code class="calibre7"><strong class="calibre3">delete</strong></code>. Based on this action, we can modify the subject and content of the email. Following is the updated function:</p>
<p class="code"><code class="calibre7">public static async notifyUsers(project, task, action) {</code></p>
<p class="code2"><code class="calibre7">if (project) {</code></p>
<p class="code3"><code class="calibre7">const userIds = project.user_ids;</code></p>
<p class="code3a"><code class="calibre7">let subject = '';</code></p>
<p class="code3"><code class="calibre7">let body = '';</code></p>
<p class="code3"><code class="calibre7">if (action === 'add') {</code></p>
<p class="code4"><code class="calibre7">subject = 'New Task Created';</code></p>
<p class="code4"><code class="calibre7">body = `A new task has been created with the title ${task.title} and description ${task.description}`;</code></p>
<p class="code3"><code class="calibre7">} else if (action === 'update') {</code></p>
<p class="code4"><code class="calibre7">subject = 'Task Updated';</code></p>
<p class="code4"><code class="calibre7">body = `A task has been updated with the title ${task.title} and description ${task.description}`;</code></p>
<p class="code3"><code class="calibre7">} else if (action === 'delete') {</code></p>
<p class="code4"><code class="calibre7">subject = 'Task Deleted';</code></p>
<p class="code4"><code class="calibre7">body = `A task has been deleted with the title ${task.title} and description ${task.description}`;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">for (const userId of userIds) {</code></p>
<p class="code4"><code class="calibre7">const user = await UsersUtil.getUserById(userId);</code></p>
<p class="code4"><code class="calibre7">if (user) {</code></p>
<p class="code5"><code class="calibre7">await NotificationUtil.enqueueEmail(</code></p>
<p class="code6"><code class="calibre7">user.email,</code></p>
<p class="code6"><code class="calibre7">subject,</code></p>
<p class="code6"><code class="calibre7">body</code></p>
<p class="code5"><code class="calibre7">);</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page297"/>Here, we are making the subject and body of the email based on the action provided. We also need to modify the call accordingly:</p>
<p class="code"><code class="calibre7">// Notify the users of the project that a new task has been created</code></p>
<p class="code1"><code class="calibre7">await TaskUtil.notifyUsers(project, task, 'add');</code></p>
<p class="nonindent">Similar to <code class="calibre7"><strong class="calibre3">addHandler</strong></code>, we can make call from <code class="calibre7"><strong class="calibre3">updateHandler()</strong></code> and <code class="calibre7"><strong class="calibre3">deleteHandler()</strong></code> <code class="calibre7"><strong class="calibre3">deleteHandler()</strong></code> as:</p>
<p class="code"><code class="calibre7">await TaskUtil.notifyUsers(project, task, 'update');</code></p>
<p class="code1"><code class="calibre7">await TaskUtil.notifyUsers(project, task, 'delete');</code></p>
<h1 class="sec" id="s224"><a href="toc.xhtml#s224a" class="calibre6">Considerations while Implementing Queues</a></h1>
<p class="nonindent">There is a set of challenges to consider while implementing a queue. Let us discuss a few of those here:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Scalability</strong>
<p class="nonindent">When it comes to handling high volumes of messages, ensuring the smooth handling can be challenging. In such cases, using multiple queues (spread across different machines) to balance the load could be helpful.</p></li>
<li class="calibre9"><strong class="calibre3">Latency and Throughput</strong>
<p class="nonindent">Throughput is the number of messages processed in a given timeframe. When there is a high volume of messages to process and the application flow is critical it becomes vital to ensure that the latency is within permissible limits. Higher latencies can be a bottleneck in real-time applications. To tackle such situations requires optimizations at application, queue and network level to achieve desirable throughput.</p></li>
<li class="calibre9"><strong class="calibre3">Fault Tolerance and Recovery</strong>
<p class="nonindent">There can be cases when due an issue in the application the queue stops processing the messages. The messages must still be processed after the application has recovered from error. There should be a mechanism so that the messages in queue (waiting to be processed) are persisted or kept safe.</p></li>
</ul>
<p class="nonindent">There are other considerations, for example, ordering and consistency of delivery of messages, security, monitoring while implementing the queue system. With help of careful design of the application these problems can be avoided, or in worst case, mitigated.</p>
<h1 class="sec" id="s225"><a id="page298" class="calibre6"/><a href="toc.xhtml#s225a" class="calibre6">Conclusion</a></h1>
<p class="nonindent">This chapter introduced a new concept <code class="calibre7">'Queue'</code> which is very important to handle processing of various types of data. In our case, we used it for email notifications. The <code class="calibre7"><strong class="calibre3">NotificationUtil</strong></code> and <code class="calibre7"><strong class="calibre3">QueueWorker</strong></code> together implemented the queue mechanism with the help of the <code class="calibre7">Bull</code>, a <code class="calibre7"><strong class="calibre3">Node.js</strong></code> library built on top of Redis.</p>
<p class="nonindent">In the next chapter, we will learn how an application can be built for production and be deployed on real servers. We will also learn to obfuscate the code so that, if it falls in wrong hands, it will not reveal everything and make the job harder for an outsider to crack.</p>
<h1 class="sec" id="s226"><a href="toc.xhtml#s226a" class="calibre6">Multiple Choice Questions</a></h1>
<ol class="num">
<li class="calibre9">What is the primary purpose of notifications in a project lifecycle?
<ol class="alfa">
<li class="calibre9">To provide entertainment.</li>
<li class="calibre9">To inform stakeholders about changes and activities.</li>
<li class="calibre9">To gather feedback.</li>
<li class="calibre9">To schedule meetings.</li></ol></li>
<li class="calibre9">How does a queue contribute to the scalability of email sending in a project management system?
<ol class="alfa">
<li class="calibre9">By limiting the number of users.</li>
<li class="calibre9">By reducing the number of emails sent.</li>
<li class="calibre9">By handling increased load effectively.</li>
<li class="calibre9">By sending all emails immediately.</li></ol></li>
<li class="calibre9">What is a key advantage of a queue in terms of reliability for email notifications?
<ol class="alfa">
<li class="calibre9">It guarantees email delivery on the first attempt.</li>
<li class="calibre9">It simplifies email content.</li>
<li class="calibre9">It allows for retrying failed email sends.</li>
<li class="calibre9">It uses less server resources per email.</li></ol></li>
<li class="calibre9"><a id="page299"/>Why is Redis chosen for implementing the queue in NotificationUtil?
<ol class="alfa">
<li class="calibre9">For its complexity.</li>
<li class="calibre9">Because it is an in-memory data store with suitable features.</li>
<li class="calibre9">Solely for cost-saving purposes.</li>
<li class="calibre9">For its slow processing speed.</li></ol></li>
<li class="calibre9">What is the purpose of a transporter in Node.js and nodemailer?
<ol class="alfa">
<li class="calibre9">To store email templates.</li>
<li class="calibre9">To encapsulate the email sending functionality.</li>
<li class="calibre9">To manage database connections.</li>
<li class="calibre9">To encrypt email content.</li></ol></li>
<li class="calibre9">How does a timely received notification affect team communication?
<ol class="alfa">
<li class="calibre9">It has no significant impact.</li>
<li class="calibre9">It slows down communication.</li>
<li class="calibre9">It speeds up communication.</li>
<li class="calibre9">It complicates communication.</li></ol></li>
<li class="calibre9">What factors influence the medium of notification?
<ol class="alfa">
<li class="calibre9">Developer’s preference.</li>
<li class="calibre9">Time of the day.</li>
<li class="calibre9">Urgency, criticality of communication, nature of the project.</li>
<li class="calibre9">Cost of the notification system.</li></ol></li>
<li class="calibre9">How is the transporter object typically used in a Node.js application?
<ol class="alfa">
<li class="calibre9">Created for each email sent.</li>
<li class="calibre9">Created once and reused.</li>
<li class="calibre9">Only used for receiving emails.</li>
<li class="calibre9">Initialized in every function call.</li></ol></li>
</ol>
<h1 class="sec1" id="s227"><a id="page300" class="calibre6"/><a href="toc.xhtml#s227a" class="calibre6">Answers</a></h1>
<ol class="num">
<li class="calibre9">b</li>
<li class="calibre9">c</li>
<li class="calibre9">c</li>
<li class="calibre9">b</li>
<li class="calibre9">b</li>
<li class="calibre9">c</li>
<li class="calibre9">c</li>
<li class="calibre9">b</li>
</ol>
<h1 class="sec" id="s228"><a href="toc.xhtml#s228a" class="calibre6">Further Readings</a></h1>
<p class="nonindent"><a href="https://nodemailer.com/">https://nodemailer.com/</a></p>
<p class="nonindent"><a href="https://redis.io/">https://redis.io/</a></p>
<p class="nonindent"><a href="https://www.npmjs.com/package/redis">https://www.npmjs.com/package/redis</a></p>
<p class="nonindent"><a href="https://redis.com/glossary/redis-queue/">https://redis.com/glossary/redis-queue/</a></p>
<p class="nonindent"><a href="https://en.wikipedia.org/wiki/Message_queue">https://en.wikipedia.org/wiki/Message_queue</a></p>

</body></html>