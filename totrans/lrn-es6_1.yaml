- en: Chapter 1. Playing with Syntax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript** was lacking behind some other programming languages when compared
    to various syntactic forms such as declaring constant variables, declaring block
    scoped variables, extracting data from arrays, shorter syntax for declaring functions
    and so on. **ES6** adds up a lot of new syntax-based features to JavaScript, which
    helps the developers to write less and do more. ES6 also prevents programmers
    from using various hacks for achieving various goals, which have negative performance
    impact and made code harder to read. In this chapter, we will look at the new
    syntactic features, introduced by ES6.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Creating the block scoped variables using the `let` keyword
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating constant variables using the `const` keyword
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The spread operator and the rest parameter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the data from iterables and objects using the destructuring assignment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrow functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new syntaxes for creating the object properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The let keyword
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ES6 `let` keyword is used to declare a block scoped variable, optionally
    initializing it to a value. The programmers who come from other programming language
    background, but new to JavaScript, often end up writing error-prone JavaScript
    programs, believing that the JavaScript variables are block scoped. Almost every
    popular programming language has the same rules when it comes to the variable
    scopes, but JavaScript acts a bit different due to a lack of the block scoped
    variables. Due to the fact that JavaScript variables are not block scoped, there
    are chances of memory leak and also the JavaScript programs are harder to read
    and debug.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Declaring function scoped variables
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript variables that are declared using the `var` keyword are called
    as **function scoped** variables. The function scoped variables are accessible
    globally to the script, that is, throughout the script, if declared outside a
    function. Similarly, if the function scoped variables are declared inside a function,
    then they become accessible throughout the function, but not outside the function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to create the function-scoped variables:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the code is:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the `c` variable is accessible outside the `if` statement,
    but this is not the case in other programming languages. So, the programmers coming
    from other languages would expect the `c` variable to be undefined outside the
    `if` statement, but that's not the case. Therefore, ES6 had introduced the `let`
    keyword, which can be used for creating variables that are block scoped.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Declaring block scoped variables
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables that are declared using the `let` keyword are called as block scoped
    variables. The block scoped variables behave the same way as the function scoped
    variables when declared outside a function, that is, they are accessible globally.
    But when the block scoped variables are declared inside a block, then they are
    accessible inside the block that they are defined in (and also any sub-blocks)
    but not outside the block.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A block is used to group zero or more statements. A pair of curly brackets delimits
    the block, that is `{}`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the previous example script, replace `var` with the `let` keyword,
    and see the output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the code is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, the output is as expected by a programmer who is used to another programming
    language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Re-declaring variables
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you declare a variable using the `var` keyword that is already declared
    using `var` keyword (in the same scope) then it''s overwritten. Consider this
    example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the code is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output is as expected. But the variables created using the `let` keyword
    don't behave in the same way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare a variable using the `let` keyword that is already declared
    using the `let` keyword in the same scope, then it throws a `TypeError` exception.
    Consider this example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you declare a variable with a name that''s already accessible in a function
    (or inner function), or is a sub-block using `var` or the `let` keyword respectively,
    then it''s a different variable. Here, is an example that shows the behavior:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the code is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`var` versus `let`, which one to use?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: When writing the ES6 code, it is recommended to switch to using the `let` keyword
    because it makes scripts more memory friendly, prevents scoping mistakes, prevents
    accidental bugs, and makes the code easier to read. But if you are already addicted
    to the `var` keyword and comfortable using it, then you can still use this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why not just make the `var` keyword to define the block-scoped
    variables instead of introducing the `let` keyword? The reason why the `var` keyword
    wasn't made enough to define block-scoped variables, instead of introducing the
    `let` keyword, was for the sake of backward compatibility.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The const keyword
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ES6 `const` keyword is used to declare the read-only variables, that is,
    the variables whose value cannot be reassigned. Before ES6, the programmers usually
    used to prefix the variables that were supposed to be constant. For example, take
    a look at the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The value of `pi` should always remain constant. Here, although we have prefixed
    it, there is still a chance that we might accidentally change its value somewhere
    in the program, as they're no native protection to the value of `pi`. Prefixing
    is just not enough to keep the track of the constant variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the `const` keyword was introduced to provide a native protection
    to the constant variables. So, the previous program should be written in this
    way in ES6:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, when we tried to change the value of `pi`, a read-only exception was thrown.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The scope of constant variables
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constant variables are block-scoped variables, that is, they follow the same
    scoping rules as the variables that are declared using the `let` keyword. Here
    is an example, which shows the scope of the constant variables:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding code is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can see that the constant variables behave in the same way as the block
    scoped variables, when it comes to the scoping rules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the objects using constant variables
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we assign an object to a variable, the reference of the object is what
    the variable holds and not the object itself. So, when assigning an object to
    a constant variable, the reference of the object becomes constant to that variable
    and not to the object itself. Therefore, the object is mutable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the preceding code is:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `a` variable stores the address (that is, reference) of
    the object. So the address of the object is the value of the `a` variable, and
    it cannot be changed. But the object is mutable. So when we tried to assign another
    object to the `a` variable, we got an exception as we were trying to change the
    value of the `a` variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Default parameter values
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript there is no defined way to assign the default values to the function
    parameters that are not passed. So, the programmers usually check for the parameters
    with the `undefined` value (as it is the default value for the missing parameters),
    and assign the default values to them. Here is an example, which shows how to
    do this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'ES6 provides a new syntax that can be used to do this in an easier way. Here
    is the code which demonstrates how to do this in ES6:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, passing `undefined` is considered as missing an argument. Here is an
    example to demonstrate this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Defaults can also be expressions. Here is an example to demonstrate this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The spread operator
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**A spread operator** is represented by the "`…`" token. A spread operator
    splits an iterable object into the individual values.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An iterable is an object that contains a group of values, and implements ES6
    iterable protocol to let us iterate through its values. An array is an example
    of built in an iterable object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: A spread operator can be placed wherever multiple function arguments or multiple
    elements (for array literals) are expected in code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The spread operator is commonly used to spread the values of an iterable object
    into the arguments of a function. Let's take an example of an array and see how
    to split it into the arguments of a function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, for providing the values of an array as function argument, the
    programmers used the `apply()` method of functions. Here is an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the apply method takes an array, extracts the values, passes them as individual
    arguments to the function, and then calls it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 provides an easy way to do this, using the spread operator. Here is an
    example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'During runtime, before the JavaScript interpreter calls the `myFunction` function,
    it replaces `…data` with the `1,4` expression:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code is replaced with:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After this, the function is called.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A spread operator doesn't call the `apply()` method. The JavaScript runtime
    engine spreads the array using the iteration protocols, and has nothing to do
    with the `apply()` method, but the behavior is same.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Other usages of the spread operator
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spread operator is not just limited to spreading an iterable object into
    the function arguments, but it can be used wherever multiple elements (for array
    literals) are expected in code. So it has many uses. Let's see some other use
    cases of the spread operator for arrays.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Making array values a part of another array
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It can also be used to make the array values a part of another array. Here is
    an example code that demonstrates how to make the values of an existing array
    a part of another array while creating it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here the following line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Will be replaced with the following line:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Pushing the values of an array into another array
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we may need to push the values of an existing array into the end
    of another existing array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, this is how the programmers used to do it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But in ES6 we have a much cleaner way to do it, which is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here the push method takes a series of variables, and adds them to the end of
    the array on which it is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the following line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Will be replaced with the following line:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Spreading multiple arrays
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple arrays can be spread on a single line of expression. For example,
    take the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The rest parameter
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rest parameter is also represented by the "`…`" token. The last parameter
    of a function prefixed with "`…`" is called as a rest parameter. The rest parameter
    is an array type, which contains the rest of the parameters of a function when
    number of arguments exceeds the number of named parameters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The rest parameter is used to capture a variable number of the function arguments
    from within a function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Before ES6, the programmers used the `arguments` object of a function to retrieve
    the extra arguments, passed to the function. The `arguments` object is not an
    array, but it provides some interfaces that are similar to an array.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that shows how to use the `arguments` object to retrieve
    the extra arguments:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In ES6, this can be done in a much easier and cleaner way, using the rest parameter.
    Here is an example of using the rest parameter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `arguments` object is not an array object. Therefore, to do array operations
    on the `arguments` object, you need to first convert it to an array. As the ES6
    rest parameter is an array type, it's easier to work with it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the "…" token called?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The "…" token is called as the spread operator or rest parameter, depending
    on where and how it's used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The destructuring assignment
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The destructuring assignment is an expression that allows you to assign the
    values or properties of an iterable or object, to the variables, using a syntax
    that looks similar to the array or object construction literals respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: A destructuring assignment makes it easy to extract data from iterables or objects
    by providing a shorter syntax. A destructuring assignment is already present in
    the programming languages, such as **Perl** and **Python**, and works the same
    way everywhere.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of destructuring assignment expressions—the array and object
    destructuring assignment. Let's see each of them in details.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The array destructuring assignment
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array destructuring assignment is used to extract the values of an iterable
    object and assign them to the variables. It's named as the *array destructuring
    assignment* because the expression is similar to an array construction literal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, the programmers used to do it this way to assign the values of
    an array to the variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we are extracting the values of an array and assigning them to the `a`,
    `b`, `c` variables respectively.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES6, we can do this in just one line statement using the array destructuring
    assignment:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you see, the `[a, b, c]` is the array destructuring expression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side of the array destructuring statement, we need to place
    the variables to which we want to assign the array values, using syntax similar
    to an array literal. On right-hand side, we need to place an array (actually any
    iterable object) whose values we want to extract.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example code can be made even shorter in this way:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here we create the variables on the same statement and instead of providing
    the array variable, we provide the array with a construction literal.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: If there are fewer variables than items in the array, then only the first items
    are considered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you place a non-iterable object on the right-hand side of the array destructuring
    assignment syntax, then a `TypeError` exception is thrown.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring values
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also ignore some of the values of the iterable. Here is example code,
    which shows how to do this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using the rest operator in the array destructuring assignment
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can prefix the last variable of the array destructuring expression using
    the "`…`" token. In this case, the variable is always converted into an array
    object, which holds the rest of the values of the iterable object, if the number
    of other variables is less than the values in the iterable object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example to understand it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the previous example code, you can see that the `b` variable is converted
    into an array, and it holds all the other values of the right-hand side array.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Here the "`…`" token is called as the **rest operator**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also ignore the values while using the rest operator. Here is an example
    to demonstrate this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we ignored the `2,` `3` values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Default values for variables
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While destructuring, you can also provide the default values to the variables
    if an array index is `undefined`. Here is an example to demonstrate this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Nested array destructuring
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also extract the values from a multi-dimensional array and assign them
    to variables. Here is an example to demonstrate this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using the destructuring assignment as a parameter
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use the array destructuring expression as the function parameter
    for extracting the values of an iterable object, passed as argument into the function
    parameters. Here is an example to demonstrate this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Earlier in this chapter, we saw that if we pass `undefined` as an argument
    to a function call, then JavaScript checks for the default parameter value. So,
    we can provide a default array here too, which will be used if the argument is
    `undefined`. Here is an example to demonstrate this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we passed `undefined` as an argument and therefore, the default array,
    which is `[1, 2, 3]`, was used for extracting the values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The object destructuring assignment
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object destructuring assignment is used to the extract property values of
    an object and assign them to the variables.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, the programmers used to do it in the following way to assign the
    values of an object''s properties to the variables:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In ES6, we can do this in just one line statement, using the object destructuring
    assignment:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: On the left-hand side of the object destructuring statement, we need to place
    the variables to which we want to assign the object property values using syntax
    similar to object literal. On right-hand side, we need to place an object whose
    property values we want to extract are finally close the statement using the `(
    )` token.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the variable names must be same as the object property names. If you want
    to assign different variable names, then you can do it this way:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The previous code can be made even shorter this way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here we are create the variables and object on the same line. We don't need
    to close the statement using the `( )` token, as we are creating the variables
    on the same statement.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Default values for the variables
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also provide the default values to the variables, if the object property
    is `undefined` while destructuring. Here is an example to demonstrate this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Destructuring computed property names
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some property names are constructed dynamically using expressions. In this
    case, to extract the property values, we can use the `[ ]` token to provide the
    property name an expression. Here is an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Destructuring nested objects
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also the extract property values from the nested objects, that is, the
    objects within the objects. Here is an example to demonstrate this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the object destructuring assignment as a parameter
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like the array destructuring assignment, we can also use the object destructuring
    assignment as a function parameter. Here is an example to demonstrate this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we passed an empty object as a default parameter value, which will be
    used as a default object if `undefined` is passed as a function argument.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The arrow functions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 provides a new way to create functions using the `=>` operator. These functions
    are called as **arrow** functions. This new method has a shorter syntax, and the
    arrow functions are the anonymous functions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to create an arrow function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, `circleArea` is a variable, referencing to the anonymous arrow function.
    The previous code is similar to the next code in ES5:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If an arrow function contains just one statement, then you don''t have to use
    the `{}` brackets to wrap the code. Here is an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When `{}` brackets are not used then the value of the statement in the body
    is automatically returned.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The value of "this" in an arrow function
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the arrow functions, the value of `this` keyword is same as the value of
    `this` keyword of the enclosing scope (the global or function scope, inside whichever
    the arrow function is defined), instead of referring to the context object (that
    is, the object inside of which the function is a property), which is the value
    of `this` in traditional functions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example to understand the difference in the traditional function''s
    and the arrow function''s `this` value:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, `this` inside the `f1` function refers to `object,` as `f1` is the property
    of it. `this` inside `f2` refers to the `window` object, as `f2` is a property
    of the `window` object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'But `this` behaves differently in the arrow functions. Let''s replace the traditional
    functions with the arrow functions in the preceding code and see the value of
    this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, `this` inside the `f1` function copies the `this` value of global scope,
    as `f1` lies in global scope. `this` inside `f2` copies the `this` value of `f1,`
    as `f2` lies in the `f1` scope.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Other differences between the arrow and traditional functions
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arrow functions cannot be used as object constructors that is, the `new`
    operator cannot be applied on them.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Apart from syntax, the `this` value, and the `new` operator, everything else
    is the same between the arrow and traditional functions, that is, they both are
    the instances of `the` `Function` constructor.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The enhanced object literals
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 has added some new syntax-based extensions to the `{}` object literal for
    creating properties. Let''s see them:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Defining properties
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 provides a shorter syntax for assigning the object properties to the values
    of the variables, which have the same name as the properties.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES5, you have been doing this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In ES6, you can do it this way:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Defining methods
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 provides a new syntax for defining the methods on an object. Here is an
    example to demonstrate the new syntax:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This concise function allows the use of `super` in them, whereas the traditional
    methods of the objects don't allow the use of `super`. We will learn more about
    it later in this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The computed property names
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性名称
- en: The property names that are evaluated during runtime are called as the **computed
    property names**. An expression is usually resolved to find the property name
    dynamically.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时评估的属性名称被称为**计算属性名称**。通常，表达式会被解析以动态地找到属性名称。
- en: 'In ES5, the computed properties are defined in this way:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，计算属性是这样定义的：
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, after creating the object, we attach the properties to the object. But
    in ES6, we can add the properties with the computed name while creating the objects.
    Here is an example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在创建对象之后，我们将属性附加到对象上。但在ES6中，我们可以在创建对象的同时添加具有计算名称的属性。以下是一个示例：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the variable's scopes, read-only variables,
    splitting arrays into individual values, passing indefinite parameters to a function,
    extracting data from objects and arrays, arrow functions, and new syntaxes for
    creating object properties.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了变量的作用域、只读变量、将数组拆分为单个值、向函数传递不定参数、从对象和数组中提取数据、箭头函数以及创建对象属性的新语法。
- en: In the next chapter, we will learn about built-in objects and symbols, and we
    will discover the properties added by ES6 into strings, arrays, and objects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习内置对象和符号，并发现ES6为字符串、数组和对象添加的新属性。
