- en: Chapter 1. Playing with Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript** was lacking behind some other programming languages when compared
    to various syntactic forms such as declaring constant variables, declaring block
    scoped variables, extracting data from arrays, shorter syntax for declaring functions
    and so on. **ES6** adds up a lot of new syntax-based features to JavaScript, which
    helps the developers to write less and do more. ES6 also prevents programmers
    from using various hacks for achieving various goals, which have negative performance
    impact and made code harder to read. In this chapter, we will look at the new
    syntactic features, introduced by ES6.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the block scoped variables using the `let` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating constant variables using the `const` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The spread operator and the rest parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the data from iterables and objects using the destructuring assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new syntaxes for creating the object properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The let keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ES6 `let` keyword is used to declare a block scoped variable, optionally
    initializing it to a value. The programmers who come from other programming language
    background, but new to JavaScript, often end up writing error-prone JavaScript
    programs, believing that the JavaScript variables are block scoped. Almost every
    popular programming language has the same rules when it comes to the variable
    scopes, but JavaScript acts a bit different due to a lack of the block scoped
    variables. Due to the fact that JavaScript variables are not block scoped, there
    are chances of memory leak and also the JavaScript programs are harder to read
    and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring function scoped variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript variables that are declared using the `var` keyword are called
    as **function scoped** variables. The function scoped variables are accessible
    globally to the script, that is, throughout the script, if declared outside a
    function. Similarly, if the function scoped variables are declared inside a function,
    then they become accessible throughout the function, but not outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to create the function-scoped variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the `c` variable is accessible outside the `if` statement,
    but this is not the case in other programming languages. So, the programmers coming
    from other languages would expect the `c` variable to be undefined outside the
    `if` statement, but that's not the case. Therefore, ES6 had introduced the `let`
    keyword, which can be used for creating variables that are block scoped.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring block scoped variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables that are declared using the `let` keyword are called as block scoped
    variables. The block scoped variables behave the same way as the function scoped
    variables when declared outside a function, that is, they are accessible globally.
    But when the block scoped variables are declared inside a block, then they are
    accessible inside the block that they are defined in (and also any sub-blocks)
    but not outside the block.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A block is used to group zero or more statements. A pair of curly brackets delimits
    the block, that is `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the previous example script, replace `var` with the `let` keyword,
    and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, the output is as expected by a programmer who is used to another programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Re-declaring variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you declare a variable using the `var` keyword that is already declared
    using `var` keyword (in the same scope) then it''s overwritten. Consider this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output is as expected. But the variables created using the `let` keyword
    don't behave in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare a variable using the `let` keyword that is already declared
    using the `let` keyword in the same scope, then it throws a `TypeError` exception.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you declare a variable with a name that''s already accessible in a function
    (or inner function), or is a sub-block using `var` or the `let` keyword respectively,
    then it''s a different variable. Here, is an example that shows the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`var` versus `let`, which one to use?'
  prefs: []
  type: TYPE_NORMAL
- en: When writing the ES6 code, it is recommended to switch to using the `let` keyword
    because it makes scripts more memory friendly, prevents scoping mistakes, prevents
    accidental bugs, and makes the code easier to read. But if you are already addicted
    to the `var` keyword and comfortable using it, then you can still use this.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why not just make the `var` keyword to define the block-scoped
    variables instead of introducing the `let` keyword? The reason why the `var` keyword
    wasn't made enough to define block-scoped variables, instead of introducing the
    `let` keyword, was for the sake of backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The const keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ES6 `const` keyword is used to declare the read-only variables, that is,
    the variables whose value cannot be reassigned. Before ES6, the programmers usually
    used to prefix the variables that were supposed to be constant. For example, take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The value of `pi` should always remain constant. Here, although we have prefixed
    it, there is still a chance that we might accidentally change its value somewhere
    in the program, as they're no native protection to the value of `pi`. Prefixing
    is just not enough to keep the track of the constant variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the `const` keyword was introduced to provide a native protection
    to the constant variables. So, the previous program should be written in this
    way in ES6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, when we tried to change the value of `pi`, a read-only exception was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of constant variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constant variables are block-scoped variables, that is, they follow the same
    scoping rules as the variables that are declared using the `let` keyword. Here
    is an example, which shows the scope of the constant variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the constant variables behave in the same way as the block
    scoped variables, when it comes to the scoping rules.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the objects using constant variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we assign an object to a variable, the reference of the object is what
    the variable holds and not the object itself. So, when assigning an object to
    a constant variable, the reference of the object becomes constant to that variable
    and not to the object itself. Therefore, the object is mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `a` variable stores the address (that is, reference) of
    the object. So the address of the object is the value of the `a` variable, and
    it cannot be changed. But the object is mutable. So when we tried to assign another
    object to the `a` variable, we got an exception as we were trying to change the
    value of the `a` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameter values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript there is no defined way to assign the default values to the function
    parameters that are not passed. So, the programmers usually check for the parameters
    with the `undefined` value (as it is the default value for the missing parameters),
    and assign the default values to them. Here is an example, which shows how to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'ES6 provides a new syntax that can be used to do this in an easier way. Here
    is the code which demonstrates how to do this in ES6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, passing `undefined` is considered as missing an argument. Here is an
    example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Defaults can also be expressions. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The spread operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**A spread operator** is represented by the "`…`" token. A spread operator
    splits an iterable object into the individual values.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An iterable is an object that contains a group of values, and implements ES6
    iterable protocol to let us iterate through its values. An array is an example
    of built in an iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: A spread operator can be placed wherever multiple function arguments or multiple
    elements (for array literals) are expected in code.
  prefs: []
  type: TYPE_NORMAL
- en: The spread operator is commonly used to spread the values of an iterable object
    into the arguments of a function. Let's take an example of an array and see how
    to split it into the arguments of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, for providing the values of an array as function argument, the
    programmers used the `apply()` method of functions. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the apply method takes an array, extracts the values, passes them as individual
    arguments to the function, and then calls it.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 provides an easy way to do this, using the spread operator. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'During runtime, before the JavaScript interpreter calls the `myFunction` function,
    it replaces `…data` with the `1,4` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is replaced with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After this, the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A spread operator doesn't call the `apply()` method. The JavaScript runtime
    engine spreads the array using the iteration protocols, and has nothing to do
    with the `apply()` method, but the behavior is same.
  prefs: []
  type: TYPE_NORMAL
- en: Other usages of the spread operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spread operator is not just limited to spreading an iterable object into
    the function arguments, but it can be used wherever multiple elements (for array
    literals) are expected in code. So it has many uses. Let's see some other use
    cases of the spread operator for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Making array values a part of another array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It can also be used to make the array values a part of another array. Here is
    an example code that demonstrates how to make the values of an existing array
    a part of another array while creating it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Will be replaced with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Pushing the values of an array into another array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we may need to push the values of an existing array into the end
    of another existing array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, this is how the programmers used to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But in ES6 we have a much cleaner way to do it, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here the push method takes a series of variables, and adds them to the end of
    the array on which it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Will be replaced with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Spreading multiple arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple arrays can be spread on a single line of expression. For example,
    take the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The rest parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rest parameter is also represented by the "`…`" token. The last parameter
    of a function prefixed with "`…`" is called as a rest parameter. The rest parameter
    is an array type, which contains the rest of the parameters of a function when
    number of arguments exceeds the number of named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The rest parameter is used to capture a variable number of the function arguments
    from within a function.
  prefs: []
  type: TYPE_NORMAL
- en: Before ES6, the programmers used the `arguments` object of a function to retrieve
    the extra arguments, passed to the function. The `arguments` object is not an
    array, but it provides some interfaces that are similar to an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that shows how to use the `arguments` object to retrieve
    the extra arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6, this can be done in a much easier and cleaner way, using the rest parameter.
    Here is an example of using the rest parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `arguments` object is not an array object. Therefore, to do array operations
    on the `arguments` object, you need to first convert it to an array. As the ES6
    rest parameter is an array type, it's easier to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the "…" token called?
  prefs: []
  type: TYPE_NORMAL
- en: The "…" token is called as the spread operator or rest parameter, depending
    on where and how it's used.
  prefs: []
  type: TYPE_NORMAL
- en: The destructuring assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The destructuring assignment is an expression that allows you to assign the
    values or properties of an iterable or object, to the variables, using a syntax
    that looks similar to the array or object construction literals respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A destructuring assignment makes it easy to extract data from iterables or objects
    by providing a shorter syntax. A destructuring assignment is already present in
    the programming languages, such as **Perl** and **Python**, and works the same
    way everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of destructuring assignment expressions—the array and object
    destructuring assignment. Let's see each of them in details.
  prefs: []
  type: TYPE_NORMAL
- en: The array destructuring assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array destructuring assignment is used to extract the values of an iterable
    object and assign them to the variables. It's named as the *array destructuring
    assignment* because the expression is similar to an array construction literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, the programmers used to do it this way to assign the values of
    an array to the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are extracting the values of an array and assigning them to the `a`,
    `b`, `c` variables respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES6, we can do this in just one line statement using the array destructuring
    assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the `[a, b, c]` is the array destructuring expression.
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side of the array destructuring statement, we need to place
    the variables to which we want to assign the array values, using syntax similar
    to an array literal. On right-hand side, we need to place an array (actually any
    iterable object) whose values we want to extract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example code can be made even shorter in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here we create the variables on the same statement and instead of providing
    the array variable, we provide the array with a construction literal.
  prefs: []
  type: TYPE_NORMAL
- en: If there are fewer variables than items in the array, then only the first items
    are considered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you place a non-iterable object on the right-hand side of the array destructuring
    assignment syntax, then a `TypeError` exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also ignore some of the values of the iterable. Here is example code,
    which shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using the rest operator in the array destructuring assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can prefix the last variable of the array destructuring expression using
    the "`…`" token. In this case, the variable is always converted into an array
    object, which holds the rest of the values of the iterable object, if the number
    of other variables is less than the values in the iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example to understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example code, you can see that the `b` variable is converted
    into an array, and it holds all the other values of the right-hand side array.
  prefs: []
  type: TYPE_NORMAL
- en: Here the "`…`" token is called as the **rest operator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also ignore the values while using the rest operator. Here is an example
    to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we ignored the `2,` `3` values.
  prefs: []
  type: TYPE_NORMAL
- en: Default values for variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While destructuring, you can also provide the default values to the variables
    if an array index is `undefined`. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Nested array destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also extract the values from a multi-dimensional array and assign them
    to variables. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Using the destructuring assignment as a parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use the array destructuring expression as the function parameter
    for extracting the values of an iterable object, passed as argument into the function
    parameters. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier in this chapter, we saw that if we pass `undefined` as an argument
    to a function call, then JavaScript checks for the default parameter value. So,
    we can provide a default array here too, which will be used if the argument is
    `undefined`. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed `undefined` as an argument and therefore, the default array,
    which is `[1, 2, 3]`, was used for extracting the values.
  prefs: []
  type: TYPE_NORMAL
- en: The object destructuring assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object destructuring assignment is used to the extract property values of
    an object and assign them to the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6, the programmers used to do it in the following way to assign the
    values of an object''s properties to the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6, we can do this in just one line statement, using the object destructuring
    assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: On the left-hand side of the object destructuring statement, we need to place
    the variables to which we want to assign the object property values using syntax
    similar to object literal. On right-hand side, we need to place an object whose
    property values we want to extract are finally close the statement using the `(
    )` token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the variable names must be same as the object property names. If you want
    to assign different variable names, then you can do it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code can be made even shorter this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here we are create the variables and object on the same line. We don't need
    to close the statement using the `( )` token, as we are creating the variables
    on the same statement.
  prefs: []
  type: TYPE_NORMAL
- en: Default values for the variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also provide the default values to the variables, if the object property
    is `undefined` while destructuring. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring computed property names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some property names are constructed dynamically using expressions. In this
    case, to extract the property values, we can use the `[ ]` token to provide the
    property name an expression. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring nested objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also the extract property values from the nested objects, that is, the
    objects within the objects. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Using the object destructuring assignment as a parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like the array destructuring assignment, we can also use the object destructuring
    assignment as a function parameter. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed an empty object as a default parameter value, which will be
    used as a default object if `undefined` is passed as a function argument.
  prefs: []
  type: TYPE_NORMAL
- en: The arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 provides a new way to create functions using the `=>` operator. These functions
    are called as **arrow** functions. This new method has a shorter syntax, and the
    arrow functions are the anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to create an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `circleArea` is a variable, referencing to the anonymous arrow function.
    The previous code is similar to the next code in ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If an arrow function contains just one statement, then you don''t have to use
    the `{}` brackets to wrap the code. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When `{}` brackets are not used then the value of the statement in the body
    is automatically returned.
  prefs: []
  type: TYPE_NORMAL
- en: The value of "this" in an arrow function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the arrow functions, the value of `this` keyword is same as the value of
    `this` keyword of the enclosing scope (the global or function scope, inside whichever
    the arrow function is defined), instead of referring to the context object (that
    is, the object inside of which the function is a property), which is the value
    of `this` in traditional functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example to understand the difference in the traditional function''s
    and the arrow function''s `this` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, `this` inside the `f1` function refers to `object,` as `f1` is the property
    of it. `this` inside `f2` refers to the `window` object, as `f2` is a property
    of the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'But `this` behaves differently in the arrow functions. Let''s replace the traditional
    functions with the arrow functions in the preceding code and see the value of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, `this` inside the `f1` function copies the `this` value of global scope,
    as `f1` lies in global scope. `this` inside `f2` copies the `this` value of `f1,`
    as `f2` lies in the `f1` scope.
  prefs: []
  type: TYPE_NORMAL
- en: Other differences between the arrow and traditional functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arrow functions cannot be used as object constructors that is, the `new`
    operator cannot be applied on them.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from syntax, the `this` value, and the `new` operator, everything else
    is the same between the arrow and traditional functions, that is, they both are
    the instances of `the` `Function` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The enhanced object literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 has added some new syntax-based extensions to the `{}` object literal for
    creating properties. Let''s see them:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 provides a shorter syntax for assigning the object properties to the values
    of the variables, which have the same name as the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES5, you have been doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6, you can do it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Defining methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 provides a new syntax for defining the methods on an object. Here is an
    example to demonstrate the new syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This concise function allows the use of `super` in them, whereas the traditional
    methods of the objects don't allow the use of `super`. We will learn more about
    it later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The computed property names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The property names that are evaluated during runtime are called as the **computed
    property names**. An expression is usually resolved to find the property name
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES5, the computed properties are defined in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, after creating the object, we attach the properties to the object. But
    in ES6, we can add the properties with the computed name while creating the objects.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the variable's scopes, read-only variables,
    splitting arrays into individual values, passing indefinite parameters to a function,
    extracting data from objects and arrays, arrow functions, and new syntaxes for
    creating object properties.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about built-in objects and symbols, and we
    will discover the properties added by ES6 into strings, arrays, and objects.
  prefs: []
  type: TYPE_NORMAL
