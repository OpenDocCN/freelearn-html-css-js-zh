<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-437"><a id="_idTextAnchor487"/>12. Using Next-Generation JavaScript</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to identify and select from the tools available for advanced JavaScript development; use the latest JavaScript syntax in older browsers; select from useful frameworks for client-side and server-side application development; use <code>npm</code> and <code>Yarn</code> within a project; apply config-free asset management using <code>Parcel</code>; and implement configurable asset management using webpack.</p>
			<h1 id="_idParaDest-438"><a id="_idTextAnchor488"/>Introduction</h1>
			<p>In the previous chapter, you looked at creating clean, maintainable code by utilizing coding best practices, ensuring pure function implementation, and keeping your code simple. Now, while your code may be concise and correct, there are numerous factors that can cause problems when it's time to deploy your application.</p>
			<p>Writing JavaScript applications is not natively a simple "<strong class="bold">write and deploy</strong>" practice. There are many caveats that need to be overcome; for instance, managing incorporated third-party modules, ensuring the proper directory structure of your project, and ensuring your code runs without error in all the necessary environments.</p>
			<p>It is important to remember that JavaScript is a constantly evolving platform. Since its creation, JavaScript has always had differences between the available runtimes and, most notably, between browser types and versions. In the early years of its existence, JavaScript was quite unruly, with obvious differences between browsers. During those times, developers needed to repeatedly test their applications in each browser frequently to ensure it ran successfully and without bugs. Even now, each available modern browser has a different list of supported features and, awkwardly, very small variations in how similar features are implemented, which can trip up an unsuspecting developer. Attempting to write code that works in all modern browsers can be time-consuming and may require some patience.</p>
			<p>Thankfully, there are ways to overcome these differences through tooling and libraries. These include the following:</p>
			<ul>
				<li><strong class="bold">Polyfill</strong> libraries, which add missing features to runtimes, ensuring a better match between environments</li>
				<li>Libraries that support coding methodologies, ensuring a practical cross-runtime development experience</li>
				<li><strong class="bold">Transpilers</strong>, which convert a singular language implementation into code supported in multiple different runtime environments</li>
			</ul>
			<p>By including these tools in your project workspaces, you can not only save hours of frustration and needless headaches when deploying your code but also ensure a pleasant development experience from its inception. The idea is to support your creativity rather than to fight with the tools.</p>
			<p>This chapter will highlight those libraries and tools that make light work of coding with JavaScript, as well as to inform you of where to look so that you can customize your development experience.</p>
			<h1 id="_idParaDest-439"><a id="_idTextAnchor489"/>Browser Differences</h1>
			<p>When a user views a website or web application, it is important that it works as expected and, preferably, works similarly within all browsers. However, ensuring this occurs is a difficult task for many developers. Not only do browsers provide slightly varying implementations of JavaScript, but also of HTML5 features, <strong class="bold">Cascading Style Sheet</strong> (<strong class="bold">CSS</strong>) support, and more. Overcoming such differences have been an important task in every JavaScript developers working life, with experience playing a key part in ensuring applications work similarly in all environments.</p>
			<p>To see what works on different browser types and versions, you can use the <em class="italic">Can I Use</em> website, which lists every browser's features and their compatibility: <a href="https://caniuse.com/">https://caniuse.com/</a>.</p>
			<p>In recent years, Microsoft has worked to eradicate these differences. For instance, on iOS devices, Microsoft's Edge browser uses <strong class="bold">WebKit</strong>, which is the same technology that's used by Google's Chrome and Apple's Safari browsers. As such, the future of web application development is looking much brighter, with fewer caveats between browsers. The problem will be, though, that not all users are up to date with the latest versions of their internet browser, meaning backward compatibility is still a necessity. </p>
			<h2 id="_idParaDest-440"><a id="_idTextAnchor490"/>polyfills</h2>
			<p>A solution to browser incompatibilities is to use polyfills. These are libraries that are created by third parties to bridge the gaps between browsers, ensuring the functionality they provide is matched. There are many polyfill libraries, each asserting a given list of features across a range of browsers and browser versions. The most popular of these polyfills is <strong class="bold">Polyfill.io</strong> (<a href="https://polyfill.io/v3">https://polyfill.io/v3</a>).</p>
			<p>Polyfill.io was created by the <em class="italic">Financial Times</em> to cover a broad range of discrepancies among browsers. It is an open-source library that can be configured to include just the features you require, or you can simply import everything. By including it in your project, you can smooth over the cracks in browser differences.</p>
			<p>Including Polyfill.io in your application is as simple as adding it with a <code>script</code> tag:</p>
			<pre>&lt;script crossorigin="anonymous" src="img/polyfill.min.js"&gt;&lt;/script&gt;</pre>
			<p>However, to make full use of Polyfill.io, it is best to appropriately configure it to your needs using the <code>Create a Polyfill Bundle</code> page on the Polyfill.io website.</p>
			<h2 id="_idParaDest-441"><a id="_idTextAnchor491"/>Transpilers</h2>
			<p>Transpilers are tools that convert one language into another. They are similar to compilers, except compilers typically convert a language into machine code or into intermediate byte code. There are many transpilers that convert a different language into JavaScript, but one of the most popular in web development is the <strong class="bold">Babel transpiler</strong>, which converts JavaScript into JavaScript. This may sound strange but imagine being able to utilize all of the latest features of JavaScript, then transpile it to work on all major browsers from the last 5 years, without having to utilize a polyfill library. This is essentially what Babel does.</p>
			<p>The Babel transpiler, as well as several other transpilers, will be discussed later in this chapter.</p>
			<h2 id="_idParaDest-442"><a id="_idTextAnchor492"/>Development Methodology Libraries</h2>
			<p>An alternative to covering the cracks in browser differences is to utilize libraries that offer a uniform development methodology that is supported in older browsers. There are many libraries that provide an arsenal of functionality, thereby making it easier to code in a predefined, opinionated manner. Some of these include the following:</p>
			<ul>
				<li>The <strong class="bold">Underscore</strong>, <strong class="bold">Lodash</strong>, <strong class="bold">RxJS</strong>, and <strong class="bold">Ramda</strong> functional programming libraries</li>
				<li>The <strong class="bold">React</strong>, <strong class="bold">Polymer</strong>, and <strong class="bold">Riot</strong> component-based UI libraries</li>
				<li>The <strong class="bold">Backbone</strong> and <strong class="bold">Knockout MVC</strong> frameworks</li>
				<li>The <strong class="bold">jQuery</strong> and <strong class="bold">MooTools DOM</strong> manipulation libraries</li>
			</ul>
			<p>Each of the preceding libraries may be used in tandem with each other and with a transpiler, so choosing your libraries can be an important step to getting the results you require. We will be looking at some useful libraries later in this chapter.</p>
			<h1 id="_idParaDest-443"><a id="_idTextAnchor493"/>Package Managers</h1>
			<p>Package managers are tools that provide managed support for your included libraries. These package managers may provide functionality that can be used in your production code, provide functionality externally to your application that helps test your code, or even provide tools you can use to make development easier but that is discarded from the eventual production code.</p>
			<p>When implementing a package manager, a manifest is kept that keeps track of each of the libraries that have been imported into your project, as well as their version numbers. This way, if you were to remove all of the libraries from your project, you could easily reinstall the libraries that were used instantly. This is very useful when storing your application source code in a source repository such as GitHub, as you only need to store your own code. Any libraries you have used in the past can be easily installed by other developers in your team using the package manifest, ensuring your source repository is streamlined.</p>
			<p>For many years, the most popular package manager that's been used by JavaScript developers has been Node Package Manager (npm). However, additional managers are available, with some gaining popularity, including Yarn.</p>
			<h2 id="_idParaDest-444"><a id="_idTextAnchor494"/>The Node Package Manager</h2>
			<p>The node package manager (npm) is automatically installed when you install Node.js. Therefore, if you followed along in <em class="italic">Chapter 9, Working with Node.js</em>, then you should already have it. To test for it, simply run the following in your Terminal:</p>
			<pre>npm -v</pre>
			<p>This will output version information if you do indeed have it installed on your system:</p>
			<div><div><img alt="Figure 12.1: npm version&#13;&#10;" src="img/C14377_12_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1: npm version</p>
			<p>When using npm with a project, it creates a manifest file called <code>package.json</code>, which maintains a list of production and development libraries to be used with your project. Any installed packages are stored in a directory called <code>node_modules</code>, which npm also creates, and which lives in the root of your project. It is advisable to ensure that the <code>node_modules</code> directory is never stored in your project's source code repository, for streamlining purposes.</p>
			<p>To begin using npm, you simply navigate to your project directory using your Terminal and execute the following command:</p>
			<pre>npm init</pre>
			<p>This will prompt you to answer a number of questions. It's okay if you don't know what to put for these, and you can simply press the Enter key to skip them and use the provided default values if you wish:</p>
			<div><div><img alt="Figure 12.2: npm initialization&#13;&#10;" src="img/C14377_12_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2: npm initialization</p>
			<p>Once completed, it will create a barebones <code>package.json</code> file containing the JSON code detailed in the preceding screenshot. Now, at this time, this JSON will not contain any modules, but that's fine. What it does and can contain is metadata about your project, such as its version, the initial index or starting script, and other such important information.</p>
			<p>One of the predefined metadata properties is the <code>scripts</code> object. This is an important entry and one you will soon become familiar with. Each entry within this object is an executable command shortcut that you can invoke using the npm Terminal command. The one that's provided initially doesn't really do anything except output an error, but you can run it anyway if you wish so that you can see it in action. Do this by executing the following in the Terminal:</p>
			<pre>npm run test</pre>
			<p>With the current JSON, this will simply output the following error:</p>
			<div><div><img alt="Figure 12.3: Initial package.json output&#13;&#10;" src="img/C14377_12_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3: Initial package.json output</p>
			<p>The <code>scripts</code> section of the <code>package.json</code> file is extremely useful for implementing your own shortcut commands so that you can run common tasks. You will be utilizing this a lot later in this chapter.</p>
			<h2 id="_idParaDest-445"><a id="_idTextAnchor495"/>Installing Modules</h2>
			<p>The key task of a package manager is to install modules. As we stated previously, there are two primary ways to install a module into your project. The first is to install it as a production-level module. This means it may be incorporated into your deployment scripts during a build phase:</p>
			<pre>npm install --save-prod &lt;module&gt;</pre>
			<p>Similarly, to install it as a development module, you would simply execute the following code:</p>
			<pre>npm install --save-dev &lt;module&gt;</pre>
			<p>Each installed module will be added to a list within the <code>package.json</code> file; either <code>dependencies</code> for production modules or <code>devDependencies</code> for development modules.</p>
			<p>At any time, once your module list exists within the <code>package.json</code> file, you can install all the modules by simply invoking the following in the Terminal:</p>
			<pre>npm install</pre>
			<p>If no <code>node_modules</code> folder exists in your project, this command will create it and proceed to download all the modules contained in both the <code>dependencies</code> and <code>devDependencies</code> lists.</p>
			<h2 id="_idParaDest-446"><a id="_idTextAnchor496"/>The Yarn Package Manager</h2>
			<p>Yarn is a more recent addition to the available JavaScript package managers but is increasing in popularity. It was conceived by Facebook, in collaboration with Google, Tilde Inc., and Exponent Inc., and works as a different frontend to the npm repository. It was created primarily to provide a safer alternative to npm since the npm command-line tool can allow modules to run code upon installation, which can be a security risk.</p>
			<p>Whether you should use Yarn is simply a preference. The issues that are exposed by the Yarn project are likely to be patched by npm over time and may already be irrelevant. Since Yarn doesn't replace much in the npm ecosystem, there isn't a big requirement to use it over the <strong class="bold">npm CLI</strong>.</p>
			<h2 id="_idParaDest-447"><a id="_idTextAnchor497"/>The Babel Transpiler</h2>
			<p>Babel is a set of tools and libraries that transpiles JavaScript into JavaScript. Its benefit is that you can use cutting-edge JavaScript features today and still ensure that they run on a wide range of browsers and browser versions, all while ensuring minimally produced code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When working on exceptionally small projects, it is still possible to create much shorter scripts than what's run on most browsers. Using Babel is mostly beneficial for medium-to-large projects, which many modern JavaScript applications tend to be. Therefore, if all you are doing is reading some values from a field or two and validating them using a handful of lines of JavaScript, then you may be better off skipping modules and transpilers altogether.</p>
			<p>A simple Babel installation provides three development-time tools and a polyfill library to be compiled into your application. These are as follows:</p>
			<ul>
				<li>The Babel engine core</li>
				<li>The Babel command-line interface</li>
				<li>The Babel environment preset engine</li>
				<li>The Babel/polyfill library</li>
			</ul>
			<p>Each of the Babel tools can be installed using the npm CLI and use package names that are prefixed with <code>@babel/</code>. This is known as the package scope or namespace and ensures that other packages in the npm repository do not conflict should they have the same name.</p>
			<h3 id="_idParaDest-448"><a id="_idTextAnchor498"/>@babel/core</h3>
			<p>The <code>@babel/core</code> tool provides the engine of the Babel transpiler. It contains functions that invoke the transformation of JavaScript code from one form to another, though the logic for various transformations may not be in the <code>@babel/core</code> package itself. All Babel installations must include the <code>@babel/core</code> package in order to function.</p>
			<h3 id="_idParaDest-449"><a id="_idTextAnchor499"/>@babel/cli</h3>
			<p><code>@babel/cli</code> provides command-line functionality for Babel projects. This can be used to invoke the transpilation of your source code, as well as to incorporate additional plugins and configuration. However, you will not typically use this CLI directly. Instead, you will create a new <code>scripts</code> entry and provide the configuration in a separate file.</p>
			<h3 id="_idParaDest-450"><a id="_idTextAnchor500"/>@babel/preset-env</h3>
			<p>The <code>@babel/preset-env</code> tool provides intelligent directives for transpiling your code for specific environments, such as browser types and versions. Typically, the wider the range of environments you wish to support, the larger your resulting deployable transpiled code will be. The configuration for this tool will exist in a configuration file so that you only need to specify it once.</p>
			<h3 id="_idParaDest-451"><a id="_idTextAnchor501"/>@babel/polyfill</h3>
			<p><code>@babel/polyfill</code> is a library that is at least partly compiled into your deployable code. Through using <code>@babel/preset-env</code>, Babel selects elements from <code>@babel/polyfill</code> to include in the transpiled code.</p>
			<h3 id="_idParaDest-452"><a id="_idTextAnchor502"/>.babelrc Configuration File</h3>
			<p>The <code>.babelrc</code> file (note the period character at the start of the filename) is a JSON configuration file that sits in the root of your project directory. This file can store information about the presets, plugins, and various other bits of information that are useful for Babel's installation.</p>
			<p>The most common configuration you will apply to this file will be the environments you wish to support:</p>
			<pre>{
"presets": [
    [
"@babel/preset-env", {
"targets": "&gt; 0.25%, not dead"
      }
    ]
  ]
}</pre>
			<p>The preceding example requests that Babel transpiles code to support browsers that are used globally by more than 0.25% of the population. Otherwise, those browsers are not considered dead, which means browsers that are still actively supported.</p>
			<p>A full explanation of the environment queries that are supported by the <code>.babelrc</code> configuration file can be found at <a href="https://packt.live/2NVxWwP">https://packt.live/2NVxWwP</a>.</p>
			<h2 id="_idParaDest-453"><a id="_idTextAnchor503"/>Exercise 12.01: A Basic Babel Project</h2>
			<p>In this exercise, you will create a usable install of the Babel transpiler using npm. This will be a simple setup that will result in a working environment that's able to transpile a source modularized JavaScript application into a deployable repository of files. Let's get started:</p>
			<ol>
				<li>Begin by creating a new directory called <code>babel_app</code> in your operating system's <code>Documents</code> folder using the Terminal. Then, navigate into that directory:<pre>cd ~/Documents/
mkdir babel_app
cd babel_app/</pre></li>
				<li>Then, initialize the folder as an npm project. You can use all of the default settings for this:<pre>npm init</pre><p>You should see something similar to the following output:</p><div><img alt="Figure 12.4: npm initialization&#13;&#10;" src="img/C14377_12_04.jpg"/></div><p class="figure-caption">Figure 12.4: npm initialization</p></li>
				<li>Now that npm is set up, you can install the Babel development libraries. These will need to be saved in the <code>devDependencies</code> list:<pre>npm install --save-dev @babel/core @babel/cli @babel/preset-env</pre><p>You will see some information pertaining to downloading the modules to the <code>node_modules</code> directory:</p><div><img alt="Figure 12.5: Development modules installed&#13;&#10;" src="img/C14377_12_05.jpg"/></div><p class="figure-caption">Figure 12.5: Development modules installed</p><p>These files will not be compiled into your resulting transpiled application since they are used to perform the transpiling itself.</p></li>
				<li>Now, you will need to install the Babel polyfill library. This library will be transpiled into your resulting application, as required by the transpiler:<pre>npm install --save @babel/polyfill</pre><p>Again, this module will be saved in the <code>node_modules</code> directory:</p><div><img alt="Figure 12.6: Polyfill module installation&#13;&#10;" src="img/C14377_12_06.jpg"/></div><p class="figure-caption">Figure 12.6: Polyfill module installation</p></li>
				<li>With the modules installed, you will now need to configure Babel. This requires a new file called <code>.babelrc</code>, which will contain the appropriate JSON. There are many possible configurable features of Babel, but for this exercise, you will simply need to specify the environment presets. Create a new file called <code>.babelrc</code> in the root of the project directory and populate it with the following content:<pre>{
  "presets": [
    "@babel/preset-env", {
      "targets": "&gt; 0.25%, not dead"
    }
  ]
}</pre></li>
				<li>With everything in place, you will now need to create your project work files and directories. You can layout your project however you like, but for this example, you'll utilize two directories: an <code>src</code> directory for source files and a <code>dist</code> directory for transpiled files. Go ahead and create these in the root of the project directory: <pre>mkdir<a id="_idTextAnchor504"/><a id="_idTextAnchor505"/>srcdist</pre></li>
				<li>Next, you'll need a project file to transpile. In the <code>src</code> directory, add a file called <code>index.js</code> and add the following JavaScript:<pre>[1, 2, 3].map((value) =&gt; console.log("Mapping value ", value));</pre><p>This JavaScript uses a little of the ES2015 specification, in the form of the fat arrow function. This means, when transpiled, you should see a difference between what is in the source file and what is in the transpiled file.</p></li>
				<li>Now, in order to get everything working, you'll need to modify the <code>package.json</code> file to include a script that executes the Babel transpiler. Go ahead and open that file up, and then add the following line to the <code>scripts</code> array:<pre>"build": "npx babel src --out-dir dist"</pre><p>This line means that when you run it, it will call the Babel CLI tool using the npm package runner and will pass it the <code>src</code> directory for input and the <code>dist</code> directory for output. Don't forget to add a comma at the end of the previous line or your JSON will be invalid. Your <code>package.json</code> file should now look as follows:</p><pre>package.json
1  {
2  "name": "babel_app",
3  "version": "1.0.0",
4  "description": "",
5  "main": "index.js",
6  "scripts": {
7  "test": "echo \"Error: no test specified\"&amp;&amp; exit 1",
8  "build": "npx babel src --out-dir dist"
9    },
10 "author": "",
11 "license": "ISC",
12 "devDependencies": {
13 "@babel/cli": "^7.5.5",
14 "@babel/core": "^7.5.5",
15 "@babel/preset-env": "^7.5.5"
The full code is available at: <a href="https://packt.live/32DKdv6">https://packt.live/32DKdv6</a></pre><p>Notice the version numbers next to each of the module entries. If your version numbers are different, don't panic. The steps that were used to install these modules ensured that the latest versions were downloaded. Any differences in your own file compared to the preceding code simply mean those modules have been updated since this chapter was written. However, everything should still work fine.</p></li>
				<li>Finally, it's time to run the transpiler. To do this, simply call the script through the npm CLI tool:<pre>npm run build</pre><p>Once executed, take a look at the <code>dist</code> directory. It should now also contain an <code>index.js</code> file. However, the contents of this file will differ slightly to the code you entered in the <code>index.js</code> file in the <code>src</code> directory:</p><pre>"use strict";
[1, 2, 3].map(function (value) {
  return console.log("Mapping value ", value);
});</pre><p>Notice that the Babel transpiler stripped out the fat arrow function syntax and replaced it with a standard function definition. This is so that the transpiled code will work in the environments you specified in the <code>.babelrc</code> configuration file. Babel allows you to utilize any of the cutting-edge features you want to use while being comforted by the knowledge that your resulting transpiled application should work exactly where you need it to.</p></li>
			</ol>
			<p>The basic setup we've described here provides a powerful starting point for even the largest of applications. Many professional JavaScript development companies use Babel to ensure code correctness, portability, and a flexible working environment that can be managed by teams of developers without having each developer stepping on the toes of another.</p>
			<p>While what you have accomplished is a great starting point for a robust, team-driven application, there is more that can be accomplished to improve this even further. We will look at some of these additional steps throughout the rest of this chapter.</p>
			<h1 id="_idParaDest-454"><a id="_idTextAnchor506"/>Babel Applications with Parcel</h1>
			<p>npm works very well as a package manager, but its project management capabilities are limited. In the previous exercise, you set up a script in the npm <code>package.json</code> file that executed the Babel transpiler. The transpiler can translate JavaScript files one at a time and place the resulting translated files in the <code>dist</code> directory, but that's about the extent of it. Often, your projects will have other requirements, such as the following:</p>
			<ul>
				<li>Ensuring your files are combined into fewer resulting JavaScript files</li>
				<li>Defining hot modules (breaking the compiled output into smaller chunks with dynamic loading)</li>
				<li>Processing CSS files</li>
				<li>Compressing images</li>
				<li>Ensuring files aren't cached between builds</li>
			</ul>
			<p>It is possible to write your own scripts to manage your projects and execute them from npm from a parent script, but this is a lot of repetitive work that has already been solved by others. <strong class="bold">Parcel</strong> is a solution to this.</p>
			<h2 id="_idParaDest-455"><a id="_idTextAnchor507"/>What is Parcel?</h2>
			<p>Parcel is considered a web application bundler. It is, essentially, a packaging module that performs the tasks that were listed in the previous section. What makes Parcel unique is that it is a zero-configuration bundler. You simply call it from your project directory, and it figures out how your application should be readied for distribution. The only requirement, then, is to call the Parcel CLI command to launch it.</p>
			<p>Parcel is typically installed in your project as a global module. This means it is not stored in the <code>node_modules</code> directory in your project folder, but in a <code>node_modules</code> directory that exists on your operating system's environment path. To do this, instead of supplying a <code>--save</code> or <code>--save-dev</code> flag, you supply a <code>-g</code> flag, for global:</p>
			<pre>npm install -g parcel</pre>
			<p>Since Parcel is globally installed, the installation will not modify the <code>package.json</code> file as it will not need to be added to the <code>dependencies</code> or <code>devDependencies</code> lists.</p>
			<h2 id="_idParaDest-456"><a id="_idTextAnchor508"/>Using Parcel</h2>
			<p>To make use of Parcel, you will need to add new scripts to the <code>package.json scripts</code> object. There are several ways Parcel can be called. The first is simply to pass the main JavaScript file as the only parameter to the <code>parcel</code> CLI tool:</p>
			<pre>parcel src/index.js</pre>
			<p>This will request that Parcel processes the JavaScript file and for it to output a development build of it. Parcel traverses this file and determines whether any other files also need processing. During the processing phase, Parcel will also analyze any configuration files present within the project directory. The <code>.babelrc</code> configuration file is one such file Parcel understands. Therefore, by its very presence, Parcel will ensure that any JavaScript files are transpiled by Babel. The same will be true if common configuration files are present for other tools, but also with files of a given type within the source tree, such as HTML and CSS files:</p>
			<div><div><img alt="Figure 12.7: Parcel development build&#13;&#10;" src="img/C14377_12_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7: Parcel development build</p>
			<p>When processing as a development build, Parcel includes additional code within the transpiled JavaScript. Additionally, a call to Parcel to process your files in development mode will not return. As you can see in the preceding screenshot, running Parcel in development mode launches a special development server, which you can navigate to by going to <a href="http://localhost:1234">http://localhost:1234</a> in your web browser. This simply presents your transpiled application as though it were running on a remote webserver.</p>
			<p>The running service also utilizes a filesystem listener so that, when you update a file within your project, that file is then automatically reprocessed, and the resulting changes are made available immediately. If you then view your application within the browser at the time a file is changed, the browser will automatically be refreshed to include those changes. This feature greatly speeds up development time.</p>
			<p>Another way to invoke the parcel CLI tool is to provide the <code>build</code> flag:</p>
			<pre>parcel build src/index.js</pre>
			<p>The <code>build</code> flag tells Parcel to process the source files so that they're ready for a production release. This version will not have the additional browser update code and there will be no development server running:</p>
			<div><div><img alt="Figure 12.8: Parcel production build&#13;&#10;" src="img/C14377_12_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8: Parcel production build</p>
			<p>When deploying your finished application to a production server, the development features are not necessary and simply add bloat to your code, so being able to compile your application without them is a necessary step.</p>
			<h2 id="_idParaDest-457"><a id="_idTextAnchor509"/>Modular Applications in Parcel</h2>
			<p>Utilizing Parcel provides a lot of features for free. In <em class="italic">Chapter 9, Working with Node.js</em>, you saw how modules are acquired in a Node.js application. Transpiling with Babel and Parcel also provides module acquisition when using the <code>import</code> keyword.</p>
			<p>When building your applications, it is preferable to break the application source into smaller files so that managing your code is simpler. The <code>import</code> keyword follows the ES2015 specification, whereby each module in your source directory <code>exports</code> one or more functions, which can then be imported into other modules as required using the <code>import</code> keyword. If a module <code>exports</code> only one function, then it can be exported simply as a <code>default</code> function:</p>
			<pre>// myModule.js
const myFun = () =&gt; console.log("Hello, World!");
export default myFun;</pre>
			<p>In another module, this function can then be imported with a named reference, like so:</p>
			<pre>// index.js
import fun from "./myModule";
fun();  // ==&gt; Hello, World!</pre>
			<p>Notice how the <code>.js</code> extension was not required when naming the importing module, much like how Node.js imports modules. The transpiler automatically understands how to reference the external file using this format. When processing the <code>index.js</code> file, Parcel automatically traverses all imported files, transpiling those as well. Each module is followed, including their linked modules and so on. The resulting code is stored in a single JavaScript file in the <code>dist</code> directory.</p>
			<p>If a module contains multiple functions, then it can export them using an object format. This foregoes the <code>default</code> keyword as, now, functions must be cherry-picked using their specific names:</p>
			<pre>// multiModule.js
const fun1 = () =&gt; console.log("I am function one");
const fun2 = () =&gt; console.log("I am function two");
export {fun1, fun2};</pre>
			<p>Now, in the calling module, each required function must be named explicitly:</p>
			<pre>// index.js
import {fun1, fun2} from "./multiModule";
fun1();
fun2();</pre>
			<p>Using this method, only those functions you intend to use need to be imported. The transpiler will ensure that any dead functions (functions that are never called) are not transpiled needlessly into the resulting <code>dist</code> code.</p>
			<h2 id="_idParaDest-458"><a id="_idTextAnchor510"/>Exercise 12.02: A Basic Parcel Project</h2>
			<p>In this exercise, you will update the application you created in <em class="italic">Exercise 12.01: A Basic Babel Project</em> to incorporate a Parcel build system. You will also include an additional module so that you can experience how simple modular application development can be. Let's get started:</p>
			<ol>
				<li value="1">First, you will need to install the Parcel tools. If you have not already done so, install them globally:<pre>npm install -g parcel</pre><p>If you are on a Mac or Linux device and you receive an error stating that you have insufficient privileges, you will need to prepend the previous line with the <code>sudo</code> command:</p><pre>sudo npm install -g parcel</pre></li>
				<li>Next, create a new file in the <code>src</code> directory and call it <code>index.html</code>. Then, add the following markup:<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Babel App&lt;/title&gt;
&lt;script src="img/index.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>Parcel works by processing a file tree. By passing an HTML file as the master file, not only will JavaScript files be processed, but so will the HTML, CSS, and other such assets linked in your application.</p></li>
				<li>Now, update the <code>package.json</code> file to include the new <code>build</code> command scripts:<pre>"dev": "parcel src/index.html",
"build": "parcel build src/index.html"</pre><p>The <code>"build"</code> entry should replace the one we used previously, which called the Babel CLI directly. Your <code>package.json</code> file should now look as follows:</p><pre>package.json
1  {
2  "name": "babel_app",
3  "version": "1.0.0",
4  "description": "",
5  "main": "index.js",
6  "scripts": {
7  "test": "echo \"Error: no test specified\"&amp;&amp; exit 1",
8  "dev": "parcel src/index.html",
9  "build":<a id="_idTextAnchor511"/><a id="_idTextAnchor512"/> "parcel build src/index.html"
10   },
11 "author": "",
12 "license": "ISC",
13 "devDependencies": {
14 "@babel/cli": "^7.5.5",
15 "@babel/core": "^7.5.5",
The full code is available at: <a href="https://packt.live/32LScpY">https://packt.live/32LScpY</a></pre></li>
				<li>Next, add a new module in <code>src</code> called <code>module.js</code>. This file will demonstrate the module loading in Parcel. In this file, add the following code:<pre>export default () =&gt; {
  [1, 2, 3].map((value) =&gt; console.log("Mapping value ", value));
};</pre></li>
				<li>Now, import that module into the <code>index.js</code> file by replacing its content with the following:<pre>import mapper from "./module";
mapper();</pre></li>
				<li>You can now run your application in development mode by simply calling the following:<pre>npm run dev</pre><p>You should then see the expected development server launch in the Terminal:</p><div><img alt="Figure 12.9: Running the development server&#13;&#10;" src="img/C14377_12_09.jpg"/></div><p class="figure-caption">Figure 12.9: Running the development server</p><p>If you launch your browser with the console open, you will see the expected content:</p><div><img alt="Figure 12.10: Console output&#13;&#10;" src="img/C14377_12_10.jpg"/></div><p class="figure-caption">Figure 12.10: Console output</p></li>
				<li>Finally, update <code>module.js</code> by adding additional value in the array. When you save the file, the browser should instantly refresh to show the latest changes:<div><img alt="Figure 12.11: Updated console output&#13;&#10;" src="img/C14377_12_11.jpg"/></div><p class="figure-caption">Figure 12.11: Updated console output</p></li>
				<li>If you view the source of the HTML page, you will see that the HTML doesn't reference <code>index.js</code> as it does in the <code>src</code> directory. Instead, the JavaScript file will have a random name in order to prevent the browser from caching the file:<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Babel App&lt;/title&gt;
&lt;script src="img/src.e31bb0bc.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<p>The setup we've created in this exercise is now a perfect starting point for many JavaScript projects. This simple build provides numerous development features that empower your coding and ensure optimal reliability in the production files.</p>
			<h1 id="_idParaDest-459"><a id="_idTextAnchor513"/>Babel Applications with Webpack</h1>
			<p>Webpack is an application bundler for JavaScript applications that provides a much more configurable experience. In version 4, the webpack team introduced zero-configuration support in order to compete with Parcel specifically. While webpack is an excellent tool for bundling your JavaScript and other assets, it does take quite a lot of configuring and requires just as much patience.</p>
			<p>To use a webpack, you simply install it, just like any JavaScript module. Webpack comes in two main parts: the webpack engine and the webpack CLI. Both can be installed simultaneously, like so:</p>
			<pre>npm install --save-dev webpack webpack-cli</pre>
			<p>If you install it using your Terminal, you should see the following output:</p>
			<div><div><img alt="Figure 12.12: Webpack installation&#13;&#10;" src="img/C14377_12_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.12: Webpack installation</p>
			<p>With those downloaded, you can then add a script in the <code>package.json</code> file in order to execute them, like so:</p>
			<pre>"wp": "webpack"</pre>
			<p>Then, by running the script in the Terminal, it should compile your JavaScript:</p>
			<div><div><img alt="Figure 12.13: Executing Webpack zero configuration&#13;&#10;" src="img/C14377_12_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13: Executing Webpack zero configuration</p>
			<p>As you can see, in the preceding screenshot, both the <code>index.js</code> and <code>module.js</code> files were compiled into a file called <code>main.js</code>. Webpack defaults its entry point path to <code>src/index.js</code> and its output path to <code>dist/main.js</code>.</p>
			<p>Let's supply a source file and output file explicitly so as to try and mimic the Parcel build. Update your <code>wp</code> script to the following:</p>
			<pre>"wp": "webpack src/index.html -o dist/index.html"</pre>
			<p>This will set the input source as the <code>index.html</code> file and request the output to be placed in the <code>dist</code> directory, but with the same filename. If you run this, you should see something like the following:</p>
			<div><div><img alt="Figure 12.14: Webpack HTML parse error&#13;&#10;" src="img/C14377_12_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.14: Webpack HTML parse error</p>
			<p>As you can see, the webpack wasn't too happy about finding an HTML file.</p>
			<p>Now, a caveat with a webpack is that it does not try to be intelligent. The compiled output of the previous execution would not have transpiled your code using Babel, so the fat arrow functions from the source files will have made it to the output folder. Also, webpack in zero-configuration mode will only compile your JavaScript, meaning any other assets included in your application require some configuration in order for them to be processed and sent to the <code>dist</code> directory, including any HTML files.</p>
			<h2 id="_idParaDest-460"><a id="_idTextAnchor514"/>Webpack Architecture</h2>
			<p>Webpack provides a linear processing pipeline for your applications. Using a source input file, it will build a dependency tree, known as a dependency graph, and will process each file where configuration exists for that file type. The pipeline utilizes the following:</p>
			<ul>
				<li>Source input file or entry point</li>
				<li>Output file</li>
				<li>Loader modules</li>
				<li>Plugin modules</li>
			</ul>
			<p>Webpack requires a specific configuration for each of the asset types in your application so that it knows how to process them.</p>
			<h2 id="_idParaDest-461"><a id="_idTextAnchor515"/>Webpack Loaders and Plugins</h2>
			<p>Both <strong class="bold">loaders</strong> and <strong class="bold">plugins</strong> are modules of code that you include in a webpack pipeline. They can be considered the bolt-on functionality since webpack is a pipeline, they are like its "fixtures and fittings." Loaders and plugins both have an effect on how your application is processed by webpack, but they are also quite different from one another.</p>
			<p>A loader is a module that works at the beginning of the webpack pipeline; sometimes even before it starts. These modules process assets individually. For instance, if you wanted to use Babel in a webpack configuration, you would need to include the babel-webpack loader, which transpiles each file individually as they are processed.</p>
			<p>Plugins, on the other hand, tend to work at the end of the webpack pipeline. These modules affect the entire output bundle and allow you to have much greater control over your application output. Plugins are quite a bit more complex than loaders, and their configuration often reflects this.</p>
			<h2 id="_idParaDest-462"><a id="_idTextAnchor516"/>Webpack Configuration</h2>
			<p>The configuration of a webpack pipeline is added to a file called <code>webpack.config.js</code>, which exists in the root of your project directory. As a JavaScript file, it is executed by the Node.js runtime and can, therefore, include Node.js-compatible JavaScript.</p>
			<p>The webpack configuration is exported from the <code>webpack.config.js</code> file, much like any JavaScript module. The exported data can include information about the entry point path, destination path, loaders, and plugins, as is required.</p>
			<p>As an example, a simple <code>webpack.config.js</code> file, which specifies the entry point and output paths, may look like this:</p>
			<pre>var path = require('path');
module.exports = {
  entry: path.join(__dirname, 'src', 'index.js'),
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'index.js'
  }
}</pre>
			<p>If you create a <code>webpack.config.js</code> file, be sure to reset your <code>package.json</code> script so that it is like so:</p>
			<pre>"wp": "webpack"</pre>
			<p>Failing to do so may cause confusing results.</p>
			<h2 id="_idParaDest-463"><a id="_idTextAnchor517"/>Exercise 12.03: A Basic WebPack Project</h2>
			<p>In this exercise, you will set up your webpack installation so that it implements Babel transpiling and so that it includes and processes your <code>index.html</code> source file. As we stated previously, there are many configuration features you can apply to a webpack installation, but by completing this exercise, you will have a better understanding of how to implement any loaders you require. Let's get started:</p>
			<ol>
				<li value="1">Although your application includes the Babel transpiler in the <code>package.json</code> file, it is not enough for a webpack to be able to understand how and when to use it. To utilize Babel with webpack, you need to include and configure the <code>Babel loader module</code>. Run the following in your Terminal to download and install the Babel loader:<pre>npm install --save-dev babel-loader</pre></li>
				<li>Next, open up the <code>webpack.config.js</code> file, if you have it, and add a new <code>module</code> section to the <code>exports</code> object. If you don't have the <code>webpack.config.js</code> file yet, create it now and add the code from the previous section:<pre>module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /node_modules/,
      use: {
        loader: "babel-loader"
      }
    }
  ]
}</pre><p>This new block provides the rule we can use to process files with Babel. Essentially, it's saying "test: for filenames that end with <code>.js</code>, exclude: any files in the <code>node_modules</code> folder, use: <code>babel-loader</code> on those files you find."</p></li>
				<li>With Babel transpilation supported, you now need to include support for HTML files. HTML processing is both a pre- and post-JavaScript processing task and, therefore, is carried out using both a loader and a plugin. To install both of these, run the following code:<pre>npm install --save-dev html-webpack-plugin html-loader</pre><p>If all went well, you should see the following output:</p><div><img alt="Figure 12.15: Webpack HTML loader and plugin installation&#13;&#10;" src="img/C14377_12_15.jpg"/></div><p class="figure-caption">Figure 12.15: Webpack HTML loader and plugin installation</p></li>
				<li>With these modules installed, they now need to be configured in the <code>webpack.config.js</code> file. Like the Babel loader, the HTML loader should be entered into the <code>modules</code> array of the <code>exports</code> object. Add it after the <code>babel-loader</code> configuration:<pre>{
  test: /\.html$/,
  use: [
    {
      loader: "html-loader",
      options: { minimize: true }
    }
  ]
}</pre></li>
				<li>Implementing the HTML plugin requires a couple of steps. First, you will need to require it at the top of the page:<pre>const HtmlWebPackPlugin = require("html-webpack-plugin");</pre></li>
				<li>With the module required, you can now configure it by adding it to the <code>plugins</code> section of the <code>exports</code> object:<pre>plugins: [
  new HtmlWebPackPlugin({
    template: "./src/index.html",
    filename: "./index.html"
  })
]</pre><p>Note that the directory of the output file is not required. The HTML plugin will place it in the <code>dist</code> folder, regardless.</p><p>Your <code>webpack.config.js</code> file should now look as follows:</p><pre>webpack.config.js
10   module: {
11     rules: [
12       {
13         test: /\.js$/,
14         exclude: /node_modules/,
15         use: {
16           loader: "babel-loader"
17         }
18       },
19       {
20         test: /\.html$/,
21         use: [
22           {
23             loader: "html-loader",
24             options: { minimize: true }
25           }
The full code is available at: <a href="https://packt.live/2XckybQ">https://packt.live/2XckybQ</a></pre></li>
				<li>Finally, execute your webpack script. You should now find that the JavaScript output has been correctly transpiled by Babel and that the <code>index.html</code> file will also be present within the <code>dist</code> directory. Your Terminal window should look as follows:<div><img alt="Figure 12.16: Successful webpack transpilation&#13;&#10;" src="img/C14377_12_16.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.16: Successful webpack transpilation</p>
			<p>Configuring webpack installations can be quite a lengthy process of trial and error. Even with this exercise, you may notice that the <code>index.html</code> file still does not implement a non-caching process whereby the JavaScript output is renamed randomly to avoid browser caching. While webpack is a must for medium-to-large projects that require that extra mile in configuration freedom, it is recommended that Parcel is used for those small projects that need a simple setup, without configuration headaches.</p>
			<h2 id="_idParaDest-464"><a id="_idTextAnchor518"/>Other Popular Bundlers</h2>
			<p>There are many bundler tools available for your JavaScript project, each with their own benefits and caveats. Obviously, choosing a bundler may result from personal choice or it may be a requirement from the project manager, development team, or the organization that tendered the project. However, of those bundlers, two of the most popular tools that haven't been covered in this chapter yet are Gulp and Grunt.</p>
			<p><strong class="bold">Gulp</strong> and <strong class="bold">Grunt</strong> are a little different from the examples you've seen up until now as they don't use configuration files. Instead, they use JavaScript code that you write to accomplish tasks similar to what webpack and Parcel can accomplish.</p>
			<p>Gulp and Grunt are known as task runners. This means that, instead of defining a coding environment for your project, they act as an application you write to manage the application you're writing; a kind of application wrapper, if you will. The toolsets for both these bundlers provide a framework to facilitate this, which runs on the Node.js runtime. You simply code what you would like to achieve and execute it.</p>
			<p>The <code>gulp</code> bundler which runs on the Node.js runtime is as follows:</p>
			<pre>var gulp = require('gulp');
gulp.task('build', () =&gt; { /* Compile production application */ });
gulp.task('build.dev', () =&gt; { /* Compile development application */ });
gulp.task('test.unit', () =&gt; { /* Run all unit tests */});
gulp.task('test.e2e', () =&gt; { /* Run all end-to-end tests */});
gulp.task('test', ['test.unit', 'test.e2e']);</pre>
			<p>The <code>grunt</code> bundler which runs on the Node.js runtime is as follows:</p>
			<pre>module.exports = function(grunt) {
  grunt.initConfig(gruntConfig);
  grunt.loadNpmTasks('grunt-contrib-jshint');
  grunt.loadNpmTasks('grunt-contrib-uglify');
  grunt.loadNpmTasks('grunt-contrib-watch');
  grunt.registerTask('default', ['jshint', 'uglify']);
};</pre>
			<h3 id="_idParaDest-465"><a id="_idTextAnchor519"/>Other Language Transpiling</h3>
			<p>The JavaScript platform is an extremely popular one. After all, it is the de facto script runtime for the majority of browsers. However, the JavaScript language isn't necessarily loved by everyone. Some developers prefer a static typing system, while others prefer better interoperability with their favorite server-side language. Whatever the reason, this love/hate relationship, mixed with JavaScript's monopoly of the browser itself, has created a long list of alternative languages that each transpile to JavaScript. Some of the more popular of these languages include the following:</p>
			<ul>
				<li>TypeScript</li>
				<li>Dart</li>
				<li>CoffeeScript</li>
				<li>Elm</li>
				<li>ClojureScript</li>
				<li>Haxe</li>
				<li>Nim</li>
				<li>PureScript</li>
			</ul>
			<p>Of course, the list is much longer than this, but the preceding list does highlight some of the more popular alternatives, each of which has its own set of benefits and drawbacks.</p>
			<h1 id="_idParaDest-466"><a id="_idTextAnchor520"/>The TypeScript Language</h1>
			<p><strong class="bold">TypeScript</strong> is an interesting and important alternative to the JavaScript language. A superset of the JavaScript language, TypeScript was developed by Microsoft and was released sometime in 2014. It is very similar to JavaScript but has a feature that is very important to some: strict typing with type inference.</p>
			<p>Strict typing is where a variable has a fixed type. This may be a number, a string, or a Boolean. By being strictly typed, a variable is unable to contain a value of any other type. This prevents a number of bugs in your system.</p>
			<p>Let's look at a JavaScript problem.</p>
			<p>A developer builds a function that accepts two numbers and adds them together:</p>
			<pre>function add(a, b) {
if (a &amp;&amp; b &amp;&amp; a + b) {
    return a + b;
  } else {
    throw "invalid parameters passed to 'add' function";
  }
}</pre>
			<p>Now, the developer has thought to check the parameters, first, that both <code>a</code> and <code>b</code> are provided, and then that the two values can be added together. However, as you saw in <em class="italic">Chapter 5, Beyond the Fundamentals</em>, the addition operator is overloaded, so if a string is passed, it will be concatenated into a new string:</p>
			<pre>add(1, 2);  // ==&gt; 3
add(true, false);  // ==&gt; "invalid parameters passed to 'add' function"
add(1, "2");  // ==&gt; "12"</pre>
			<p>While this is fine if the developer expected the outcome, it does raise potential hazards that could be missed by even seasoned developers. Such bugs are problematic because they do not resolve in an error at the source, but rather further in the application.</p>
			<p>TypeScript's static typing could easily solve this issue by ensuring the values that are passed to the function are of a specific type:</p>
			<pre>function add(a: number, b: number): number {
  return a + b;
}</pre>
			<p>All types are checked at compile time. In the preceding example, checking the content of the type is not necessary as the compiler will ensure that the function is called with the correct number of arguments. If an argument were optional, then it could be marked as such with the <code>?</code> operator:</p>
			<pre>function fun(a: number, b?: boolean) {}</pre>
			<p>Such optional parameters must always appear at the tail end of the arguments list.</p>
			<p>Of course, specifying the types of your variables is not required—the compiler will infer them. This means that based on the first value the variable contains, the compiler will then expect it to always contain a value of that type. Function arguments can still contain any type if you wish them to.</p>
			<h2 id="_idParaDest-467"><a id="_idTextAnchor521"/>Exercise 12.04: A Basic TypeScript Project</h2>
			<p>TypeScript is a major player in the professional JavaScript world, so understanding how to set up a TypeScript project is an important skill. In this exercise, you will create a minimal webpack project by utilizing the TypeScript transpiler. Let's get started:</p>
			<ol>
				<li value="1">Create a new directory and initialize it with a webpack installation, as per <em class="italic">Exercise 12.03: A Basic Webpack Project</em>.</li>
				<li>Next, install the TypeScript libraries from npm. These libraries will be saved as <code>devDependencies</code>, since TypeScript is not required by your project after transpiling:<pre>npm install --sa<a id="_idTextAnchor522"/>ve-dev typescript ts-loader</pre><p><code>ts-loader</code> is a webpack loader module since webpack doesn't know about or understand <code>*.ts</code> files out of the box.</p></li>
				<li>The TypeScript transpiler utilizes configuration from a unique document in the root of your project called <code>tsconfig.json</code>. The possible values for this document are extensive, but for a simple project, simply enter the following:<pre>{
"compilerOptions": {
"outDir": "./dist/",
"noImplicitAny": true,
"module": "es6",
"target": "es5",
"allowJs": true
  }
}</pre></li>
				<li>Open the <code>webpack.config.js</code> file and add the following rule to the <code>rules</code> list:<pre>{
  test: /\.tsx?$/,
  use: 'ts-loader',
  exclude: /node_modules/,
},</pre></li>
				<li>Update the entry filename from <code>index.js</code> to <code>index.ts</code>.  Your entire <code>webpack.config.js</code> file should now look as follows:<pre>webpack.config.js
28  plugins: [
29    new HtmlWebPackPlugin({
30      template: "./src/index.html",
31      filename: "./index.html"
32    })
33  ],
34  resolve: {
35    extensions: [ '.tsx', '.ts', '.js' ],
36  },
37  output: {
38    filename: 'bundle.js',
39    path: path.resolve(__dirname, 'dist'),
40  },
41}
The full code is available at: <a href="https://packt.live/2KhPK3Y">https://packt.live/2KhPK3Y</a></pre></li>
				<li>Now, provide an <code>index.ts</code> file within the <code>src</code> directory and add the following content:<pre>export function hello(name: string): string {
  return 'Hello ' + name;
}</pre></li>
				<li>You can now compile the application with the following code:<pre>npm run wp</pre></li>
			</ol>
			<p>You should now see a successful compilation output, as follows:</p>
			<div><div><img alt="Figure 12.17: TypeScript with webpack&#13;&#10;" src="img/C14377_12_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.17: TypeScript with webpack</p>
			<p>What you have just created is boilerplate for any kind of TypeScript application. Creating a webpack and TypeScript project may be something you do time and time again for many of your future projects.</p>
			<h2 id="_idParaDest-468"><a id="_idTextAnchor523"/>Elm and ClojureScript</h2>
			<p>Both <code>null</code> and <code>undefined</code> values completely.</p>
			<p>The intention of these languages is to empower the developer by outputting better code, but also improving the developer's coding ability. By thinking declaratively and functionally, problems can be solved more quickly and with better results.</p>
			<h2 id="_idParaDest-469"><a id="_idTextAnchor524"/>Haxe</h2>
			<p>Haxe approaches JavaScript from a different angle. It was created as a unified language that could compile on many platforms, including the following:</p>
			<ul>
				<li>Flash ActionScript 3</li>
				<li>C++</li>
				<li>C# (.NET)</li>
				<li>Java</li>
				<li>JavaScript</li>
				<li>Neko (a small, native cross-platform virtual machine)</li>
				<li>HashLink (an even faster, more portable cross-platform virtual machine)</li>
				<li>PHP</li>
				<li>Python</li>
				<li>Lua</li>
			</ul>
			<p>The platforms that are supported are continually increasing thanks to an enthusiastic community.</p>
			<p>By compiling on many platforms, the source code of a Haxe application has the benefit of being potentially portable between those platforms. This means you could write a Haxe application for a JavaScript client, but also use much of the same code in a C# server application.</p>
			<h1 id="_idParaDest-470"><a id="_idTextAnchor525"/>Code Support Libraries</h1>
			<p>Throughout its relatively long life, JavaScript has acquired a number of popular and useful libraries to aid engineers with their application development. Some of these libraries simply provide useful and reusable functions that reduce code complexity, while others offer extensive opinionated frameworks. Everything from user interfaces to database management is covered, with many overlapping libraries providing something a little different than competing libraries.</p>
			<h2 id="_idParaDest-471"><a id="_idTextAnchor526"/>jQuery</h2>
			<p>jQuery is one of the oldest running utility libraries available. Functioning as a general-purpose tool, jQuery empowered developers with a simple means to manipulate the browser's Document Object Model (DOM), perform animations, send Asynchronous JavaScript and XML (AJAX) requests, manage events, and more.</p>
			<p>Before jQuery was first released, finding and acquiring nodes within a web page was a laborious task, as was handling data and events from UI controls. The inception of jQuery alleviated a lot of the issues of earlier browsers, specifically with regard to cross-browser differences.</p>
			<p>These days, much of the functionality provided by jQuery is now present in modern browsers, but the library itself is still a popular choice for many seeking a more uniform means to manage client-side application development.</p>
			<p>jQuery provides a singular global reference object that can be accessed in two ways:</p>
			<pre>jquery(&lt;context&gt;)
$(&lt;context&gt;)</pre>
			<p>jQuery's ubiquity means that you're likely to see the solitary <code>$</code> symbol used throughout the internet and, indeed, very few libraries adopt this simple sigil, which is a valid variable symbol, for that reason.</p>
			<p>The jQuery library has been covered somewhat in previous chapters, so no further information will be provided here.</p>
			<h2 id="_idParaDest-472"><a id="_idTextAnchor527"/>Underscore, Lodash, and Ramda</h2>
			<p>Functional programming is becoming ever more important, with the benefits being realized in many different languages and platforms. While we can program in JavaScript functionally, it still does lack many features of more mature functional languages.</p>
			<p>To overcome this shortcoming, the JavaScript community has provided numerous functional-oriented libraries, with the most popular being Underscore, Lodash, and Ramda.</p>
			<p>Underscore and Lodash are named thus due to their use of the <code>_</code> symbol. Just like jQuery's <code>$</code> symbol, the <code>_</code> symbol provides the single access point for either of these libraries. Both libraries provide a means to assign the primary object to a variable of a different name if there is a likelihood of a clash of library namespaces in an application, but since Underscore and Lodash provide much of the same functionality, it is not common to see both in use at the same time. The Ramda library uses the capital letter <code>R</code> as its library accessor:</p>
			<pre>let toString = (v) =&gt; `${v}`;
// Lodash
_.map([1, 2], toString);  // ==&gt; ["1", "2"]
// Underscore
_.map([1, 2], toString);  // ==&gt; ["1", "2"]
// Ramda
R.map(toString, [1, 2]);  // ==&gt; ["1", "2"]</pre>
			<p>While each of these libraries provides a number of overlapping features, there are some functionalities that are unique to a library among the three. For instance, the Ramda library provides lensing functionality, which is a means to operate on subsets of a collection of data that match the given criteria.</p>
			<h2 id="_idParaDest-473"><a id="_idTextAnchor528"/>Client Frameworks Overview</h2>
			<p>Recent years have seen an explosion in powerful JavaScript application frameworks. Many of these provide interesting ways to greatly simplify single-page application (SPA) development, as well as modular, dynamically loaded applications. While frameworks have long been an important requirement for reducing development complexity, supporting engineering teams, and facilitating common use cases with minimal fuss, modern frameworks often take things to a whole new level.</p>
			<p>Thanks to mobile internet browsing, JavaScript applications often require increased functionality within the browser and less on the server. This greatly increases complexity and, while many such large applications require many engineers to work on such a JavaScript project, building these from scratch simply isn't conducive to a productive project. As such, frameworks are now becoming more and more important to reduce time to market, increase standards and best practices, and to raise creativity.</p>
			<h2 id="_idParaDest-474"><a id="_idTextAnchor529"/>Models, Views, and Controllers</h2>
			<p>Most application frameworks implement an architecture that separates application logic into common units of functionality. The primary abstraction of these units typically consists of Models, Views, and Controllers (MVC), whereby the Model represents an application's data, the View represents how information is presented to the user, and the Controller is the functionality that facilitates processing between data and events:</p>
			<div><div><img alt="Figure 12.18: Model-View-Controller&#13;&#10;" src="img/C14377_12_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.18: Model-View-Controller</p>
			<p>The notion of an MVC was derived well before the inception of the JavaScript language and, indeed, frameworks often derive from an MVC to something a bit more appropriate to the browser, such as the Model-View-View-Model (MVVM) pattern. However, simply understanding that there is an abstraction, and knowing the roles of the actors therein, helps improve your adoption of any given framework.</p>
			<h2 id="_idParaDest-475"><a id="_idTextAnchor530"/>Virtual DOMs</h2>
			<p>Another commonality of many newer frameworks is the inclusion of a virtual DOM. These are rendering engines that manage changes to nodes within the DOM. This means that, instead of manipulating the HTML within a web page directly, developers will instead utilize an API that sits between the application and the DOM. This way, when updates are needed, the virtual DOM will modify only those elements of the DOM that have changed by facilitating known low-latency, highly efficient methods.</p>
			<p>A great benefit of virtual DOMs arises when implementing two-way data binding between a Model and a View. If a user inputs a value in a text field, the associated Model could be instantly and automatically updated. Likewise, when the model updates, this may also trigger another view to display this new value. </p>
			<p>This is known as two-way data binding, which is the ability for a model and its views to equally update each other when one location changes. Such manipulations of the browser are greatly enhanced through the use of a virtual DOM, which may previously have resulted in user experience degradation.</p>
			<h2 id="_idParaDest-476"><a id="_idTextAnchor531"/>Reactive Programming</h2>
			<p>Another feature that's commonly found in modern frameworks is reactive functionality. When two-way data binding occurs using a virtual DOM, it is typically a reactive code that facilitates it. Reactive programming is a methodology of facilitating responsiveness, resilience, and scalability through data messaging. The idea is that, instead of polling and pulling data, messages are pushed as changes to data occur or when new data is made available. These updates may occur within an application or between applications, such as between the browser and the server.</p>
			<p>Reactive programming is such an important new paradigm that whole libraries and frameworks are named after it, such as RxJS (the Rx means Reactive) and ReactJS.</p>
			<h1 id="_idParaDest-477"><a id="_idTextAnchor532"/>Popular Frameworks</h1>
			<p>Of the numerous frameworks available, there are three that are arguably the most popular among the JavaScript community. They are as follows:</p>
			<ul>
				<li><strong class="bold">AngularJS</strong></li>
				<li><strong class="bold">ReactJS</strong></li>
				<li><strong class="bold">Vue.js</strong></li>
			</ul>
			<h2 id="_idParaDest-478"><a id="_idTextAnchor533"/>AngularJS</h2>
			<p>AngularJS was created by Google and released in October 2010 and was completely rewritten in 2014 as Angular2, changing many of its unique characteristics and adopting TypeScript as its preferred language; though it can be utilized with vanilla JavaScript with a bit of work. Since the rewrite, Angular2 is now incrementally updated with new releases regularly. Currently, Angular2 is on version 8 but is still called Angular2, which can get very confusing.</p>
			<p>AngularJS (and its successor, Angular2) has a relatively high learning curve, flourishing many paradigms that are unique to the Angular community. However, it's an extremely opinionated library, helping to ensure that teams of developers utilize it in a common way, relieving any potential ambiguity of functionality. Additionally, AngularJS is a fully encompassing framework, providing almost all of the tools you may require when building complex browser-based applications.</p>
			<h2 id="_idParaDest-479"><a id="_idTextAnchor534"/>ReactJS</h2>
			<p>ReactJS was conceived and developed by a single engineer at Facebook. In contrast to AngularJS, ReactJS does not try to do everything for you but purports to be merely the UI management layer, providing Virtual DOM functionality and other such goodies. The community that has formed around this framework has created additional libraries that can come together to form an ecosystem with similar capabilities to AngularJS. However, unlike AngularJS, ReactJS is not so opinionated, meaning applications can pick and choose what is implemented and, to some degree, how it is implemented. Developers also have greater freedom to decide from a range of libraries that compete to provide similar functionality.</p>
			<h2 id="_idParaDest-480"><a id="_idTextAnchor535"/>Vue.js</h2>
			<p>Vue.js was developed by Evan You in 2013, a Google developer who had been using AngularJS while working for Google, but who decided he'd like to take only those elements of AngularJS that he liked and make his own lightweight framework. The result is a modular framework that provides almost all of the functionality of AngularJS, but in pieces that can be selected as needed, such as ReactJS, and with a total file size far smaller than either of the other two frameworks.</p>
			<p>Vue.js has a very gentle learning curve and is steadily increasing in popularity as a framework that offers great application development structure, but without the rigid opinionated paradigms that work well in team environments. However, these often-hinder projects of a less vanilla nature.</p>
			<h1 id="_idParaDest-481"><a id="_idTextAnchor536"/>Server-Side Libraries</h1>
			<p>Just like the browser, the server-side JavaScript ecosystem also has access to libraries and frameworks that aid an application's development. Since Node.js is JavaScript too, it is possible to utilize many libraries within both the browser and Node.js. For instance, Lodash, Underscore, and Ramda, having no browser-specific qualities, will function just as well in a Node.js application. This is one of the key reasons why the Node.js platform took off so quickly following its initial release; with so many libraries already usable on the platform that was created for browser applications, it was possible for developers to continue working in a style they were familiar with for server-side application development.</p>
			<p>As well as all the possible browser-centric libraries, Node.js also has some key libraries of its own that provide functionality that is not possible in the browser, such as REST server functionality or database object relational mapping (ORM).</p>
			<h2 id="_idParaDest-482"><a id="_idTextAnchor537"/>Express</h2>
			<p>Possibly the single most popular library for Node.js is called Express. This library makes it extremely easy to build webservers since it provides functions that are able to establish routes and serve content when requests are sent to those routes.</p>
			<p>Express can be installed with the following command:</p>
			<pre>npm install --save express</pre>
			<p>Once installed, you can write a simple server application, such as the following:</p>
			<pre>const express = require('express')
const app = express()
const port = 4000; 
app.get("/say_hello", (request, response) =&gt; response.send("Hello, World!"))
app.listen(4000port, () =&gt; console.log(`Web server now listening on port: ${port}`))</pre>
			<p>Once built, the webserver can be launched just like any other Node.js application; for example:</p>
			<pre>node index.js</pre>
			<p>The Express object supports all possible HTTP call types, including <code>GET</code>, <code>PUT</code>, <code>POST</code>, and <code>DELETE</code>, thus empowering complete REST-capable servers, but is also capable of serving static HTML, JavaScript, CSS, and other such asset files, using a special <code>static</code> function.</p>
			<p>The Express library is very complete, so reading the documentation and guides on its website is recommended so that you get a true feeling of its capabilities.</p>
			<h2 id="_idParaDest-483"><a id="_idTextAnchor538"/>Request</h2>
			<p>While Express functions as a webserver, the Request library functions as a web client. Often, when creating web applications, it can become necessary to proxy content, data, or functionality from another remote webserver. The Request library enables communication with such servers for this purpose.</p>
			<p>Request can be installed with the following command:</p>
			<pre>npm install --save request</pre>
			<p>Once installed, you can use Request as follows:</p>
			<pre>const request = require("request")
request("https://www.google.com", function (error, response, data) {
  // do something with data
});</pre>
			<h2 id="_idParaDest-484"><a id="_idTextAnchor539"/>Socket.IO</h2>
			<p>Working with HTTP can be slow. The client creates a request packet and sends it to the recipient server. This server then creates a response packet and sends it back to the caller. Each request/response transaction is atomic, meaning it occurs independently of any other request/response transactions, often requiring a unique connection setup and teardown.</p>
			<p>Modern applications prefer to utilize web sockets more and more. These are "always connected" sockets that use a faster, more agile connection protocol for sending data and are wonderful for building applications such as online chat rooms, multiplayer games, and also for fast data storage and retrieval.</p>
			<p>While web sockets utilize a protocol of their own, that protocol merely handles the security and reliability of the data transaction, and not with the specific requirements of an application's logic.</p>
			<p>To address this, Socket.IO provides an additional layer to make working with web sockets much easier, thus providing functionality that's common to many applications that can utilize it how they see fit.</p>
			<p>Socket.IO can be installed with the following command:</p>
			<pre>npm install --save socket.io</pre>
			<p>A simple Socket.IO server application looks as follows:</p>
			<pre>const app = require("express")()
const server = require("http").createServer(app)
const sio = require("socket.io")(server)
sio.on("connection", function(socket){
  console.log("Connection established");
});</pre>
			<h2 id="_idParaDest-485"><a id="_idTextAnchor540"/>Activity 12.01: Creating a Project to Recognize and Compile TypeScript Files</h2>
			<p>This chapter provided a lot of information regarding the investigation of the greater JavaScript world. Obviously, there is a lot you can learn beyond the basics of a language or platform but knowing where to look and how to integrate a new library or framework into your application provides the necessary foundation from which you can experiment and improve your coding skills.</p>
			<p>In this activity, you have been tasked with setting up TypeScript for a new project. You are now aware of what TypeScript is. For the project at hand, both your project manager and your developer colleagues want to utilize TypeScript's static typing capabilities, among other things, in what will be a large project.</p>
			<p>Your task for this activity is to create the initial project setup, ensuring that TypeScript files are recognized and compiled correctly to the output folder. It is not important to provide any code, merely to ensure everything compiles successfully. The project manager is happy for Parcel to be used in this project in order to keep things simple.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Create a new project that has <code>npm</code> initialized.</li>
				<li>Install Parcel as a global library.</li>
				<li>Install the TypeScript library in the application.</li>
				<li>Create the necessary TypeScript configuration but keep it simple.</li>
				<li>Create a temporary <code>.ts</code> file in the <code>src</code> directory.</li>
				<li>Add the necessary script to the <code>package.json</code> file.</li>
				<li>Run the transpiler and ensure that output is generated. You should see no errors. The TypeScript transpiler should show a <code>Built in &lt;x&gt;ms</code> response message if all went well.</li>
			</ol>
			<p>The expected output for this activity is as follows:</p>
			<div><div><img alt="Figure 12.19: Parcel TypeScript Output&#13;&#10;" src="img/C14377_12_19.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.19: Par<a id="_idTextAnchor541"/>cel TypeScript Output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to the activity can be found on page 752.</p>
			<p>Simply knowing how to utilize a package manager opens up vast amounts of power so that you can create functional applications quickly. When working in a professional environment, using the necessary tools in the correct fashion is paramount and will ensure that your application starts off on the right footing.</p>
			<h1 id="_idParaDest-486"><a id="_idTextAnchor542"/>Summary</h1>
			<p>In this chapter, we had a look at the various tools that are available on the market for advanced development in JavaScript. We learned how to use the latest JavaScript syntax in older browsers and identified the different options that are available for the development of JavaScript applications in other languages. We also explored the various package managers, such as npm and Yarn, that are compatible with JavaScript, along with several different frameworks, such as AngularJS, ReactJS, and Vue.js. Finally, we looked at some server-side libraries such as Express, Request, and Socket.IO.</p>
			<p>In the next chapter, we will look at some other areas of advanced JavaScript.</p>
		</div>
	</body></html>