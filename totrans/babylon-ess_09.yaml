- en: Chapter 9. Create and Play Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned everything that is required to create
    cool, beautiful, and complete 3D applications. This is the last chapter and the
    last thing that you need to learn is how to animate objects in your scene. Then,
    finally, you will get a fully dynamic scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Babylon.js framework provides a way to create animations without managing
    them with code. For example, you want to create a rotation animation that will
    affect five objects (nodes) in your scene; Babylon.js will allow you to create
    an animation object that you can share easily between your five nodes. In this
    chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations using Babylon.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smooth animations using easing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing and managing animated models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating animations using Babylon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this first topic, let's discuss how to simply animate a box with code and
    how to create an animation using the Babylon.js tools such as the `BABYLON.Animation`
    class. You'll quickly understand the importance of using the provided tools instead
    of handling animations with code.
  prefs: []
  type: TYPE_NORMAL
- en: Animating an object with code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the following scene (a plane and a box):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating an object with code](img/image_09_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's animate the box to turn around its center (x = 0, y = 0, and z = 0). The
    process should be to increment a value (angle) in time and set the new position
    of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, (*x = Radius*Cos(angle)*, *y = 0*, and *z = Radius*Sin(angle)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this action, you can call a `.registerBeforeRender` function on
    the scene. This function takes an anonymous function as the parameter and this
    anonymous function will be automatically called for every frame, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is pretty simple; however, it is applied only to the box. What
    if you want to animate another object by sharing the same code? The solution is
    simple; just pass the node as a parameter to a function that will register a new
    function at each call before render, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is not necessarily a problem to manage the animations through
    code. The real problem occurs when you have to synchronize the animation with
    time (manage the speed of animation), stop or pause animations, and so on. These
    functions require you to create a complete manager and it is not necessary what
    you want to do.
  prefs: []
  type: TYPE_NORMAL
- en: The next sub-topic will show you how to use the animation manager of Babylon.js
    and don't worry about the time, stop and pause functions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using the animation manager of Babylon.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take the same scene and create a simple animation only using the animation
    manager of Babylon.js. You need to understand only one thing: the frame keys of
    an animation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an animation, just use the `BABYLON.Animation` class and attach it
    to a node (or several nodes). The `BABYLON.Animation` class isn''t difficult to
    understand, it takes a name, a property to animate on a node (and not necessarily
    a property of a node), number of frames per second, data type, and loop mode,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `rotation` parameter says that the animation manager will animate the `.rotation`
    property of the object attached to the animation. A rotation is of the `BABYLON.Vector3` type,
    this is the reason why the data type is `BABYLON.Animation.ANIMATIONTYPE_VECTOR3`.
    Finally, we want the animation to loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the property you are animating (*rotation* in the previous example
    that is a `BABYLON.Vector3` object), you have to provide a valid data type which
    can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANIMATIONTYPE_FLOAT`: When the property is of the `float` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANIMATIONTYPE_VECTOR2`: When the property is of the `BABYLON.Vector2` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANIMATIONTYPE_VECTOR3`: When the property is of the `BABYLON.Vector3` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANIMATIONTYPE_QUATERNION`: When the property is of the `BABYLON.Quaternion` type.
    A mathematical object that can be used to represent the rotation of a node (`node.rotationQuaternion`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANIMATIONTYPE_MATRIX`: When the property is of the `BABYLON.Matrix` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANIMATIONTYPE_COLOR3`: When the property is of the `BABYLON.Color3` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we use the `Vector3` data type as the `.rotation` property is
    `BABYLON.Vector3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step consists of creating an array of keys. The keys (or key frames)
    represent the state of the animated property at specific frames. In the previously
    created animation, the number of frames per second was set to `1`. Then, each
    second, a key, in the array of keys, is reached. The keys of an animation is simply
    an array of objects, objects each composed of two properties: the frame number
    and, according to the animated property, the associated value (of type `float`,
    `BABYLON.Vector2`, or `BABYLON.Vector3`, and so on.), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create two keys that will translate the box from the position (`x =
    0`, `y = 2.5`, and `z = 0`) to (`x = 10`, `y = 10`, and `z = 10`) at frame 20,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the number of frames per second is set to `1`, the second key (`frame = 20`)
    means that the box position will be at (`x = 10`, `y = 10`, and `z = 10`) 20 seconds
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the keys for the `simpleAnimation` animation manager, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s attach the animation manager to the box and start the animation
    in the scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks similar to the following at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the animation manager of Babylon.js](img/image_09_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, once the animation has finished, the result looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the animation manager of Babylon.js](img/image_09_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To reproduce the previous example (the box that turns around the center), the
    solution is pretty simple; just add 360 keys that represent every degree of a
    circle, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To control your animations (start, pause, restart, and stop), the `.beginAnimation`
    function returns an object of the `BABYLON.Animatable` type. The returned object
    is created on the fly and allows you to control your animations. Let''s consider
    the same example as earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a simple animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first example, with only two frames, can be heavy as I know that you''ll
    quickly create a helper, once and for all. Babylon.js thought about this and provides
    a static `CreateAndStartAnimation` function that creates two frames and starts
    the animation for you. Let''s create the same animation only using the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can guess, this method is used by Babylon.js to create `BABYLON.InterpolateValueAction`
    ([Chapter 7](ch07.html "Chapter 7. Defining Actions on Objects"), *Defining Actions
    on Objects*).
  prefs: []
  type: TYPE_NORMAL
- en: Managing events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An advanced use of the Babylon.js animations is to call a function when a specific
    frame is reached. The `BABYLON.AnimationEvent` class exists to allow you to attach
    one or more events to a specific frame. For example, consider the previous example
    (`complexAnimation`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using easing functions to smooth animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advanced features of the Babylon.js animations management is to use
    easing functions to smooth well and add behaviors to your animations.
  prefs: []
  type: TYPE_NORMAL
- en: To take a quick look at the appearance of the easing functions (we do not necessarily
    remember every type of easing functions), you should follow this link ([http://easings.net/en](http://easings.net/en)).
  prefs: []
  type: TYPE_NORMAL
- en: Applying an easing function to an animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To apply an easing function to an animation, the method only consists of customizing
    an already created animation. You'll just have to call the `.setEasingFunction`
    method for an animation with an easing function as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The available easing functions are (with the associated curve in time) as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Circle ease: `BABYLON.CircleEase()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Back ease: `BABYLON.BackEase(amplitude)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Bounce ease: `BABYLON.BounceEase(bounces, bounciness)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_006.png)'
  prefs: []
  type: TYPE_IMG
- en: Cubic ease: `BABYLON.CubicEase()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Elastic ease: `BABYLON.ElasticEase(oscillations, springiness)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_008.png)'
  prefs: []
  type: TYPE_IMG
- en: Exponential ease: `BABYLON.ExponentialEase(exponent)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_009.png)'
  prefs: []
  type: TYPE_IMG
- en: Quadratic ease:`BABYLON.QuadraticEase()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_010.png)'
  prefs: []
  type: TYPE_IMG
- en: Quartic ease: `BABYLON.QuarticEase()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_011.png)'
  prefs: []
  type: TYPE_IMG
- en: Quintic ease: `BABYLON.QuinticEase()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_013.png)'
  prefs: []
  type: TYPE_IMG
- en: Sine ease: `BABYLON.SineEase()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Applying an easing function to an animation](img/image_09_012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with the following simple example (animate the .x property of
    the box''s rotation using a circle easing function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all, the animation will now follow the formula of the circle easing
    function, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As it is hard to represent an animation by taking screenshots, you can try the
    different easing functions by yourself. The method is the same for all the easing
    functions, except that several easing function constructors will need some arguments
    for more customization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify the behavior of the easing function. An easing function
    consists of modes, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In`, when the animation starts (enters): `BABYLON.EasingFunction.EASINGMODE_EASEIN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Out`, when the animation is completed (exits): `BABYLON.EasingFunction.EASINGMODE_EASEOUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`In & Out`, when the animation starts and finishes (both enter and exit): `BABYLON.EasingFunction.EASINGMODE_EASEINOUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the easing mode is set to `In` (`BABYLON.EasingFunction.EASINGMODE_EASEIN`).
    The website [http://easings.net/en](http://easings.net/en) shows exactly how the
    easing functions look in these three modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the easing mode, just call the `.setEasingMode` method on an animation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating your own easing function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the last sub-topic about easing functions, let's discuss how to create your
    own easing function if it is not available in Babylon.js. The process is really
    simple (except the possible difficult mathematical formula(s) associated with your
    easing function).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just create a class that inherits from the `BABYLON.EasingFunction` class that
    implements the `BABYLON.IEasingFunction` interface. The only thing to do is to
    implement the `.easeInCore(gradient: number)` function that takes the interpolated
    value as the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an example with a Power easing function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Importing and managing animated models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To finish this chapter with a cool demo, let's discuss how to animate characters
    or 3D models, in general.
  prefs: []
  type: TYPE_NORMAL
- en: How 3D animated models work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you remember, each vertex of a 3D model is computed to be projected on the
    screen by a vertex shader. In fact, the animated 3D models (such as a character)
    are also animated with the associated hierarchy of bones (the hierarchy is called **Skeleton**).
    Animated 3D models are also called **Skinned Meshes**. In 3D engines, the bones
    are invisible nodes that are animated (`BABYLON.Animation`) to be sent to the
    vertex shader associated with the 3D model. In other words, the transformation
    of each bone is sent to the vertex shader and is applied to the associated vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To go further in the theory, the vertex shader contains the following two additional
    buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: The bones' matrices weights (Vector4, represents the *intensity* of the influence
    of each bone on the current vertex).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bones' matrices indices (Vector4, until four bone influences per vertex)
    work like the indices buffer, but for bones. In other words, for each vertex,
    which bones influence the vertex (indices in the array of bones' transformations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note:** The common buffers for static 3D models are the positions (required),
    indices (required), normals (not required), UVs (texture coordinates, not required),
    and colors (not required).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for each vertex, the formula (in GLSL) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When artists export their 3D models (animated with the tools provided by the
    modeling software), the Babylon.js exporters (3ds Max and Blender) explicitly
    write the bones' weights' buffers and the bones' matrices indices buffers in the
    exported file, which arrays of numbers. In conclusion, for animated 3D models,
    you don't have to specify the animations through code, the exporters can do everything
    for you. Let's wait until the next sub-topic to learn how to animate the 3D models.
  prefs: []
  type: TYPE_NORMAL
- en: Importing and playing animations of an animated 3D model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To import an animated 3D model, you have to use the `BABYLON.SceneLoader` class
    for the static 3D models ([Chapter 3](ch03.html "Chapter 3. Create, Load, and
    Draw 3D Objects on the Screen"), *Create, Load, and Draw 3D Objects on the Screen*)
    to import an animated 3D model. In fact, the `.Load` (and `.Append`) function
    automatically loads the animated 3D models with the associated skeletons (hierarchy
    of nodes) with the difference that the `.ImportMesh` function''s callback provides
    the loaded meshes, particle systems, and skeletons, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Concretely, as the animated nodes are the skeletons'' bones, the target of
    the `.beginAnimation` function is only the skeleton associated with your animated
    3D model and not the node itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start an example (available in the example files) using the `.ImportMesh`
    function, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note:** An animated 3D model can contain multiple meshes. This is the reason
    the `ImportMesh` function can return an array of multiple meshes and only one
    skeleton in the array of skeletons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result (the man is walking and the animation played from frame 0 to 150)
    is as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and playing animations of an animated 3D model](img/image_09_014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `.Load` function, the method is pretty different. As the success
    callback provides only the loaded scene, you''ll have to find the skeletons stored
    in the scene. To do this, simple use the `.getSkeletonByName` function on the
    scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result with the `dude.babylon` scene using the `.Load` function is as shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and playing animations of an animated 3D model](img/image_09_015.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating animations using Babylon.js can really make your scenes more alive.
    As you can see, these features are also pretty simple to use, following the principle
    of Babylon.js: the KISS principle (Keep It Simple, Stupid).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, at the end of this book, you are ready to work with the artists and combine
    all the learned features of Babylon.js. Using post-processes, manage and customize
    materials, create and manage animations, load scenes, manage actions, and so on!
  prefs: []
  type: TYPE_NORMAL
- en: To go further, you can have a look at the new features (recently released) such
    as the materials library (a library of specific easy-to-use materials like the
    standard material, such as water, terrain material, PBR, lava, and so on!). One
    of the new features should be the procedural textures automatically handled by
    Babylon.js such as fire, ground, grass, and so on. Also, to go further, you can
    take a look at the particle systems and shadows generator for specific projects
    that need to create some smoke or fire, and more beautiful (but more expansive)
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Have fun with Babylon.js!
  prefs: []
  type: TYPE_NORMAL
