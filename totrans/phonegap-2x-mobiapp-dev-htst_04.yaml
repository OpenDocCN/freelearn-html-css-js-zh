- en: Chapter 4. Let's Take a Trip
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。让我们去旅行
- en: Geolocation has become very important in today's world, especially since most
    phones have the capability to determine your position to an astonishing degree
    of accuracy. Given that this used to (not so long ago) be the mainstay of expensive
    GPS gadgets, it is amazing how quickly this ability has become ubiquitous. Because
    of this, users expect location-aware applications, and not just that, but they
    expect a nice map that responds to their input right along with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 地理定位在当今世界变得非常重要，尤其是在大多数手机都有能力以惊人的精确度确定你的位置之后。鉴于这曾经（不久前）是昂贵GPS设备的主要功能，这种能力迅速普及真是令人惊讶。因此，用户期望有位置感知的应用程序，不仅如此，他们还期望有一个能够响应他们输入的漂亮地图。
- en: What do we build?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么？
- en: Our project is aimed at two concepts, the first being to simply use a (very)
    small portion of the Google Maps API (as of this writing, 3.9). We will use this
    API to display a fully functional map that is centered on the user's current location.
    Secondly, we will use the geolocation features that PhoneGap provides in order
    to obtain the user's current location. When we're done, we'll have an app that
    can not only display a map centered around the user's current location, but we'll
    also have an app that can record their movements and show them on-screen. Instead
    of a voice recorder, think of it as a location recorder.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目旨在实现两个概念，第一个是简单地使用（非常）小部分的Google Maps API（截至本文写作时，3.9）。我们将使用这个API来显示一个以用户当前位置为中心的完整功能地图。其次，我们将使用PhoneGap提供的地理定位功能来获取用户的当前位置。完成之后，我们将有一个应用程序，不仅可以显示以用户当前位置为中心的地图，还可以记录他们的移动并在屏幕上显示。与其想象成录音机，不如想象成位置记录器。
- en: What does it do?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它做什么？
- en: We introduced document management in the last project, and we'll further shore
    up those capabilities in this project. Thankfully, most of the work is done for
    us, but as you recall, there were a few situations where the user could get into
    trouble (if they used a name that collided with an existing file). We'll take
    care of that in this project so that we have a much more robust solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目中，我们引入了文档管理，在这个项目中我们将进一步巩固这些功能。幸运的是，大部分工作已经为我们完成，但正如你所回忆的，有几个情况下用户可能会遇到麻烦（如果他们使用了一个与现有文件冲突的名称）。在这个项目中，我们将解决这个问题，以便我们有一个更加健壮的解决方案。
- en: We'll also be going over the various methods that we can use to load in the
    Google Maps APIs, something that turns out to be a little more difficult than
    one would initially think, and this is complicated by the fact that we have to
    deal with the possibility of losing (or not having) network access. We won't use
    the entire Google Maps API, it deserves a book all its own, but we will use some
    basic features, including markers and lines.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍我们可以使用的各种方法来加载Google Maps API，这比最初想象的要困难一些，而且我们还要处理可能失去（或没有）网络访问的可能性。我们不会使用整个Google
    Maps API，它值得一本自己的书，但我们将使用一些基本功能，包括标记和线条。
- en: Finally, we'll be using geolocation. Some browsers are kind enough to provide
    a good implementation of geolocation, and since PhoneGap's implementation follows
    the W3C standard, it will use the browser solution if it is good enough. This
    also means that what we're building could even be made to work outside of PhoneGap
    if one switched to using `localStorage` instead of persistent files.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用地理定位。一些浏览器足够好，提供了良好的地理定位实现，由于PhoneGap的实现遵循W3C标准，如果浏览器解决方案足够好，它将使用浏览器解决方案。这也意味着，如果我们使用`localStorage`而不是持久文件，我们构建的内容甚至可以在PhoneGap之外工作。
- en: 'When we''ve put it all together, we''ll have a pretty interesting app. An app
    that records our location (while we let it) and that can then display it. This
    opens up all sorts of possibilities for extension: you could share a path with
    a friend, you could export to KML for ingestion by other applications, and more.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有这些整合在一起时，我们将有一个相当有趣的应用程序。一个可以记录我们的位置（在我们允许的情况下）并显示它的应用程序。这为扩展提供了各种可能性：你可以与朋友分享路径，你可以导出为KML以供其他应用程序使用，等等。
- en: Why is it great?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它为什么很好？
- en: Geolocation and interactive maps are something users expect in today's apps.
    If you display an address, you should at least be able to display a map to go
    along with it. If you offer searches by location, you should be able to locate
    where the user is and provide them with relevant results. Geolocation and interactive
    maps aren't just for turn-by-turn location or helping someone who's become lost;
    they are invaluable in a lot of other applications as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 地理定位和交互式地图是现代应用中用户所期望的功能。如果你显示地址，至少应该能够显示一个地图与之配合。如果你提供基于位置的搜索，你应该能够定位用户的位置并向他们提供相关结果。地理定位和交互式地图不仅用于路线导航或帮助迷路的人；它们在许多其他应用中也非常有价值。
- en: How are we going to do it?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们该如何进行？
- en: In many ways, this task is easier than those that have preceded it. For one,
    our framework has become pretty stable (though there are some changes for this
    project), and we have a good start on document management. What's really left
    is creating the data model that is capable of storing location information and
    saving and retrieving it. This is also our first app where we'll dispense with
    the start view – we'll jump straight into the app from now on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这个任务比之前的任务更容易。一方面，我们的框架已经变得相当稳定（尽管这个项目有一些变化），我们在文档管理方面也有了一个良好的开端。真正剩下的是创建一个能够存储位置信息并保存和检索它的数据模型。这也是我们第一个不需要开始视图的应用——从现在起，我们将直接进入应用。
- en: 'In order to accomplish this, we''ll use the same familiar steps we''ve used
    before:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用之前使用过的相同熟悉步骤：
- en: Designing our UI and the look and feel
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计我们的UI和外观感受
- en: Designing our data model
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计我们的数据模型
- en: Implementing our data model
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现我们的数据模型
- en: Changing our document manager
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改我们的文档管理器
- en: Implementing our map view
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现我们的地图视图
- en: What do I need to get started?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要什么来开始？
- en: As always, go ahead and create your project. Be sure to follow the same project
    steps as in previous projects, though you don't need to worry about plugin support;
    we don't need any native plugins for this app.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，继续创建你的项目。虽然你不需要担心插件支持；我们不需要任何本机插件来为这个应用。
- en: 'Also, take a look at the Google Maps API ([https://developers.google.com/maps/documentation/javascript/3.9/reference](https://developers.google.com/maps/documentation/javascript/3.9/reference)).
    While there, you might want to sign up for an API key as well. Although you can
    use the API without one (and we do here), having a key allows for usage metrics,
    and should your app become popular enough, the ability to pay for your use so
    that you aren''t restricted to the low API caps enforced for non-key users. Be
    sure to take a look at their documentation as well; there''s a lot of it there,
    enough to fill several chapters alone, but it is well worth perusing. Put it this
    way: there are things Google Maps does that I never knew it could do, and you
    might discover the same.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也请查看一下谷歌地图API ([https://developers.google.com/maps/documentation/javascript/3.9/reference](https://developers.google.com/maps/documentation/javascript/3.9/reference))。在那里，你可能还想注册一个API密钥。虽然你可以不使用密钥使用API（我们在这里就是这样做的），但拥有一个密钥可以提供使用指标，并且如果你的应用足够受欢迎，你将能够为你的使用付费，这样你就不会受到为非密钥用户强制执行的低API配额的限制。务必查看他们的文档；那里有很多内容，足以填满几个章节，但它非常值得浏览。这样说吧：有些谷歌地图能做的事情，我以前从未知道它能够做到，你也可能会发现同样的情况。
- en: Designing our UI and the look and feel
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的UI和外观感受
- en: As always, let's not start coding until we have a good idea about how we want
    our app to look. Thankfully, we really only have to focus on the map view. We've
    already covered the look and feel of our document manager in the previous project,
    and it's not changed much here. Furthermore, since a good portion of the view
    will actually be taken up by the interactive map provided by Google, there's not
    even a lot we have to do there.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在我们对应用的外观有一个很好的想法之前，不要开始编码。幸运的是，我们实际上只需要关注地图视图。我们在上一个项目中已经涵盖了文档管理器的外观和感受，这里并没有太大的变化。此外，由于视图的大部分实际上将由谷歌提供的交互式地图占据，所以我们甚至不需要做太多。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Once again, get your pencil and paper out or your favorite graphics editor;
    we'll be using them to design our wireframe and then build out any of the assets
    we might need later on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，拿出你的铅笔和纸或者你最喜欢的图形编辑器；我们将使用它们来设计我们的线框图，然后构建我们可能以后需要的任何资产。
- en: Getting on with it
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动吧
- en: 'The following screenshot gives a final mockup of our map view:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们地图视图的最终原型：
- en: '![Getting on with it](img/9403_04_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动吧](img/9403_04_01.jpg)'
- en: At first glance, this appears like a pretty simple view—and it is—but don't
    let that fool you. There's a lot of power underneath!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎是一个相当简单的视图——确实如此——但不要被它欺骗。其下隐藏着巨大的力量！
- en: 'Let''s go over the various items:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下各种项目：
- en: The **Back** button will take the user back to the document management interface.
    For Android, of course, this button will not be present; the device's physical
    back button will do the trick.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回**按钮将用户带回到文档管理界面。当然，对于Android来说，这个按钮将不会出现；设备的物理返回按钮将起到作用。'
- en: The title on the navigation bar will be the title of the document. The user
    can tap on it to change the document via a prompt alert from our framework.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航栏上的标题将是文档的标题。用户可以点击它，通过我们框架的提示警报来更改文档。
- en: The button with the *globe* is intended to be the *find me* button. The view
    will automatically do this when shown, but one of the hallmarks of an interactive
    map is that you should be able to explore it on your own without constantly being
    dragged back to your current position. This button is intended to re-center your
    map after you've done some exploration.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有*地球仪*的按钮打算作为*找到我*按钮。当显示时，视图将自动执行此操作，但交互式地图的一个显著特点是您应该能够自己探索它，而无需不断被拖回到当前位置。此按钮的目的是在您进行了一些探索后重新定位您的地图。
- en: The button with the *red dot* is the *record* button. When tapped the view will
    begin to record your position (as often as it changes) and draw a line following
    your progress. If tapped again, it will stop tracking your location.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有*红点*的按钮是*记录*按钮。当点击时，视图将开始记录您的位置（每次位置改变时）并绘制一条跟随您进度的线。如果再次点击，它将停止跟踪您的位置。
- en: Below the navigation bar is the Google Map (here, an *X* image). This will,
    of course, be populated from Google. Moving the map with your finger will, of
    course, pan the map, but more importantly, we will catch this event so that we
    can *unlock* the map from your current location.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航栏下方是谷歌地图（此处为*X*图像）。当然，这将由谷歌提供。用手指移动地图将平移地图，但更重要的是，我们将捕捉这个事件，以便我们可以*解锁*地图，使其从您的当前位置开始。
- en: The downward pointing arrow is a representation of the typical *Google Marker*;
    this will indicate your current position.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下的箭头是典型的*谷歌标记*的表示；这将指示您的当前位置。
- en: The line is a representation of some path already recorded; it will indicate
    every update in your path during the recording.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线条是表示已经记录的一些路径的表示；它将指示在记录过程中路径的每次更新。
- en: Now that we've defined how everything should work together, let's go into our
    graphics program and create the graphical assets we'll need.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了所有东西应该如何协同工作，让我们进入我们的图形程序，创建我们需要的图形资产。
- en: 'The documents view will be as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文档视图将如下所示：
- en: '![Getting on with it](img/9403_04_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_04_02.jpg)'
- en: 'The map view will be as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 地图视图将如下所示：
- en: '![Getting on with it](img/9403_04_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_04_04.jpg)'
- en: Generally, we've used the same assets as for our previous project, though our
    document image has changed to a map. We'll also need to use the images on our
    buttons, one for the standard find me icon, and two for the various states of
    the record button—a circle (for record) and a pause icon (not shown). These icons
    are from App-Bits' free icon set available at [http://app-bits.com/free-icons.html](http://app-bits.com/free-icons.html).
    You might want to go ahead and download that set as well, if you haven't already.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用了与先前项目相同的资产，尽管我们的文档图像已更改为地图。我们还需要使用按钮上的图像，一个用于标准的*找到我*图标，两个用于记录按钮的各种状态——一个圆圈（用于记录）和一个暂停图标（未显示）。这些图标来自App-Bits的免费图标集，可在[http://app-bits.com/free-icons.html](http://app-bits.com/free-icons.html)找到。如果您还没有，您可能想先下载这个图标集。
- en: What did we do?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task we've covered how the user interface will be designed and how the
    various pieces of it will work. We skipped discussing the document manager since
    it is virtually identical to the prior project, the only thing that has changed
    is the image we're using and the file extension.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们介绍了用户界面的设计以及它的各个部分如何工作。我们跳过了文档管理器的讨论，因为它与先前项目几乎相同，唯一的变化是我们使用的图像和文件扩展名。
- en: Designing our data model
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的数据模型
- en: In this task, we will work on designing our data models. We'll focus on our
    document and the items that go in it; the document manager model remains unchanged
    from the previous project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将致力于设计我们的数据模型。我们将关注文档及其包含的项目；文档管理器模型与先前项目保持不变。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you look up the documentation for geolocation, you'll notice that the position
    information contains quite a bit of information including latitude, longitude,
    altitude, heading, and speed. Most implementations also return the accuracy of
    the location and altitude, but we'll be ignoring that for now. Since our map will
    show the current location, we will assume that the user won't start recording
    until the current location is correct, and so waiting for the accuracy to settle
    down is less important. If we were going to begin recording instantly, we would
    need to wait for the accuracy to narrow to an acceptable limit, and this is where
    those values become useful.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查阅地理位置的文档，你会注意到位置信息包含相当多的信息，包括纬度、经度、海拔、航向和速度。大多数实现也会返回位置和海拔的精度，但我们现在将忽略这一点。由于我们的地图将显示当前位置，我们假设用户只有在当前位置正确的情况下才会开始记录，因此等待精度稳定下来就不那么重要了。如果我们打算立即开始记录，我们需要等待精度缩小到可接受的极限，这就是这些值变得有用的地方。
- en: Go ahead and get out your paper and pencil, and we'll start working on our data
    model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 拿出你的纸和笔，我们将开始构建我们的数据模型。
- en: Getting on with it
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'Our data model will look like the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据模型将类似于以下截图：
- en: '![Getting on with it](img/9403_04_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_04_03.jpg)'
- en: 'Technically, we have three models: the two shown in the preceding screenshot
    and the `PathRecDocumentCollection` model, which is identical to the document
    manager model we saw in the last project. Since it is identical, we''ll skip that
    and focus on the two models shown in the preceding screenshot. Let''s start with
    `PathRecDocumentItem` :'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们有三个模型：前一个截图显示的两个模型和 `PathRecDocumentCollection` 模型，后者与我们在上一个项目中看到的文档管理器模型相同。由于它相同，我们将跳过它，专注于前一个截图显示的两个模型。让我们从
    `PathRecDocumentItem` 开始：
- en: '`timestamp`, `latitude`, `longitude`, `altitude`, `heading`, and `speed` are
    all properties our item needs to store. We''ll collect these at object creation
    time and store them via `setPosition()` so that our item will be immediately populated.
    Unlike the `position` object used for geolocation, we won''t store the coordinates
    in a `coords` object, but we will have to deal with that later.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp`、`latitude`、`longitude`、`altitude`、`heading` 和 `speed` 都是项目需要存储的属性。我们将在对象创建时收集这些属性，并通过
    `setPosition()` 存储它们，以便我们的项目能够立即填充。与用于地理位置的 `position` 对象不同，我们不会在 `coords` 对象中存储坐标，但我们必须稍后处理这个问题。'
- en: '`setPosition()` takes either a geolocation position (with a `coords` object)
    or a serialized `PathRecDocumentItem` object (without a `coords` object). It will
    update the properties appropriately.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setPosition()` 方法可以接受一个地理位置位置（带有 `coords` 对象）或一个序列化的 `PathRecDocumentItem`
    对象（不带 `coords` 对象）。它将适当地更新属性。'
- en: The `get…()` property will return the requested property value.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get…()` 属性将返回请求的属性值。'
- en: The `getLatLong()` property returns the latitude and longitude in the form `lat,
    long`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLatLong()` 属性以 `lat, long` 的形式返回纬度和经度。'
- en: The `getGoogleLatLng()` property returns a Google Maps `LatLng` object.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getGoogleLatLng()` 属性返回一个 Google Maps `LatLng` 对象。'
- en: The `getGoogleMarker()` property returns a Google Maps `Marker` object.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getGoogleMarker()` 属性返回一个 Google Maps `Marker` 对象。'
- en: The `serialize()` property returns an object ready for storing in a JSON document.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize()` 属性返回一个准备好存储在 JSON 文档中的对象。'
- en: 'Keep in mind that the preceding model only stores a single geolocation position;
    to string a bunch of them together requires the next model, `PathRecDocument`,
    which includes the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，前面的模型只存储单个地理位置位置；要将多个位置串联起来，需要下一个模型 `PathRecDocument`，它包括以下内容：
- en: '`fileEntry`, `filename`, `completion`, `failure`, and `state` are all the same
    as the document in our last project.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileEntry`、`filename`、`completion`、`failure` 和 `state` 都与我们在上一个项目中使用的文档相同。'
- en: The `title` property stores the title of the document.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title` 属性存储文档的标题。'
- en: '`nodes` is an array of the earlier-listed items; this is how we''ll store a
    series of geolocation positions. Put them all together in a line, and we''ll have
    the path that a user took during a recording.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodes` 是先前列出的项的数组；这是我们存储一系列地理位置位置的方式。将它们全部放在一行中，我们就会得到用户在录制过程中走过的路径。'
- en: The `get`/`setTitle()` methods returns and sets the title of the document.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`/`setTitle()` 方法返回并设置文档的标题。'
- en: The `get`/`setNodes()` methods will return and set the nodes; these take arrays.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`/`setNodes()` 方法将返回并设置节点；这些需要数组。'
- en: The `addNode()` method will push a node onto the list of notes; this must be
    a `PathRecDocumentItem`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addNode()` 方法将节点推送到笔记列表中；这必须是一个 `PathRecDocumentItem`。'
- en: The `getNodeAtIndex()` method will return a node at the given index.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNodeAtIndex()` 方法将返回给定索引处的节点。'
- en: The `getNodeCount()` method will return how many nodes are in the path.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNodeCount()` 方法将返回路径中的节点数量。'
- en: The remaining methods are the same as the document model in the previous project.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的方法与上一个项目的文档模型相同。
- en: The `serialize()` method will return an object suitable for storing in a file.
    Unlike in the previous project, this time `serialize()` must iterate through each
    node, calling its `serialize()` method to build up an array of nodes without all
    the extra methods in `PathRecDocumentItem`. (After all, there's no reason to store
    these.) The result will be an object with a title property, and a nodes array
    with only the position information contained within; everything else will be stripped
    out.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize()` 方法将返回一个适合存储在文件中的对象。与上一个项目不同，这次 `serialize()` 必须遍历每个节点，调用其 `serialize()`
    方法来构建一个不包含 `PathRecDocumentItem` 中所有额外方法的节点数组。（毕竟，没有理由存储这些。）结果将是一个具有标题属性和仅包含位置信息的节点数组的对象；其他所有内容都将被删除。'
- en: What did we do?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we created our data model, and reused portions of our previous
    project's data model. After all, why reinvent the wheel, right?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们创建了我们的数据模型，并重用了我们之前项目数据模型的部分。毕竟，为什么要重新发明轮子，对吧？
- en: Next up, we need to actually implement this data model. We'll tackle that in
    the next task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实际实现这个数据模型。我们将在下一个任务中处理这个问题。
- en: Implementing our data model
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的数据模型
- en: We'll be creating two files, namely, `PathRecDocumentCollection.js` and `PathRecDocument.js`
    to store our three data models. Since the first is so much like the last project's
    document manager, we'll skip over most of that code in the project and focus on
    the latter script.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个文件，即 `PathRecDocumentCollection.js` 和 `PathRecDocument.js`，以存储我们的三个数据模型。由于第一个与上一个项目的文档管理器非常相似，我们将跳过项目中的大部分代码，并专注于后面的脚本。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Go ahead and open up your editor and copy the `PathRecDocument.js` and `PathRecDocumentCollection.js`,
    files from the `www/models` directory to your project so that you can follow along
    with our discussion of the implementation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的编辑器，并将 `www/models` 目录中的 `PathRecDocument.js` 和 `PathRecDocumentCollection.js`
    文件复制到你的项目中，这样你就可以跟随我们关于实现的讨论。
- en: Getting on with it
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始吧
- en: 'Before we get started with the real meat, let''s take a quick look at some
    changes in our `PathRecDocumentCollection` model in the `PathRecDocumentCollection.js`
    file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始真正的重点之前，让我们快速看一下 `PathRecDocumentCollection.js` 文件中我们的 `PathRecDocumentCollection`
    模型的一些变化：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll notice that our `renameDocumentAtIndexTo` now has an additional few lines
    of code to ensure we don't overwrite a file that already exists. If there is a
    file with the same name, we dispatch an error to the `failure` method, and our
    document manager will happily prevent the user from doing anything dangerous.
    We've done the same thing to creating a document and copying a document.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们的 `renameDocumentAtIndexTo` 现在多了几行代码，以确保我们不会覆盖已经存在的文件。如果存在同名文件，我们会向 `failure`
    方法发送错误，我们的文档管理器会愉快地阻止用户进行任何危险的操作。我们对创建文档和复制文档也做了同样的事情。
- en: 'With that out of the way, let''s go to `PathRecDocumentItem` in `PathRecDocument.js`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们转到 `PathRecDocument.js` 中的 `PathRecDocumentItem`：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with our model, the preceding defines our properties.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的模型一样，前面的定义了我们的属性。
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `setPosition()` method will set the properties to the incoming position.
    If it is a geolocation position (it will have a `coords` object), we use those
    values, but if it is a serialized `PathRecDocumentItem`, we just use those values
    instead.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPosition()` 方法会将属性设置为传入的位置。如果是一个地理位置位置（它将有一个 `coords` 对象），我们使用这些值，但如果它是一个序列化的
    `PathRecDocumentItem`，我们则只使用这些值。'
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like in all good objects, we provide getters for all the properties. Since they
    are all so simple, we won't go over each one of them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有好的对象一样，我们为所有属性提供了获取器。由于它们都非常简单，我们不会逐一介绍每一个。
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous two methods are really convenience methods. One is to return the
    latitude and longitude in the form `lat, long`, and another to return a Google
    Maps `LatLng` object. This object is a critical object in the Google Maps API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法实际上是便利方法。一个是返回 `lat, long` 格式的经纬度，另一个是返回一个 Google Maps `LatLng` 对象。这个对象是
    Google Maps API 中的一个关键对象。
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is also a convenience method, but it returns a Google Maps `Marker` instead.
    This requires a Google Map to already be initialized, but otherwise it will set
    up a marker with the title of `Lat,` `Long` at the same position.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个便利的方法，但它返回一个Google Maps `Marker`。这需要一个已经初始化的Google地图，否则它将设置一个带有标题`Lat,`
    `Long`的标记，位置相同。
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to save the item to a file, it needs to be serialized. Since we don't
    need to serialize the methods, all we'll do is return an object with the location
    in it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将项目保存到文件中，它需要被序列化。由于我们不需要序列化方法，我们只需返回一个包含位置的物体对象。
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, at the end of the constructor, we'll set the position, if one was passed
    to us. If not, the object will have no position data set at all.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在构造函数的末尾，我们将设置位置，如果传给了我们。如果没有，对象将没有任何位置数据设置。
- en: Next, we'll look at the `PathRecDocument` object. A good majority of it is similar
    to the document object in the last project, so we'll omit those portions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`PathRecDocument`对象。其中大部分与上一个项目中的文档对象相似，所以我们将省略那些部分。
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The only real difference so far is that instead of storing text, we're storing
    an array of `PathRecDocumentItems`. These will be used to store the coordinates
    within the path.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一的真正区别是，我们不再存储文本，而是存储一个`PathRecDocumentItems`数组。这些将用于存储路径内的坐标。
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, these getters and setters are pretty typical. We can request the list
    of items (`getNodes`), and give the object a new list (`setNodes`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些获取器和设置器相当典型。我们可以请求项目列表（`getNodes`），并给对象一个新的列表（`setNodes`）。
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `addNode()` method will put a new `PathRecDocumentItem` into our node list.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`addNode()`方法会将一个新的`PathRecDocumentItem`放入我们的节点列表中。'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While we could use the `getNodes()` method to return the entire list, it can
    also be convenient to work with them individually; hence we work with `getNodeAtIndex`
    and `getNodeCount`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用`getNodes()`方法来返回整个列表，但逐个处理它们也很方便；因此，我们使用`getNodeAtIndex`和`getNodeCount`。
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most of the code leading up to the actually loading of our document has been
    omitted here. It's the same as the prior project, but here we start seeing some
    differences. First, if there's nothing in the file, we assume it to be a blank
    document, but we need to initialize our document with a default title and an empty
    list of nodes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到实际加载我们的文档之前的代码大部分在这里被省略了。它与前一个项目相同，但这里我们开始看到一些差异。首先，如果没有内容在文件中，我们假设它是一个空白文档，但我们需要用默认标题和空节点列表初始化我们的文档。
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, while the title is easy enough to set, we have to iterate through the
    list of nodes from the file and add them to the document. When we complete, our
    document will have all the saved nodes in the file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，虽然设置标题很容易，但我们必须遍历文件中的节点列表并将它们添加到文档中。当我们完成时，我们的文档将包含文件中保存的所有节点。
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Saving the file contents is actually the same as in the previous project, but
    what has changed in the previous code snippet is the `serialize()` method. First,
    we create an empty array and then iterate through our list of positions. We then
    serialize each one and add the serialized result to our array. This ensures that
    the array has only position data without method definitions. Then we return the
    title and the serialized positions, this is enough to save the document!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件内容实际上与上一个项目相同，但前一个代码片段中改变的是`serialize()`方法。首先，我们创建一个空数组，然后遍历我们的位置列表。然后我们序列化每一个，并将序列化的结果添加到我们的数组中。这确保了数组中只有位置数据而没有方法定义。然后我们返回标题和序列化的位置，这足以保存文档！
- en: What did we do?
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we created the data model for each geolocation position, the document
    that contains them, and then reused the document manager implementation from the
    previous project.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们为每个地理位置位置创建了数据模型，包含它们的文档，然后重新使用了上一个项目中的文档管理器实现。
- en: Changing our document manager
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变我们的文档管理器
- en: We've made a few minor changes to the way the document manager works. Nothing
    huge, but it does merit going over.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对文档管理器的工作方式做了一些小的改动。虽然不是什么大改动，但确实值得一看。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open up `www/views/documentsView.html` in an editor so that you can follow along
    with the discussion.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中打开`www/views/documentsView.html`，以便你可以跟随讨论。
- en: Getting on with it
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: The largest change is how we deal with tapping parts of the document list display
    based on the platform we're on. If you recall in the last project, Android didn't
    feel terribly at home because one had to tap the icon to open the document, but
    if they tapped the name, they would be prompted to rename the document. In our
    new manager, we've reversed it so that tapping the name will open the document,
    and tapping the icon will prompt for a rename operation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的变化是我们如何根据我们所在的平台处理文档列表显示部分的点击。如果您还记得上一个项目，Android 感觉并不那么舒适，因为必须点击图标才能打开文档，但如果他们点击了名称，就会提示重命名文档。在我们的新管理器中，我们已经将其反转，点击名称将打开文档，点击图标将提示重命名操作。
- en: 'The changes are shown in the following document template:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改在以下文档模板中显示：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The key differences have been highlighted. First, we've introduced a new `div`
    element called `documentTapArea` . This lives behind the entire document detail
    so that it can be a tap target for Android. It will fire off `documentContainerTapped()`
    so that we can respond to the event should it happen.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 已经突出显示了关键差异。首先，我们引入了一个名为 `documentTapArea` 的新 `div` 元素。它位于整个文档详情之后，以便它可以成为 Android
    的点击目标。它将触发 `documentContainerTapped()`，以便我们可以在事件发生时做出响应。
- en: 'The next difference is for the icon: we fire off `documentIconTapped()` instead
    of `openDocument`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个差异是对于图标：我们触发 `documentIconTapped()` 而不是 `openDocument`。
- en: 'The final difference is the title: we fire off `documentNameTapped()` instead
    of `renameDocument`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的区别是标题：我们触发 `documentNameTapped()` 而不是 `renameDocument`。
- en: 'These changes are easily picked out in the code, as seen in the following code
    snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改在代码中很容易被发现，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What we do in each of these methods is determine how to react based on the current
    platform. If we're an iOS device, the icon should open the document (it's the
    largest tap target), the tap target beneath the document should do nothing, and
    the title should prompt for a rename. On the other hand, all other devices should
    open a document if the name or tap target have been tapped, and only prompt for
    a rename if the icon has been tapped.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中，我们做的是根据当前平台确定如何反应。如果我们是 iOS 设备，图标应该打开文档（它是最大的点击目标），文档下的点击目标应该什么都不做，标题应该提示重命名。另一方面，所有其他设备如果点击了名称或点击目标，应该打开文档，只有当点击了图标时才提示重命名。
- en: What did we do?
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task we covered some of the subtle changes made to the document manager
    to help make it feel more at home on the Android platform.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们介绍了一些对文档管理器进行的微妙更改，以帮助它在 Android 平台上感觉更加舒适。
- en: Implementing our map view
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的地图视图
- en: In reality, the appearance of our map view will be fairly simple. Google Maps
    will take care of the interactive content (and scrolling it, thankfully), so our
    primary focus will be on the navigation bar and interacting with the Google Maps.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的地图视图的外观将会相当简单。Google 地图将负责交互内容（以及滚动，感谢上帝），因此我们的主要关注点将是导航栏和与 Google 地图的交互。
- en: 'When we''re done, we should have something that looks like the following on
    iOS:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们应该在 iOS 上看到以下内容：
- en: '![Implementing our map view](img/9403_04_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的地图视图](img/9403_04_05.jpg)'
- en: 'The view on an Android device should be as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设备上的视图应该是这样的：
- en: '![Implementing our map view](img/9403_04_06.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![实现我们的地图视图](img/9403_04_06.jpg)'
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be working from the `mapView.js` file in the `www/views` directory, so
    go ahead and open it so you can follow along.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `www/views` 目录下的 `mapView.js` 文件开始工作，所以请打开它，以便您可以跟上。
- en: Getting on with it
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: 'Let''s look at our HTML for the view first:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看视图的 HTML：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, our navigation bar has a few buttons in it. `trackButton` is intended
    to re-center the map on the user's location if the map has been moved. `actionButton`
    is essentially the *record* button, but we've named it *action* because it controls
    the state of recording, essentially *start* and *stop*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的导航栏中包含几个按钮。`trackButton` 的目的是在地图被移动后重新将地图中心定位到用户的位置。`actionButton` 实际上是
    *记录* 按钮，但我们将其命名为 *action*，因为它控制着记录的状态，本质上就是 *开始* 和 *停止*。
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only real difference between our other views and this one at this point
    in the code is the `div` element named `mapView_mapCanvas`; this will be used
    to hold our Google Map. We give it a `100%` width and height so that it fills
    the view.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的这个阶段，我们其他视图与这个视图之间唯一的真正区别是名为 `mapView_mapCanvas` 的 `div` 元素；这个元素将被用来包含我们的
    Google 地图。我们给它设置了 `100%` 的宽度和高度，以便它填充视图。
- en: 'And that''s all there is to the view. Now let''s look at the code behind it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是视图的全部内容。现在让我们看看背后的代码：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The initial properties should look familiar, they are like those in the previous
    project. But beyond those, we start with several properties that are going to
    be critically important to our view. Let''s go over them before proceeding:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 初始属性应该看起来很熟悉，它们与上一个项目中的属性类似。但除此之外，我们还有一些将对我们观点至关重要的属性。在继续之前，让我们来回顾一下：
- en: The `map` property will store the reference to the Google Map we'll eventually
    be creating.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 属性将存储我们将最终创建的 Google 地图的引用。'
- en: The `watchID` property will store the timer ID for the watch we'll create for
    geolocation. The idea is that PhoneGap will call an `update` function every time
    the position changes, and gives us this ID to cancel this update functionality
    when needed. While we're in the view, we can get as many position updates as needed,
    but when we leave the view, we should cancel the watch.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watchID` 属性将存储为我们创建的地理位置创建的计时器 ID。想法是 PhoneGap 将在位置每次变化时调用一个 `update` 函数，并给我们这个
    ID，以便在需要时取消此更新功能。当我们处于视图状态时，我们可以获取所需的所有位置更新，但当我们离开视图时，我们应该取消监视。'
- en: '`Polyline` is another Google Maps API object. It will store a series of positions
    in an array, much like our own `PathRecDocument.nodes` property, but it does so
    in a *Google* way. We will have to translate our position items into this object
    in order to display the path on a map.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Polyline` 是另一个 Google Maps API 对象。它将在一个数组中存储一系列位置，就像我们自己的 `PathRecDocument.nodes`
    属性一样，但它以 *Google* 的方式这样做。为了在地图上显示路径，我们必须将我们的位置项转换为这个对象。'
- en: The `currentPositionMarker` property will store a Google Maps `Marker` object.
    We'll use this marker to indicate the user's current position. You can get pretty
    fancy with the marker, including animating it and giving a custom image, but for
    now we'll use the defaults.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentPositionMarker` 属性将存储一个 Google Maps `Marker` 对象。我们将使用这个标记来指示用户的当前位置。你可以对标记做得很花哨，包括动画和自定义图像，但就目前而言，我们将使用默认设置。'
- en: The `keepMapCentered` property tracks whether or not we should, as the name
    implies, keep the map centered on the user's current position. If `true`, we'll
    pan the map's center to the current position at each update. But if `false`, we
    won't. We change this value whenever a *drag* is detected on the map. This means
    the user wants to explore the map around the current position, and if we didn't
    set this to `false`, the map would snap back to the current position every time
    the position changed, creating a disconcerting and painful experience.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keepMapCentered` 属性跟踪我们是否应该，正如其名所示，保持地图在用户的当前位置上。如果为真，我们将在每次更新时将地图中心平移到当前位置。但如果为假，则不会这样做。我们会在检测到地图上的
    *拖动* 时更改此值。这意味着用户想要探索当前位置周围的地图，如果我们不将其设置为 `false`，则每次位置变化时地图都会弹回到当前位置，从而产生令人不安和痛苦的经历。'
- en: The `lastKnownPosition` property will store our last known position. This will
    always be kept up-to-date so that we can pan to the last known position whenever
    `keepMapCentered` is set to `true` after having once been set to `false`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastKnownPosition` 属性将存储我们最后已知的位置。这将始终保持更新，以便我们可以在 `keepMapCentered` 设置为 `true`
    后，一旦设置为 `false`，就可以平移到最后已知的位置。'
- en: The `recordingPath` property indicates whether or not we are recording the current
    location. If true, we'll store position updates and add them to the document,
    but if false, we won't store any updates. The user can toggle this by tapping
    on `actionButton`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recordingPath` 属性指示我们是否正在记录当前位置。如果为真，我们将存储位置更新并将它们添加到文档中，但如果为假，则不会存储任何更新。用户可以通过点击
    `actionButton` 来切换此功能。'
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `initializeView()` method itself is similar to our other views, so we'll
    skip ahead to `actionButtonPressed()`. All this function will do is toggle whether
    or not we are recording (and update the button accordingly). It then sends our
    view a geolocation update with the last known position. This way recording starts
    immediately and at the current position rather than waiting until a new position
    is received.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeView()` 方法本身与我们的其他视图类似，所以我们将跳到 `actionButtonPressed()`。这个函数将只切换我们是否正在记录（并相应地更新按钮）。然后它将带有最后已知位置的地定位更新发送到我们的视图。这样，记录就会立即开始，而不是等待接收到新的位置。'
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the user pans the map, we will turn `keepMapCentered` to `false` so that
    the map doesn't keep springing back to the current position. This method will
    set it back to `true` and send a new update so that the map immediately moves
    to the current position (rather than waiting for a new update). This ensures that
    the map responds immediately, otherwise the user may not think anything happened.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户平移地图，我们将`keepMapCentered`设置为`false`，这样地图就不会总是弹回到当前位置。此方法将将其重新设置为`true`并发送新的更新，以便地图立即移动到当前位置（而不是等待新的更新）。这确保了地图能够立即响应，否则用户可能不会认为有任何事情发生。
- en: If we're recording, this does of course incur an additional position in our
    path, but it will be at a previously known position, so it won't display. One
    could add code to prevent adding nodes that are exactly like the previous node.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在记录，这当然会在我们的路径中增加一个额外的位置，但它将位于之前已知的位置，因此不会显示。可以添加代码以防止添加与上一个节点完全相同的节点。
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `geolocationUpdate()` method is called every time the user's position changes
    (or at a set frequency, if you wish). The first thing we do is create a new `LatLng`
    object with the coordinates so that we can update our marker. We also store the
    position into our `lastKnownPosition` property so that we can re-center the map
    at any point.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户的地理位置发生变化时（或者如果您愿意，以设定频率），就会调用`geolocationUpdate()`方法。我们首先创建一个新的`LatLng`对象，包含坐标，以便我们可以更新我们的标记。我们还把位置存储到我们的`lastKnownPosition`属性中，这样我们可以在任何时刻重新居中地图。
- en: If `keepMapCentered` is `true`, we call the `panTo()` method on the map, which
    will pan the map smoothly to the new position, if possible. If the new position
    is a long way out of the current view of the map, Google Maps will just snap to
    the new position without any animation. Thankfully, we don't have to actually
    track that on our own; we can be assured the map will be centered on the correct
    location.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`keepMapCentered`是`true`，我们在地图上调用`panTo()`方法，这将平滑地将地图平移到新位置，如果可能的话。如果新位置远离当前地图视图，谷歌地图将直接跳转到新位置而没有任何动画。幸运的是，我们不必自己跟踪这一点；我们可以确信地图将居中在正确的位置。
- en: We then update our marker with the correct location so that it is also up-to-date.
    If the user is playing with the map, this means they can always see the current
    location (if in view).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们更新我们的标记到正确的位置，以便它也是最新的。如果用户正在与地图互动，这意味着他们可以始终看到当前位置（如果处于视图中）。
- en: Finally, if we're recording, we call the `push()` method for the path in our
    polyline. This has the nice benefit of automatically updating the Google Maps
    view to include the change in our path. Then we add the node to our own document
    so that we can keep track of it as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们在记录，我们调用路径的`push()`方法。这有一个很好的好处，就是自动更新谷歌地图视图以包括路径的变化。然后我们将节点添加到我们的文档中，这样我们也可以跟踪它。
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The geolocation functionality also allows an error function. You could do many
    different things here as the error object will indicate with some granularity
    why the function is being called: a timeout (couldn''t retrieve the position in
    a certain period of time), the position itself is unavailable, or our request
    for the position was denied (which a user has the right to do). In our case, we
    just display the message in an alert.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 地理位置功能还允许一个错误函数。您在这里可以执行许多不同的事情，因为错误对象将以某种粒度指示函数被调用的原因：超时（在特定时间段内无法检索位置）、位置本身不可用，或者我们请求位置被拒绝（用户有权这样做）。在我们的情况下，我们只是在警告框中显示消息。
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Loading our document is pretty similar to the previous project except for what
    happens after the document is completely loaded into memory. In order to display
    our path on the Google Map, we have to push all the loaded positions into the
    polyline, which is created near the end of the method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 加载我们的文档与上一个项目非常相似，只是在文档完全加载到内存之后发生的事情不同。为了在谷歌地图上显示我们的路径，我们必须将所有加载的位置推送到多线中，这是在方法接近结束时创建的。
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When showing the view for the first time, we will create the Google Map. There''s
    no real reason to create it again later which is why we do this once. The map
    uses our `mapView_mapCanvas` element, which is set to fill the entire view. Notice
    that we pass several properties to the constructor:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次展示视图时，我们将创建谷歌地图。没有真正的原因要在之后再次创建它，这就是为什么我们只做一次。地图使用我们的`mapView_mapCanvas`元素，该元素被设置为填充整个视图。请注意，我们向构造函数传递了几个属性：
- en: '`disableDefaultUI` when `true` will turn off all the UI elements on the Google
    Map. This means buttons such as switching between satellite and road map types
    will be gone, as well as street view, panning, and zooming. Interactions with
    the map still work, but getting the controls out of the way is a good idea in
    this case, since some of them will cause the app to open a new browser (such as
    street view).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`disableDefaultUI`为`true`时，将关闭谷歌地图上的所有UI元素。这意味着像在卫星图和道路图类型之间切换的按钮将消失，以及街景、平移和缩放。与地图的交互仍然有效，但在这个情况下，移除控制元素是个好主意，因为其中一些会导致应用打开新的浏览器（如街景）。
- en: '`center` is where the map should be initially centered. The latitude and longitude
    mean nothing in particular. It will be reset when the we get our first geolocation
    update.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`表示地图应该最初居中的位置。纬度和经度没有特别的意义。当我们获得第一次地理定位更新时，它将被重置。'
- en: '`zoom` indicates how far the map should be zoomed. A level of 15 permits users
    to see their current street, so it is a pretty good level to start at. The user,
    of course, can change their zoom later to anything they want.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoom`表示地图应该缩放多远。15级允许用户看到他们当前的街道，所以这是一个很好的起始级别。当然，用户可以稍后更改他们的缩放级别，以满足他们的需求。'
- en: '`mapTypeId` indicates the type of map, in this case, the road map type.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapTypeId`表示地图的类型，在这种情况下，是道路图类型。'
- en: Once we create a map, we also add a listener to it that is fired whenever the
    user pans the map on their own. If they do, we set `keepMapCentered` to `false`
    so that future updates won't re-center the map.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个地图，我们也会为它添加一个监听器，当用户自己平移地图时，这个监听器会被触发。如果他们这样做，我们将`keepMapCentered`设置为`false`，这样未来的更新就不会重新居中地图。
- en: After that, we initialize our current position marker. We have to tell the marker
    which map it will be displayed on (the one we just created), and also the title
    of the marker. The title doesn't appear by default, so we've picked something
    nice and generic.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们初始化我们的当前位置标记。我们必须告诉标记它将显示在哪个地图上（我们刚刚创建的那个），以及标记的标题。标题默认不显示，所以我们选择了一些既漂亮又通用的东西。
- en: Near the end of the method, we create a watch for the user's position using
    `navigator.geolocation.watchPosition()` . The first parameter indicates the `success`
    method to call, the second the `failure` method, and the third indicates the various
    options. All we are requesting in this option list is that the GPS return a highly
    accurate position. This can take several seconds to acquire, especially if the
    GPS hasn't been used in a while, so the user will see the position update as the
    GPS narrows things down. This is why we don't start recording immediately upon
    displaying the view; otherwise, we'd have to implement some sort of tolerance
    method to figure out when the position was accurate enough. In our case, the user
    will only start recording once they are satisfied with the current position on
    the screen, so they do our work for us.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法接近结束时，我们使用`navigator.geolocation.watchPosition()`创建一个对用户位置的监视。第一个参数指示要调用的`success`方法，第二个参数指示`failure`方法，第三个参数表示各种选项。在这个选项列表中，我们只请求GPS返回一个高度精确的位置。这可能需要几秒钟才能获得，尤其是如果GPS一段时间内没有使用过，所以用户会看到位置更新随着GPS缩小范围。这就是为什么我们不立即开始记录显示视图；否则，我们就必须实现某种容差方法来确定位置何时足够准确。在我们的情况下，用户只有在他们对屏幕上的当前位置满意后才会开始记录，这样他们就在为我们工作了。
- en: At the end of the method, we kick off loading our document so that the view
    will be populated as quickly as possible.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法结束时，我们启动加载我们的文档，以便尽可能快地填充视图。
- en: Oh, and if you're asking why we are using `viewWillAppear` and `viewDidAppear`
    , it's because the Google Map doesn't like to be created while the view is in
    the process of being animated in. Therefore, we let the animation occur, and then
    load the map when everything has settled down.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，如果你在问我们为什么使用`viewWillAppear`和`viewDidAppear`，那是因为谷歌地图不喜欢在视图正在动画过程中被创建。因此，我们让动画发生，然后在一切平静下来后加载地图。
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the view is about to be dismissed, we clear the watch on the user's position.
    After all, there's little to no reason to continue receiving updates when the
    view isn't the current view on the stack. We also turn recording off (just in
    case the user didn't stop the recording before dismissing the view), and turn
    map centering back on. We then tell the polyline that it shouldn't be visible
    on the map anymore and destroy it. If we didn't do this, it would be all too easy
    for previous paths to show up on the map from previously loaded documents.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图即将被关闭时，我们清除用户位置的监视。毕竟，当视图不是堆栈中的当前视图时，继续接收更新几乎没有理由。我们还关闭了录制（以防用户在关闭视图之前没有停止录制），并将地图居中功能重新打开。然后我们告诉折线它不再应该在地图上可见，并销毁它。如果我们不这样做，以前加载的文档中的先前路径很容易就会显示在地图上。
- en: What did we do?
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we created an interactive Google Map that displays a recorded
    path as well as the user's current position. We dealt with polylines (which actually
    display the path on the map) as well as markers. We also handled recording the
    path and centering the map.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们创建了一个交互式谷歌地图，显示记录的路径以及用户的当前位置。我们处理了折线（实际上在地图上显示路径）以及标记。我们还处理了记录路径和地图居中。
- en: What else do I need to know?
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: 'Here''s the sad truth as our application currently stands: when the phone is
    locked or the app is in the background, no updates occur. This is expected behavior
    as the phone has no real way to know that we want to continue receiving updates.
    There are platform-specific methods that you can use to register your app to continue
    working during a lock or backgrounding, but we''ll let you go into those yourself.
    For now, the app only receives updates when the screen is on and the app is in
    the foreground.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们当前应用的悲惨现实：当手机锁定或应用处于后台时，不会发生更新。这是预期行为，因为手机没有真正的方式知道我们想要继续接收更新。你可以使用特定于平台的方法来注册你的应用，以便在锁定或后台运行时继续工作，但我们会让你自己深入了解这些内容。目前，应用只有在屏幕开启且应用处于前台时才会接收更新。
- en: Game Over..... Wrapping it up
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束..... 结束一切
- en: In this project we achieved quite a bit. We created an interactive Google Map
    that the user can pan and zoom. We created markers and polylines that displayed
    on the map as well. We also created a way to record a path and then later display
    it. We also created the document model capable of storing the positional information
    so that it could be saved and loaded. Finally, we also made some minor changes
    to the document manager to make it a little more friendly to Android devices.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们取得了相当大的成就。我们创建了一个用户可以平移和缩放的交互式谷歌地图。我们还创建了在地图上显示的标记和折线。我们还创建了一种记录路径并在以后显示的方法。我们还创建了一个文档模型，可以存储位置信息，以便可以保存和加载。最后，我们还对文档管理器进行了一些小的修改，使其对Android设备更加友好。
- en: 'Some resources you might find useful:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你可能觉得有用的资源：
- en: Google Maps API (3.9) at [https://developers.google.com/maps/documentation/javascript/3.9/reference](https://developers.google.com/maps/documentation/javascript/3.9/reference)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Maps API (3.9) at [https://developers.google.com/maps/documentation/javascript/3.9/reference](https://developers.google.com/maps/documentation/javascript/3.9/reference)
- en: KML at [https://developers.google.com/kml/documentation/](https://developers.google.com/kml/documentation/)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KML at [https://developers.google.com/kml/documentation/](https://developers.google.com/kml/documentation/)
- en: Can you take the HEAT? The HotshotChallenge
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受压力吗？热手挑战
- en: We've done quite a bit in this project, but there's always room for improvement
    and extension. Why don't you see if you can complete some of these challenges?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们已经做了很多，但总有改进和扩展的空间。你为什么不看看自己能否完成一些这些挑战？
- en: Add the ability to share a path with a friend. This could include an image of
    the path, the file, or some creative representation. Or, you could get into the
    *native* side of things and look at how to tell the phone that your app can open
    certain kinds of files.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加与朋友分享路径的功能。这可能包括路径的图片、文件或一些创意表示。或者，你可以深入了解*原生*部分，看看如何告诉手机你的应用可以打开某些类型的文件。
- en: Add the ability to export a path to KML. This is a standard interchange format
    for geolocation data.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加导出路径到KML的功能。这是地理定位数据的标准交换格式。
- en: Add displays of the additional data we're capturing. We only show a path using
    latitude and longitude, but we're capturing heading, speed, and altitude as well.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加显示我们正在捕获的附加数据。我们只显示使用纬度和经度的路径，但我们还捕获航向、速度和高度。
- en: Add the ability to edit the path once recorded, including moving, removing,
    and adding points.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加在记录路径后编辑路径的能力，包括移动、删除和添加点。
- en: Come up with a way to reduce the amount of data recorded. We track every point
    as the user's position changes, but this is often not necessary. If someone is
    driving in a straight line, it would make the most sense to discard the intervening
    points (as well as save memory).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想出一个减少记录数据量的方法。我们跟踪用户位置变化时的每一个点，但这种情况通常并不必要。如果某人正在直线驾驶，那么丢弃中间的点（以及节省内存）将是最合理的选择。
- en: This may involve some native coding, but look into and implement what is required
    to allow the app to capture geolocation data even while in the background and/or
    the device is locked. (This would save battery life, since the display wouldn't
    need to be visible.)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能需要一些本地编码，但调查并实现所需的功能，以便即使在后台运行或设备锁定时，应用程序也能捕获地理位置数据。（这将节省电池寿命，因为不需要显示可见。）
