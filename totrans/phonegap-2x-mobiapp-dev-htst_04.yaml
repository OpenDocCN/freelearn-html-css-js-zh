- en: Chapter 4. Let's Take a Trip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geolocation has become very important in today's world, especially since most
    phones have the capability to determine your position to an astonishing degree
    of accuracy. Given that this used to (not so long ago) be the mainstay of expensive
    GPS gadgets, it is amazing how quickly this ability has become ubiquitous. Because
    of this, users expect location-aware applications, and not just that, but they
    expect a nice map that responds to their input right along with it.
  prefs: []
  type: TYPE_NORMAL
- en: What do we build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our project is aimed at two concepts, the first being to simply use a (very)
    small portion of the Google Maps API (as of this writing, 3.9). We will use this
    API to display a fully functional map that is centered on the user's current location.
    Secondly, we will use the geolocation features that PhoneGap provides in order
    to obtain the user's current location. When we're done, we'll have an app that
    can not only display a map centered around the user's current location, but we'll
    also have an app that can record their movements and show them on-screen. Instead
    of a voice recorder, think of it as a location recorder.
  prefs: []
  type: TYPE_NORMAL
- en: What does it do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We introduced document management in the last project, and we'll further shore
    up those capabilities in this project. Thankfully, most of the work is done for
    us, but as you recall, there were a few situations where the user could get into
    trouble (if they used a name that collided with an existing file). We'll take
    care of that in this project so that we have a much more robust solution.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be going over the various methods that we can use to load in the
    Google Maps APIs, something that turns out to be a little more difficult than
    one would initially think, and this is complicated by the fact that we have to
    deal with the possibility of losing (or not having) network access. We won't use
    the entire Google Maps API, it deserves a book all its own, but we will use some
    basic features, including markers and lines.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll be using geolocation. Some browsers are kind enough to provide
    a good implementation of geolocation, and since PhoneGap's implementation follows
    the W3C standard, it will use the browser solution if it is good enough. This
    also means that what we're building could even be made to work outside of PhoneGap
    if one switched to using `localStorage` instead of persistent files.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''ve put it all together, we''ll have a pretty interesting app. An app
    that records our location (while we let it) and that can then display it. This
    opens up all sorts of possibilities for extension: you could share a path with
    a friend, you could export to KML for ingestion by other applications, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it great?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Geolocation and interactive maps are something users expect in today's apps.
    If you display an address, you should at least be able to display a map to go
    along with it. If you offer searches by location, you should be able to locate
    where the user is and provide them with relevant results. Geolocation and interactive
    maps aren't just for turn-by-turn location or helping someone who's become lost;
    they are invaluable in a lot of other applications as well.
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to do it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many ways, this task is easier than those that have preceded it. For one,
    our framework has become pretty stable (though there are some changes for this
    project), and we have a good start on document management. What's really left
    is creating the data model that is capable of storing location information and
    saving and retrieving it. This is also our first app where we'll dispense with
    the start view – we'll jump straight into the app from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accomplish this, we''ll use the same familiar steps we''ve used
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing our UI and the look and feel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing our data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing our data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing our document manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing our map view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do I need to get started?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, go ahead and create your project. Be sure to follow the same project
    steps as in previous projects, though you don't need to worry about plugin support;
    we don't need any native plugins for this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, take a look at the Google Maps API ([https://developers.google.com/maps/documentation/javascript/3.9/reference](https://developers.google.com/maps/documentation/javascript/3.9/reference)).
    While there, you might want to sign up for an API key as well. Although you can
    use the API without one (and we do here), having a key allows for usage metrics,
    and should your app become popular enough, the ability to pay for your use so
    that you aren''t restricted to the low API caps enforced for non-key users. Be
    sure to take a look at their documentation as well; there''s a lot of it there,
    enough to fill several chapters alone, but it is well worth perusing. Put it this
    way: there are things Google Maps does that I never knew it could do, and you
    might discover the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing our UI and the look and feel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, let's not start coding until we have a good idea about how we want
    our app to look. Thankfully, we really only have to focus on the map view. We've
    already covered the look and feel of our document manager in the previous project,
    and it's not changed much here. Furthermore, since a good portion of the view
    will actually be taken up by the interactive map provided by Google, there's not
    even a lot we have to do there.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, get your pencil and paper out or your favorite graphics editor;
    we'll be using them to design our wireframe and then build out any of the assets
    we might need later on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot gives a final mockup of our map view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At first glance, this appears like a pretty simple view—and it is—but don't
    let that fool you. There's a lot of power underneath!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over the various items:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Back** button will take the user back to the document management interface.
    For Android, of course, this button will not be present; the device's physical
    back button will do the trick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title on the navigation bar will be the title of the document. The user
    can tap on it to change the document via a prompt alert from our framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button with the *globe* is intended to be the *find me* button. The view
    will automatically do this when shown, but one of the hallmarks of an interactive
    map is that you should be able to explore it on your own without constantly being
    dragged back to your current position. This button is intended to re-center your
    map after you've done some exploration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button with the *red dot* is the *record* button. When tapped the view will
    begin to record your position (as often as it changes) and draw a line following
    your progress. If tapped again, it will stop tracking your location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the navigation bar is the Google Map (here, an *X* image). This will,
    of course, be populated from Google. Moving the map with your finger will, of
    course, pan the map, but more importantly, we will catch this event so that we
    can *unlock* the map from your current location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The downward pointing arrow is a representation of the typical *Google Marker*;
    this will indicate your current position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line is a representation of some path already recorded; it will indicate
    every update in your path during the recording.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've defined how everything should work together, let's go into our
    graphics program and create the graphical assets we'll need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documents view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The map view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generally, we've used the same assets as for our previous project, though our
    document image has changed to a map. We'll also need to use the images on our
    buttons, one for the standard find me icon, and two for the various states of
    the record button—a circle (for record) and a pause icon (not shown). These icons
    are from App-Bits' free icon set available at [http://app-bits.com/free-icons.html](http://app-bits.com/free-icons.html).
    You might want to go ahead and download that set as well, if you haven't already.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task we've covered how the user interface will be designed and how the
    various pieces of it will work. We skipped discussing the document manager since
    it is virtually identical to the prior project, the only thing that has changed
    is the image we're using and the file extension.
  prefs: []
  type: TYPE_NORMAL
- en: Designing our data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this task, we will work on designing our data models. We'll focus on our
    document and the items that go in it; the document manager model remains unchanged
    from the previous project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look up the documentation for geolocation, you'll notice that the position
    information contains quite a bit of information including latitude, longitude,
    altitude, heading, and speed. Most implementations also return the accuracy of
    the location and altitude, but we'll be ignoring that for now. Since our map will
    show the current location, we will assume that the user won't start recording
    until the current location is correct, and so waiting for the accuracy to settle
    down is less important. If we were going to begin recording instantly, we would
    need to wait for the accuracy to narrow to an acceptable limit, and this is where
    those values become useful.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and get out your paper and pencil, and we'll start working on our data
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our data model will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Technically, we have three models: the two shown in the preceding screenshot
    and the `PathRecDocumentCollection` model, which is identical to the document
    manager model we saw in the last project. Since it is identical, we''ll skip that
    and focus on the two models shown in the preceding screenshot. Let''s start with
    `PathRecDocumentItem` :'
  prefs: []
  type: TYPE_NORMAL
- en: '`timestamp`, `latitude`, `longitude`, `altitude`, `heading`, and `speed` are
    all properties our item needs to store. We''ll collect these at object creation
    time and store them via `setPosition()` so that our item will be immediately populated.
    Unlike the `position` object used for geolocation, we won''t store the coordinates
    in a `coords` object, but we will have to deal with that later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setPosition()` takes either a geolocation position (with a `coords` object)
    or a serialized `PathRecDocumentItem` object (without a `coords` object). It will
    update the properties appropriately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get…()` property will return the requested property value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getLatLong()` property returns the latitude and longitude in the form `lat,
    long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getGoogleLatLng()` property returns a Google Maps `LatLng` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getGoogleMarker()` property returns a Google Maps `Marker` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `serialize()` property returns an object ready for storing in a JSON document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep in mind that the preceding model only stores a single geolocation position;
    to string a bunch of them together requires the next model, `PathRecDocument`,
    which includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fileEntry`, `filename`, `completion`, `failure`, and `state` are all the same
    as the document in our last project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `title` property stores the title of the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodes` is an array of the earlier-listed items; this is how we''ll store a
    series of geolocation positions. Put them all together in a line, and we''ll have
    the path that a user took during a recording.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get`/`setTitle()` methods returns and sets the title of the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get`/`setNodes()` methods will return and set the nodes; these take arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addNode()` method will push a node onto the list of notes; this must be
    a `PathRecDocumentItem`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getNodeAtIndex()` method will return a node at the given index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getNodeCount()` method will return how many nodes are in the path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining methods are the same as the document model in the previous project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `serialize()` method will return an object suitable for storing in a file.
    Unlike in the previous project, this time `serialize()` must iterate through each
    node, calling its `serialize()` method to build up an array of nodes without all
    the extra methods in `PathRecDocumentItem`. (After all, there's no reason to store
    these.) The result will be an object with a title property, and a nodes array
    with only the position information contained within; everything else will be stripped
    out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we created our data model, and reused portions of our previous
    project's data model. After all, why reinvent the wheel, right?
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we need to actually implement this data model. We'll tackle that in
    the next task.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be creating two files, namely, `PathRecDocumentCollection.js` and `PathRecDocument.js`
    to store our three data models. Since the first is so much like the last project's
    document manager, we'll skip over most of that code in the project and focus on
    the latter script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and open up your editor and copy the `PathRecDocument.js` and `PathRecDocumentCollection.js`,
    files from the `www/models` directory to your project so that you can follow along
    with our discussion of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get started with the real meat, let''s take a quick look at some
    changes in our `PathRecDocumentCollection` model in the `PathRecDocumentCollection.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that our `renameDocumentAtIndexTo` now has an additional few lines
    of code to ensure we don't overwrite a file that already exists. If there is a
    file with the same name, we dispatch an error to the `failure` method, and our
    document manager will happily prevent the user from doing anything dangerous.
    We've done the same thing to creating a document and copying a document.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, let''s go to `PathRecDocumentItem` in `PathRecDocument.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As with our model, the preceding defines our properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `setPosition()` method will set the properties to the incoming position.
    If it is a geolocation position (it will have a `coords` object), we use those
    values, but if it is a serialized `PathRecDocumentItem`, we just use those values
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like in all good objects, we provide getters for all the properties. Since they
    are all so simple, we won't go over each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous two methods are really convenience methods. One is to return the
    latitude and longitude in the form `lat, long`, and another to return a Google
    Maps `LatLng` object. This object is a critical object in the Google Maps API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is also a convenience method, but it returns a Google Maps `Marker` instead.
    This requires a Google Map to already be initialized, but otherwise it will set
    up a marker with the title of `Lat,` `Long` at the same position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In order to save the item to a file, it needs to be serialized. Since we don't
    need to serialize the methods, all we'll do is return an object with the location
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, at the end of the constructor, we'll set the position, if one was passed
    to us. If not, the object will have no position data set at all.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at the `PathRecDocument` object. A good majority of it is similar
    to the document object in the last project, so we'll omit those portions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The only real difference so far is that instead of storing text, we're storing
    an array of `PathRecDocumentItems`. These will be used to store the coordinates
    within the path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So far, these getters and setters are pretty typical. We can request the list
    of items (`getNodes`), and give the object a new list (`setNodes`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `addNode()` method will put a new `PathRecDocumentItem` into our node list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While we could use the `getNodes()` method to return the entire list, it can
    also be convenient to work with them individually; hence we work with `getNodeAtIndex`
    and `getNodeCount`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code leading up to the actually loading of our document has been
    omitted here. It's the same as the prior project, but here we start seeing some
    differences. First, if there's nothing in the file, we assume it to be a blank
    document, but we need to initialize our document with a default title and an empty
    list of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, while the title is easy enough to set, we have to iterate through the
    list of nodes from the file and add them to the document. When we complete, our
    document will have all the saved nodes in the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Saving the file contents is actually the same as in the previous project, but
    what has changed in the previous code snippet is the `serialize()` method. First,
    we create an empty array and then iterate through our list of positions. We then
    serialize each one and add the serialized result to our array. This ensures that
    the array has only position data without method definitions. Then we return the
    title and the serialized positions, this is enough to save the document!
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we created the data model for each geolocation position, the document
    that contains them, and then reused the document manager implementation from the
    previous project.
  prefs: []
  type: TYPE_NORMAL
- en: Changing our document manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've made a few minor changes to the way the document manager works. Nothing
    huge, but it does merit going over.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up `www/views/documentsView.html` in an editor so that you can follow along
    with the discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The largest change is how we deal with tapping parts of the document list display
    based on the platform we're on. If you recall in the last project, Android didn't
    feel terribly at home because one had to tap the icon to open the document, but
    if they tapped the name, they would be prompted to rename the document. In our
    new manager, we've reversed it so that tapping the name will open the document,
    and tapping the icon will prompt for a rename operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes are shown in the following document template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The key differences have been highlighted. First, we've introduced a new `div`
    element called `documentTapArea` . This lives behind the entire document detail
    so that it can be a tap target for Android. It will fire off `documentContainerTapped()`
    so that we can respond to the event should it happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next difference is for the icon: we fire off `documentIconTapped()` instead
    of `openDocument`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final difference is the title: we fire off `documentNameTapped()` instead
    of `renameDocument`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These changes are easily picked out in the code, as seen in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What we do in each of these methods is determine how to react based on the current
    platform. If we're an iOS device, the icon should open the document (it's the
    largest tap target), the tap target beneath the document should do nothing, and
    the title should prompt for a rename. On the other hand, all other devices should
    open a document if the name or tap target have been tapped, and only prompt for
    a rename if the icon has been tapped.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task we covered some of the subtle changes made to the document manager
    to help make it feel more at home on the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our map view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In reality, the appearance of our map view will be fairly simple. Google Maps
    will take care of the interactive content (and scrolling it, thankfully), so our
    primary focus will be on the navigation bar and interacting with the Google Maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re done, we should have something that looks like the following on
    iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing our map view](img/9403_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The view on an Android device should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing our map view](img/9403_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be working from the `mapView.js` file in the `www/views` directory, so
    go ahead and open it so you can follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at our HTML for the view first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, our navigation bar has a few buttons in it. `trackButton` is intended
    to re-center the map on the user's location if the map has been moved. `actionButton`
    is essentially the *record* button, but we've named it *action* because it controls
    the state of recording, essentially *start* and *stop*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The only real difference between our other views and this one at this point
    in the code is the `div` element named `mapView_mapCanvas`; this will be used
    to hold our Google Map. We give it a `100%` width and height so that it fills
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s all there is to the view. Now let''s look at the code behind it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial properties should look familiar, they are like those in the previous
    project. But beyond those, we start with several properties that are going to
    be critically important to our view. Let''s go over them before proceeding:'
  prefs: []
  type: TYPE_NORMAL
- en: The `map` property will store the reference to the Google Map we'll eventually
    be creating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `watchID` property will store the timer ID for the watch we'll create for
    geolocation. The idea is that PhoneGap will call an `update` function every time
    the position changes, and gives us this ID to cancel this update functionality
    when needed. While we're in the view, we can get as many position updates as needed,
    but when we leave the view, we should cancel the watch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Polyline` is another Google Maps API object. It will store a series of positions
    in an array, much like our own `PathRecDocument.nodes` property, but it does so
    in a *Google* way. We will have to translate our position items into this object
    in order to display the path on a map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `currentPositionMarker` property will store a Google Maps `Marker` object.
    We'll use this marker to indicate the user's current position. You can get pretty
    fancy with the marker, including animating it and giving a custom image, but for
    now we'll use the defaults.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `keepMapCentered` property tracks whether or not we should, as the name
    implies, keep the map centered on the user's current position. If `true`, we'll
    pan the map's center to the current position at each update. But if `false`, we
    won't. We change this value whenever a *drag* is detected on the map. This means
    the user wants to explore the map around the current position, and if we didn't
    set this to `false`, the map would snap back to the current position every time
    the position changed, creating a disconcerting and painful experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lastKnownPosition` property will store our last known position. This will
    always be kept up-to-date so that we can pan to the last known position whenever
    `keepMapCentered` is set to `true` after having once been set to `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `recordingPath` property indicates whether or not we are recording the current
    location. If true, we'll store position updates and add them to the document,
    but if false, we won't store any updates. The user can toggle this by tapping
    on `actionButton`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `initializeView()` method itself is similar to our other views, so we'll
    skip ahead to `actionButtonPressed()`. All this function will do is toggle whether
    or not we are recording (and update the button accordingly). It then sends our
    view a geolocation update with the last known position. This way recording starts
    immediately and at the current position rather than waiting until a new position
    is received.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the user pans the map, we will turn `keepMapCentered` to `false` so that
    the map doesn't keep springing back to the current position. This method will
    set it back to `true` and send a new update so that the map immediately moves
    to the current position (rather than waiting for a new update). This ensures that
    the map responds immediately, otherwise the user may not think anything happened.
  prefs: []
  type: TYPE_NORMAL
- en: If we're recording, this does of course incur an additional position in our
    path, but it will be at a previously known position, so it won't display. One
    could add code to prevent adding nodes that are exactly like the previous node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `geolocationUpdate()` method is called every time the user's position changes
    (or at a set frequency, if you wish). The first thing we do is create a new `LatLng`
    object with the coordinates so that we can update our marker. We also store the
    position into our `lastKnownPosition` property so that we can re-center the map
    at any point.
  prefs: []
  type: TYPE_NORMAL
- en: If `keepMapCentered` is `true`, we call the `panTo()` method on the map, which
    will pan the map smoothly to the new position, if possible. If the new position
    is a long way out of the current view of the map, Google Maps will just snap to
    the new position without any animation. Thankfully, we don't have to actually
    track that on our own; we can be assured the map will be centered on the correct
    location.
  prefs: []
  type: TYPE_NORMAL
- en: We then update our marker with the correct location so that it is also up-to-date.
    If the user is playing with the map, this means they can always see the current
    location (if in view).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we're recording, we call the `push()` method for the path in our
    polyline. This has the nice benefit of automatically updating the Google Maps
    view to include the change in our path. Then we add the node to our own document
    so that we can keep track of it as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The geolocation functionality also allows an error function. You could do many
    different things here as the error object will indicate with some granularity
    why the function is being called: a timeout (couldn''t retrieve the position in
    a certain period of time), the position itself is unavailable, or our request
    for the position was denied (which a user has the right to do). In our case, we
    just display the message in an alert.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Loading our document is pretty similar to the previous project except for what
    happens after the document is completely loaded into memory. In order to display
    our path on the Google Map, we have to push all the loaded positions into the
    polyline, which is created near the end of the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When showing the view for the first time, we will create the Google Map. There''s
    no real reason to create it again later which is why we do this once. The map
    uses our `mapView_mapCanvas` element, which is set to fill the entire view. Notice
    that we pass several properties to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`disableDefaultUI` when `true` will turn off all the UI elements on the Google
    Map. This means buttons such as switching between satellite and road map types
    will be gone, as well as street view, panning, and zooming. Interactions with
    the map still work, but getting the controls out of the way is a good idea in
    this case, since some of them will cause the app to open a new browser (such as
    street view).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center` is where the map should be initially centered. The latitude and longitude
    mean nothing in particular. It will be reset when the we get our first geolocation
    update.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zoom` indicates how far the map should be zoomed. A level of 15 permits users
    to see their current street, so it is a pretty good level to start at. The user,
    of course, can change their zoom later to anything they want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapTypeId` indicates the type of map, in this case, the road map type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we create a map, we also add a listener to it that is fired whenever the
    user pans the map on their own. If they do, we set `keepMapCentered` to `false`
    so that future updates won't re-center the map.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we initialize our current position marker. We have to tell the marker
    which map it will be displayed on (the one we just created), and also the title
    of the marker. The title doesn't appear by default, so we've picked something
    nice and generic.
  prefs: []
  type: TYPE_NORMAL
- en: Near the end of the method, we create a watch for the user's position using
    `navigator.geolocation.watchPosition()` . The first parameter indicates the `success`
    method to call, the second the `failure` method, and the third indicates the various
    options. All we are requesting in this option list is that the GPS return a highly
    accurate position. This can take several seconds to acquire, especially if the
    GPS hasn't been used in a while, so the user will see the position update as the
    GPS narrows things down. This is why we don't start recording immediately upon
    displaying the view; otherwise, we'd have to implement some sort of tolerance
    method to figure out when the position was accurate enough. In our case, the user
    will only start recording once they are satisfied with the current position on
    the screen, so they do our work for us.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the method, we kick off loading our document so that the view
    will be populated as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and if you're asking why we are using `viewWillAppear` and `viewDidAppear`
    , it's because the Google Map doesn't like to be created while the view is in
    the process of being animated in. Therefore, we let the animation occur, and then
    load the map when everything has settled down.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the view is about to be dismissed, we clear the watch on the user's position.
    After all, there's little to no reason to continue receiving updates when the
    view isn't the current view on the stack. We also turn recording off (just in
    case the user didn't stop the recording before dismissing the view), and turn
    map centering back on. We then tell the polyline that it shouldn't be visible
    on the map anymore and destroy it. If we didn't do this, it would be all too easy
    for previous paths to show up on the map from previously loaded documents.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we created an interactive Google Map that displays a recorded
    path as well as the user's current position. We dealt with polylines (which actually
    display the path on the map) as well as markers. We also handled recording the
    path and centering the map.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the sad truth as our application currently stands: when the phone is
    locked or the app is in the background, no updates occur. This is expected behavior
    as the phone has no real way to know that we want to continue receiving updates.
    There are platform-specific methods that you can use to register your app to continue
    working during a lock or backgrounding, but we''ll let you go into those yourself.
    For now, the app only receives updates when the screen is on and the app is in
    the foreground.'
  prefs: []
  type: TYPE_NORMAL
- en: Game Over..... Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project we achieved quite a bit. We created an interactive Google Map
    that the user can pan and zoom. We created markers and polylines that displayed
    on the map as well. We also created a way to record a path and then later display
    it. We also created the document model capable of storing the positional information
    so that it could be saved and loaded. Finally, we also made some minor changes
    to the document manager to make it a little more friendly to Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some resources you might find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Maps API (3.9) at [https://developers.google.com/maps/documentation/javascript/3.9/reference](https://developers.google.com/maps/documentation/javascript/3.9/reference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KML at [https://developers.google.com/kml/documentation/](https://developers.google.com/kml/documentation/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you take the HEAT? The HotshotChallenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've done quite a bit in this project, but there's always room for improvement
    and extension. Why don't you see if you can complete some of these challenges?
  prefs: []
  type: TYPE_NORMAL
- en: Add the ability to share a path with a friend. This could include an image of
    the path, the file, or some creative representation. Or, you could get into the
    *native* side of things and look at how to tell the phone that your app can open
    certain kinds of files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the ability to export a path to KML. This is a standard interchange format
    for geolocation data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add displays of the additional data we're capturing. We only show a path using
    latitude and longitude, but we're capturing heading, speed, and altitude as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the ability to edit the path once recorded, including moving, removing,
    and adding points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Come up with a way to reduce the amount of data recorded. We track every point
    as the user's position changes, but this is often not necessary. If someone is
    driving in a straight line, it would make the most sense to discard the intervening
    points (as well as save memory).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may involve some native coding, but look into and implement what is required
    to allow the app to capture geolocation data even while in the background and/or
    the device is locked. (This would save battery life, since the display wouldn't
    need to be visible.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
