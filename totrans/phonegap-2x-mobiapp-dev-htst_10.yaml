- en: Chapter 10. Scaling Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。扩展
- en: So far we've really only covered how to create apps for smaller devices such
    as phones. But there are a lot of other mobile devices that aren't phone-shaped,
    namely tablets (and the so called phablets, which are often 7 inches instead of
    10). Though there aren't as many users who have tablets as phones, it is still
    an incredibly important market.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们真正覆盖的只是如何为小设备如手机创建应用程序。但还有很多其他非手机形状的移动设备，即平板电脑（以及所谓的“大屏手机”，通常为7英寸而不是10英寸）。尽管拥有平板电脑的用户不如手机用户多，但这仍然是一个极其重要的市场。
- en: Sometimes it is possible to simply display the same user interface on a larger
    device. This is often seen in games, where the graphics and control areas are
    often just scaled to the device's screen size. Other times it is possible to largely
    use the same user interface, but small tweaks are required in order to make it
    function well on an a larger screen. And there are other times when there is simply
    no choice; the user interface must be re-thought entirely for the larger screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在更大的设备上简单地显示相同用户界面是可能的。这在游戏中很常见，图形和控制区域通常只是按设备屏幕大小进行缩放。有时，可以大量使用相同的用户界面，但需要对它进行一些小的调整，以便在更大的屏幕上良好运行。还有其他时候，别无选择；用户界面必须完全重新设计以适应更大的屏幕。
- en: What do we build?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么？
- en: In this project, we'll revisit an app that we created in [Project 3](ch03.html
    "Chapter 3. Being Productive"), *Being Productive*. The app isn't terribly complex,
    but it is flexible enough to support various ways of scaling up, which is what
    we'll do. We're going to create several different versions of Filer, each with
    different concepts of scaling to a tablet-sized screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将回顾我们在[项目3](ch03.html "第3章。提高生产力")中创建的应用程序。该应用程序并不特别复杂，但它足够灵活，可以支持各种扩展方式，这正是我们将要做的。我们将创建几个不同的Filer版本，每个版本都有不同的扩展到平板电脑屏幕大小的概念。
- en: What does it do?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它能做什么？
- en: One of the main problems with developing for a larger screen when one has been
    solely developing for a small screen is "What to do with all that space?" When
    one is constrained to developing for a 320 x 80 or 600 x 800 dimension, it can
    be a sudden shock to realize that one has a lot more pixels to fill. Often, these
    larger displays are sized at 1024 x 768, 1280 x 768, 1280 x 800, or higher. In
    fact, the iPad 3 has a display that's technically 2048 x 1536, which when you
    think about it, is pretty astounding. Thankfully, the iPad 3 scales that back
    to 1024 x 768 for us.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个人只针对小屏幕开发时，开发大屏幕的一个主要问题是“如何处理所有这些空间？”当一个人被限制在开发320 x 80或600 x 800的维度时，突然意识到自己有更多的像素要填充可能会感到震惊。通常，这些更大的显示器尺寸为1024
    x 768、1280 x 768、1280 x 800或更高。实际上，iPad 3的显示屏在技术上为2048 x 1536，当你这么想的时候，这相当令人惊讶。幸运的是，iPad
    3将其缩放回1024 x 768为我们。
- en: What we'll do in this project is rethink the user interface for Filer to account
    for the larger real estate. We won't focus so much on the actual functionality—we've
    done that work in [Project 3](ch03.html "Chapter 3. Being Productive"), *Being
    Productive*, but we will deal with how to handle larger screens.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将重新思考Filer的用户界面，以适应更大的显示区域。我们不会过多关注实际的功能性——我们已经在[项目3](ch03.html "第3章。提高生产力")中完成了这项工作，*提高生产力*，但我们将处理如何处理更大的屏幕。
- en: 'We''ll focus on two typical scenarios: **scale-it-up**, where we simply scale
    the interface to fit the new screen size, and **split view** (otherwise referred
    to as **master-detail**), where we will add a sidebar to the interface (something
    you see quite often on the iPad, for example, the **Settings** app).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注两种典型场景：**放大**，其中我们只是将界面放大以适应新的屏幕大小，以及**分割视图**（也称为**主详情**），其中我们将向界面添加侧边栏（例如，在iPad上你经常会看到，例如**设置**应用程序）。
- en: Why is it great?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它为什么这么好？
- en: Sometimes an app just screams for more space—and note-taking apps aren't any
    exception. A bigger screen means that there is a larger on-screen keyboard, and
    a bigger screen means that there is more space for important content—such as text.
    At other times, we can transition an app to the larger screen by using split-view
    layouts that allow us to efficiently flatten the app's hierarchy. We'll explore
    all these options with our three versions of Filer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序只是需要更多的空间——记事应用程序也不例外。更大的屏幕意味着更大的屏幕键盘，更大的屏幕意味着有更多空间用于重要内容——例如文本。在其他时候，我们可以通过使用分割视图布局来将应用程序过渡到更大的屏幕，这些布局允许我们有效地简化应用程序的层次结构。我们将通过Filer的三个版本来探索所有这些选项。
- en: How are we going to do it?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何做到这一点？
- en: 'We''ll approach the three designs as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式处理这三个设计：
- en: Designing the scaled-up UI
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计扩展的用户界面
- en: Implementing the scaled-up UI
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现扩展的用户界面
- en: Designing the split-view UI
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计分割视图用户界面
- en: Implementing the split-view UI
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分割视图用户界面
- en: What do I need to get started?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要准备些什么才能开始？
- en: For this particular task, we'll be working with the files for this project,
    so if you want to follow along, go ahead and download them. There are two directories
    named `1` and `2`, which are versions of the app in this project. The first is
    what we'll focus on next, while the second is what we'll work on later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的任务，我们将使用这个项目的文件，所以如果你想跟上，请下载它们。有两个名为`1`和`2`的目录，这是本项目中的应用版本。第一个是我们接下来要关注的，而第二个是我们稍后要工作的。
- en: Designing the scaled-up UI
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计扩展的用户界面
- en: A lot of apps can simply "scale up" to fit the larger screen, and our framework,
    thankfully, does a lot of the "scaling" part for us. While this works well for
    games, we do need to do a bit more work to make Filer fit the big screen well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用可以简单地“扩展”以适应更大的屏幕，幸运的是，我们的框架为我们做了很多“扩展”的工作。虽然这对游戏来说效果很好，但我们确实需要做更多的工作来使Filer更好地适应大屏幕。
- en: Getting on with it
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: 'If you remember the Filer app from [Project 3](ch03.html "Chapter 3. Being
    Productive"), *Being Productive*, there were three views: a **start view**, a
    **documents view**, and the **document view**. We''ll be scrapping the first view—there''d
    be nothing to do with it to make it work on a larger screen anyway. Instead, we''ll
    focus on the last two views—and, in all honesty, for this task, we''re only really
    going to make a lot of the changes to the first of them.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[项目3](ch03.html "第3章。提高生产力")中的Filer应用，那么在“提高生产力”中，有三个视图：一个**起始视图**、一个**文档视图**和一个**文档视图**。我们将放弃第一个视图——无论如何，在大屏幕上也没有什么可以做的来使其工作。相反，我们将专注于最后两个视图——坦白说，在这个任务中，我们主要将对第一个视图进行大量更改。
- en: 'Let''s take a look at the screenshot from the documents view for the Filer
    app from [Project 3](ch03.html "Chapter 3. Being Productive"), *Being Productive*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看[项目3](ch03.html "第3章。提高生产力")中“提高生产力”的Filer应用的文档视图截图：
- en: '![Getting on with it](img/9403_10_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动](img/9403_10_02.jpg)'
- en: 'For our tablet-sized app, we''ll display this list of documents horizontally
    and vertically, rather than just horizontally. On an iPad, this will show about
    three icons across when in portrait orientation and four icons across when in
    landscape. This means our mockup looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的平板电脑尺寸的应用，我们将水平垂直地显示这个文档列表，而不仅仅是水平显示。在iPad上，纵向时大约显示三个图标，横向时显示四个图标。这意味着我们的原型看起来是这样的：
- en: '![Getting on with it](img/9403_10_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动](img/9403_10_01.jpg)'
- en: For the purposes of this project, we'll keep the **Create** button on the navigation
    bar, but there is a challenge at the end of the project to turn this into a larger
    feature within the document list. For example, some apps might have a blank document
    image with a "plus" icon in it to symbolize creating a new document. Others might
    use a dashed rectangle to indicate the same thing. For the larger display, something
    like this is definitely appropriate; while on a small screen, it'd be seen as
    a waste of space.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的目的下，我们将保留导航栏上的**创建**按钮，但在项目结束时，我们将将其转变为文档列表中的一个更大功能。例如，一些应用可能有一个带有“+”图标的空白文档图像来表示创建新文档。其他应用可能使用虚线矩形来表示相同的意思。对于更大的显示，这样的设计无疑是合适的；而在小屏幕上，这会被视为空间的浪费。
- en: Beyond making this change to the document list, that's really all we're going
    to be doing to the app. The rest of it will work as is on the larger screen, thanks
    to the fact that our framework is designed to fill the screen.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对文档列表进行这个更改外，我们还将对这个应用进行其他一些更改。由于我们的框架设计为填充屏幕，其余部分在大屏幕上将按原样工作。
- en: What did we do?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task we went over the app from [Project 3](ch03.html "Chapter 3. Being
    Productive"), *Being Productive*, and created a new mockup for the user interface
    for the larger screen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们回顾了[项目3](ch03.html "第3章。提高生产力")中的应用“提高生产力”，并为更大屏幕的用户界面创建了一个新的原型。
- en: What else do I need to know?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: Scaling up an iPhone app is pretty easy *if* you've already planned for the
    future of scaling it up. That is, if you've planned everything down to the pixel
    and built for a 320 x 480 screen, you're going to have to change all those pixels
    around on a larger screen. When dealing with simple productivity apps such as
    Filer, building a layout that can scale to a larger screen isn't terribly difficult,
    but get into more complex layouts and graphics, and it starts to become a challenge.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展iPhone应用相对简单，*只要*你已经为未来的扩展做好了规划。也就是说，如果你已经将所有事情规划到像素级别，并为320 x 480的屏幕构建了应用，那么你将不得不在更大的屏幕上更改所有这些像素。当处理像Filer这样的简单生产力应用时，构建可以扩展到更大屏幕的布局并不特别困难，但一旦涉及到更复杂的布局和图形，这就会变成一个挑战。
- en: In some ways, highly graphical games have it both the hardest and the easiest.
    A game is probably going to keep the same user interface when scaling to a new
    screen—with perhaps a few minor tweaks to button placement or size. The graphics,
    however, are going to be the same, visually. Underneath the hood, though, those
    graphics may be rendered at vastly different resolutions. A certain graphic might
    work fine on a small screen, but get that up to a larger screen, and it will either
    seem too large or too small. To avoid forcing the browser to scale *everything*
    (which always slows things down and results in some blurriness), it is better
    to re-render the graphics for the target screen, because you never know what kind
    of screens will be out in the future. It is, for this reason, always better to
    create your graphics in a vector format—this way you can always create a new rendition
    when a new size is needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，高度图形化的游戏既是最难也是最简单的。当扩展到新屏幕时，游戏可能保持相同的用户界面——可能只是对按钮位置或大小进行一些小的调整。然而，图形在视觉上将是相同的。然而，在底层，这些图形可能在不同的分辨率下渲染。某个图形可能在小型屏幕上运行良好，但放大到更大的屏幕上，它可能会显得太大或太小。为了避免强制浏览器缩放*所有*内容（这总是会减慢速度并导致一些模糊），最好是针对目标屏幕重新渲染图形，因为你永远不知道未来会有什么样的屏幕。因此，始终以矢量格式创建你的图形会更好——这样你就可以在需要新尺寸时始终创建新的版本。
- en: One of the hardest things to deal with properly are full-screen images. These
    might be in-game backgrounds, menu backgrounds, splashes, and so on, and you want
    them to look as nice as possible. In our sample game ([Project 8](ch08.html "Chapter 8. Playing
    Around"), *Playing Around*), we didn't focus on this a great deal, but if you
    had a device that had a substantially different aspect ratio than I had, you probably
    noticed some letter-boxing when the full-screen assets were shown. This is one
    way to approach it without having to do a lot of work—the other would be to scale
    and crop the image, potentially blurring it a bit, and losing portions of the
    image. The only other realistic option is to create an image specifically for
    each supported resolution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最难妥善处理的是全屏图像。这些可能是游戏背景、菜单背景、启动画面等等，你希望它们看起来尽可能好。在我们的示例游戏([项目8](ch08.html "第8章。玩转"),
    *玩转*)中，我们没有过多关注这一点，但如果你有一个与我设备屏幕宽高比差异很大的设备，你可能会注意到当全屏资源显示时出现了一些黑边。这是不进行大量工作的方法之一——另一种方法是缩放并裁剪图像，可能会稍微模糊一些，并丢失图像的部分。唯一其他现实的选择是为每个支持的分辨率创建一个特定的图像。
- en: For the best visual appearance, you should always render your images at the
    device's native resolution. For a Retina iPad, this would be 2048 x 1536 for a
    full-screen image. This, of course, is different for just about every Android
    device, and there's no terribly easy way to deal with it. You can replace the
    graphics via JavaScript based on the size of the screen, or you can use media
    queries to target specific graphic elements. You should note that though the framework
    we use does make a distinction between phone-sized devices and tablet-sized devices
    as well as non-retina and retina displays, it does nothing about all the different
    resolutions available on Android. Your best option would be to use CSS media queries
    (for more information, see [https://developer.mozilla.org/en-US/docs/CSS/Media_queries](https://developer.mozilla.org/en-US/docs/CSS/Media_queries)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最佳的视觉效果，你应该始终以设备的原生分辨率渲染你的图片。对于一个Retina iPad，全屏图片的分辨率将是2048 x 1536。当然，对于几乎每一款Android设备来说，这都不同，而且处理起来并没有特别简单的方法。你可以根据屏幕大小通过JavaScript替换图形，或者你可以使用媒体查询来针对特定的图形元素。你应该注意，尽管我们使用的框架确实在手机尺寸设备、平板尺寸设备以及非Retina和Retina显示之间做出了区分，但它对Android上所有不同的分辨率并没有做什么。你最好的选择是使用CSS媒体查询（更多信息，请参阅[https://developer.mozilla.org/en-US/docs/CSS/Media_queries](https://developer.mozilla.org/en-US/docs/CSS/Media_queries))。
- en: In other ways, non-game apps can be terribly painful to scale up. You might
    be dealing with, for example, a lot of content that is formatted in a reasonably
    complex manner. It looks great given one screen size, but on another, things may
    break in odd places, especially when just scaling it. Sometimes the fact that
    we're working in HTML and CSS will save us—it's meant for dealing with complicated
    layout, but just as many times as not, it'll cause the look and feel to go awry
    in a way that you hadn't envisioned.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，非游戏应用在扩展时可能会非常痛苦。你可能正在处理大量格式化得相当复杂的内 容。在某个屏幕尺寸下看起来很棒，但在另一个屏幕上，东西可能会在奇怪的地方破裂，尤其是在仅仅缩放它的时候。有时我们使用HTML和CSS工作的事实会拯救我们——它旨在处理复杂的布局，但同样多的时间，它会导致外观和感觉以一种你没有预想到的方式出错。
- en: This is when creating code and layout *specifically* for the tablet-size screen
    may be necessary. You can do things in your JavaScript, HTML, and CSS code to
    handle these sizes—you could put a `DIV` tag classed with `tablet` in your HTML,
    and have a CSS rule that hides it on anything but a tablet. Likewise, you could
    hide the phone UI elements if you're trying to create a universal app that can
    run on both phone-sized screens and tablet-sized screens. Or, if you're positioning
    certain things with JavaScript, you can always look at the type of device you're
    running on to get a good idea about what to do—and worst case, look at the width
    or height of the screen. Again, using media queries can often help when dealing
    with multiple resolutions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，可能需要为平板尺寸屏幕创建特定的代码和布局。你可以在你的JavaScript、HTML和CSS代码中处理这些尺寸——你可以在HTML中放置一个带有`tablet`类的`DIV`标签，并有一个CSS规则在除了平板电脑之外隐藏它。同样，如果你试图创建一个可以在手机尺寸屏幕和平板尺寸屏幕上运行的全能应用，你可以隐藏手机UI元素。或者，如果你正在使用JavaScript定位某些东西，你总是可以查看你正在运行的设备类型，以获得关于要做什么的好主意——最坏的情况是查看屏幕的宽度和高度。再次强调，使用媒体查询在处理多个分辨率时通常很有帮助。
- en: Implementing the scaled-up UI
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现放大后的用户界面
- en: Now that we've designed the UI for Filer HD mark I, it's time to implement it.
    The number of changes that we've made to our code are astoundingly small, so get
    ready to keep your eyes open—blink, and you might miss it!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为Filer HD mark I设计了用户界面，是时候实现它了。我们对代码所做的更改数量惊人地少，所以准备好保持警觉——眨眼之间，你可能会错过它！
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Although we''re focusing primarily on the iOS platform for this app, the concepts
    apply equally to any platform-based tablet. With that said, to render an iOS app
    specific to the iPad, there are a couple of settings that need to be set in the
    project itself, outside of code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们主要关注iOS平台上的这个应用，但这些概念同样适用于任何基于平台的平板电脑。话虽如此，为了渲染针对iPad的iOS应用，需要在项目本身中设置一些设置，而不仅仅是代码之外：
- en: In the project's settings in Xcode, change the **Devices** setting to **iPad**
    from **Universal**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode的项目设置中，将**设备**设置从**通用**更改为**iPad**。
- en: 'You should see the project setting like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下所示的项目设置：
- en: '![Getting ready](img/9403_10_08.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/9403_10_08.jpg)'
- en: Aside from this change (and setting our typical settings for the project in
    `Cordova.plist` for iOS), we'll copy the files from [Project 3](ch03.html "Chapter 3. Being
    Productive"), *Being Productive*. If you want to follow along, navigate to `/1/www`
    in the code files of this project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个更改（以及为iOS项目在`Cordova.plist`中设置我们的典型设置）之外，我们将从[项目3](ch03.html "第3章。提高生产力")，*提高生产力*中复制文件。如果你想跟上来，请导航到本项目代码文件中的`/1/www`。
- en: Getting on with it
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: There's really surprisingly little that we have to do to make the app fit to
    the larger screen. As we've said before, our framework does do a good portion
    of the work—it always attempts to ensure that the content fills the screen, and
    our HTML in our views helps too—where possible, we want to use percentages not
    pixels. (This is not to say that using pixels is not good; for example, we use
    them liberally when dealing with button placement on the navigation bar.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们为了使应用适应更大的屏幕所需要做的非常少。正如我们之前所说的，我们的框架确实做了很多工作——它总是试图确保内容填满屏幕，我们视图中的HTML也有帮助——尽可能，我们想使用百分比而不是像素。（这并不是说使用像素不好；例如，我们在处理导航栏上的按钮位置时，会大量使用它们。）
- en: 'Just as a reminder, here''s the documents view''s HTML:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就此提醒一下，这是文档视图的HTML：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Nothing here has to change, really. Next up, here''s some of our styling:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里实际上没有什么需要更改的。接下来，这是我们的部分样式：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far, no change for the iPad devices. We did strip out the code that turned
    this into a list for Android devices, and so all tablet devices will get nice,
    big document icons.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对于iPad设备没有变化。我们移除了将此转换为Android设备的列表的代码，因此所有平板设备都将获得漂亮的大文档图标。
- en: 'The one place where we made some change was in the actual code, so let''s take
    a look there:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了一些更改的地方实际上是在实际代码中，所以让我们看看那里：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See the comment about deleted code?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 看到关于已删除代码的注释了吗？
- en: That's right—we *deleted* something! If you remember, on the iPhone we wanted
    the document listing to scroll *horizontally*, so there was some code that set
    the width of the document list's container to *the number of items multiplied
    by the width*. This would make `DIV` larger, and it therefore allowed the content
    to scroll horizontally. For this app, we want the width to be of one-screen width,
    and then we want the browser to *wrap* our documents just like words on a page.
    So the next document to the right of the screen actually goes below the left-most
    document and starts a new row.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 没错——我们*删除*了一些东西！如果你记得，在iPhone上，我们希望文档列表可以*水平滚动*，所以有一些代码设置了文档列表容器的宽度为*项目数量乘以宽度*。这将使`DIV`变大，因此允许内容水平滚动。对于这个应用，我们希望宽度为单屏宽度，然后我们希望浏览器*换行*我们的文档，就像页面上的一行字。所以屏幕右侧的下一个文档实际上是在最左侧文档下方开始的新一行。
- en: Guess what—that's *it*. Our buttons didn't need to change position, and the
    text editor in our document view is already coded to fill the entire screen, so
    we didn't need to do anything there. The only thing we *had* to take out was code
    that was written specifically for a phone-sized device.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看——那就是*全部*。我们的按钮不需要改变位置，我们文档视图中的文本编辑器已经编码为填满整个屏幕，所以我们那里不需要做任何事情。唯一我们需要移除的是专门为手机尺寸设备编写的代码。
- en: '![Getting on with it](img/9403_10_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_10_03.jpg)'
- en: So what does it look like now?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那现在看起来是什么样子？
- en: '![Getting on with it](img/9403_10_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_10_04.jpg)'
- en: What did we do?
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task we converted what was a phone app into a tablet app.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将一个手机应用转换成了平板应用。
- en: What else do I need to know?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: We accomplished this by actually removing code that was constraining the app
    to that of a phone, but not all apps will be so simple to scale. Sometimes you
    may need to reposition buttons, content, and various elements in order to fit
    better on the larger screen. If you want the app to remain universal (that is,
    it will work on both a phone-sized device and a tablet-sized device), your work
    becomes harder, because you have to keep both layouts around. Thankfully, CSS,
    HTML, and JavaScript come to the rescue and help us out by letting us target certain
    classes and IDs or media queries with CSS and writing JavaScript code specific
    to a particular layout. In our case, we could have kept the phone-sized specific
    code by checking for the size of the device—the framework happily takes care of
    the rest of the sizing itself to the different sizes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实际上删除限制应用程序为手机版本的代码来实现这一点，但并非所有应用程序都可以如此简单地进行扩展。有时你可能需要重新定位按钮、内容和各种元素以更好地适应更大的屏幕。如果你想使应用程序保持通用性（即，它将在手机尺寸的设备和平板尺寸的设备上运行），你的工作将变得更加困难，因为你必须保留两种布局。幸运的是，CSS、HTML和JavaScript来拯救我们，通过让我们使用CSS针对特定的类和ID或媒体查询，以及编写针对特定布局的JavaScript代码来帮助我们。在我们的情况下，我们可以通过检查设备的尺寸来保留手机尺寸的特定代码——框架愉快地处理了其余的尺寸问题。
- en: Sometimes you can get by with the way your framework handles the different viewport
    sizes, but there are often times when this falls flat—the UI is either too sparse
    on a large screen or too crammed on a small screen. If this occurs, it would be
    better to build your UI specifically for each device size rather than relying
    on the framework to get things right—because sometimes it doesn't.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可以通过框架处理不同视口尺寸的方式应付过去，但往往会有时候这种方法不起作用——UI在大型屏幕上可能太稀疏，在小型屏幕上可能太拥挤。如果发生这种情况，最好是针对每个设备尺寸专门构建你的UI，而不是依赖框架来正确处理事情——因为有时候它并不正确。
- en: Designing the split-view UI
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计分割视图用户界面
- en: The split-view layout is by far one of the most popular methods for scaling
    your app to the tablet. It also has the side benefit of flattening the application's
    information hierarchy, which is just the technical way of saying that it takes
    less "taps" to get somewhere in the app.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 分割视图布局是将应用程序扩展到平板电脑的最受欢迎的方法之一。它还有附带的好处，即简化应用程序的信息层次结构，这仅仅是技术上的说法，意味着在应用程序中到达某个地方所需的“点击”次数更少。
- en: Most tablet platforms implement this view in similar ways—in landscape mode
    it's always there on the left (but sometimes on the right), and in portrait mode
    it's usually hidden offscreen, ready and waiting for when the user taps a button
    to call it out. Other times the view is always visible in portrait mode, but this
    depends on the type of app and whether or not the loss of screen space is worth
    having the split view always visible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数平板电脑平台以类似的方式实现这种视图——在横屏模式下它始终位于左侧（但有时位于右侧），而在竖屏模式下通常隐藏在屏幕之外，准备并等待用户点击按钮将其调出。有时在竖屏模式下视图始终可见，但这取决于应用程序的类型以及屏幕空间损失是否值得始终显示分割视图。
- en: Getting on with it
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: The split view is really just two views put together. That's the easy way to
    think about it—one view is on the left in a smaller sidebar while the second view
    is on the right. The left view is technically called the **master view**, while
    the right view is called the **detail view**. Technically, this pattern is the
    **master-detail** pattern, and it is most obvious when working with data records
    where the record selection occurs in the master view (on the left), and the detail
    of the record shows in the detail view (on the right).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 分割视图实际上只是将两个视图组合在一起。这样思考起来很简单——一个视图位于左侧的较小侧边栏中，而第二个视图位于右侧。左侧视图在技术上被称为**主视图**，而右侧视图被称为**详细视图**。在技术上，这种模式被称为**主-详细**模式，当与数据记录一起工作时最为明显，记录选择发生在主视图（左侧），而记录的详细信息显示在详细视图中（右侧）。
- en: In our app, we're going to make the documents list the master view so that the
    document itself can be the focus of the user. This means that a specific document
    will become the detail. In this arrangement, however, we need to switch from the
    pretty grid listing of documents in the previous version of the app and go back
    to a simple list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将使文档列表成为主视图，以便文档本身可以成为用户的焦点。这意味着一个特定的文档将成为详细内容。然而，在这种安排中，我们需要从上一个版本应用程序中文档的精美网格列表切换回简单的列表。
- en: 'Here''s what our design looks like now:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看我们的设计是什么样的：
- en: '![Getting on with it](img/9403_10_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_10_05.jpg)'
- en: The only thing not quite "true" in this sketch is the **Create** button on the
    top. In reality there's going to be a title next to it as well, just that there
    wasn't enough space in the mockup to put it there. So it won't look as out-of-place
    as it does in the previous screenshot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个草图里唯一不太“真实”的是顶部的**创建**按钮。实际上，旁边还将有一个标题，只是由于原型设计中的空间不足，无法将其放置在那里。所以它看起来不会像上一个截图那样显得突兀。
- en: What isn't obvious is what happens when the device rotates to portrait orientation.
    The sidebar will actually disappear—leaving only the text document visible. We'll
    have a button on the left titled **Documents** that will bring the sidebar back,
    and once the sidebar is displayed, a **Close** button that will dismiss it. In
    a challenge at the end of this project, you'll be asked to implement gestures
    to open and close the sidebar.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不明显的是，当设备旋转到纵向模式时会发生什么。侧边栏实际上会消失——只留下文本文档可见。我们将在左侧有一个名为**文档**的按钮，点击它将恢复侧边栏，一旦侧边栏显示，将有一个**关闭**按钮可以关闭它。在项目末尾的挑战中，你将被要求实现手势来打开和关闭侧边栏。
- en: What did we do?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we designed the user interface for a split-view layout.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们为分割视图布局设计了用户界面。
- en: What else do I need to know?
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: It really depends on your app if the master view needs to go away when oriented
    in portrait. Some apps can spare the loss of screen-width, other apps can't. When
    dealing with content (such as graphics, text, and so on.), it's probably a good
    idea to get rid of it when in portrait mode. If you're dealing with settings,
    properties, or the like, then you can keep it there with little impact on usability.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上取决于你的应用，当应用处于纵向模式时，主视图是否需要消失。有些应用可以容忍屏幕宽度的损失，而有些应用则不能。当处理内容（如图形、文本等）时，在纵向模式下移除它可能是个好主意。如果你处理的是设置、属性或类似的内容，那么你可以保留它，对可用性的影响很小。
- en: Implementing the split-view UI
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现分割视图UI
- en: Now it's time to implement the changes necessary to make our app a split-view
    app. From this point forward, we'll be working in `/2/www` if you want to follow
    along. We started from the code in the last task and then modified it to suit
    the new user interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现使我们的应用成为分割视图应用所需的更改。从这一点开始，如果你想跟上，我们将工作在`/2/www`。我们从上一个任务中的代码开始，然后修改它以适应新的用户界面。
- en: Getting on with it
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: Unlike the last time, we're going to be making several modifications. Not a
    *lot* of code, mind you, but we'll be touching several different files and making
    tweaks to support the change. The documents view gets only a few minor modifications,
    though we will change the display to a list instead of a grid, and the file view
    gets several modifications. For one, it has to handle what to do when there is
    no document loaded (which will happen at the beginning of the app). Second, it
    has to change the way it handles autosaving content (since there is no longer
    any dismissal of the view).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与上次不同，我们将进行几次修改。请注意，这并不是很多代码，但我们将触及几个不同的文件，并对它们进行微调以支持更改。文档视图只进行了一些小的修改，尽管我们将显示从网格改为列表，文件视图则进行了几个修改。首先，它必须处理没有加载文档的情况（这将在应用开始时发生）。其次，它必须改变处理自动保存内容的方式（因为不再有视图的关闭操作）。
- en: 'But first, we need to get the layout set up to show two views side-by-side.
    We''ll start in `index.html`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要设置布局以显示两个视图并排。我们将从`index.html`开始：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we've added two elements to the `rootContainer` element. The first
    is `leftSplitContainer` and the second is `rightSplitContainer`. The position
    of these elements should be apparent from the `ID` values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已经向`rootContainer`元素添加了两个元素。第一个是`leftSplitContainer`，第二个是`rightSplitContainer`。这些元素的定位应该从它们的`ID`值中明显看出。
- en: 'This alone isn''t going to get us there, though. We need to style these appropriately—and
    for this, we''ve made a change in the framework''s base CSS. Look at `2/www/framework/base.css`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此还不够，我们还需要适当地对这些内容进行样式设计——为此，我们在框架的基本CSS中做了一些更改。查看`2/www/framework/base.css`：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What we've done is indicated that while the device is in landscape orientation,
    the two splits should be side-by-side. The left-hand will be 319 pixels wide,
    and the right-hand view will start at pixel 320\. Whatever's left on the screen
    will determine the width of the right-hand view. *The size of this sidebar is
    not set in stone*—if your app needs a smaller sidebar, go ahead and aim lower—likewise,
    if it needs a larger one, set it larger. It is best, however, to not exceed half
    the width of the screen. If you feel the need, it is time to decide if you've
    got your views on the correct side.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是表明，当设备处于横屏方向时，两个分割应该并排显示。左侧将宽319像素，右侧视图将从像素320开始。屏幕上剩余的部分将决定右侧视图的宽度。*这个侧边栏的大小并不是一成不变的*——如果你的应用需要更小的侧边栏，可以适当减小尺寸——同样，如果需要更大的，可以设置得更大。然而，最好不要超过屏幕宽度的一半。如果你觉得有必要，现在是时候决定你的视图是否在正确的位置了。
- en: In portrait mode, we *hide* the sidebar. That said, this sidebar can appear
    again when the user wants, so we also make sure that it is indexed above all of
    the other content. We also give it a shadow so that there is a visual distinction
    for the user between the sidebar and the content underneath.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在竖屏模式下，我们*隐藏*侧边栏。尽管如此，当用户想要时，这个侧边栏可以再次出现，所以我们还确保它被索引在其他所有内容之上。我们还给它添加了一个阴影，以便用户在侧边栏和下面的内容之间有一个视觉上的区分。
- en: 'Changing the styles alone, however, isn''t enough. Let''s take a look at what
    we''ve changed in `app.js`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅改变样式是不够的。让我们看看我们在`app.js`中做了什么改变：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, our loading code has changed a little. Note that instead of attaching
    to `rootContainer`, we attach to `leftSplitContainer` and `rightSplitContainer`.
    This first step is critical to ensuring that each view's content ends up in the
    right place on the screen. Note also that we show *each* view. This is new too—previously
    we would only have shown one view, but since we are combining two views on the
    screen, we need them both to be visible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的加载代码有所变化。注意，我们不再连接到`rootContainer`，而是连接到`leftSplitContainer`和`rightSplitContainer`。这一步至关重要，确保每个视图的内容最终显示在屏幕的正确位置。还要注意，我们显示*每个*视图。这也是新的——之前我们只会显示一个视图，但既然我们在屏幕上组合了两个视图，我们需要它们两个都可见。
- en: There's one last new feature at the bottom of the previous code—a new event
    listener. We'll cover the following code, but essentially we ask the browser to
    notify us of any change in orientation. While the CSS and HTML go a long way to
    making sure our layout is correct when the orientation changes, they don't get
    us *all* the way, and so we need some code to figure out the rest.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的底部有一个最后的新特性——一个新的事件监听器。我们将覆盖以下代码，但基本上我们要求浏览器通知我们任何方向的变化。虽然CSS和HTML在很大程度上确保了方向变化时布局的正确性，但它们并不能做到全部，因此我们需要一些代码来找出其余的部分。
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is called by both the documents and file views, and its sole purpose
    is to toggle the appearance of the sidebar. If it is visible, this function will
    hide it, and vice versa.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被文档视图和文件视图同时调用，它的唯一目的是切换侧边栏的显示。如果侧边栏是可见的，这个函数将隐藏它，反之亦然。
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code gets called at every change in orientation. If we change to portrait,
    we'll hide the sidebar, and if we change to landscape, we show it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在每次方向变化时都会被调用。如果我们改变为竖屏，我们将隐藏侧边栏，如果改变为横屏，我们将显示它。
- en: 'Next, we need to make some minor changes to the documents view:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对文档视图做一些小的修改：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The main difference is that we've added a **Close** button to the view—this
    button will allow the user to dismiss the sidebar when they've previously elected
    to display it in portrait mode. We'll add some styles later on to prevent it from
    being visible while in landscape mode. We also changed the click handlers for
    certain areas, since this is now a list instead of a grid.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的不同之处在于我们在视图中添加了一个**关闭**按钮——这个按钮将允许用户在之前选择在竖屏模式下显示它时关闭侧边栏。我们稍后会添加一些样式来防止它在横屏模式下可见。我们还更改了某些区域的点击处理程序，因为现在这是一个列表而不是网格。
- en: 'To support the new button, we have added some code to `documentsView.initializeView`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持新的按钮，我们在`documentsView.initializeView`中添加了一些代码：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All this does is call `APP.toggleSidebar` whenever the **Close** button is tapped.
    Since the sidebar will be visible when we call this function, this means it will
    dismiss the sidebar by hiding it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是会在点击**关闭**按钮时调用`APP.toggleSidebar`。由于调用这个函数时侧边栏是可见的，这意味着它将通过隐藏它来关闭侧边栏。
- en: The only other change? We removed calls to `PKUI.CORE.pushView`. These would
    normally have pushed the file view on the stack, but since it's already visible,
    we don't need to push anything. So we just remove those lines.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的其他更改？我们移除了对 `PKUI.CORE.pushView` 的调用。这些调用通常会将文件视图推入堆栈，但由于它已经可见，我们不需要推入任何内容。所以我们只是移除了那些行。
- en: 'We did make changes to the styling, however (in `style.css`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实对样式进行了更改（在 `style.css` 中）：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code will make each document item a nice little list item with
    the icon on the left, the title on the right, and the action icons below. You
    could take what you've learned from previous projects and add gesture support
    as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将使每个文档项成为一个带有图标在左侧、标题在右侧以及操作图标在下面的漂亮的小列表项。你可以从以前的项目中学到的东西，并添加手势支持。
- en: 'The file view itself gets quite a bit of change:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 文件视图本身发生了相当大的变化：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing different is that we've added a documents button on the navigation
    bar in place of the **Back** button. This button will show the sidebar when in
    portrait mode. When in landscape, we'll have a special style that makes this button
    go away.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不同之处在于，我们在导航栏上添加了一个文档按钮，取代了**返回**按钮。当处于纵向模式时，此按钮将显示侧边栏。当处于横向模式时，我们将有一个特殊样式使此按钮消失。
- en: 'Next, let''s look at the code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看代码：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is pretty similar—instead of adding a listener to a **Back** button,
    we add one to the **Documents** button. The only other thing we do differently
    is hide the `TEXTAREA` control—if no document is loaded, there's no reason to
    show it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当类似——我们不是向 **返回** 按钮添加监听器，而是向 **文档** 按钮添加监听器。我们做的另一件事是隐藏 `TEXTAREA` 控制器——如果没有加载文档，就没有理由显示它。
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's nothing new in this code—just a lot of movement of code. Some of this
    code used to live in `viewWillHide`—to handle saving just before the view disappeared.
    But this view will never disappear now, so how do we know we should save the document?
    Turns out that the only time we'll ever know is when a new document is selected.
    So before we load *that* document, we save the one we've currently got loaded.
    We can tell if we have one loaded by `fileView.hasLoadedDocument`—we'll set it
    to `true` once we get a document loaded.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中没有新内容——只是大量代码的移动。其中一些代码曾经位于 `viewWillHide` 中——用于在视图消失前处理保存。但现在这个视图永远不会消失，我们如何知道应该保存文档呢？结果是，我们唯一知道的时候是当选择了一个新文档。所以在加载那个文档之前，我们保存当前加载的文档。我们可以通过
    `fileView.hasLoadedDocument` 来判断是否已加载文档——一旦我们加载了一个文档，我们就将其设置为 `true`。
- en: At the end of the function, `fileView.loadDocument()` used to live in `viewWillAppear`.
    Since we may not have a document selected (especially at the beginning of the
    app), we aren't trying to load a nonexistent document there, and so we move it
    here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 函数末尾的 `fileView.loadDocument()` 之前位于 `viewWillAppear` 中。由于我们可能没有选择文档（尤其是在应用开始时），我们不会尝试在那里加载一个不存在的文档，所以我们将其移动到这里。
- en: 'Speaking of loading a document, consider the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 说到加载文档，考虑以下代码：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The highlighted code in `loadDocument` is what makes sure our `TEXTAREA` element
    to become visible so that the user can edit it. One thing our code doesn't do
    is hide it again if there's an error—you should definitely handle an error appropriately
    in your own code by hiding the `TEXTAREA` element and ensuring that you don't
    autosave, and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loadDocument` 中高亮的代码确保我们的 `TEXTAREA` 元素可见，以便用户可以编辑它。我们的代码没有做的一件事是在出现错误时再次隐藏它——你应该在你的代码中适当地处理错误，通过隐藏
    `TEXTAREA` 元素并确保不自动保存等。
- en: The only other change necessary was the removal of any code handling a back-button
    event—this leaves `viewWillAppear` and `viewWillHide` completely empty! Note that
    for Android, we still need a `backButtonPressed` function, but we don't do anything
    in it. (You could save the document and quit the app, though, if you wanted.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一必要的其他更改是移除处理返回按钮事件的任何代码——这使得 `viewWillAppear` 和 `viewWillHide` 完全为空！请注意，对于
    Android，我们仍然需要一个 `backButtonPressed` 函数，但我们没有在其中做任何事情。（如果你愿意，你可以在其中保存文档并退出应用。）
- en: 'We''re *almost* done—one last thing to do before we quit, and that''s to make
    the styles hide our buttons appropriately. In `style.css`, we have:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了——在退出之前还有最后一件事要做，那就是确保样式适当地隐藏我们的按钮。在 `style.css` 中，我们有：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And that''s it! Here''s what things look like in landscape mode:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！以下是横向模式下的样子：
- en: '![Getting on with it](img/9403_10_06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_10_06.jpg)'
- en: 'And in portrait mode (with the sidebar visible), it looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在纵向模式（侧边栏可见）下，它看起来像这样：
- en: '![Getting on with it](img/9403_10_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_10_07.jpg)'
- en: Notice in the image on the right that the sidebar is visible in the portrait
    orientation—this is because we clicked the **Documents** button to bring it up.
    Now if we clicked **Close**, the sidebar would disappear.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意右边的图片，在纵向模式下侧边栏是可见的——这是因为我们点击了**文档**按钮将其展开。现在如果我们点击**关闭**，侧边栏就会消失。
- en: What did we do?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We converted the Filer app to a split-view application ready for the tablet-sized
    screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Filer 应用转换成了适用于平板屏幕尺寸的分割视图应用。
- en: What else do I need to know?
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: If your app includes a couple of views (like this one), then conversion is going
    to be pretty simple. But if your app needs to have navigation occur in both views,
    then you're going to run into a hitch as our current framework *doesn't* actually
    support it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用包含几个视图（就像这个一样），那么转换将会非常简单。但如果你的应用需要在两个视图中进行导航，那么你将会遇到问题，因为我们的当前框架**实际上**不支持这一点。
- en: The view stack as implemented by our current framework assumes only one view
    on the screen at one time. But in a split-view app, you can have multiple views
    on the screen. Although the framework plans to support this in the near future,
    it's not currently available, and so you would need to handle navigation between
    views on your own. In short, don't try to use view pushing or popping—otherwise
    funny things will happen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前框架实现的视图堆栈假设屏幕上一次只显示一个视图。但在分割视图应用中，你可以在屏幕上显示多个视图。尽管框架计划在不久的将来支持这一点，但目前尚不可用，因此你需要自己处理视图之间的导航。简而言之，不要尝试使用视图推送或弹出——否则会发生奇怪的事情。
- en: 'If you want to follow the framework''s progress beyond this book, please visit
    the framework''s Github page: [https://github.com/photokandyStudios/YASMF](https://github.com/photokandyStudios/YASMF).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在这个书之外跟踪框架的进展，请访问框架的 Github 页面：[https://github.com/photokandyStudios/YASMF](https://github.com/photokandyStudios/YASMF)。
- en: Game Over..... Wrapping it up
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束..... 总结
- en: Well, we did it. We've converted an app into two different forms ready for the
    tablet-sized screen. Although these are the most popular ways of doing it, that
    doesn't mean that another method might not work better for your app, or a combination
    of several. It all depends on your content and how the app itself works. You would
    do well to consult your platform's *Human Interface Guidelines* (links in [Appendix
    A](apa.html "Appendix A. Quick Design Pattern Reference"), *Quick Design Pattern
    Reference*) too. Only after a thorough examination of your content, layout, graphics,
    and so on, can you determine what approach would be best—and even then, don't
    be afraid to experiment and try something else.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经完成了。我们将一个应用转换成了两种不同的形式，以适应平板屏幕尺寸。尽管这些是目前最受欢迎的做法，但这并不意味着另一种方法可能不会更适合你的应用，或者几种方法的组合。这完全取决于你的内容和应用本身的工作方式。你最好也查阅一下你平台上的**人类界面指南**（[附录
    A](apa.html "附录 A. 快速设计模式参考"), **快速设计模式参考**）。只有在你对内容、布局、图形等进行彻底审查之后，你才能确定哪种方法最好——即使如此，也不要害怕尝试和尝试其他方法。
- en: Can you take the HEAT? The Hotshot Challenge
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受压力吗？热手挑战
- en: This project only covered two methods of scaling to a tablet interface. There
    are, of course, myriad ways of improving what we've shown here, or using other
    design patterns to scale to a tablet interface. Why don't you try a few?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目只涵盖了两种将界面扩展到平板的方法。当然，有无数种方法可以改进我们在这里展示的内容，或者使用其他设计模式来扩展到平板界面。你为什么不尝试几种呢？
- en: The split-view pattern has the left split view (or master view) disappearing
    when in portrait mode. When the **Documents** button is tapped, it appears immediately.
    Why don't you add some animation instead, to make this less jarring? (Don't forget
    to animate it when **Close** is tapped too.)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割视图模式在纵向模式下左侧分割视图（或主视图）会消失。当点击**文档**按钮时，它会立即出现。你为什么不添加一些动画，使这个过程不那么突兀呢？（别忘了在点击**关闭**时也要进行动画处理。）
- en: Continuing the theme, dismiss the left split view automatically when you select
    (or create) a document when in portrait mode.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续这个主题，当在纵向模式下选择（或创建）文档时，自动关闭左侧分割视图。
- en: Most apps today will allow a gesture to open and close the sidebar (usually
    a horizontal swipe). Add this to the app.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天的大多数应用都允许通过手势打开和关闭侧边栏（通常是水平滑动）。将这个功能添加到应用中。
- en: Lastly, when the app opens in portrait mode, there's no real indication of what
    to do (short of tapping **Documents**)—make the sidebar appear automatically.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当应用在纵向模式下打开时，没有真正的指示要做什么（除了轻触**文档**按钮之外）——让侧边栏自动出现。
- en: Instead of using **Create** buttons to create a document, use a "create" item
    in the document list instead. This can be similar in shape to the existing document
    items, or not—your call!
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用**创建**按钮来创建文档，而是在文档列表中使用“创建”选项。这可以与现有的文档项形状相似，也可以不同——由你决定！
- en: Take the split view a step further and add a twist! If you've seen the Facebook
    iOS app, you know that the sidebar actually lives below the main content. The
    main content can then be slid to the right, which exposes the sidebar underneath.
    Try and implement this style of app.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分割视图再进一步，并加入一个转折！如果你看过Facebook的iOS应用，你会知道侧边栏实际上位于主内容下方。然后可以将主内容向右滑动，从而露出下方的侧边栏。尝试实现这种应用风格。
- en: Try putting the sidebar of the split view in a different position. Putting it
    on the right is the easiest, but a harder challenge would be the top or the bottom
    of the screen.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将分割视图的侧边栏放置在不同的位置。将其放在右侧是最简单的，但更难的挑战是将它放在屏幕的顶部或底部。
