- en: Chapter 10. Scaling Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we've really only covered how to create apps for smaller devices such
    as phones. But there are a lot of other mobile devices that aren't phone-shaped,
    namely tablets (and the so called phablets, which are often 7 inches instead of
    10). Though there aren't as many users who have tablets as phones, it is still
    an incredibly important market.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it is possible to simply display the same user interface on a larger
    device. This is often seen in games, where the graphics and control areas are
    often just scaled to the device's screen size. Other times it is possible to largely
    use the same user interface, but small tweaks are required in order to make it
    function well on an a larger screen. And there are other times when there is simply
    no choice; the user interface must be re-thought entirely for the larger screen.
  prefs: []
  type: TYPE_NORMAL
- en: What do we build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we'll revisit an app that we created in [Project 3](ch03.html
    "Chapter 3. Being Productive"), *Being Productive*. The app isn't terribly complex,
    but it is flexible enough to support various ways of scaling up, which is what
    we'll do. We're going to create several different versions of Filer, each with
    different concepts of scaling to a tablet-sized screen.
  prefs: []
  type: TYPE_NORMAL
- en: What does it do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main problems with developing for a larger screen when one has been
    solely developing for a small screen is "What to do with all that space?" When
    one is constrained to developing for a 320 x 80 or 600 x 800 dimension, it can
    be a sudden shock to realize that one has a lot more pixels to fill. Often, these
    larger displays are sized at 1024 x 768, 1280 x 768, 1280 x 800, or higher. In
    fact, the iPad 3 has a display that's technically 2048 x 1536, which when you
    think about it, is pretty astounding. Thankfully, the iPad 3 scales that back
    to 1024 x 768 for us.
  prefs: []
  type: TYPE_NORMAL
- en: What we'll do in this project is rethink the user interface for Filer to account
    for the larger real estate. We won't focus so much on the actual functionality—we've
    done that work in [Project 3](ch03.html "Chapter 3. Being Productive"), *Being
    Productive*, but we will deal with how to handle larger screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll focus on two typical scenarios: **scale-it-up**, where we simply scale
    the interface to fit the new screen size, and **split view** (otherwise referred
    to as **master-detail**), where we will add a sidebar to the interface (something
    you see quite often on the iPad, for example, the **Settings** app).'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it great?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes an app just screams for more space—and note-taking apps aren't any
    exception. A bigger screen means that there is a larger on-screen keyboard, and
    a bigger screen means that there is more space for important content—such as text.
    At other times, we can transition an app to the larger screen by using split-view
    layouts that allow us to efficiently flatten the app's hierarchy. We'll explore
    all these options with our three versions of Filer.
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to do it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll approach the three designs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the scaled-up UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the scaled-up UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the split-view UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the split-view UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do I need to get started?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this particular task, we'll be working with the files for this project,
    so if you want to follow along, go ahead and download them. There are two directories
    named `1` and `2`, which are versions of the app in this project. The first is
    what we'll focus on next, while the second is what we'll work on later.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the scaled-up UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of apps can simply "scale up" to fit the larger screen, and our framework,
    thankfully, does a lot of the "scaling" part for us. While this works well for
    games, we do need to do a bit more work to make Filer fit the big screen well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you remember the Filer app from [Project 3](ch03.html "Chapter 3. Being
    Productive"), *Being Productive*, there were three views: a **start view**, a
    **documents view**, and the **document view**. We''ll be scrapping the first view—there''d
    be nothing to do with it to make it work on a larger screen anyway. Instead, we''ll
    focus on the last two views—and, in all honesty, for this task, we''re only really
    going to make a lot of the changes to the first of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the screenshot from the documents view for the Filer
    app from [Project 3](ch03.html "Chapter 3. Being Productive"), *Being Productive*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our tablet-sized app, we''ll display this list of documents horizontally
    and vertically, rather than just horizontally. On an iPad, this will show about
    three icons across when in portrait orientation and four icons across when in
    landscape. This means our mockup looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the purposes of this project, we'll keep the **Create** button on the navigation
    bar, but there is a challenge at the end of the project to turn this into a larger
    feature within the document list. For example, some apps might have a blank document
    image with a "plus" icon in it to symbolize creating a new document. Others might
    use a dashed rectangle to indicate the same thing. For the larger display, something
    like this is definitely appropriate; while on a small screen, it'd be seen as
    a waste of space.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond making this change to the document list, that's really all we're going
    to be doing to the app. The rest of it will work as is on the larger screen, thanks
    to the fact that our framework is designed to fill the screen.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task we went over the app from [Project 3](ch03.html "Chapter 3. Being
    Productive"), *Being Productive*, and created a new mockup for the user interface
    for the larger screen.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scaling up an iPhone app is pretty easy *if* you've already planned for the
    future of scaling it up. That is, if you've planned everything down to the pixel
    and built for a 320 x 480 screen, you're going to have to change all those pixels
    around on a larger screen. When dealing with simple productivity apps such as
    Filer, building a layout that can scale to a larger screen isn't terribly difficult,
    but get into more complex layouts and graphics, and it starts to become a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: In some ways, highly graphical games have it both the hardest and the easiest.
    A game is probably going to keep the same user interface when scaling to a new
    screen—with perhaps a few minor tweaks to button placement or size. The graphics,
    however, are going to be the same, visually. Underneath the hood, though, those
    graphics may be rendered at vastly different resolutions. A certain graphic might
    work fine on a small screen, but get that up to a larger screen, and it will either
    seem too large or too small. To avoid forcing the browser to scale *everything*
    (which always slows things down and results in some blurriness), it is better
    to re-render the graphics for the target screen, because you never know what kind
    of screens will be out in the future. It is, for this reason, always better to
    create your graphics in a vector format—this way you can always create a new rendition
    when a new size is needed.
  prefs: []
  type: TYPE_NORMAL
- en: One of the hardest things to deal with properly are full-screen images. These
    might be in-game backgrounds, menu backgrounds, splashes, and so on, and you want
    them to look as nice as possible. In our sample game ([Project 8](ch08.html "Chapter 8. Playing
    Around"), *Playing Around*), we didn't focus on this a great deal, but if you
    had a device that had a substantially different aspect ratio than I had, you probably
    noticed some letter-boxing when the full-screen assets were shown. This is one
    way to approach it without having to do a lot of work—the other would be to scale
    and crop the image, potentially blurring it a bit, and losing portions of the
    image. The only other realistic option is to create an image specifically for
    each supported resolution.
  prefs: []
  type: TYPE_NORMAL
- en: For the best visual appearance, you should always render your images at the
    device's native resolution. For a Retina iPad, this would be 2048 x 1536 for a
    full-screen image. This, of course, is different for just about every Android
    device, and there's no terribly easy way to deal with it. You can replace the
    graphics via JavaScript based on the size of the screen, or you can use media
    queries to target specific graphic elements. You should note that though the framework
    we use does make a distinction between phone-sized devices and tablet-sized devices
    as well as non-retina and retina displays, it does nothing about all the different
    resolutions available on Android. Your best option would be to use CSS media queries
    (for more information, see [https://developer.mozilla.org/en-US/docs/CSS/Media_queries](https://developer.mozilla.org/en-US/docs/CSS/Media_queries)).
  prefs: []
  type: TYPE_NORMAL
- en: In other ways, non-game apps can be terribly painful to scale up. You might
    be dealing with, for example, a lot of content that is formatted in a reasonably
    complex manner. It looks great given one screen size, but on another, things may
    break in odd places, especially when just scaling it. Sometimes the fact that
    we're working in HTML and CSS will save us—it's meant for dealing with complicated
    layout, but just as many times as not, it'll cause the look and feel to go awry
    in a way that you hadn't envisioned.
  prefs: []
  type: TYPE_NORMAL
- en: This is when creating code and layout *specifically* for the tablet-size screen
    may be necessary. You can do things in your JavaScript, HTML, and CSS code to
    handle these sizes—you could put a `DIV` tag classed with `tablet` in your HTML,
    and have a CSS rule that hides it on anything but a tablet. Likewise, you could
    hide the phone UI elements if you're trying to create a universal app that can
    run on both phone-sized screens and tablet-sized screens. Or, if you're positioning
    certain things with JavaScript, you can always look at the type of device you're
    running on to get a good idea about what to do—and worst case, look at the width
    or height of the screen. Again, using media queries can often help when dealing
    with multiple resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the scaled-up UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've designed the UI for Filer HD mark I, it's time to implement it.
    The number of changes that we've made to our code are astoundingly small, so get
    ready to keep your eyes open—blink, and you might miss it!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although we''re focusing primarily on the iOS platform for this app, the concepts
    apply equally to any platform-based tablet. With that said, to render an iOS app
    specific to the iPad, there are a couple of settings that need to be set in the
    project itself, outside of code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the project's settings in Xcode, change the **Devices** setting to **iPad**
    from **Universal**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the project setting like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/9403_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Aside from this change (and setting our typical settings for the project in
    `Cordova.plist` for iOS), we'll copy the files from [Project 3](ch03.html "Chapter 3. Being
    Productive"), *Being Productive*. If you want to follow along, navigate to `/1/www`
    in the code files of this project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's really surprisingly little that we have to do to make the app fit to
    the larger screen. As we've said before, our framework does do a good portion
    of the work—it always attempts to ensure that the content fills the screen, and
    our HTML in our views helps too—where possible, we want to use percentages not
    pixels. (This is not to say that using pixels is not good; for example, we use
    them liberally when dealing with button placement on the navigation bar.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as a reminder, here''s the documents view''s HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing here has to change, really. Next up, here''s some of our styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So far, no change for the iPad devices. We did strip out the code that turned
    this into a list for Android devices, and so all tablet devices will get nice,
    big document icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one place where we made some change was in the actual code, so let''s take
    a look there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See the comment about deleted code?
  prefs: []
  type: TYPE_NORMAL
- en: That's right—we *deleted* something! If you remember, on the iPhone we wanted
    the document listing to scroll *horizontally*, so there was some code that set
    the width of the document list's container to *the number of items multiplied
    by the width*. This would make `DIV` larger, and it therefore allowed the content
    to scroll horizontally. For this app, we want the width to be of one-screen width,
    and then we want the browser to *wrap* our documents just like words on a page.
    So the next document to the right of the screen actually goes below the left-most
    document and starts a new row.
  prefs: []
  type: TYPE_NORMAL
- en: Guess what—that's *it*. Our buttons didn't need to change position, and the
    text editor in our document view is already coded to fill the entire screen, so
    we didn't need to do anything there. The only thing we *had* to take out was code
    that was written specifically for a phone-sized device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So what does it look like now?
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task we converted what was a phone app into a tablet app.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We accomplished this by actually removing code that was constraining the app
    to that of a phone, but not all apps will be so simple to scale. Sometimes you
    may need to reposition buttons, content, and various elements in order to fit
    better on the larger screen. If you want the app to remain universal (that is,
    it will work on both a phone-sized device and a tablet-sized device), your work
    becomes harder, because you have to keep both layouts around. Thankfully, CSS,
    HTML, and JavaScript come to the rescue and help us out by letting us target certain
    classes and IDs or media queries with CSS and writing JavaScript code specific
    to a particular layout. In our case, we could have kept the phone-sized specific
    code by checking for the size of the device—the framework happily takes care of
    the rest of the sizing itself to the different sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you can get by with the way your framework handles the different viewport
    sizes, but there are often times when this falls flat—the UI is either too sparse
    on a large screen or too crammed on a small screen. If this occurs, it would be
    better to build your UI specifically for each device size rather than relying
    on the framework to get things right—because sometimes it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the split-view UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The split-view layout is by far one of the most popular methods for scaling
    your app to the tablet. It also has the side benefit of flattening the application's
    information hierarchy, which is just the technical way of saying that it takes
    less "taps" to get somewhere in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Most tablet platforms implement this view in similar ways—in landscape mode
    it's always there on the left (but sometimes on the right), and in portrait mode
    it's usually hidden offscreen, ready and waiting for when the user taps a button
    to call it out. Other times the view is always visible in portrait mode, but this
    depends on the type of app and whether or not the loss of screen space is worth
    having the split view always visible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The split view is really just two views put together. That's the easy way to
    think about it—one view is on the left in a smaller sidebar while the second view
    is on the right. The left view is technically called the **master view**, while
    the right view is called the **detail view**. Technically, this pattern is the
    **master-detail** pattern, and it is most obvious when working with data records
    where the record selection occurs in the master view (on the left), and the detail
    of the record shows in the detail view (on the right).
  prefs: []
  type: TYPE_NORMAL
- en: In our app, we're going to make the documents list the master view so that the
    document itself can be the focus of the user. This means that a specific document
    will become the detail. In this arrangement, however, we need to switch from the
    pretty grid listing of documents in the previous version of the app and go back
    to a simple list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our design looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The only thing not quite "true" in this sketch is the **Create** button on the
    top. In reality there's going to be a title next to it as well, just that there
    wasn't enough space in the mockup to put it there. So it won't look as out-of-place
    as it does in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: What isn't obvious is what happens when the device rotates to portrait orientation.
    The sidebar will actually disappear—leaving only the text document visible. We'll
    have a button on the left titled **Documents** that will bring the sidebar back,
    and once the sidebar is displayed, a **Close** button that will dismiss it. In
    a challenge at the end of this project, you'll be asked to implement gestures
    to open and close the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we designed the user interface for a split-view layout.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It really depends on your app if the master view needs to go away when oriented
    in portrait. Some apps can spare the loss of screen-width, other apps can't. When
    dealing with content (such as graphics, text, and so on.), it's probably a good
    idea to get rid of it when in portrait mode. If you're dealing with settings,
    properties, or the like, then you can keep it there with little impact on usability.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the split-view UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to implement the changes necessary to make our app a split-view
    app. From this point forward, we'll be working in `/2/www` if you want to follow
    along. We started from the code in the last task and then modified it to suit
    the new user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the last time, we're going to be making several modifications. Not a
    *lot* of code, mind you, but we'll be touching several different files and making
    tweaks to support the change. The documents view gets only a few minor modifications,
    though we will change the display to a list instead of a grid, and the file view
    gets several modifications. For one, it has to handle what to do when there is
    no document loaded (which will happen at the beginning of the app). Second, it
    has to change the way it handles autosaving content (since there is no longer
    any dismissal of the view).
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we need to get the layout set up to show two views side-by-side.
    We''ll start in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've added two elements to the `rootContainer` element. The first
    is `leftSplitContainer` and the second is `rightSplitContainer`. The position
    of these elements should be apparent from the `ID` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This alone isn''t going to get us there, though. We need to style these appropriately—and
    for this, we''ve made a change in the framework''s base CSS. Look at `2/www/framework/base.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What we've done is indicated that while the device is in landscape orientation,
    the two splits should be side-by-side. The left-hand will be 319 pixels wide,
    and the right-hand view will start at pixel 320\. Whatever's left on the screen
    will determine the width of the right-hand view. *The size of this sidebar is
    not set in stone*—if your app needs a smaller sidebar, go ahead and aim lower—likewise,
    if it needs a larger one, set it larger. It is best, however, to not exceed half
    the width of the screen. If you feel the need, it is time to decide if you've
    got your views on the correct side.
  prefs: []
  type: TYPE_NORMAL
- en: In portrait mode, we *hide* the sidebar. That said, this sidebar can appear
    again when the user wants, so we also make sure that it is indexed above all of
    the other content. We also give it a shadow so that there is a visual distinction
    for the user between the sidebar and the content underneath.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the styles alone, however, isn''t enough. Let''s take a look at what
    we''ve changed in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, our loading code has changed a little. Note that instead of attaching
    to `rootContainer`, we attach to `leftSplitContainer` and `rightSplitContainer`.
    This first step is critical to ensuring that each view's content ends up in the
    right place on the screen. Note also that we show *each* view. This is new too—previously
    we would only have shown one view, but since we are combining two views on the
    screen, we need them both to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: There's one last new feature at the bottom of the previous code—a new event
    listener. We'll cover the following code, but essentially we ask the browser to
    notify us of any change in orientation. While the CSS and HTML go a long way to
    making sure our layout is correct when the orientation changes, they don't get
    us *all* the way, and so we need some code to figure out the rest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code is called by both the documents and file views, and its sole purpose
    is to toggle the appearance of the sidebar. If it is visible, this function will
    hide it, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code gets called at every change in orientation. If we change to portrait,
    we'll hide the sidebar, and if we change to landscape, we show it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to make some minor changes to the documents view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The main difference is that we've added a **Close** button to the view—this
    button will allow the user to dismiss the sidebar when they've previously elected
    to display it in portrait mode. We'll add some styles later on to prevent it from
    being visible while in landscape mode. We also changed the click handlers for
    certain areas, since this is now a list instead of a grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support the new button, we have added some code to `documentsView.initializeView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: All this does is call `APP.toggleSidebar` whenever the **Close** button is tapped.
    Since the sidebar will be visible when we call this function, this means it will
    dismiss the sidebar by hiding it.
  prefs: []
  type: TYPE_NORMAL
- en: The only other change? We removed calls to `PKUI.CORE.pushView`. These would
    normally have pushed the file view on the stack, but since it's already visible,
    we don't need to push anything. So we just remove those lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We did make changes to the styling, however (in `style.css`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will make each document item a nice little list item with
    the icon on the left, the title on the right, and the action icons below. You
    could take what you've learned from previous projects and add gesture support
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file view itself gets quite a bit of change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing different is that we've added a documents button on the navigation
    bar in place of the **Back** button. This button will show the sidebar when in
    portrait mode. When in landscape, we'll have a special style that makes this button
    go away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty similar—instead of adding a listener to a **Back** button,
    we add one to the **Documents** button. The only other thing we do differently
    is hide the `TEXTAREA` control—if no document is loaded, there's no reason to
    show it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new in this code—just a lot of movement of code. Some of this
    code used to live in `viewWillHide`—to handle saving just before the view disappeared.
    But this view will never disappear now, so how do we know we should save the document?
    Turns out that the only time we'll ever know is when a new document is selected.
    So before we load *that* document, we save the one we've currently got loaded.
    We can tell if we have one loaded by `fileView.hasLoadedDocument`—we'll set it
    to `true` once we get a document loaded.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the function, `fileView.loadDocument()` used to live in `viewWillAppear`.
    Since we may not have a document selected (especially at the beginning of the
    app), we aren't trying to load a nonexistent document there, and so we move it
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of loading a document, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code in `loadDocument` is what makes sure our `TEXTAREA` element
    to become visible so that the user can edit it. One thing our code doesn't do
    is hide it again if there's an error—you should definitely handle an error appropriately
    in your own code by hiding the `TEXTAREA` element and ensuring that you don't
    autosave, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The only other change necessary was the removal of any code handling a back-button
    event—this leaves `viewWillAppear` and `viewWillHide` completely empty! Note that
    for Android, we still need a `backButtonPressed` function, but we don't do anything
    in it. (You could save the document and quit the app, though, if you wanted.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re *almost* done—one last thing to do before we quit, and that''s to make
    the styles hide our buttons appropriately. In `style.css`, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s it! Here''s what things look like in landscape mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And in portrait mode (with the sidebar visible), it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice in the image on the right that the sidebar is visible in the portrait
    orientation—this is because we clicked the **Documents** button to bring it up.
    Now if we clicked **Close**, the sidebar would disappear.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We converted the Filer app to a split-view application ready for the tablet-sized
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your app includes a couple of views (like this one), then conversion is going
    to be pretty simple. But if your app needs to have navigation occur in both views,
    then you're going to run into a hitch as our current framework *doesn't* actually
    support it.
  prefs: []
  type: TYPE_NORMAL
- en: The view stack as implemented by our current framework assumes only one view
    on the screen at one time. But in a split-view app, you can have multiple views
    on the screen. Although the framework plans to support this in the near future,
    it's not currently available, and so you would need to handle navigation between
    views on your own. In short, don't try to use view pushing or popping—otherwise
    funny things will happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to follow the framework''s progress beyond this book, please visit
    the framework''s Github page: [https://github.com/photokandyStudios/YASMF](https://github.com/photokandyStudios/YASMF).'
  prefs: []
  type: TYPE_NORMAL
- en: Game Over..... Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we did it. We've converted an app into two different forms ready for the
    tablet-sized screen. Although these are the most popular ways of doing it, that
    doesn't mean that another method might not work better for your app, or a combination
    of several. It all depends on your content and how the app itself works. You would
    do well to consult your platform's *Human Interface Guidelines* (links in [Appendix
    A](apa.html "Appendix A. Quick Design Pattern Reference"), *Quick Design Pattern
    Reference*) too. Only after a thorough examination of your content, layout, graphics,
    and so on, can you determine what approach would be best—and even then, don't
    be afraid to experiment and try something else.
  prefs: []
  type: TYPE_NORMAL
- en: Can you take the HEAT? The Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project only covered two methods of scaling to a tablet interface. There
    are, of course, myriad ways of improving what we've shown here, or using other
    design patterns to scale to a tablet interface. Why don't you try a few?
  prefs: []
  type: TYPE_NORMAL
- en: The split-view pattern has the left split view (or master view) disappearing
    when in portrait mode. When the **Documents** button is tapped, it appears immediately.
    Why don't you add some animation instead, to make this less jarring? (Don't forget
    to animate it when **Close** is tapped too.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing the theme, dismiss the left split view automatically when you select
    (or create) a document when in portrait mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most apps today will allow a gesture to open and close the sidebar (usually
    a horizontal swipe). Add this to the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, when the app opens in portrait mode, there's no real indication of what
    to do (short of tapping **Documents**)—make the sidebar appear automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using **Create** buttons to create a document, use a "create" item
    in the document list instead. This can be similar in shape to the existing document
    items, or not—your call!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the split view a step further and add a twist! If you've seen the Facebook
    iOS app, you know that the sidebar actually lives below the main content. The
    main content can then be slid to the right, which exposes the sidebar underneath.
    Try and implement this style of app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try putting the sidebar of the split view in a different position. Putting it
    on the right is the easiest, but a harder challenge would be the top or the bottom
    of the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
