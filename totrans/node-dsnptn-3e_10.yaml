- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Universal JavaScript for Web Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用 JavaScript 用于 Web 应用程序
- en: JavaScript was born with the goal of giving web developers the power to execute
    code directly on the browser and build dynamic and interactive websites.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的诞生目标是赋予网络开发者直接在浏览器中执行代码并构建动态和交互式网站的能力。
- en: Since its inception, JavaScript has grown up a lot. If, at the very beginning,
    JavaScript was a very simple and limited language, today, it can be considered
    a complete general-purpose language that can be used even outside the browser
    to build almost any kind of application. In fact, JavaScript now powers frontend
    applications, web servers, and mobile applications, as well as embedded devices
    such as wearable devices, thermostats, and flying drones.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 JavaScript 诞生以来，它已经发展了很多。如果，在最开始，JavaScript 是一个非常简单和有限制的语言，那么今天，它可以被认为是一种完整的通用语言，甚至可以用于浏览器之外构建几乎任何类型的应用程序。事实上，JavaScript
    现在为前端应用程序、网络服务器、移动应用程序以及嵌入式设备（如可穿戴设备、恒温器和飞行无人机）提供动力。
- en: 'The language''s availability across platforms and devices is fostering a new
    trend among JavaScript developers: being able to simplify code reuse across different
    environments in the same project. With Node.js, developers have the opportunity
    to build web applications where it is easy to share code between the server (backend)
    and the browser (frontend). This quest for code reuse was originally identified
    with the term **Isomorphic JavaScript**, but today, it''s mostly recognized as
    **Universal JavaScript**.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 语言在平台和设备上的可用性正在促进 JavaScript 开发者中的一种新趋势：能够在同一项目中简化不同环境之间的代码复用。有了 Node.js，开发者有机会构建易于在服务器（后端）和浏览器（前端）之间共享代码的
    Web 应用程序。这种代码复用的追求最初与术语 **同构 JavaScript** 相关联，但今天，它更多地被认可为 **通用 JavaScript**。
- en: In this chapter, we are going to explore the wonders of Universal JavaScript,
    specifically in the field of web development, and discover many tools and techniques
    we can use to share code between the server and the browser.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索通用 JavaScript 的奇妙之处，特别是在网络开发领域，并发现我们可以用来在服务器和浏览器之间共享代码的许多工具和技术。
- en: We will explore what a module bundler is and why we need one. We will then learn
    how module bundlers work and we will practice with one of the most popular, webpack.
    Then, we will discuss some generic patterns that can help us with code reuse across
    platforms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨什么是模块打包器以及为什么我们需要它。然后，我们将学习模块打包器是如何工作的，并使用最流行的之一 webpack 进行实践。接着，我们将讨论一些通用的模式，这些模式可以帮助我们在不同平台上进行代码复用。
- en: Finally, we will learn the basic functionalities of React and we will use it
    to build a complete Universal JavaScript application that features universal rendering,
    universal routing, and universal data loading.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习 React 的基本功能，并使用它来构建一个具有通用渲染、通用路由和通用数据加载的完整通用 JavaScript 应用程序。
- en: 'To summarize, here''s a list of topics we will be covering in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是本章我们将涉及的主题列表：
- en: How to share code between the browser and Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在浏览器和 Node.js 之间共享代码
- en: Fundamentals of cross-platform development (code branching, module swapping,
    and other useful patterns)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台开发基础（代码分支、模块交换和其他有用的模式）
- en: A brief introduction to React
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 简要介绍
- en: How to build a complete Universal JavaScript application using React and Node.js
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 React 和 Node.js 构建一个完整的通用 JavaScript 应用程序
- en: Sit tight, this is going to be an exciting chapter!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请耐心等待，这将是一个令人兴奋的章节！
- en: Sharing code with the browser
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与浏览器共享代码
- en: 'One of the main selling points of Node.js is the fact that it''s based on JavaScript
    and runs on V8, a JavaScript engine that actually powers some of the most popular
    browsers: Google Chrome and Microsoft Edge. We might think that sharing the same
    JavaScript engine is enough to make sharing code between Node.js and the browser
    an easy task; however, as we will see in this chapter, this is not always true,
    unless we want to share only simple, self-contained, and generic fragments of
    code.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的一个主要卖点是基于 JavaScript，并在 V8 上运行，V8 是一个 JavaScript 引擎，实际上为一些最受欢迎的浏览器提供动力：Google
    Chrome 和 Microsoft Edge。我们可能会认为共享相同的 JavaScript 引擎就足以使 Node.js 和浏览器之间的代码共享变得容易；然而，正如我们将在本章中看到的，这并不总是正确的，除非我们只想共享简单、自包含和通用的代码片段。
- en: Developing code for both the client and the server requires a non-negligible
    level of effort in making sure that the same code can run properly in two environments
    that are intrinsically different. For example, in Node.js, we don't have the DOM
    or long-living views, while on the browser, we surely don't have the filesystem
    and many other interfaces to interact with the underlying operating system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为客户端和服务器开发代码需要付出相当大的努力，以确保相同的代码可以在本质上不同的两个环境中正确运行。例如，在 Node.js 中，我们没有 DOM 或长期存在的视图，而在浏览器上，我们肯定没有文件系统和其他许多与底层操作系统交互的接口。
- en: Another contention point is the level of support for modern JavaScript features.
    When we target Node.js, we can safely adopt modern language features because we
    know which Node.js version runs on our servers. For instance, for our server code,
    we can safely decide to adopt async/await if we know it will run on Node.js version
    8 (or on a more recent version). Unfortunately, we can't have the same confidence
    when writing JavaScript code for the browser.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个争议点是对现代 JavaScript 特性的支持程度。当我们针对 Node.js 进行开发时，我们可以安全地采用现代语言特性，因为我们知道哪些 Node.js
    版本运行在我们的服务器上。例如，对于我们的服务器代码，如果我们知道它将在 Node.js 版本 8（或更高版本）上运行，我们可以安全地决定采用 async/await。不幸的是，在为浏览器编写
    JavaScript 代码时，我们无法拥有同样的信心。
- en: This is because different users will have different browsers with different
    levels of compatibility with the latest language features. Some users might be
    using a modern browser with full support for async/await, while other users might
    still be using an old device with an old browser that does not support async/await.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为不同的用户将使用不同版本的浏览器，它们对最新语言特性的兼容性水平也不同。一些用户可能使用支持 async/await 的现代浏览器，而其他用户可能仍在使用不支持
    async/await 的旧设备和旧浏览器。
- en: So, most of the effort required when developing for both platforms is to make
    sure to reduce those differences to a minimum. This can be done with the help
    of abstractions, patterns, and tools that enable the application to switch, dynamically
    or at build time, between browser-compatible code and Node.js code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在为两个平台开发时，大部分所需的工作是确保将这些差异减少到最小。这可以通过使用抽象、模式和工具来实现，这些工具使应用程序能够在构建时或动态地切换到浏览器兼容代码和
    Node.js 代码。
- en: Luckily, with the rising interest in this new mind-blowing possibility, many
    libraries and frameworks in the ecosystem have started to support both environments.
    This evolution is also backed by a growing number of tools supporting this new
    kind of workflow, which, over the years, have been refined and perfected. This
    means that if we are using an npm package on Node.js, there is a good probability
    that it will work seamlessly on the browser as well. However, this is often not
    enough to guarantee that our application can run without problems on both the
    browser and Node.js. As we will see, a careful design is always needed when developing
    cross-platform code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，随着对这个令人惊叹的新可能性的兴趣日益增长，生态系统中的许多库和框架已经开始支持这两个环境。这种演变也得到了越来越多的工具的支持，这些工具在多年的发展中得到了精炼和完善。这意味着如果我们正在
    Node.js 上使用 npm 包，那么它在浏览器上也能很好地工作。然而，这通常不足以保证我们的应用程序可以在浏览器和 Node.js 上无问题地运行。正如我们将看到的，在开发跨平台代码时，始终需要进行仔细的设计。
- en: In this section, we are going to explore the fundamental problems we might encounter
    when writing code for both Node.js and the browser, and we are going to propose
    some tools and patterns that can help us with tackling this new and exciting challenge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在为 Node.js 和浏览器编写代码时可能遇到的根本问题，并提出一些工具和模式，以帮助我们应对这个新而激动人心的挑战。
- en: JavaScript modules in a cross-platform context
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台环境中的 JavaScript 模块
- en: The first wall we hit when we want to share some code between the browser and
    the server is the mismatch between the module system used by Node.js and the heterogeneous
    landscape of the module systems used on the browser. Another problem is that on
    the browser, we don't have a `require()` function or the filesystem from which
    we can resolve modules. Most modern browsers support `import` and ES modules,
    but again, some of the users visiting our website might not have already adopted
    one of those modern browsers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在浏览器和服务器之间共享一些代码时，我们首先遇到的第一道障碍是 Node.js 使用的模块系统与浏览器上使用的异构模块系统之间的不匹配。另一个问题是，在浏览器上，我们没有
    `require()` 函数或文件系统来解析模块。大多数现代浏览器支持 `import` 和 ES 模块，但同样，访问我们网站的某些用户可能还没有采用这些现代浏览器之一。
- en: In addition to these problems, we have to take into account the differences
    in distributing code for the server and the browser. On the server, modules are
    loaded directly from the filesystem. This is generally a performant operation
    and therefore developers are encouraged to split their code into small modules
    to keep the different logic units small and organized.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些问题，我们还需要考虑服务器和浏览器在代码分发上的差异。在服务器上，模块是直接从文件系统中加载的。这通常是一个性能良好的操作，因此鼓励开发者将代码拆分成小的模块，以保持不同的逻辑单元小而有序。
- en: 'On the browser, the script loading model is totally different. The process
    generally starts with the browser downloading an HTML page from a remote endpoint.
    The HTML code is parsed by the browser, which might find references to script
    files that need to be downloaded and executed. If we are dealing with a large
    application, there might be many scripts to download, so the browser will have
    to issue a significant number of HTTP requests and download and parse multiple
    script files before the application can be fully initialized. The higher the number
    of script files, the larger the performance penalty that we will have to pay to
    run an application on the browser, especially on slow networks. Even though some
    of this performance penalty can be mitigated with the adoption of **HTTP/2 Server
    Push** ([nodejsdp.link/http2-server-push](http://nodejsdp.link/http2-server-push)),
    client-side caching, preloading, or similar techniques, the underlying problem
    still stands: having to receive and parse a large number of files is generally
    worse than having to deal with a few optimized files.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上，脚本加载模型完全不同。这个过程通常从浏览器从远程端点下载一个 HTML 页面开始。浏览器会解析 HTML 代码，可能会找到需要下载和执行的脚本文件的引用。如果我们处理的是一个大型应用程序，可能会有很多脚本需要下载，因此浏览器将不得不发出大量的
    HTTP 请求，在应用程序完全初始化之前下载和解析多个脚本文件。脚本文件的数量越多，我们在浏览器上运行应用程序时需要付出的性能代价就越大，尤其是在网络较慢的情况下。尽管可以通过采用
    **HTTP/2 服务器推送** ([nodejsdp.link/http2-server-push](http://nodejsdp.link/http2-server-push))、客户端缓存、预加载或类似技术来减轻一些性能损失，但根本问题仍然存在：需要接收和解析大量文件通常比处理少量优化文件要差。
- en: A common practice to address this problem is to "build" packages (or **bundles**)
    for the browser. A typical build process will collate all the source files into
    a very small number of bundles (for instance, one JavaScript file per page) so
    that the browser won't have to download a huge number of scripts for each page
    visit. A build process is not limited to just reducing the number of files, in
    fact, it can perform other interesting optimizations. Another common optimization
    is *code minification*, which allows us to reduce the number of characters to
    a minimum without altering the functionality. This is generally done by removing
    comments, removing unused code, and renaming function and variable names.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见做法是为浏览器“构建”包（或 **包**）。典型的构建过程会将所有源文件合并成非常少的几个包（例如，每个页面一个 JavaScript
    文件），这样浏览器就不需要为每次页面访问下载大量的脚本。构建过程不仅限于减少文件数量，实际上，它还可以执行其他有趣的优化。另一种常见的优化是 *代码压缩*，这允许我们将字符数减少到最小而不改变功能。这通常是通过删除注释、删除未使用的代码以及重命名函数和变量名来实现的。
- en: Module bundlers
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块打包器
- en: 'If we want to write large portions of code that can work as seamlessly as possible
    both on the server and on the browser, we need a tool to help us with "bundling"
    all the dependencies together at build time. These tools are generally called
    **module bundlers**. Let''s visualize this with an example of how shared code
    can be loaded on to the server and the client using a module bundler:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要编写可以在服务器和浏览器上无缝运行的大量代码，我们需要一个工具来帮助我们“打包”所有依赖项，在构建时将它们一起打包。这些工具通常被称为 **模块打包器**。让我们通过一个示例来可视化如何使用模块打包器将共享代码加载到服务器和客户端：
- en: '![](img/B15729_10_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15729_10_01.png)'
- en: 'Figure 10.1: Loading shared modules on the server and on the browser (using
    a module bundler)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：服务器和浏览器上加载共享模块（使用模块打包器）
- en: 'By looking at *Figure 10.1*, we can see that the code is processed and loaded
    differently on the server side and on the browser:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 *图 10.1*，我们可以看到代码在服务器端和浏览器上的处理和加载方式是不同的：
- en: '**On the server side**: Node.js can directly execute our `serverApp.js`, which,
    in turn, will import the modules `moduleA.js`, `moduleB.js`, and `moduleC.js`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在服务器端**：Node.js 可以直接执行我们的 `serverApp.js`，它反过来会导入模块 `moduleA.js`、`moduleB.js`
    和 `moduleC.js`。'
- en: '**On the browser**: We have `browserApp.js`, which also imports `moduleA.js`,
    `moduleB.js`, and `moduleC.js`. If our index file were to include `browserApp.js`
    directly, we would have to download a total of five files (`index.html`, `browserApp.js`,
    and the three dependency modules) before the app would be fully initialized. The
    module bundler allows us to reduce the total number of files to only two by preprocessing
    `browserApp.js` and all its dependencies and producing a single equivalent bundle
    called `main.js`, which is then referenced by `index.html` and therefore loaded
    by the browser.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在浏览器上**：我们有`browserApp.js`，它还导入了`moduleA.js`、`moduleB.js`和`moduleC.js`。如果我们的索引文件直接包含`browserApp.js`，那么在应用程序完全初始化之前，我们需要下载总共五个文件（`index.html`、`browserApp.js`和三个依赖模块）。模块打包器允许我们通过预处理`browserApp.js`及其所有依赖项，并生成一个单一的等效打包文件`main.js`，然后由`index.html`引用并由浏览器加载，从而将文件总数减少到只有两个。'
- en: To summarize, on the browser, we generally have to deal with two logical phases,
    build and runtime, while on the server, we generally don't need a build phase
    and we can execute our source code directly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在浏览器上，我们通常必须处理两个逻辑阶段，构建和运行时，而在服务器上，我们通常不需要构建阶段，可以直接执行源代码。
- en: 'When it comes to picking a module bundler, the most popular option is probably
    **webpack** ([nodejsdp.link/webpack](http://nodejsdp.link/webpack)). Webpack is
    one of the most complete and mature module bundlers currently available and it
    is the one we are going to use in this chapter. It''s worth mentioning, though,
    that there is a quite prosperous ecosystem full of alternatives, each one with
    its own strengths. If you are curious, here are some of the most well-known alternatives
    to webpack:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到选择模块打包器时，最受欢迎的选项可能就是**webpack**([nodejsdp.link/webpack](http://nodejsdp.link/webpack))。Webpack是目前最完整、最成熟的模块打包器之一，也是我们将在本章中使用的打包器。不过，值得一提的是，有一个相当繁荣的生态系统，其中充满了各种替代方案，每个方案都有其独特的优势。如果你对此感兴趣，以下是一些最著名的webpack替代方案：
- en: '**Parcel** ([nodejsdp.link/parcel](http://nodejsdp.link/parcel)): Aims to be
    fast and to work "*auto-magically*" without any configuration.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parcel**([nodejsdp.link/parcel](http://nodejsdp.link/parcel))：旨在快速且无需任何配置即可“自动魔法般”地工作。'
- en: '**Rollup** ([nodejsdp.link/rollup](http://nodejsdp.link/rollup)): One of the
    first module bundlers to fully support ESM and to offer a number of optimizations
    like tree shaking and dead code elimination.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rollup**([nodejsdp.link/rollup](http://nodejsdp.link/rollup))：第一个完全支持ESM的模块打包器，并提供了一些优化，如摇树优化和死代码消除。'
- en: '**Browserify** ([nodejsdp.link/browserify](http://nodejsdp.link/browserify)):
    The first module bundler with support for CommonJS and is still widely adopted.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Browserify**([nodejsdp.link/browserify](http://nodejsdp.link/browserify))：第一个支持CommonJS的模块打包器，至今仍被广泛采用。'
- en: Other trending module bundlers are **FuseBox** ([nodejsdp.link/fusebox](http://nodejsdp.link/fusebox)),
    **Brunch** ([nodejsdp.link/brunch](http://nodejsdp.link/brunch)), and **Microbundle**
    ([nodejsdp.link/microbundle](http://nodejsdp.link/microbundle)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的模块打包器包括**FuseBox**([nodejsdp.link/fusebox](http://nodejsdp.link/fusebox))、**Brunch**([nodejsdp.link/brunch](http://nodejsdp.link/brunch))和**Microbundle**([nodejsdp.link/microbundle](http://nodejsdp.link/microbundle))。
- en: In the next section, we will discuss in greater detail how a module bundler
    works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地讨论模块打包器的工作原理。
- en: How a module bundler works
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块打包器的工作原理
- en: We can define a module bundler as a tool that takes the source code of an application
    (in the form of an entry module and its dependencies) and produces one or more
    bundle files. The bundling process doesn't change the business logic of the app;
    it just creates files that are optimized to run on the browser. In a way, we can
    think of a bundler as a compiler for the browser.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将模块打包器定义为一个工具，它接受应用程序的源代码（以入口模块及其依赖项的形式），并生成一个或多个打包文件。打包过程不会改变应用程序的业务逻辑；它只是创建了一些优化后可在浏览器上运行的文件。从某种意义上说，我们可以将打包器视为浏览器的编译器。
- en: In the previous section, we saw how a bundler can help to reduce the total number
    of files that the browser will need to load, but in reality, a bundler can do
    so much more than that. For instance, it can use a **transpiler** like **Babel**
    ([nodejsdp.link/babel](http://nodejsdp.link/babel)). A transpiler is a tool that
    processes the source code and makes sure that modern JavaScript syntax is converted
    into equivalent ECMAScript 5 syntax so that a large variety of browsers (including
    older ones) can run the application correctly. Some module bundlers allow us to
    preprocess and optimize not just JavaScript code but also other assets such as
    images and stylesheets.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了打包器如何帮助减少浏览器需要加载的文件总数，但事实上，打包器能做的远不止这些。例如，它可以使用 **转译器** 如 **Babel**
    ([nodejsdp.link/babel](http://nodejsdp.link/babel))。转译器是一个处理源代码的工具，确保现代 JavaScript
    语法被转换为等效的 ECMAScript 5 语法，以便各种浏览器（包括较旧的浏览器）能够正确运行应用程序。一些模块打包器允许我们预处理和优化不仅仅是 JavaScript
    代码，还包括其他资产，如图像和样式表。
- en: In this section, we will provide a simplified view of how a module bundler works
    and how it navigates the code of a given application to produce an equivalent
    bundle optimized for the browser. The work of a module bundler can be divided
    into two steps that we will call **dependency resolution** and **packing**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一个简化的视图，说明模块打包器是如何工作的，以及它是如何导航给定应用程序的代码以生成一个针对浏览器优化的等效包。模块打包器的工作可以分为两个步骤，我们将它们称为**依赖解析**和**打包**。
- en: Dependency resolution
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖解析
- en: The dependency resolution step has the goal of traversing the codebase, starting
    from the main module (also called the **entry point**), and discovering all the
    dependencies. The way a bundler can do this is by representing dependencies as
    an acyclic direct graph, known as a **dependency graph**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖解析步骤的目标是从主模块（也称为**入口点**）开始遍历代码库，发现所有依赖项。打包器可以这样做是通过将依赖项表示为一个无环直接图，称为**依赖图**。
- en: 'Let''s explore this concept with an example: a fictional calculator application.
    The implementation is intentionally incomplete as we only want to focus on the
    module structure, how the different modules depend on each other, and how the
    module bundler can build the dependency graph of this application:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来探讨这个概念：一个虚构的计算器应用程序。实现是有意不完整的，因为我们只想关注模块结构，不同的模块如何相互依赖，以及模块打包器如何构建这个应用程序的依赖图：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s see how the module bundler will walk through this code to figure out
    the dependency graph:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模块打包器如何遍历这段代码，以确定依赖图：
- en: 'The module bundler starts its analysis from the entry point of the application,
    the module `app.js`. In this phase, the module bundler will discover dependencies
    by looking at `import` statements. The bundler starts to scan the code of the
    entry point and the first `import` it finds references the `calculator.js` module.
    Now, the bundler suspends the analysis of `app.js` and jumps immediately into
    `calculator.js`. The bundler will keep tabs on the open files: it will remember
    that the first line of `app.js` was already scanned so that when it eventually
    restarts processing this file, it will continue from the second line.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块打包器从应用程序的入口点开始分析，即模块 `app.js`。在这个阶段，打包器将通过查看 `import` 语句来发现依赖项。打包器开始扫描入口点的代码，并找到的第一个
    `import` 引用了 `calculator.js` 模块。现在，打包器暂停对 `app.js` 的分析，并立即跳转到 `calculator.js`。打包器会跟踪打开的文件：它会记住
    `app.js` 的第一行已经被扫描，所以当它最终重新处理此文件时，它将从第二行继续。
- en: In `calculator.js`, the bundler immediately finds a new import for `parser.js`
    so that the processing of `calculator.js` is interrupted to move into `parser.js`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `calculator.js` 中，打包器立即找到一个对 `parser.js` 的新导入，因此 `calculator.js` 的处理被中断以跳转到
    `parser.js`。
- en: In `parser.js`, there's no `import` statement, so after the file has been scanned
    entirely, the bundler goes back into `calculator.js`, where the next `import`
    statement refers to `resolver.js`. Again, the analysis of `calculator.js` is suspended
    and the bundler jumps immediately into `resolver.js`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `parser.js` 中没有 `import` 语句，因此文件被完全扫描后，打包器会回到 `calculator.js`，在那里下一个 `import`
    语句引用了 `resolver.js`。再次，`calculator.js` 的分析被暂停，打包器立即跳转到 `resolver.js`。
- en: The module `resolver.js` does not contain any imports, so the control goes back
    to `calculator.js`. The `calculator.js` module does not contain other imports,
    so the control goes back to `app.js`. In `app.js`, the next import is `display.js`
    and the bundler jumps straight into it.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块`resolver.js`不包含任何导入，因此控制权返回到`calculator.js`。`calculator.js`模块不包含其他导入，因此控制权返回到`app.js`。在`app.js`中，下一个导入是`display.js`，打包器直接跳入其中。
- en: '`display.js` does not contain any imports. So, again the control goes back
    to `app.js`. There are no more imports in `app.js`, so the code has been fully
    explored, and the dependency graph has been fully constructed.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`display.js`不包含任何导入。因此，控制权再次返回到`app.js`。`app.js`中不再有其他导入，因此代码已经被完全探索，依赖关系图已经完全构建。'
- en: 'Every time the module bundler jumps from one file to another, it means we are
    discovering a new dependency and adding a new node to the dependency graph. A
    visual representation of the steps described in the preceding list can be found
    in *Figure 10.2*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每次模块打包器从一个文件跳转到另一个文件时，这意味着我们正在发现一个新的依赖关系并向依赖关系图中添加一个新的节点。前述步骤的视觉表示可以在*图10.2*中找到：
- en: '![../../../Downloads/Untitled%20Diagram%20(15).png](img/B15729_10_02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![../../../Downloads/Untitled%20Diagram%20(15).png](img/B15729_10_02.png)'
- en: 'Figure 10.2: Dependency graph resolution'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：依赖关系图解析
- en: This way of resolving dependencies also works with cyclic dependencies. In fact,
    if the bundler encounters the same dependency for a second time, the dependency
    will be skipped because it's already present in the dependency graph.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解析依赖关系的方式也适用于循环依赖。实际上，如果打包器遇到第二次相同的依赖项，该依赖项将被跳过，因为它已经在依赖图中存在。
- en: '**Tree shaking**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**摇树优化**'
- en: It's worth noting that if we have entities (for example, functions, classes,
    or variables) in our project modules that are never imported, then these won't
    appear in this dependency graph, so they won't be included in the final bundle.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果我们项目模块中有从未导入的实体（例如，函数、类或变量），那么这些实体不会出现在这个依赖关系图中，因此它们不会被包含在最终打包中。
- en: A more advanced module bundler could also keep track of the entities imported
    from every module and the exported entities found in the dependency graph. This
    allows the bundle to figure out if there are exported functionalities that are
    never used in the application so that they can be pruned from the final bundle.
    This optimization technique is called **tree shaking** ([nodejsdp.link/tree-shaking](http://nodejsdp.link/tree-shaking)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的模块打包器还可以跟踪从每个模块导入的实体和在依赖关系图中找到的导出实体。这允许打包器确定是否有在应用程序中从未使用过的导出功能，从而可以从最终打包中删除它们。这种优化技术称为**摇树优化**([nodejsdp.link/tree-shaking](http://nodejsdp.link/tree-shaking))。
- en: 'During the dependency resolution phase, the module bundler builds a data structure
    called **modules map**. This data structure is a hash map that has unique module
    identifiers (for example, file paths) as keys and a representation of the module
    source code as values. In our example, a simplified representation of the modules
    map might look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖关系解析阶段，模块打包器构建一个名为**模块映射**的数据结构。这个数据结构是一个哈希表，它以唯一的模块标识符（例如，文件路径）作为键，以模块源代码的表示作为值。在我们的例子中，模块映射的简化表示可能如下所示：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Every module in the modules map is a *factory function* that accepts two arguments:
    `module` and `require`. We will see in more detail what those arguments are in
    the next section. What is important to understand now is that every module here
    is a complete representation of the code in the original source module. If we
    take, for example, the code for the `calculator.js` module, it might be represented
    as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模块映射中的每个模块都是一个**工厂函数**，它接受两个参数：`module`和`require`。我们将在下一节中更详细地了解这些参数是什么。现在需要理解的是，这里的每个模块都是原始源模块中代码的完整表示。例如，如果我们取`calculator.js`模块的代码，它可能表示如下：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note how the ESM syntax has been converted into something that resembles the
    syntax of the CommonJS module system. Remember that the browser does not support
    CommonJS and that these variables are not global, so there is no risk of a naming
    collision here. In this simplified implementation, we decided to use exactly the
    same identifiers as in CommonJS (`module`, `require`, and `module.exports`) to
    make the similarity with CommonJS look more apparent. In reality, every module
    bundler will use its own unique identifiers. For instance, webpack uses identifiers
    such as `__webpack_require__` and `__webpack_exports__`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，ESM 语法已经被转换成类似于 CommonJS 模块系统的语法。记住，浏览器不支持 CommonJS，并且这些变量不是全局的，所以这里没有命名冲突的风险。在这个简化的实现中，我们决定使用与
    CommonJS 完全相同的标识符（`module`、`require` 和 `module.exports`），以便使与 CommonJS 的相似性更加明显。实际上，每个模块打包器都会使用它自己独特的标识符。例如，webpack
    使用 `__webpack_require__` 和 `__webpack_exports__` 这样的标识符。
- en: Packing
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打包
- en: 'The modules map is the final output of the dependency resolution phase. In
    the packing phase, the module bundler takes the modules map and converts it into
    an *executable bundle*: a single JavaScript file that contains all the business
    logic of the original application.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模块映射是依赖解析阶段的最终输出。在打包阶段，模块打包器将模块映射转换为 *可执行包*：一个包含原始应用程序所有业务逻辑的单个 JavaScript 文件。
- en: 'The idea is simple: we already have a representation of the original codebase
    of our application inside the modules map; we have to find a way to convert it
    into something that the browser can execute correctly and save it into the resulting
    bundle file.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们已经在模块映射中有了原始应用程序代码库的表示；我们必须找到一种方法将其转换为浏览器可以正确执行的内容，并将其保存到结果包文件中。
- en: 'Given the structure of our modules map, this can actually be done with just
    a few lines of code wrapping the modules map:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们模块映射的结构，这实际上只需要几行代码就可以完成，这些代码将模块映射包装起来：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is not a lot of code, but there''s a lot happening here, so let''s go
    through it together, step by step:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很多代码，但这里发生了很多事情，所以让我们一步一步地一起来看：
- en: In this code snippet, we have an **Immediately Invoked Function Expression**
    (**IIFE**) that receives the entire modules map as an argument.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们有一个接收整个模块映射作为参数的 **立即执行函数表达式**（**IIFE**）。
- en: When the function is executed, it defines a *custom* `require` function. This
    function receives a module `name` as input and it will load and execute the corresponding
    module from `modulesMap`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数执行时，它定义了一个 *自定义* 的 `require` 函数。这个函数接收一个模块 `name` 作为输入，并将从 `modulesMap` 中加载并执行相应的模块。
- en: In the `require` function, a `module` object is initialized. This object has
    only one property called `exports`, which is an object with no attributes.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `require` 函数中，初始化一个 `module` 对象。这个对象只有一个属性，叫做 `exports`，它是一个没有任何属性的普通对象。
- en: At this point, the factory function of the given module is invoked and we pass
    to it the `module` object we just created and a reference to the `require` function
    itself. Note that this is essentially an implementation of the Service Locator
    pattern ([nodejsdp.link/service-locator-pattern](http://nodejsdp.link/service-locator-pattern)).
    Here, the factory function, once executed, modifies the `module` object by attaching
    to it the functionality that the module exports. The factory function can also
    recursively require other modules by using the `require` function passed as an
    argument.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，给定模块的工厂函数被调用，我们向它传递我们刚刚创建的 `module` 对象以及 `require` 函数本身的引用。请注意，这本质上是一个服务定位器模式的实现（[nodejsdp.link/service-locator-pattern](http://nodejsdp.link/service-locator-pattern)）。在这里，一旦执行，工厂函数会通过附加模块导出的功能来修改
    `module` 对象。工厂函数还可以通过使用作为参数传递的 `require` 函数递归地要求其他模块。
- en: Finally, the `require` function returns the `module.exports` object, which was
    populated by the factory function that was invoked in the previous step.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`require` 函数返回 `module.exports` 对象，该对象由之前步骤中调用的工厂函数填充。
- en: The last step is to require the entry point of our dependency graph, which in
    our case is the module `app.js`. This last step is what actually bootstraps the
    entire application. In fact, by loading the entry point, it will, in turn, load
    and execute all its dependencies in the right order and then execute its own business
    logic.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是要求我们的依赖图入口点，在我们的例子中是模块 `app.js`。这一步实际上是启动整个应用程序的关键。实际上，通过加载入口点，它会依次加载并按正确顺序执行所有依赖项，然后执行自己的业务逻辑。
- en: With this process, we essentially created a self-sufficient module system that
    is capable of loading modules that have been properly organized within the same
    file. In other words, we managed to convert an app originally organized in multiple
    files into an equivalent app where all the code has been moved into a single file.
    This is the resulting bundle file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个过程，我们实际上创建了一个自给自足的模块系统，能够加载在同一文件中正确组织的模块。换句话说，我们成功地将原本组织在多个文件中的应用程序转换成了一个所有代码都移动到单个文件中的等效应用程序。这就是生成的包文件。
- en: Note that the preceding code has been intentionally simplified just to illustrate
    how module bundlers work. There are many edge cases that we did not take into
    account. For instance, what happens if we require a module that does not exist
    in the modules map?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码已被有意简化，只是为了说明模块打包器是如何工作的。有许多边缘情况我们没有考虑。例如，如果我们要求一个在模块映射中不存在的模块会发生什么？
- en: Using webpack
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 webpack
- en: Now that we know how a module bundler works, let's build a simple application
    that can work both on Node.js and on the browser. Throughout this exercise, we
    will learn how to write a simple library that can be used without changes from
    the browser app and the server app. We will be using webpack to build the browser
    bundle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了模块打包器是如何工作的，让我们构建一个既能在 Node.js 上运行也能在浏览器上运行的应用程序。在整个练习过程中，我们将学习如何编写一个简单的库，该库可以在浏览器应用程序和服务器应用程序中无需更改即可使用。我们将使用
    webpack 来构建浏览器包。
- en: To keep things simple, our application will be nothing more than a simple "hello
    world" for now, but don't worry, we will be building a more realistic application
    in the *Creating a Universal JavaScript app* section, later in this chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们的应用程序现在将只是一个简单的 "hello world"，但不用担心，我们将在本章后面的 *创建通用 JavaScript 应用程序*
    部分构建一个更真实的应用程序。
- en: 'Let''s start by installing the webpack CLI in our system with:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在我们的系统中安装 webpack CLI，使用以下命令：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s now initialize a new project in a new folder with:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个新文件夹中初始化一个新的项目，使用以下命令：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the guided project initialization is complete, since we want to use ESM
    in Node.js, we need to add the property `"type": "module"` to our `package.json`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦引导项目初始化完成，由于我们想在 Node.js 中使用 ESM，我们需要将属性 `"type": "module"` 添加到我们的 `package.json`
    中。'
- en: 'Now, we can run:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This guided procedure will install webpack in your project and it will help
    you to automatically generate a webpack configuration file. At the time of writing,
    using webpack 4, the guided procedure does not realize that we want to use ESM
    in Node.js, so we have to apply two small changes to the generated files:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此引导过程将在你的项目中安装 webpack，并帮助你自动生成一个 webpack 配置文件。在编写本文时，使用 webpack 4，引导过程没有意识到我们想在
    Node.js 中使用 ESM，因此我们必须对生成的文件进行两个小的修改：
- en: Rename `webpack.config.js` to `webpack.config.cjs`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `webpack.config.js` 重命名为 `webpack.config.cjs`
- en: 'Change the following npm scripts in `package.json`:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `package.json` 中的以下 npm 脚本：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we are ready to start writing our application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始编写我们的应用程序。
- en: 'Let''s first write the module we want to share in `src/say-hello.js`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先编写我们想要在 `src/say-hello.js` 中共享的模块：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code, we are using the `nunjucks` template library ([nodejsdp.link/nunjucks](http://nodejsdp.link/nunjucks)),
    which must be installed with npm. This module is exporting a simple `sayHello`
    function that accepts a `name` as the only argument and uses it to construct an
    HTML string.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用了 `nunjucks` 模板库（[nodejsdp.link/nunjucks](http://nodejsdp.link/nunjucks)），该库必须使用
    npm 安装。此模块导出了一个简单的 `sayHello` 函数，它接受一个 `name` 作为唯一参数，并使用它来构造一个 HTML 字符串。
- en: 'Let''s now write the browser application that will use this module (`src/index.js`):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写将使用此模块（`src/index.js`）的浏览器应用程序：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code uses the `sayHello` function to build an HTML fragment saying *Hello
    Browser* and then inserts it into the `body` section of the current HTML page.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用 `sayHello` 函数构建一个表示 *Hello Browser* 的 HTML 片段，并将其插入到当前 HTML 页面的 `body`
    部分。
- en: If you want to preview this application, you can run `npm start` in your terminal.
    This should open your default browser and you should see the application running.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要预览这个应用程序，你可以在终端中运行 `npm start`。这应该会打开你的默认浏览器，你应该能看到应用程序正在运行。
- en: 'If you want to generate a static version of the application, you can run:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想生成应用程序的静态版本，你可以运行：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will generate a folder called `dist` containing two files: an `index.html`
    and our bundle file (whose name will look like `main.12345678901234567890.js`).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `dist` 的文件夹，包含两个文件：一个 `index.html` 和我们的包文件（其名称将类似于 `main.12345678901234567890.js`）。
- en: The file name of the bundle is generated by using a hash of the file content.
    This way, every time our source code changes, we will obtain a new bundle with
    a different name. This is a useful optimization technique, called **cache busting**,
    that webpack adopts by default and it is particularly convenient when deploying
    our assets to a **content delivery network** (**CDN**). With CDNs, it is generally
    quite expensive to override files that are geographically distributed across multiple
    servers and already cached in multiple layers, possibly including our users' browsers.
    By generating new files with every change, we avoid cache invalidation entirely.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 打包文件的名称是通过使用文件内容的哈希值生成的。这样，每次我们的源代码发生变化时，我们都会获得一个具有不同名称的新打包文件。这是一种有用的优化技术，称为**缓存破坏**，webpack默认采用，当我们将资产部署到**内容分发网络**（**CDN**）时尤其方便。使用CDN，通常在多个服务器上地理分布并已在多个层级中缓存的文件进行覆盖是非常昂贵的。通过每次更改生成新文件，我们可以完全避免缓存失效。
- en: You can open the `index.html` file with your browser to see a preview of your
    application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用浏览器打开`index.html`文件来查看您应用程序的预览。
- en: If you are curious, you can have a look at the generated bundle file. You will
    notice that it is a bit more convoluted and verbose than the sample bundle we
    illustrated in the previous section. However, you should be able to recognize
    the structure and notice that the entire `nunjucks` library, as well as our `sayHello`
    module, have been embedded in the bundle code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，您可以查看生成的打包文件。您会注意到，它比上一节中展示的示例打包文件要复杂和冗长一些。然而，您应该能够识别其结构，并注意到整个`nunjucks`库以及我们的`sayHello`模块都已嵌入到打包代码中。
- en: 'Now, what if we want to build an equivalent application that runs in Node.js?
    For instance, we could use the `sayHello` function and display the resulting code
    in the terminal:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想构建一个在Node.js上运行的等效应用程序，会怎样呢？例如，我们可以使用`sayHello`函数并在终端中显示结果代码：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's it!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'If we run this code with:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下方式运行此代码：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will see the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Yes, displaying HTML in the terminal is not particularly useful, but right now
    we achieved our goal of being able to use a library from both the browser and
    the server without any changes in the library codebase.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，在终端中显示HTML并不特别有用，但到目前为止，我们已经实现了使用来自浏览器和服务器端库的目标，而无需对库代码库进行任何更改。
- en: In the next sections, we will discuss some patterns that allow us to actually
    change the code where necessary if we want to provide more specialized behaviors
    on the browser or Node.js.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论一些模式，允许我们在必要时实际更改代码，如果我们想在浏览器或Node.js上提供更专业的行为。
- en: Fundamentals of cross-platform development
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台开发基础
- en: When developing for different platforms, the most common problem we face is
    how can we reuse as much code as possible and, at the same time, provide specialized
    implementations for details that are platform-specific. We will now explore some
    of the principles and the patterns to use when facing this challenge, such as
    code branching and module swapping.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在为不同的平台开发时，我们面临的最常见问题是：我们如何尽可能多地重用代码，同时为特定平台的细节提供专门的实现。现在，我们将探讨一些面对这一挑战时可以使用的原则和模式，例如代码分支和模块交换。
- en: Runtime code branching
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时代码分支
- en: The most simple and intuitive technique for providing different implementations
    based on the host platform is to dynamically branch our code. This requires that
    we have a mechanism to recognize the host platform at runtime and then dynamically
    switch the implementation with an `if...else` statement. Some generic approaches
    involve checking global variables that are available only on Node.js or only on
    the browser.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据主机平台提供不同实现的最简单和直观的技术是动态分支我们的代码。这需要我们有一个机制在运行时识别主机平台，然后使用`if...else`语句动态切换实现。一些通用方法包括检查仅在Node.js上或仅在浏览器上可用的全局变量。
- en: 'For example, we can check the existence of the `window` global variable. Let''s
    modify our `say-hello.js` module to use this technique to provide a slightly different
    functionality depending on whether the module is running on the browser or on
    the server:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以检查`window`全局变量的存在。让我们修改我们的`say-hello.js`模块，使用这种技术根据模块是在浏览器上还是在服务器上运行提供略有不同的功能：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The escape sequence `\u001b[1m` is a special terminal formatting indicator
    that sets the text to bold. The sequence `\u001b[0m` instead resets the formatting
    to normal. If you are curious to find out more about escape sequences and their
    history, check out ANSI escape sequences: [nodejsdp.link/ansi-escape-sequences](http://nodejsdp.link/ansi-escape-sequences).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 转义序列 `\u001b[1m` 是一个特殊的终端格式化指示符，用于将文本设置为粗体。序列 `\u001b[0m` 则将格式重置为正常。如果你对转义序列及其历史感兴趣，可以查看
    ANSI 转义序列：[nodejsdp.link/ansi-escape-sequences](http://nodejsdp.link/ansi-escape-sequences)。
- en: Try again to run our application on Node.js and on the browser and see the differences!
    If you do that, you will not see HTML code on the terminal when running the Node.js
    application. Instead, you will see a string with proper terminal formatting. The
    frontend application on the browser remains unchanged.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试在 Node.js 和浏览器上运行我们的应用程序，看看差异！如果你这样做，当运行 Node.js 应用程序时，你将在终端上看到 HTML 代码。相反，你将看到一个带有适当终端格式的字符串。浏览器上的前端应用程序保持不变。
- en: Challenges of runtime code branching
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时代码分支的挑战
- en: 'Using a runtime branching approach for switching between Node.js and the browser
    is definitely the most intuitive and simple pattern we can use for this purpose;
    however, there are some inconveniences:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运行时分支方法在 Node.js 和浏览器之间切换无疑是实现这一目的最直观和简单的方式；然而，也有一些不便之处：
- en: The code for both platforms is included in the same module and therefore in
    the final bundle. This increases the bundle size, adding unreachable and unnecessary
    code. It is also possible that the unreachable code contains sensitive information
    like encryption keys or API keys that are not meant to be sent to a user's browser.
    In this case, this approach might also raise significant security concerns.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个平台的代码都包含在同一个模块中，因此也在最终的包中。这增加了包的大小，添加了不可达且不必要的代码。还可能存在这种情况，不可达的代码包含敏感信息，如加密密钥或不应发送到用户浏览器的
    API 密钥。在这种情况下，这种方法可能会引起重大的安全担忧。
- en: If used too extensively, it can considerably reduce the readability of the code,
    as the business logic would be mixed with logic meant only to add cross-platform
    compatibility.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果过度使用，这可能会显著降低代码的可读性，因为业务逻辑将与仅用于添加跨平台兼容性的逻辑混合。
- en: 'Using dynamic branching to load a different module, depending on the platform,
    will result in all the modules being added to the final bundle, regardless of
    their target platform. For example, if we consider the following code fragment,
    both `clientModule` and `serverModule` will be included in a bundle generated
    with webpack, unless we explicitly exclude one of them from the build:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态分支来根据平台加载不同的模块，会导致所有模块都被添加到最终的包中，无论它们的目标平台是什么。例如，如果我们考虑以下代码片段，`clientModule`
    和 `serverModule` 都将包含在用 webpack 生成的包中，除非我们明确地从构建中排除其中一个：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This last inconvenience happens because of the following reasons:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最后的不便是由于以下原因：
- en: Bundlers have no sure way of knowing the value of a runtime variable at build
    time (unless the variable is a constant), so, in the preceding example, both branches
    of the `if...else` statement are always included in the final bundle, even though
    it is obvious that the browser will always execute only one of them.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包器没有确定的方式在构建时知道运行时变量的值（除非该变量是常量），因此，在前面的例子中，`if...else` 语句的两个分支总是包含在最终的包中，尽管很明显浏览器将始终只执行其中一个。
- en: ES module imports are always defined declaratively at the top of the file and
    we don't have a way to filter the imports based on the current environment. The
    bundler will not try to understand whether you are conditionally using only a
    subset of the imported feature and it will include all the imported code anyway.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES 模块导入始终在文件顶部声明性定义，我们没有根据当前环境过滤导入的方法。打包器不会尝试理解你是否仅条件性地使用导入功能的一个子集，它仍然会包含所有导入的代码。
- en: 'A consequence of this last property is that modules imported dynamically using
    variables are not included in the bundle. For example, from the following code,
    no module will be bundled:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后特性的一个后果是，使用变量动态导入的模块不会被包含在包中。例如，从以下代码中，没有任何模块会被打包：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It''s worth underlining that webpack overcomes some of these limitations and,
    under certain specific circumstances, it is able to guess all the possible values
    for a dynamic requirement. For instance, if you have a snippet of code like the
    following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，webpack克服了一些这些限制，并在某些特定情况下，能够猜测动态需求的全部可能值。例如，如果你有一段如下所示的代码片段：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Webpack will include all the modules available in the `controller` folder in
    the final bundle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack将包括`controller`文件夹中所有可用的模块到最终的包中。
- en: It's highly recommended to have a look at the official documentation to understand
    all the supported cases ([nodejsdp.link/webpack-dynamic-imports](http://nodejsdp.link/webpack-dynamic-imports)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 高度推荐查看官方文档，以了解所有支持的案例([nodejsdp.link/webpack-dynamic-imports](http://nodejsdp.link/webpack-dynamic-imports))。
- en: Build-time code branching
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建时代码分支
- en: In this section, we are going to see how to use webpack plugins to remove, at
    build time, all parts of the code that we want to run only on the server. This
    allows us to obtain lighter bundle files and to avoid accidentally exposing code
    containing sensible information (for instance, secrets, passwords, or API keys)
    that should only live on the server.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用webpack插件在构建时移除我们只想在服务器上运行的代码的所有部分。这使我们能够获得更轻的包文件，并避免意外暴露包含敏感信息（例如，机密信息、密码或API密钥）的代码，这些信息只应存在于服务器上。
- en: Webpack offers support for plugins, which allows us to extend webpack's capabilities
    and add new processing steps that can be used to produce the bundle file. To perform
    build-time code branching, we can leverage a built-in plugin called `DefinePlugin`
    and a third-party plugin called `terser-webpack-plugin` ([nodejsdp.link/terser-webpack](http://nodejsdp.link/terser-webpack)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack提供了对插件的支持，这允许我们扩展webpack的功能，并添加新的处理步骤，这些步骤可以用于生成包文件。为了执行构建时代码分支，我们可以利用一个内置插件`DefinePlugin`和一个第三方插件`terser-webpack-plugin`([nodejsdp.link/terser-webpack](http://nodejsdp.link/terser-webpack))。
- en: '`DefinePlugin` can be used to replace specific code occurrences in our source
    files with custom code or variables. `terser-webpack-plugin` allows us to compress
    the resulting code and remove unreachable statements (**dead code elimination**).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefinePlugin`可用于用自定义代码或变量替换我们的源文件中的特定代码出现。`terser-webpack-plugin`允许我们压缩生成的代码并删除不可达的语句（**死代码消除**）。'
- en: 'Let''s start by rewriting our `say-hello.js` module to explore these concepts:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先重写我们的`say-hello.js`模块，以探索这些概念：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we are checking for the existence of a generic variable called `__BROWSER__`
    to enable the browser code. This is the variable that we will replace at build
    time using `DefinePlugin`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在检查一个名为`__BROWSER__`的通用变量的存在，以启用浏览器代码。这是我们在构建时使用`DefinePlugin`替换的变量。
- en: 'Now, let''s install `terser-webpack-plugin` with:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令安装`terser-webpack-plugin`：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, let''s update our `webpack.config.cjs` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新我们的`webpack.config.cjs`文件：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first change here is to set the option `mode` to `production`. This option
    will enable optimizations such as code **minification** (or minimization). Optimization
    options are defined in the dedicated `optimization` object. Here, we are enabling
    minification by setting `minimize` to `true` and we are providing a new instance
    of `terser-webpack-plugin` as the minimizer. Finally, we are also adding `webpack.DefinePlugin`
    and configuring it to replace the string `__BROWSER__` with the value `true`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个更改是将`mode`选项设置为`production`。此选项将启用诸如代码**压缩**（或最小化）之类的优化。优化选项定义在专门的`optimization`对象中。在这里，我们通过将`minimize`设置为`true`来启用压缩，并提供一个新的`terser-webpack-plugin`实例作为最小化器。最后，我们还添加了`webpack.DefinePlugin`并配置它将字符串`__BROWSER__`替换为值`true`。
- en: Every value in the configuration object of `DefinePlugin` represents a piece
    of code that will be evaluated by webpack at build time and then used to replace
    the currently matched snippet of code. This allows us to add external dynamic
    values containing, for instance, the content of an environment variable, the current
    timestamp, or the hash of the last git commit to the bundle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefinePlugin`的配置对象中的每个值都代表一段代码，webpack将在构建时评估该代码，然后用于替换当前匹配的代码片段。这使我们能够向包中添加外部动态值，例如，包含环境变量内容、当前时间戳或最后git提交的哈希值。'
- en: With this configuration, when we build a new bundle, every occurrence of `__BROWSER__` is
    replaced with `true`. The first `if` statement will internally look like `if (true
    !== 'undefined')`, but webpack is smart enough to understand that this expression
    will always be evaluated as `true`, so it transforms the resulting code again
    into `if (true)`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种配置，当我们构建一个新的包时，`__BROWSER__`的每个出现都将被替换为`true`。第一个`if`语句在内部看起来像`if (true
    !== 'undefined')`，但webpack足够智能，能够理解这个表达式将始终评估为`true`，因此它将生成的代码再次转换成`if (true)`。
- en: 'Once webpack has finished processing all the code, it will invoke `terser-webpack-plugin`
    to minimize the resulting code. `terser-webpack-plugin` is a wrapper around Terser
    ([nodejsdp.link/terser](http://nodejsdp.link/terser)), a modern JavaScript minifier.
    Terser is capable of removing dead code as part of its minimization algorithm,
    so given that, at this stage, our code will look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦webpack处理完所有代码，它将调用`terser-webpack-plugin`来最小化生成的代码。`terser-webpack-plugin`是Terser（[nodejsdp.link/terser](http://nodejsdp.link/terser)）的一个包装器，Terser是一个现代的JavaScript压缩器。Terser能够在其最小化算法中删除死代码，因此在这个阶段，我们的代码将看起来像这样：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Terser will reduce it to:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Terser将将其缩减为：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This way, we got rid of all the server-side code in our browser bundle.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们就从浏览器包中移除了所有的服务器端代码。
- en: Even if build-time code branching is way better than runtime code branching
    because it produces much leaner bundle files, it can still make our source code
    cumbersome when abused. In fact, if you overuse this technique, you will end up
    with code that contains too many `if` statements, which will be hard to understand
    and debug.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 即使构建时代码分支比运行时代码分支要好得多，因为它会产生更精简的包文件，但如果过度使用，它仍然会使我们的源代码变得复杂。事实上，如果你过度使用这种技术，你最终会得到包含太多`if`语句的代码，这将很难理解和调试。
- en: When this happens, it is generally better to move all the platform-specific
    code into dedicated modules. We will discuss this alternative approach in the
    next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，通常最好将所有平台特定的代码移动到专用模块中。我们将在下一节讨论这种替代方法。
- en: Module swapping
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块交换
- en: Most of the time, we already know at build time what code has to be included
    in the client bundle and what shouldn't. This means that we can take this decision
    upfront and instruct the bundler to replace the implementation of an entire module
    at build time. This often results in a leaner bundle, as we are excluding unnecessary
    modules, and more readable code because we don't have all the `if...else` statements
    required by runtime and build-time branching.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们在构建时已经知道哪些代码需要包含在客户端包中，哪些不应该包含。这意味着我们可以提前做出这个决定，并指示打包器在构建时替换整个模块的实现。这通常会导致更精简的包，因为我们排除了不必要的模块，并且代码的可读性更高，因为我们不需要所有由运行时和构建时分支所需的`if...else`语句。
- en: Let's find out how to adopt module swapping with webpack by updating our example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新示例来了解如何采用模块交换（module swapping）的方式使用webpack。
- en: 'The main idea is that we want to have two separate implementations of our `sayHello`
    functionality: one optimized for the server (`say-hello.js`) and one optimized
    for the browser (`say-hello-browser.js`). We will then tell webpack to replace
    any import of `say-hello.js` with `say-hello-browser.js`. Let''s see what our
    new implementation looks like now:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是我们希望有两个独立的`sayHello`功能实现：一个针对服务器优化（`say-hello.js`）和一个针对浏览器优化（`say-hello-browser.js`）。然后我们将告诉webpack将任何对`say-hello.js`的导入替换为`say-hello-browser.js`。现在让我们看看新的实现看起来像什么：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that, on the server-side version, we introduced a new dependency, `chalk`
    ([nodejsdp.link/chalk](http://nodejsdp.link/chalk)), a utility library that allows
    us to format text for the terminal. This is to demonstrate one of the main advantages
    of this approach. Now that we''ve separated our server-side code from the client-side
    code, we can introduce new functionalities and libraries without worrying about
    the impact that those might have on the frontend-only bundle. At this point, in
    order to tell webpack to swap the modules at build time, we have to replace `webpack.DefinePlugin`
    with a new plugin in our `webpack.config.cjs`, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在服务器端版本中，我们引入了一个新的依赖项，`chalk`（[nodejsdp.link/chalk](http://nodejsdp.link/chalk)），这是一个实用库，允许我们在终端中格式化文本。这是为了展示这种方法的主要优势之一。现在，由于我们已经将服务器端代码与客户端代码分离，我们可以引入新的功能和库，而不用担心这些可能会对仅包含前端代码的包产生的影响。在这个阶段，为了告诉webpack在构建时交换模块，我们必须在我们的`webpack.config.cjs`中将`webpack.DefinePlugin`替换为一个新的插件，如下所示：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are using `webpack.NormalModuleReplacementPlugin`, which accepts two arguments.
    The first argument is a regular expression and the second one is a string representing
    a path to a resource. At build time, if a module path matches the given regular
    expression, it is replaced with the one provided in the second argument.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `webpack.NormalModuleReplacementPlugin`，它接受两个参数。第一个参数是一个正则表达式，第二个参数是一个表示资源路径的字符串。在构建时，如果一个模块路径与给定的正则表达式匹配，它将被第二个参数提供的替换。
- en: Note that this technique is not limited to our internal modules, but it can
    also be used with external libraries in our `node_modules` folder.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种技术不仅限于我们的内部模块，也可以用于我们的 `node_modules` 文件夹中的外部库。
- en: Thanks to webpack and the module replacement plugin, we can easily deal with
    structural differences between platforms. We can focus on writing separate modules
    that are meant to provide platform-specific code and we can then swap Node.js-only
    modules with browser-specific ones in the final bundle.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 webpack 和模块替换插件，我们可以轻松处理平台之间的结构差异。我们可以专注于编写旨在提供平台特定代码的单独模块，然后我们可以在最终捆绑包中将仅适用于
    Node.js 的模块与浏览器特定的模块进行交换。
- en: Design patterns for cross-platform development
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台开发的设计模式
- en: 'Let''s now revise some of the design patterns we discussed in the previous
    chapters to see how we can leverage those for cross-platform development:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下在前几章中讨论的一些设计模式，看看我们如何可以利用这些模式进行跨平台开发：
- en: '**Strategy and template**: These two are probably the most useful patterns
    when sharing code with the browser. Their intent is, in fact, to define the common
    steps of an algorithm, allowing some of its parts to be replaced, which is exactly
    what we need! In cross-platform development, these patterns allow us to share
    the platform-agnostic part of our components, while allowing their platform-specific
    parts to be changed using a different strategy or template method (which can be
    changed using code branching (runtime or build-time) or module swapping).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略和模板**: 这两个模式在共享代码到浏览器时可能是最有用的。它们的意图实际上是为了定义算法的通用步骤，允许其部分被替换，这正是我们所需要的！在跨平台开发中，这些模式允许我们共享组件的平台无关部分，同时允许它们的平台特定部分通过不同的策略或模板方法（可以通过代码分支（运行时或构建时）或模块交换来更改）进行更改。'
- en: '**Adapter**: This pattern is probably the most useful when we need to swap
    an entire component. We have already seen several examples in *Chapter 8*, *Structural
    Design Patterns*. If your server application is using a database like SQLite,
    you could use the Adapter pattern to provide an alternative data storage implementation
    that works in the browser. For instance you could use the `localStorage` API ([nodejsdp.link/localstorage](http://nodejsdp.link/localstorage))
    or the `IndexedDB` API ([nodejsdp.link/indexdb](http://nodejsdp.link/indexdb)).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器模式**: 当我们需要替换整个组件时，这个模式可能是最有用的。我们已经在 *第8章*，*结构型设计模式* 中看到了几个例子。如果你的服务器应用程序正在使用像
    SQLite 这样的数据库，你可以使用适配器模式来提供一个在浏览器中工作的替代数据存储实现。例如，你可以使用 `localStorage` API ([nodejsdp.link/localstorage](http://nodejsdp.link/localstorage))
    或 `IndexedDB` API ([nodejsdp.link/indexdb](http://nodejsdp.link/indexdb))。'
- en: '**Proxy**: When code meant to run on the server runs on the browser, we often
    need functionality that is used on the server to be available on the browser as
    well. This is where the *remote* Proxy pattern is useful. Imagine if we wanted
    to access the filesystem of the server from the browser: we could think of creating
    an `fs` object on the client that proxies every call to the `fs` module living
    on the server, using Ajax or WebSockets as a way of exchanging commands and return
    values.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**: 当代码打算在服务器上运行但在浏览器上运行时，我们通常需要服务器上使用的功能也出现在浏览器上。这就是远程代理模式有用的地方。想象一下，如果我们想从浏览器访问服务器的文件系统：我们可以在客户端创建一个
    `fs` 对象，它代理对服务器上 `fs` 模块的每个调用，使用 Ajax 或 WebSocket 作为交换命令和返回值的方式。'
- en: '**Dependency injection and service locator**: Both dependency injection and
    service locator can be useful to replace the implementation of a module at the
    moment of its injection. When we introduced the concept of modules maps, in the
    *Packing* section, we also saw how the Service Locator pattern was intrinsically
    used by module bundlers to collate all the code from different modules into one
    file.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入和服务定位器**: 依赖注入和服务定位器都可以在模块注入时替换模块的实现。当我们介绍模块映射的概念时，在 *打包* 部分，我们也看到了服务定位器模式如何被模块打包器内在地使用，以将来自不同模块的所有代码收集到一个文件中。'
- en: As we can see, the arsenal of patterns at our disposal is quite powerful, but
    the most powerful weapon is still the ability of the developer to choose the best
    approach and adapt it to the specific problem at hand.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可用的模式库非常强大，但最强大的武器仍然是开发者选择最佳方法并将其适应特定问题的能力。
- en: Now that we understand the fundamentals of module bundlers and we have learned
    a number of useful patterns to write cross-platform code, we are ready to move
    into the second part of this chapter, where we will learn about React and write
    our first universal JavaScript application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模块打包器的原理，并且学习了许多编写跨平台代码的有用模式，我们准备进入本章的第二部分，我们将学习 React 并编写我们的第一个通用
    JavaScript 应用程序。
- en: A brief introduction to React
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 简介简述
- en: React is a popular JavaScript library created and maintained by Facebook. React
    is focused on providing a comprehensive set of functions and tools to build the
    view layer in web applications. React offers a view abstraction focused on the
    concept of a **component**. A component could be a button, a form input, a simple
    container such as an HTML `div`, or any other element in your user interface.
    The idea is that you should be able to construct the user interface of your application
    by just defining and composing highly reusable components with specific responsibilities.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: React 是由 Facebook 创建和维护的一个流行的 JavaScript 库。React 专注于提供一套全面的函数和工具，用于构建 Web 应用程序的用户视图层。React
    提供了一个基于 **组件** 概念的视图抽象。一个组件可以是按钮、表单输入、简单的容器，如 HTML `div`，或者用户界面中的任何其他元素。理念是，你应该能够通过定义和组合具有特定职责的高度可重用组件来构建应用程序的用户界面。
- en: What makes React different from other view libraries for the web is that it
    is not bound to the DOM by design. In fact, it provides a high-level abstraction
    called the **virtual DOM** ([nodejsdp.link/virtual-dom](http://nodejsdp.link/virtual-dom))
    that fits very well with the web but that can also be used in other contexts,
    for example, for building mobile apps, modeling 3D environments, or even defining
    the interaction between hardware components. In simple terms, the virtual DOM
    can be seen as an efficient way to re-render data organized in a tree-like structure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使 React 与其他 Web 视图库不同的地方在于，它不是通过设计绑定到 DOM 上。实际上，它提供了一个称为 **虚拟 DOM** 的高级抽象（[nodejsdp.link/virtual-dom](http://nodejsdp.link/virtual-dom)），它与
    Web 非常契合，但也可以用于其他上下文，例如，用于构建移动应用、模拟 3D 环境，甚至定义硬件组件之间的交互。简单来说，虚拟 DOM 可以被视为一种高效地重新渲染以树状结构组织的数据的方法。
- en: '"Learn it once, use it everywhere."'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"一次学习，处处可用。"'
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Facebook
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——Facebook
- en: This is the motto used by Facebook to introduce React. It intentionally mocks
    the famous Java motto *Write it once, run it everywhere* with the clear intention
    to underline a fundamental shift from the Java philosophy. The original design
    goal of Java was to allow developers to write applications once and run them on
    as many platforms as possible without changes. Conversely, the React philosophy
    acknowledges that every platform is inherently different and therefore encourages
    developers to write different applications that are optimized for the related
    target platform. React, as a library, shifts its focus on providing *convenient*
    design and architecture principles and tools that, once mastered, can be easily
    used to write platform-specific code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Facebook 用来介绍 React 的口号。它故意模仿了著名的 Java 口号 *一次编写，到处运行*，明确地强调从 Java 哲学到根本转变。Java
    的原始设计目标是允许开发者编写一次应用程序，并在尽可能多的平台上运行而无需更改。相反，React 哲学承认每个平台本质上都是不同的，因此鼓励开发者编写针对相关目标平台优化的不同应用程序。作为一个库，React
    将其重点转移到提供 *方便* 的设计和架构原则以及工具，一旦掌握，就可以轻松用于编写特定平台的代码。
- en: 'If you are curious to learn about the applications of React in contexts not
    strictly related to the field of web development, you can have a look at the following
    projects: **React Native** for mobile apps ([nodejsdp.link/react-native](http://nodejsdp.link/react-native)),
    **React PIXI** for 2D rendering with OpenGL ([nodejsdp.link/react-pixi](http://nodejsdp.link/react-pixi)),
    **react-three-fiber** to create 3D scenes ([nodejsdp.link/react-three-fiber](http://nodejsdp.link/react-three-fiber)),
    and **React Hardware** ([nodejsdp.link/react-hardware](http://nodejsdp.link/react-hardware)).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对React在严格不限于Web开发领域的应用感兴趣，可以查看以下项目：**React Native**用于移动应用([nodejsdp.link/react-native](http://nodejsdp.link/react-native))、**React
    PIXI**用于OpenGL的2D渲染([nodejsdp.link/react-pixi](http://nodejsdp.link/react-pixi))、**react-three-fiber**用于创建3D场景([nodejsdp.link/react-three-fiber](http://nodejsdp.link/react-three-fiber))以及**React
    Hardware**([nodejsdp.link/react-hardware](http://nodejsdp.link/react-hardware))。
- en: The main reason why React is so interesting in the context of Universal JavaScript
    development is because it allows us to render React components both on the client
    and on the server using almost the same code. To put it another way, with React,
    we are able to render the HTML code that is required to display the page directly
    from Node.js. Then, when the page is loaded on the browser, React will perform
    a process called **hydration** ([nodejsdp.link/hydration](http://nodejsdp.link/hydration)),
    which will add all the frontend-only side effects like click handlers, animations,
    additional asynchronous data fetching, dynamic routing, and so on. Hydration converts
    a static markup into a fully interactive experience.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: React在通用JavaScript开发环境中之所以如此有趣，主要原因是它允许我们使用几乎相同的代码在客户端和服务器上渲染React组件。换句话说，使用React，我们能够直接从Node.js中渲染显示页面所需的HTML代码。然后，当页面在浏览器上加载时，React将执行一个称为**水合**（[nodejsdp.link/hydration](http://nodejsdp.link/hydration)）的过程，这将添加所有仅在前端存在的副作用，如点击处理程序、动画、额外的异步数据获取、动态路由等。水合将静态标记转换为完全交互式的体验。
- en: This approach allows us to build **single-page applications** (**SPAs**), where
    the first render happens mostly on the server, but then, once the page is loaded
    on the browser and the user starts to click around, only the parts of the page
    that need to be changed are dynamically refreshed, without requiring a full page
    reload.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们构建**单页应用**（**SPAs**），其中第一次渲染主要在服务器上发生，但一旦页面在浏览器上加载并且用户开始点击，只需要动态刷新需要更改的页面部分，而不需要完全重新加载页面。
- en: 'This design offers two main advantages:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计提供了两个主要优势：
- en: '**Better search engine optimization (SEO)**: Since the page markup is pre-rendered
    by the server, various search engines can make sense of the content of the page
    by just looking at the HTML returned by the server. They won''t need to simulate
    a browser environment and wait for the page to be fully loaded to see what a given
    page is about.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的搜索引擎优化（SEO）**：由于页面标记是由服务器预先渲染的，各种搜索引擎可以通过查看服务器返回的HTML来理解页面内容。他们不需要模拟浏览器环境并等待页面完全加载来了解给定页面的内容。'
- en: '**Better performance**: Since we are pre-rendering the markup, this will be
    already available and visible on the browser, even while the browser is still
    downloading, parsing, and executing the JavaScript code included with the page.
    This approach can lead to a better user experience as the content is perceived
    to load faster and there are less browser "flashes" during rendering.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的性能**：由于我们预先渲染了标记，因此即使在浏览器仍在下载、解析和执行页面中包含的JavaScript代码时，它也将已经可用并可见。这种方法可以带来更好的用户体验，因为内容看起来加载得更快，在渲染过程中浏览器“闪烁”也更少。'
- en: It is worth mentioning that the React virtual DOM is capable of optimizing the
    way changes are rendered. This means that the DOM is not rendered in full after
    every change, but instead React uses a smart in-memory diffing algorithm that
    is able to pre-calculate the minimum number of changes to apply to the DOM in
    order to update the view. This results in a very efficient mechanism for fast
    browser rendering.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，React虚拟DOM能够优化渲染更改的方式。这意味着在每次更改后，DOM不会完全重新渲染，而是React使用一个智能的内存diffing算法，能够预先计算出应用于DOM的最小更改数以更新视图。这导致了一种非常高效的机制，用于快速浏览器渲染。
- en: Now that we know what React is, in the next section, we will write our first
    React component!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了React是什么，在下一节中，我们将编写我们的第一个React组件！
- en: Hello React
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello React
- en: Without further ado, let's start to use React and jump to a concrete example.
    This will be a "Hello World" type of example but it will help us to illustrate
    the main ideas behind React, before we move onto more realistic examples.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们开始使用 React 并跳到一个具体的例子。这将会是一个 "Hello World" 类型的例子，但它在我们将要转向更实际的例子之前，将帮助我们阐明
    React 的主要思想。
- en: 'Let''s start by creating a new webpack project in a new folder with:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在新的文件夹中创建一个新的 webpack 项目开始，使用以下命令：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, follow the guided instructions. Now, let''s install React:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照引导说明操作。现在，让我们安装 React：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s create a file, `src/index.js`, with the following content:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个文件，`src/index.js`，并包含以下内容：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s review what''s happening with this code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这段代码正在发生什么：
- en: The first thing that we do is to create a handy alias for the `react.createElement`
    function. We will be using this function a couple of times in this example to
    create React elements. These could be plain DOM nodes (regular HTML tags) or instances
    of React components.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先做的是为 `react.createElement` 函数创建一个方便的别名。在这个例子中，我们将多次使用这个函数来创建 React 元素。这些可以是普通的
    DOM 节点（常规 HTML 标签）或 React 组件的实例。
- en: Now, we define our `Hello` component, which has to extend the `react.Component`
    class.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义我们的 `Hello` 组件，它必须扩展 `react.Component` 类。
- en: Every React component has to implement a `render()` method. This method defines
    how the component will be displayed on the screen when it is rendered on the DOM
    and it has to return a React element.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 React 组件都必须实现一个 `render()` 方法。这个方法定义了当组件在 DOM 上渲染时，它将在屏幕上如何显示，并且它必须返回一个 React
    元素。
- en: We are using the `react.createElement` function to create an `h1` DOM element.
    This method expects three or more arguments. The first argument is the tag name
    (as a string) or a React component class. The second argument is an object used
    to pass attributes (or **props**) to the component (or `null` if we don't need
    to specify any attribute). Finally, the third argument is an array (or you can
    pass multiple arguments as well) of children elements. Elements can also be text
    (text nodes), as in our current example.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `react.createElement` 函数来创建一个 `h1` DOM 元素。这个方法期望有三个或更多的参数。第一个参数是标签名（作为字符串）或一个
    React 组件类。第二个参数是一个对象，用于将属性（或 **props**）传递给组件（或 `null` 如果我们不需要指定任何属性）。最后，第三个参数是一个数组（或者你也可以传递多个参数），包含子元素。元素也可以是文本（文本节点），就像我们当前的例子一样。
- en: Here, we are using `this.props` to access the attributes that are passed to
    this component at runtime. In this specific case, we are looking for the `name`
    attribute. If this is passed, we use it to construct a text node; otherwise, we
    default to the string `"World"`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `this.props` 来访问在运行时传递给这个组件的属性。在这个特定的情况下，我们正在寻找 `name` 属性。如果传递了这个属性，我们就用它来构造一个文本节点；否则，我们默认使用字符串
    `"World"`。
- en: In this last block of code, we use `ReactDOM.render()` to initialize our application.
    This function is responsible for attaching a React application to the existing
    page. An application is nothing more than an instance of a React component. Here,
    we are instantiating our `Hello` component and passing the string `"React"` for
    the `name` attribute. Finally, as the last argument, we have to specify which
    DOM node in the page will be the parent element of our application. In this case,
    we are using the `body` element of the page, but you can target any existing DOM
    element in the page.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这段代码的最后部分，我们使用 `ReactDOM.render()` 来初始化我们的应用程序。这个函数负责将 React 应用程序附加到现有页面上。应用程序不过是一个
    React 组件的实例。在这里，我们实例化我们的 `Hello` 组件，并将字符串 `"React"` 传递给 `name` 属性。最后，作为最后一个参数，我们必须指定页面上哪个
    DOM 节点将成为我们应用程序的父元素。在这种情况下，我们使用页面的 `body` 元素，但你也可以针对页面上的任何现有 DOM 元素。
- en: 'Now, you can see a preview of your application by running:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过运行以下命令来预览你的应用程序：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should now see "Hello React" in your browser window. Congratulations, you
    have built your first React application!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在浏览器窗口中看到 "Hello React"。恭喜你，你已经构建了你的第一个 React 应用程序！
- en: Alternatives to react.createElement
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`react.createElement` 的替代方案'
- en: Repeated usage of `react.createElement()` might compromise the readability of
    our React components. In fact, nesting many invocations of `react.createElement()`,
    even with our `h()` alias, will make it hard to understand the HTML structure
    we want our components to render.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用 `react.createElement()` 可能会降低我们 React 组件的可读性。实际上，即使使用我们的 `h()` 别名，嵌套多个
    `react.createElement()` 的调用也会使得理解我们希望组件渲染的 HTML 结构变得困难。
- en: For this reason, it is not very common to use `react.createElement()` directly.
    To address this problem, the React team offers and encourages an alternative syntax
    called **JSX** ([nodejsdp.link/jsx](http://nodejsdp.link/jsx)).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，直接使用 `react.createElement()` 并不是很常见。为了解决这个问题，React 团队提供并鼓励使用一种名为 **JSX**
    的替代语法 ([nodejsdp.link/jsx](http://nodejsdp.link/jsx))。
- en: 'JSX is a superset of JavaScript that allows you to embed HTML-like code into
    JavaScript code. JSX makes the creation of React elements similar to writing HTML
    code. With JSX, React components are generally more readable and easier to write.
    It is easier to see what we mean here by looking at a concrete example, so let''s
    rewrite our "Hello React" application using JSX:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是 JavaScript 的超集，它允许你在 JavaScript 代码中嵌入类似 HTML 的代码。JSX 使得创建 React 元素类似于编写
    HTML 代码。使用 JSX，React 组件通常更易于阅读和编写。通过查看一个具体的例子，我们可以更容易地理解这里的含义，所以让我们使用 JSX 重写我们的“Hello
    React”应用程序：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Much more readable, isn't it?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 难道不是更易于阅读吗？
- en: Unfortunately, since JSX is not a standard JavaScript feature, adopting JSX
    would require us to "compile" JSX code into standard equivalent JavaScript code.
    In the context of Universal JavaScript applications, we would have to do this
    both on the client-side code and the server-side code, so, for the sake of simplicity,
    we are not going to use JSX throughout the rest of this chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于 JSX 不是标准的 JavaScript 功能，采用 JSX 需要我们将 JSX 代码“编译”成标准的等效 JavaScript 代码。在通用
    JavaScript 应用程序的环境中，我们既需要在客户端代码中，也需要在服务器端代码中这样做，因此，为了简化，我们不会在本章的其余部分使用 JSX。
- en: There are some relatively new JSX alternatives that rely on standard JavaScript
    tagged template literals (you can read more about JavaScript tagged template literals
    at [nodejsdp.link/template-literals](http://nodejsdp.link/template-literals)).
    Using template literals seems to be a good compromise between code that is still
    quite easy to read and write and not having to perform an intermediate compilation
    process. Two of the most promising libraries providing this functionality are
    `htm` ([nodejsdp.link/htm](http://nodejsdp.link/htm)) and `esx` ([nodejsdp.link/esx](http://nodejsdp.link/esx)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有些相对较新的 JSX 替代方案依赖于标准的 JavaScript 标签模板字面量（你可以在 [nodejsdp.link/template-literals](http://nodejsdp.link/template-literals)
    了解更多关于 JavaScript 标签模板字面量的信息）。使用模板字面量似乎是在易于阅读和编写的代码与无需执行中间编译过程之间的一种良好折衷。提供此功能的两个最有前途的库是
    `htm` ([nodejsdp.link/htm](http://nodejsdp.link/htm)) 和 `esx` ([nodejsdp.link/esx](http://nodejsdp.link/esx))。
- en: 'In the rest of this chapter, we will be using `htm`, so let''s rewrite once
    more our "Hello React" example, this time using `htm`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用 `htm`，所以让我们再次重写我们的“Hello React”示例，这次使用 `htm`：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code looks quite readable, but let''s quickly clarify how we are using
    `htm` here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来相当易于阅读，但让我们快速澄清我们在这里是如何使用 `htm` 的：
- en: The first thing that we have to do is create the template tag function `html`.
    This function allows us to use template literals to generate React elements. At
    runtime, this template tag function will be calling `react.createElement()` for
    us when needed.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是创建模板标签函数 `html`。这个函数允许我们使用模板字面量来生成 React 元素。在运行时，这个模板标签函数将根据需要为我们调用
    `react.createElement()`。
- en: Here, we use a tagged template literal with the `html` tag function to create
    an `h1` tag. Note that, as this is a standard tagged template literal, we can
    use the regular placeholder syntax (`${expression}`) to insert dynamic expressions
    into the string. Remember that template literals and tagged template literals
    use backticks (`` ` ``) instead of single quotes (`'`) to delimit the template
    string.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用带有 `html` 标签函数的标签模板字面量来创建一个 `h1` 标签。请注意，由于这是一个标准的标签模板字面量，我们可以使用常规的占位符语法
    (`${expression}`) 将动态表达式插入到字符串中。记住，模板字面量和标签模板字面量使用反引号（`` ` ``）而不是单引号（`'`）来界定模板字符串。
- en: Similarly, we can use the placeholder syntax to create instances of React components
    (`<${ComponentClass}>`). Note that, if a component instance contains children
    elements, we can use the special `</>` tag to indicate the end of the component
    (for example, `<${Component}><child/></>`). Finally, we can pass props to the
    component as normal HTML attributes.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以使用占位符语法来创建 React 组件的实例 (`<${ComponentClass}>`)。请注意，如果一个组件实例包含子元素，我们可以使用特殊的
    `</>` 标签来表示组件的结束（例如，`<${Component}><child/></>`）。最后，我们可以像正常的 HTML 属性一样传递属性给组件。
- en: At this point, we should be able to understand the basic structure of a simple
    "Hello World" React component. In the next section, we will show you how to manage
    states in a React component, an important concept for most real-world applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该能够理解一个简单的"Hello World" React组件的基本结构。在下一节中，我们将向您展示如何在React组件中管理状态，这对于大多数实际应用来说是一个重要的概念。
- en: Stateful components
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态组件
- en: In the previous example, we saw how to build a *stateless* React component.
    By stateless, we mean that the component only receives input from the outside
    (in our example, it was receiving a `name` property) and it doesn't need to calculate
    or manage any internal information to be able to render itself to the DOM.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何构建一个*无状态*的React组件。通过无状态，我们指的是组件只接收外部的输入（在我们的例子中，它是接收一个`name`属性），并且它不需要计算或管理任何内部信息来能够将其渲染到DOM中。
- en: While it's great to have stateless components, sometimes, you have to manage
    some kind of state. React allows us to do that, so let's learn how with an example.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无状态组件很好，但有时你必须管理某种状态。React允许我们这样做，所以让我们通过一个例子来学习如何操作。
- en: Let's build a React application that displays a list of projects that have been
    recently updated on GitHub.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个React应用程序，显示在GitHub上最近更新的项目列表。
- en: 'We can encapsulate all the logic for asynchronously fetching the data from
    GitHub and displaying it on a dedicated component: the `RecentGithubProjects`
    component. This component is configurable through the `query` prop, which allows
    us to filter the projects on GitHub. The `query` prop will receive a keyword such
    as "javascript" or "react", and this value will be used to construct the API call
    to GitHub.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将从GitHub异步获取数据并在专用组件上显示的所有逻辑封装起来：`RecentGithubProjects`组件。该组件可以通过`query`属性进行配置，允许我们在GitHub上过滤项目。`query`属性将接收一个关键字，如"javascript"或"react"，这个值将用于构造对GitHub的API调用。
- en: 'Let''s finally have a look at the code of the `RecentGithubProjects` component:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后看看`RecentGithubProjects`组件的代码：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are some new React concepts in this component, so let''s discuss the
    main details here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，有一些新的React概念，所以让我们在这里讨论主要细节：
- en: In this new component, we are overriding the default constructor. A constructor
    accepts the props passed to the component as an argument.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新组件中，我们重写了默认构造函数。构造函数接受传递给组件的属性作为参数。
- en: The first thing we have to do is call the original constructor and propagate
    the props so that the component can be initialized correctly by React.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是调用原始构造函数并传播属性，以便组件可以由React正确初始化。
- en: Now, we can define the initial component state. Our final state is going to
    be a list of GitHub projects, but those won't be available immediately as we will
    need to load them dynamically. Therefore, we define the initial state as a boolean
    flag, indicating that we are loading the data and the list of projects as an empty
    array.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义初始组件状态。我们的最终状态将是一个GitHub项目列表，但它们不会立即可用，因为我们需要动态地加载它们。因此，我们将初始状态定义为表示我们正在加载数据的布尔标志，并将项目列表定义为空数组。
- en: 'The function `loadData()` is the function that is responsible for making the
    API request, fetching the necessary data, and updating the internal state using
    `this.setState()`. Note that `this.setState()` is called twice: before we issue
    the HTTP request (to activate the loading state) and when the request is completed
    (to unset the loading flag and populate the list of projects). React will re-render
    the component automatically when the state changes.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`loadData()`负责发起API请求，获取必要的数据，并使用`this.setState()`更新内部状态。请注意，`this.setState()`被调用了两次：在我们发出HTTP请求之前（以激活加载状态）和请求完成时（取消加载标志并填充项目列表）。当状态改变时，React会自动重新渲染组件。
- en: 'Here, we are introducing another new concept: the `componentDidMount` *lifecycle*
    function. This function is automatically invoked by React once the component has
    been successfully instantiated and attached (or *mounted*) to the DOM. This is
    the perfect place to load our data for the first time.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们引入了另一个新概念：`componentDidMount`生命周期函数。这个函数在组件成功实例化并附加（或*挂载*）到DOM后，由React自动调用。这是第一次加载数据的完美位置。
- en: The function `componentDidUpdate` is another React lifecycle function and it
    is automatically invoked every time the component is updated (for instance, if
    new props have been passed to the component). Here, we check if the `query` prop
    has changed since the last update. If that's the case, then we need to reload
    the list of projects.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate` 函数是另一个 React 生命周期函数，每次组件更新时都会自动调用（例如，如果向组件传递了新的属性）。在这里，我们检查
    `query` 属性是否自上次更新以来已更改。如果是这样，那么我们需要重新加载项目列表。'
- en: 'Finally, let''s see what happens in our `render()` function. The main thing
    to note is that here we have to handle the two different states of the component:
    the loading state and the state where we have the list of projects available for
    display. Since React will invoke the `render()` function every time the state
    or the props change, just having an `if` statement here will be enough. This technique
    is often called **conditional rendering**.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们看看 `render()` 函数中会发生什么。需要注意的是，在这里我们必须处理组件的两个不同状态：加载状态和我们有可显示的项目列表的状态。由于
    React 会在状态或属性改变时调用 `render()` 函数，所以这里只需要一个 `if` 语句就足够了。这种技术通常被称为 **条件渲染**。
- en: In this final step, we are rendering a list of elements using `Array.map()`
    to create a list element for every project fetched using the GitHub API. Note
    that every list element receives a value for the `key` prop. The `key` prop is
    a special prop that is recommended whenever you are rendering an array of elements.
    Every element should provide a unique `key`. This prop helps the virtual DOM optimize
    every rendering pass (If you are curious to understand in detail what React does
    in this situation you can have a look at [nodejsdp.link/react-reconciliation](http://nodejsdp.link/react-reconciliation)).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一最终步骤中，我们使用 `Array.map()` 渲染一个元素列表，为通过 GitHub API 获取的每个项目创建一个列表元素。请注意，每个列表元素都接收一个
    `key` 属性的值。`key` 属性是一个特殊的属性，在渲染元素数组时推荐使用。每个元素都应该提供一个唯一的 `key`。这个属性有助于虚拟 DOM 优化每次渲染过程（如果你对
    React 在这种情况下的具体操作感兴趣，可以查看[nodejsdp.link/react-reconciliation](http://nodejsdp.link/react-reconciliation)）。
- en: You might have noticed that we are not handling potential errors while fetching
    the data. There are several ways we can do this in React. The most elegant solution
    is probably implementing an `ErrorBoundary` component ([nodejsdp.link/error-boundary](http://nodejsdp.link/error-boundary)),
    but we will leave that as an exercise for you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在获取数据时没有处理潜在的错误。在 React 中，我们可以以几种方式来做这件事。最优雅的解决方案可能是实现一个 `ErrorBoundary`
    组件([nodejsdp.link/error-boundary](http://nodejsdp.link/error-boundary))，但我们将把这个留给你作为练习。
- en: 'Let''s now write the main application component. Here, we want to display a
    navigation menu where the user can select different queries ("JavaScript", "Node.js",
    and "React") to filter for different types of GitHub projects:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写主应用程序组件。在这里，我们想要显示一个导航菜单，用户可以通过选择不同的查询（“JavaScript”、“Node.js”和“React”）来过滤不同的
    GitHub 项目类型：
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This component is using its internal state to track the currently selected query.
    Initially, the "javascript" query is set and passed down to the `RecentGithubProjects`
    component. Then, every time a keyword in the navigation menu is clicked, we update
    the state with the new selected keyword. When this happens, the `render()` method
    will be automatically invoked and it will pass the new value for the `query` prop
    to `RecentGithubProjects`. In turn, `RecentGithubProjects` will be marked as *updated*,
    and it will internally reload and eventually update the list of projects for the
    new query.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件使用其内部状态来跟踪当前选定的查询。最初，“javascript”查询被设置并传递给 `RecentGithubProjects` 组件。然后，每次导航菜单中的关键字被点击时，我们都会使用新的选定关键字更新状态。当这种情况发生时，`render()`
    方法将自动被调用，并将新的 `query` 属性值传递给 `RecentGithubProjects`。反过来，`RecentGithubProjects`
    将被标记为 *已更新*，并且它将内部重新加载并最终更新新查询的项目列表。
- en: One interesting detail to underline is that, in the constructor, we are explicitly
    binding the `setQuery()` function to the current component instance. The reason
    why we do this is because this function is used directly as an event handler for
    the click event. In this case, the reference to `this` would be `undefined` without
    the bind and it would not be possible to call `this.setState()` from the handler.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得强调的有趣细节是，在构造函数中，我们明确地将 `setQuery()` 函数绑定到当前组件实例上。我们这样做的原因是因为这个函数被直接用作点击事件的处理器。在这种情况下，没有绑定的话，`this`
    的引用将是 `undefined`，并且无法从处理器中调用 `this.setState()`。
- en: 'At this point, we only need to attach the `App` component to the DOM to run
    our application. Let''s do this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需要将`App`组件附加到DOM上，就可以运行我们的应用程序。让我们这样做：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, let's just run the application with `npm start` and test it on the
    browser.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们用`npm start`运行应用程序，并在浏览器上测试它。
- en: Note that since we used async/await in our application, the default configuration
    generated by webpack might not work straight away. If you have any issues, compare
    your configuration file with the one in the code examples provided with this book
    ([nodejsdp.link/wpconf](http://nodejsdp.link/wpconf)).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们在应用程序中使用了async/await，webpack生成的默认配置可能不会立即工作。如果你有任何问题，请将你的配置文件与本书提供的代码示例中的配置文件进行比较([nodejsdp.link/wpconf](http://nodejsdp.link/wpconf))。
- en: Try to refresh the page and click on the various keywords on the navigation
    menu. After a few seconds, you should see the list of projects being refreshed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试刷新页面并点击导航菜单上的各种关键词。几秒钟后，你应该会看到项目列表正在刷新。
- en: At this point, it should be quite clear to you how React works, how to compose
    components together, and how to take advantage of state and props. Hopefully,
    this simple exercise will also help you to find new, interesting, open source
    JavaScript projects that you might want to contribute to!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，React的工作原理、如何组合组件以及如何利用状态和属性应该对你来说已经很清晰了。希望这个简单的练习也能帮助你找到你想要贡献的开源JavaScript项目！
- en: We've covered just enough ground for us to be able to build our first Universal
    React application. But if you want to be proficient with React, we recommend that
    you read the official React documentation ([nodejsdp.link/react-docs](http://nodejsdp.link/react-docs))
    for a more exhaustive overview of the library.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了足够的内容，使我们能够构建我们的第一个通用React应用程序。但如果你想精通React，我们建议你阅读官方的React文档([nodejsdp.link/react-docs](http://nodejsdp.link/react-docs))，以获得对库的更全面了解。
- en: We are finally ready to take what we learned about webpack and React to create
    a simple, yet complete, universal JavaScript application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好将我们关于webpack和React的知识应用到创建一个简单但完整的通用JavaScript应用程序上了。
- en: Creating a Universal JavaScript app
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个通用JavaScript应用程序
- en: Now that we've covered the basics, let's start to build a more complete Universal
    JavaScript application. We are going to build a simple "book library" application
    where we can list different authors and see their biography and some of their
    masterpieces. Although this is going to be a very simple application, it will
    allow us to cover more advanced topics such as **universal routing**, **universal
    rendering**, and **universal data fetching**. The idea is that you can later use
    this application as a scaffold for a real project and build on top of it your
    next universal JavaScript application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，让我们开始构建一个更完整的通用JavaScript应用程序。我们将构建一个简单的“图书库”应用程序，我们可以列出不同的作者并查看他们的传记以及一些他们的杰作。尽管这将是一个非常简单的应用程序，但它将使我们能够涵盖更高级的主题，如**通用路由**、**通用渲染**和**通用数据获取**。想法是你可以稍后使用这个应用程序作为真实项目的脚手架，并在其上构建你的下一个通用JavaScript应用程序。
- en: 'In this experiment, we are going to use the following technologies:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将使用以下技术：
- en: '**React** ([nodejsdp.link/react](http://nodejsdp.link/react)), which we just
    introduced'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React** ([nodejsdp.link/react](http://nodejsdp.link/react))，我们刚刚介绍过的'
- en: '**React Router** ([nodejsdp.link/react-router](http://nodejsdp.link/react-router)),
    a companion routing layer for React'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React Router** ([nodejsdp.link/react-router](http://nodejsdp.link/react-router))，React的配套路由层'
- en: '**Fastify** ([nodejsdp.link/fastify](http://nodejsdp.link/fastify)), a fast
    and ergonomic framework to build web servers in Node.js'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fastify** ([nodejsdp.link/fastify](http://nodejsdp.link/fastify))，一个快速且易于使用的Node.js构建Web服务器的框架'
- en: '**Webpack** as the module bundler'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Webpack**作为模块打包器'
- en: For practical reasons, we selected a very specific set of technologies for this
    exercise, but we will try to focus as much as possible on the design principles
    and patterns rather than the technologies themselves. As you learn these patterns,
    you should be able to use the acquired knowledge with any other combination of
    technologies and achieve similar results.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实际原因，我们为这次练习选择了非常具体的一组技术，但我们将会尽可能关注设计原则和模式，而不是技术本身。随着你学习这些模式，你应该能够使用所获得的知识结合任何其他技术组合，并实现类似的结果。
- en: In order to keep things simple, we will be using webpack only to process the
    frontend code and we will leave the backend code unchanged, leveraging the native
    Node.js support for ESM.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们只会使用webpack来处理前端代码，并将后端代码保持不变，利用原生Node.js对ESM的支持。
- en: 'At the time of writing, there are some subtle discrepancies between how webpack
    interprets the semantics of ESM imports as opposed to how Node.js does it, especially
    when importing modules written using the CommonJS syntax. For this reason, we
    recommend running the examples in the rest of this chapter using `esm` ([nodejsdp.link/esm](http://nodejsdp.link/esm)),
    a Node.js library that will preprocess ESM imports in a way that minimizes those
    differences. Once you have installed the `esm` module in your project, you can
    run a script with `esm` as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，webpack在解释ESM导入的语义与Node.js的做法之间存在一些细微的差异，尤其是在导入使用CommonJS语法的模块时。因此，我们建议使用`esm`
    ([nodejsdp.link/esm](http://nodejsdp.link/esm))库运行本章余下的示例，这是一个Node.js库，它将以最小化这些差异的方式预处理ESM导入。一旦你在项目中安装了`esm`模块，你可以使用以下方式运行带有`esm`的脚本：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Frontend-only app
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅前端应用
- en: In this section, we are going to focus on building our app on the frontend only,
    using webpack as a development web server. In the next sections, we will expand
    and update this basic app to convert it to a full Universal JavaScript application.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于仅在前端构建我们的应用，使用webpack作为开发Web服务器。在下一节中，我们将扩展和更新这个基本应用，将其转换为全通用JavaScript应用。
- en: 'This time, we will be using a custom webpack configuration, so let''s start
    by creating a new folder and copying the `package.json` and `webpack.config.cjs`
    files from the code repository provided with this book ([nodejsdp.link/frontend-only-app](http://nodejsdp.link/frontend-only-app)),
    then install all the necessary dependencies with:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用自定义的webpack配置，所以让我们首先创建一个新的文件夹，并将代码库中提供的`package.json`和`webpack.config.cjs`文件复制到该文件夹中，然后使用以下命令安装所有必要的依赖项：
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The data we will be using is stored in a JavaScript file (as a simple substitute
    for a database), so make sure you copy the file `data/authors.js` into your project
    as well. This file contains some sample data in the following format:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的数据存储在一个JavaScript文件中（作为数据库的简单替代），所以请确保你也把`data/authors.js`文件复制到你的项目中。此文件包含以下格式的示例数据：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Of course, feel free to change the data in this file if you want to add your
    favorite authors and books!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想添加你喜欢的作者和书籍，可以随意更改此文件中的数据！
- en: Now that we have all the configuration in place, let's quickly discuss what
    we want our application to look like.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有配置，让我们快速讨论我们希望我们的应用看起来像什么。
- en: '![../../../Downloads/Untitled%20Diagram%20(15).png](img/B15729_10_03.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![../../../Downloads/Untitled%20Diagram%20(15).png](img/B15729_10_03.png)'
- en: 'Figure 10.3: Application mockup'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：应用原型
- en: '*Figure 10.3* shows that our application will have two different types of page:
    an index page, where we list all the authors available in our data store, and
    then a page to visualize the details of a given author, where we will see their
    biography and some of their books.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.3* 显示，我们的应用将有两种不同类型的页面：一个索引页面，其中我们列出数据存储中所有可用的作者，然后是一个用于可视化特定作者详细信息的页面，我们将看到他们的传记以及一些他们的书籍。'
- en: These two types of page will only have a header in common. This will allow us
    to go back to the index page at any time.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的页面将只有标题是共同的。这将允许我们在任何时候返回到索引页面。
- en: We will be exposing the index page at the root path of our server (`/`), while
    we will be using the path `/author/:authorId` for the author's page.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在服务器的根路径（`/`）上公开索引页面，而我们将使用路径`/author/:authorId`来访问作者页面。
- en: Finally, we will also have a `404` page.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将有一个`404`页面。
- en: 'In terms of file structure, we will organize our project as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件结构方面，我们将按照以下方式组织我们的项目：
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s start by writing the `index.js` module, which will serve as the entry
    point for loading our frontend application and attaching it to the DOM:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写`index.js`模块，它将作为加载我们的前端应用并将其附加到DOM的入口点：
- en: '[PRE38]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code is quite simple as we are mainly importing the `App` component and
    attaching it to the DOM in an element with the ID equal to `root`. The only detail
    that stands out is that we are wrapping the application into a `BrowserRouter`
    component. This component comes from the `react-router-dom` library and it provides
    our app with client-side routing capabilities. Some of the components we will
    be writing next will showcase how to fully take advantage of these routing capabilities
    and how to connect different pages together using links. Later on, we will revisit
    this routing configuration to make it available on the server side as well.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单，因为我们主要导入 `App` 组件并将其附加到具有 ID 为 `root` 的 DOM 元素中。唯一引人注目的是，我们将应用程序包裹在一个
    `BrowserRouter` 组件中。这个组件来自 `react-router-dom` 库，并为我们的应用程序提供了客户端路由功能。我们接下来将要编写的某些组件将展示如何充分利用这些路由功能以及如何使用链接将不同的页面连接在一起。稍后，我们将重新访问这个路由配置，使其也适用于服务器端。
- en: 'Right now, let''s focus on the source code for `App.js`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于 `App.js` 的源代码：
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can tell from this code, the `App` component is responsible for loading
    all the page components and configuring the routing for them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中可以看出，`App` 组件负责加载所有页面组件并为它们配置路由。
- en: Here, we are using the `Switch` component from `react-router-dom`. This component
    allows us to define `Route` components. Every `Route` component needs to have
    a `path` and a `component` prop associated with it. At render time, `Switch` will
    check the current URL against the paths defined by the routes, and it will render
    the component associated to the first `Route` component that matches.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用来自 `react-router-dom` 的 `Switch` 组件。这个组件允许我们定义 `Route` 组件。每个 `Route`
    组件都需要一个与它关联的 `path` 和 `component` 属性。在渲染时，`Switch` 将检查当前 URL 与路由定义的路径进行对比，并将渲染与第一个匹配的
    `Route` 组件关联的组件。
- en: As in a JavaScript `switch` statement, where the order of `case` statements
    is important, here, the order of the `Route` components is important too. Our
    last route is a *catch-all route*, which will always match if none of the previous
    routes matches..
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 JavaScript 的 `switch` 语句中，`case` 语句的顺序很重要一样，这里，`Route` 组件的顺序也很重要。我们的最后一个路由是一个
    *通配路由*，如果前面的任何路由都不匹配，它总是会匹配。
- en: 'Note also that we are setting the prop `exact` for the first `Route`. This
    is needed because `react-router-dom` will match based on prefixes, so a plain
    `/` will match any URL. By specifying `exact: true`, we are telling the router
    to only match this path if it is exactly `/` (and not if it just starts with `/`).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '还要注意，我们为第一个 `Route` 设置了 `exact` 属性。这是必需的，因为 `react-router-dom` 将基于前缀进行匹配，所以一个普通的
    `/` 将匹配任何 URL。通过指定 `exact: true`，我们告诉路由器只有当路径正好是 `/` 时才匹配这个路径（而不是如果它只是以 `/` 开头）。'
- en: 'Let''s now have a quick look at our `Header` component:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们快速看一下我们的 `Header` 组件：
- en: '[PRE40]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a very simple component that just renders an `h1` title containing "My
    library." The only detail worth discussing here is that the title is wrapped by
    a `Link` component from the `react-router-dom` library. This component is responsible
    for rendering a clickable link that can interact with the application router to
    switch to a new route dynamically, without refreshing the entire page.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的组件，它只渲染一个包含 "我的图书馆" 的 `h1` 标题。这里值得讨论的唯一细节是，标题被来自 `react-router-dom`
    库的 `Link` 组件包裹。这个组件负责渲染一个可点击的链接，它可以与应用程序路由器交互，动态切换到新的路由，而无需刷新整个页面。
- en: 'Now, we have to write, one by one, our page components. Let''s start with the
    `AuthorsIndex` component:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须逐个编写我们的页面组件。让我们从 `AuthorsIndex` 组件开始：
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Yet another very simple component. Here, we are rendering some markup dynamically
    based on the list of authors available in our data file. Note that we are using,
    once again, the `Link` component from `react-router-dom` to create dynamic links
    to the author page.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常简单的组件。在这里，我们根据数据文件中可用的作者列表动态渲染一些标记。请注意，我们再次使用来自 `react-router-dom` 的 `Link`
    组件来创建指向作者页面的动态链接。
- en: 'Now, let''s have a look at the `Author` component code:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下 `Author` 组件的代码：
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This component has a little bit of logic in it. In the `render()` method, we
    filter the `authors` dataset to find the current author. Notice that we are using
    `props.match.params.authorId` to get the current author ID. The `match` prop will
    be passed to the component by the router at render time and the nested `params`
    object will be populated if the current path has dynamic parameters.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件中包含了一点点逻辑。在`render()`方法中，我们过滤`authors`数据集以找到当前作者。请注意，我们正在使用`props.match.params.authorId`来获取当前作者ID。`match`属性将在渲染时由路由器传递给组件，如果当前路径有动态参数，嵌套的`params`对象将被填充。
- en: It is common practice to memoize ([nodejsdp.link/memoization](http://nodejsdp.link/memoization))
    the result of any complex calculation performed in the `render()` method. This
    prevents the complex calculation from running again in case its inputs haven't
    changed since the last render. In our example, a possible target for this type
    of optimization is the call to `authors.find()`. We leave this to you as an exercise.
    If you want to know more about this technique take a look at [nodejsdp.link/react-memoization](http://nodejsdp.link/react-memoization).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render()`方法中执行任何复杂计算的结果通常会被缓存（[nodejsdp.link/memoization](http://nodejsdp.link/memoization)），这可以防止在输入没有改变的情况下再次运行复杂的计算。在我们的例子中，这种优化可能的目标是调用`authors.find()`。我们将这个练习留给你。如果你想了解更多关于这种技术的信息，请查看[nodejsdp.link/react-memoization](http://nodejsdp.link/react-memoization)。
- en: There's a chance that we are receiving an ID that doesn't match any author in
    our dataset, so in this case, `author` will be `undefined`. This is clearly a
    `404`, so instead of rendering the author data, we delegate the render logic to
    the `FourOhFour` component, which is responsible for rendering the `404` error
    page.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能我们收到的是一个与我们的数据集中任何作者都不匹配的ID，所以在这种情况下，`author`将是`undefined`。这显然是一个`404`错误，所以我们不是渲染作者数据，而是将渲染逻辑委托给`FourOhFour`组件，该组件负责渲染`404`错误页面。
- en: 'Finally, let''s see the source code for the `FourOhFour` component:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`FourOhFour`组件的源代码：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This component is responsible for rendering the `404` page. Note that we made
    the error message configurable through the `error` prop and also that we are using
    a `Link` from the `react-router-dom` library to allow the user to travel back
    to the home page when landing on this error page.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件负责渲染`404`页面。请注意，我们通过`error`属性使错误消息可配置，并且我们使用来自`react-router-dom`库的`Link`，允许用户在到达这个错误页面时返回主页。
- en: 'This was quite a lot of code, but we are finally ready to run our frontend-only
    React application: just type `npm start` in your console and you should see the
    application running in your browser. Pretty barebones, but if we did everything
    correctly, it should work as expected and allow us to see our favorite authors
    and their masterpieces.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当多，但我们终于准备好运行我们的纯前端React应用程序了：只需在控制台中输入`npm start`，你应该会在浏览器中看到应用程序正在运行。相当基础，但如果一切正确，它应该按预期工作，并允许我们查看我们最喜欢的作者及其杰作。
- en: It is worth using the app with the browser developer tools open so that we can
    verify that our dynamic routing is working correctly, that is, once the first
    page is loaded, transitions to other pages happen without any page refresh.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 值得使用浏览器开发者工具打开应用程序，这样我们就可以验证我们的动态路由是否正确工作，也就是说，一旦加载了第一个页面，转到其他页面时不会刷新页面。
- en: For a better understanding of what happens when you interact with a React application,
    you can install and use the React Developer Tools browser extension on Chrome
    ([nodejsdp.link/react-dev-tools-chrome](http://nodejsdp.link/react-dev-tools-chrome))
    or Firefox ([nodejsdp.link/react-dev-tools-firefox](http://nodejsdp.link/react-dev-tools-firefox)).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解与React应用程序交互时会发生什么，您可以在Chrome（[nodejsdp.link/react-dev-tools-chrome](http://nodejsdp.link/react-dev-tools-chrome)）或Firefox（[nodejsdp.link/react-dev-tools-firefox](http://nodejsdp.link/react-dev-tools-firefox)）上安装并使用React开发者工具浏览器扩展。
- en: Server-side rendering
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: 'Our application works and this is great news. However, the app is running only
    on the client side, which means that if we try to `curl` one of the pages, we
    will see something like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序运行得很好，这是一个好消息。然而，应用程序仅在客户端运行，这意味着如果我们尝试`curl`其中一个页面，我们会看到类似以下的内容：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: No content whatsoever! There's only an empty container (the root `div`), which
    is where our application is mounted at runtime.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 完全没有内容！只有一个空的容器（根`div`），这是我们的应用程序在运行时挂载的地方。
- en: In this section, we will modify our application to be able to render the content
    also from the server.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将修改我们的应用程序，使其能够从服务器渲染内容。
- en: 'Let''s start by adding `fastify` and `esm` to our project:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将`fastify`和`esm`添加到我们的项目中开始：
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can create our server application in `src/server.js`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`src/server.js`中创建我们的服务器应用程序：
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There''s a lot of code here, so let''s discuss step by step the main concepts
    introduced here:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码很多，所以让我们一步一步地讨论这里介绍的主要概念：
- en: Since we are not going to use the webpack dev server, we need to return the
    full HTML code of the page from our server. Here, we are defining the HTML template
    for all our pages using a function and a template literal. We will be passing
    the result of our server-rendered React application as `content` to this template
    to get the final HTML to return to the client.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不会使用webpack开发服务器，我们需要从我们的服务器返回页面的完整HTML代码。在这里，我们使用一个函数和模板字面量定义了所有页面的HTML模板。我们将把我们的服务器渲染的React应用程序的结果作为`content`传递给这个模板，以获取返回给客户端的最终HTML。
- en: Here, we create a Fastify server instance and enable logging.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个Fastify服务器实例并启用了日志记录。
- en: As you might have noticed from our template code, our web application will load
    the script `/public/main.js`. This file is the frontend bundle that is generated
    by webpack. Here, we are letting the Fastify server instance serve all static
    assets from the `public` folder using the `fastify-static` plugin.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您从我们的模板代码中注意到的，我们的Web应用程序将加载`/public/main.js`脚本。这个文件是由webpack生成的前端包。在这里，我们让Fastify服务器实例使用`fastify-static`插件从`public`文件夹提供所有静态资产。
- en: In this line, we define a catch-all route for every `GET` request to the server.
    The reason why we are doing a catch-all route is because the actual routing logic
    is already contained in the React application. When we render the React application,
    it will display the correct page component based on the current URL.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一行中，我们为服务器上的每个`GET`请求定义了一个通配符路由。我们之所以要做通配符路由，是因为实际的路由逻辑已经包含在React应用程序中。当我们渲染React应用程序时，它将根据当前URL显示正确的页面组件。
- en: On the server side, we have to use an instance of `StaticRouter` from `react-router-dom`
    and wrap our application component with it. `StaticRouter` is a version of React
    Router that can be used for server-side rendering. This router, rather than taking
    the current URL from the browser window, allows us to pass the current URL directly
    from the server through the `location` prop.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器端，我们必须使用`react-router-dom`中的`StaticRouter`的一个实例，并用它包裹我们的应用程序组件。`StaticRouter`是React
    Router的一个版本，可以用于服务器端渲染。这个路由器，而不是从浏览器窗口中获取当前URL，允许我们通过`location`属性直接从服务器传递当前URL。
- en: Here, we can finally generate the HTML code for our `serverApp` component by
    using React's `renderToString()` function. The generated HTML is the same as the
    one generated by the client-side application on a given URL. In the next few lines,
    we wrap this code with our page layout using the `template()` function and finally,
    we send the result to the client.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以最终使用React的`renderToString()`函数生成我们的`serverApp`组件的HTML代码。生成的HTML与客户端应用程序在给定URL上生成的HTML相同。在接下来的几行中，我们使用`template()`函数将这段代码包裹在我们的页面布局中，最后将结果发送给客户端。
- en: In the last few lines of code, we tell our Fastify `server` instance to listen
    on a given address and port defaulting to `localhost:3000`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码的最后几行中，我们告诉我们的Fastify `server`实例在给定的地址和端口上监听，默认为`localhost:3000`。
- en: 'Now, we can run `npm run build` to create the frontend bundle and finally,
    we can run our server, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`npm run build`来创建前端包，最后我们可以运行我们的服务器，如下所示：
- en: '[PRE47]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s open our browser on `http://localhost:3000/` and see if our app is still
    working as expected. All good, right? Great! Now, let''s try to `curl` our home
    page to see if the server-generated code looks different:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`http://localhost:3000/`上打开我们的浏览器，看看我们的应用程序是否仍然按预期工作。一切正常，对吧？太好了！现在，让我们尝试使用`curl`我们的主页，看看服务器生成的代码是否有所不同：
- en: '[PRE48]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This time, this is what we should see:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们应该看到的是：
- en: '[PRE49]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Great! This time, our root container is not empty: we are rendering the list
    of authors directly from the server. You should also try some author pages and
    see that it works correctly for those as well. Mission complete! Well, almost...
    what happens if we try to render a page that does not exist? Let''s have a look:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这次，我们的根容器不再是空的：我们直接从服务器渲染作者列表。你也应该尝试一些作者页面，看看它们是否也能正确工作。任务完成！嗯，几乎是这样...如果我们尝试渲染一个不存在的页面会发生什么？让我们看看：
- en: '[PRE50]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will print:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：
- en: '[PRE51]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: At first glance, this might seem correct because we are rendering our `404`
    page, but we are actually returning a `200` status code… not good!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是正确的，因为我们正在渲染我们的`404`页面，但实际上我们返回了一个`200`状态码…这不太好！
- en: We can actually fix this with just a little extra effort, so let's do it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们只需稍作努力就可以解决这个问题，所以让我们来做。
- en: React `StaticRouter` allows us to pass a generic `context` prop that can be
    used to exchange information between the React application and the server. We
    can leverage this utility to allow our 404 page to inject some information into
    this shared context so that on the server side, we are aware of whether we should
    return a `200` or a `404` status code.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: React 的 `StaticRouter` 允许我们传递一个通用的 `context` 属性，该属性可用于在 React 应用程序和服务器之间交换信息。我们可以利用这个实用工具来允许我们的
    404 页面将一些信息注入到这个共享上下文中，这样在服务器端，我们就知道是否应该返回 `200` 或 `404` 状态码。
- en: 'Let''s update the catch-all route on the server side first:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先更新服务器端的通配符路由：
- en: '[PRE52]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The changes from the previous version are highlighted in bold. As you can see,
    we create an empty object called `staticContext` and pass it to the router instance
    in the `context` prop. Later on, after the server-side rendering is completed,
    we check if `staticContext.statusCode` was populated during the rendering process.
    If it was, it will now contain the status code that we have to return to the client,
    together with the rendered HTML code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个版本中的更改以粗体突出显示。正如您所看到的，我们创建了一个名为 `staticContext` 的空对象，并将其传递给路由实例的 `context`
    属性。稍后，在服务器端渲染完成后，我们检查在渲染过程中是否填充了 `staticContext.statusCode`。如果是，它现在将包含我们必须返回给客户端的状态码，以及渲染的
    HTML 代码。
- en: 'Let''s now change the `FourOhFour` component to actually populate this value.
    To do this, we just need to update the `render()` function with the following
    code before we return the elements to render:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更改 `FourOhFour` 组件以实际填充此值。为此，我们只需在返回要渲染的元素之前更新 `render()` 函数，如下所示：
- en: '[PRE53]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that the `context` prop passed to `StaticRouter` is passed only to direct
    children of `Route` components using the prop `staticContext`. For this reason,
    if we rebuild the frontend bundle and relaunch our server, this time, we will
    see a correct `404` status for `http://localhost:3000/blah`, but it won't work
    for URLs that match the author page such as `http://localhost:3000/author/blah`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，传递给 `StaticRouter` 的 `context` 属性仅传递给使用 `staticContext` 属性的直接子组件 `Route`
    组件。因此，如果我们重新构建前端包并重新启动我们的服务器，这次，我们将看到 `http://localhost:3000/blah` 的正确 `404` 状态码，但它不会适用于匹配作者页面（如
    `http://localhost:3000/author/blah`）的 URL。
- en: 'In order to make this work, we also need to propagate `staticContext` from
    the `Author` component into the `FourOhFour` component. To do this, in the `Author`
    component''s `render()` method, we have to apply the following change:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们还需要将 `staticContext` 从 `Author` 组件传播到 `FourOhFour` 组件。为此，在 `Author`
    组件的 `render()` 方法中，我们必须应用以下更改：
- en: '[PRE54]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, the `404` status code will be returned correctly from the server, even
    on author pages for non-existent authors.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务器将正确地返回 `404` 状态码，即使在不存在作者的作者页面上也是如此。
- en: Great—we now have a fully functional React application that uses server-side
    rendering! But don't celebrate just yet, we still have some work to do...
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们现在有一个完全功能化的使用服务器端渲染的 React 应用程序！但别急着庆祝，我们还有一些工作要做...
- en: Asynchronous data retrieval
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步数据检索
- en: Now, imagine for a second that we are asked to build the website for the Library
    of Trinity College in Dublin, one of the most famous libraries in the world. It
    has about 300 years of history and about 7 million books. Ok, now let's imagine
    we have to allow the users to browse this massive collection of books. Yes, all
    7 million of them... a simple data file is not going to be a great idea here!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，如果我们被要求为都柏林三一学院的图书馆建立网站，这是世界上最著名的图书馆之一。它有大约 300 年的历史和大约 700 万本书。好的，现在让我们想象我们必须允许用户浏览这个庞大的书籍收藏。是的，所有
    700 万本...一个简单的数据文件在这里并不是一个好主意！
- en: A better approach would be to have a dedicated API to retrieve the data about
    the books and use it to dynamically fetch only the minimum amount of data needed
    to render a given page. More data will be fetched as the user navigates through
    the various pages of the website.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是有专门的 API 来检索有关书籍的数据，并使用它来动态获取渲染给定页面所需的最小数据量。随着用户在网站的各种页面之间导航，将获取更多数据。
- en: 'This approach is valid for most web applications, so let''s try to apply the
    same principle to our demo application. We will be using an API with two endpoints:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于大多数 Web 应用程序，因此让我们尝试将相同的原理应用到我们的演示应用程序中。我们将使用一个具有两个端点的 API：
- en: '`/api/authors`, to get the list of authors'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/authors`，获取作者列表'
- en: '`/api/author/:authorId`, to get the information for a given author'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/author/:authorId`，获取特定作者的信息'
- en: For the sake of this demo application, we will keep things very simple. We only
    want to demonstrate how our application is going to change as soon as we introduce
    asynchronous data fetching, so we are not going to bother with using a real database
    to back our API or with introducing more advanced features like pagination, filtering,
    or search.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个演示应用程序，我们将保持事情非常简单。我们只想展示一旦我们引入异步数据获取，我们的应用程序将如何改变，所以我们不会去麻烦使用真实的数据库来支持我们的
    API，或者引入更高级的功能，如分页、过滤或搜索。
- en: Since building such an API server leveraging our existing data file is a rather
    trivial exercise (one that doesn't add much value in the context of this chapter),
    we are going to skip the walkthrough of the API implementation. You can get the
    source code of the API server from the code repository of this book ([nodejsdp.link/authors-api-server](http://nodejsdp.link/authors-api-server)).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 由于利用我们现有的数据文件构建这样的 API 服务器是一个相当简单的练习（在本书的上下文中，这并不增加多少价值），我们将跳过 API 实现的详细说明。您可以从本书的代码仓库中获取
    API 服务器的源代码（[nodejsdp.link/authors-api-server](http://nodejsdp.link/authors-api-server)）。
- en: This simple API server runs independently from our backend server, so it uses
    another port (or potentially even on another domain). In order to allow the browser
    to make asynchronous HTTP requests to a different port or domain, we need our
    API server to support **cross-origin resource sharing** or **CORS** ([nodejsdp.link/cors](http://nodejsdp.link/cors)),
    a mechanism that allows secure cross-origin requests. Thankfully, enabling CORS
    with Fastify is as easy as installing the `fastify-cors` ([nodejsdp.link/fastify-cors](http://nodejsdp.link/fastify-cors))
    plugin.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的 API 服务器独立于我们的后端服务器运行，因此它使用另一个端口（或者甚至可能在另一个域名上）。为了允许浏览器向不同的端口或域名发出异步 HTTP
    请求，我们需要我们的 API 服务器支持 **跨源资源共享** 或 **CORS** ([nodejsdp.link/cors](http://nodejsdp.link/cors))，这是一种允许安全跨源请求的机制。幸运的是，使用
    Fastify 启用 CORS 与安装 `fastify-cors` ([nodejsdp.link/fastify-cors](http://nodejsdp.link/fastify-cors))
    插件一样简单。
- en: We are also going to need an HTTP client that works seamlessly on both the browser
    and Node.js. A good option is `superagent` ([nodejsdp.link/superagent](http://nodejsdp.link/superagent)).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个在浏览器和 Node.js 上都能无缝工作的 HTTP 客户端。一个不错的选择是 `superagent` ([nodejsdp.link/superagent](http://nodejsdp.link/superagent))。
- en: 'Let''s install the new dependencies then:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装新的依赖项：
- en: '[PRE55]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we are ready to run our API server:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行我们的 API 服务器：
- en: '[PRE56]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And let''s try some requests with `curl`, for instance:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用 `curl` 发送一些请求，例如：
- en: '[PRE57]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If everything worked as expected, we are now ready to update our React components
    to use these new API endpoints rather than reading directly from the `authors`
    dataset. Let''s start by updating the `AuthorsIndex` component:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期进行，我们现在可以更新我们的 React 组件，使用这些新的 API 端点而不是直接从 `authors` 数据集中读取。让我们先从更新
    `AuthorsIndex` 组件开始：
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The main changes from the previous version are highlighted in bold. Essentially,
    we converted our React component into a stateful component. At construction time,
    we initialized the state to an empty array of authors and we set the `loading`
    flag to `true`. Then, we used the `componentDidMount` lifecycle method to load
    the authors data using the new API endpoint. Finally, we updated the `render()`
    method to display a loading message while the data was being loaded asynchronously.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个版本相比，主要的变化以粗体突出显示。基本上，我们将我们的 React 组件转换成了一个有状态的组件。在构建时，我们将状态初始化为一个空的作者数组，并将
    `loading` 标志设置为 `true`。然后，我们使用 `componentDidMount` 生命周期方法通过新的 API 端点加载数据。最后，我们更新了
    `render()` 方法，在数据异步加载时显示一个加载消息。
- en: 'Now, we have to update our `Author` component:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须更新我们的 `Author` 组件：
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The changes here are quite similar to the ones we applied to the previous component.
    In this component, we also generalized the data loading operation into the `loadData()`
    method. We did this because this component implements not just the `componentDidMount()`
    but also the `componentDidUpdate()` lifecycle method. This is necessary because
    if we end up passing new props to the same component instance, we want the component
    to update correctly. This will happen, for instance, if we have a link in the
    author page that points to another author page, something that could happen if
    we implement a "related authors" feature in our application.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的更改与我们之前应用于上一个组件的更改非常相似。在这个组件中，我们也把数据加载操作泛化为`loadData()`方法。我们这样做是因为这个组件不仅实现了`componentDidMount()`，还实现了`componentDidUpdate()`生命周期方法。这是必要的，因为如果我们最终将新属性传递给同一个组件实例，我们希望组件能够正确更新。这种情况可能会发生，例如，如果我们有一个指向另一个作者页面的链接，这可能会在我们实现应用程序中的“相关作者”功能时发生。
- en: At this point, we are ready to try this new version of the code. Let's regenerate
    the frontend bundle with `npm run build` and start both our backend server and
    our API server, then point our browser to `http://localhost:3000/`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好尝试这个代码的新版本了。让我们使用`npm run build`重新生成前端包，然后启动我们的后端服务器和API服务器，然后将浏览器指向`http://localhost:3000/`。
- en: If you navigate around the various pages, everything should work as expected.
    You might also notice that page content gets loaded interactively as you navigate
    through the pages.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览各个页面，一切应该像预期的那样工作。你也可能会注意到，当你浏览页面时，页面内容会交互式地加载。
- en: 'But what happens to our server-side rendering? If we try to use `curl` on our
    home page, we should see the following HTML markup being returned:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的服务器端渲染会发生什么呢？如果我们尝试在我们的主页上使用`curl`，我们应该看到以下HTML标记被返回：
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Did you notice that there's no content anymore, but just a quite useless "Loading
    …" indicator? This is not good. Also, this is not the only problem here. If you
    try to use `curl` on an invalid author page, you will notice that you will get
    the same HTML markup with the loading indicator and no content and that the returned
    status code is `200` rather than `404`!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到内容已经没有了，只剩下一个相当无用的“加载中…”指示器吗？这并不好。而且，这并不是唯一的问题。如果你尝试在一个无效的作者页面上使用`curl`，你会注意到你会得到相同的HTML标记，带有加载指示器和没有内容，并且返回的状态码是`200`而不是`404`！
- en: We don't see any real content on the server-side rendered markup because the
    `componentDidMount` lifecycle method is executed only on the browser while it's
    ignored by React during server-side rendering.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器端渲染的标记中看不到任何实际内容，因为`componentDidMount`生命周期方法仅在浏览器中执行，而在服务器端渲染时被React忽略。
- en: Furthermore, server-side rendering is a synchronous operation, so even if we
    move our loading code somewhere else, we still won't be able to perform any asynchronous
    data loading while rendering on the server.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，服务器端渲染是一个同步操作，所以即使我们将加载代码移动到其他地方，我们仍然无法在服务器渲染时执行任何异步数据加载。
- en: In the next section of this chapter, we will explore a pattern that can help
    us to achieve full universal rendering and data loading.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将探讨一种可以帮助我们实现完全通用渲染和数据加载的模式。
- en: Universal data retrieval
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用数据检索
- en: Server-side rendering is a synchronous operation and this makes it tricky to
    preload all the necessary data effectively. Being able to avoid the problems we
    underlined at the end of the previous section is not as straightforward as you
    might expect.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染是一个同步操作，这使得有效地预加载所有必要数据变得很棘手。能够避免我们在上一节末尾强调的问题并不像你想象的那样简单直接。
- en: The root of the problem is that we are keeping our routing logic within the
    React application, so, on the server, we cannot know which page we are actually
    going to render before we call `renderToString()`. This is why the server cannot
    establish whether we need to preload some data for a particular page.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的根源在于我们把路由逻辑保留在React应用程序中，所以，在服务器上，在我们调用`renderToString()`之前，我们无法知道我们将要渲染哪个页面。这就是为什么服务器无法确定我们是否需要为特定页面预加载数据。
- en: Universal data retrieval is still quite a nebulous area in React, and different
    frameworks or libraries that facilitate React server-side rendering have come
    up with different solutions to this problem.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，通用数据检索仍然是一个相当模糊的领域，不同的框架或库为促进React服务器端渲染而提出了不同的解决方案来解决这个问题。
- en: As of today, the two patterns that we believe are worth discussing are **two-pass
    rendering** and **async pages**. These two techniques have different ways of figuring
    out which data needs to be preloaded. In both cases, once the data is fully loaded
    on the server, the generated HTML page will provide an inline `script` block to
    inject all the data into the global scope (the `window` object) so that when the
    application runs on the browser, the same data already loaded on the server won't
    have to be reloaded from the client.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，我们认为值得讨论的两种模式是**双次渲染**和**异步页面**。这两种技术以不同的方式确定需要预加载哪些数据。在两种情况下，一旦数据在服务器上完全加载，生成的HTML页面将提供一个内联`script`块，将所有数据注入全局作用域（`window`对象），这样当应用程序在浏览器上运行时，已经在服务器上加载的数据就不需要从客户端重新加载。
- en: Two-pass rendering
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双次渲染
- en: 'The idea of two-pass rendering is to use the React router static context as
    a vector to exchange information between React and the server. *Figure 10.4* shows
    us how this works:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 双次渲染的想法是使用React路由静态上下文作为在React和服务器之间交换信息的向量。*图10.4*展示了它是如何工作的：
- en: '![../../../Downloads/Untitled%20Diagram%20(15).png](img/B15729_10_04.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![../../../Downloads/Untitled Diagram (15).png](img/B15729_10_04.png)'
- en: 'Figure 10.4: Two-pass rendering schematic'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：双次渲染示意图
- en: 'The steps of two-pass rendering are as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 双次渲染的步骤如下：
- en: The server calls `renderToString()`, passing the URL received from the client
    and an empty static context object to the React application.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器调用`renderToString()`，将客户端接收到的URL和一个空的静态上下文对象传递给React应用程序。
- en: The React application will perform the routing process and select the components
    that need to be rendered for the given URL. Every component that requires to load
    some data asynchronously will need to implement some extra logic to allow such
    data to be preloaded on the server as well. This can be done by attaching a promise
    representing the result of the data loading operation to the router static context.
    This way, at the end of the rendering process, the server will receive an incomplete
    markup (representing the current loading state) and the static context will contain
    a number of promises representing data loading operations.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React应用程序将执行路由过程并选择需要为给定URL渲染的组件。每个需要异步加载数据的组件都需要实现一些额外的逻辑，以便允许这些数据在服务器上也被预加载。这可以通过将表示数据加载操作结果的promise附加到路由静态上下文中来完成。这样，在渲染过程结束时，服务器将收到一个不完整的标记（表示当前的加载状态），而静态上下文将包含表示数据加载操作的一系列promise。
- en: At this point, the server can look at the static context and wait for all the
    promises to settle to make sure that all the data has been preloaded completely.
    During this process, the server builds a new static context that contains the
    results returned by the promises. This new static context is used for a second
    round of rendering. This is why this technique is called two-pass rendering.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，服务器可以查看静态上下文并等待所有promise解决，以确保所有数据都已完全预加载。在这个过程中，服务器构建一个新的静态上下文，其中包含promise返回的结果。这个新的静态上下文用于第二轮渲染。这就是为什么这种技术被称为双次渲染。
- en: Now, the ball is again on the React side of the field. The routing process should
    pick the same components used during the first rendering pass, since the URL has
    not changed. This time, the components that need data preloading should see that
    such data is already available in the static context and they can render the view
    straight away. This step produces a complete static markup that the server can
    now use.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，球再次回到了React的一侧。路由过程应该选择在第一次渲染过程中使用的相同组件，因为URL没有改变。这次，需要预加载数据的组件应该看到这些数据已经在静态上下文中可用，并且它们可以直接渲染视图。这一步产生了一个完整的静态标记，服务器现在可以使用它。
- en: At this point, the server has the complete markup and it uses it to render the
    final HTML page. The server can also include all the preloaded data in a `script`
    tag so that, on the browser, the data will be already available so there won't
    be any need to load it again while visiting the first page of the application.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，服务器已经拥有了完整的标记，并使用它来渲染最终的HTML页面。服务器还可以在`script`标签中包含所有预加载的数据，这样在浏览器上，数据将已经可用，因此在访问应用程序的第一页时，无需再次加载它。
- en: This technique is very powerful and has some interesting advantages. For instance,
    it allows you to organize your React components tree in a very flexible way. You
    can have multiple components requesting asynchronous data, and they can be placed
    at any level of the components tree.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术非常强大，并且具有一些有趣的优势。例如，它允许你以非常灵活的方式组织你的 React 组件树。你可以拥有多个请求异步数据的组件，并且它们可以放置在组件树的任何级别。
- en: In more advanced use cases, you can also have data being loaded over multiple
    rendering passes. For instance, during the second pass, a new component in the
    tree might be rendered and this component might also need to load data asynchronously
    so it can just add new promises to the static context. To support this particular
    case, the server will have to continue the rendering loop until there are no more
    promises left in the static context. This particular variation of the two-pass
    rendering technique is referred to as **multi-pass rendering**.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高级的使用案例中，你也可以有在多个渲染过程中加载数据的情况。例如，在第二次渲染过程中，树中的新组件可能会被渲染，并且这个组件可能也需要异步加载数据，以便它可以将新的承诺添加到静态上下文中。为了支持这种特殊情况，服务器将不得不继续渲染循环，直到静态上下文中没有更多的承诺为止。这种两次渲染技术的特定变体被称为
    **多遍渲染**。
- en: The biggest disadvantage of this technique is that every call to `renderToString()`
    is not cheap and in real-life applications, this technique might force the server
    to go through multiple rendering passes, making the whole process very slow.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的最大缺点是每次调用 `renderToString()` 都不便宜，在实际应用中，这种技术可能会迫使服务器进行多次渲染过程，从而使整个过程非常缓慢。
- en: This might lead to severe performance degradation on the entire application,
    which can dramatically affect the user experience.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致整个应用程序的性能严重下降，这可能会极大地影响用户体验。
- en: A simpler but potentially more performant alternative will be discussed in the
    next section.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个更简单但可能更高效的替代方案。
- en: Async pages
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步页面
- en: The technique we are going to describe here, which we are going to call "async
    pages," is based on a more constrained structure of the React application.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要描述的技术，我们将称之为“异步页面”，基于一个更受限的 React 应用程序结构。
- en: The idea is to structure the top layers of the application components tree in
    a very specific way. Let's have a look at a possible structure first, then it
    will be easier to discuss how this specific approach can help us with asynchronous
    data loading.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将应用程序组件树的顶层结构以非常具体的方式进行组织。让我们先看看一种可能的结构，然后这将更容易讨论这种特定方法如何帮助我们进行异步数据加载。
- en: '![](img/B15729_10_05.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15729_10_05.png)'
- en: 'Figure 10.5: Async pages components tree structure'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：异步页面组件树结构
- en: 'In *Figure 10.5*, we have represented the structure that allows us to apply
    the async pages technique. Let''s discuss in detail the scope of every layer in
    the components tree:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 10.5* 中，我们展示了允许我们应用异步页面技术的结构。让我们详细讨论组件树中每一层的范围：
- en: The root of the application is always a `Router` component (`StaticRouter` on
    the server and `BrowserRouter` on the client).
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的根始终是一个 `Router` 组件（服务器上的 `StaticRouter` 和客户端上的 `BrowserRouter`）。
- en: The application component is the only child of the `Router` component.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序组件是 `Router` 组件的唯一子组件。
- en: The only child of the application component is a `Switch` component from the
    `react-router-dom` package.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序组件的唯一子组件是来自 `react-router-dom` 包的 `Switch` 组件。
- en: The `Switch` component has one or more `Route` components as children. These
    are used to define all the possible routes and which component should be rendered
    for every route.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Switch` 组件有一个或多个作为子组件的 `Route` 组件。这些用于定义所有可能的路由以及每个路由应该渲染哪个组件。'
- en: 'This is the most interesting layer as we actually introduce the concept of
    a "page component." The idea is that a page component is responsible for the look
    and feel of an entire page. A page component can have an arbitrary subtree of
    components used to render the current view; for instance, a header, a body, and
    a footer. We can have two types of page components: regular page components that
    behave as any other React components and `AsyncPage` components. Async pages are
    special *stateful* components that need to preload data for the page to be rendered
    both on the server- and the client side. They implement a special static method
    called `preloadAsyncData()` that contains the logic necessary to preload the data
    for the given page.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是最具趣味性的层次，因为我们实际上引入了“页面组件”的概念。这个想法是页面组件负责整个页面的外观和感觉。页面组件可以包含任意子组件树，用于渲染当前视图；例如，页眉、主体和页脚。我们可以有两种类型的页面组件：常规页面组件，它们的行为类似于任何其他React组件，以及`AsyncPage`组件。异步页面是特殊的*有状态*组件，需要在服务器端和客户端渲染页面之前预加载数据。它们实现了一个名为`preloadAsyncData()`的特殊静态方法，该方法包含预加载数据所需的逻辑。
- en: You can see that layers 1 to 4 are responsible for the routing logic, while
    level 5 is responsible for data loading and for actually rendering the current
    page. There are no other nested layers for additional routing and data loading.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，第1到4层负责路由逻辑，而第5层负责数据加载和实际渲染当前页面。没有其他嵌套层用于额外的路由和数据加载。
- en: Technically, there could be additional layers for routing and data loading after
    level 5, but those won't be universally available as they will be resolved only
    on the client side after the page has been rendered.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在第5层之后可能有额外的路由和数据加载层，但它们不会普遍可用，因为它们将在页面渲染后仅在客户端解决。
- en: Now that we've discussed this more rigid structure, let's see how it can be
    useful to avoid multiple rendering passes and achieve universal data retrieval.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了这种更严格的结构，让我们看看它如何有助于避免多次渲染遍历并实现通用数据检索。
- en: 'Here''s the idea: if we have our routes defined in a dedicated file as an array
    of paths and components, we can easily reuse this file on the server side and
    determine, before the React rendering phase, which page component we will actually
    end up rendering.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是想法：如果我们把我们的路由定义在一个专门的文件中，作为一个路径和组件的数组，我们就可以轻松地在服务器端重用这个文件，并在React渲染阶段之前确定我们将实际渲染哪个页面组件。
- en: Then, we can see if this page component is an `AsyncPage`. If it is, it means
    we have to preload some data on the server side before the rendering. We can do
    this by calling the `preloadAsyncData()` method from the given component.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以查看这个页面组件是否是`AsyncPage`。如果是，这意味着我们必须在渲染之前在服务器端预加载数据。我们可以通过从给定组件调用`preloadAsyncData()`方法来完成此操作。
- en: Once the data has been preloaded, this can be added in the static context and
    we can render the entire application. During the rendering phase, the `AsyncPage`
    component will see that its data is already preloaded and available in the static
    context and it will be able to render straight away, skipping the loading state.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被预加载，我们就可以将其添加到静态上下文中，并渲染整个应用程序。在渲染阶段，`AsyncPage`组件将看到其数据已经预加载并可在静态上下文中使用，它将能够立即渲染，跳过加载状态。
- en: Once the rendering is finished, the server can add the same preloaded data in
    a `script` tag so that, on the browser side, the user won't have to wait for the
    data to be loaded again.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦渲染完成，服务器可以在`script`标签中添加相同的预加载数据，这样在浏览器端，用户就不必等待再次加载数据。
- en: The Next.js framework ([nodejsdp.link/nextjs](http://nodejsdp.link/nextjs))
    is a popular framework for Universal JavaScript applications and adopts a similar
    technique to the one described here, so it is a good example of this pattern in
    the wild.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js框架([nodejsdp.link/nextjs](http://nodejsdp.link/nextjs))是一个流行的通用JavaScript应用程序框架，它采用了与这里描述的类似的技术，因此它是这种模式在野外的良好示例。
- en: Implementing async pages
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现异步页面
- en: Now that we know how to solve our data fetching problems, let's implement the
    async pages technique in our application.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何解决我们的数据获取问题，让我们在我们的应用程序中实现异步页面技术。
- en: Our components tree is already structured in a way that it's compliant to what's
    expected by this technique. Our pages are the `AuthorsIndex` component, the `Author`
    component, and the `FourOhFour` component. The first two require universal data
    loading, so we will have to convert them into async pages.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件树已经以符合这种技术预期的方式进行了结构化。我们的页面是`AuthorsIndex`组件、`Author`组件和`FourOhFour`组件。前两个需要全局数据加载，因此我们必须将它们转换为异步页面。
- en: 'Let''s start to update our application by extrapolating the route definitions
    into a dedicated file, `src/frontend/routes.js`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将路由定义扩展到专门的文件`src/frontend/routes.js`开始更新我们的应用程序：
- en: '[PRE61]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We want this configuration file to be the source of truth for the router configuration
    across the various parts of the application, so let''s refactor the frontend `App`
    component to use this file as well:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个配置文件成为应用程序各个部分中路由配置的真相来源，因此让我们重构前端`App`组件，使其也能使用这个文件：
- en: '[PRE62]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, the only change here is that, rather than defining the various
    `Route` components inline, we build them dynamically starting from the `routes`
    configuration array. Any change in the `routes.js` file will be automatically
    reflected in the application as well.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里唯一的改变是，我们不再在行内定义各种`Route`组件，而是从`routes`配置数组动态构建它们。`routes.js`文件中的任何更改都将自动反映在应用程序中。
- en: At this point, we can update the server-side logic in `src/server.js`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以更新`src/server.js`中的服务器端逻辑。
- en: The first thing that we want to do is import a utility function from the `react-router-dom`
    package that allows us to see if a given URL matches a given React router path
    definition. We also need to import the `routes` array from the new `routes.js`
    module.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是从`react-router-dom`包中导入一个实用函数，该函数允许我们查看给定的URL是否与给定的React路由路径定义匹配。我们还需要从新的`routes.js`模块中导入`routes`数组。
- en: '[PRE63]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, let''s update our server-side HTML template generation function to be
    able to embed preloaded data in our page:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的服务器端HTML模板生成函数，以便能够在我们的页面中嵌入预加载的数据：
- en: '[PRE64]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see, our template now accepts a new argument called `serverData`.
    If this argument is passed to the `template` function, it will render a `script`
    tag that will inject this data into a global variable called `window.__STATIC_CONTEXT__`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的模板现在接受一个名为`serverData`的新参数。如果将此参数传递给`template`函数，它将渲染一个`script`标签，将此数据注入名为`window.__STATIC_CONTEXT__`的全局变量中。
- en: 'Now, let''s get into the meaty bit; let''s rewrite the server-side rendering
    logic:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入重点部分；让我们重写服务器端渲染逻辑：
- en: '[PRE65]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'There are quite some changes here. Let''s discuss the main blocks one by one:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多更改。让我们逐一讨论主要块：
- en: 'The first change aims to detect which page will be rendered for the current
    URL. We loop through the defined `routes` and we use the `matchPath` utility to
    verify if `location` matches the current `route` definition. If it does, we stop
    the loop and record which component will be rendered in the `component` variable.
    We can be sure a component will be matched here because our last route (the `404`
    page) will always match. The `match` variable will contain information about the
    match. For instance, if the route contains some parameters, `match` will contain
    the path fragment that matched every parameter. For instance, for the URL `/author/joyce`,
    `match` will have the property `params` equal to `{ authorId: ''joyce'' }`. This
    is the same prop that a page component will receive from the router when rendered.'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '第一个更改的目的是检测当前URL将渲染哪个页面。我们遍历定义的`routes`，并使用`matchPath`实用函数来验证`location`是否与当前`route`定义匹配。如果匹配，我们停止循环并在`component`变量中记录将渲染的组件。我们可以确信这里会匹配一个组件，因为我们的最后一个路由（`404`页面）总是会匹配。`match`变量将包含有关匹配的信息。例如，如果路由包含一些参数，`match`将包含匹配每个参数的路径片段。例如，对于URL
    `/author/joyce`，`match`将具有属性`params`等于`{ authorId: ''joyce'' }`。这就是页面组件在渲染时将从路由接收到的相同属性。'
- en: In the second block of changes, we check if the selected component is an `AsyncPage`.
    We do that by checking if the component has a static method called `preloadAsyncData`.
    If that's the case, we invoke that function by passing an object that contains
    the `match` object as an argument (this way, we propagate any parameter that might
    be needed to fetch the data, such as `authorId`). This function should return
    a promise. If the promise resolves, we have successfully preloaded the data for
    this component. If it rejects, we make sure to record the error. Finally, we create
    the `staticContext` object. This object maps the preloaded data (or the rejection
    error) to the current location. The reason why we keep the location as a key is
    to be sure that if, for any reason, the browser renders another page from the
    one we preloaded (because of a programmatic error or because of a user action,
    like hitting the back button on the browser before the page is fully loaded),
    we won't end up using preloaded data that is not relevant to the current page
    on the browser.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个更改块中，我们检查所选组件是否为`AsyncPage`。我们通过检查组件是否有一个名为`preloadAsyncData`的静态方法来完成此操作。如果是这种情况，我们通过传递一个包含`match`对象作为参数的对象来调用该函数（这样，我们可以传播可能需要的任何参数，例如`authorId`）。这个函数应该返回一个承诺。如果承诺解决，我们已成功预加载数据。如果它拒绝，我们确保记录错误。最后，我们创建`staticContext`对象。此对象将预加载数据（或拒绝错误）映射到当前位置。我们保留位置作为键的原因是确保如果由于任何原因，浏览器渲染了另一个页面（因为程序错误或用户操作，例如在页面完全加载之前在浏览器中点击后退按钮），我们不会使用与当前浏览器页面不相关的预加载数据。
- en: In the last block of changes, we invoke the `renderToString()` function to get
    the rendered HTML of the application. Note that since we are passing a static
    context containing the preloaded data, we expect that the application will be
    able to completely render the page without returning a loading state view. This
    does not happen magically, of course. We will need to add some logic to our React
    component to check if the necessary data is already available in the static context.
    Once we have the generated HTML, we use our `template()` function to generate
    the complete page markup and we return it to the browser. We also make sure to
    respect the status code. For instance, if we ended up rendering the `FourOhFour`
    component, we will have the `statusCode` property in the static context changed,
    so if that's the case, we use that value for the final status code; otherwise,
    we default to `200`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一个更改块中，我们调用`renderToString()`函数以获取应用的渲染HTML。请注意，由于我们传递了一个包含预加载数据的静态上下文，我们期望应用能够完全渲染页面而不会返回加载状态视图。当然，这并不是神奇发生的。我们需要在我们的React组件中添加一些逻辑来检查必要的数据是否已经在静态上下文中可用。一旦我们有了生成的HTML，我们使用我们的`template()`函数来生成完整的页面标记，并将其返回给浏览器。我们还确保尊重状态码。例如，如果我们最终渲染了`FourOhFour`组件，我们将在静态上下文中更改`statusCode`属性，因此如果这种情况发生，我们使用该值作为最终状态码；否则，我们默认为`200`。
- en: That's it for our server-side rendering.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染到此结束。
- en: 'Now, it''s time to create the async page abstraction in our React application.
    Since we are going to have two distinct async pages, a good way to reuse some
    code is to create a base class and to use the Template pattern that we already
    discussed in *Chapter 9*, *Behavioral Design Patterns*. Let''s define this class
    in `src/frontend/components/pages/AsyncPage.js`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在我们的React应用中创建异步页面抽象了。由于我们将有两个不同的异步页面，一个很好的代码重用方法是创建一个基类，并使用我们已经在*第9章*，*行为设计模式*中讨论过的模板模式。让我们在`src/frontend/components/pages/AsyncPage.js`中定义这个类：
- en: '[PRE66]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This class provides helper code for building a stateful component that can
    handle three possible scenarios:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 本类提供构建一个能够处理三种可能场景的有状态组件的辅助代码：
- en: We are rendering on the server and we already have the data preloaded (no need
    to load the data).
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在服务器上渲染，并且已经预加载数据（无需加载数据）。
- en: We are rendering on the client and the data is already available in the page
    through the `__STATIC_CONTEXT__` variable (no need to load the data).
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在客户端渲染，并且数据已经通过`__STATIC_CONTEXT__`变量在页面中可用（无需加载数据）。
- en: We are rendering on the client and the data is not available (for instance,
    if this page was not rendered by the server, but a page the user navigated to
    after the first load). In this case, the data has to be dynamically loaded from
    the client when the component is mounted.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在客户端进行渲染，但数据不可用（例如，如果这个页面不是由服务器渲染的，而是用户在第一次加载后导航到的页面）。在这种情况下，数据必须在组件挂载时从客户端动态加载。
- en: 'Let''s review the main points of this implementation together:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起回顾一下这个实现的要点：
- en: This component class should not be instantiated directly but only extended when
    implementing async pages. When this class is extended, the async page component
    will need to implement the methods `static async preloadAsyncData(props)` and
    `render()`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个组件类不应该直接实例化，而只能在实现异步页面时扩展。当这个类被扩展时，异步页面组件将需要实现 `static async preloadAsyncData(props)`
    和 `render()` 方法。
- en: 'In the constructor, we have to initialize the component state. There are two
    possible outcomes here: the data is already available (so we can set it in the
    state) or the data is not available (so we need to set the state to "loading"
    and let the component load the data once it''s mounted on the page). If we are
    on the browser and we load the data from the static context, we also make sure
    to delete this data from the context. This will allow the user to see fresh data
    if they happen to go back to this page during the navigation.'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们必须初始化组件状态。这里有两种可能的结果：数据已经可用（因此我们可以将其设置在状态中）或数据不可用（因此我们需要将状态设置为“加载中”，并让组件在页面挂载后加载数据）。如果我们正在浏览器中，并从静态上下文加载数据，我们还要确保从上下文中删除这些数据。这将使用户在导航过程中返回此页面时看到新鲜的数据。
- en: The method `componentDidMount()` is executed by React only on the browser. Here,
    we handle the case where the data was not preloaded and we have to dynamically
    load it at runtime.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 只在浏览器中执行 `componentDidMount()` 方法。在这里，我们处理数据未预先加载的情况，并在运行时动态加载它。
- en: 'Now that we have this useful abstraction in place, we can rewrite our `AuthorsIndex`
    and `Author` components and convert them into async pages. Let''s start with `AuthorsIndex`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个有用的抽象，我们可以重写我们的 `AuthorsIndex` 和 `Author` 组件，并将它们转换为异步页面。让我们从 `AuthorsIndex`
    开始：
- en: '[PRE67]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see here, our `AuthorsIndex` component now extends `AsyncPage`. Since
    the `AsyncPage` template will take care of all the state management in its constructor,
    we don't need a constructor here anymore; we just need to specify the business
    logic to load the data in the `preloadAsyncData()` method.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的 `AuthorsIndex` 组件现在扩展了 `AsyncPage`。由于 `AsyncPage` 模板将在其构造函数中处理所有状态管理，我们在这里不再需要构造函数；我们只需要在
    `preloadAsyncData()` 方法中指定加载数据的业务逻辑。
- en: If you compare this implementation with the previous one, you might notice that
    the logic of this method is almost the same as what we had previously in `componentDidMount()`.
    The method `componentDidMount()` has been removed from here because the one we
    inherit from `AsyncPage` will suffice. The only difference between the previous
    version of `componentDidMount()` and `preloadAsyncData()` is that in `preloadAsyncData()`,
    we don't set the internal state directly; we just need to return the data. The
    underlying code in `AsyncPage` will update the state as needed for us.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个实现与之前的版本进行比较，你可能会注意到这个方法的逻辑几乎与我们在之前的 `componentDidMount()` 中所拥有的相同。`componentDidMount()`
    方法已经被从这里移除，因为我们从 `AsyncPage` 继承的那个就足够了。`componentDidMount()` 的上一个版本和 `preloadAsyncData()`
    之间的唯一区别是，在 `preloadAsyncData()` 中，我们不会直接设置内部状态；我们只需要返回数据。`AsyncPage` 中的底层代码将根据需要为我们更新状态。
- en: 'Let''s now rewrite the `Author` component:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在重写 `Author` 组件：
- en: '[PRE68]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The changes here are perfectly in line with the changes we made for the `AuthorsIndex`
    component. We are only moving the data loading logic into `preloadAsyncData()`
    and letting the underlying abstraction manage the state transition for us.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的更改与我们对 `AuthorsIndex` 组件所做的更改完全一致。我们只是将数据加载逻辑移动到 `preloadAsyncData()` 中，并让底层的抽象为我们管理状态转换。
- en: Now, we can apply just a last small optimization in our `src/frontend/index.js`
    file. We can swap the `reactDOM.render()` function call with `reactDOM.hydrate()`.
    Since we will produce exactly the same markup from both the server side and the
    client side, this will make React a bit faster to initialize during the first
    browser load.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `src/frontend/index.js` 文件中应用最后的微小优化。我们可以将 `reactDOM.render()` 函数调用与
    `reactDOM.hydrate()` 交换。由于我们将从服务器端和客户端生成完全相同的标记，这将使 React 在第一次浏览器加载时初始化更快。
- en: We are finally ready to try all these changes. Make sure to rebuild the frontend
    bundle and relaunch the server. Have a look at the application and the code that
    is generated by the server; it should contain all the preloaded data for every
    page. Also, `404` errors should be reported correctly for every `404` page, including
    the ones for missing authors.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好尝试所有这些变化了。确保重新构建前端包并重新启动服务器。查看应用和服务器生成的代码；它应该包含每个页面的预加载数据。此外，对于每个`404`页面，包括缺失作者的页面，都应该正确报告`404`错误。
- en: 'Great! We finally managed to build an application that efficiently shares code,
    logic, and data between the client and the server: a true Universal JavaScript
    application!'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们终于成功地构建了一个能够高效地在客户端和服务器之间共享代码、逻辑和数据的应用程序：一个真正的通用JavaScript应用程序！
- en: Summary
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the innovative and fast-moving world of Universal
    JavaScript. Universal JavaScript opens up a lot of new opportunities in the field
    of web development and it can help you build single-page applications that load
    fast, are accessible, and are optimized for search engines.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了创新且快速发展的通用JavaScript世界。通用JavaScript在Web开发领域开辟了许多新的机会，它可以帮助你构建快速加载、可访问且针对搜索引擎优化的单页应用程序。
- en: In this chapter, we focused on introducing all the basics of this subject. We
    started from exploring module bundlers, why we need them, and how they work. We
    learned how to use webpack, and then we introduced React and discussed some of
    its functionality. We learned how to build component-oriented user interfaces
    and then started to build an application from scratch to explore universal rendering,
    universal routing, and universal data retrieval.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于介绍这个主题的所有基础知识。我们从探索模块打包器开始，讨论为什么我们需要它们以及它们是如何工作的。我们学习了如何使用webpack，然后介绍了React并讨论了一些其功能。我们学习了如何构建面向组件的用户界面，然后从头开始构建一个应用程序来探索通用渲染、通用路由和通用数据检索。
- en: Even though we discussed a lot of topics, we barely scratched the surface of
    this wide topic, but you should have gained all the necessary knowledge to keep
    exploring this world on your own if you are interested in knowing more. Given
    that this field is still evolving quite rapidly, tools and libraries will probably
    change a lot in the next few years, but all the basic concepts should stay there,
    so don't be afraid to keep exploring and experimenting. Becoming an expert on
    this topic is now just a matter of using the acquired knowledge to build a first
    real-world app with real, business-driven use cases.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们讨论了许多主题，但我们只是触及了这个广泛主题的皮毛，但如果你对了解更多内容感兴趣，你应该已经获得了继续独自探索这个世界的所有必要知识。鉴于这个领域仍在快速发展，工具和库在接下来的几年里可能会发生很大变化，但所有基本概念都应该保持不变，所以不要害怕继续探索和实验。成为这个主题的专家现在只是利用所获得的知识来构建一个第一个真实世界的应用，该应用具有真实、以业务为导向的使用案例。
- en: It's also worth underlining that the knowledge acquired here might be useful
    for projects that cross the boundaries of web development, like mobile app development.
    If you are interested in this topic, React Native might be a good starting point.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得强调的是，在这里获得的知识可能对跨越网络开发边界的项目有用，比如移动应用开发。如果你对这个主题感兴趣，React Native可能是一个好的起点。
- en: In the next chapter, we are going to take a problem-solution approach to explore
    some more advanced topics. Are you ready?
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将采用问题-解决方案的方法来探索一些更高级的主题。你准备好了吗？
- en: Exercises
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**10.1 A matter of style**: Our little library application looks very barebone.
    It could look a lot better with some style and images. Why don''t you try to improve
    the look of the app? If you get stuck or need some inspiration, you can check
    our version of this exercise on GitHub ([nodejsdp.link/univ](http://nodejsdp.link/univ)).'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10.1 风格问题**：我们的小型库应用看起来非常简陋。通过添加一些风格和图片，它可以看起来好得多。你为什么不尝试改善应用的外观呢？如果你遇到困难或需要一些灵感，你可以在GitHub上查看我们这个练习的版本（[nodejsdp.link/univ](http://nodejsdp.link/univ)）。'
- en: '**10.2 Proper data management**: As we said, keeping a lot of data in a file
    is not a great idea. Why don''t you try to move all the data into a real database
    backend of your choice? At this point, you might also want to take this application
    to the next level and write some script to import data from a big collection of
    books like the Open Library archive ([nodejsdp.link/open-libary-api](http://nodejsdp.link/open-libary-api)).'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10.2 正确的数据管理**：正如我们所说，将大量数据保存在文件中并不是一个好主意。你为什么不尝试将所有数据移动到你所选择的真正数据库后端呢？在这个阶段，你也可能想要将这个应用程序提升到下一个层次，并编写一些脚本从像Open
    Library档案（[nodejsdp.link/open-libary-api](http://nodejsdp.link/open-libary-api)）这样的大规模书籍集合中导入数据。'
- en: '**10.3 Pagination and search**: Now that you have a more significant database,
    it''s probably time to add some important features like search and pagination.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10.3 分页和搜索**：既然你已经拥有了一个更大的数据库，可能现在是时候添加一些重要功能，比如搜索和分页。'
- en: '**10.4 A Universal… Blog!**: Build a new universal JavaScript app from scratch
    that implements a blog. Then, try the same exercise using a framework like Next.js
    ([nodejsdp.link/nextjs](http://nodejsdp.link/nextjs)) or Gatsby ([nodejsdp.link/gatsby](http://nodejsdp.link/gatsby)).'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10.4 一个通用的…博客**！：从头开始构建一个新的通用JavaScript应用程序，实现一个博客。然后，尝试使用像Next.js ([nodejsdp.link/nextjs](http://nodejsdp.link/nextjs))
    或 Gatsby ([nodejsdp.link/gatsby](http://nodejsdp.link/gatsby)) 这样的框架来完成同样的练习。'
