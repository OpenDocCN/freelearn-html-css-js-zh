<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-79"><a id="_idTextAnchor080"/>5</h1>
<h1 id="_idParaDest-80"><a id="_idTextAnchor081"/>Custom Events with Actions</h1>
<p>Actions are one of the most powerful features of Svelte.</p>
<p>They are a lightweight alternative to a component that encapsulates logic and data into a reusable unit. They help us reuse the same logic on different elements.</p>
<p>While components have life cycle methods such as <code>onMount</code> and <code>onDestroy</code> that run when all the elements within the component are added to or removed from the DOM, actions are designed to handle the logic for individual elements, running only when that specific element is added to or removed from the DOM.</p>
<p>While components can receive and react to prop changes, you can pass data to actions from a parent component to a child component. The actions will react when the data is changed and you can specify how the action should react when that data changes.</p>
<p>Actions<a id="_idIndexMarker183"/> are simple yet amazingly versatile. You can use them for various things. In this and the following chapters, we are going to explore some of the use cases of actions.</p>
<p>One of the many use cases of actions is to manage elements’ event listeners. Event listeners are very common in web applications as they allow us to implement specific behaviors in response to user actions. This makes our application more interactive and dynamic. So, it will be interesting to see how Svelte actions can be used to help us manage event listeners.</p>
<p>In this chapter, we will start by looking at how we can use actions to help manage event listeners for elements. We will follow that up with examples and exercises to reinforce the idea.</p>
<p>This chapter includes sections on the following:</p>
<ul>
<li>Managing event listeners with actions</li>
<li>Creating custom events with actions</li>
</ul>
<h1 id="_idParaDest-81"><a id="_idTextAnchor082"/>Technical requirements</h1>
<p>You can find the projects of the chapter here: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05</a><a href="https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter05%0D"/></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/>Defining actions</h1>
<p>Before we<a id="_idIndexMarker184"/> start to talk about using Svelte actions to create custom events, let’s quickly recap how to define an action in Svelte.</p>
<p>In Svelte, an action is nothing but a function that follows an action contract. This means if a function follows a specific function signature, it is considered an action. Here is the function signature of an action:</p>
<pre class="source-code">
function action(node) {
  return {
    destroy() {}
  };
}</pre> <p>It is a function that optionally returns an object that has a <code>destroy</code> method.</p>
<p>In this case, since the <code>action</code> function follows the action contract, it is a Svelte action.</p>
<p>To use the Svelte action on an element, you can use the <code>use:</code> directive:</p>
<pre class="source-code">
&lt;div use:action /&gt;</pre> <p>Here, we used the Svelte action named <code>action</code> on the <code>div</code> element.</p>
<p>So, what will happen to the <code>div</code> element with a Svelte action?</p>
<p>When the <code>&lt;div&gt;</code> element is mounted to the DOM, Svelte will call the <code>action</code> function with the reference to the <code>&lt;</code><code>div&gt;</code> element:</p>
<pre class="source-code">
const action_obj = action(div);</pre> <p>When the element is removed from the DOM, Svelte will call the <code>destroy</code> method from the object returned from calling the <code>action</code> function:</p>
<pre class="source-code">
if (action_obj &amp;&amp; action_obj.destroy) action_obj.destroy();</pre> <p>We can customize the behavior of a Svelte action by using parameters. We can pass in an extra parameter to the <code>action</code> function:</p>
<pre class="source-code">
function action(node, parameter) {
  return {
   update(parameter) {},
   destroy() {},
  };
}</pre> <p>Also, you<a id="_idIndexMarker185"/> can add another method to the returning object, <code>update</code>, which will be called when the value of the parameter changes:</p>
<pre class="source-code">
action_obj.update(new_value);</pre> <p>To pass in an additional parameter, you can specify it in a similar syntax as the <code>value</code> attribute:</p>
<pre class="source-code">
&lt;div use:action={value} /&gt;</pre> <p>Now that we know how to use and define an action in Svelte, let’s take a look at our first use case of actions.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Reusing DOM event logic with custom events</h1>
<p>Before we start <a id="_idIndexMarker186"/>talking directly about actions, let’s look at an example of using the <code>mousedown</code> and <code>mouseup</code> events to <a id="_idIndexMarker187"/>create a long-press behavior. We<a id="_idIndexMarker188"/> shall see how this simple example will lead us on to Svelte actions:</p>
<pre class="source-code">
&lt;script&gt;
  let timer;
  function handleMousedown() {
    timer = setTimeout(() =&gt; {
      console.log('long press!');
    }, 2000);
  }
  function handleMouseup() {
    clearTimeout(timer);
  }
&lt;/script&gt;
&lt;button
  on:mousedown={handleMousedown}
  on:mouseup={handleMouseup}
/&gt;</pre> <p>In the preceding<a id="_idIndexMarker189"/> example, we tried to implement a long-press behavior in a button. The idea is to press and hold the button<a id="_idIndexMarker190"/> for more than two seconds and then perform some action. As we detect it’s a long press, we print <code>'long press!'</code> into the console.</p>
<p>To implement <a id="_idIndexMarker191"/>the long-press behavior, I attached two event listeners: <code>mousedown</code> and <code>mouseup</code>. The two event listeners work together. <code>mousedown</code> starts counting down using <code>setTimeout</code> for two seconds, and <code>mouseup</code> clears the countdown using <code>clearTimeout</code>. If the user did not hold onto the button for long enough, the timeout would not be triggered and it would not be considered a long press. Note that to coordinate the timers between the two event listeners, the <code>timer</code> variable is shared across the event listeners.</p>
<p>As you can see, to implement a long-press behavior, you will need two event listeners and one shared variable.</p>
<p>Now, what if you need to have this long-press behavior on another button?</p>
<p>You can’t really share the same event listener and the variable, as you might want a different duration to be considered as a timeout or a different behavior when a long press happens.</p>
<p>So, you would have to redeclare them again and remember to pair the right event with the right event listener.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor085"/>Encapsulating logic into a component</h2>
<p>A way<a id="_idIndexMarker192"/> to recreate a different long-press button is to encapsulate it as a component, putting all the long-press button logic into a component and reusing the component as a means to reuse the logic.</p>
<p>When you define a component, you define the logic as well as the elements in the component. This means that if we put both the long-press logic and the <code>button</code> element into the component, we have to use the long-press logic together with the <code>button</code> element and no other elements.</p>
<p>If you want to customize the element, maybe by using a different element, having a different style, showing a different text content, or adding more event listeners, you would have to define the styles, text contents, or event listeners as props of the component and pass them into the <code>button</code> element in the component:</p>
<pre class="source-code">
&lt;!-- LongPressButton.svelte --&gt;
&lt;button
  // besides the longpress behavior
  on:mousedown={handleMousedown}
  on:mouseup={handleMouseup}
  // you need to pass down props as attributes
  <strong class="bold">{...$$props}</strong>
  // and also forward events up
  <strong class="bold">on:click</strong>
  <strong class="bold">on:dblclick</strong>
&gt;
  &lt;slot /&gt;
&lt;/button&gt;</pre> <p>In the preceding code, we passed in extra attributes from the props into the <code>button</code> element along with forwarding two events, <code>click</code> and <code>dblclick</code>, from the button element out to the component.</p>
<p>The point I <a id="_idIndexMarker193"/>am trying to make here is that if you wish to reuse event listener logic via components, you will find yourself having to take care of other attributes that go along with the element in the component.</p>
<p>We can do much more with a component, but if we are trying to reuse just the long-press behavior, then reusing it by defining it in a component is a bit overkill, and it can grow unmanageable rather quickly.</p>
<p>So, what other options do we have?</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Encapsulating logic into an action</h2>
<p>A better<a id="_idIndexMarker194"/> option is to use an action to encapsulate the long-press behavior.</p>
<p>Let’s just do that and then I’ll explain why using an action is a better approach:</p>
<pre class="source-code">
function longPress(node) {
  let timer;
  function handleMousedown() {
    timer = setTimeout(() =&gt; {
      console.log('long press!');
    }, 2000);
  }
  function handleMouseup() {
    clearTimeout(timer);
  }
  node.addEventListener('mousedown', handleMousedown);
  node.addEventListener('mouseup', handleMouseup);
  return {
    destroy() {
     node.removeEventListener('mousedown', handleMousedown);
     node.removeEventListener('mouseup', handleMouseup);
    }
  }
}</pre> <p>With the<a id="_idIndexMarker195"/> action defined (as shown in the preceding code), we can use the action over multiple elements:</p>
<pre class="source-code">
&lt;button use:longPress&gt;Button one&lt;/button&gt;
&lt;button use:longPress&gt;Button two&lt;/button&gt;</pre> <p>You can apply the action to a different type of element:</p>
<pre class="source-code">
&lt;span use:longPress&gt;Hold on to me&lt;/span&gt;</pre> <p>You can also use it alongside other attributes or event listeners:</p>
<pre class="source-code">
&lt;button use:longPress class="..." on:click={...} /&gt;</pre> <p>I hope you can see that the <code>longPress</code> action encapsulates only the long-press behavior. Unlike the <code>LongPressButton</code> component, the <code>longPress</code> action can easily be reused in any element.</p>
<p>So, as a rule of thumb, when abstracting logic from an element, if you are abstracting it together with the elements, it is okay to use a component. But if you only need to abstract the logic behavior from an element, use actions.</p>
<p>Actions are a great tool for abstracting out element-level logic. But there is still one missing piece of the puzzle: how should we add a different long-press handler for a different element? We’ll see how next.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>Passing parameters to an action</h2>
<p>So, how <a id="_idIndexMarker196"/>do we customize the behavior of our <code>longPress</code> action?</p>
<p>You could have probably guessed the answer since you’ve seen it in the previous section. We can customize the behavior of an action by passing parameters into the action.</p>
<p>For example, if we want to have a different function to handle a long-press action on different <code>button</code> elements, we can pass a different function into the action through action parameters:</p>
<pre class="source-code">
&lt;button use:longPress={doSomething1} /&gt;
&lt;button use:longPress={doSomething2} /&gt;</pre> <p>We will then receive this function within the second argument of the action function:</p>
<pre class="source-code">
function longPress(node, fn) {
  // ...
}</pre> <p>We call the function passed in when it is considered a long press:</p>
<pre class="source-code">
fn();</pre> <p>We can similarly pass in other parameters, such as the duration to be considered as a long press.</p>
<p>In Svelte actions, you can only pass in one parameter. To pass in multiple parameters, you will have to turn them into an object and pass them in as one parameter.</p>
<p>Over in our <code>longPress</code> action, we want to pass the function to be called when the <code>longPress</code> action is detected, as well as the duration to be considered a long press, into the <code>longPress</code> action. To pass both the function and the duration in, we create an object that has them as object values and pass the object as the action parameter:</p>
<pre class="source-code">
&lt;button
  use:longPress=<strong class="bold">{{</strong>
<strong class="bold">    onLongPress: doSomething1,</strong>
<strong class="bold">    duration: 5000</strong>
<strong class="bold">  }}</strong> /&gt;</pre> <p>Some of the<a id="_idIndexMarker197"/> parameters in the object could be optional, so we might need to provide a default value when reading them within the action:</p>
<pre class="source-code">
function longPress(node, { onLongPress, duration = 1000 }) {
  // if not specified, the default duration is 1s
}</pre> <p>At this stage, you might wonder, can the <code>onLongPress</code> be optional too?</p>
<p>It does not make much sense in our case since the main goal of our action is to detect a long press and call the <code>onLongPress</code> function.</p>
<p>However, this is a good question.</p>
<p>In some other actions, you may have function handlers that are optional.</p>
<p>For example, what if we have a <code>gesture</code> action that can detect different gestures performed on the element? In that case, each <code>gesture</code> callback function can be optional since you may only be interested in one of the gestures:</p>
<pre class="source-code">
function gesture(node, { onSwipe, onDrag, onPinch }) { }</pre> <p>The <code>onSwipe</code>, <code>onDrag</code>, and <code>onPinch</code> function handlers in this <code>gesture</code> action are optional and could be undefined.</p>
<p>Instead of creating an empty function as a fallback, we should instead check whether the function is defined before calling it:</p>
<pre class="source-code">
if (typeof onSwipe === 'function') onSwipe();</pre> <p>This way, we don’t have to create a function unnecessarily.</p>
<p>However, this gets messier when you have multiple callback functions and you need to check whether each of them has been defined before calling them.</p>
<p>Is there a better way to handle this?</p>
<p>Yes, there is.</p>
<p>In fact, a more idiomatic Svelte way of having an action to notify or call a function when something happens is to dispatch a custom event.</p>
<p>For example, to know whether the user has long-pressed the <code>&lt;button&gt;</code> element, it would be natural to listen to the <code>'longpress'</code> custom event on the <code>&lt;</code><code>button&gt;</code> element:</p>
<pre class="source-code">
&lt;button on:longpress={doSomething1} /&gt;</pre> <p>However, there’s no native event called <code>'longpress'</code>.</p>
<p>But no <a id="_idIndexMarker198"/>worries, we can create a custom <code>'</code><code>longpress'</code> event.</p>
<p>Luckily, we have the <code>longPress</code> action to determine when the user long-presses a button. What we need to create a custom <code>'longpress'</code> event is to trigger the <code>'longpress'</code> event after determining the user has long-pressed a button in our <code>longPress</code> action. And so, in the line of code where we have determined that the user is long-pressing the button, we can dispatch a custom event from the button:</p>
<pre class="source-code">
node.dispatchEvent(new CustomEvent('longpress'));</pre> <p>Let’s listen to the <code>longpress</code> custom event and create the custom <code>'longpress'</code> event in our action. Here is the final code:</p>
<pre class="source-code">
&lt;script&gt;
  function longPress(node, { duration = 1000 } = {}) {
    let timer;
    function handleMousedown() {
      timer = setTimeout(() =&gt; {
        <strong class="bold">node.dispatchEvent(new CustomEvent('longpress'));</strong>
      }, duration);
    }
    function handleMouseup() {
      clearTimeout(timer);
    }
    node.addEventListener('mousedown', handleMousedown);
    node.addEventListener('mouseup', handleMouseup);
    return {
      destroy() {
        node.removeEventListener('mousedown', handleMousedown);
        node.removeEventListener('mouseup', handleMouseup);
     }
    }
  }
&lt;/script&gt;
&lt;button <code>longPress</code> action to the <code>button</code> element, which adds logic to determine whether the button is being long-pressed. When the button is long-pressed, the <code>longPress</code> action dispatches a custom event called <code>'longpress'</code> on the element. To react to and trigger specific behaviors when the custom <code>'longpress'</code> event is dispatched on the element, we can listen to the event by using <code>on:longpress</code> with an event handler.</p>
<p>It may feel like a roundabout way to call a function from an action by dispatching an event, but doing it this way has a few pros:</p>
<ul>
<li>Whether we listen to the <code>'longpress'</code> event on the button or not, the action could still dispatch the <code>'longpress'</code> custom event. So, with this approach, we don’t need to check whether the handler is defined or not.</li>
<li>Listening to the <code>'longpress'</code> event using <code>on:</code> instead of passing the function directly into the action would mean that you could use other Svelte features that come with Svelte’s <code>on:</code> directive. For example, to only listen to the <code>'longpress'</code> event once, you can use the <code>|once</code> event modifier, for example, <code>on:longpress|once</code>.</li>
</ul>
<p>Another way of <a id="_idIndexMarker200"/>describing what we have done with the <code>longPress</code> action is that the <code>longPress</code> action enhances the button element and provides a new event, <code>'longpress'</code>, that can be listened to on the element.</p>
<p>Now that we’ve learned how we can define Svelte actions, and how we can use actions to create new events that we can listen to on an element, let’s look at a few more examples that use this technique.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor088"/>Example – validating form inputs with custom events</h1>
<p>The <a id="_idIndexMarker201"/>example that we are going to<a id="_idIndexMarker202"/> explore is using actions to validate form inputs.</p>
<p>When you add an input <a id="_idIndexMarker203"/>element to your form, you can add attributes such as <code>required</code>, <code>minlength</code>, and <code>min</code> to indicate that the input value has to pass the constraint validation or else would be considered invalid.</p>
<p>However, by default, such a validation check is only done during form submission. There’s no real-time feedback on whether your input is valid as you type.</p>
<p>To make the input element validate as you type, we need to add an <code>'input'</code> event listener (which will be called on every keystroke as we type in the input element) and call <code>input.checkValidity()</code> to validate the input. Now, let’s do just that:</p>
<pre class="source-code">
&lt;input on:input={(event) =&gt; event.target.checkValidity()} /&gt;</pre> <p>As you call the <code>checkValidity()</code> method, if the input is indeed invalid, then it will trigger the <code>'</code><code>invalid'</code> event:</p>
<pre class="source-code">
&lt;input
  on:input={(event) =&gt; event.target.checkValidity()}
  on:invalid={(event) =&gt; console.log(event.target.validity)}
/&gt;</pre> <p>Unfortunately, there’s no <code>'valid'</code> event. So, there’s no way to tell whether the input has passed the validation.</p>
<p>It<a id="_idIndexMarker204"/> would be<a id="_idIndexMarker205"/> great if there were an event called <code>'validate'</code> in which within the event details, we can tell whether the input is valid or not. If it isn’t, we could get an error message about why the input is invalid.</p>
<p>Here’s an example of how we could use the <code>'</code><code>validate'</code> event:</p>
<pre class="source-code">
&lt;input on:validate={(event) =&gt; {
  if (event.detail.isValid) {
    errorMessage = '';
  } else {
    errorMessage = event.detail.errorMessage;
  }
}} /&gt;</pre> <p>There isn’t an <a id="_idIndexMarker206"/>event called <code>'validate'</code>, but we can create this custom event ourselves. So, why not create an action to create this custom event for us?</p>
<p>This logic is well suited to be written as an action for the following reasons:</p>
<ul>
<li>It can be reused in other input elements.</li>
<li>This logic itself is not involved in creating or updating elements. If it were, it would probably be better suited to be a component.</li>
</ul>
<p>Let us write this action:</p>
<ol>
<li>Firstly, this action involves listening to the <code>'input'</code> event listener. So, in the code, as shown, we are going to add an event listener at the start of the action and remove the <code>'input'</code> event listener in the <code>destroy</code> method. This means that whenever an element that uses this action is added to the DOM, it will listen to the <code>'input'</code> event, and when it is removed from the DOM, the event listener will be automatically removed:<pre class="source-code">
function validateOnType(input) {
  input.addEventListener('input', onInput);
  return {
    destroy() {
      input.removeEventListener('input', onInput);
    }
  };
}</pre></li> <li>Next, within<a id="_idIndexMarker207"/> the input handler, we<a id="_idIndexMarker208"/> are going to call <code>checkValidity()</code> to check whether the input is valid. If the input is invalid, then we will read <code>input.validity</code> and determine the error message:<pre class="source-code">
function validateOnType(input) {
  function onInput() {
    const isValid = input.checkValidity();
    const errorMessage = isValid ? '' : getErrorMessage(input.validity);
  }
  // ...
}</pre></li> <li>Finally, we <a id="_idIndexMarker209"/>will dispatch the custom <code>'validate'</code> event with <code>isValid</code> and <code>errorMessage</code> as event details:<pre class="source-code">
function validateOnType(input) {
  function onInput() {
// ...
input.dispatchEvent(
  new CustomEvent(
    'validate',
    { detail: { isValid, errorMessage } }
  )
);
  }
  // ...
}</pre></li> <li>Now, with this action completed, we can enhance the <code>&lt;input&gt;</code> element by adding<a id="_idIndexMarker210"/> a new <code>'validate'</code> event, which will be called <code>as-you-type</code>, letting you know<a id="_idIndexMarker211"/> whether the input is currently valid or invalid. It will also show the corresponding error message:<pre class="source-code">
&lt;input
  use:validateOnType
  on:validate={(event) =&gt; console.log(event.detail)}
/&gt;</pre><p class="list-inset">To make<a id="_idIndexMarker212"/> the validation results more useful to the user, you can use the result from the <code>'validate'</code> event to modify element styles, such as setting the input border color to red when the validation result is invalid, as shown in the following snippet:</p><pre class="source-code">&lt;script&gt;
  let isValid = false;
&lt;/script&gt;
&lt;input
  class:invalid={!isValid}
  use:validateOnType
  on:validate={(event) =&gt; isValid = event.detail.isValid}
/&gt;
&lt;style&gt;
  .invalid { border: red 1px solid; }
&lt;/style&gt;</pre></li> </ol>
<p>Are you<a id="_idIndexMarker213"/> getting<a id="_idIndexMarker214"/> the hang of writing actions that <a id="_idIndexMarker215"/>create custom events?</p>
<p>Let’s try the next one as an exercise. This time, we’ll tackle one of the most common user interactions, drag and drop.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor089"/>Exercise – creating a drag-and-drop event</h1>
<p>A <a id="_idIndexMarker216"/>drag-and-drop behavior means clicking on an element, moving the mouse while holding down the click to drag the element across the screen to the <a id="_idIndexMarker217"/>desired location, and then releasing the mouse click to drop the element in the new location.</p>
<p>A drag-and-drop behavior thus involves coordination between multiple events, namely, <code>'mousedown'</code>, <code>'mousemove'</code>, and <code>'mouseup'</code>.</p>
<p>As we perform the drag-and-drop motion, what we are interested in knowing is when the dragging starts, how far the element is dragged, and when the dragging ends.</p>
<p>These three events can be translated into three custom events: <code>'dragStart'</code>, <code>'dragMove'</code>, and <code>'dragEnd'</code>.</p>
<p>Let us try to <a id="_idIndexMarker218"/>implement the drag-and-drop behavior <a id="_idIndexMarker219"/>as an action that will create these three custom events:</p>
<pre class="source-code">
&lt;div
  use:dragAndDrop
  on:dragStart={...}
  on:dragMove={...}
  on:dragEnd={...}
/&gt;</pre> <p>You can check the answer to this exercise here: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05/03-drag-and-drop">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05/03-drag-and-drop</a>.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor090"/>Summary</h1>
<p>In this chapter, we saw how to define an action. We talked about one of the common patterns of actions, which is to create custom events. This allows us to encapsulate DOM event logic into custom events and reuse them across elements.</p>
<p>In the next chapter, we will look at the next common pattern of actions, which is integrating third-party libraries.</p>
</div>
</div></body></html>