<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer022">
<h1 class="chapter-number" id="_idParaDest-79"><a id="_idTextAnchor080"/>5</h1>
<h1 id="_idParaDest-80"><a id="_idTextAnchor081"/>Custom Events with Actions</h1>
<p>Actions are one of the most powerful features <span class="No-Break">of Svelte.</span></p>
<p>They are a lightweight alternative to a component that encapsulates logic and data into a reusable unit. They help us reuse the same logic on <span class="No-Break">different elements.</span></p>
<p>While components have life cycle methods such as <strong class="source-inline">onMount</strong> and <strong class="source-inline">onDestroy</strong> that run when all the elements within the component are added to or removed from the DOM, actions are designed to handle the logic for individual elements, running only when that specific element is added to or removed from <span class="No-Break">the DOM.</span></p>
<p>While components can receive and react to prop changes, you can pass data to actions from a parent component to a child component. The actions will react when the data is changed and you can specify how the action should react when that <span class="No-Break">data changes.</span></p>
<p>Actions<a id="_idIndexMarker183"/> are simple yet amazingly versatile. You can use them for various things. In this and the following chapters, we are going to explore some of the use cases <span class="No-Break">of actions.</span></p>
<p>One of the many use cases of actions is to manage elements’ event listeners. Event listeners are very common in web applications as they allow us to implement specific behaviors in response to user actions. This makes our application more interactive and dynamic. So, it will be interesting to see how Svelte actions can be used to help us manage <span class="No-Break">event listeners.</span></p>
<p>In this chapter, we will start by looking at how we can use actions to help manage event listeners for elements. We will follow that up with examples and exercises to reinforce <span class="No-Break">the idea.</span></p>
<p>This chapter includes sections on <span class="No-Break">the following:</span></p>
<ul>
<li>Managing event listeners <span class="No-Break">with actions</span></li>
<li>Creating custom events <span class="No-Break">with actions</span></li>
</ul>
<h1 id="_idParaDest-81"><a id="_idTextAnchor082"/>Technical requirements</h1>
<p>You can find the projects of the chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05</span></a><a href="https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter05%0D"/></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/>Defining actions</h1>
<p>Before we<a id="_idIndexMarker184"/> start to talk about using Svelte actions to create custom events, let’s quickly recap how to define an action <span class="No-Break">in Svelte.</span></p>
<p>In Svelte, an action is nothing but a function that follows an action contract. This means if a function follows a specific function signature, it is considered an action. Here is the function signature of <span class="No-Break">an action:</span></p>
<pre class="source-code">
function action(node) {
  return {
    destroy() {}
  };
}</pre> <p>It is a function that optionally returns an object that has a <span class="No-Break"><strong class="source-inline">destroy</strong></span><span class="No-Break"> method.</span></p>
<p>In this case, since the <strong class="source-inline">action</strong> function follows the action contract, it is a <span class="No-Break">Svelte action.</span></p>
<p>To use the Svelte action on an element, you can use the <span class="No-Break"><strong class="source-inline">use:</strong></span><span class="No-Break"> directive:</span></p>
<pre class="source-code">
&lt;div use:action /&gt;</pre> <p>Here, we used the Svelte action named <strong class="source-inline">action</strong> on the <span class="No-Break"><strong class="source-inline">div</strong></span><span class="No-Break"> element.</span></p>
<p>So, what will happen to the <strong class="source-inline">div</strong> element with a <span class="No-Break">Svelte action?</span></p>
<p>When the <strong class="source-inline">&lt;div&gt;</strong> element is mounted to the DOM, Svelte will call the <strong class="source-inline">action</strong> function with the reference to the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">div&gt;</strong></span><span class="No-Break"> element:</span></p>
<pre class="source-code">
const action_obj = action(div);</pre> <p>When the element is removed from the DOM, Svelte will call the <strong class="source-inline">destroy</strong> method from the object returned from calling the <span class="No-Break"><strong class="source-inline">action</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
if (action_obj &amp;&amp; action_obj.destroy) action_obj.destroy();</pre> <p>We can customize the behavior of a Svelte action by using parameters. We can pass in an extra parameter to the <span class="No-Break"><strong class="source-inline">action</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
function action(node, parameter) {
  return {
   update(parameter) {},
   destroy() {},
  };
}</pre> <p>Also, you<a id="_idIndexMarker185"/> can add another method to the returning object, <strong class="source-inline">update</strong>, which will be called when the value of the <span class="No-Break">parameter changes:</span></p>
<pre class="source-code">
action_obj.update(new_value);</pre> <p>To pass in an additional parameter, you can specify it in a similar syntax as the <span class="No-Break"><strong class="source-inline">value</strong></span><span class="No-Break"> attribute:</span></p>
<pre class="source-code">
&lt;div use:action={value} /&gt;</pre> <p>Now that we know how to use and define an action in Svelte, let’s take a look at our first use case <span class="No-Break">of actions.</span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Reusing DOM event logic with custom events</h1>
<p>Before we start <a id="_idIndexMarker186"/>talking directly about actions, let’s look at an example of using the <strong class="source-inline">mousedown</strong> and <strong class="source-inline">mouseup</strong> events to <a id="_idIndexMarker187"/>create a long-press behavior. We<a id="_idIndexMarker188"/> shall see how this simple example will lead us on to <span class="No-Break">Svelte actions:</span></p>
<pre class="source-code">
&lt;script&gt;
  let timer;
  function handleMousedown() {
    timer = setTimeout(() =&gt; {
      console.log('long press!');
    }, 2000);
  }
  function handleMouseup() {
    clearTimeout(timer);
  }
&lt;/script&gt;
&lt;button
  on:mousedown={handleMousedown}
  on:mouseup={handleMouseup}
/&gt;</pre> <p>In the preceding<a id="_idIndexMarker189"/> example, we tried to implement a long-press behavior in a button. The idea is to press and hold the button<a id="_idIndexMarker190"/> for more than two seconds and then perform some action. As we detect it’s a long press, we print <strong class="source-inline">'long press!'</strong> into <span class="No-Break">the console.</span></p>
<p>To implement <a id="_idIndexMarker191"/>the long-press behavior, I attached two event listeners: <strong class="source-inline">mousedown</strong> and <strong class="source-inline">mouseup</strong>. The two event listeners work together. <strong class="source-inline">mousedown</strong> starts counting down using <strong class="source-inline">setTimeout</strong> for two seconds, and <strong class="source-inline">mouseup</strong> clears the countdown using <strong class="source-inline">clearTimeout</strong>. If the user did not hold onto the button for long enough, the timeout would not be triggered and it would not be considered a long press. Note that to coordinate the timers between the two event listeners, the <strong class="source-inline">timer</strong> variable is shared across the <span class="No-Break">event listeners.</span></p>
<p>As you can see, to implement a long-press behavior, you will need two event listeners and one <span class="No-Break">shared variable.</span></p>
<p>Now, what if you need to have this long-press behavior on <span class="No-Break">another button?</span></p>
<p>You can’t really share the same event listener and the variable, as you might want a different duration to be considered as a timeout or a different behavior when a long <span class="No-Break">press happens.</span></p>
<p>So, you would have to redeclare them again and remember to pair the right event with the right <span class="No-Break">event listener.</span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor085"/>Encapsulating logic into a component</h2>
<p>A way<a id="_idIndexMarker192"/> to recreate a different long-press button is to encapsulate it as a component, putting all the long-press button logic into a component and reusing the component as a means to reuse <span class="No-Break">the logic.</span></p>
<p>When you define a component, you define the logic as well as the elements in the component. This means that if we put both the long-press logic and the <strong class="source-inline">button</strong> element into the component, we have to use the long-press logic together with the <strong class="source-inline">button</strong> element and no <span class="No-Break">other elements.</span></p>
<p>If you want to customize the element, maybe by using a different element, having a different style, showing a different text content, or adding more event listeners, you would have to define the styles, text contents, or event listeners as props of the component and pass them into the <strong class="source-inline">button</strong> element in <span class="No-Break">the component:</span></p>
<pre class="source-code">
&lt;!-- LongPressButton.svelte --&gt;
&lt;button
  // besides the longpress behavior
  on:mousedown={handleMousedown}
  on:mouseup={handleMouseup}
  // you need to pass down props as attributes
  <strong class="bold">{...$$props}</strong>
  // and also forward events up
  <strong class="bold">on:click</strong>
  <strong class="bold">on:dblclick</strong>
&gt;
  &lt;slot /&gt;
&lt;/button&gt;</pre> <p>In the preceding code, we passed in extra attributes from the props into the <strong class="source-inline">button</strong> element along with forwarding two events, <strong class="source-inline">click</strong> and <strong class="source-inline">dblclick</strong>, from the button element out to <span class="No-Break">the component.</span></p>
<p>The point I <a id="_idIndexMarker193"/>am trying to make here is that if you wish to reuse event listener logic via components, you will find yourself having to take care of other attributes that go along with the element in <span class="No-Break">the component.</span></p>
<p>We can do much more with a component, but if we are trying to reuse just the long-press behavior, then reusing it by defining it in a component is a bit overkill, and it can grow unmanageable <span class="No-Break">rather quickly.</span></p>
<p>So, what other options do <span class="No-Break">we have?</span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>Encapsulating logic into an action</h2>
<p>A better<a id="_idIndexMarker194"/> option is to use an action to encapsulate the <span class="No-Break">long-press behavior.</span></p>
<p>Let’s just do that and then I’ll explain why using an action is a <span class="No-Break">better approach:</span></p>
<pre class="source-code">
function longPress(node) {
  let timer;
  function handleMousedown() {
    timer = setTimeout(() =&gt; {
      console.log('long press!');
    }, 2000);
  }
  function handleMouseup() {
    clearTimeout(timer);
  }
  node.addEventListener('mousedown', handleMousedown);
  node.addEventListener('mouseup', handleMouseup);
  return {
    destroy() {
     node.removeEventListener('mousedown', handleMousedown);
     node.removeEventListener('mouseup', handleMouseup);
    }
  }
}</pre> <p>With the<a id="_idIndexMarker195"/> action defined (as shown in the preceding code), we can use the action over <span class="No-Break">multiple elements:</span></p>
<pre class="source-code">
&lt;button use:longPress&gt;Button one&lt;/button&gt;
&lt;button use:longPress&gt;Button two&lt;/button&gt;</pre> <p>You can apply the action to a different type <span class="No-Break">of element:</span></p>
<pre class="source-code">
&lt;span use:longPress&gt;Hold on to me&lt;/span&gt;</pre> <p>You can also use it alongside other attributes or <span class="No-Break">event listeners:</span></p>
<pre class="source-code">
&lt;button use:longPress class="..." on:click={...} /&gt;</pre> <p>I hope you can see that the <strong class="source-inline">longPress</strong> action encapsulates only the long-press behavior. Unlike the <strong class="source-inline">LongPressButton</strong> component, the <strong class="source-inline">longPress</strong> action can easily be reused in <span class="No-Break">any element.</span></p>
<p>So, as a rule of thumb, when abstracting logic from an element, if you are abstracting it together with the elements, it is okay to use a component. But if you only need to abstract the logic behavior from an element, <span class="No-Break">use actions.</span></p>
<p>Actions are a great tool for abstracting out element-level logic. But there is still one missing piece of the puzzle: how should we add a different long-press handler for a different element? We’ll see <span class="No-Break">how next.</span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>Passing parameters to an action</h2>
<p>So, how <a id="_idIndexMarker196"/>do we customize the behavior of our <span class="No-Break"><strong class="source-inline">longPress</strong></span><span class="No-Break"> action?</span></p>
<p>You could have probably guessed the answer since you’ve seen it in the previous section. We can customize the behavior of an action by passing parameters into <span class="No-Break">the action.</span></p>
<p>For example, if we want to have a different function to handle a long-press action on different <strong class="source-inline">button</strong> elements, we can pass a different function into the action through <span class="No-Break">action parameters:</span></p>
<pre class="source-code">
&lt;button use:longPress={doSomething1} /&gt;
&lt;button use:longPress={doSomething2} /&gt;</pre> <p>We will then receive this function within the second argument of the <span class="No-Break">action function:</span></p>
<pre class="source-code">
function longPress(node, fn) {
  // ...
}</pre> <p>We call the function passed in when it is considered a <span class="No-Break">long press:</span></p>
<pre class="source-code">
fn();</pre> <p>We can similarly pass in other parameters, such as the duration to be considered as a <span class="No-Break">long press.</span></p>
<p>In Svelte actions, you can only pass in one parameter. To pass in multiple parameters, you will have to turn them into an object and pass them in as <span class="No-Break">one parameter.</span></p>
<p>Over in our <strong class="source-inline">longPress</strong> action, we want to pass the function to be called when the <strong class="source-inline">longPress</strong> action is detected, as well as the duration to be considered a long press, into the <strong class="source-inline">longPress</strong> action. To pass both the function and the duration in, we create an object that has them as object values and pass the object as the <span class="No-Break">action parameter:</span></p>
<pre class="source-code">
&lt;button
  use:longPress=<strong class="bold">{{</strong>
<strong class="bold">    onLongPress: doSomething1,</strong>
<strong class="bold">    duration: 5000</strong>
<strong class="bold">  }}</strong> /&gt;</pre> <p>Some of the<a id="_idIndexMarker197"/> parameters in the object could be optional, so we might need to provide a default value when reading them within <span class="No-Break">the action:</span></p>
<pre class="source-code">
function longPress(node, { onLongPress, duration = 1000 }) {
  // if not specified, the default duration is 1s
}</pre> <p>At this stage, you might wonder, can the <strong class="source-inline">onLongPress</strong> be <span class="No-Break">optional too?</span></p>
<p>It does not make much sense in our case since the main goal of our action is to detect a long press and call the <span class="No-Break"><strong class="source-inline">onLongPress</strong></span><span class="No-Break"> function.</span></p>
<p>However, this is a <span class="No-Break">good question.</span></p>
<p>In some other actions, you may have function handlers that <span class="No-Break">are optional.</span></p>
<p>For example, what if we have a <strong class="source-inline">gesture</strong> action that can detect different gestures performed on the element? In that case, each <strong class="source-inline">gesture</strong> callback function can be optional since you may only be interested in one of <span class="No-Break">the gestures:</span></p>
<pre class="source-code">
function gesture(node, { onSwipe, onDrag, onPinch }) { }</pre> <p>The <strong class="source-inline">onSwipe</strong>, <strong class="source-inline">onDrag</strong>, and <strong class="source-inline">onPinch</strong> function handlers in this <strong class="source-inline">gesture</strong> action are optional and could <span class="No-Break">be undefined.</span></p>
<p>Instead of creating an empty function as a fallback, we should instead check whether the function is defined before <span class="No-Break">calling it:</span></p>
<pre class="source-code">
if (typeof onSwipe === 'function') onSwipe();</pre> <p>This way, we don’t have to create a <span class="No-Break">function unnecessarily.</span></p>
<p>However, this gets messier when you have multiple callback functions and you need to check whether each of them has been defined before <span class="No-Break">calling them.</span></p>
<p>Is there a better way to <span class="No-Break">handle this?</span></p>
<p>Yes, <span class="No-Break">there is.</span></p>
<p>In fact, a more idiomatic Svelte way of having an action to notify or call a function when something happens is to dispatch a <span class="No-Break">custom event.</span></p>
<p>For example, to know whether the user has long-pressed the <strong class="source-inline">&lt;button&gt;</strong> element, it would be natural to listen to the <strong class="source-inline">'longpress'</strong> custom event on the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">button&gt;</strong></span><span class="No-Break"> element:</span></p>
<pre class="source-code">
&lt;button on:longpress={doSomething1} /&gt;</pre> <p>However, there’s no native event <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">'longpress'</strong></span><span class="No-Break">.</span></p>
<p>But no <a id="_idIndexMarker198"/>worries, we can create a custom <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">longpress'</strong></span><span class="No-Break"> event.</span></p>
<p>Luckily, we have the <strong class="source-inline">longPress</strong> action to determine when the user long-presses a button. What we need to create a custom <strong class="source-inline">'longpress'</strong> event is to trigger the <strong class="source-inline">'longpress'</strong> event after determining the user has long-pressed a button in our <strong class="source-inline">longPress</strong> action. And so, in the line of code where we have determined that the user is long-pressing the button, we can dispatch a custom event from <span class="No-Break">the button:</span></p>
<pre class="source-code">
node.dispatchEvent(new CustomEvent('longpress'));</pre> <p>Let’s listen to the <strong class="source-inline">longpress</strong> custom event and create the custom <strong class="source-inline">'longpress'</strong> event in our action. Here is the <span class="No-Break">final code:</span></p>
<pre class="source-code">
&lt;script&gt;
  function longPress(node, { duration = 1000 } = {}) {
    let timer;
    function handleMousedown() {
      timer = setTimeout(() =&gt; {
        <strong class="bold">node.dispatchEvent(new CustomEvent('longpress'));</strong>
      }, duration);
    }
    function handleMouseup() {
      clearTimeout(timer);
    }
    node.addEventListener('mousedown', handleMousedown);
    node.addEventListener('mouseup', handleMouseup);
    return {
      destroy() {
        node.removeEventListener('mousedown', handleMousedown);
        node.removeEventListener('mouseup', handleMouseup);
     }
    }
  }
&lt;/script&gt;
&lt;button <strong class="bold">use:longPress</strong> on:longpress={() =&gt; {/* do something */}} /&gt;</pre> <p>Putting it in<a id="_idIndexMarker199"/> words, we add a <strong class="source-inline">longPress</strong> action to the <strong class="source-inline">button</strong> element, which adds logic to determine whether the button is being long-pressed. When the button is long-pressed, the <strong class="source-inline">longPress</strong> action dispatches a custom event called <strong class="source-inline">'longpress'</strong> on the element. To react to and trigger specific behaviors when the custom <strong class="source-inline">'longpress'</strong> event is dispatched on the element, we can listen to the event by using <strong class="source-inline">on:longpress</strong> with an <span class="No-Break">event handler.</span></p>
<p>It may feel like a roundabout way to call a function from an action by dispatching an event, but doing it this way has a <span class="No-Break">few pros:</span></p>
<ul>
<li>Whether we listen to the <strong class="source-inline">'longpress'</strong> event on the button or not, the action could still dispatch the <strong class="source-inline">'longpress'</strong> custom event. So, with this approach, we don’t need to check whether the handler is defined <span class="No-Break">or not.</span></li>
<li>Listening to the <strong class="source-inline">'longpress'</strong> event using <strong class="source-inline">on:</strong> instead of passing the function directly into the action would mean that you could use other Svelte features that come with Svelte’s <strong class="source-inline">on:</strong> directive. For example, to only listen to the <strong class="source-inline">'longpress'</strong> event once, you can use the <strong class="source-inline">|once</strong> event modifier, for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">on:longpress|once</strong></span><span class="No-Break">.</span></li>
</ul>
<p>Another way of <a id="_idIndexMarker200"/>describing what we have done with the <strong class="source-inline">longPress</strong> action is that the <strong class="source-inline">longPress</strong> action enhances the button element and provides a new event, <strong class="source-inline">'longpress'</strong>, that can be listened to on <span class="No-Break">the element.</span></p>
<p>Now that we’ve learned how we can define Svelte actions, and how we can use actions to create new events that we can listen to on an element, let’s look at a few more examples that use <span class="No-Break">this technique.</span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor088"/>Example – validating form inputs with custom events</h1>
<p>The <a id="_idIndexMarker201"/>example that we are going to<a id="_idIndexMarker202"/> explore is using actions to validate <span class="No-Break">form inputs.</span></p>
<p>When you add an input <a id="_idIndexMarker203"/>element to your form, you can add attributes such as <strong class="source-inline">required</strong>, <strong class="source-inline">minlength</strong>, and <strong class="source-inline">min</strong> to indicate that the input value has to pass the constraint validation or else would be <span class="No-Break">considered invalid.</span></p>
<p>However, by default, such a validation check is only done during form submission. There’s no real-time feedback on whether your input is valid as <span class="No-Break">you type.</span></p>
<p>To make the input element validate as you type, we need to add an <strong class="source-inline">'input'</strong> event listener (which will be called on every keystroke as we type in the input element) and call <strong class="source-inline">input.checkValidity()</strong> to validate the input. Now, let’s do <span class="No-Break">just that:</span></p>
<pre class="source-code">
&lt;input on:input={(event) =&gt; event.target.checkValidity()} /&gt;</pre> <p>As you call the <strong class="source-inline">checkValidity()</strong> method, if the input is indeed invalid, then it will trigger the <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">invalid'</strong></span><span class="No-Break"> event:</span></p>
<pre class="source-code">
&lt;input
  on:input={(event) =&gt; event.target.checkValidity()}
  on:invalid={(event) =&gt; console.log(event.target.validity)}
/&gt;</pre> <p>Unfortunately, there’s no <strong class="source-inline">'valid'</strong> event. So, there’s no way to tell whether the input has passed <span class="No-Break">the validation.</span></p>
<p>It<a id="_idIndexMarker204"/> would be<a id="_idIndexMarker205"/> great if there were an event called <strong class="source-inline">'validate'</strong> in which within the event details, we can tell whether the input is valid or not. If it isn’t, we could get an error message about why the input <span class="No-Break">is invalid.</span></p>
<p>Here’s an example of how we could use the <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">validate'</strong></span><span class="No-Break"> event:</span></p>
<pre class="source-code">
&lt;input on:validate={(event) =&gt; {
  if (event.detail.isValid) {
    errorMessage = '';
  } else {
    errorMessage = event.detail.errorMessage;
  }
}} /&gt;</pre> <p>There isn’t an <a id="_idIndexMarker206"/>event called <strong class="source-inline">'validate'</strong>, but we can create this custom event ourselves. So, why not create an action to create this custom event <span class="No-Break">for us?</span></p>
<p>This logic is well suited to be written as an action for the <span class="No-Break">following reasons:</span></p>
<ul>
<li>It can be reused in other <span class="No-Break">input elements.</span></li>
<li>This logic itself is not involved in creating or updating elements. If it were, it would probably be better suited to be <span class="No-Break">a component.</span></li>
</ul>
<p>Let us write <span class="No-Break">this action:</span></p>
<ol>
<li>Firstly, this action involves listening to the <strong class="source-inline">'input'</strong> event listener. So, in the code, as shown, we are going to add an event listener at the start of the action and remove the <strong class="source-inline">'input'</strong> event listener in the <strong class="source-inline">destroy</strong> method. This means that whenever an element that uses this action is added to the DOM, it will listen to the <strong class="source-inline">'input'</strong> event, and when it is removed from the DOM, the event listener will be <span class="No-Break">automatically removed:</span><pre class="source-code">
function validateOnType(input) {
  input.addEventListener('input', onInput);
  return {
    destroy() {
      input.removeEventListener('input', onInput);
    }
  };
}</pre></li> <li>Next, within<a id="_idIndexMarker207"/> the input handler, we<a id="_idIndexMarker208"/> are going to call <strong class="source-inline">checkValidity()</strong> to check whether the input is valid. If the input is invalid, then we will read <strong class="source-inline">input.validity</strong> and determine the <span class="No-Break">error message:</span><pre class="source-code">
function validateOnType(input) {
  function onInput() {
    const isValid = input.checkValidity();
    const errorMessage = isValid ? '' : getErrorMessage(input.validity);
  }
  // ...
}</pre></li> <li>Finally, we <a id="_idIndexMarker209"/>will dispatch the custom <strong class="source-inline">'validate'</strong> event with <strong class="source-inline">isValid</strong> and <strong class="source-inline">errorMessage</strong> as <span class="No-Break">event details:</span><pre class="source-code">
function validateOnType(input) {
  function onInput() {
// ...
input.dispatchEvent(
  new CustomEvent(
    'validate',
    { detail: { isValid, errorMessage } }
  )
);
  }
  // ...
}</pre></li> <li>Now, with this action completed, we can enhance the <strong class="source-inline">&lt;input&gt;</strong> element by adding<a id="_idIndexMarker210"/> a new <strong class="source-inline">'validate'</strong> event, which will be called <strong class="source-inline">as-you-type</strong>, letting you know<a id="_idIndexMarker211"/> whether the input is currently valid or invalid. It will also show the corresponding <span class="No-Break">error message:</span><pre class="source-code">
&lt;input
  use:validateOnType
  on:validate={(event) =&gt; console.log(event.detail)}
/&gt;</pre><p class="list-inset">To make<a id="_idIndexMarker212"/> the validation results more useful to the user, you can use the result from the <strong class="source-inline">'validate'</strong> event to modify element styles, such as setting the input border color to red when the validation result is invalid, as shown in the <span class="No-Break">following snippet:</span></p><pre class="source-code">&lt;script&gt;
  let isValid = false;
&lt;/script&gt;
&lt;input
  class:invalid={!isValid}
  use:validateOnType
  on:validate={(event) =&gt; isValid = event.detail.isValid}
/&gt;
&lt;style&gt;
  .invalid { border: red 1px solid; }
&lt;/style&gt;</pre></li> </ol>
<p>Are you<a id="_idIndexMarker213"/> getting<a id="_idIndexMarker214"/> the hang of writing actions that <a id="_idIndexMarker215"/>create <span class="No-Break">custom events?</span></p>
<p>Let’s try the next one as an exercise. This time, we’ll tackle one of the most common user interactions, drag <span class="No-Break">and drop.</span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor089"/>Exercise – creating a drag-and-drop event</h1>
<p>A <a id="_idIndexMarker216"/>drag-and-drop behavior means clicking on an element, moving the mouse while holding down the click to drag the element across the screen to the <a id="_idIndexMarker217"/>desired location, and then releasing the mouse click to drop the element in the <span class="No-Break">new location.</span></p>
<p>A drag-and-drop behavior thus involves coordination between multiple events, namely, <strong class="source-inline">'mousedown'</strong>, <strong class="source-inline">'mousemove'</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">'mouseup'</strong></span><span class="No-Break">.</span></p>
<p>As we perform the drag-and-drop motion, what we are interested in knowing is when the dragging starts, how far the element is dragged, and when the <span class="No-Break">dragging ends.</span></p>
<p>These three events can be translated into three custom events: <strong class="source-inline">'dragStart'</strong>, <strong class="source-inline">'dragMove'</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">'dragEnd'</strong></span><span class="No-Break">.</span></p>
<p>Let us try to <a id="_idIndexMarker218"/>implement the drag-and-drop behavior <a id="_idIndexMarker219"/>as an action that will create these three <span class="No-Break">custom events:</span></p>
<pre class="source-code">
&lt;div
  use:dragAndDrop
  on:dragStart={...}
  on:dragMove={...}
  on:dragEnd={...}
/&gt;</pre> <p>You can check the answer to this exercise <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05/03-drag-and-drop"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05/03-drag-and-drop</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor090"/>Summary</h1>
<p>In this chapter, we saw how to define an action. We talked about one of the common patterns of actions, which is to create custom events. This allows us to encapsulate DOM event logic into custom events and reuse them <span class="No-Break">across elements.</span></p>
<p>In the next chapter, we will look at the next common pattern of actions, which is integrating <span class="No-Break">third-party libraries.</span></p>
</div>
</div></body></html>