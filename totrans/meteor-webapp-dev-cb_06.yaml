- en: Chapter 6. Mastering Reactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and consuming a reactive value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ajax query results in ReactiveVar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a custom library reactive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating Blaze templates without Mongo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inline data to modify UI elements reactively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the jQuery UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactive programming** is an emerging development methodology, where changes
    to data automatically trigger changes to the rest of the system. This allows you,
    the developer, to write code declaratively and let the reactive elements manage
    any changes. Meteor is, perhaps, the best and most fully developed implementation
    of reactive programming available today. By understanding the core concepts of
    reactive programming, you can use the `Tracker` (formerly `Deps`) library to create
    simple, declarative code while avoiding the usual pitfalls associated with reactive
    and asynchronous JavaScript programming. The recipes in this chapter will give
    you simple, clear examples of how the major components of Meteor''s reactive model
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and consuming a reactive value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Tracker`, simply put, is Meteor''s variable tracking system. It is used to
    manage reactive values, data structures, and computations (functions that consume
    reactive values). This recipe will show you how to create reactive values, and
    perform computations on those values, using `Tracker.autorun()`. In other words,
    it will teach you how reactive programming works inside Meteor. This recipe will
    come in handy as a foundation for more complex functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we will be using a default Meteor project, with
    the `reactive-var` package added to it. Open a terminal window, navigate to where
    you would like to create your root project, and execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You are now ready to start using reactive variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to modify the text of a button, based on a reactive variable; so
    we will need to create the button and hook up the reactive context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your project in your favorite text editor and edit the `reactiverecipes.html`
    file, adding an ID to the `<button>` element, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open `reactiverecipes.js` and add the following lines of code just below
    the `if (Meteor.isClient)` condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following line inside the `Template.hello.events` declaration,
    just below the `Session.set()` function in the `''click button''` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your changes and navigate to `http://localhost:3000` in a browser. Once
    there, click on the button labeled **Click Me** and watch the text change to **Again!**:![How
    to do it...](img/image00374.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can manually change the value of the button text by opening a console window
    in your browser and using the `btnText.set()` command, as shown in the following
    example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The button text will change to whatever value you set it to, instantly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding example seems oversimplified, but we have two things to say about
    that.
  prefs: []
  type: TYPE_NORMAL
- en: First, it's simple because Meteor was built to make your code very simple and
    easy to follow. This makes your development and debug efforts significantly less
    time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the process of declaring a reactive variable is made up of one line
    of code. When we added the `btnText = new ReactiveVar('Click Me')` statement,
    we were simply declaring a variable (and initializing its value to `'Click Me'`),
    but we know by the declaration that it is a reactive variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we encapsulated an extremely straightforward jQuery statement inside a
    `Tracker.autorun()` block. This block is called a **reactive computation**. Reactive
    computations run once initially and then rerun (are recomputed) whenever a change
    is made to any reactive variables contained inside. So, in this example, we told
    `Tracker` to monitor the value of `btnText`(a reactive variable) and automatically
    run (hence the term `autorun`) the code block again when it would change.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don't have to worry about any time conditions, such as "is this
    the first run?" or "okay, when there's a change…." We just simply declare the
    jQuery statement and let `Tracker` figure out the timing for us.
  prefs: []
  type: TYPE_NORMAL
- en: This is what the term **transparent reactive programming** means. There is one
    set of code for the initialization and another set of code for changes. Besides
    the variable declarations, your entire code base can be written as normal, plain
    old JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Second, what it's doing under the hood is anything but simple! To create this
    frontend simplicity for you, the programmer, Meteor implements reactive providers
    and reactive computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll sacrifice a bit of fidelity to make the concept simpler to understand.
    When `Tracker.autorun` is called, it does four things:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets `Tracker.currentComputation` to that computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls the function that was passed to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets `Tracker.currentComputation` to `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computation is essentially an event handler function and contains a reference
    to the function that was passed to `Tracker.autorun`. The event that the computation
    is waiting for is a call to the `computation.invalidate` method. When the `invalidate`
    method is called, the computation reruns the function it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we come to the function. The function passed to `Tracker.autorun` is considered
    a reactive function if it contains **reactive providers**. A reactive provider
    is an object that has functions to get and set some value, and keeps track of
    dependencies. When the `get` function is called, it does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks to see whether `Tracker.currentComputation` has a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it does, the computation is added to an internal list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the value of the variable that the getter requested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both steps 1 and 2 are performed by making a call to `depend()`, which is a
    method found on a dependency object. The `reactive-var` library automates this
    part, so you don't have to call the `depend()` method directly. All you have to
    do is use the reactive variable!
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, when the `set` function is called, it does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It changes the value of the internal variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every computation in the internal list, the `invalidate()` method is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `invalidate()` methods are called in a loop by making a call to `changed()`,
    which is a `helper` method found on a dependency object. Again, `reactive-var`
    takes care of this for you. You're welcome!
  prefs: []
  type: TYPE_NORMAL
- en: When each computation is invalidated, it reruns the function that it contains.
    And the entire loop starts over with the newly rerun function calling the getters,
    which return their values (like the `text` value of our `btnReact` button) and
    add the computations to the provider's internal list, waiting once again for the
    setter to be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though they are extremely oversimplified (any core MDG members reading
    this are probably spitting coffee right now…), here is what the `ReactiveVar`
    and `autorun` objects do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are two things that we left out, for clarity, but are important in order
    to have a complete understanding. First, the `depend()` helper method also sets
    up an `onInvalidate()` listener, which removes the computation from the reactive
    provider's internal list. Second, computations are checked to see whether they
    already exist in an internal list before they are added.
  prefs: []
  type: TYPE_NORMAL
- en: Why are the computations removed when the computation is invalidated, you may
    ask? The answer, in short, is that it makes the entire computation `add-execute-remove`
    loop very elegant. It keeps all the computations up to date and the dependent
    functions only run once each, no matter how many times a getter is called inside
    the same function. If they weren't removed, the functions would be run multiple
    times, which is *no bueno*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s review what we did in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: The `autorun` method creates a computation and passes your function to this
    computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computation has an `onInvalidate` method that, among other things, runs
    your function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After `autorun` has created a computation, it runs your function once, using
    the `onInvalidate` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your function has reactive variables in it, which have to-do lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As your function runs, getters are called, which add the computations to the
    to-do lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setters are also called, which execute the to-do lists and clear them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because your functions in the to-do lists have reactive variables, the process
    is repeated (the functions are rerun)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lather, rinse, and repeat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, this explanation is drastically simplified, and therefore, pretty inaccurate;
    however, conceptually, it will hopefully give you a good understanding of what's
    happening under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Meteor also provides the `ReactiveDict` object, which runs exactly like `ReactiveVar`,
    but can store collections of reactive variables in key-value pairs. The syntax
    is exactly the same as for `ReactiveVar`, but you will need to add a key to the
    `set` and `get` methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `ReactiveDict`, simply add the `reactive-dict` package using the following
    terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, you don't have to use `ReactiveVar`, or `ReactiveDict`, and can instead
    *roll your own* reactive providers. Please see the *Making a custom library reactive*
    recipe found in this chapter as an example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating dynamic lists* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Making a custom library reactive* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ajax query results in ReactiveVar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we use Ajax, requesting (and even receiving) data is pretty easy. The
    complications come in when we have to update the UI with new or updated data.
    With Meteor's reactive programming capabilities, this is no longer an issue. In
    this recipe, you will see how to update your UI with Ajax results, using Meteor's
    `ReactiveVar` library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get up and run quickly, we will use a default Meteor project with a few
    packages added. Open a terminal window, navigate to where you would like to create
    your root project, and execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to build a reactive Ajax query!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be pulling the weather data from `openweathermap.org`, using their free
    (but for testing only) API. We will take the results from our `openweathermap.org`
    queries and put them into a `ReactiveVar` library so that they can then be consumed
    reactively by our Blaze templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by modifying the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ajaxreactive.html` and add a call to our soon-to-be-created `weather`
    template, just under the call to the existing `hello` template, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also want to repurpose the counter in our `hello` template to tell
    us what the starting longitude will be. Change the description in the `<p>` element
    inside the `hello` template, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add our `weather` template, which is just a simple table with a bit of
    prettiness added, thanks to bootstrap! At the bottom of `ajaxreactive.html`, add
    the following template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your changes and navigate to `http://localhost:3000`. While nothing (except
    the description of the counter) will change, we will very soon want to view our
    weather data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s open `ajaxreactive.js` and declare our `ReactiveVar` libraries. Just
    below `Session.setDefault()`, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now modify the `''click button''` function to increment the counter
    and make our Ajax call. Locate the function inside the `Template.hello.events`
    section and modify the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to update the counter increment to `4`; otherwise, your `weather`
    data won't change much as you click.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to add `Template.weather.helpers` so that our UI will populate
    properly. Just after the `Template.hello.events` section, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to add our Ajax call and the asynchronous callback function
    once the result comes in. Just after the `Template.weather.helpers` section, add
    the following two functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all your changes and click on the button on the project page in your browser.
    You should see something similar to the following screenshot:![How to do it…](img/image00375.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you click, the weather results for a given area, moving towards north, will
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this instance, we didn't use a Mongo collection, which is automatically reactive.
    Instead, we made calls to `openweather.org api` and updated a `ReactiveVar` library
    (in this case, the `weatherList` variable) using the `set` method. Because the
    template helpers rely on a call to the `get` method of that same `ReactiveVar`,
    they are automatically rerun when the `ReactiveVar` is updated. Let's break it
    down.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first created the `weather` template in our HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The template iterates over the `reports` helper object using an `{{#each...}}`
    block, populating an HTML table with the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside our client-side JavaScript, we declared our reactive variable,
    `weatherlist`, using a new `ReactiveVar` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then used `weatherlist.get()` in our `reports` helper object, which is in
    `Template.weather.helpers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By using it here, we set up a dependency so that anytime `weatherlist.set()`
    is called, the data for the template is refreshed and the template is updated/rerun.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we hooked up our button to an Ajax call using `HTTP.get()`, and we
    passed the `harvestWeather` function as a callback (`HTTP.get(url,arg,callback)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the callback is triggered, it massages the data from the Ajax call and
    repopulates our reactive variable using `weatherlist.set()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the preceding section, when this `set` function is called, it
    invalidates the template functions and reactively updates our UI.
  prefs: []
  type: TYPE_NORMAL
- en: You can see very clearly in the callback function (`harvestWeather`), and in
    the weather template helper function (`reports`), that the calls are regular,
    plain JavaScript. We're literally just calling a `get` or `set` function. Because
    the object we're calling those functions on is a `ReactiveVar`, all the reactive
    dependencies and UI updates are handled for us.
  prefs: []
  type: TYPE_NORMAL
- en: You can begin to quickly see how powerful Meteor's reactive programming model
    is. Instead of messing around with events and handlers or worrying about callback
    hell, we used a simple, clean `set` command and let Meteor handle all the details
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating dynamic lists* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and consuming a reactive value* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a custom library reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we so often deal with variables and data, it can go unnoticed that Meteor's
    reactivity doesn't only work with reactive values. Any function from any JavaScript
    library can be turned into a reactive provider. This recipe will show you how
    to create your own reactive providers using the `Tracker.depend()` and `Tracker.changed()`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep the example simple, we will use a default Meteor project, with a `bootstrap`
    package, and a random color generator. Open a terminal window, navigate to where
    you would like to create your root project, and execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's pretend you have a (pretty awesome) library called `colorsaurus`. Your
    `colorsaurus` object likes to roar. A lot. Mostly because "rawr" means "I love
    you" in dinosaur, but also because the colorsaurus wants to share as many random
    colors as possible with all his friends. Whenever you ask this motley beast for
    a color, he instantly gives you a random color. This is obviously the most useful
    library ever written, so let's get to work building it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `customreactive.js` and add the following `colorsaurus` object just below
    the `Template` declarations, inside the `Meteor.isClient` conditional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While we''re in `customreactive.js`, let''s add the `numcolor` helper function.
    Locate the `Template.hello.helpers` method and add the following to the top of
    the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your changes, navigate to `http://localhost:3000`, and in the console
    window, type the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should get a random color and a nice, short *I love you* from our friend,
    the `colorsaurus` function:![How to do it…](img/image00376.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s not reactive yet, but we need to prepare our UI first, for all the awesomeness
    that a reactive `colorsaurus` function can unleash. Open `customreactive.html`
    and make the following modifications to the `hello` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to change our `click` event to make `colorsaurus` roar. In `customreactive.js`,
    modify the `Template.hello.events` section as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All that''s left to do is make `colorsaurus` reactive and set up an `autorun`
    function. Open `customreactive.js` again and add the following reactive statements,
    including adding the `Tracker.Depenency` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a `Tracker.autorun` function, immediately after the `colorsaurus`
    code block, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your changes, go to your browser, and click on the button as many times
    as your little 'colorsaurus-lovin' heart wishes. You'll get some really great
    color combinations, as shown in the following screenshot:![How to do it…](img/image00377.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice how the button, text, and the page background change, and they all change
    to random, separate colors. That's because we used a reactive library function
    that returns a random color each time it is called instead of returning a set
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: By having our `color()` function return the result of `randomColor()`, we are
    ensuring that every time `colorsaurus.color()` is called, we get a different result.
  prefs: []
  type: TYPE_NORMAL
- en: We added `colorDep.depend()` to the returning function, which logs the computations
    that are created by either `Tracker.autorun` or by a reactive template (see the
    *Creating and consuming a reactive value* recipe found in this chapter for a full
    explanation).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we called `colorDep.changed()`, which runs the logged computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every part of the code is separate from—and therefore not dependent on—the
    other code parts or libraries. Through the `Tracker.Dependency` object, Meteor
    keeps track of everything for us so we can add or remove reactive dependencies
    at will. Try, for example, running the following line in your browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time you click the button on the page, you get yet another random
    color from the `colorsaurus`, printed to your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/image00378.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is reactive programming at its very best. Rawr!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using reactivity with HTML attributes* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and consuming a reactive value* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating Blaze templates without Mongo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not everything in our UI has to be dependent on Mongo collections. We can, in
    fact, use pretty much any reactive object inside our templates, and changes will
    appear instantly. This recipe will quickly show you how to use custom collections
    to populate and update UI templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a base Meteor project and add the `bootstrap` and `reactive-var`
    packages. In a terminal window, navigate to where you would like your project
    to reside and enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, open a browser and navigate to `http://localhost:3000` so that you
    can see updates in real time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a simple array of button press snapshots, with a new element
    being added to the array every time the button on the page is clicked. Subsequently,
    these buttons will be added to the UI using a `{{#each}}` template block.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open `mongoless.html` and add the following block to the `hello` template,
    just after the `<p>` element and just before the closing `</template>` tag, as
    shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to add a reactive variable and append some helpers to the `Template.hello.helpers`
    object. Open `mongoless.js` and add the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All that''s left to do is to update the `presses` variable each time the button
    is pressed. Inside `Template.hello.events`, in the `''click button''` event handler,
    add the following lines of code immediately after the `Session.set()` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all of your changes, go to your browser, and start clicking on the button
    labeled **Click Me**. You should see a new button created each time you click
    on the button, similar to the following:![How to do it…](img/image00379.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we added the `buttonPresses` helper function to the `Template.hello.helpers`
    object, we simply replaced what we would usually use a Mongo collection for with
    a simple array stored inside a `ReactiveVar` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Collections are reactive providers, which means they track and rerun computations
    as appropriate. The `presses` object is also a reactive provider, and therefore,
    does the exact same thing. It reruns any stored computations / reactive functions
    whenever the value is updated. In this case, it reruns computations when the array
    is modified, and `presses.set()` is called as a result.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating dynamic lists* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating and consuming a reactive value* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inline data to modify UI elements reactively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, when elements in an HTML page are rendered, then that rendering isn't
    directly linked to any of the data used to create them, for example, if we have
    an array of objects, we may generate some HTML by iterating over the array and
    adding `<div>` elements for each object in the array. Unless we do something to
    manually link them to the array of objects, these newly created elements aren't
    associated with the data that created them in any way. This leads to all kinds
    of development shenanigans, as developers try to shoehorn in associative data,
    which is used in events and other downstream functions. Long story short, using
    only existing web technologies, it's difficult to keep all of the data exactly
    in sync with your HTML DOM elements. Meteor has been designed to help solve this
    problem gracefully, keeping track of the context of each DOM element and therefore
    allowing instant access to the data used to create the element in the first place.
    This recipe will walk you through how to retrieve and use the data associated
    with individual DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the code base from the *Updating Blaze templates without Mongo*
    recipe, found in this chapter. Please complete that recipe and then add the `randomcolor`
    package by running the following terminal command in the root folder of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Have your browser open to `http://localhost:3000` as well so we can see the
    changes in real time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to add some functionality to the existing button creation. First,
    we'll add a random color to each new button; second, we'll remove this color when
    the buttons are clicked; and third, we'll restore the color based on the associative
    inline data.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started. We need to update the `hello` template, setting the initial
    background colors for new buttons. We also need a way to remove those colors at
    random. We'll do this by adding a new control button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `.html` file (probably `mongoless.html`) and modify the `hello` template
    to look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to add the `btnColor` helper to `Template.hello.helpers` and modify
    the data object being stored to make room for the new color. We also need to refine
    the `click` events on the buttons to differentiate between adding a new button
    and removing a button''s color. Open your `.js` file (probably called `mongoless.js`)
    and make the following changes to the variable declarations and the helpers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to modify the existing `click` event, add a new event to remove
    color, and add one final handler to set up all the new buttons to regain their
    color when clicked. Make the following changes to the `Template.hello.events`
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all your changes and click on the **Click Me** Button on your screen 5-10
    times. You'll notice that all the new buttons being added have a random color
    assigned to them, as shown in the following screenshot:![How to do it...](img/image00380.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on the **Or Me!** button multiple times. At random, the buttons will
    lose their random color and change to the default `btn-info` blue color provided
    by `bootstrap`, as shown in the following screenshot:![How to do it...](img/image00381.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any of the buttons that have lost their color can regain the color by clicking
    directly on the button.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The crux of this recipe is found inside the `''click .pressed''` event handler.
    There, we assign the `backgroundColor` attribute of the clicked button to `this.color`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this case, there is a reference to the associated data object for that DOM
    element. Meteor keeps track of how each element is created. So when an event is
    fired inside the template, Meteor provides the data object as the *context* (the
    `this`) in the event handler. In this way, Meteor can provide instant access to
    the inline data for each rendered element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that even after we manually changed the `backgroundColor` using the
    `''click #chgColor''` event, Meteor still has a reference to the data object used
    to render the element. This becomes important because we now no longer need to
    store data as an attribute of the DOM element—no more `data-color` or `data-whatever`
    attributes that clutter up the UI and potentially expose data. The data objects,
    though hidden from the UI, are available instantly and inline. So no fancy calculations
    or DOM manipulation needs to be done in order to access the necessary contextual
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding example uses the default Meteor `Template` event handlers, so
    of course, the data is available. But, even if you bypass Meteor's `Template`
    event handlers and use, say, jQuery events instead, the associated data will be
    available by calling the `Blaze.getData()` function of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the event handler is a little bit tricky in this case. We have to
    first move the population of each button to a new template because the jQuery
    `click` event handler must be run inside of a `rendered()` function callback.
    To accomplish this, make the following changes to your `.html` file (probably
    `mongoless.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to remove the `''click .pressed''` event handler from `Template.hello.events`.
    Once you''ve removed the event handler, add the `jQuery.click()` event handler
    inside a `Template.btnRank.rendered` code block, to be run immediately upon the
    rendering of a new button, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, because we moved the `div` rendering to the new `helloBtn` template,
    we need to move the `btnRank` and `btnColor` helpers from `Template.hello.helpers`
    to a newly created `Template.helloBtn.helpers` block, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That's a lot of work for the same result, but it helps to illustrate the flexibility
    of the Blaze/Meteor associative data capabilities. We only had to slightly modify
    the event helper to point to `Blaze.getData(this).color` rather than `this.color`.
    Although the same keyword exists in each event handler, the `this` inside the
    jQuery event handler refers to the DOM element, rather than the associated data
    object inside the original Meteor event handler. `Blaze.getData(element)` takes
    a DOM element as an argument and retrieves the associated inline data for that
    element.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, getting to the associated data is very straightforward and allows
    you to do anything to your UI programmatically, without having to worry about
    destroying/altering the data associated with each rendered element.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Inserting templates with Spacebars* and *Creating dynamic lists* recipes
    in [Chapter 3](part0036.xhtml#aid-12AK81 "Chapter 3. Building Great User Interfaces"),
    *Building Great User Interfaces*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating a jQuery UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jQuery library is crazily popular, and for good reason. When used properly,
    it can speed up the development process and give us reliable ways of doing things
    that would otherwise take a lot of coding effort.
  prefs: []
  type: TYPE_NORMAL
- en: A complement to jQuery is jQuery UI, which is a set of widgets, themes, and
    animation effects. With jQuery UI, you can quickly create drag and drop components,
    sortable lists, and lots of other useful UI niceties.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will walk you through creating a jQuery UI-sortable widget inside
    a Meteor template.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will definitely want client and server folders to keep the
    code clean and readable. To accomplish this, we will rely on our default template
    scaffolding. Please create a new project called `swatches` using the *Setting
    up your project file structure* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Optimizing Your Workflow"), *Optimizing Your Workflow*, as your starting
    file structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve completed the scaffolding, we will need to add the `randomcolor`
    package to our project. In a terminal window, navigate to the root folder of your
    project and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also want a nice theme, so let''s use the adapted version of Google''s
    Material Design theme, for funzies. Enter the following command in the same terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to get a customized version of jQuery UI directly from `jqueryui.com`.
    Navigate to [http://jqueryui.com/](http://jqueryui.com/) in a browser and click
    on **Custom Download**, placed toward the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00382.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the download builder, make the following selections:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the latest stable version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncheck the **Toggle** **All** checkbox under **Components**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the **Toggle** **All** checkbox under **UI** **Core**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the **Sortable** checkbox under **Interactions**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the bottom, select **No** **Theme** from the **Theme** dropdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your selections will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/image00383.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All we need is the sortable interaction and the UI core. Everything else just
    adds to our file size, so we'll leave it out. Click on **Download**, unzip the
    downloaded file once complete, locate the `jquery-ui.min.js` file, and copy it
    to your `[project root]/client/lib/scripts` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We could simply pull in jQuery UI using a community package, but it's a bit
    bulkier and it doesn't help us see how non-packaged third-party libraries can
    be used inside Meteor. So, we'll go with this manual installation.
  prefs: []
  type: TYPE_NORMAL
- en: Open a browser to `http://localhost:3000` so we can see the changes in real
    time. We are now ready to add the jQuery UI-sortable widget to our project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create color swatches, which will display the hexadecimal code they
    represent, and they will be sortable, which means we can move them around via
    drag and drop.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we first need to create a `Swatches` collection, accessible
    on both the client and the server. In your `[project root]/both/` folder, create/edit
    a file named `model.js` and add the following collection declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create our UI using a template named `swatches`. Open/create the
    `[project root]/client/main.html` file, remove all the contents, and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will want to style it just a little bit to make the swatches consistently
    sized. Open/create a file named `[project root]/client/lib/styles/style.css` and
    add the following CSS declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will create the logic needed to add swatches and be able to drag
    them around the screen. Open/create the `[project root]/client/scripts/main.js`
    file, delete anything inside the file, and add the following `Template.helpers`
    and `Rankings` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the fun part! We will create the `jQuery.sortable` object with its `stop()`
    function and hook up our `button.click` event handler using regular jQuery. In
    order for the `sortable` and `click` event handlers to be added properly, we need
    to declare them inside a `Template.rendered()` function. In the same `main.js`
    file, just below the `Rankings` declaration, enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all of your changes and hop over to your browser. The page should have
    a nice, stylish blue button labeled **NEW** **COLOR**. Every time you click on
    this button, a new swatch will be added with a random color. If you drag and drop
    any of the swatches from one position to another, the swatches will be reordered
    appropriately. This reordering is not temporary. If you refresh the page or open
    another browser window, the reordering you did via drag and drop will remain.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, let's say you move a swatch from the last element to the first.
    The change will stick and any other clients/browsers that open to the same page
    will instantly reflect the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the following purple swatch is dragged and dropped, the changes will be
    as shown, as displayed on the right-hand side of the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image00384.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is instantly updated in every UI, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image00385.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thanks to our `click` event handler, whenever a swatch is added using `Swatches.insert()`,
    a rank is assigned to that swatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the `swatches` helper inside `Template.colors.helpers`, we can
    see that the Mongo `Collection.find()` query is sorted by `rank`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This preserves the order of the swatches in the UI and allows us to manipulate
    their order as a result of drag and drop.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of our `sortable.stop()` function, we were identifying where in the list
    the swatch had been dragged and dropped to. Once we determine where the swatch
    is located, we calculate a new rank for that swatch using the `Rankings` helper
    functions. We then immediately update the `swatches` collection with the new rank,
    which propagates and makes the position of the UI change permanent.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key takeaway here is that while jQuery (or any other third-party library)
    may be used to make direct DOM manipulations, these manipulations won't persist
    beyond a single user's session, or even beyond the next DDP change from the server.
  prefs: []
  type: TYPE_NORMAL
- en: To make the manipulations permanent and to fully utilize the Blaze rendering
    engine's fantastic reactive programming model, we need to modify the datasource
    (in this case, the `swatches` collection). The modification is handled immediately,
    and with no effort on our part, through reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: So, to review, third-party libraries can go right ahead and manipulate DOM elements
    in a Meteor application, with the third-party code being executed inside a `Template.rendered()`
    function block.
  prefs: []
  type: TYPE_NORMAL
- en: To make the changes "stick", we simply update the corresponding Mongo collection
    as well. Using this technique, we can integrate nearly every JavaScript library
    out there (if someone hasn't already done it for us on [https://atmospherejs.com/](https://atmospherejs.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Setting up your project file structure* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Optimizing Your Workflow"), *Optimizing Your Workflow*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using inline data to modify UI elements reactively* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
