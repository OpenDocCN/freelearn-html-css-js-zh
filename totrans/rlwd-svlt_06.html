<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer023">
<h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor091"/>6</h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor092"/>Integrating Libraries with Actions</h1>
<p>There are a lot of JavaScript UI libraries out there on the internet. However, at the time of writing this book, Svelte is relatively new. Not all the UI libraries out there are written using Svelte and written specifically for Svelte. But that does not mean that we can’t use them in our <span class="No-Break">Svelte component.</span></p>
<p>There are many ways to integrate third-party JavaScript UI libraries into Svelte. In this chapter, we are going to explore how we can do it using <span class="No-Break">Svelte actions.</span></p>
<p>We will start by integrating an imaginary UI library, slowly building up our case for why Svelte actions are suitable for the job. Along the way, I will explain how to use Svelte actions for different scenarios and show you where Svelte actions fall short. I’ll discuss my reasonings and personal opinions on when to choose Svelte actions and when to <span class="No-Break">choose otherwise.</span></p>
<p>Following that, I will show you some real-world UI library examples. After that, we will explore integrating UI libraries written in other frameworks, such as React and Vue, with a few <span class="No-Break">more examples.</span></p>
<p>By the end of this chapter, you will see that you are not limited to using only UI libraries written in Svelte in your Svelte application – you can reuse any UI library that is available on <span class="No-Break">the internet.</span></p>
<p>This chapter covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>Integrating JavaScript UI libraries <span class="No-Break">into Svelte</span></li>
<li>Why we should use actions to integrate UI libraries and <span class="No-Break">other alternatives</span></li>
<li>Integrating UI libraries written in other frameworks <span class="No-Break">into Svelte</span></li>
</ul>
<h1 id="_idParaDest-92"><a id="_idTextAnchor093"/>Technical requirements</h1>
<p>You can find the examples and code for this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/>Integrating vanilla JavaScript UI libraries into Svelte</h1>
<p>First, we will <a id="_idIndexMarker220"/>explore UI libraries that are written in vanilla JavaScript. When we use the phrase <em class="italic">vanilla JavaScript</em>, we’re referring to plain JavaScript, or JavaScript in the absence of frameworks <span class="No-Break">or libraries.</span></p>
<p>There are many reasons a UI library is written in <span class="No-Break">vanilla JavaScript:</span></p>
<ul>
<li>Performance reasons – it would be much easier to optimize without the abstractions from the <span class="No-Break">web framework</span></li>
<li>The library author’s personal preference to <span class="No-Break">be framework-agnostic</span></li>
<li>The library was created predating any modern <span class="No-Break">web frameworks</span></li>
</ul>
<p>For us, vanilla JavaScript UI libraries are great because they do not depend on any specific framework runtime, which is an extra overhead on top of the UI <span class="No-Break">library itself.</span></p>
<p>For example, if we use a calendar component library that is implemented in React, then besides installing the calendar component library, we would need to install React’s framework <span class="No-Break">as well.</span></p>
<p>This additional dependency leads to an increased bundle size and potential conflicts with Svelte. Therefore, when using a component library in Svelte, it is generally preferable to choose a library that does not depend on any <span class="No-Break">specific framework.</span></p>
<p>Now that we have learned about why vanilla JavaScript UI libraries are great, let’s discuss how we can integrate them into Svelte. In this chapter, we will explore integrating libraries in Svelte using Svelte actions, which begs the question, why do we choose to use Svelte actions to integrate a <span class="No-Break">UI library?</span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>Why use Svelte actions to integrate a UI library?</h2>
<p>In the previous <a id="_idIndexMarker221"/>chapter, we explored how Svelte actions are useful for adding custom event handlers. At the same time, Svelte actions function as element-level life cycle functions, making them very useful for interfacing with third-party libraries. Now, let’s explore why that’s <span class="No-Break">the case.</span></p>
<p>Let’s take a calendar component library as an example. For simplicity’s sake and to not get bogged down by implementation details, let’s imagine the library as an imaginary library instead of using any real-life calendar component library. This allows us to focus on the general problem itself rather than the specific library’s <span class="No-Break">implementation details.</span></p>
<p>We will look at some real-life UI <span class="No-Break">libraries afterward.</span></p>
<p>To decide <a id="_idIndexMarker222"/>where the calendar component will be added to the DOM, component libraries usually require us to specify a container element to house the <span class="No-Break">library component.</span></p>
<p>For example, here, <strong class="source-inline">ImaginaryCalendar</strong> requires us to pass the container element as part of the argument for <span class="No-Break">the constructor:</span></p>
<pre class="source-code">
new ImaginaryCalendar({ container: containerElement })</pre> <p>To get the reference to an element in Svelte, we can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">bind:this</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  let containerElement;
&lt;/script&gt;
&lt;div bind:this={containerElement} /&gt;</pre> <p>The <strong class="source-inline">containerElement</strong> variable is only updated with the reference of the element after the element is mounted, so it can only be referred to <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">onMount</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let containerElement;
  let calendar;
  onMount(() =&gt; {
    calendar = new ImaginaryCalendar({ container: containerElement });
    return () =&gt; calendar.cleanup();
  });
&lt;/script&gt;</pre> <p>Note that we are keeping the reference of the <strong class="source-inline">calendar</strong> instance because we can use it to call calendar methods to get or <span class="No-Break">set values:</span></p>
<pre class="source-code">
calendar.setDate(date);</pre> <p>Also, we call <strong class="source-inline">calendar.cleanup()</strong> when the component unmounts for <span class="No-Break">cleanup purposes.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">The calendar library is just an imaginary example. However, most UI libraries will provide similar APIs or methods to retrieve or modify the component instance’s internal state and clean up when they are no longer <span class="No-Break">in use.</span></p>
<p>We need<a id="_idIndexMarker223"/> to be extra careful when we are using the <strong class="source-inline">calendar</strong> instance here. We want to avoid referencing the <strong class="source-inline">calendar</strong> instance before it is initialized to prevent encountering a reference error as the calendar instance is only declared and initialized <span class="No-Break">after </span><span class="No-Break"><strong class="source-inline">onMount</strong></span><span class="No-Break">:</span></p>
<p>To be safe, we should check whether the <strong class="source-inline">calendar</strong> instance is defined before calling any of its methods. In the code example below, we verify if the calendar instance is defined, before calling the <span class="No-Break"><strong class="source-inline">calendar.setDate()</strong></span><span class="No-Break"> method.</span></p>
<pre class="source-code">
if (calendar) calendar.setDate(date).</pre> <p>The need for this extra level of cautiousness is more obvious when the calendar is <span class="No-Break">conditionally created:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let containerElement;
  let calendar;
  onMount(() =&gt; {
    if (containerElement) {
      calendar = new ImaginaryCalendar({ container: containerElement });
      return () =&gt; calendar.cleanup();
    }
  });
&lt;/script&gt;
{#if someCondition}
  &lt;div bind:this={containerElement} /&gt;
{/if}</pre> <p>In the preceding code, you can see that <strong class="source-inline">&lt;div&gt;</strong> is conditionally created based on <strong class="source-inline">someCondition</strong>. That is why in <strong class="source-inline">onMount</strong>, we need to check whether <strong class="source-inline">containerElement</strong> is available before we create <strong class="source-inline">ImaginaryCalendar</strong> using <strong class="source-inline">containerElement</strong> as a container. And the <strong class="source-inline">calendar</strong> instance is only available if <strong class="source-inline">ImaginaryCalendar</strong> is created, and thus only available if <strong class="source-inline">someCondition</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
<p>The preceding code illustrates one of the many possibilities where the <strong class="source-inline">calendar</strong> instance could <span class="No-Break">be undefined.</span></p>
<p>One thing to note about this code is that it is not behaviorally correct as it does not attempt to create <strong class="source-inline">ImaginaryCalendar</strong> whenever the value of <strong class="source-inline">someCondition</strong> turns from <strong class="source-inline">false</strong> to <strong class="source-inline">true</strong> and does cleanup whenever it turns back <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
<p>This is where Svelte <span class="No-Break">actions shine.</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>Using Svelte actions</h2>
<p>By altering the <a id="_idIndexMarker224"/>preceding code so that it uses actions, you will see that we do not need the extra check to ensure that <strong class="source-inline">containerElement</strong> is available before <span class="No-Break">instantiating </span><span class="No-Break"><strong class="source-inline">ImaginaryCalendar</strong></span><span class="No-Break">.</span></p>
<p>The following code shows how such an action could be implemented. Here, the name of our Svelte action <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">calendar</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  function calendar(containerElement) {
    const calendar = new ImaginaryCalendar({ container: containerElement });
    return {
      destroy() {
        calendar.cleanup();
      }
    };
  }
&lt;/script&gt;
{#if someCondition}
  &lt;div use:calendar /&gt;
{/if}</pre> <p>This is because, when <a id="_idIndexMarker225"/>using Svelte actions, the action function will only be called with the reference of the element whenever the element is created and mounted onto <span class="No-Break">the DOM.</span></p>
<p>When the condition changes to such that the <strong class="source-inline">&lt;div&gt;</strong> element is removed from the DOM, the <strong class="source-inline">destroy</strong> method of the action will be called to clean <span class="No-Break">things up.</span></p>
<p>Using Svelte actions, we can now create as many <strong class="source-inline">ImaginaryCalendar</strong> instances as we want within one component by adding the action to different <span class="No-Break">HTML elements:</span></p>
<p>To prove my point, in the code snippet below, in addition to the original <strong class="source-inline">&lt;div&gt;</strong> element you’ve seen in the previous examples, I am adding another <strong class="source-inline">&lt;div&gt;</strong> element and three more <strong class="source-inline">&lt;div&gt;</strong> elements using the <strong class="source-inline">{#each}</strong> block. I am then applying the calendar actions to all four <strong class="source-inline">&lt;div&gt;</strong> elements to create four more calendars, and we do not run into any errors for having multiple calendars <span class="No-Break">at once.</span></p>
<pre class="source-code">
{#if someCondition}
  &lt;div use:calendar /&gt;
{/if}
&lt;!-- Look we can have as many calendars as we want --&gt;
&lt;div use:calendar /&gt;
{#each [1, 2, 3] as item}
  &lt;div use:calendar /&gt;
{/each}</pre> <p>If we <a id="_idIndexMarker226"/>were to use <strong class="source-inline">bind:this</strong> and <strong class="source-inline">onMount</strong>, we would have to repeat ourselves multiple times by declaring multiple <strong class="source-inline">containerElement</strong> variables multiple times and instantiate <strong class="source-inline">ImaginaryCalendar</strong> with each of the <span class="No-Break"><strong class="source-inline">containerElement</strong></span><span class="No-Break"> variables.</span></p>
<p>Now, with the <strong class="source-inline">calendar</strong> instance encapsulated within the action, how should we call the <strong class="source-inline">calendar</strong> instance method to update the <strong class="source-inline">calendar</strong> state from <span class="No-Break">the outside?</span></p>
<p>That’s what the action data <span class="No-Break">is for!</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/>Adding data to Svelte actions</h2>
<p>In the <a id="_idIndexMarker227"/>previous section, we created a <strong class="source-inline">calendar</strong> action and instantiated an <strong class="source-inline">ImaginaryCalendar</strong> instance inside that action. If we want to call an instance method of <strong class="source-inline">ImaginaryCalendar</strong> outside the <strong class="source-inline">calendar</strong> action, such as calling <strong class="source-inline">calendar.setDate(date)</strong> to set the date of the calendar, what should <span class="No-Break">we do?</span></p>
<p>There’s no way to call <strong class="source-inline">calendar.setDate(date)</strong> outside of the <strong class="source-inline">calendar</strong> action since the <strong class="source-inline">calendar</strong> instance is defined within the <strong class="source-inline">calendar</strong> action. A workaround is to pass <strong class="source-inline">date</strong> through action data – that is, we can provide <strong class="source-inline">date</strong> as action data and call <strong class="source-inline">calendar.setDate(date)</strong> with the date <span class="No-Break">passed in.</span></p>
<p>For example, in the following code snippet, we’re passing <strong class="source-inline">date</strong> into the <span class="No-Break"><strong class="source-inline">calendar</strong></span><span class="No-Break"> action:</span></p>
<pre class="source-code">
&lt;div use:calendar={date} /&gt;</pre> <p>In the <strong class="source-inline">calendar</strong> action, we call <strong class="source-inline">calendar.setDate(date)</strong> with the date passed in. In addition to that, we define an <strong class="source-inline">update</strong> method in the action, such that whenever the date that’s passed to the calendar action changes, Svelte will <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">calendar.setDate(date)</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  function calendar(containerElement, date) {
    const calendar = new ImaginaryCalendar({ container: containerElement });
    <strong class="bold">calendar.setDate(date);</strong>
    return {
      <strong class="bold">update(newDate) {</strong>
        <strong class="bold">calendar.setDate(newDate);</strong>
      <strong class="bold">},</strong>
      destroy() {
        calendar.cleanup();
      }
    };
  }
&lt;/script&gt;
&lt;div use:calendar={new Date(2022, 10, 5)} /&gt;</pre> <p>Here, we <a id="_idIndexMarker228"/>can pass different dates to the different <span class="No-Break"><strong class="source-inline">calendar</strong></span><span class="No-Break"> instances:</span></p>
<pre class="source-code">
{#each dates as date}
  &lt;div use:calendar={date} /&gt;
{/each}</pre> <p><span class="No-Break">That’s great!</span></p>
<p>Now, what if you want to call a different <strong class="source-inline">calendar</strong> instance method, such as <strong class="source-inline">calendar.setMode()</strong>, whenever the <span class="No-Break">mode changes?</span></p>
<p>You could pass both <strong class="source-inline">date</strong> and <strong class="source-inline">mode</strong> into <span class="No-Break">the action:</span></p>
<pre class="source-code">
&lt;div use:calendar={{ date, mode }} /&gt;</pre> <p>In that case, the <strong class="source-inline">calendar</strong> action would need to handle both <strong class="source-inline">date</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">mode</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
function calendar(node, { date, mode }) {
  const calendar = new ImaginaryCalendar({ container: containerElement });
  calendar.setDate(date);
  calendar.setMode(mode);
  return {
    update({ date: newDate, mode: newMode }) {
      calendar.setDate(newDate);
      calendar.setMode(newMode);
    },
    destroy() { ... }
  };
}</pre> <p>The <strong class="source-inline">update</strong> method <a id="_idIndexMarker229"/>of the <strong class="source-inline">calendar</strong> action will be called whenever either <strong class="source-inline">date</strong> or <strong class="source-inline">mode</strong> changes. This means that in the preceding code, we are calling both <strong class="source-inline">calendar.setDate()</strong> and <strong class="source-inline">calendar.setMode()</strong> whenever either <strong class="source-inline">date</strong> or <strong class="source-inline">mode</strong> changes. This may not have any apparent consequences, but we may be doing an <span class="No-Break">unnecessary job.</span></p>
<p>A workaround for this is to keep track and always check whether <strong class="source-inline">date</strong> or <strong class="source-inline">mode</strong> have changed in the <strong class="source-inline">update</strong> method. This is how we can <span class="No-Break">do this:</span></p>
<pre class="source-code">
function calendar(node, { date, mode }) {
  const calendar = new ImaginaryCalendar({ container: containerElement });
  calendar.setDate(date);
  calendar.setMode(mode);
  return {
    update({ date: newDate, mode: newMode }) {
      if (date !== newDate) {
        calendar.setDate(newDate);
        date = newDate;
      }
      if (mode !== newMode) {
        calendar.setMode(newMode);
        mode = newMode;
      }
    },
    destroy() { ... }
  };
}</pre> <p>In the <a id="_idIndexMarker230"/>preceding code, we’re checking if <strong class="source-inline">newDate</strong> is different from the current <strong class="source-inline">date</strong>, and if it is different, then we call the <strong class="source-inline">calendar.setDate()</strong> method and update our current reference of <strong class="source-inline">date</strong>. We do a similar thing <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">mode</strong></span><span class="No-Break">.</span></p>
<p>This works. However, as you can see, it is more code and more complex than what we set up when we first started creating the <span class="No-Break"><strong class="source-inline">calendar</strong></span><span class="No-Break"> action.</span></p>
<p>And what if you want to call a <strong class="source-inline">calendar</strong> instance method that is not tied to any data, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">calendar.refreshDates()</strong></span><span class="No-Break">?</span></p>
<p>This is where using actions <span class="No-Break">falls short.</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>An alternative to Svelte actions</h2>
<p>Remember<a id="_idIndexMarker231"/> the previous example, where we used <strong class="source-inline">bind:this</strong> and <strong class="source-inline">onMount</strong> to <span class="No-Break">initialize </span><span class="No-Break"><strong class="source-inline">ImaginaryCalendar</strong></span><span class="No-Break">?</span></p>
<p>We said that the approach is not versatile enough and falls short if we need to do <span class="No-Break">the following:</span></p>
<ul>
<li>Conditionally render the container and <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">ImaginaryCalendar</strong></span></li>
<li>Have multiple calendars within the <span class="No-Break">same component</span></li>
</ul>
<p>These drawbacks are all true, but there’s a use case in which it is perfectly fine to use <strong class="source-inline">bind:this</strong> and <strong class="source-inline">onMount</strong> to initialize <strong class="source-inline">ImaginaryCalendar</strong>. This is when the conditions we mentioned previously are <span class="No-Break">never true:</span></p>
<ul>
<li>We do not need to conditionally render <span class="No-Break">the container</span></li>
<li>We do not need to have multiple calendar instances within the same component (this is not exactly true, but we will come back <span class="No-Break">to this)</span></li>
</ul>
<p>I’m not <a id="_idIndexMarker232"/>sure whether you are thinking the same thing right now but allow me to cut <span class="No-Break">the suspense.</span></p>
<p>This is when we want to use <strong class="source-inline">ImaginaryCalendar</strong> as a <span class="No-Break">Svelte component.</span></p>
<p>Within the <strong class="source-inline">ImaginaryCalendar</strong> Svelte component itself, we will have only one container element, and it will always <span class="No-Break">be available:</span></p>
<pre class="source-code">
&lt;!-- ImaginaryCalendarComponent.svelte --&gt;
&lt;script&gt;
  import { onMount } from 'svelte';
  let containerElement;
  let calendar;
  onMount(() =&gt; { ... });
&lt;/script&gt;
&lt;div bind:this={containerElement} /&gt;</pre> <p>You can then use this <span class="No-Break">component conditionally:</span></p>
<pre class="source-code">
&lt;script&gt;
  import ImaginaryCalendarComponent from './ ImaginaryCalendarComponent.svelte';
&lt;/script&gt;
{#if someCondition}
  &lt;ImaginaryCalendarComponent /&gt;
{/if}</pre> <p>Alternatively, you can use it however many times as <span class="No-Break">you like:</span></p>
<pre class="source-code">
{#if someCondition}
  &lt;ImaginaryCalendarComponent /&gt;
{/if}
&lt;!-- Look we can have as many calendars as we want --&gt;
&lt;ImaginaryCalendarComponent /&gt;
{#each array as item}
  &lt;ImaginaryCalendarComponent /&gt;
{/each}</pre> <p>Here, we’ve <a id="_idIndexMarker233"/>swapped out elements using actions, <strong class="source-inline">&lt;div use:calendar /&gt;</strong>, with Svelte components, <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">ImaginaryCalendarComponent /&gt;</strong></span><span class="No-Break">.</span></p>
<p>This is <span class="No-Break">perfectly normal.</span></p>
<p>In the previous chapter, we contemplated between abstracting logic through components or abstracting <span class="No-Break">through actions.</span></p>
<p>In this scenario, we are looking at abstracting the logic of instantiating a UI library using an element as a container, and we could abstract it into a Svelte action or a <span class="No-Break">Svelte component.</span></p>
<p>Both options are <span class="No-Break">equally fine.</span></p>
<p>Both options are designed <span class="No-Break">for this.</span></p>
<p>So, which options should you choose? Let’s <span class="No-Break">find out.</span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Choosing between Svelte actions and Svelte components</h2>
<p>Here are <a id="_idIndexMarker234"/>my personal preferences when faced with a choice between <span class="No-Break">either option.</span></p>
<p>Choose a Svelte action to integrate with a UI library when you are looking for an option that provides the <span class="No-Break">following aspects:</span></p>
<ul>
<li>Is more lightweight. A Svelte component has slightly more overhead compared to a <span class="No-Break">Svelte action.</span></li>
<li>Only passes zero to one data into the UI library component instance. If you were to pass in two or more pieces of data into the action, then the update method of the action will be called whenever any part of the <span class="No-Break">data changes.</span></li>
</ul>
<p>You should <a id="_idIndexMarker235"/>choose a Svelte component if you are looking for an option that provides <span class="No-Break">the following:</span></p>
<ul>
<li>Allows more room for optimization and <span class="No-Break">finer control</span></li>
<li>Allows you to call UI library component instance <span class="No-Break">methods directly</span></li>
<li>Allows you to pass in child content into the UI <span class="No-Break">component library</span></li>
</ul>
<p>We did not discuss this much, but integrating a UI library as a component opens up the possibility of passing additional content into the UI component library <span class="No-Break">through slots:</span></p>
<pre class="source-code">
&lt;ImaginaryCalendarComponent&gt;
  &lt;!—Customize how each cell of the calendar looks ––&gt;
  &lt;svelte:fragment sl"t="c"ll" let:date&gt;
    {date}
  &lt;/svelte:fragment&gt;
&lt;/ImaginaryCalendarComponent&gt;</pre> <p>If you are interested in learning more about slots and how to compose components in Svelte, read <a href="B18887_04.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, where we explored this topic extensively. Now that we’ve covered how we could integrate a UI library using Svelte actions, why we should use Svelte actions, as well as the alternatives and considerations, let’s take a look at a real-world <span class="No-Break">example, Tippy.js.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>Example – integrating Tippy.js</h1>
<p>Tippy.js is a<a id="_idIndexMarker236"/> tooltip, popover, dropdown, and <span class="No-Break">menu library.</span></p>
<p>I do not have any affiliation with the Tippy.js library, and the reason I chose Tippy.js as an example is purely by chance. Nonetheless, Tippy.js has a nice and simple API, making it a good candidate for <span class="No-Break">an example.</span></p>
<p>First, let’s<a id="_idIndexMarker237"/> look at the Tippy.js <span class="No-Break">documentation: </span><a href="https://atomiks.github.io/tippyjs/"><span class="No-Break">https://atomiks.github.io/tippyjs/</span></a><span class="No-Break">.</span></p>
<p>After <a id="_idIndexMarker238"/>installing the <strong class="source-inline">tippy.js</strong> library using a package manager of our choice, we can then import Tippy.js into <span class="No-Break">our code:</span></p>
<pre class="source-code">
import tippy from 'tippy.js';
import 'tippy.js/dist/tippy.css';</pre> <p>Now, we can initialize <strong class="source-inline">tippy</strong> with the following <span class="No-Break">constructor function:</span></p>
<pre class="source-code">
tippy('#id');
tippy(document.getElementById('my-element'));</pre> <p>Here, we pass in the element where Tippy.js should provide <span class="No-Break">a tooltip.</span></p>
<p>You can specify any customizations of the tooltip's content through the data attributes of the element, which Tippy.js will pick up as <span class="No-Break">it initializes:</span></p>
<pre class="source-code">
&lt;button data-tippy-content="hello" /&gt;</pre> <p>Alternatively, you can pass this in <span class="No-Break">the constructor:</span></p>
<pre class="source-code">
tippy(element, { content: 'hello' });</pre> <p>To update the content after initialization, call the Tippy.js <span class="No-Break"><strong class="source-inline">setContent</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
tooltipInstance.setContent("bye");</pre> <p>To permanently destroy and clean up the tooltip instance, Tippy.js provides the <span class="No-Break"><strong class="source-inline">destroy</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
tooltipInstance.destroy();</pre> <p>Here, we have all we need to create a <strong class="source-inline">tippy</strong> action. We have methods to do <span class="No-Break">the following:</span></p>
<ul>
<li>Create the <strong class="source-inline">tippy</strong> tooltip – <span class="No-Break"><strong class="source-inline">tippy(…)</strong></span></li>
<li>Clean up the <strong class="source-inline">tippy</strong> tooltip – <span class="No-Break"><strong class="source-inline">tooltipInstance.destroy()</strong></span></li>
<li>Update the <strong class="source-inline">tippy</strong> tooltip – <span class="No-Break"><strong class="source-inline">tooltipInstance.setContent(…)</strong></span></li>
</ul>
<p>Let’s take a look at what the <strong class="source-inline">tippy</strong> action should <span class="No-Break">look like.</span></p>
<p>Here is how I want it <span class="No-Break">to look:</span></p>
<pre class="source-code">
&lt;div use:tippy={tooltipContent} /&gt;</pre> <p>In the <a id="_idIndexMarker239"/>preceding code snippet, we applied our <strong class="source-inline">tippy</strong> action to a <strong class="source-inline">&lt;div&gt;</strong> element. The content within the tooltip created by Tippy.js should be passed into the <strong class="source-inline">tippy</strong> action as action data, represented by the <strong class="source-inline">tooltipContent</strong> variable. Whenever <strong class="source-inline">tooltipContent</strong> changes, the action should react to it and update <span class="No-Break">the tooltip.</span></p>
<p>So, let’s write our <strong class="source-inline">tippy</strong> Svelte action. Here’s the scaffolding for <span class="No-Break">an action:</span></p>
<pre class="source-code">
function tippy(element, content) {
  // TODO #1: initialize the library
  return {
    update(newContent) {
      // TODO #2: do something when action data changes
    },
    destroy() {
      // TODO #3: clean up
    }
  };
}</pre> <p>As you can see, we created the <strong class="source-inline">tippy</strong> action based on the Svelte action contract: a function that returns an object with <strong class="source-inline">destroy</strong> and <span class="No-Break"><strong class="source-inline">update</strong></span><span class="No-Break"> methods.</span></p>
<p>I left three TODOs in the code, each marking different stages of Svelte actions. Let’s go through each one and fill them up. The first <strong class="source-inline">TODO</strong> is where the action will be called after the element is created and mounted onto the DOM. Here, we are given the element the action is applied to and the action data, and we should use it to initialize the <span class="No-Break">Tippy.js tooltip:</span></p>
<pre class="source-code">
// TODO #1: initialize the library
const tooltipInstance = tippy(element, { content });</pre> <p>The<a id="_idIndexMarker240"/> second <strong class="source-inline">TODO</strong> is inside the <strong class="source-inline">update</strong> method. This method will be called every time the action data changes. Here, we need to call the Tippy.js tooltip instance to reflect the dataset in the <span class="No-Break">Svelte component:</span></p>
<pre class="source-code">
// TODO #2: do something when action data changes
tooltipInstance.setContent(newContent);</pre> <p>The third <strong class="source-inline">TODO</strong> is inside the <strong class="source-inline">destroy</strong> method. This method will be called after the element is removed from the DOM. Here, we need to do the cleanup on the Tippy.js tooltip instance that we created in <span class="No-Break">the action:</span></p>
<pre class="source-code">
// TODO #3: clean up
tooltipInstance.destroy();</pre> <p>And that’s it – we now have a working <strong class="source-inline">tippy</strong> action that integrates the Tippy.js tooltip and will show a tooltip with customizable content whenever we hover over <span class="No-Break">the element.</span></p>
<p>You can find the complete code on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy"><span class="No-Break">https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy</span></a><span class="No-Break">.</span></p>
<p>Let’s look at one more example, through which I want to show you one more thing that you can do with actions when integrating with <span class="No-Break">UI libraries.</span></p>
<p>The UI library we are going to look at next <span class="No-Break">is CodeMirror.</span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor101"/>Example – integrating CodeMirror</h1>
<p>CodeMirror is <a id="_idIndexMarker241"/>a code editor component that has many great features for editing, such as syntax highlighting, code folding, <span class="No-Break">and more.</span></p>
<p>You can find the <a id="_idIndexMarker242"/>CodeMirror documentation <span class="No-Break">at </span><a href="https://codemirror.net/"><span class="No-Break">https://codemirror.net/</span></a><span class="No-Break">.</span></p>
<p>At the time of writing, CodeMirror is currently at <span class="No-Break">version 5.65.9.</span></p>
<p>After installing the <strong class="source-inline">codemirror</strong> library using the package manager of our choice, we can import <strong class="source-inline">codemirror</strong> into <span class="No-Break">our code:</span></p>
<pre class="source-code">
import CodeMirror from 'codemirror';
import 'codemirror/lib/codemirror.css';</pre> <p>Now, we can initialize CodeMirror with the following <span class="No-Break">constructor function:</span></p>
<pre class="source-code">
const myCodeMirror = CodeMirror(document.body);</pre> <p>Here, we <a id="_idIndexMarker243"/>pass in the element where we want the CodeMirror code editor <span class="No-Break">to be.</span></p>
<p>Before I continue, at this point, note that we are looking for the same set of things <span class="No-Break">from CodeMirror:</span></p>
<ul>
<li>Methods to <span class="No-Break">initialize CodeMirror</span></li>
<li>Any method needed to clean up a <span class="No-Break">CodeMirror instance</span></li>
<li>Any method to update a <span class="No-Break">CodeMirror instance</span></li>
</ul>
<p>I am going to leave it to you to complete the checklist and figure <span class="No-Break">it out.</span></p>
<p>However, allow me to draw your attention to one particular API from the <span class="No-Break">CodeMirror instance:</span></p>
<pre class="source-code">
myCodeMirror.on('change', () =&gt; { ... });</pre> <p>The <strong class="source-inline">on</strong> method from CodeMirror allows the CodeMirror instance to listen to events and react <span class="No-Break">to them.</span></p>
<p>So, if we want to add event listeners to the CodeMirror instance from outside of the action, how should we <span class="No-Break">do it?</span></p>
<p>In the previous chapter, we saw that we could create custom events on the element <span class="No-Break">using actions.</span></p>
<p>This means that we can allow users to listen to the <strong class="source-inline">'change'</strong> event from the element that uses the <span class="No-Break"><strong class="source-inline">codemirror</strong></span><span class="No-Break"> action:</span></p>
<pre class="source-code">
&lt;div use:codemirror on:change={onChangeHandler} /&gt;</pre> <p>To make this happen, you can dispatch an event from within <span class="No-Break">the action:</span></p>
<pre class="source-code">
function codemirror(element) {
  const editor = CodeMirror(element);
  editor.on('change', () =&gt; {
    // trigger 'change' event on the element
    // whenever the editor changes
    element.dispatchEvent(new CustomEvent('change'));
  });
}</pre> <p>Remember<a id="_idIndexMarker244"/> to check whether you need to clean up or unlisten to any event in the <strong class="source-inline">destroy</strong> method so that you don’t cause any <span class="No-Break">unwanted behavior.</span></p>
<p>And <span class="No-Break">that’s it!</span></p>
<p>The rest of the action is left to you as <span class="No-Break">an exercise.</span></p>
<p>You can find the complete code on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror</span></a><span class="No-Break">.</span></p>
<p>In this section, we learned how to integrate vanilla UI libraries into Svelte. However, not all UI libraries are implemented independently without any framework. Sometimes, the library you are looking for might be implemented in a different framework, such as React or Vue. In such cases, how can you integrate them into a Svelte application? That is what we will <span class="No-Break">explore next.</span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor102"/>Using UI libraries written in other frameworks</h1>
<p>It is not impossible to use components from other frameworks <span class="No-Break">in Svelte.</span></p>
<p>However, doing<a id="_idIndexMarker245"/> so will introduce the framework’s runtime and other overheads that come along with the framework. The runtime usually includes code to handle reactivity and normalize browser APIs and events. Each framework usually ships its own code for this logic and does not share it with other frameworks. The runtime for React version 18.2.0 weighs 6.4 kB when minified, which is additional code you need to include when you want to use a React component <span class="No-Break">within Svelte.</span></p>
<p>So, this is not recommended unless it <span class="No-Break">is necessary.</span></p>
<p>The reason this section has been included in this book is more for educational purposes and to demonstrate that this is possible, as well as what needs to be done to make <span class="No-Break">it happen.</span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/>Creating components in various frameworks</h2>
<p>Each<a id="_idIndexMarker246"/> framework usually provides an API that takes in a container element and the framework component as the root of <span class="No-Break">the application.</span></p>
<p>In this section, we’re going to take a look at React and Vue, the two most popular JavaScript frameworks at the time <span class="No-Break">of writing.</span></p>
<p>For example, in React 18, we use the <span class="No-Break"><strong class="source-inline">createRoot</strong></span><span class="No-Break"> API:</span></p>
<pre class="source-code">
import ReactDOM from 'react-dom';
const root = ReactDOM.createRoot(container);
root.render(&lt;h1&gt;Hello, world&lt;/h1&gt;);</pre> <p>The preceding code uses the JSX syntax, which is not part of the standard JavaScript language syntax. It is syntactic sugar <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">jsx</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import { jsx } from 'react/jsx-runtime';
const root = ReactDOM.createRoot(container)
root.render(jsx('h1', { children: 'Hello, world' }));</pre> <p>You will have to write the preceding code if you do not configure any transpiling process in your code to turn JSX syntax into <span class="No-Break">valid JavaScript.</span></p>
<p>On the other hand, In Vue 3, there is the <span class="No-Break"><strong class="source-inline">createApp</strong></span><span class="No-Break"> API:</span></p>
<pre class="source-code">
import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App);
app.mount(container);</pre> <p>The Vue framework uses the word <em class="italic">application</em> in the documentation, mentioning that the <strong class="source-inline">createApp</strong> method is used to create a new application instance. The word <em class="italic">application</em> is aptly used as integrating component libraries written in other frameworks is very much like starting a new sub-application within our <span class="No-Break">Svelte application.</span></p>
<p>You may <a id="_idIndexMarker247"/>have also started to notice the similarity between the APIs from these frameworks and other UI libraries that we’ve seen so far – all of them take in a container element so that they know where to render the content or <span class="No-Break">apply changes.</span></p>
<p>Similar to integrating UI libraries using actions, after figuring out what APIs we can use to render a component within a container element, the next thing we must check is whether there is any API to clean up when it is no <span class="No-Break">longer needed.</span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor104"/>Cleaning up the components in various frameworks</h2>
<p>Depending <a id="_idIndexMarker248"/>on the underlying framework of the component library, different APIs are provided to clean up whenever the component is no <span class="No-Break">longer needed.</span></p>
<p>In React, there is a method for this <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">unmount</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
root.unmount();</pre> <p>In Vue, it is also <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">unmount</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
app.unmount();</pre> <p>The next thing we need to check is whether there is any API to pass data into our component and API so that they can be <span class="No-Break">updated later.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor105"/>Updating the component in various frameworks</h2>
<p>Similar to <a id="_idIndexMarker249"/>different frameworks having different APIs for cleaning up, frameworks provide different APIs to update the component with <span class="No-Break">new data.</span></p>
<p>If you are familiar with React, you can pass data into a React component <span class="No-Break">through props:</span></p>
<pre class="source-code">
&lt;Component prop_name={value} /&gt;</pre> <p>This is akin to the props in a <span class="No-Break">Svelte component.</span></p>
<p>The preceding code desugars into <span class="No-Break">the following:</span></p>
<pre class="source-code">
jsx(Component, { prop_name: value });</pre> <p>To update the props of the component, React allows us to call <strong class="source-inline">root.render</strong> again with the same component but with a different <span class="No-Break">prop value:</span></p>
<pre class="source-code">
root.render(jsx(App, { prop_name: 123 }));
// some time later
root.render(jsx(App, { prop_name: 456 }));</pre> <p>React <a id="_idIndexMarker250"/>will reconcile this internally and figure out how to update <span class="No-Break">the DOM.</span></p>
<p>On the other hand, in Vue, you can pass data through props in the <span class="No-Break"><strong class="source-inline">createApp</strong></span><span class="No-Break"> API:</span></p>
<pre class="source-code">
const app = createApp(Component, { prop_name: value });</pre> <p>However, to the best of my knowledge, there’s no straightforward way to update the props’ value from <span class="No-Break">the outside.</span></p>
<p>However, you could use a Vue Composition API, such as <strong class="source-inline">ref()</strong>, to create a reactive and mutable ref. With that, you could modify the ref instead of updating the <span class="No-Break">props directly:</span></p>
<pre class="source-code">
const value = ref(123);
const app = createApp(Component, { prop_name: ref });
// some time later
value.value = 456;</pre> <p>It is okay if you are not familiar with how React and Vue work. This book is for Svelte, not for React <span class="No-Break">or Vue.</span></p>
<p>The most important thing to take home from this is that when integrating a UI library, whether it is in vanilla JavaScript, React, or Vue, we look for <span class="No-Break">three things:</span></p>
<ul>
<li>A method to create the component with a <span class="No-Break">container element</span></li>
<li>A method to clean up the <span class="No-Break">component instance</span></li>
<li>A method to pass in data and update <span class="No-Break">the data</span></li>
</ul>
<p>If you are familiar with a framework, you will be able to figure out a way to do all <span class="No-Break">these things.</span></p>
<p>With that out of the way, let’s take a look at a real-world example, where we will integrate a React calendar <span class="No-Break">library, </span><span class="No-Break"><strong class="source-inline">react-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Integrating react-calendar into Svelte</h1>
<p>The <strong class="source-inline">react-calendar</strong> library is <a id="_idIndexMarker251"/>a calendar component library written <span class="No-Break">in React.</span></p>
<p>You can read more about it <span class="No-Break">here: </span><a href="https://projects.wojtekmaj.pl/react-calendar/"><span class="No-Break">https://projects.wojtekmaj.pl/react-calendar/</span></a><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">react-calendar</strong> library takes in various props for customization purposes. But for demonstration <a id="_idIndexMarker252"/>purposes, we are only going to focus on two props, <strong class="source-inline">value</strong> and <strong class="source-inline">onChange</strong>, which allow us to control the selected date of <span class="No-Break">the library.</span></p>
<p>We pass the <a id="_idIndexMarker253"/>selected date through a prop named <strong class="source-inline">value</strong>. The <strong class="source-inline">onChange</strong> prop, on the other hand, is used to pass in an event handler that will be called when the value changes from within the calendar component. We saw how we could handle event handlers in a UI library in the previous section when we <span class="No-Break">discussed CodeMirror.</span></p>
<p>So, here is what I think using the <strong class="source-inline">calendar</strong> action would <span class="No-Break">look like:</span></p>
<pre class="source-code">
&lt;div
  use:calendar={selectedDate}
  on:change={(event) =&gt; selectedDate = event.detail}
/&gt;</pre> <p>Here, <strong class="source-inline">event.detail</strong> is the data attached to the custom <strong class="source-inline">'change'</strong> event, which would be the date value that’s sent from the <strong class="source-inline">react-calendar</strong> component through the <span class="No-Break"><strong class="source-inline">onChange</strong></span><span class="No-Break"> props.</span></p>
<p>Now that we know what our <strong class="source-inline">calendar</strong> action would look like, let’s write the <span class="No-Break">action out.</span></p>
<p>Again, here’s the scaffolding of <span class="No-Break">an action:</span></p>
<pre class="source-code">
function calendar(element, date) {
  // TODO #1: render the react-calendar into the element
  // TODO #2: the onChange handler to dispatch a new custom event
  return {
    update(newDate) {
      // TODO #3: re-render the calendar again when there's a new date value
    },
    destroy() {
      // TODO #4: clean up
    }
  };
}</pre> <p>Here, I’ve<a id="_idIndexMarker254"/> created a basic code structure of a Svelte action and left a few TODOs within the code. The first two TODOs are to set up the <strong class="source-inline">calendar</strong> instance with the element the action is applied to. The third <strong class="source-inline">TODO</strong> is to handle when a new date is passed into the action, and the last <strong class="source-inline">TODO</strong> is to clean up when the <a id="_idIndexMarker255"/>element is removed from <span class="No-Break">the DOM.</span></p>
<p>So, let’s fill up <span class="No-Break">the TODOs.</span></p>
<p>For the first <strong class="source-inline">TODO</strong>, let’s create a React root and render our <span class="No-Break"><strong class="source-inline">react-calendar</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
import { jsx } from 'react/jsx-runtime';
import ReactDOM from 'react-dom';
function calendar(element, date) {
  # TODO #1: render the react-calendar into the element
  const app = ReactDOM.createRoot(element);
  app.render(jsx(Calendar, { value: date, onChange }));
  // ...
}</pre> <p>Here, we passed in <strong class="source-inline">onChange</strong>, which we have not <span class="No-Break">defined yet.</span></p>
<p>Let’s do <span class="No-Break">this now:</span></p>
<pre class="source-code">
# TODO #2: the onChange handler to dispatch a new custom event
function onChange(value) {
  element.dispatchEvent(
  new CustomEvent('change', { detail: value })
  );
}</pre> <p>In the<a id="_idIndexMarker256"/> preceding code snippet, whenever <strong class="source-inline">onChange</strong> is called, we<a id="_idIndexMarker257"/> will dispatch a new custom event, with <strong class="source-inline">value</strong> passed in as the detail for the <span class="No-Break">custom event.</span></p>
<p>The third <strong class="source-inline">TODO</strong> is the content for the <strong class="source-inline">update</strong> method. Whenever a new date value is passed in from the action, we will re-render the <strong class="source-inline">Calendar</strong> <span class="No-Break">component again:</span></p>
<pre class="source-code">
// TODO #3: re-render the calendar again when there's a new date value
app.render(jsx(Calendar, { value: newDate, onChange }));</pre> <p>In the last <strong class="source-inline">TODO</strong>, in the <strong class="source-inline">destroy</strong> method, we unmount our <span class="No-Break"><strong class="source-inline">Calendar</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
// TODO #4: clean up
app.unmount();</pre> <p>And <span class="No-Break">that’s it.</span></p>
<p>You can find the complete code on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar</span></a><span class="No-Break">.</span></p>
<p>With that, you’ve written a Svelte action that integrates a component library from a different framework, React, into Svelte, and you set up and updated the component’s value in a <span class="No-Break">controlled manner.</span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Summary</h1>
<p>In this chapter, we learned how to use actions to integrate UI libraries, either written in vanilla JavaScript or any other frameworks into Svelte. We went through two real-world examples – integrating Tippy.js and <strong class="source-inline">react-calendar</strong> into Svelte using Svelte actions. In both examples, we went through a step-by-step process of writing out a Svelte action. We started by creating the structure of a Svelte action and then filled up the steps within the action for when the Svelte action is initialized as the element is created, when the data changes, and when the element is removed from the DOM. We also discussed why we choose to use Svelte actions, as well as the other alternatives and considerations when it comes to integrating <span class="No-Break">UI libraries.</span></p>
<p>In the next chapter, we will look at the next common pattern of actions, which is to progressively enhance <span class="No-Break">your elements.</span></p>
</div>
</div></body></html>