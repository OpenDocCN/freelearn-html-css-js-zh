<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor091"/>6</h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor092"/>Integrating Libraries with Actions</h1>
<p>There are a lot of JavaScript UI libraries out there on the internet. However, at the time of writing this book, Svelte is relatively new. Not all the UI libraries out there are written using Svelte and written specifically for Svelte. But that does not mean that we can’t use them in our Svelte component.</p>
<p>There are many ways to integrate third-party JavaScript UI libraries into Svelte. In this chapter, we are going to explore how we can do it using Svelte actions.</p>
<p>We will start by integrating an imaginary UI library, slowly building up our case for why Svelte actions are suitable for the job. Along the way, I will explain how to use Svelte actions for different scenarios and show you where Svelte actions fall short. I’ll discuss my reasonings and personal opinions on when to choose Svelte actions and when to choose otherwise.</p>
<p>Following that, I will show you some real-world UI library examples. After that, we will explore integrating UI libraries written in other frameworks, such as React and Vue, with a few more examples.</p>
<p>By the end of this chapter, you will see that you are not limited to using only UI libraries written in Svelte in your Svelte application – you can reuse any UI library that is available on the internet.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Integrating JavaScript UI libraries into Svelte</li>
<li>Why we should use actions to integrate UI libraries and other alternatives</li>
<li>Integrating UI libraries written in other frameworks into Svelte</li>
</ul>
<h1 id="_idParaDest-92"><a id="_idTextAnchor093"/>Technical requirements</h1>
<p>You can find the examples and code for this chapter here: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06</a>.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/>Integrating vanilla JavaScript UI libraries into Svelte</h1>
<p>First, we will <a id="_idIndexMarker220"/>explore UI libraries that are written in vanilla JavaScript. When we use the phrase <em class="italic">vanilla JavaScript</em>, we’re referring to plain JavaScript, or JavaScript in the absence of frameworks or libraries.</p>
<p>There are many reasons a UI library is written in vanilla JavaScript:</p>
<ul>
<li>Performance reasons – it would be much easier to optimize without the abstractions from the web framework</li>
<li>The library author’s personal preference to be framework-agnostic</li>
<li>The library was created predating any modern web frameworks</li>
</ul>
<p>For us, vanilla JavaScript UI libraries are great because they do not depend on any specific framework runtime, which is an extra overhead on top of the UI library itself.</p>
<p>For example, if we use a calendar component library that is implemented in React, then besides installing the calendar component library, we would need to install React’s framework as well.</p>
<p>This additional dependency leads to an increased bundle size and potential conflicts with Svelte. Therefore, when using a component library in Svelte, it is generally preferable to choose a library that does not depend on any specific framework.</p>
<p>Now that we have learned about why vanilla JavaScript UI libraries are great, let’s discuss how we can integrate them into Svelte. In this chapter, we will explore integrating libraries in Svelte using Svelte actions, which begs the question, why do we choose to use Svelte actions to integrate a UI library?</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>Why use Svelte actions to integrate a UI library?</h2>
<p>In the previous <a id="_idIndexMarker221"/>chapter, we explored how Svelte actions are useful for adding custom event handlers. At the same time, Svelte actions function as element-level life cycle functions, making them very useful for interfacing with third-party libraries. Now, let’s explore why that’s the case.</p>
<p>Let’s take a calendar component library as an example. For simplicity’s sake and to not get bogged down by implementation details, let’s imagine the library as an imaginary library instead of using any real-life calendar component library. This allows us to focus on the general problem itself rather than the specific library’s implementation details.</p>
<p>We will look at some real-life UI libraries afterward.</p>
<p>To decide <a id="_idIndexMarker222"/>where the calendar component will be added to the DOM, component libraries usually require us to specify a container element to house the library component.</p>
<p>For example, here, <code>ImaginaryCalendar</code> requires us to pass the container element as part of the argument for the constructor:</p>
<pre class="source-code">
new ImaginaryCalendar({ container: containerElement })</pre> <p>To get the reference to an element in Svelte, we can use <code>bind:this</code>:</p>
<pre class="source-code">
&lt;script&gt;
  let containerElement;
&lt;/script&gt;
&lt;div bind:this={containerElement} /&gt;</pre> <p>The <code>containerElement</code> variable is only updated with the reference of the element after the element is mounted, so it can only be referred to in <code>onMount</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let containerElement;
  let calendar;
  onMount(() =&gt; {
    calendar = new ImaginaryCalendar({ container: containerElement });
    return () =&gt; calendar.cleanup();
  });
&lt;/script&gt;</pre> <p>Note that we are keeping the reference of the <code>calendar</code> instance because we can use it to call calendar methods to get or set values:</p>
<pre class="source-code">
calendar.setDate(date);</pre> <p>Also, we call <code>calendar.cleanup()</code> when the component unmounts for cleanup purposes.</p>
<p class="callout-heading">Note</p>
<p class="callout">The calendar library is just an imaginary example. However, most UI libraries will provide similar APIs or methods to retrieve or modify the component instance’s internal state and clean up when they are no longer in use.</p>
<p>We need<a id="_idIndexMarker223"/> to be extra careful when we are using the <code>calendar</code> instance here. We want to avoid referencing the <code>calendar</code> instance before it is initialized to prevent encountering a reference error as the calendar instance is only declared and initialized after <code>onMount</code>:</p>
<p>To be safe, we should check whether the <code>calendar</code> instance is defined before calling any of its methods. In the code example below, we verify if the calendar instance is defined, before calling the <code>calendar.setDate()</code> method.</p>
<pre class="source-code">
if (calendar) calendar.setDate(date).</pre> <p>The need for this extra level of cautiousness is more obvious when the calendar is conditionally created:</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let containerElement;
  let calendar;
  onMount(() =&gt; {
    if (containerElement) {
      calendar = new ImaginaryCalendar({ container: containerElement });
      return () =&gt; calendar.cleanup();
    }
  });
&lt;/script&gt;
{#if someCondition}
  &lt;div bind:this={containerElement} /&gt;
{/if}</pre> <p>In the preceding code, you can see that <code>&lt;div&gt;</code> is conditionally created based on <code>someCondition</code>. That is why in <code>onMount</code>, we need to check whether <code>containerElement</code> is available before we create <code>ImaginaryCalendar</code> using <code>containerElement</code> as a container. And the <code>calendar</code> instance is only available if <code>ImaginaryCalendar</code> is created, and thus only available if <code>someCondition</code> is <code>true</code>.</p>
<p>The preceding code illustrates one of the many possibilities where the <code>calendar</code> instance could be undefined.</p>
<p>One thing to note about this code is that it is not behaviorally correct as it does not attempt to create <code>ImaginaryCalendar</code> whenever the value of <code>someCondition</code> turns from <code>false</code> to <code>true</code> and does cleanup whenever it turns back to <code>false</code>.</p>
<p>This is where Svelte actions shine.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>Using Svelte actions</h2>
<p>By altering the <a id="_idIndexMarker224"/>preceding code so that it uses actions, you will see that we do not need the extra check to ensure that <code>containerElement</code> is available before instantiating <code>ImaginaryCalendar</code>.</p>
<p>The following code shows how such an action could be implemented. Here, the name of our Svelte action is <code>calendar</code>:</p>
<pre class="source-code">
&lt;script&gt;
  function calendar(containerElement) {
    const calendar = new ImaginaryCalendar({ container: containerElement });
    return {
      destroy() {
        calendar.cleanup();
      }
    };
  }
&lt;/script&gt;
{#if someCondition}
  &lt;div use:calendar /&gt;
{/if}</pre> <p>This is because, when <a id="_idIndexMarker225"/>using Svelte actions, the action function will only be called with the reference of the element whenever the element is created and mounted onto the DOM.</p>
<p>When the condition changes to such that the <code>&lt;div&gt;</code> element is removed from the DOM, the <code>destroy</code> method of the action will be called to clean things up.</p>
<p>Using Svelte actions, we can now create as many <code>ImaginaryCalendar</code> instances as we want within one component by adding the action to different HTML elements:</p>
<p>To prove my point, in the code snippet below, in addition to the original <code>&lt;div&gt;</code> element you’ve seen in the previous examples, I am adding another <code>&lt;div&gt;</code> element and three more <code>&lt;div&gt;</code> elements using the <code>{#each}</code> block. I am then applying the calendar actions to all four <code>&lt;div&gt;</code> elements to create four more calendars, and we do not run into any errors for having multiple calendars at once.</p>
<pre class="source-code">
{#if someCondition}
  &lt;div use:calendar /&gt;
{/if}
&lt;!-- Look we can have as many calendars as we want --&gt;
&lt;div use:calendar /&gt;
{#each [1, 2, 3] as item}
  &lt;div use:calendar /&gt;
{/each}</pre> <p>If we <a id="_idIndexMarker226"/>were to use <code>bind:this</code> and <code>onMount</code>, we would have to repeat ourselves multiple times by declaring multiple <code>containerElement</code> variables multiple times and instantiate <code>ImaginaryCalendar</code> with each of the <code>containerElement</code> variables.</p>
<p>Now, with the <code>calendar</code> instance encapsulated within the action, how should we call the <code>calendar</code> instance method to update the <code>calendar</code> state from the outside?</p>
<p>That’s what the action data is for!</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/>Adding data to Svelte actions</h2>
<p>In the <a id="_idIndexMarker227"/>previous section, we created a <code>calendar</code> action and instantiated an <code>ImaginaryCalendar</code> instance inside that action. If we want to call an instance method of <code>ImaginaryCalendar</code> outside the <code>calendar</code> action, such as calling <code>calendar.setDate(date)</code> to set the date of the calendar, what should we do?</p>
<p>There’s no way to call <code>calendar.setDate(date)</code> outside of the <code>calendar</code> action since the <code>calendar</code> instance is defined within the <code>calendar</code> action. A workaround is to pass <code>date</code> through action data – that is, we can provide <code>date</code> as action data and call <code>calendar.setDate(date)</code> with the date passed in.</p>
<p>For example, in the following code snippet, we’re passing <code>date</code> into the <code>calendar</code> action:</p>
<pre class="source-code">
&lt;div use:calendar={date} /&gt;</pre> <p>In the <code>calendar</code> action, we call <code>calendar.setDate(date)</code> with the date passed in. In addition to that, we define an <code>update</code> method in the action, such that whenever the date that’s passed to the calendar action changes, Svelte will call <code>calendar.setDate(date)</code>:</p>
<pre class="source-code">
&lt;script&gt;
  function calendar(containerElement, date) {
    const calendar = new ImaginaryCalendar({ container: containerElement });
    <strong class="bold">calendar.setDate(date);</strong>
    return {
      <strong class="bold">update(newDate) {</strong>
        <strong class="bold">calendar.setDate(newDate);</strong>
      <strong class="bold">},</strong>
      destroy() {
        calendar.cleanup();
      }
    };
  }
&lt;/script&gt;
&lt;div use:calendar={new Date(2022, 10, 5)} /&gt;</pre> <p>Here, we <a id="_idIndexMarker228"/>can pass different dates to the different <code>calendar</code> instances:</p>
<pre class="source-code">
{#each dates as date}
  &lt;div use:calendar={date} /&gt;
{/each}</pre> <p>That’s great!</p>
<p>Now, what if you want to call a different <code>calendar</code> instance method, such as <code>calendar.setMode()</code>, whenever the mode changes?</p>
<p>You could pass both <code>date</code> and <code>mode</code> into the action:</p>
<pre class="source-code">
&lt;div use:calendar={{ date, mode }} /&gt;</pre> <p>In that case, the <code>calendar</code> action would need to handle both <code>date</code> and <code>mode</code>:</p>
<pre class="source-code">
function calendar(node, { date, mode }) {
  const calendar = new ImaginaryCalendar({ container: containerElement });
  calendar.setDate(date);
  calendar.setMode(mode);
  return {
    update({ date: newDate, mode: newMode }) {
      calendar.setDate(newDate);
      calendar.setMode(newMode);
    },
    destroy() { ... }
  };
}</pre> <p>The <code>update</code> method <a id="_idIndexMarker229"/>of the <code>calendar</code> action will be called whenever either <code>date</code> or <code>mode</code> changes. This means that in the preceding code, we are calling both <code>calendar.setDate()</code> and <code>calendar.setMode()</code> whenever either <code>date</code> or <code>mode</code> changes. This may not have any apparent consequences, but we may be doing an unnecessary job.</p>
<p>A workaround for this is to keep track and always check whether <code>date</code> or <code>mode</code> have changed in the <code>update</code> method. This is how we can do this:</p>
<pre class="source-code">
function calendar(node, { date, mode }) {
  const calendar = new ImaginaryCalendar({ container: containerElement });
  calendar.setDate(date);
  calendar.setMode(mode);
  return {
    update({ date: newDate, mode: newMode }) {
      if (date !== newDate) {
        calendar.setDate(newDate);
        date = newDate;
      }
      if (mode !== newMode) {
        calendar.setMode(newMode);
        mode = newMode;
      }
    },
    destroy() { ... }
  };
}</pre> <p>In the <a id="_idIndexMarker230"/>preceding code, we’re checking if <code>newDate</code> is different from the current <code>date</code>, and if it is different, then we call the <code>calendar.setDate()</code> method and update our current reference of <code>date</code>. We do a similar thing for <code>mode</code>.</p>
<p>This works. However, as you can see, it is more code and more complex than what we set up when we first started creating the <code>calendar</code> action.</p>
<p>And what if you want to call a <code>calendar</code> instance method that is not tied to any data, such as <code>calendar.refreshDates()</code>?</p>
<p>This is where using actions falls short.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>An alternative to Svelte actions</h2>
<p>Remember<a id="_idIndexMarker231"/> the previous example, where we used <code>bind:this</code> and <code>onMount</code> to initialize <code>ImaginaryCalendar</code>?</p>
<p>We said that the approach is not versatile enough and falls short if we need to do the following:</p>
<ul>
<li>Conditionally render the container and create <code>ImaginaryCalendar</code></li>
<li>Have multiple calendars within the same component</li>
</ul>
<p>These drawbacks are all true, but there’s a use case in which it is perfectly fine to use <code>bind:this</code> and <code>onMount</code> to initialize <code>ImaginaryCalendar</code>. This is when the conditions we mentioned previously are never true:</p>
<ul>
<li>We do not need to conditionally render the container</li>
<li>We do not need to have multiple calendar instances within the same component (this is not exactly true, but we will come back to this)</li>
</ul>
<p>I’m not <a id="_idIndexMarker232"/>sure whether you are thinking the same thing right now but allow me to cut the suspense.</p>
<p>This is when we want to use <code>ImaginaryCalendar</code> as a Svelte component.</p>
<p>Within the <code>ImaginaryCalendar</code> Svelte component itself, we will have only one container element, and it will always be available:</p>
<pre class="source-code">
&lt;!-- ImaginaryCalendarComponent.svelte --&gt;
&lt;script&gt;
  import { onMount } from 'svelte';
  let containerElement;
  let calendar;
  onMount(() =&gt; { ... });
&lt;/script&gt;
&lt;div bind:this={containerElement} /&gt;</pre> <p>You can then use this component conditionally:</p>
<pre class="source-code">
&lt;script&gt;
  import ImaginaryCalendarComponent from './ ImaginaryCalendarComponent.svelte';
&lt;/script&gt;
{#if someCondition}
  &lt;ImaginaryCalendarComponent /&gt;
{/if}</pre> <p>Alternatively, you can use it however many times as you like:</p>
<pre class="source-code">
{#if someCondition}
  &lt;ImaginaryCalendarComponent /&gt;
{/if}
&lt;!-- Look we can have as many calendars as we want --&gt;
&lt;ImaginaryCalendarComponent /&gt;
{#each array as item}
  &lt;ImaginaryCalendarComponent /&gt;
{/each}</pre> <p>Here, we’ve <a id="_idIndexMarker233"/>swapped out elements using actions, <code>&lt;div use:calendar /&gt;</code>, with Svelte components, <code>&lt;</code><code>ImaginaryCalendarComponent /&gt;</code>.</p>
<p>This is perfectly normal.</p>
<p>In the previous chapter, we contemplated between abstracting logic through components or abstracting through actions.</p>
<p>In this scenario, we are looking at abstracting the logic of instantiating a UI library using an element as a container, and we could abstract it into a Svelte action or a Svelte component.</p>
<p>Both options are equally fine.</p>
<p>Both options are designed for this.</p>
<p>So, which options should you choose? Let’s find out.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Choosing between Svelte actions and Svelte components</h2>
<p>Here are <a id="_idIndexMarker234"/>my personal preferences when faced with a choice between either option.</p>
<p>Choose a Svelte action to integrate with a UI library when you are looking for an option that provides the following aspects:</p>
<ul>
<li>Is more lightweight. A Svelte component has slightly more overhead compared to a Svelte action.</li>
<li>Only passes zero to one data into the UI library component instance. If you were to pass in two or more pieces of data into the action, then the update method of the action will be called whenever any part of the data changes.</li>
</ul>
<p>You should <a id="_idIndexMarker235"/>choose a Svelte component if you are looking for an option that provides the following:</p>
<ul>
<li>Allows more room for optimization and finer control</li>
<li>Allows you to call UI library component instance methods directly</li>
<li>Allows you to pass in child content into the UI component library</li>
</ul>
<p>We did not discuss this much, but integrating a UI library as a component opens up the possibility of passing additional content into the UI component library through slots:</p>
<pre class="source-code">
&lt;ImaginaryCalendarComponent&gt;
  &lt;!—Customize how each cell of the calendar looks ––&gt;
  &lt;svelte:fragment sl"t="c"ll" let:date&gt;
    {date}
  &lt;/svelte:fragment&gt;
&lt;/ImaginaryCalendarComponent&gt;</pre> <p>If you are interested in learning more about slots and how to compose components in Svelte, read <a href="B18887_04.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, where we explored this topic extensively. Now that we’ve covered how we could integrate a UI library using Svelte actions, why we should use Svelte actions, as well as the alternatives and considerations, let’s take a look at a real-world example, Tippy.js.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>Example – integrating Tippy.js</h1>
<p>Tippy.js is a<a id="_idIndexMarker236"/> tooltip, popover, dropdown, and menu library.</p>
<p>I do not have any affiliation with the Tippy.js library, and the reason I chose Tippy.js as an example is purely by chance. Nonetheless, Tippy.js has a nice and simple API, making it a good candidate for an example.</p>
<p>First, let’s<a id="_idIndexMarker237"/> look at the Tippy.js documentation: <a href="https://atomiks.github.io/tippyjs/">https://atomiks.github.io/tippyjs/</a>.</p>
<p>After <a id="_idIndexMarker238"/>installing the <code>tippy.js</code> library using a package manager of our choice, we can then import Tippy.js into our code:</p>
<pre class="source-code">
import tippy from 'tippy.js';
import 'tippy.js/dist/tippy.css';</pre> <p>Now, we can initialize <code>tippy</code> with the following constructor function:</p>
<pre class="source-code">
tippy('#id');
tippy(document.getElementById('my-element'));</pre> <p>Here, we pass in the element where Tippy.js should provide a tooltip.</p>
<p>You can specify any customizations of the tooltip's content through the data attributes of the element, which Tippy.js will pick up as it initializes:</p>
<pre class="source-code">
&lt;button data-tippy-content="hello" /&gt;</pre> <p>Alternatively, you can pass this in the constructor:</p>
<pre class="source-code">
tippy(element, { content: 'hello' });</pre> <p>To update the content after initialization, call the Tippy.js <code>setContent</code> method:</p>
<pre class="source-code">
tooltipInstance.setContent("bye");</pre> <p>To permanently destroy and clean up the tooltip instance, Tippy.js provides the <code>destroy</code> method:</p>
<pre class="source-code">
tooltipInstance.destroy();</pre> <p>Here, we have all we need to create a <code>tippy</code> action. We have methods to do the following:</p>
<ul>
<li>Create the <code>tippy</code> tooltip – <code>tippy(…)</code></li>
<li>Clean up the <code>tippy</code> tooltip – <code>tooltipInstance.destroy()</code></li>
<li>Update the <code>tippy</code> tooltip – <code>tooltipInstance.setContent(…)</code></li>
</ul>
<p>Let’s take a look at what the <code>tippy</code> action should look like.</p>
<p>Here is how I want it to look:</p>
<pre class="source-code">
&lt;div use:tippy={tooltipContent} /&gt;</pre> <p>In the <a id="_idIndexMarker239"/>preceding code snippet, we applied our <code>tippy</code> action to a <code>&lt;div&gt;</code> element. The content within the tooltip created by Tippy.js should be passed into the <code>tippy</code> action as action data, represented by the <code>tooltipContent</code> variable. Whenever <code>tooltipContent</code> changes, the action should react to it and update the tooltip.</p>
<p>So, let’s write our <code>tippy</code> Svelte action. Here’s the scaffolding for an action:</p>
<pre class="source-code">
function tippy(element, content) {
  // TODO #1: initialize the library
  return {
    update(newContent) {
      // TODO #2: do something when action data changes
    },
    destroy() {
      // TODO #3: clean up
    }
  };
}</pre> <p>As you can see, we created the <code>tippy</code> action based on the Svelte action contract: a function that returns an object with <code>destroy</code> and <code>update</code> methods.</p>
<p>I left three TODOs in the code, each marking different stages of Svelte actions. Let’s go through each one and fill them up. The first <code>TODO</code> is where the action will be called after the element is created and mounted onto the DOM. Here, we are given the element the action is applied to and the action data, and we should use it to initialize the Tippy.js tooltip:</p>
<pre class="source-code">
// TODO #1: initialize the library
const tooltipInstance = tippy(element, { content });</pre> <p>The<a id="_idIndexMarker240"/> second <code>TODO</code> is inside the <code>update</code> method. This method will be called every time the action data changes. Here, we need to call the Tippy.js tooltip instance to reflect the dataset in the Svelte component:</p>
<pre class="source-code">
// TODO #2: do something when action data changes
tooltipInstance.setContent(newContent);</pre> <p>The third <code>TODO</code> is inside the <code>destroy</code> method. This method will be called after the element is removed from the DOM. Here, we need to do the cleanup on the Tippy.js tooltip instance that we created in the action:</p>
<pre class="source-code">
// TODO #3: clean up
tooltipInstance.destroy();</pre> <p>And that’s it – we now have a working <code>tippy</code> action that integrates the Tippy.js tooltip and will show a tooltip with customizable content whenever we hover over the element.</p>
<p>You can find the complete code on GitHub: <a href="https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy">https://github.com/PacktPublishing/Practical-Svelte/tree/main/Chapter06/01-tippy</a>.</p>
<p>Let’s look at one more example, through which I want to show you one more thing that you can do with actions when integrating with UI libraries.</p>
<p>The UI library we are going to look at next is CodeMirror.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor101"/>Example – integrating CodeMirror</h1>
<p>CodeMirror is <a id="_idIndexMarker241"/>a code editor component that has many great features for editing, such as syntax highlighting, code folding, and more.</p>
<p>You can find the <a id="_idIndexMarker242"/>CodeMirror documentation at <a href="https://codemirror.net/">https://codemirror.net/</a>.</p>
<p>At the time of writing, CodeMirror is currently at version 5.65.9.</p>
<p>After installing the <code>codemirror</code> library using the package manager of our choice, we can import <code>codemirror</code> into our code:</p>
<pre class="source-code">
import CodeMirror from 'codemirror';
import 'codemirror/lib/codemirror.css';</pre> <p>Now, we can initialize CodeMirror with the following constructor function:</p>
<pre class="source-code">
const myCodeMirror = CodeMirror(document.body);</pre> <p>Here, we <a id="_idIndexMarker243"/>pass in the element where we want the CodeMirror code editor to be.</p>
<p>Before I continue, at this point, note that we are looking for the same set of things from CodeMirror:</p>
<ul>
<li>Methods to initialize CodeMirror</li>
<li>Any method needed to clean up a CodeMirror instance</li>
<li>Any method to update a CodeMirror instance</li>
</ul>
<p>I am going to leave it to you to complete the checklist and figure it out.</p>
<p>However, allow me to draw your attention to one particular API from the CodeMirror instance:</p>
<pre class="source-code">
myCodeMirror.on('change', () =&gt; { ... });</pre> <p>The <code>on</code> method from CodeMirror allows the CodeMirror instance to listen to events and react to them.</p>
<p>So, if we want to add event listeners to the CodeMirror instance from outside of the action, how should we do it?</p>
<p>In the previous chapter, we saw that we could create custom events on the element using actions.</p>
<p>This means that we can allow users to listen to the <code>'change'</code> event from the element that uses the <code>codemirror</code> action:</p>
<pre class="source-code">
&lt;div use:codemirror on:change={onChangeHandler} /&gt;</pre> <p>To make this happen, you can dispatch an event from within the action:</p>
<pre class="source-code">
function codemirror(element) {
  const editor = CodeMirror(element);
  editor.on('change', () =&gt; {
    // trigger 'change' event on the element
    // whenever the editor changes
    element.dispatchEvent(new CustomEvent('change'));
  });
}</pre> <p>Remember<a id="_idIndexMarker244"/> to check whether you need to clean up or unlisten to any event in the <code>destroy</code> method so that you don’t cause any unwanted behavior.</p>
<p>And that’s it!</p>
<p>The rest of the action is left to you as an exercise.</p>
<p>You can find the complete code on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/02-codemirror</a>.</p>
<p>In this section, we learned how to integrate vanilla UI libraries into Svelte. However, not all UI libraries are implemented independently without any framework. Sometimes, the library you are looking for might be implemented in a different framework, such as React or Vue. In such cases, how can you integrate them into a Svelte application? That is what we will explore next.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor102"/>Using UI libraries written in other frameworks</h1>
<p>It is not impossible to use components from other frameworks in Svelte.</p>
<p>However, doing<a id="_idIndexMarker245"/> so will introduce the framework’s runtime and other overheads that come along with the framework. The runtime usually includes code to handle reactivity and normalize browser APIs and events. Each framework usually ships its own code for this logic and does not share it with other frameworks. The runtime for React version 18.2.0 weighs 6.4 kB when minified, which is additional code you need to include when you want to use a React component within Svelte.</p>
<p>So, this is not recommended unless it is necessary.</p>
<p>The reason this section has been included in this book is more for educational purposes and to demonstrate that this is possible, as well as what needs to be done to make it happen.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/>Creating components in various frameworks</h2>
<p>Each<a id="_idIndexMarker246"/> framework usually provides an API that takes in a container element and the framework component as the root of the application.</p>
<p>In this section, we’re going to take a look at React and Vue, the two most popular JavaScript frameworks at the time of writing.</p>
<p>For example, in React 18, we use the <code>createRoot</code> API:</p>
<pre class="source-code">
import ReactDOM from 'react-dom';
const root = ReactDOM.createRoot(container);
root.render(&lt;h1&gt;Hello, world&lt;/h1&gt;);</pre> <p>The preceding code uses the JSX syntax, which is not part of the standard JavaScript language syntax. It is syntactic sugar for <code>jsx</code>:</p>
<pre class="source-code">
import { jsx } from 'react/jsx-runtime';
const root = ReactDOM.createRoot(container)
root.render(jsx('h1', { children: 'Hello, world' }));</pre> <p>You will have to write the preceding code if you do not configure any transpiling process in your code to turn JSX syntax into valid JavaScript.</p>
<p>On the other hand, In Vue 3, there is the <code>createApp</code> API:</p>
<pre class="source-code">
import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App);
app.mount(container);</pre> <p>The Vue framework uses the word <em class="italic">application</em> in the documentation, mentioning that the <code>createApp</code> method is used to create a new application instance. The word <em class="italic">application</em> is aptly used as integrating component libraries written in other frameworks is very much like starting a new sub-application within our Svelte application.</p>
<p>You may <a id="_idIndexMarker247"/>have also started to notice the similarity between the APIs from these frameworks and other UI libraries that we’ve seen so far – all of them take in a container element so that they know where to render the content or apply changes.</p>
<p>Similar to integrating UI libraries using actions, after figuring out what APIs we can use to render a component within a container element, the next thing we must check is whether there is any API to clean up when it is no longer needed.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor104"/>Cleaning up the components in various frameworks</h2>
<p>Depending <a id="_idIndexMarker248"/>on the underlying framework of the component library, different APIs are provided to clean up whenever the component is no longer needed.</p>
<p>In React, there is a method for this called <code>unmount</code>:</p>
<pre class="source-code">
root.unmount();</pre> <p>In Vue, it is also called <code>unmount</code>:</p>
<pre class="source-code">
app.unmount();</pre> <p>The next thing we need to check is whether there is any API to pass data into our component and API so that they can be updated later.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor105"/>Updating the component in various frameworks</h2>
<p>Similar to <a id="_idIndexMarker249"/>different frameworks having different APIs for cleaning up, frameworks provide different APIs to update the component with new data.</p>
<p>If you are familiar with React, you can pass data into a React component through props:</p>
<pre class="source-code">
&lt;Component prop_name={value} /&gt;</pre> <p>This is akin to the props in a Svelte component.</p>
<p>The preceding code desugars into the following:</p>
<pre class="source-code">
jsx(Component, { prop_name: value });</pre> <p>To update the props of the component, React allows us to call <code>root.render</code> again with the same component but with a different prop value:</p>
<pre class="source-code">
root.render(jsx(App, { prop_name: 123 }));
// some time later
root.render(jsx(App, { prop_name: 456 }));</pre> <p>React <a id="_idIndexMarker250"/>will reconcile this internally and figure out how to update the DOM.</p>
<p>On the other hand, in Vue, you can pass data through props in the <code>createApp</code> API:</p>
<pre class="source-code">
const app = createApp(Component, { prop_name: value });</pre> <p>However, to the best of my knowledge, there’s no straightforward way to update the props’ value from the outside.</p>
<p>However, you could use a Vue Composition API, such as <code>ref()</code>, to create a reactive and mutable ref. With that, you could modify the ref instead of updating the props directly:</p>
<pre class="source-code">
const value = ref(123);
const app = createApp(Component, { prop_name: ref });
// some time later
value.value = 456;</pre> <p>It is okay if you are not familiar with how React and Vue work. This book is for Svelte, not for React or Vue.</p>
<p>The most important thing to take home from this is that when integrating a UI library, whether it is in vanilla JavaScript, React, or Vue, we look for three things:</p>
<ul>
<li>A method to create the component with a container element</li>
<li>A method to clean up the component instance</li>
<li>A method to pass in data and update the data</li>
</ul>
<p>If you are familiar with a framework, you will be able to figure out a way to do all these things.</p>
<p>With that out of the way, let’s take a look at a real-world example, where we will integrate a React calendar library, <code>react-calendar</code>.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Integrating react-calendar into Svelte</h1>
<p>The <code>react-calendar</code> library is <a id="_idIndexMarker251"/>a calendar component library written in React.</p>
<p>You can read more about it here: <a href="https://projects.wojtekmaj.pl/react-calendar/">https://projects.wojtekmaj.pl/react-calendar/</a>.</p>
<p>The <code>react-calendar</code> library takes in various props for customization purposes. But for demonstration <a id="_idIndexMarker252"/>purposes, we are only going to focus on two props, <code>value</code> and <code>onChange</code>, which allow us to control the selected date of the library.</p>
<p>We pass the <a id="_idIndexMarker253"/>selected date through a prop named <code>value</code>. The <code>onChange</code> prop, on the other hand, is used to pass in an event handler that will be called when the value changes from within the calendar component. We saw how we could handle event handlers in a UI library in the previous section when we discussed CodeMirror.</p>
<p>So, here is what I think using the <code>calendar</code> action would look like:</p>
<pre class="source-code">
&lt;div
  use:calendar={selectedDate}
  on:change={(event) =&gt; selectedDate = event.detail}
/&gt;</pre> <p>Here, <code>event.detail</code> is the data attached to the custom <code>'change'</code> event, which would be the date value that’s sent from the <code>react-calendar</code> component through the <code>onChange</code> props.</p>
<p>Now that we know what our <code>calendar</code> action would look like, let’s write the action out.</p>
<p>Again, here’s the scaffolding of an action:</p>
<pre class="source-code">
function calendar(element, date) {
  // TODO #1: render the react-calendar into the element
  // TODO #2: the onChange handler to dispatch a new custom event
  return {
    update(newDate) {
      // TODO #3: re-render the calendar again when there's a new date value
    },
    destroy() {
      // TODO #4: clean up
    }
  };
}</pre> <p>Here, I’ve<a id="_idIndexMarker254"/> created a basic code structure of a Svelte action and left a few TODOs within the code. The first two TODOs are to set up the <code>calendar</code> instance with the element the action is applied to. The third <code>TODO</code> is to handle when a new date is passed into the action, and the last <code>TODO</code> is to clean up when the <a id="_idIndexMarker255"/>element is removed from the DOM.</p>
<p>So, let’s fill up the TODOs.</p>
<p>For the first <code>TODO</code>, let’s create a React root and render our <code>react-calendar</code> component:</p>
<pre class="source-code">
import { jsx } from 'react/jsx-runtime';
import ReactDOM from 'react-dom';
function calendar(element, date) {
  # TODO #1: render the react-calendar into the element
  const app = ReactDOM.createRoot(element);
  app.render(jsx(Calendar, { value: date, onChange }));
  // ...
}</pre> <p>Here, we passed in <code>onChange</code>, which we have not defined yet.</p>
<p>Let’s do this now:</p>
<pre class="source-code">
# TODO #2: the onChange handler to dispatch a new custom event
function onChange(value) {
  element.dispatchEvent(
  new CustomEvent('change', { detail: value })
  );
}</pre> <p>In the<a id="_idIndexMarker256"/> preceding code snippet, whenever <code>onChange</code> is called, we<a id="_idIndexMarker257"/> will dispatch a new custom event, with <code>value</code> passed in as the detail for the custom event.</p>
<p>The third <code>TODO</code> is the content for the <code>update</code> method. Whenever a new date value is passed in from the action, we will re-render the <code>Calendar</code> component again:</p>
<pre class="source-code">
// TODO #3: re-render the calendar again when there's a new date value
app.render(jsx(Calendar, { value: newDate, onChange }));</pre> <p>In the last <code>TODO</code>, in the <code>destroy</code> method, we unmount our <code>Calendar</code> component:</p>
<pre class="source-code">
// TODO #4: clean up
app.unmount();</pre> <p>And that’s it.</p>
<p>You can find the complete code on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter06/03-react-calendar</a>.</p>
<p>With that, you’ve written a Svelte action that integrates a component library from a different framework, React, into Svelte, and you set up and updated the component’s value in a controlled manner.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Summary</h1>
<p>In this chapter, we learned how to use actions to integrate UI libraries, either written in vanilla JavaScript or any other frameworks into Svelte. We went through two real-world examples – integrating Tippy.js and <code>react-calendar</code> into Svelte using Svelte actions. In both examples, we went through a step-by-step process of writing out a Svelte action. We started by creating the structure of a Svelte action and then filled up the steps within the action for when the Svelte action is initialized as the element is created, when the data changes, and when the element is removed from the DOM. We also discussed why we choose to use Svelte actions, as well as the other alternatives and considerations when it comes to integrating UI libraries.</p>
<p>In the next chapter, we will look at the next common pattern of actions, which is to progressively enhance your elements.</p>
</div>
</div></body></html>