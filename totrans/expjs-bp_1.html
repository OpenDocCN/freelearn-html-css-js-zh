<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Building a Basic Express Site"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Building a Basic Express Site</h1></div></div></div><p>Express is<a id="id0" class="indexterm"/> a web development framework for Node.js. Node.js is an <a id="id1" class="indexterm"/>open source, cross-platform runtime environment for server-side and networking applications. It uses Google Chrome's JavaScript engine, V8, to execute code. Node.js is single-threaded and event-driven. It uses non-blocking I/O to squeeze every ounce of processing power out of the CPU. Express builds on top of Node.js, providing all of the tools necessary to develop robust web applications with node.</p><p>In addition, by utilizing Express, one gains access to a host of open source software to help solve common pain points in development. The framework is unopinionated, meaning it does not guide you one way or the other in terms of implementation or interface. Because it is unopinionated, the developer has more control and can use the framework to accomplish nearly any task; however, the power Express offers is easily abused. In this book, you will learn how to use the framework in the right way by exploring the following different styles of an application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up Express for a static site</li><li class="listitem" style="list-style-type: disc">Local user authentication</li><li class="listitem" style="list-style-type: disc">OAuth with passport</li><li class="listitem" style="list-style-type: disc">Profile pages</li><li class="listitem" style="list-style-type: disc">Testing</li></ul></div><div class="section" title="Setting up Express for a static site"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Setting up Express for a static site</h1></div></div></div><p>To get <a id="id2" class="indexterm"/>our feet wet, we'll first go over how to respond to basic HTTP requests. In this example, we will handle several <code class="literal">GET</code> requests, responding first with plaintext and then with static HTML. However, before we get started, you must install two essential tools: node and npm, which is the node package manager.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Navigate<a id="id3" class="indexterm"/> to <a class="ulink" href="https://nodejs.org/download/">https://nodejs.org/download/</a> to install node and npm.</p></div></div><div class="section" title="Saying Hello, World in Express"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Saying Hello, World in Express</h2></div></div></div><p>For those unfamiliar with Express, we <a id="id4" class="indexterm"/>will start with a basic example—Hello World! We'll start with an empty directory. As with any Node.js project, we will run the following code to generate our <code class="literal">package.json</code> file, which keeps track of metadata about the project, such as dependencies, scripts, licenses, and even where the code is hosted:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm init</strong></span>
</pre></div><p>The <code class="literal">package.json</code> file keeps track of all of our dependencies so that we don't have versioning issues, don't have to include dependencies with our code, and can deploy fearlessly. You will be prompted with a few questions. Choose the defaults for all except the entry point, which you should set to <code class="literal">server.js</code>.</p><p>There are many generators out there that can help you generate new Express applications, but we'll create the skeleton this time around. Let's install Express. To install a module, we use <code class="literal">npm</code> to install the package. We use the <code class="literal">--save</code> flag to tell npm to add the dependency to our <code class="literal">package.json</code> file; that way, we don't need to commit our dependencies to the source control. We can just install them based on the contents of the <code class="literal">package.json</code> file (npm makes this easy):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install --save express </strong></span>
</pre></div><p>We'll be using Express v4.4.0 throughout this book.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Warning: Express v4.x is not backwards compatible with the versions before it.</p></div></div><p>You can create a new file <code class="literal">server.js</code> as follows:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var app = express();

app.get('/', function(req, res, next) {
 res.send('Hello, World!');
});

app.listen(3000);
console.log('Express started on port 3000');</pre></div><p>This file is the entry point for our application. It is here that we generate an application, register routes, and finally listen for incoming requests on port <code class="literal">3000</code>. The <code class="literal">require('express')</code> method returns a generator of applications.</p><p>We can continually create as many applications as we want; in this case, we only created one, which we assigned to the variable <code class="literal">app</code>. Next, we register a <code class="literal">GET</code> route that listens for <code class="literal">GET</code> requests on the<a id="id5" class="indexterm"/> server root, and when requested, sends the string <code class="literal">'Hello, World'</code> to the client. Express has methods for all of the HTTP verbs, so we could have also done <code class="literal">app.post</code>, <code class="literal">app.put</code>, <code class="literal">app.delete</code>, or even <code class="literal">app.all</code>, which responds to all HTTP verbs. Finally, we start the app listening on port <code class="literal">3000</code>, then log to standard out.</p><p>It's finally time to start our server and make sure everything works as expected.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ node server.js</strong></span>
</pre></div><p>We can validate that everything is working by navigating to <code class="literal">http://localhost:3000</code> in our browser or <code class="literal">curl -v localhost:3000</code> in your terminal.</p></div><div class="section" title="Jade templating"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Jade templating</h2></div></div></div><p>We are now<a id="id6" class="indexterm"/> going to extract the HTML we send to the client into a separate template. After all, it would be quite difficult to render full HTML pages simply by using <code class="literal">res.send</code>. To accomplish this, we will use a templating language frequently in conjunction with <code class="literal">Express -- jade</code>. There are many templating languages that you can use with Express. We chose Jade because it greatly simplifies writing HTML and was created by the same developer of the Express framework.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install --save jade</strong></span>
</pre></div><p>After installing Jade, we're going to have to add the following code to <code class="literal">server.js</code>:</p><div class="informalexample"><pre class="programlisting">app.set('view engine', 'jade');
app.set('views', __dirname + '/views');

app.get('/', function(req, res, next) {
res.render('index');
});</pre></div><p>The preceding code sets the default view engine for Express—sort of like telling Express that in the future it should assume that, unless otherwise specified, templates are in the Jade templating language. Calling <code class="literal">app.set</code> sets a key value pair for Express internals. You can think of this sort of application like wide configuration. We could call <code class="literal">app.get </code>(view engine) to retrieve our set value at any time.</p><p>We also specify the folder that Express should look into to find view files. That means we should create a <code class="literal">views</code> directory in our application and add a file, <code class="literal">index.jade</code> to it. Alternatively, if you want to include many different template types, you could execute the following:</p><div class="informalexample"><pre class="programlisting">app.engine('jade', require('jade').__express);
app.engine('html', require('ejs').__express);
app.get('/html', function(req, res, next) {
res.render('index.html');
});

app.get(/'jade, function(req, res, next) {
res.render('index.jade');
});</pre></div><p>Here, we<a id="id7" class="indexterm"/> set custom template rendering based on the extension of the template we want to render. We use the Jade renderer for <code class="literal">.jade</code> extensions and the <code class="literal">ejs</code> renderer for <code class="literal">.html</code> extensions and expose both of our index files by different routes. This is useful if you choose one templating option and later want to switch to a new one in an incremental way. You can refer to the source for the most basic of templates.</p></div></div></div>
<div class="section" title="Local user authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Local user authentication</h1></div></div></div><p>The <a id="id8" class="indexterm"/>majority of applications require user accounts. Some applications only allow authentication through third parties, but not all users are interested in authenticating through third parties for privacy reasons, so it is important to include a local option. Here, we will go over best practices when implementing local user authentication in an Express app. We'll be using MongoDB to store our users and Mongoose as an ODM (Object Document Mapper). Then, we'll leverage passport to simplify the session handling and provide a unified view of authentication.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><div class="section" title="User object modeling"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>User object modeling</h2></div></div></div><p>We will<a id="id9" class="indexterm"/> leverage passportjs to handle user <a id="id10" class="indexterm"/>authentication. Passport centralizes all of the authentication logic and provides convenient ways to authenticate locally in addition to third parties, such as Twitter, Google, Github, and so on. First, install passport and the local authentication strategy as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install --save passport-local</strong></span>
</pre></div><p>In our first pass, we will implement a local authentication strategy, which means that users will be able to register locally for an account. We start by defining a user model using Mongoose. Mongoose provides a way to define schemas for objects that we want to store in MongoDB and then provide a convenient way to map between stored records in the database and an in-memory representation.</p><p>Mongoose <a id="id11" class="indexterm"/>also provides convenient <a id="id12" class="indexterm"/>syntax to make many MongoDB queries and perform CRUD operations on models. Our user model will only have an e-mail, password, and timestamp for now. Before getting started, we need to install Mongoose:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install --save mongoose bcrypt validator</strong></span>
</pre></div><p>Now we define the schema for our user in <code class="literal">models/user.js</code> as follows:</p><div class="informalexample"><pre class="programlisting">Var mongoose = require('mongoose');

var userSchema = new mongoose.Schema({
 email: {
   type: String,
   required: true,
   unique: true
 },
 password: {
   type: String,
   required: true
 },
 created_at: {
   type: Date,
   default: Date.now
 }
});

userSchema.pre('save', function(next) {
 if (!this.isModified('password')) {
   return next();
 }
 this.password = User.encryptPassword(this.password);
 next();
});</pre></div><p>Here, we create a schema that describes our users. Mongoose has convenient ways to describe the required and unique fields as well as the type of data that each property should hold. Mongoose does all the validations required under the hood. We don't require many user fields for our first boilerplate application—e-mail, password, and timestamp to get us started.</p><p>We also use <a id="id13" class="indexterm"/>Mongoose middleware to rehash a user's password if and when they decide to change it. Mongoose exposes several hooks to run user-defined callbacks. In our example, we define a callback to be invoked before <a id="id14" class="indexterm"/>Mongoose saves a model. That way, every time a user is saved, we'll check to see whether their password was changed.</p><p>Without this middleware, it would be possible to store a user's password in plaintext, which is not only a security vulnerability but would break authentication. Mongoose supports two kinds of middleware – serial and parallel. Parallel middleware can run asynchronous functions and gets an additional callback to invoke; you'll learn more about Mongoose middleware later in this book.</p><p>Now, we want to add validations to make sure that our data is correct. We'll use the <code class="literal">validator</code> library to accomplish this, as follows:</p><div class="informalexample"><pre class="programlisting">Var validator = require('validator');

User.schema.path('email').validate(function(email) {
 return validator.isEmail(email);
});

User.schema.path('password').validate(function(password) {
 return validator.isLength(password, 6);
});

var User = mongoose.model('User', userSchema);
module.exports = User;</pre></div><p>We added validations for e-mail and password length using a library called <code class="literal">validator</code>, which provides a lot of convenient validators for different types of fields. Validator has validations based on length, URL, int, upper case; essentially, anything you would want to validate (and don't forget to validate all user input!).</p><p>We also added a host of helper functions regarding registration, authentication, as well as encrypting passwords that you can find in <code class="literal">models/user.js</code>. We added these to the user model to help encapsulate the variety of interactions we want using the abstraction of a user.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>For more information on <a id="id15" class="indexterm"/>Mongoose, see <a class="ulink" href="http://mongoosejs.com/">http://mongoosejs.com/</a>. You can find more on <a id="id16" class="indexterm"/>passportjs at <a class="ulink" href="http://passportjs.org/">http://passportjs.org/</a>.</p></div></div><p>This lays out the beginning of a design pattern called MVC—model, view, controller. The basic idea is that you encapsulate separate concerns in different objects: the model code knows about the database, storage, and querying; the controller code knows about routing and requests/responses; and the view code knows what to render for users.</p></div><div class="section" title="Introducing Express middleware"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Introducing Express middleware</h2></div></div></div><p>Passport is <a id="id17" class="indexterm"/>authentication middleware that can be used with Express applications. Before diving into passport, we should go over<a id="id18" class="indexterm"/> Express middleware. Express is a connect framework, which means it uses the connect middleware. Connecting internally has a stack of functions that handle requests.</p><p>When a request comes in, the first function in the stack is given the request and response objects along with the <code class="literal">next()</code> function. The <code class="literal">next()</code> function when called, delegates to the next function in the middleware stack. Additionally, you can specify a path for your middleware, so it is only called for certain paths.</p><p>Express lets you add middleware to an application using the <code class="literal">app.use()</code> function. In fact, the HTTP handlers we already wrote are a special kind of middleware. Internally, Express has one level of middleware for the router, which delegates to the appropriate handler.</p><p>Middleware is extraordinarily useful for logging, serving static files, error handling, and more. In fact, passport utilizes middleware for authentication. Before anything else happens, passport looks for a cookie in the request, finds metadata, and then loads the user from the database, adds it to req, user, and then continues down the middleware stack.</p></div><div class="section" title="Setting up passport"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Setting up passport</h2></div></div></div><p>Before we<a id="id19" class="indexterm"/> can make full use of passport, we need to tell it how to do a few important things. First, we need to instruct passport how to serialize a user to a session. Then, we need to deserialize the user from the session information. Finally, we need to tell passport how to tell if a given e-mail/password combination represents a valid user as given in the following:</p><div class="informalexample"><pre class="programlisting">// passport.js
var passport = require('passport');
var LocalStrategy = require('passport-local').Strategy;
var User = require('mongoose').model('User');

passport.serializeUser(function(user, done) {
 done(null, user.id);
});

passport.deserializeUser(function(id, done) {
User.findById(id, done);
});</pre></div><p>Here, we tell <a id="id20" class="indexterm"/>passport that when we serialize a user, we only need that user's <code class="literal">id</code>. Then, when we want to deserialize a user from session data, we just look up the user by their ID! This is used in passport's middleware, after the request is finished, we take <code class="literal">req.user</code> and serialize their ID to our persistent session. When we first get a request, we take the ID stored in our session, retrieve the record from the database, and populate the request object with a <code class="literal">user</code> property. All of this functionality is provided transparently by passport, as long as we provide definitions for these two functions as given in the following:</p><div class="informalexample"><pre class="programlisting">function authFail(done) {
 done(null, false, { message: 'incorrect email/password combination' });
}

passport.use(new LocalStrategy(function(email, password, done) {
  User.findOne({
    email: email
  }, function(err, user) {
    if (err) return done(err);
    if (!user) {
      return authFail(done);
    }
    if (!user.validPassword(password)) {
      return authFail(done);
    }
    return done(null, user);
  });
}));</pre></div><p>We tell passport how to authenticate a user locally. We create a new <code class="literal">LocalStrategy()</code> function, which, when given an e-mail and password, will try to lookup a user by e-mail. We can do this because we required the e-mail field to be unique, so there should only be one user. If there is no user, we return an error. If there is a user, but they provided an invalid password, we still return an error. If there is a user and they provided the correct password, then we tell passport that the authentication request was a success by calling the <code class="literal">done</code> callback with the valid user.</p><p>In order to utilize passport, we need to add the middleware we talked about. We actually need to add a few different kinds of middleware. The great part about Express middleware is that it encourages developers to write small, focused modules so that you can bring in functionality that you want and exclude functionality that you don't need.</p><div class="informalexample"><pre class="programlisting">// server.js
var mongoose = require('mongoose');
var User = require('./models/user');
var passport = require('./passport');

mongoose.connect('mongodb://localhost/chapter01', function(err) {
 if (err) throw err;
});
…
app.use(require('cookie-parser')('my secret string'));
app.use(require('express-session')({ secret: "my other secret string" }));
app.use(require('body-parser')());
app.use(passport.initialize());
app.use(passport.session());</pre></div><p>In order to <a id="id21" class="indexterm"/>use passport, we have to enable a few things for our server. First we need to enable cookies and session support. To enable session support, we add a cookie parser. This middleware parses a cookie object into <code class="literal">req.cookies</code>. The session middleware lets us modify <code class="literal">req.session</code> and have that data persist across requests. By default, it uses cookies, but it has a variety of session stores that you can configure. Then, we have to add body-parsing middleware, which parses the body of HTTP requests into a JavaScript object <code class="literal">req.body</code>.</p><p>In our use case, we need this middleware to extract the e-mail and password fields from <code class="literal">POST</code> requests. Finally, we add the passport middleware and session support.</p></div><div class="section" title="Registering users"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Registering users</h2></div></div></div><p>Now, we <a id="id22" class="indexterm"/>add routes for registration, both a view with a basic form and backend logic to create a user. First, we will create a user controller. Up until now, we have thrown our routes in our <code class="literal">server.js</code> file, but this is generally bad practice. What we want to do is have separate controllers for each kind of route that we want. We have seen the model portion of MVC. Now it's time to take a look at controllers. Our user controller will have all the routes that manipulate the user model. Let's create a new file in a new directory, <code class="literal">controllers/user.js</code>:</p><div class="informalexample"><pre class="programlisting">// controllers/user.js
var User = require('mongoose').model('User');

module.exports.showRegistrationForm = function(req, res, next) {
  res.render('register');
};

module.exports.createUser = function(req, res, next) {
  User.register(req.body.email, req.body.password, function(err, user) {
    if (err) return next(err);
    req.login(user, function(err) {
      if (err) return next(err);
      res.redirect('/');
    });
  });  
};</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Note that the <code class="literal">User</code> model takes care of the validations and registration logic; we just provide callback. Doing this helps consolidate the error handling and generally makes the registration logic easier to understand. If the registration was successful, we call <code class="literal">req.login</code>, a function added by passport, which creates a new session for that user and that user will be available as <code class="literal">req.user</code> on subsequent requests.</p></div></div><p>Finally, we <a id="id23" class="indexterm"/>register the routes. At this point, we also extract the routes we previously added to <code class="literal">server.js</code> to their own file. Let's create a new file called <code class="literal">routes.js</code> as follows:</p><div class="informalexample"><pre class="programlisting">// routes.js
app.get('/users/register', userRoutes.showRegistrationForm);
app.post('/users/register', userRoutes.createUser);</pre></div><p>Now we have a file dedicated to associating controller handlers with actual paths that users can access. This is generally good practice because now we have a place to come visit and see all of our defined routes. It also helps unclutter our <code class="literal">server.js</code> file, which should be exclusively devoted to server configuration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>For details, as well as the registration templates used, see the preceding code.</p></div></div></div><div class="section" title="Authenticating users"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Authenticating users</h2></div></div></div><p>We <a id="id24" class="indexterm"/>have already done most of the work required to authenticate users (or rather, passport has). Really, all we need to do is set up routes for authentication and a form to allow users to enter their credentials. First, we'll add handlers to our user controller:</p><div class="informalexample"><pre class="programlisting">// controllers/user.js
module.exports.showLoginForm = function(req, res, next) {
  res.render('login');
};

module.exports.createSession = passport.authenticate('local', {
  successRedirect: '/',
  failureRedirect: '/login'
});</pre></div><p>Let's <a id="id25" class="indexterm"/>deconstruct what's happening in our login post. We create a handler that is the result of calling <code class="literal">passport.authenticate('local', …)</code>. This tells passport that the handler uses the local authentication strategy. So, when someone hits that route, passport will delegate to our LocalStrategy. If they provided a valid e-mail/password combination, our LocalStrategy will give passport the now authenticated user, and passport will redirect the user to the server root. If the e-mail/password combination was unsuccessful, passport will redirect the user to <code class="literal">/login</code> so they can try again.</p><p>Then, we will bind these callbacks to routes in <code class="literal">routes.js</code>:</p><div class="informalexample"><pre class="programlisting">app.get('/users/login', userRoutes.showLoginForm);
app.post('/users/login', userRoutes.createSession);</pre></div><p>At this point, we should be able to register an account and login with those same credentials. (see tag 0.2 for where we are right now).</p></div></div>
<div class="section" title="OAuth with passport"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>OAuth with passport</h1></div></div></div><p>Now we <a id="id26" class="indexterm"/>will add support for logging into our application using Twitter, Google, and GitHub. This functionality is useful if users don't want to register a separate account for your application. For these users, allowing OAuth through these providers will increase conversions and generally make for an easier registration process for users.</p><div class="section" title="Adding OAuth to user model"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Adding OAuth to user model</h2></div></div></div><p>Before<a id="id27" class="indexterm"/> adding OAuth, we need to keep track of several additional properties on our user model. We keep track of these properties to make sure we can look up user accounts provided there is information to ensure we don't allow <a id="id28" class="indexterm"/>duplicate accounts and allow users to link multiple third-party accounts by using the following code:</p><div class="informalexample"><pre class="programlisting">var userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
  },
  created_at: {
    type: Date,
    default: Date.now
  },
  twitter: String,
  google: String,
  github: String,
  profile: {
    name: { type: String, default: '' },
    gender: { type: String, default: '' },
    location: { type: String, default: '' },
    website: { type: String, default: '' },
    picture: { type: String, default: '' }
  },
});</pre></div><p>First, we add a property for each provider, in which we will store a unique identifier that the provider gives us when they authorize with that provider. Next, we will store an array of tokens, so we can conveniently access a list of providers that are linked to this account; this is useful if you ever want to let a user register through one and then link to others for viral marketing or extra user information. Finally, we keep track of some demographic information about the user that the providers give to us so we can provide a better experience for our users.</p></div><div class="section" title="Getting API tokens"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Getting API tokens</h2></div></div></div><p>Now, we need<a id="id29" class="indexterm"/> to go to the appropriate third parties and register our application to receive application keys and secret tokens. We will add these to our configuration. We will use separate tokens for development and production purposes (for obvious reasons!). For security reasons, we will only have our production tokens as environment variables on our final deploy server, not committed to version control.</p><p>I'll wait while<a id="id30" class="indexterm"/> you navigate to the third-party websites and add their tokens to your configuration as follows:</p><div class="informalexample"><pre class="programlisting">  // config.js
  twitter: {
    consumerKey: process.env.TWITTER_KEY || 'VRE4lt1y0W3yWTpChzJHcAaVf',
    consumerSecret: process.env.TWITTER_SECRET  ||  'TOA4rNzv9Cn8IwrOi6MOmyV894hyaJks6393V6cyLdtmFfkWqe',
    callbackURL: '/auth/twitter/callback'
  },
  google: {
    clientID: process.env.GOOGLE_ID || '627474771522-uskkhdsevat3rn15kgrqt62bdft15cpu.apps.googleusercontent.com',
    clientSecret: process.env.GOOGLE_SECRET || 'FwVkn76DKx_0BBaIAmRb6mjB',
    callbackURL: '/auth/google/callback'
  },
  github: {
    clientID: process.env.GITHUB_ID || '81b233b3394179bfe2bc',
    clientSecret: process.env.GITHUB_SECRET || 'de0322c0aa32eafaa84440ca6877ac5be9db9ca6',
    callbackURL: '/auth/github/callback'
  }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Of course, you should never commit your development keys publicly either. Be sure to either not commit this file or to use private source control. The best idea is to only have secrets live on machines ephemerally (usually as environment variables). You especially should not use the keys that I provided here!</p></div></div></div><div class="section" title="Third-party registration and login"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Third-party registration and login</h2></div></div></div><p>Now we <a id="id31" class="indexterm"/>need to install and implement the various third-party registration strategies. To install third-party registration strategies run the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install --save passport-twitter passport-google-oAuth passport-github</strong></span>
</pre></div><p>Most of these are extraordinarily similar, so I will only show the <code class="literal">TwitterStrategy</code>, as follows:</p><div class="informalexample"><pre class="programlisting">passport.use(new TwitterStrategy(config.twitter, function(req, accessToken, tokenSecret, profile, done) {
  User.findOne({ twitter: profile.id }, function(err, existingUser) {
      if (existingUser) return done(null, existingUser);
      var user = new User();
      // Twitter will not provide an email address.  Period.
      // But a person's twitter username is guaranteed to be unique
      // so we can "fake" a twitter email address as follows:
      // username@twitter.mydomain.com
user.email = profile.username + "@twitter." + config.domain + ".com";
      user.twitter = profile.id;
      user.tokens.push({ kind: 'twitter', accessToken: accessToken, tokenSecret: tokenSecret });
      user.profile.name = profile.displayName;
      user.profile.location = profile._json.location;
      user.profile.picture = profile._json.profile_image_url;
      user.save(function(err) {
        done(err, user);
      });
    });
}));</pre></div><p>Here, I<a id="id32" class="indexterm"/> included one example of how we would do this. First, we pass a new TwitterStrategy to passport. The TwitterStrategy takes our Twitter keys and callback information and a callback is used to make sure we can register the user with that information. If the user is already registered, then it's a no-op; otherwise we save their information and pass along the error and/or successfully saved user to the callback. For the others, refer to the source.</p></div></div>
<div class="section" title="Profile pages"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Profile pages</h1></div></div></div><p>It is <a id="id33" class="indexterm"/>finally time to add profile pages for each of our users. To do so, we're going to discuss more about Express routing and how to pass request-specific data to Jade templates. Often times when writing a server, you want to capture some portion of the URL to use in the controller; this could be a user id, username, or anything! We'll use Express's ability to capture URL parts to get the id of the user whose profile page was requested.</p><div class="section" title="URL params"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>URL params</h2></div></div></div><p>Express, like<a id="id34" class="indexterm"/> any good web framework, supports extracting data from URL parts. For example, you can do the following:</p><div class="informalexample"><pre class="programlisting">app.get('/users/:id', function(req, res, next) {
  console.log(req.params.id);
}</pre></div><p>In the preceding example, we will print whatever comes after <code class="literal">/users/</code> in the request URL. This allows an easy way to specify per user routes, or routes that only make sense in the context of a specific user, that is, a profile page only makes sense when you specify a specific user. We will use this kind of routing to implement our profile page. For now, we want to make sure that only the logged-in user can see their own profile page (we can change this functionality later):</p><div class="informalexample"><pre class="programlisting">app.get('/users/:id', function(req, res, next) {
  if (!req.user || (req.user.id != req.params.id)) {
    return next('Not found');
  }
  res.render('users/profile', { user: req.user.toJSON() });
});</pre></div><p>Here, we check first that the user is signed in and that the requested user's id is the same as the logged-in user's id. If it isn't, then we return an error. If it is, then we render the <code class="literal">users/profile.jade</code> template with <code class="literal">req.user</code> as the data.</p></div><div class="section" title="Profile templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Profile templates</h2></div></div></div><p>We <a id="id35" class="indexterm"/>already looked at models and controllers at length, but our templates have been underwhelming. Finally, we'll show how to write some basic Jade templates. This section will serve as a brief introduction to the Jade templating language, but does not try to be comprehensive. The code for Profile templates is as follows:</p><div class="informalexample"><pre class="programlisting">html
  body
    h1
      =user.email
    h2
      =user.created_at
    - for (var prop in user.profile)
      if user.profile[prop]
        h4
          =prop + "=" + user.profile[prop]</pre></div><p>Notably, because in the controller we passed in the user to the view, we can access the variable user and it refers to the logged-in user! We can execute arbitrary JavaScript to render into the template by prefixing it with <code class="literal">=</code> --. In these blocks, we can do anything we would normally do, including string concatenation, method invocation, and so on.</p><p>Similarly, we<a id="id36" class="indexterm"/> can include JavaScript code that is not intended to be written as HTML by prefixing it with <code class="literal">-</code> like we did with the <code class="literal">for</code> loop. This basic template prints out the user's e-mail, the <code class="literal">created_at</code> timestamp, as well as all of the properties in their profile, if any.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>For a more in-depth look at Jade, please<a id="id37" class="indexterm"/> see <a class="ulink" href="http://jade-lang.com/reference/">http://jade-lang.com/reference/</a>.</p></div></div></div></div>
<div class="section" title="Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Testing</h1></div></div></div><p>Testing is <a id="id38" class="indexterm"/>essential for any application. I will not dwell on the whys, but instead assume that you are angry with me for skipping this topic in the previous sections. Testing Express applications tend to be relatively straightforward and painless. The general format is that we make fake requests and then make certain assertions about the responses.</p><p>We could also implement finer-grained unit tests for more complex logic, but up until now almost everything we did is straightforward enough to be tested on a per route basis. Additionally, testing at the API level provides a more realistic view of how real customers will be interacting with your website and makes tests less brittle in the face of refactoring code.</p><div class="section" title="Introducing Mocha"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Introducing Mocha</h2></div></div></div><p>Mocha<a id="id39" class="indexterm"/> is a simple, flexible, test framework runner. First, I would suggest installing Mocha globally so you can easily run tests from the command line as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install --save-dev –g mocha</strong></span>
</pre></div><p>The <code class="literal">--save-dev</code> option saves <code class="literal">mocha</code> as a development dependency, meaning we don't have to install Mocha on our production servers. Mocha is just a test runner. We also need an assertion library. There are a variety of solutions, but <code class="literal">should.js</code> syntax, written by the same person as Express and Mocha, gives a clean syntax to make assertions:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install --save-dev should</strong></span>
</pre></div><p>The <code class="literal">should.js</code> syntax provides BDD assertions, such as <code class="literal">'hello'.should.equal('hello')</code> and <code class="literal">[1,2].should.have.length(2)</code>. We can start with a Hello World<a id="id40" class="indexterm"/> test example by creating a <code class="literal">test</code> directory with a single file, <code class="literal">hello-world.js</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var should = require('should');

describe('The World', function() {
  it('should say hello', function() {
    'Hello, World'.should.equal('Hello, World');
  });
  it('should say hello asynchronously!', function(done) {
    setTimeout(function() {
      'Hello, World'.should.equal('Hello, World');
      done();
    }, 300);
  });
});</pre></div><p>We have two different tests both in the same namespace, <code class="literal">The World</code>. The first test is an example of a synchronous test. Mocha executes the function we give to it, sees that no exception gets thrown and the test passes. If, instead, we accept a <code class="literal">done </code>argument in our callback, as we do in the second example, Mocha will intelligently wait until we invoke the callback before checking the validity of our test. For the most part, we will use the second version, in which we must explicitly invoke the <code class="literal">done</code> argument to finish our test because it makes more sense to test Express applications.</p><p>Now, if we go back to the command line, we should be able to run Mocha (or <code class="literal">node_modules/.bin/mocha</code> if you didn't install it globally) and see that both of the tests we wrote pass!</p></div><div class="section" title="Testing API endpoints"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Testing API endpoints</h2></div></div></div><p>Now that<a id="id41" class="indexterm"/> we have a basic understanding of how to run tests using Mocha<a id="id42" class="indexterm"/> and make assertions with <code class="literal">should</code> syntax, we can apply it to test local user registration. First, we need to introduce another <code class="literal">npm</code> module that will help us test our server programmatically and make assertions about what kind of responses we expect. The library is called <code class="literal">supertest</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install --save-dev supertest</strong></span>
</pre></div><p>The library makes testing Express applications a breeze and provides chainable assertions. Let's <a id="id43" class="indexterm"/>take<a id="id44" class="indexterm"/> a look at an example usage to test our create user route, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var should = require('should'),
    request = require('supertest'),
    app = require('../server').app,
    User = require('mongoose').model('User');

describe('Users', function() {
  before(function(done) {
    User.remove({}, done);
  });
  describe('registration', function() {
    it('should register valid user', function(done) {
      request(app)
        .post('/users/register')
        .send({
          email: "test@example.com",
          password: "hello world"
        })
        .expect(302)
        .end(function(err, res) {
          res.text.should.containEql("Redirecting to /");
          done(err);
        });
    });
  });
});</pre></div><p>First, notice that we used two namespaces: <code class="literal">Users</code> and <code class="literal">registration</code>. Now, before we run any tests, we remove all users from the database. This is useful to ensure we know where we're starting the tests This will delete all of your saved users though, so it's useful to use a different database in the test environment. Node detects the environment by looking at the <code class="literal">NODE_ENV</code> environment variable. Typically it is test, development, staging, or production. We can do so by changing the database URL in our configuration file to use a different local database when in a test environment and then run Mocha tests with <code class="literal">NODE_ENV=test mocha</code>.</p><p>Now, on to the interesting bits! Supertest exposes a chainable API to make requests and assertions about responses. To make a request, we use <code class="literal">request(app)</code>. From there, we specify the HTTP method and path. Then, we can specify a JSON body to send to the server; in this case, an example user registration form. On registration, we expect a redirect, which is a <code class="literal">302</code> response. If that assertion fails, then the <code class="literal">err</code> argument in our callback will be populated, and the test will fail when we use <code class="literal">done(err)</code>. Additionally, we validate that <a id="id45" class="indexterm"/>we were redirected to the route we expect, the server root <code class="literal">/</code>.</p></div></div>
<div class="section" title="Automate builds and deploys"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Automate builds and deploys</h1></div></div></div><p>All of this <a id="id46" class="indexterm"/>development is relatively worthless without a smooth process to build and deploy your application. Fortunately, the node community has written a <a id="id47" class="indexterm"/>variety of task runners. Among these are Grunt and Gulp, two of the most popular task runners. Both work seamlessly with Express and provide a set of utilities for us to use, including concatenating and uglifying JavaScript, compiling sass/less, and reloading the server on local file changes. We'll focus on Grunt, for simplicity.</p><div class="section" title="Introducing the Gruntfile"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Introducing the Gruntfile</h2></div></div></div><p>Grunt itself is a<a id="id48" class="indexterm"/> simple task runner, but its extensibility and plugin architecture lets you install third-party scripts to run in predefined tasks. To give us an idea of how we might use Grunt, we're going to write our <code class="literal">css</code> in <code class="literal">sass</code> and then use Grunt to compile <code class="literal">sass</code> to <code class="literal">css</code>. Through this example, we'll explore the different ideas that Grunt introduces. First, you need to install <code class="literal">cli</code> globally to install the plugin that compiles <code class="literal">sass</code> to <code class="literal">css</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install -g grunt-cli </strong></span>
<span class="strong"><strong>$ npm install --save grunt grunt-contrib-sass</strong></span>
</pre></div><p>Now we need to create <code class="literal">Gruntfile.js</code>, which contains instructions for all of the tasks and build targets that we need. To do this perform the following:</p><div class="informalexample"><pre class="programlisting">// Gruntfile.js
module.exports = function(grunt) {
  grunt.loadNpmTasks('grunt-contrib-sass');
  grunt.initConfig({
    sass: {
      dist: {
        files: [{
          expand: true,
          cwd: "public/styles",
          src: ["**.scss"],
          dest: "dist/styles",
          ext: ".css"
        }]
      }
    }
  });
  
}</pre></div><p>Let's go over the major parts. Right at the top, we require the plugin we will use, <code class="literal">grunt-contrib-sass</code>. This tells <code class="literal">grunt</code> that we are going to configure a task called <code class="literal">sass</code>. In our definition of the task <code class="literal">sass</code>, we specify a target, <code class="literal">dist</code>, which is commonly used for tasks that produce production files (minified, concatenated, and so on).</p><p>In that task, we <a id="id49" class="indexterm"/>build our file list dynamically, telling Grunt to look in <code class="literal">/public/styles/</code> recursively for all <code class="literal">.scss</code> files, then compile them all to the same paths in <code class="literal">/dist/styles</code>. It is useful to have two parallel static directories, one for development and one for production, so we don't have to look at minified code in development. We can invoke this target by executing <code class="literal">grunt sass</code> or <code class="literal">grunt sass:dist</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>It is worth noting that we don't explicitly concatenate the files in this task, but if we use <code class="literal">@imports</code> in our <code class="literal">main sass</code> file, the compiler will concatenate everything for us.</p></div></div><p>We can also configure Grunt to run our test suite. To do this, let's add another plugin -- <code class="literal">npm install --save-dev grunt-mocha-test</code>. Now we have to add the following code to our <code class="literal">Gruntfile.js</code> file:</p><div class="informalexample"><pre class="programlisting">grunt.loadNpmTasks('grunt-mocha-test');
grunt.registerTask('test', 'mochaTest');
...

  mochaTest: {
    test: {
      src: ["test/**.js"]
    }
  }</pre></div><p>Here, the task is called <code class="literal">mochaTest</code> and we register a new task called <code class="literal">test</code> that simply delegates to the <code class="literal">mochaTest</code> task. This way, it is easier to remember how to run tests. Similarly, we could have specified a list of tasks to run if we passed an array of strings as the second argument to <code class="literal">registerTask</code>. This is a sampling of what can be accomplished with Grunt. For an example of a more robust Gruntfile, check out the source.</p></div><div class="section" title="Continuous integration with Travis"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Continuous integration with Travis</h2></div></div></div><p>Travis CI <a id="id50" class="indexterm"/>provides free continuous integration for open source projects as well as paid options for closed source applications. It uses a git hook to automatically test your application after every push. This is useful to ensure no regression was introduced. Also, there could be dependency problems only revealed in CI that local development masks; Travis is the first line of defense for these bugs. It takes your source, runs npm install to install the dependencies specified in <code class="literal">package.json</code>, and then runs the npm test to run your test suite.</p><p>Travis accepts a <a id="id51" class="indexterm"/>configuration file called <code class="literal">travis.yml</code>. These typically look like this:</p><div class="informalexample"><pre class="programlisting">language: node_js
node_js:
  - "0.11"
- "0.10"
- "0.8"
services:
  - mongodb</pre></div><p>We can specify the versions of node that we want to test against as well as the services that we rely on (specifically MongoDB). Now we have to update our test command in <code class="literal">package.json</code> to run <code class="literal">grunt test</code>. Finally, we have to set up a webhook for the repository in question. We can do this on Travis by enabling the repository. Now we just have to push our changes and Travis will make sure all the tests pass! Travis is extremely flexible and you can use it to accomplish most tasks related to continuous integration, including automatically deploying successful builds.</p></div><div class="section" title="Deploying Node.js applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Deploying Node.js applications</h2></div></div></div><p>One of the <a id="id52" class="indexterm"/>easiest ways to deploy Node.js applications is to utilize <a id="id53" class="indexterm"/>Heroku, a platform as a service provider. Heroku has its own toolbelt to create and deploy Heroku apps from your machine. Before getting started with Heroku, you will need to install its toolbelt.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Please<a id="id54" class="indexterm"/> go to <a class="ulink" href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</a> to download the Heroku toolbelt.</p></div></div><p>Once installed, you can log in to Heroku or register via the web UI and then run Heroku login. Heroku uses<a id="id55" class="indexterm"/> a special file, called the Procfile, which specifies exactly how to run your application.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Our Procfile looks like this:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>web: node server.js</strong></span>
</pre></div><p>Extraordinarily simple: in order to run the web server, just run node server.js.</p></li><li class="listitem">In order to verify that our Procfile is correct, we can run the following locally:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ foreman start</strong></span>
</pre></div></li><li class="listitem">Foreman<a id="id56" class="indexterm"/> looks at the Procfile and uses that to try to start our server. Once that runs successfully, we need to create a new application and then deploy our application to Heroku. Be sure to commit the Procfile to version control:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ heroku create</strong></span>
<span class="strong"><strong>$ git push heroku master</strong></span>
</pre></div><p>Heroku will create a new application and URL in Heroku, as well as a git remote repository named heroku. Pushing that remote actually triggers a deploy of your code.</p><p>If you do all of this, unfortunately your application will not work. We don't have a Mongo instance for our application to talk to!</p></li><li class="listitem">First we have to request MongoDB from Heroku:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ heroku addons:add mongolab // don't worry, it's free</strong></span>
</pre></div><p>This spins up a shared MongoDB instance and gives our application an environment variable named <code class="literal">MONOGOLAB_URI</code>, which we should use as our MongoDB connect URI. We need to change our configuration file to reflect these changes.</p><p>In our configuration file, in production, for our database URL, we should look at the environment variable <code class="literal">MONGOLAB_URI</code>. Also, be sure that Express is listening on <code class="literal">process.env.PORT || 3000</code>, or else you will receive strange errors and/or timeouts.</p></li><li class="listitem">With all of that set up, we can commit our changes and push the changes once again to Heroku. Hopefully, this time it works! To view the application logs for debugging purposes, just use the Heroku toolbelt:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ heroku logs</strong></span>
</pre></div></li><li class="listitem">One last thing about deploying Express applications: sometimes applications crash, software isn't perfect. We should anticipate crashes and have our application respond accordingly (by restarting itself). There are many server monitoring tools, including pm2 and forever. We use forever because of its simplicity.<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ npm install --save forever</strong></span>
</pre></div></li><li class="listitem">Then, we update our Procfile to reflect our use of forever:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>// Procfile</strong></span>
<span class="strong"><strong>web: node_modules/.bin/forever server.js</strong></span>
</pre></div></li></ol></div><p>Now, forever will <a id="id57" class="indexterm"/>automatically restart our application, if it crashes for any strange reason. You can also set up Travis to automatically push successful builds to your server, but that goes beyond the deployment we will do in this book.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we got our feet wet in the world of node and using the Express framework. We went over everything from Hello World and MVC to testing and deployments. You should feel comfortable using basic Express APIs, but also feel empowered to own a <code class="literal">Node.js</code> application across the entire stack.</p><p>In the following chapters, we will build on the core ideas introduced in this chapter in order to create rich user experiences and compelling applications.</p></div></body></html>