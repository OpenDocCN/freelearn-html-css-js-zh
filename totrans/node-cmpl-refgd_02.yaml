- en: Setting up Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting started with using Node.js, you must set up your development
    environment. In the following chapters, we'll use this for development and for non-production
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install Node.js from source and prepackaged binaries on Linux, macOS,
    or Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install **Node Package Manager** (**NPM**) and some popular tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node.js module system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js and JavaScript language improvements from the ECMAScript committee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: System requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js runs on POSIX-like operating systems, various UNIX derivatives (Solaris,
    for example) or workalikes (Linux, macOS, and so on), as well as on Microsoft
    Windows. It can run on machines both large and small, including the tiny ARM devices
    such as the Raspberry Pi microscale embeddable computer for DIY software/hardware
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is now available via package management systems, limiting the need to
    compile and install from source.
  prefs: []
  type: TYPE_NORMAL
- en: Because many Node.js packages are written in C or C++, you must have a C compiler
    (such as GCC), Python 2.7 (or later), and the `node-gyp` package. If you plan
    to use encryption in your networking code, you will also need the OpenSSL cryptographic
    library. The modern UNIX derivatives almost certainly come with these, and Node.js's
    configure script, used when installing from source, will detect their presence.
    If you need to install them, Python is available at [http://python.org](http://python.org)
    and OpenSSL is available at [http://openssl.org](http://openssl.org).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js using package managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preferred method for installing Node.js, now, is to use the versions available
    in package managers, such as `apt-get`, or MacPorts. Package managers simplify
    your life by helping to maintain the current version of the software on your computer,
    ensuring to update dependent packages as necessary, all by typing a simple command
    such as `apt-get update`. Let's go over this first.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on macOS with MacPorts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MacPorts project ([http://www.macports.org/](http://www.macports.org/))
    has for years been packaging a long list of open source software packages for
    macOS, and they have packaged Node.js. After you have installed MacPorts using
    the installer on their website, installing Node.js is pretty much this simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing on macOS with Homebrew
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Homebrew is another open source software package manager for macOS, which some
    say is the perfect replacement for MacPorts. It is available through their home
    page at [http://brew.sh/](http://brew.sh/). After installing Homebrew using the
    instructions on their website and ensuring that Homebrew is correctly set up,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed this way, the Node.js command can be run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Installing on Linux, *BSD, or Windows from package management systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is now available through most of the package management systems. Instructions
    on the Node.js website currently list packaged versions of Node.js for a long
    list of Linux, as well as FreeBSD, OpenBSD, NetBSD, macOS, and even Windows. Visit
    [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Debian and other Debian-based Linux distro''s (such as Ubuntu),
    use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To download other Node.js versions (this example shows version 10.x), modify
    the URL to suit.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js in the Windows Subsystem for Linux (WSL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Windows Subsystem for Linux** (**WSL**) lets you install Ubuntu, openSUSE,
    or SUSE Linux Enterprise on Windows. All three are available via the Store built
    into Windows 10\. You may need to update your Windows for the installation to
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, the Linux-specific instructions will install Node.js within
    the Linux subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: To install the WSL, see [https://msdn.microsoft.com/en-us/commandline/wsl/install-win10](https://msdn.microsoft.com/en-us/commandline/wsl/install-win10).
  prefs: []
  type: TYPE_NORMAL
- en: Opening an administrator-privileged PowerShell on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the commands you'll run while installing tools on Windows are to be
    executed in a PowerShell window with elevated privileges. We mention this because
    the process of enabling the WSL includes a command to be run in such a PowerShell
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Start menu, enter PowerShell in the applications search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resultant menu will list PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the PowerShell entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The context menu that comes up will have an entry Run as Administrator. Click
    on that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resultant command window will have administrator privileges, and the title
    bar will say Administrator: Windows PowerShell.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Node.js distribution from nodejs.org
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [https://nodejs.org/en/](https://nodejs.org/en/) website offers built-in
    binaries for Windows, macOS, Linux, and Solaris. We can simply go to the website,
    click on the Install button, and run the installer. For systems with package managers,
    such as the ones we''ve just discussed, it''s preferable to use the package management
    system. That''s because you''ll find it easier to stay up-to-date with the latest
    version. But, that doesn''t serve all people because:'
  prefs: []
  type: TYPE_NORMAL
- en: Some will prefer to install a binary rather than deal with the package manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their chosen system doesn't have a package management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node.js implementation in their package management system is out-of-date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simply go to the Node.js website and you''ll see something like the following
    screenshot. The page does its best to determine your OS and supply the appropriate
    download. If you need something different, click on the DOWNLOADS link in the
    header for all possible downloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffdbcc7f-0d3c-4da4-8ecf-62b4826a0a24.png)'
  prefs: []
  type: TYPE_IMG
- en: For macOS, the installer is a `PKG` file giving the typical installation process.
    For Windows, the installer simply takes you through the typical Install Wizard
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Once finished with the installer, you have command-line tools, such as `node`
    and `npm`, with which you can run Node.js programs. On Windows, you're supplied
    with a version of the Windows command shell preconfigured to work nicely with
    Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Installing from source on POSIX-like systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing the prepackaged Node.js distributions is the preferred installation
    method. However, installing Node.js from source is desirable in a few situations:'
  prefs: []
  type: TYPE_NORMAL
- en: It can let you optimize the compiler settings as desired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can let you cross-compile, say, for an embedded ARM system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might need to keep multiple Node.js builds for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be working on Node.js itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have the high-level view, let's get our hands dirty mucking around
    in some build scripts. The general process follows the usual `configure`, `make`,
    and `make install` routine that you may already have performed with other open
    source software packages. If not, don't worry, we'll guide you through the process.
  prefs: []
  type: TYPE_NORMAL
- en: The official installation instructions are in the `README.md` contained within
    the source distribution at [https://github.com/nodejs/node/blob/master/README.md](https://github.com/nodejs/node/blob/master/README.md).
  prefs: []
  type: TYPE_NORMAL
- en: Installing prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three prerequisites: a C compiler, Python, and the OpenSSL libraries.
    The Node.js compilation process checks for their presence and will fail if the
    C compiler or Python is not present. The specific method of installing these is
    dependent on your operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These sorts of commands will check for their presence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See this for details: [https://github.com/nodejs/node/blob/master/BUILDING.md](https://github.com/nodejs/node/blob/master/BUILDING.md).
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js build tools do not support Python 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: Installing developer tools on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developer tools (such as GCC) are an optional installation on macOS. Fortunately,
    they're easy to acquire.
  prefs: []
  type: TYPE_NORMAL
- en: 'You start with Xcode, which is available for free through the Mac App Store.
    Simply search for Xcode and click on the Get button. Once you have Xcode installed,
    open a Terminal window and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs the Xcode command-line tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3094a2d2-ccb5-4c1b-8234-878a78d6463a.png)'
  prefs: []
  type: TYPE_IMG
- en: For additional information, visit [http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/](http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing from source for all POSIX-like systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiling Node.js from source follows this process:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the source from
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://nodejs.org/download.](http://nodejs.org/download)Configure the source
    for building using `./configure`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make`, then `make install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source bundle can be downloaded with your browser, or as follows, substituting
    your preferred version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we configure the source so that it can be built. This is just like many
    other open source packages, and there are a long list of options to customize
    the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To cause the installation to land in your home directory, run it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re going to install multiple Node.js versions side by side, it''s useful
    to put the version number in the path like this. That way, each version will sit
    in a separate directory. It''s a simple matter of switching between Node.js versions
    by changing the `PATH` variable appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A simpler way to install multiple Node.js versions is the `nvm` script described
    later.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to install Node.js in a system-wide directory, simply leave off
    the `--prefix` option and it will default to installing in `/usr/local`.
  prefs: []
  type: TYPE_NORMAL
- en: After a moment, it'll stop and will likely have successfully configured the
    source tree for installation in your chosen directory. If this doesn't succeed,
    the error messages that are printed will describe what needs to be fixed. Once
    the configure script is satisfied, you can go on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the configure script satisfied, you compile the software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are installing into a system-wide directory, do the last step this way
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you should make sure that you add the installation directory
    to your `PATH` variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for `csh` users, use this syntax to make an exported environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in some directories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Installing from source on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BUILDING.md` document referenced previously has instructions. One uses
    the build tools from Visual Studio, or else the full Visual Studio 2017 product:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017: [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build tools: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three additional tools are required:'
  prefs: []
  type: TYPE_NORMAL
- en: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python: [https://www.python.org/](https://www.python.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSSL: [https://www.openssl.org/source/](https://www.openssl.org/source/) and [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, run the included `.\vcbuild` script to perform the build.
  prefs: []
  type: TYPE_NORMAL
- en: Installing multiple Node.js instances with nvm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, you won't install multiple versions of Node.js and doing so adds complexity
    to your system. But if you are hacking on Node.js itself, or are testing your
    software against different Node.js releases, you may want to have multiple Node.js
    installations. The method to do so is a simple variation on what we've already
    discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, while discussing building Node.js from source, we noted that one can
    install multiple Node.js instances in separate directories. It's only necessary
    to build from source if you need a customized Node.js build, and most folks will
    be satisfied with pre-built Node.js binaries. They, too, can be installed into
    separate directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'To switch between Node.js versions is simply a matter of changing the `PATH`
    variable (on POSIX systems), as follows, using the directory where you installed
    Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts to be a little tedious to maintain this after a while. For each release,
    you have to set up Node.js, NPM, and any third-party modules you desire in your
    Node.js installation. Also, the command shown to change your `PATH` is not quite
    optimal. Inventive programmers have created several version managers to simplify
    managing multiple Node.js/NPM releases and providing commands to change your `PATH`
    the smart way:'
  prefs: []
  type: TYPE_NORMAL
- en: Node version manager: [https://github.com/tj/n](https://github.com/tj/n)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node version manager: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both maintain multiple simultaneous versions of Node and let you easily switch
    between versions. Installation instructions are available on their respective
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with `nvm`, you can run commands like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that you can have a system-wide Node.js installed, keep multiple
    private Node.js versions managed by `nvm`, and switch between them as needed.
    When new Node.js versions are released, they are simple to install with `nvm`
    even if the official packaged version for your OS doesn't immediately update.
  prefs: []
  type: TYPE_NORMAL
- en: Installing nvm on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfortunately, `nvm` does not support Windows. Fortunately, a couple of Windows-specific
    clones of the `nvm` concept exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marcelklehr/nodist](https://github.com/marcelklehr/nodist)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another route is to use the WSL. Because in WSL you're interacting with a Linux
    command line, you can use `nvm` itself.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the examples in this book were tested using the `nvm-windows` application.
    There are slight behavior differences, but it acts largely the same as `nvm` for
    Linux and macOS. The biggest change is the version number specifier in the `nvm
    use` and `nvm install` commands.
  prefs: []
  type: TYPE_NORMAL
- en: With `nvm` for Linux and macOS one can type a simple version number, like `nvm
    use 8`, and it will automatically substitute the latest release of the named Node.js
    version. With `nvm-windows` the same command acts as if you typed "`nvm use 8.0.0`".
    In other words, with `nvm-windows` you must use the exact version number. Fortunately,
    the list of supported versions is easily available using the "`nvm list available`"
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Native code modules and node-gyp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we won't discuss native code module development in this book, we do need
    to make sure that they can be built. Some modules in the NPM repository are native
    code, and they must be compiled with a C or C++ compiler to build the corresponding `.node` files 
    (the `.node` extension is used for binary native-code modules).
  prefs: []
  type: TYPE_NORMAL
- en: The module will often describe itself as a wrapper for some other library. For
    example, the `libxslt` and `libxmljs` modules are wrappers around the C/C++ libraries
    of the same name. The module includes the C/C++ source code, and when installed,
    a script is automatically run to do the compilation with `node-gyp`.
  prefs: []
  type: TYPE_NORMAL
- en: The `node-gyp` tool is a cross-platform command-line tool written in Node.js
    for compiling native add-on modules for Node.js. We've mentioned native code modules
    several times, and it is this tool that compiles them for use with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily see this in action by running these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is done in a temporary directory, so you can delete it afterward. If your
    system does not have the tools installed to compile native code modules, you'll
    see error messages. Otherwise, you'll see in the output a `node-gyp` execution,
    followed by many lines of text obviously related to compiling C/C++ files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `node-gyp` tool has prerequisites similar to those for compiling Node.js
    from source. Namely, a C/C++ compiler, a Python environment, and other build tools
    such as Git. For Unix/macOS/Linux systems those are easy to come by. For Windows,
    you should install:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Build Tools: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python for Windows: [https://www.python.org/](https://www.python.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, you won't need to worry about installing `node-gyp`. That's because
    it is installed behind the scenes as part of NPM. That's done so that NPM can
    automatically build native code modules.
  prefs: []
  type: TYPE_NORMAL
- en: Its GitHub repository contains documentation at [https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp).
  prefs: []
  type: TYPE_NORMAL
- en: Reading the `node-gyp` documentation, in its repository, will give you a clearer
    understanding of the compilation prerequisites discussed previously, as well as
    of developing native code modules.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js versions policy and what to use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just threw around so many different Node.js version numbers in the previous
    section that you may have become confused over which version to use. This book
    is targeting Node.js version 10.x, and it's expected that everything we'll cover
    is compatible with Node.js 10.x and any subsequent release.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Node.js 4.x, the Node.js team is following a dual-track approach.
    The even-numbered releases (4.x, 6.x, 8.x, and so on) are what they're calling
    **Long Term Support** (**LTS**), while the odd-numbered releases (5.x, 7.x, 9.x,
    and so on) are where current new feature development occurs. While the development
    branch is kept stable, the LTS releases are positioned as being for production
    use and will receive updates for several years.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Node.js 8.x is the current LTS release; Node.js 9.x
    was just released and will eventually become Node.js 10.x, which in turn will
    eventually become the LTS release. For complete details about the release schedule,
    refer to [https://github.com/nodejs/LTS/](https://github.com/nodejs/LTS/).
  prefs: []
  type: TYPE_NORMAL
- en: A major impact of each new Node.js release, beyond the usual performance improvements
    and bug fixes, is bringing in the latest V8 JavaScript engine release. In turn,
    this means bringing in more of the ES-2015/2016/2017 features as the V8 team implements
    those features. In Node.js 8.x, `async/await` functions arrived, and in Node.js
    10.x support for the standard ES6 module format has arrived.
  prefs: []
  type: TYPE_NORMAL
- en: A practical consideration is whether a new Node.js release will break your code.
    New language features are always being added as V8 catches up with ECMA Script,
    and the Node.js team sometimes makes breaking changes in the Node.js API. If you've
    tested on one Node.js version, will it work on an earlier version? Will a Node.js
    change break some assumptions we made?
  prefs: []
  type: TYPE_NORMAL
- en: The NPM Package Manager helps us ensure that our packages execute on the correct
    Node.js version. This means that we can specify in the `package.json` file, which
    we'll explore in Chapter 3, *Node.js Modules*, the compatible Node.js versions
    for a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add an entry to `package.json` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This means exactly what it implies—that the given package is compatible with
    Node.js version 6.x or later.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, your development machine(s) could have several Node.js versions installed.
    You'll need the version your software is declared to support, plus any later versions
    you wish to evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: Editors and debuggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Node.js code is JavaScript, any JavaScript-aware editor will be useful.
    Unlike some other languages that are so complex that an IDE with code completion
    is a necessity, a simple programming editor is perfectly sufficient for Node.js
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two editors are worth calling out because they are written in Node.js: Atom
    and Microsoft Visual Studio Code.'
  prefs: []
  type: TYPE_NORMAL
- en: Atom ([https://atom.io/](https://atom.io/)) bills itself as a hackable editor
    for the 21st century. It is extendable by writing Node.js modules using the Atom
    API, and the configuration files are easily editable. In other words, it's hackable
    in the same way plenty of other editors have been, going back to Emacs, meaning
    one writes a software module to add capabilities to the editor. The Electron framework
    was invented in order to build Atom, and Electron is a super easy way to build
    desktop applications using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    is also a hackable editor—well, the home page says extensible and customizable,
    which means the same thing—that is also open source, and is also implemented in
    Electron. But it's not a hollow me-too editor, aping Atom while adding nothing
    of its own.  Instead, Visual Studio Code is a solid programmers editor in its
    own right, bringing interesting functionality to the table.
  prefs: []
  type: TYPE_NORMAL
- en: As for debuggers, there are several interesting choices. Starting with Node.js
    6.3, the `inspector` protocol made it possible to use the Google Chrome debugger.
    Visual Studio Code has a built-in debugger that also uses the `inspector` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of debugging options and tools, see [https://nodejs.org/en/docs/guides/debugging-getting-started/](https://nodejs.org/en/docs/guides/debugging-getting-started/).
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've installed Node.js, we want to do two things—verify that the
    installation was successful, and familiarize you with the command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js's command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic installation of Node.js includes two commands, `node` and `npm`. We've
    already seen the `node` command in action. It's used either for running command-line
    scripts or server processes. The other, `npm`, is a package manager for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to verify that your Node.js installation works is also the
    best way to get help with Node.js. Type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are options for both Node.js and V8 (not shown in the previous
    command line). Remember that Node.js is built on top of V8; it has its own universe
    of options that largely focus on details of bytecode compilation or garbage collection
    and heap algorithms. Enter `node --v8-options` to see the full list of them.
  prefs: []
  type: TYPE_NORMAL
- en: On the command line, you can specify options, a single script file, and a list
    of arguments to that script. We'll discuss script arguments further in the next
    section, *Running a simple script with Node.js*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Node.js with no arguments plops you into an interactive JavaScript
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Any code you can write in a Node.js script can be written here. The command
    interpreter gives a good Terminal-oriented user experience and is useful for interactively
    playing with your code. You do play with your code, don't you? Good!
  prefs: []
  type: TYPE_NORMAL
- en: Running a simple script with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's see how to run scripts with Node.js. It's quite simple; let's start
    by referring to the help message shown previously. The command-line pattern is
    just a script filename and some script arguments, which should be familiar to
    anyone who has written scripts in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing Node.js scripts can be done with any text editor that deals
    with plain text files, such as VI/VIM, Emacs, Notepad++, Atom, Visual Studio Code,
    Jedit, BB Edit, TextMate, or Komodo. It's helpful if it's a programmer-oriented
    editor, if only for the syntax coloring.
  prefs: []
  type: TYPE_NORMAL
- en: For this and other examples in this book, it doesn't truly matter where you
    put the files. However, for the sake of neatness, you can start by making a directory
    named `node-web-dev` in the home directory of your computer, and inside that creating
    one directory per chapter (for example, `chap02` and `chap03`).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a text file named `ls.js` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run it by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is a pale cheap imitation of the Unix `ls` command (as if you couldn't
    figure that out from the name). The `readdir` function is a close analog to the
    Unix `readdir` system call (type `man 3 readdir` in a Terminal window to learn
    more) and is used to list the files in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: We have written this using an inline `async` function, the `await` keyword,
    and an ES2015 `for..of` loop. Using `util.promisify`, we can convert any callback-oriented
    function so it returns a Promise, so that the Promise plays well with the `await`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: By default `fs` module functions use the callback paradigm, as does most Node.js
    modules. But within `async` functions it is more convenient if functions instead
    return promises. Using `util.promisify` we can make it so.
  prefs: []
  type: TYPE_NORMAL
- en: This script is hardcoded to list files in the current directory. The real `ls`
    command takes a directory name, so let's modify the script a little.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-line arguments land in a global array named `process.argv`. Therefore
    we can modify `ls.js`, copying it as `ls2.js`, as follows to see how this array
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We simply checked if a command-line argument was present, `if (process.argv[2])`.
    If it was, we overrode the value of the `dir` variable, `dir = process.argv[2]`,
    and we then used that as the `readdir` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you give it a non-existent directory pathname, an error will be thrown and
    printed using the `catch` clause. That looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Conversion to async functions and the Promise paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section we discussed the `util.promisify` and its ability to
    convert a callback-oriented function into one that returns a Promise. The latter
    play well within async functions and therefore it is preferable for functions
    to return a Promise.
  prefs: []
  type: TYPE_NORMAL
- en: To be more precise, `util.promisify` is to be given a function that uses the
    error-first-callback paradigm. The last argument of such functions is a callback
    function whose first argument is interpreted as an error indicator, hence the
    phrase error-first-callback. What `util.promisify` returns is another function
    that returns a Promise.
  prefs: []
  type: TYPE_NORMAL
- en: The Promise serves the same purpose as the error-first-callback. If an error
    is indicated, the Promise resolves to the rejected status, while if success is
    indicated the Promise resolves to a success status. As we see in these examples,
    within an `async` function the Promise is handled very nicely.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js ecosystem has a large body of functions using the error-first-callback.
    The community has begun a conversion process where functions will return a Promise,
    and possibly also take an error-first-callback for API compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the new features in Node.js 10 is an example of such a conversion. Within
    the `fs` module is a submodule, named `fs.promises`, with the same API but producing
    Promise objects. We could rewrite the previous example as so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the functions in the `fs.promises` module returns a Promise
    without requiring a callback function. The new program, which you can save as
    `ls2-promises.js`, is run as so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The API is currently in an experimental state and therefore we're shown this
    warning.
  prefs: []
  type: TYPE_NORMAL
- en: Another choice is a 3rd party module, `fs-extra`. This module has an extended
    API beyond the standard `fs` module. On the one hand its functions return a Promise
    if no callback function is provided, or else invokes the callback. In addition
    it includes several useful functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this book we will be using `fs-extra` because of those additional
    functions. For documentation of the module, see: [https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra).
  prefs: []
  type: TYPE_NORMAL
- en: Launching a server with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many scripts that you'll run are server processes. We'll be running lots of
    these scripts later on. Since we're still in the dual mode of verifying the installation
    and familiarizing you with using Node.js, we want to run a simple HTTP server.
    Let's borrow the simple server script on the Node.js home page ([http://nodejs.org](http://nodejs.org)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `app.js` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest of web servers you can build with Node.js. If you''re
    interested in how it works, flip forward to [Chapter 4](2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml),
    *HTTP Servers and Clients*; [Chapter 5](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml),
    *Your First Express Application*; and Chapter 6, *Implementing the Mobile-First
    Paradigm*. For the moment, just visit `http://127.0.0.1:8124` in your browser
    to see the Hello, World! message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e7c2753-e616-42e7-99ac-1ecad972774c.png)'
  prefs: []
  type: TYPE_IMG
- en: A question to ponder is why this script did not exit when `ls.js` did exit.
    In both cases, execution of the script reaches the end of the script; the Node.js
    process does not exit in `app.js`, while in `ls.js` it does.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is the presence of active event listeners. Node.js always starts
    up an event loop, and in `app.js`, the `listen` function creates an event `listener`
    that implements the HTTP protocol. This event listener keeps `app.js` running
    until you do something such as typing *Ctrl* + *C* in the Terminal window. In
    `ls.js`, there is nothing that creates a long-running event listener, so when
    `ls.js` reaches the end of its script, the `node` process will exit.
  prefs: []
  type: TYPE_NORMAL
- en: NPM – the Node.js package manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js by itself is a pretty basic system, being a JavaScript interpreter with
    a few interesting asynchronous I/O libraries. One of the things that makes Node.js
    interesting is the rapidly growing ecosystem of third-party modules for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: At the center of that ecosystem is NPM. While Node.js modules can be downloaded
    as source and assembled manually for use with Node.js programs, that's tedious
    and it's difficult to implement a repeatable build process. NPM gives us a simpler
    way; NPM is the de facto standard package manager for Node.js and it greatly simplifies
    downloading and using these modules. We will talk about NPM at length in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The sharp-eyed will have noticed that `npm` is already installed via all the
    installation methods discussed previously. In the past, `npm` was installed separately,
    but today it is bundled with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `npm` installed, let''s take it for a quick spin. The **hexy** program
    is a utility for printing hex dumps of files. That''s a very 1970 thing to do,
    but is still extremely useful. It serves our purpose right now in giving us something
    to quickly install and try out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Adding the `-g` flag makes the module available globally, irrespective of the
    present-working-directory of your command shell. A global install is most useful
    when the module provides a command-line interface. When a package provides a command-line
    script, `npm` sets that up. For a global install, the command is installed correctly
    for use by all users of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on how Node.js is installed for you, that may need to be run with
    `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is installed, you''ll be able to run the newly–installed program this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Again, we'll be doing a deep dive into NPM in the next chapter. The `hexy` utility
    is both a Node.js library and a script for printing out these old-style hex dumps.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js, ECMAScript 2015/2016/2017, and beyond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2015, the ECMAScript committee released a long-awaited major update of the
    JavaScript language. The update brought in many new features to JavaScript, such
    as Promises, arrow functions, and Class objects. The language update set the stage
    for improvements. since that should dramatically improve our ability to write
    clean, understandable JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: The browser makers are adding those much-needed features, meaning the V8 engine
    is adding those features as well. These features are making their way into Node.js
    starting with version 4.x.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about the current status of ES-2015 in Node.js, visit [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/).
  prefs: []
  type: TYPE_NORMAL
- en: By default, only the ES-2015/2016/2017 features that V8 considers stable are
    enabled by Node.js. Further features can be enabled with command-line options.
    The almost-complete features are enabled with the `--es_staging` option. The website
    documentation gives more information.
  prefs: []
  type: TYPE_NORMAL
- en: The Node green website ([http://node.green/](http://node.green/)) has a table
    listing the status of a long list of features in Node.js versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ES2017 language spec is published at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: The TC-39 committee does its work on GitHub [https://github.com/tc39](https://github.com/tc39).
  prefs: []
  type: TYPE_NORMAL
- en: The ES-2015 features make a big improvement in the JavaScript language. One
    feature, the `Promise` class, should mean a fundamental rethinking of common idioms
    in Node.js programming. In ES-2017, a pair of new keywords, `async` and `await`,
    will simplify writing asynchronous code in Node.js, and it should encourage the
    Node.js community to further rethink the common idioms of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: There's a long list of new JavaScript features, but let's quickly go over two
    of them that we'll use extensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is a lighter-weight function syntax called the arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is more than the syntactic sugar of replacing the `function` keyword with
    the fat arrow. Arrow functions are lighter-weight as well as being easier to read.
    The lighter weight comes at the cost of changing the value of `this` inside the
    arrow function. In regular functions, `this` has a unique value inside the function.
    In an arrow function, `this` has the same value as the scope containing the arrow
    function. This means that, when using an arrow function, we don't have to jump
    through hoops to bring `this` into the callback function because `this` is the
    same at both levels of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next feature is the `Promise` class, which is used for deferred and asynchronous
    computations. Deferred code execution to implement asynchronous behavior is a
    key paradigm for Node.js, and it requires two idiomatic conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: The last argument to an asynchronous function is a callback function, which
    is called when an asynchronous execution is to be performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first argument to the callback function is an error indicator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While convenient, these conventions resulted in multilayer code pyramids that
    can be difficult to understand and maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Depending on how many steps are required for a specific task, a code pyramid
    can get quite deep. Promises will let us unravel the code pyramid and improve
    reliability, because error handling is more straightforward and easily captures
    all errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Promise` class is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than passing in a callback function, the caller receives a `Promise`
    object. When properly utilized, the preceding pyramid can be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This works because the `Promise` class supports chaining if a `then` function
    returns a `Promise` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `async/await` feature implements the promise of the Promise class to simplify
    asynchronous coding. This feature becomes active within an `async` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'An `async` arrow function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s used as so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Isn't this a breath of fresh air compared to the nested structure we started
    with?
  prefs: []
  type: TYPE_NORMAL
- en: The `await` keyword is used with a Promise. It automatically waits for the Promise
    to resolve. If the Promise resolves successfully then the value is returned, and
    if it resolves with an error then that error is thrown. Both handling results
    and throwing errors are handled in the natural manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example also shows another ES2015 feature: destructuring. The fields of
    an object can be extracted using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We have an object with three fields, but extract only two of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: Using Babel to use experimental JavaScript features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Babel transpiler ([http://babeljs.io/](http://babeljs.io/)) is a great way
    to use cutting-edge JavaScript features on older implementations. The word **transpile**
    means Babel rewrites JavaScript code into other JavaScript code, specifically
    to rewrite ES-2015 or ES-2016 features to older JavaScript code. Babel converts
    JavaScript source to an abstract syntax tree, then manipulates that tree to rewrite
    the code using older JavaScript features, and then writes that tree to a JavaScript
    source code file.
  prefs: []
  type: TYPE_NORMAL
- en: Put another way, Babel rewrites JavaScript code into JavaScript code, applying
    desired transformations such as converting ES2015/2016 features into ES5 code
    that can run in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Many use Babel to experiment with new JavaScript feature proposals working their
    way through the TC-39 committee. Others use Babel to use new JavaScript features
    in projects on JavaScript engines that do not support those features.
  prefs: []
  type: TYPE_NORMAL
- en: The Node Green website makes it clear that Node.js supports pretty much all
    of the ES2015/2016/2017 features. Therefore, as a practical matter, we no longer
    need to use Babel for Node.js projects.
  prefs: []
  type: TYPE_NORMAL
- en: For web browsers, there is a much longer time lag between a set of ECMAScript
    features and when we can reliably use those features in browser-side code. It's
    not that the web browser makers are slow in adopting new features, because the
    Google, Mozilla, and Microsoft teams are proactive about adopting the latest features.
    Apple's Safari team seems slow to adopt new features, unfortunately. What's slower,
    however, is the penetration of new browsers into the fleet of computers in the
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, modern JavaScript programmers need to familiarize themselves with
    Babel.
  prefs: []
  type: TYPE_NORMAL
- en: We're not ready to show example code for these features, but we can go ahead
    and document the setup of the Babel tool. For further information on setup documentation,
    visit [http://babeljs.io/docs/setup/](http://babeljs.io/docs/setup/), and then
    click on the CLI button.
  prefs: []
  type: TYPE_NORMAL
- en: To get a brief introduction to Babel, we'll use it to transpile the scripts
    we saw earlier to run on Node.js 6.x. In those scripts we used async functions,
    which are not supported in Node.js 6.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the directory containing `ls.js` and `ls2.js`, type these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This installs the Babel software, along with a couple of transformation plugins.
    Babel has a plugin system so that you enable the transformations required by your
    project. Our primary goal in this example is converting the `async` functions
    shown earlier into Generator functions. Generators are a new sort of function
    introduced with ES2015, which form the foundation for implementation of `async`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Node.js 6.x does not have `util.promisify`, we need to make one substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This structure is more or less what the `util.promisify` function does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a file named `.babelrc` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This file instructs Babel to use the named transformation plugins that we installed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we installed `babel-cli`, a `babel` command is installed such that
    we can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To transpile your code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This command transpiles the named file, producing a new file. The new file
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This code isn't meant to be easy to read by humans. Instead, it's meant that
    you edit the original source file, and then convert it for your target JavaScript
    engine. The main thing to notice is that the transpiled code uses a Generator
    function in place of the `async` function, and the `yield` keyword in place of
    the `await` keyword. The `_asyncToGenerator` function implements functionality
    similar to async functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transpiled script is run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In other words, it runs the same as the `async` version, but on an older Node.js
    release.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about installing Node.js, using its command-line
    tools, and running a Node.js server. We also breezed past a lot of details that
    will be covered later in the book, so be patient.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered downloading and compiling the Node.js source code,
    installing Node.js either for development use in your home directory or for deployment
    in system directories and installing NPM—the de facto standard package manager
    used with Node.js. We also saw how to run Node.js scripts or Node.js servers.
    We then took a look at the new features in ES-2015/2016/2017\. Finally, we saw
    how to use Babel to implement those features in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how to set up the basic system, we're ready to start working
    on implementing applications with Node.js. First, you must learn the basic building
    blocks of Node.js applications and modules, which we will cover in the next chapter.
  prefs: []
  type: TYPE_NORMAL
