- en: Setting up Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Node.js
- en: Before getting started with using Node.js, you must set up your development
    environment. In the following chapters, we'll use this for development and for non-production
    deployment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用Node.js之前，你必须设置你的开发环境。在接下来的章节中，我们将使用它进行开发和非生产部署。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to install Node.js from source and prepackaged binaries on Linux, macOS,
    or Windows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux、macOS或Windows上从源代码和预包装的二进制文件安装Node.js
- en: How to install **Node Package Manager** (**NPM**) and some popular tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装**Node包管理器**（**NPM**）和一些流行工具
- en: The Node.js module system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js模块系统
- en: Node.js and JavaScript language improvements from the ECMAScript committee
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js和JavaScript语言从ECMAScript委员会的改进
- en: So let's get on with it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧。
- en: System requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统要求
- en: Node.js runs on POSIX-like operating systems, various UNIX derivatives (Solaris,
    for example) or workalikes (Linux, macOS, and so on), as well as on Microsoft
    Windows. It can run on machines both large and small, including the tiny ARM devices
    such as the Raspberry Pi microscale embeddable computer for DIY software/hardware
    projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js运行在POSIX-like操作系统上，包括各种UNIX衍生版本（例如Solaris）或类似系统（Linux、macOS等），以及Microsoft
    Windows。它可以在大小不同的机器上运行，包括微小的ARM设备，如用于DIY软件/硬件项目的Raspberry Pi微嵌入式计算机。
- en: Node.js is now available via package management systems, limiting the need to
    compile and install from source.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js现在可以通过包管理系统获得，这减少了从源代码编译和安装的需求。
- en: Because many Node.js packages are written in C or C++, you must have a C compiler
    (such as GCC), Python 2.7 (or later), and the `node-gyp` package. If you plan
    to use encryption in your networking code, you will also need the OpenSSL cryptographic
    library. The modern UNIX derivatives almost certainly come with these, and Node.js's
    configure script, used when installing from source, will detect their presence.
    If you need to install them, Python is available at [http://python.org](http://python.org)
    and OpenSSL is available at [http://openssl.org](http://openssl.org).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多Node.js包是用C或C++编写的，你必须有一个C编译器（如GCC），Python 2.7（或更高版本）和`node-gyp`包。如果你计划在网络代码中使用加密，你还需要OpenSSL加密库。现代UNIX衍生版本几乎都包含这些，Node.js的配置脚本，在从源代码安装时使用，将检测它们的存在。如果你需要安装它们，Python可以在[http://python.org](http://python.org)获取，OpenSSL可以在[http://openssl.org](http://openssl.org)获取。
- en: Installing Node.js using package managers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包管理器安装Node.js
- en: The preferred method for installing Node.js, now, is to use the versions available
    in package managers, such as `apt-get`, or MacPorts. Package managers simplify
    your life by helping to maintain the current version of the software on your computer,
    ensuring to update dependent packages as necessary, all by typing a simple command
    such as `apt-get update`. Let's go over this first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装Node.js的首选方法是使用包管理器中可用的版本，例如`apt-get`或MacPorts。包管理器通过帮助维护计算机上软件的当前版本，确保按需更新依赖包，通过输入简单的命令（如`apt-get
    update`）来简化你的生活。让我们首先来了解一下这一点。
- en: Installing on macOS with MacPorts
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MacPorts在macOS上安装
- en: 'The MacPorts project ([http://www.macports.org/](http://www.macports.org/))
    has for years been packaging a long list of open source software packages for
    macOS, and they have packaged Node.js. After you have installed MacPorts using
    the installer on their website, installing Node.js is pretty much this simple:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MacPorts项目([http://www.macports.org/](http://www.macports.org/))多年来一直在为macOS打包大量开源软件包，他们也打包了Node.js。在你使用他们网站上的安装程序安装MacPorts之后，安装Node.js基本上是这样的简单：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing on macOS with Homebrew
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Homebrew在macOS上安装
- en: 'Homebrew is another open source software package manager for macOS, which some
    say is the perfect replacement for MacPorts. It is available through their home
    page at [http://brew.sh/](http://brew.sh/). After installing Homebrew using the
    instructions on their website and ensuring that Homebrew is correctly set up,
    use the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew是另一个适用于macOS的开源软件包管理器，有人说它是MacPorts的完美替代品。它可以通过他们的主页[http://brew.sh/](http://brew.sh/)获取。按照他们网站上的说明安装Homebrew，并确保Homebrew正确设置后，使用以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, install it this way:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式安装：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once installed this way, the Node.js command can be run as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式安装，就可以按照以下方式运行Node.js命令：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing on Linux, *BSD, or Windows from package management systems
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从包管理系统在Linux、*BSD或Windows上安装
- en: Node.js is now available through most of the package management systems. Instructions
    on the Node.js website currently list packaged versions of Node.js for a long
    list of Linux, as well as FreeBSD, OpenBSD, NetBSD, macOS, and even Windows. Visit
    [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    for more information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 现在通过大多数包管理系统提供。Node.js 网站上的说明目前列出了适用于大量 Linux、FreeBSD、OpenBSD、NetBSD、macOS
    甚至 Windows 的 Node.js 打包版本。有关更多信息，请访问 [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)。
- en: 'For example, on Debian and other Debian-based Linux distro''s (such as Ubuntu),
    use the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Debian 和其他基于 Debian 的 Linux 发行版（如 Ubuntu）上，使用以下命令：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To download other Node.js versions (this example shows version 10.x), modify
    the URL to suit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载其他 Node.js 版本（此示例显示版本 10.x），修改 URL 以适应。
- en: Installing Node.js in the Windows Subsystem for Linux (WSL)
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows Subsystem for Linux (WSL) 中安装 Node.js
- en: The **Windows Subsystem for Linux** (**WSL**) lets you install Ubuntu, openSUSE,
    or SUSE Linux Enterprise on Windows. All three are available via the Store built
    into Windows 10\. You may need to update your Windows for the installation to
    work.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows Subsystem for Linux** (**WSL**) 允许您在 Windows 上安装 Ubuntu、openSUSE
    或 SUSE Linux Enterprise。这三个都可通过 Windows 10 内置的商店获得。您可能需要更新 Windows 以使安装生效。'
- en: Once installed, the Linux-specific instructions will install Node.js within
    the Linux subsystem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，Linux 特定的说明将在 Linux 子系统中安装 Node.js。
- en: To install the WSL, see [https://msdn.microsoft.com/en-us/commandline/wsl/install-win10](https://msdn.microsoft.com/en-us/commandline/wsl/install-win10).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 WSL，请参阅 [https://msdn.microsoft.com/en-us/commandline/wsl/install-win10](https://msdn.microsoft.com/en-us/commandline/wsl/install-win10)。
- en: Opening an administrator-privileged PowerShell on Windows
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上打开具有管理员权限的 PowerShell
- en: Some of the commands you'll run while installing tools on Windows are to be
    executed in a PowerShell window with elevated privileges. We mention this because
    the process of enabling the WSL includes a command to be run in such a PowerShell
    window.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装工具时，您将运行的某些命令需要在具有提升权限的 PowerShell 窗口中执行。我们提到这一点是因为启用 WSL 的过程包括在这样一个
    PowerShell 窗口中运行的命令。
- en: 'The process is simple:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程很简单：
- en: In the Start menu, enter PowerShell in the applications search box.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始菜单中，在应用程序搜索框中输入 PowerShell。
- en: The resultant menu will list PowerShell.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果菜单将列出 PowerShell。
- en: Right-click the PowerShell entry.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 PowerShell 条目。
- en: The context menu that comes up will have an entry Run as Administrator. Click
    on that.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出的上下文菜单将有一个“以管理员身份运行”的条目。点击它。
- en: 'The resultant command window will have administrator privileges, and the title
    bar will say Administrator: Windows PowerShell.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果命令窗口将具有管理员权限，标题栏将显示为管理员：Windows PowerShell。
- en: Installing the Node.js distribution from nodejs.org
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 nodejs.org 安装 Node.js 发行版
- en: 'The [https://nodejs.org/en/](https://nodejs.org/en/) website offers built-in
    binaries for Windows, macOS, Linux, and Solaris. We can simply go to the website,
    click on the Install button, and run the installer. For systems with package managers,
    such as the ones we''ve just discussed, it''s preferable to use the package management
    system. That''s because you''ll find it easier to stay up-to-date with the latest
    version. But, that doesn''t serve all people because:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://nodejs.org/en/](https://nodejs.org/en/) 网站为 Windows、macOS、Linux 和
    Solaris 提供了内置的二进制文件。我们只需访问网站，点击安装按钮，然后运行安装程序。对于具有包管理器的系统，例如我们刚才讨论的系统，最好使用包管理系统。这是因为你会发现保持最新版本更容易。但是，这并不适用于所有人，因为：'
- en: Some will prefer to install a binary rather than deal with the package manager
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人可能更愿意安装二进制文件而不是处理包管理器
- en: Their chosen system doesn't have a package management system
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的系统没有包管理器
- en: The Node.js implementation in their package management system is out-of-date
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的包管理系统中的 Node.js 实现已过时
- en: 'Simply go to the Node.js website and you''ll see something like the following
    screenshot. The page does its best to determine your OS and supply the appropriate
    download. If you need something different, click on the DOWNLOADS link in the
    header for all possible downloads:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地访问 Node.js 网站，您会看到如下截图。页面会尽力确定您的操作系统并提供相应的下载。如果您需要其他内容，请点击页眉中的“下载”链接以获取所有可能的下载：
- en: '![](img/ffdbcc7f-0d3c-4da4-8ecf-62b4826a0a24.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffdbcc7f-0d3c-4da4-8ecf-62b4826a0a24.png)'
- en: For macOS, the installer is a `PKG` file giving the typical installation process.
    For Windows, the installer simply takes you through the typical Install Wizard
    process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Once finished with the installer, you have command-line tools, such as `node`
    and `npm`, with which you can run Node.js programs. On Windows, you're supplied
    with a version of the Windows command shell preconfigured to work nicely with
    Node.js.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Installing from source on POSIX-like systems
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing the prepackaged Node.js distributions is the preferred installation
    method. However, installing Node.js from source is desirable in a few situations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: It can let you optimize the compiler settings as desired
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can let you cross-compile, say, for an embedded ARM system
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might need to keep multiple Node.js builds for testing
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be working on Node.js itself
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have the high-level view, let's get our hands dirty mucking around
    in some build scripts. The general process follows the usual `configure`, `make`,
    and `make install` routine that you may already have performed with other open
    source software packages. If not, don't worry, we'll guide you through the process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The official installation instructions are in the `README.md` contained within
    the source distribution at [https://github.com/nodejs/node/blob/master/README.md](https://github.com/nodejs/node/blob/master/README.md).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Installing prerequisites
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three prerequisites: a C compiler, Python, and the OpenSSL libraries.
    The Node.js compilation process checks for their presence and will fail if the
    C compiler or Python is not present. The specific method of installing these is
    dependent on your operating system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'These sorts of commands will check for their presence:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See this for details: [https://github.com/nodejs/node/blob/master/BUILDING.md](https://github.com/nodejs/node/blob/master/BUILDING.md).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js build tools do not support Python 3.x.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Installing developer tools on macOS
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developer tools (such as GCC) are an optional installation on macOS. Fortunately,
    they're easy to acquire.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'You start with Xcode, which is available for free through the Mac App Store.
    Simply search for Xcode and click on the Get button. Once you have Xcode installed,
    open a Terminal window and type the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This installs the Xcode command-line tools:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3094a2d2-ccb5-4c1b-8234-878a78d6463a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: For additional information, visit [http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/](http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Installing from source for all POSIX-like systems
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiling Node.js from source follows this process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Download the source from
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://nodejs.org/download.](http://nodejs.org/download)Configure the source
    for building using `./configure`.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make`, then `make install`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source bundle can be downloaded with your browser, or as follows, substituting
    your preferred version:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we configure the source so that it can be built. This is just like many
    other open source packages, and there are a long list of options to customize
    the build:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们配置源，以便可以构建。这就像许多其他开源软件包一样，有一长串选项可以自定义构建：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To cause the installation to land in your home directory, run it this way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使安装位于你的主目录中，请按以下方式运行：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you''re going to install multiple Node.js versions side by side, it''s useful
    to put the version number in the path like this. That way, each version will sit
    in a separate directory. It''s a simple matter of switching between Node.js versions
    by changing the `PATH` variable appropriately:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算并行安装多个 Node.js 版本，将版本号放入路径中很有用，如下所示。这样，每个版本都将位于单独的目录中。通过适当地更改 `PATH` 变量，可以简单地切换
    Node.js 版本：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A simpler way to install multiple Node.js versions is the `nvm` script described
    later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装多个 Node.js 版本的更简单方法是后面描述的 `nvm` 脚本。
- en: If you want to install Node.js in a system-wide directory, simply leave off
    the `--prefix` option and it will default to installing in `/usr/local`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在系统目录中安装 Node.js，只需省略 `--prefix` 选项，它将默认安装到 `/usr/local`。
- en: After a moment, it'll stop and will likely have successfully configured the
    source tree for installation in your chosen directory. If this doesn't succeed,
    the error messages that are printed will describe what needs to be fixed. Once
    the configure script is satisfied, you can go on to the next step.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，它将停止，并且很可能已成功配置源树以在所选目录中安装。如果这没有成功，打印的错误信息将描述需要解决的问题。一旦配置脚本满意，你可以继续下一步。
- en: 'With the configure script satisfied, you compile the software:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 配置脚本满意后，编译软件：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you are installing into a system-wide directory, do the last step this way
    instead:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在系统目录中安装，请按以下方式执行最后一步：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once installed, you should make sure that you add the installation directory
    to your `PATH` variable as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你应该确保将安装目录添加到你的 `PATH` 变量中，如下所示：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, for `csh` users, use this syntax to make an exported environment
    variable:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `csh` 用户，使用以下语法来创建一个导出的环境变量：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should result in some directories, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成以下目录：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Installing from source on Windows
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上从源安装
- en: 'The `BUILDING.md` document referenced previously has instructions. One uses
    the build tools from Visual Studio, or else the full Visual Studio 2017 product:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前引用的 `BUILDING.md` 文档中有说明。一种方法是使用 Visual Studio 的构建工具，或者使用完整的 Visual Studio
    2017 产品：
- en: Visual Studio 2017: [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017: [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)
- en: Build tools: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
- en: 'Three additional tools are required:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 需要三个额外的工具：
- en: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
- en: Python: [https://www.python.org/](https://www.python.org/)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python: [https://www.python.org/](https://www.python.org/)
- en: OpenSSL: [https://www.openssl.org/source/](https://www.openssl.org/source/) and [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL: [https://www.openssl.org/source/](https://www.openssl.org/source/) 和 [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)
- en: Then, run the included `.\vcbuild` script to perform the build.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行包含的 `.\vcbuild` 脚本来执行构建。
- en: Installing multiple Node.js instances with nvm
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nvm 安装多个 Node.js 实例
- en: Normally, you won't install multiple versions of Node.js and doing so adds complexity
    to your system. But if you are hacking on Node.js itself, or are testing your
    software against different Node.js releases, you may want to have multiple Node.js
    installations. The method to do so is a simple variation on what we've already
    discussed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会安装多个 Node.js 版本，这样做会增加系统的复杂性。但是，如果你正在修改 Node.js 本身，或者正在针对不同的 Node.js 发布版测试你的软件，你可能希望拥有多个
    Node.js 安装。这样做的方法是我们已经讨论过的简单变体。
- en: Earlier, while discussing building Node.js from source, we noted that one can
    install multiple Node.js instances in separate directories. It's only necessary
    to build from source if you need a customized Node.js build, and most folks will
    be satisfied with pre-built Node.js binaries. They, too, can be installed into
    separate directories.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'To switch between Node.js versions is simply a matter of changing the `PATH`
    variable (on POSIX systems), as follows, using the directory where you installed
    Node.js:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It starts to be a little tedious to maintain this after a while. For each release,
    you have to set up Node.js, NPM, and any third-party modules you desire in your
    Node.js installation. Also, the command shown to change your `PATH` is not quite
    optimal. Inventive programmers have created several version managers to simplify
    managing multiple Node.js/NPM releases and providing commands to change your `PATH`
    the smart way:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Node version manager: [https://github.com/tj/n](https://github.com/tj/n)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node version manager: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both maintain multiple simultaneous versions of Node and let you easily switch
    between versions. Installation instructions are available on their respective
    websites.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with `nvm`, you can run commands like these:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This demonstrates that you can have a system-wide Node.js installed, keep multiple
    private Node.js versions managed by `nvm`, and switch between them as needed.
    When new Node.js versions are released, they are simple to install with `nvm`
    even if the official packaged version for your OS doesn't immediately update.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Installing nvm on Windows
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfortunately, `nvm` does not support Windows. Fortunately, a couple of Windows-specific
    clones of the `nvm` concept exist:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marcelklehr/nodist](https://github.com/marcelklehr/nodist)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another route is to use the WSL. Because in WSL you're interacting with a Linux
    command line, you can use `nvm` itself.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Many of the examples in this book were tested using the `nvm-windows` application.
    There are slight behavior differences, but it acts largely the same as `nvm` for
    Linux and macOS. The biggest change is the version number specifier in the `nvm
    use` and `nvm install` commands.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: With `nvm` for Linux and macOS one can type a simple version number, like `nvm
    use 8`, and it will automatically substitute the latest release of the named Node.js
    version. With `nvm-windows` the same command acts as if you typed "`nvm use 8.0.0`".
    In other words, with `nvm-windows` you must use the exact version number. Fortunately,
    the list of supported versions is easily available using the "`nvm list available`"
    command.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Native code modules and node-gyp
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we won't discuss native code module development in this book, we do need
    to make sure that they can be built. Some modules in the NPM repository are native
    code, and they must be compiled with a C or C++ compiler to build the corresponding `.node` files 
    (the `.node` extension is used for binary native-code modules).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The module will often describe itself as a wrapper for some other library. For
    example, the `libxslt` and `libxmljs` modules are wrappers around the C/C++ libraries
    of the same name. The module includes the C/C++ source code, and when installed,
    a script is automatically run to do the compilation with `node-gyp`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `node-gyp` tool is a cross-platform command-line tool written in Node.js
    for compiling native add-on modules for Node.js. We've mentioned native code modules
    several times, and it is this tool that compiles them for use with Node.js.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily see this in action by running these commands:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is done in a temporary directory, so you can delete it afterward. If your
    system does not have the tools installed to compile native code modules, you'll
    see error messages. Otherwise, you'll see in the output a `node-gyp` execution,
    followed by many lines of text obviously related to compiling C/C++ files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The `node-gyp` tool has prerequisites similar to those for compiling Node.js
    from source. Namely, a C/C++ compiler, a Python environment, and other build tools
    such as Git. For Unix/macOS/Linux systems those are easy to come by. For Windows,
    you should install:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Build Tools: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python for Windows: [https://www.python.org/](https://www.python.org/)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, you won't need to worry about installing `node-gyp`. That's because
    it is installed behind the scenes as part of NPM. That's done so that NPM can
    automatically build native code modules.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Its GitHub repository contains documentation at [https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Reading the `node-gyp` documentation, in its repository, will give you a clearer
    understanding of the compilation prerequisites discussed previously, as well as
    of developing native code modules.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Node.js versions policy and what to use
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just threw around so many different Node.js version numbers in the previous
    section that you may have become confused over which version to use. This book
    is targeting Node.js version 10.x, and it's expected that everything we'll cover
    is compatible with Node.js 10.x and any subsequent release.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Node.js 4.x, the Node.js team is following a dual-track approach.
    The even-numbered releases (4.x, 6.x, 8.x, and so on) are what they're calling
    **Long Term Support** (**LTS**), while the odd-numbered releases (5.x, 7.x, 9.x,
    and so on) are where current new feature development occurs. While the development
    branch is kept stable, the LTS releases are positioned as being for production
    use and will receive updates for several years.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node.js 4.x 开始，Node.js 团队采用了一种双轨方法。偶数版本的发布（4.x、6.x、8.x 等等）被称为**长期支持**（**LTS**），而奇数版本的发布（5.x、7.x、9.x
    等等）是当前新功能开发的地方。虽然开发分支保持稳定，但 LTS 发布版定位为生产使用，并将接收多年的更新。
- en: At the time of writing, Node.js 8.x is the current LTS release; Node.js 9.x
    was just released and will eventually become Node.js 10.x, which in turn will
    eventually become the LTS release. For complete details about the release schedule,
    refer to [https://github.com/nodejs/LTS/](https://github.com/nodejs/LTS/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Node.js 8.x 是当前的长期支持（LTS）版本；Node.js 9.x 刚刚发布，最终将成为 Node.js 10.x，而 Node.js
    10.x 最终将成为 LTS 版本。关于发布计划的完整详情，请参阅 [https://github.com/nodejs/LTS/](https://github.com/nodejs/LTS/)。
- en: A major impact of each new Node.js release, beyond the usual performance improvements
    and bug fixes, is bringing in the latest V8 JavaScript engine release. In turn,
    this means bringing in more of the ES-2015/2016/2017 features as the V8 team implements
    those features. In Node.js 8.x, `async/await` functions arrived, and in Node.js
    10.x support for the standard ES6 module format has arrived.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每次新的 Node.js 发布都会带来重大影响，除了通常的性能改进和错误修复之外，还会引入最新的 V8 JavaScript 引擎版本。反过来，这也意味着随着
    V8 团队实现这些功能，将引入更多的 ES-2015/2016/2017 特性。在 Node.js 8.x 中，`async/await` 函数出现，而在
    Node.js 10.x 中，对标准 ES6 模块格式的支持也出现了。
- en: A practical consideration is whether a new Node.js release will break your code.
    New language features are always being added as V8 catches up with ECMA Script,
    and the Node.js team sometimes makes breaking changes in the Node.js API. If you've
    tested on one Node.js version, will it work on an earlier version? Will a Node.js
    change break some assumptions we made?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际的考虑因素是新的 Node.js 发布是否会破坏您的代码。随着 V8 追上 ECMAScript，新的语言特性始终在添加，Node.js 团队有时会在
    Node.js API 中进行破坏性更改。如果您在一个 Node.js 版本上进行了测试，它会在更早的版本上工作吗？Node.js 的更改是否会破坏我们做出的某些假设？
- en: The NPM Package Manager helps us ensure that our packages execute on the correct
    Node.js version. This means that we can specify in the `package.json` file, which
    we'll explore in Chapter 3, *Node.js Modules*, the compatible Node.js versions
    for a package.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: NPM 包管理器帮助我们确保我们的包能够在正确的 Node.js 版本上执行。这意味着我们可以在第 3 章中将要探讨的 `package.json` 文件中指定一个包的兼容
    Node.js 版本。
- en: 'We can add an entry to `package.json` as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `package.json` 中添加如下条目：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This means exactly what it implies—that the given package is compatible with
    Node.js version 6.x or later.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它确实意味着所提供的包与 Node.js 6.x 或更高版本兼容。
- en: Of course, your development machine(s) could have several Node.js versions installed.
    You'll need the version your software is declared to support, plus any later versions
    you wish to evaluate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您的开发机器可能安装了多个 Node.js 版本。您需要您的软件声明的支持版本，以及您希望评估的任何后续版本。
- en: Editors and debuggers
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器和调试器
- en: Since Node.js code is JavaScript, any JavaScript-aware editor will be useful.
    Unlike some other languages that are so complex that an IDE with code completion
    is a necessity, a simple programming editor is perfectly sufficient for Node.js
    development.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 代码是 JavaScript，任何具有 JavaScript 意识的编辑器都将是有用的。与一些其他语言如此复杂，以至于需要一个具有代码补全功能的
    IDE 一样，一个简单的编程编辑器对于 Node.js 开发来说就足够了。
- en: 'Two editors are worth calling out because they are written in Node.js: Atom
    and Microsoft Visual Studio Code.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个编辑器值得特别提及，因为它们是用 Node.js 编写的：Atom 和 Microsoft Visual Studio Code。
- en: Atom ([https://atom.io/](https://atom.io/)) bills itself as a hackable editor
    for the 21st century. It is extendable by writing Node.js modules using the Atom
    API, and the configuration files are easily editable. In other words, it's hackable
    in the same way plenty of other editors have been, going back to Emacs, meaning
    one writes a software module to add capabilities to the editor. The Electron framework
    was invented in order to build Atom, and Electron is a super easy way to build
    desktop applications using Node.js.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    is also a hackable editor—well, the home page says extensible and customizable,
    which means the same thing—that is also open source, and is also implemented in
    Electron. But it's not a hollow me-too editor, aping Atom while adding nothing
    of its own.  Instead, Visual Studio Code is a solid programmers editor in its
    own right, bringing interesting functionality to the table.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: As for debuggers, there are several interesting choices. Starting with Node.js
    6.3, the `inspector` protocol made it possible to use the Google Chrome debugger.
    Visual Studio Code has a built-in debugger that also uses the `inspector` protocol.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of debugging options and tools, see [https://nodejs.org/en/docs/guides/debugging-getting-started/](https://nodejs.org/en/docs/guides/debugging-getting-started/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing commands
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've installed Node.js, we want to do two things—verify that the
    installation was successful, and familiarize you with the command-line tools.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Node.js's command-line tools
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic installation of Node.js includes two commands, `node` and `npm`. We've
    already seen the `node` command in action. It's used either for running command-line
    scripts or server processes. The other, `npm`, is a package manager for Node.js.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to verify that your Node.js installation works is also the
    best way to get help with Node.js. Type the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that there are options for both Node.js and V8 (not shown in the previous
    command line). Remember that Node.js is built on top of V8; it has its own universe
    of options that largely focus on details of bytecode compilation or garbage collection
    and heap algorithms. Enter `node --v8-options` to see the full list of them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: On the command line, you can specify options, a single script file, and a list
    of arguments to that script. We'll discuss script arguments further in the next
    section, *Running a simple script with Node.js*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Node.js with no arguments plops you into an interactive JavaScript
    shell:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Any code you can write in a Node.js script can be written here. The command
    interpreter gives a good Terminal-oriented user experience and is useful for interactively
    playing with your code. You do play with your code, don't you? Good!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Running a simple script with Node.js
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's see how to run scripts with Node.js. It's quite simple; let's start
    by referring to the help message shown previously. The command-line pattern is
    just a script filename and some script arguments, which should be familiar to
    anyone who has written scripts in other languages.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing Node.js scripts can be done with any text editor that deals
    with plain text files, such as VI/VIM, Emacs, Notepad++, Atom, Visual Studio Code,
    Jedit, BB Edit, TextMate, or Komodo. It's helpful if it's a programmer-oriented
    editor, if only for the syntax coloring.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: For this and other examples in this book, it doesn't truly matter where you
    put the files. However, for the sake of neatness, you can start by making a directory
    named `node-web-dev` in the home directory of your computer, and inside that creating
    one directory per chapter (for example, `chap02` and `chap03`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a text file named `ls.js` with the following content:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, run it by typing the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a pale cheap imitation of the Unix `ls` command (as if you couldn't
    figure that out from the name). The `readdir` function is a close analog to the
    Unix `readdir` system call (type `man 3 readdir` in a Terminal window to learn
    more) and is used to list the files in a directory.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: We have written this using an inline `async` function, the `await` keyword,
    and an ES2015 `for..of` loop. Using `util.promisify`, we can convert any callback-oriented
    function so it returns a Promise, so that the Promise plays well with the `await`
    keyword.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: By default `fs` module functions use the callback paradigm, as does most Node.js
    modules. But within `async` functions it is more convenient if functions instead
    return promises. Using `util.promisify` we can make it so.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: This script is hardcoded to list files in the current directory. The real `ls`
    command takes a directory name, so let's modify the script a little.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-line arguments land in a global array named `process.argv`. Therefore
    we can modify `ls.js`, copying it as `ls2.js`, as follows to see how this array
    works:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can run it as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We simply checked if a command-line argument was present, `if (process.argv[2])`.
    If it was, we overrode the value of the `dir` variable, `dir = process.argv[2]`,
    and we then used that as the `readdir` argument.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'If you give it a non-existent directory pathname, an error will be thrown and
    printed using the `catch` clause. That looks like so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Conversion to async functions and the Promise paradigm
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section we discussed the `util.promisify` and its ability to
    convert a callback-oriented function into one that returns a Promise. The latter
    play well within async functions and therefore it is preferable for functions
    to return a Promise.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: To be more precise, `util.promisify` is to be given a function that uses the
    error-first-callback paradigm. The last argument of such functions is a callback
    function whose first argument is interpreted as an error indicator, hence the
    phrase error-first-callback. What `util.promisify` returns is another function
    that returns a Promise.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The Promise serves the same purpose as the error-first-callback. If an error
    is indicated, the Promise resolves to the rejected status, while if success is
    indicated the Promise resolves to a success status. As we see in these examples,
    within an `async` function the Promise is handled very nicely.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js ecosystem has a large body of functions using the error-first-callback.
    The community has begun a conversion process where functions will return a Promise,
    and possibly also take an error-first-callback for API compatibility.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the new features in Node.js 10 is an example of such a conversion. Within
    the `fs` module is a submodule, named `fs.promises`, with the same API but producing
    Promise objects. We could rewrite the previous example as so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, the functions in the `fs.promises` module returns a Promise
    without requiring a callback function. The new program, which you can save as
    `ls2-promises.js`, is run as so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The API is currently in an experimental state and therefore we're shown this
    warning.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Another choice is a 3rd party module, `fs-extra`. This module has an extended
    API beyond the standard `fs` module. On the one hand its functions return a Promise
    if no callback function is provided, or else invokes the callback. In addition
    it includes several useful functions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this book we will be using `fs-extra` because of those additional
    functions. For documentation of the module, see: [https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Launching a server with Node.js
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many scripts that you'll run are server processes. We'll be running lots of
    these scripts later on. Since we're still in the dual mode of verifying the installation
    and familiarizing you with using Node.js, we want to run a simple HTTP server.
    Let's borrow the simple server script on the Node.js home page ([http://nodejs.org](http://nodejs.org)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `app.js` containing the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run it as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the simplest of web servers you can build with Node.js. If you''re
    interested in how it works, flip forward to [Chapter 4](2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml),
    *HTTP Servers and Clients*; [Chapter 5](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml),
    *Your First Express Application*; and Chapter 6, *Implementing the Mobile-First
    Paradigm*. For the moment, just visit `http://127.0.0.1:8124` in your browser
    to see the Hello, World! message:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e7c2753-e616-42e7-99ac-1ecad972774c.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: A question to ponder is why this script did not exit when `ls.js` did exit.
    In both cases, execution of the script reaches the end of the script; the Node.js
    process does not exit in `app.js`, while in `ls.js` it does.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The reason is the presence of active event listeners. Node.js always starts
    up an event loop, and in `app.js`, the `listen` function creates an event `listener`
    that implements the HTTP protocol. This event listener keeps `app.js` running
    until you do something such as typing *Ctrl* + *C* in the Terminal window. In
    `ls.js`, there is nothing that creates a long-running event listener, so when
    `ls.js` reaches the end of its script, the `node` process will exit.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: NPM – the Node.js package manager
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js by itself is a pretty basic system, being a JavaScript interpreter with
    a few interesting asynchronous I/O libraries. One of the things that makes Node.js
    interesting is the rapidly growing ecosystem of third-party modules for Node.js.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: At the center of that ecosystem is NPM. While Node.js modules can be downloaded
    as source and assembled manually for use with Node.js programs, that's tedious
    and it's difficult to implement a repeatable build process. NPM gives us a simpler
    way; NPM is the de facto standard package manager for Node.js and it greatly simplifies
    downloading and using these modules. We will talk about NPM at length in the next
    chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The sharp-eyed will have noticed that `npm` is already installed via all the
    installation methods discussed previously. In the past, `npm` was installed separately,
    but today it is bundled with Node.js.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `npm` installed, let''s take it for a quick spin. The **hexy** program
    is a utility for printing hex dumps of files. That''s a very 1970 thing to do,
    but is still extremely useful. It serves our purpose right now in giving us something
    to quickly install and try out:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding the `-g` flag makes the module available globally, irrespective of the
    present-working-directory of your command shell. A global install is most useful
    when the module provides a command-line interface. When a package provides a command-line
    script, `npm` sets that up. For a global install, the command is installed correctly
    for use by all users of the computer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on how Node.js is installed for you, that may need to be run with
    `sudo`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once it is installed, you''ll be able to run the newly–installed program this
    way:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Again, we'll be doing a deep dive into NPM in the next chapter. The `hexy` utility
    is both a Node.js library and a script for printing out these old-style hex dumps.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Node.js, ECMAScript 2015/2016/2017, and beyond
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2015, the ECMAScript committee released a long-awaited major update of the
    JavaScript language. The update brought in many new features to JavaScript, such
    as Promises, arrow functions, and Class objects. The language update set the stage
    for improvements. since that should dramatically improve our ability to write
    clean, understandable JavaScript code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The browser makers are adding those much-needed features, meaning the V8 engine
    is adding those features as well. These features are making their way into Node.js
    starting with version 4.x.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器制造商正在添加这些迫切需要的特性，这意味着V8引擎也在添加这些特性。这些特性从4.x版本开始进入Node.js。
- en: To learn about the current status of ES-2015 in Node.js, visit [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Node.js中ES-2015的当前状态，请访问[https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/)。
- en: By default, only the ES-2015/2016/2017 features that V8 considers stable are
    enabled by Node.js. Further features can be enabled with command-line options.
    The almost-complete features are enabled with the `--es_staging` option. The website
    documentation gives more information.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node.js只启用了V8认为稳定的ES-2015/2016/2017特性。可以通过命令行选项启用更多特性。几乎完整的特性可以通过`--es_staging`选项启用。网站文档提供了更多信息。
- en: The Node green website ([http://node.green/](http://node.green/)) has a table
    listing the status of a long list of features in Node.js versions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Node green网站([http://node.green/](http://node.green/))列出了Node.js版本中大量特性的状态。
- en: 'The ES2017 language spec is published at:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ES2017语言规范发布在：
- en: '[https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm)。'
- en: The TC-39 committee does its work on GitHub [https://github.com/tc39](https://github.com/tc39).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: TC-39委员会在GitHub上完成其工作[https://github.com/tc39](https://github.com/tc39)。
- en: The ES-2015 features make a big improvement in the JavaScript language. One
    feature, the `Promise` class, should mean a fundamental rethinking of common idioms
    in Node.js programming. In ES-2017, a pair of new keywords, `async` and `await`,
    will simplify writing asynchronous code in Node.js, and it should encourage the
    Node.js community to further rethink the common idioms of the platform.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ES-2015特性在JavaScript语言中做出了重大改进。其中一个特性，`Promise`类，应该意味着对Node.js编程中常见惯用的根本性重新思考。在ES-2017中，一对新的关键字`async`和`await`将简化Node.js中的异步代码编写，并应该鼓励Node.js社区进一步重新思考平台上的常见惯用。
- en: There's a long list of new JavaScript features, but let's quickly go over two
    of them that we'll use extensively.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多新的JavaScript特性，但让我们快速浏览其中两个我们将广泛使用的特性。
- en: 'The first is a lighter-weight function syntax called the arrow function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个更轻量级的函数语法，称为箭头函数：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is more than the syntactic sugar of replacing the `function` keyword with
    the fat arrow. Arrow functions are lighter-weight as well as being easier to read.
    The lighter weight comes at the cost of changing the value of `this` inside the
    arrow function. In regular functions, `this` has a unique value inside the function.
    In an arrow function, `this` has the same value as the scope containing the arrow
    function. This means that, when using an arrow function, we don't have to jump
    through hoops to bring `this` into the callback function because `this` is the
    same at both levels of the code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是用肥箭头替换`function`关键字这种语法糖。箭头函数不仅更轻量级，而且更容易阅读。轻量级的代价是改变箭头函数内部`this`的值。在常规函数中，`this`在函数内部有一个独特的值。在箭头函数中，`this`与包含箭头函数的作用域具有相同的值。这意味着，当使用箭头函数时，我们不需要跳过任何障碍来将`this`带入回调函数，因为`this`在代码的两个级别上都是相同的。
- en: 'The next feature is the `Promise` class, which is used for deferred and asynchronous
    computations. Deferred code execution to implement asynchronous behavior is a
    key paradigm for Node.js, and it requires two idiomatic conventions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个特性是`Promise`类，它用于延迟和异步计算。将代码执行延迟以实现异步行为是Node.js的一个关键范式，它需要两个惯用约定：
- en: The last argument to an asynchronous function is a callback function, which
    is called when an asynchronous execution is to be performed
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数的最后一个参数是一个回调函数，当需要进行异步执行时会被调用
- en: The first argument to the callback function is an error indicator
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数的第一个参数是一个错误指示器
- en: 'While convenient, these conventions resulted in multilayer code pyramids that
    can be difficult to understand and maintain:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然方便，但这些约定导致了多层代码金字塔，这可能难以理解和维护：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Depending on how many steps are required for a specific task, a code pyramid
    can get quite deep. Promises will let us unravel the code pyramid and improve
    reliability, because error handling is more straightforward and easily captures
    all errors.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定任务所需的步骤数量，代码金字塔可以变得相当深。`Promise` 将使我们解开代码金字塔并提高可靠性，因为错误处理更直接且易于捕获所有错误。
- en: 'A `Promise` class is created as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Promise` 类的方式如下：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Rather than passing in a callback function, the caller receives a `Promise`
    object. When properly utilized, the preceding pyramid can be coded as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是传递回调函数，调用者接收一个 `Promise` 对象。当正确使用时，前面的金字塔可以编码如下：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This works because the `Promise` class supports chaining if a `then` function
    returns a `Promise` object.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `Promise` 类支持链式调用，如果 `then` 函数返回一个 `Promise` 对象。
- en: 'The `async/await` feature implements the promise of the Promise class to simplify
    asynchronous coding. This feature becomes active within an `async` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`async/await` 特性实现了 `Promise` 类的承诺，以简化异步编程。此特性在 `async` 函数内激活：'
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An `async` arrow function is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 箭头函数如下：'
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It''s used as so:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Isn't this a breath of fresh air compared to the nested structure we started
    with?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们最初使用的嵌套结构相比，这难道不是一股清新的空气吗？
- en: The `await` keyword is used with a Promise. It automatically waits for the Promise
    to resolve. If the Promise resolves successfully then the value is returned, and
    if it resolves with an error then that error is thrown. Both handling results
    and throwing errors are handled in the natural manner.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 关键字与 `Promise` 一起使用。它自动等待 `Promise` 解决。如果 `Promise` 成功解决，则返回值，如果它以错误解决，则抛出该错误。处理结果和抛出错误都以自然的方式处理。'
- en: 'This example also shows another ES2015 feature: destructuring. The fields of
    an object can be extracted using the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还展示了另一个 ES2015 特性：解构。可以使用以下方式提取对象的字段：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have an object with three fields, but extract only two of the fields.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含三个字段的对象，但只提取其中的两个字段。
- en: Using Babel to use experimental JavaScript features
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Babel 来使用实验性的 JavaScript 特性
- en: The Babel transpiler ([http://babeljs.io/](http://babeljs.io/)) is a great way
    to use cutting-edge JavaScript features on older implementations. The word **transpile**
    means Babel rewrites JavaScript code into other JavaScript code, specifically
    to rewrite ES-2015 or ES-2016 features to older JavaScript code. Babel converts
    JavaScript source to an abstract syntax tree, then manipulates that tree to rewrite
    the code using older JavaScript features, and then writes that tree to a JavaScript
    source code file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 转译器（[http://babeljs.io/](http://babeljs.io/））是使用旧实现上的前沿 JavaScript 特性的绝佳方式。**转译**一词意味着
    Babel 将 JavaScript 代码重写为其他 JavaScript 代码，具体来说，是将 ES-2015 或 ES-2016 特性重写为旧 JavaScript
    代码。Babel 将 JavaScript 源代码转换为抽象语法树，然后操作该树以使用旧 JavaScript 功能重写代码，然后将该树写入 JavaScript
    源代码文件。
- en: Put another way, Babel rewrites JavaScript code into JavaScript code, applying
    desired transformations such as converting ES2015/2016 features into ES5 code
    that can run in a web browser.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Babel 将 JavaScript 代码重写为 JavaScript 代码，应用所需的转换，例如将 ES2015/2016 特性转换为可以在网页浏览器中运行的
    ES5 代码。
- en: Many use Babel to experiment with new JavaScript feature proposals working their
    way through the TC-39 committee. Others use Babel to use new JavaScript features
    in projects on JavaScript engines that do not support those features.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人使用 Babel 来尝试 TC-39 委员会正在推进的新 JavaScript 特性提案。其他人使用 Babel 在不支持这些特性的 JavaScript
    引擎的项目中使用新的 JavaScript 特性。
- en: The Node Green website makes it clear that Node.js supports pretty much all
    of the ES2015/2016/2017 features. Therefore, as a practical matter, we no longer
    need to use Babel for Node.js projects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Node Green 网站明确指出，Node.js 几乎支持所有 ES2015/2016/2017 特性。因此，从实际的角度来看，我们不再需要为 Node.js
    项目使用 Babel。
- en: For web browsers, there is a much longer time lag between a set of ECMAScript
    features and when we can reliably use those features in browser-side code. It's
    not that the web browser makers are slow in adopting new features, because the
    Google, Mozilla, and Microsoft teams are proactive about adopting the latest features.
    Apple's Safari team seems slow to adopt new features, unfortunately. What's slower,
    however, is the penetration of new browsers into the fleet of computers in the
    field.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网页浏览器来说，一组 ECMAScript 特性从提出到我们可以在浏览器端代码中可靠地使用它们之间有一个更长的时间滞后。这并不是因为网页浏览器的制造商在采用新特性方面缓慢，因为
    Google、Mozilla 和 Microsoft 团队都是积极采用最新特性的。不幸的是，苹果的 Safari 团队似乎在采用新特性方面较慢。然而，更慢的是新浏览器在现有计算机群体中的渗透率。
- en: Therefore, modern JavaScript programmers need to familiarize themselves with
    Babel.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代 JavaScript 程序员需要熟悉 Babel。
- en: We're not ready to show example code for these features, but we can go ahead
    and document the setup of the Babel tool. For further information on setup documentation,
    visit [http://babeljs.io/docs/setup/](http://babeljs.io/docs/setup/), and then
    click on the CLI button.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还没有准备好展示这些功能的示例代码，但我们可以继续记录 Babel 工具的设置。有关设置文档的更多信息，请访问 [http://babeljs.io/docs/setup/](http://babeljs.io/docs/setup/)，然后点击
    CLI 按钮。
- en: To get a brief introduction to Babel, we'll use it to transpile the scripts
    we saw earlier to run on Node.js 6.x. In those scripts we used async functions,
    which are not supported in Node.js 6.x.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简要了解 Babel，我们将使用它来转换我们之前看到的脚本，以便在 Node.js 6.x 上运行。在这些脚本中，我们使用了异步函数，这些函数在 Node.js
    6.x 中不受支持。
- en: 'In the directory containing `ls.js` and `ls2.js`, type these commands:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含 `ls.js` 和 `ls2.js` 的目录中，输入以下命令：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This installs the Babel software, along with a couple of transformation plugins.
    Babel has a plugin system so that you enable the transformations required by your
    project. Our primary goal in this example is converting the `async` functions
    shown earlier into Generator functions. Generators are a new sort of function
    introduced with ES2015, which form the foundation for implementation of `async`
    functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Babel 软件，以及一些转换插件。Babel 有一个插件系统，这样您就可以启用项目所需的转换。在这个例子中，我们的主要目标是把之前展示的 `async`
    函数转换为 Generator 函数。Generators 是 ES2015 中引入的一种新类型的函数，它是 `async` 函数实现的基础。
- en: 'Because Node.js 6.x does not have `util.promisify`, we need to make one substitution:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 6.x 没有提供 `util.promisify`，我们需要进行一项替换：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This structure is more or less what the `util.promisify` function does.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构大致就是 `util.promisify` 函数所做的事情。
- en: 'Next, create a file named `.babelrc` containing the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `.babelrc` 的文件，包含以下内容：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This file instructs Babel to use the named transformation plugins that we installed
    earlier.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件指示 Babel 使用我们之前安装的命名转换插件。
- en: 'Because we installed `babel-cli`, a `babel` command is installed such that
    we can type the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们安装了 `babel-cli`，因此安装了一个 `babel` 命令，这样我们就可以输入以下内容：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To transpile your code, run the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换您的代码，请运行以下命令：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This command transpiles the named file, producing a new file. The new file
    is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将转换指定的文件，生成一个新文件。新文件如下：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code isn't meant to be easy to read by humans. Instead, it's meant that
    you edit the original source file, and then convert it for your target JavaScript
    engine. The main thing to notice is that the transpiled code uses a Generator
    function in place of the `async` function, and the `yield` keyword in place of
    the `await` keyword. The `_asyncToGenerator` function implements functionality
    similar to async functions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不是为了让人容易阅读。相反，它是为了编辑原始源文件，然后将其转换为您的目标 JavaScript 引擎。需要注意的是，转换后的代码使用 Generator
    函数代替了 `async` 函数，并使用 `yield` 关键字代替了 `await` 关键字。`_asyncToGenerator` 函数实现了与异步函数类似的功能。
- en: 'The transpiled script is run as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的脚本如下运行：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In other words, it runs the same as the `async` version, but on an older Node.js
    release.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它运行方式与 `async` 版本相同，但是在较旧的 Node.js 版本上。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about installing Node.js, using its command-line
    tools, and running a Node.js server. We also breezed past a lot of details that
    will be covered later in the book, so be patient.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了关于安装 Node.js、使用其命令行工具以及运行 Node.js 服务器的大量知识。我们还快速浏览了许多将在本书后面章节中详细讲解的细节，所以请耐心等待。
- en: Specifically, we covered downloading and compiling the Node.js source code,
    installing Node.js either for development use in your home directory or for deployment
    in system directories and installing NPM—the de facto standard package manager
    used with Node.js. We also saw how to run Node.js scripts or Node.js servers.
    We then took a look at the new features in ES-2015/2016/2017\. Finally, we saw
    how to use Babel to implement those features in your code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了下载和编译 Node.js 源代码，安装 Node.js，无论是用于个人目录中的开发还是部署在系统目录中，以及安装 NPM——与 Node.js
    一起使用的既定标准包管理器。我们还看到了如何运行 Node.js 脚本或 Node.js 服务器。然后，我们查看了一下 ES-2015/2016/2017
    的新特性。最后，我们看到了如何使用 Babel 在你的代码中实现这些特性。
- en: Now that we've seen how to set up the basic system, we're ready to start working
    on implementing applications with Node.js. First, you must learn the basic building
    blocks of Node.js applications and modules, which we will cover in the next chapter.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何设置基本系统，我们就可以开始使用 Node.js 实现应用程序了。首先，你必须学习 Node.js 应用程序和模块的基本构建块，这些内容我们将在下一章中进行讲解。
