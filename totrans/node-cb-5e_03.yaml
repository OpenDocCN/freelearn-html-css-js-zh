- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streams are one of the key features of Node.js. Most Node.js applications rely
    on the underlying Node.js streams implementation, be it for reading/writing files,
    handling HTTP requests, or other network communications. Streams provide a mechanism
    to read input and write output sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: By reading chunks of data sequentially, we can work with very large files (or
    other data input) that would generally be too large to read into memory and process
    as a whole. Streams are fundamental to big data applications or media streaming
    services, where the data is too large to consume at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main types of streams in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readable streams** : Used for reading data, such as reading a file, or reading
    data from a request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writable streams** : Used for writing data, such as writing a file, or sending
    data to a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duplex streams** : Used for both reading and writing data, such as a TCP
    socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transform streams** : A type of duplex stream that transforms the data input,
    and then outputs the transformed data. A common example would be a compression
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will demonstrate how we can create these various types of streams,
    as well as how we can chain these types of streams together to form stream pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating readable and writable streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with paused streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Piping streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating transform streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building stream pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter will focus on the streams implementations provided
    by the Node.js core **stream** module in Node.js 22. Because of this, we will
    not use the **readable-stream** module ( [https://github.com/nodejs/readable-stream](https://github.com/nodejs/readable-stream)
    ). The **readable-stream** module aims to mitigate any inconsistencies in the
    streams implementations across Node.js versions by providing an external mirror
    of the streams implementations as an independently installable module. At the
    time of writing, the latest major version of **readable-stream** is version 4,
    which aligns with the Node.js 18 streams implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you should have Node.js 22 installed, preferably the latest
    version of Node.js 22. You’ll also need access to a terminal, editor, and the
    internet.
  prefs: []
  type: TYPE_NORMAL
- en: The code samples for this chapter are available in this book’s GitHub repository
    ( [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    ) in the **Chapter03** directory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating readable and writable streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Node.js **stream** core module provides the Node.js stream API. This recipe
    will introduce using streams in Node.js. It will cover how to create both a readable
    stream and a writable stream to interact with files using the Node.js core **fs**
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into this recipe, we must set up our workspace by creating a
    directory and files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a directory to work in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following two files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we’re ready to start this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll learn how to create both a readable stream and a writeable
    stream. First, we’ll create a writable stream so that we can write a large file.
    After, we’ll read that large file using a readable stream:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the Node.js core **File system** module into **write-stream.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create the writable stream using the **createWriteStream()**
    method that’s available on the **fs** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we can start writing content into our file. Let’s write a random
    string to the file multiple times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run the script with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create a file named **file.txt** in your current directory. The file
    will be approximately **7.5M** in size. To check that the file exists, enter the
    following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create a script that will create a readable stream to read the
    contents of the file. Start the **read-stream.js** file by importing the **fs**
    core module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create our readable stream using the **createReadStream()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can register a **data** event handler, which will execute each time
    a chunk of data has been read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also add an **end** event handler, which will be fired when there is
    no more data left to be consumed from the stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the data chunks as **Buffer** data that’s logged as they’re read:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A snippet of data chunks read by the stream](img/B19212_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A snippet of data chunks read by the stream
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call **toString()** on the individual chunks of data within the **data**
    event handler function, we’ll see the **String** content output as it is processed.
    Change the **data** event handler function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerun the script using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A snippet of the data chunks read by the stream, in string form](img/B19212_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – A snippet of the data chunks read by the stream, in string form
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve created a file using **createWriteStream()** , and then read
    that file using **createReadStream()** .
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we wrote and read a file sequentially using the **createReadStream()**
    and **createWriteStream()** core **fs** methods. The Node.js core **fs** module
    relies on the underlying Node.js **stream** core module. Generally, the Node.js
    **stream** core module is not interacted with directly. You’d typically only interact
    with the Node.js **stream** implementation via higher-level APIs, such as those
    exposed by the **fs** module.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the underlying Node.js streams implementations and
    API, please refer to the Node.js **stream** module documentation at [https://nodejs.org/docs/latest-v22.x/api/stream.html](https://nodejs.org/docs/latest-v22.x/api/stream.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: We created a writable stream, via the **fs.createWriteStream()** method, to
    write our file contents sequentially. The **fs.createWriteStream()** method accepts
    two parameters. The first is the path of the file to write to, while the second
    is an **options** object that can be used to supply configuration to the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table details the configuration that we can supply to the **fs.createWriteStream()**
    method via an **options** object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** | **Default Value** |'
  prefs: []
  type: TYPE_TB
- en: '| **flags** | Defines **File** **System** flags. | **w** |'
  prefs: []
  type: TYPE_TB
- en: '| **encoding** | The encoding of the file. | **utf8** |'
  prefs: []
  type: TYPE_TB
- en: '| **fd** | The **fd** value is expected to be a file descriptor. When this
    value is supplied, the **path** argument will be ignored. | **null** |'
  prefs: []
  type: TYPE_TB
- en: '| **mode** | Sets the file permissions. | **0o666** |'
  prefs: []
  type: TYPE_TB
- en: '| **autoClose** | When **autoClose** is set to **true** , the file descriptor
    will be closed automatically. When **false** , the file descriptor will need to
    be closed manually. | **true** |'
  prefs: []
  type: TYPE_TB
- en: '| **emitClose** | Controls whether the stream emits a **close** event after
    it has been destroyed. | **false** |'
  prefs: []
  type: TYPE_TB
- en: '| **start** | Can be used to specify, as an integer, the position to start
    writing data. | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| **fs** | Used to override **fs** implementations. | **null** |'
  prefs: []
  type: TYPE_TB
- en: '| **signal** | Used to specify an **AbortSignal** object to programmatically
    cancel the writing of the stream. | **null** |'
  prefs: []
  type: TYPE_TB
- en: '| **highWaterMark** | Used to specify the maximum number of bytes that can
    be buffered before backpressure is applied. | **16384** |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – The configurations that can be passed to the createWriteStream()
    method
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on **File System** flags, please refer to [https://nodejs.org/api/fs.html#fs_file_system_flags](https://nodejs.org/api/fs.html#fs_file_system_flags)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we created a readable stream to read the contents of our file sequentially.
    The **createReadStream()** method is an abstraction of a readable stream. Again,
    this method expects two parameters – the first being the path to the contents
    to read, and the second being an **options** object. The following table details
    the options we can pass to the **createReadStream()** method via an **options**
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** | **Default Value** |'
  prefs: []
  type: TYPE_TB
- en: '| **flags** | Defines **File** **System** flags. | **r** |'
  prefs: []
  type: TYPE_TB
- en: '| **encoding** | The encoding of the file. | **null** |'
  prefs: []
  type: TYPE_TB
- en: '| **fd** | The **fd** value is expected to be a file descriptor. When this
    value is supplied, the **path** argument will be ignored. | **null** |'
  prefs: []
  type: TYPE_TB
- en: '| **mode** | Sets the file permissions, but only when the file is created.
    | **0o666** |'
  prefs: []
  type: TYPE_TB
- en: '| **autoClose** | When **autoClose** is set to **true** , the file descriptor
    will be closed automatically. When **false** , the file descriptor will need to
    be closed manually. | **true** |'
  prefs: []
  type: TYPE_TB
- en: '| **emitClose** | Controls whether the stream emits a **close** event after
    it has been destroyed. | **false** |'
  prefs: []
  type: TYPE_TB
- en: '| **start** | Can be used to specify, as an integer, which position to start
    reading data. | **0** |'
  prefs: []
  type: TYPE_TB
- en: '| **end** | Can be used to specify, as an integer, the position to stop reading
    data. | **Infinity** |'
  prefs: []
  type: TYPE_TB
- en: '| **highWaterMark** | Dictates the maximum number of bytes that are stored
    in the internal buffer before the stream stops reading the input. | 64 KiB |'
  prefs: []
  type: TYPE_TB
- en: '| **fs** | Used to override **fs** implementations. | **null** |'
  prefs: []
  type: TYPE_TB
- en: '| **signal** | Used to specify an **AbortSignal** object to programmatically
    cancel the reading of the stream. | **null** |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – The configurations that can be passed to the createReadStream()
    method
  prefs: []
  type: TYPE_NORMAL
- en: 'In **read-stream.js** , we registered a **data** event handler that executed
    each time our readable stream read a chunk of data. We could see the individual
    chunks’ outputs on the screen as they were read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once all the file data was read, our **end** event handler triggered – resulting
    in the **No more** **data** message.
  prefs: []
  type: TYPE_NORMAL
- en: All Node.js streams are instances of the **EventEmitter** class ( [https://nodejs.org/api/events.html#events_class_eventemitter](https://nodejs.org/api/events.html#events_class_eventemitter)
    ). Streams emit a series of different events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following events are emitted on readable streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**close** : Emitted when the stream and any of the stream’s resources have
    been closed. No further events will be emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**data** : Emitted when new data is read from the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**end** : Emitted when all available data has been read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**error** : Emitted when the readable stream experiences an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pause** : Emitted when the readable stream is paused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**readable** : Emitted when there is data available to be read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**resume** : Emitted when a readable stream resumes after being in a paused
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following events are emitted on writable streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**close** : Emitted when the stream and any of its resources have been closed.
    No further events will be emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**drain** : Emitted when the writable stream can resume writing data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**error** : Emitted when the writeable stream experiences an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**finish** : Emitted when the writeable stream has ended, and all writes have
    been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pipe** : Emitted when the **stream.pipe()** method is called on a readable
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**unpipe** : Emitted when the **stream.unpipe()** method is called on a readable
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s dive deeper into readable streams, including how to read from infinite
    data sources. We’ll also learn how to use the more modern asynchronous iterator
    syntax with readable streams.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with infinite data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Streams make it possible to interact with infinite amounts of data. Let’s write
    a script that will process data sequentially, indefinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **learning-streams** directory, create a file named **infinite-read.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need an infinite data source. We will use the **/dev/urandom** file, which
    is available on Unix-like operating systems. This file is a pseudo-random number
    generator. Add the following to **infinite-read.js** to calculate the ongoing
    size of **/dev/urandom** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see an output similar to the following, showing the ever-growing
    size of the **/** **dev/urandom** file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Output showing the ever-growing size of /dev/urandom](img/B19212_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Output showing the ever-growing size of /dev/urandom
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates how we can use streams to process infinite amounts
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Readable streams with async iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Readable streams are **asynchronous iterables** . This means we can use the
    **for await...of** syntax to loop over the stream data. In the following steps,
    we will implement the same functionality as in the main recipe but using the **for**
    **await...of** syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named **for-await-read-stream.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement the **read-stream.js** logic from this recipe using asynchronous
    iterables, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the file with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For more information on the **for await...of** syntax, please refer to the MDN
    web docs ( [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Generally, developers should opt to use one of the Node.js streams API styles
    as using a combination of **on('data')** , **on('readable')** , **pipe()** , and/or
    async iterators could lead to unclear behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Generating readable streams with Readable.from()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Readable.from()** method is exposed by the Node.js core **stream** module.
    This method is used to construct readable streams with iterators. Let’s take a
    closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named **async-generator.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the **Readable** class from the **stream** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the asynchronous generator function. This will form the content of our
    readable stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the use of the **function*** syntax. This syntax defines a generator function.
    For more details on generator syntax, please refer to the MDN web docs ( [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)
    ).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the readable stream using the **Readable.from()** method, passing the
    **generate()** function as the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To output the content of our readable stream, register a **data** event handler
    that prints the chunks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program by entering the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following generated values as output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B19212_02.xhtml#_idTextAnchor041)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Interacting with paused streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Piping streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating transform streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building stream pipelines* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with paused streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Node.js stream can be in either flowing or paused mode. In flowing mode, data
    chunks are read automatically, whereas in paused mode, the **stream.read()** method
    must be called to read the chunks of data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to interact with a readable stream that is in
    paused mode, which is its default upon creation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the **learning-streams** directory that we created in the previous recipe,
    create the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We’re now ready to start this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll learn how to interact with a readable stream that is
    in paused mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the **fs** module into **paused-stream.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a readable stream to read the **file.txt** file using the **createReadStream()**
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to register a **readable** event handler on the readable stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the manual logic to read the data chunks within our **readable**
    handler. Add the following logic to read the data, until there is no data left
    to consume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can register an **end** event handler for our readable stream that
    will print a message stating **No more data.** once all the data has been read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following output, indicating that the chunks of the readable
    stream are being read:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Overview of the readable stream chunks as they are being read](img/B19212_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Overview of the readable stream chunks as they are being read
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve learned how to interact with a readable stream in paused mode.
    We did this by listening for the readable event and manually calling the **read()**
    method.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned how to interact with a readable stream that was in
    paused mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, a readable stream is in paused mode. However, a readable stream
    will switch to flowing mode in the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: When a **data** event handler is registered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **pipe()** method is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **resume()** method is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since our program in this recipe did none of these, our stream remained in paused
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a readable stream was in flowing mode, it would switch back to paused mode
    in the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: When the **pause()** method is called and there are no pipe destinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **unpipe()** method is called on all pipe destinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a **readable** event handler to our readable stream. If the readable
    stream was already in flowing mode, a readable event handler being registered
    would stop the stream from flowing (it’s switched to paused mode).
  prefs: []
  type: TYPE_NORMAL
- en: When the readable stream is in paused mode, it is necessary to manually call
    the **readableStream.read()** method to consume the stream data. In this recipe,
    we added logic within our **readable** event handler that continued to read the
    stream data until the data value was **null** . The data value being **null**
    indicates that the stream has ended (all currently available data has been read).
    The **readable** event can be emitted multiple times, indicating that more data
    has become available.
  prefs: []
  type: TYPE_NORMAL
- en: When a stream is in paused mode, we can have more control over when the data
    is being read. Essentially, we’re pulling the data from the stream, rather than
    it being pushed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Generally, if possible, it’s worthwhile using the **pipe()** method to handle
    the consumption data of a readable stream as memory management is handled automatically.
    The following recipe, *Piping streams* , will go into more detail about the **pipe()**
    method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B19212_02.xhtml#_idTextAnchor041)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating readable and writable streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Piping streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating transform streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building stream pipelines* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Piping streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pipe is a form of one-way redirection. In our terminal (DOS or Unix-like),
    we often utilize the pipe operator ( **|** ) to pipe the output of one program
    as the input to another program. For example, we can enter **$ ls | head -3**
    to pipe the output of the **ls** command to the **head -3** command, resulting
    in the first three files in our directory being returned.
  prefs: []
  type: TYPE_NORMAL
- en: Like how we can use the pipe operator in our shells to pipe output between programs,
    we can use the Node.js **pipe()** method to pipe data between streams.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to use the **pipe()** method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory to work in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by creating a file named **file.txt** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some dummy data to **file.txt** , such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we’re ready to start this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll learn how to pipe a readable stream to a writable stream:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named **pipe-stream.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start the **pipe-stream.js** file by importing the **fs** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a readable stream to read **file.txt** using the **createReadStream()**
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to pipe our readable stream to **process.stdout** , which returns
    a writable stream connected to **STDOUT** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we’ve piped a readable stream to a writeable stream using the **pipe()**
    method.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a readable stream to read our **file.txt** file using
    the **createReadStream()** method. Then, we piped the output of this readable
    stream to **process.stdout** (a writable stream) using the **pipe()** method.
    The **pipe()** method attaches a data event handler to the source stream, which
    writes the incoming data to the destination stream.
  prefs: []
  type: TYPE_NORMAL
- en: The **pipe()** method is used to direct data through a flow of streams. Under
    the hood, the **pipe()** method manages the flow of data to ensure that the destination
    writable stream is not overwhelmed by a faster readable stream.
  prefs: []
  type: TYPE_NORMAL
- en: The in-built management provided by the **pipe()** method helps resolve the
    issue of backpressure. Backpressure occurs when an input overwhelms a system’s
    capacity. For streams, this could occur when we’re consuming a stream that is
    rapidly reading data, and the writable stream can’t keep up. This can result in
    a large amount of memory being kept in a process before being written by the writable
    stream. The mass amount of data being stored in memory can degrade our Node.js
    process performance, or in the worst cases, cause the process to crash.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when using the **pipe()** method, **stream.end()** is called on
    the destination writable stream when the source readable stream emits an **end**
    event. This means that the destination is no longer writable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable this default behavior, we can supply **{ end: false }** to the **pipe()**
    method via an **options** argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This configuration instructs the destination stream to remain open even after
    the **end** event has been emitted by the source stream.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stream chaining in Node.js allows for efficient data processing by linking
    together multiple streams. This method enables data transformations with minimal
    memory overhead, which is ideal for operations such as compression. In the following
    example, we’ll demonstrate the process of reading a file, compressing its contents,
    and writing the compressed data to a new file to highlight the use of **pipe()**
    for chaining streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, **readStream.pipe(zlib.createGzip()).pipe(writeStream);** reads
    data from **input.txt** , compresses it on-the-fly, and writes the compressed
    data to **output.txt.gz** . This chain of operations is executed with efficiency,
    showcasing the elegance and power of stream chaining in Node.js for data processing
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the example provided, error handling is not explicitly shown, but it’s crucial
    in a real-world application. In Node.js, when chaining streams, errors can be
    propagated through the chain. When using **pipe()** , errors should be listened
    for on each stream by attaching an **error** event listener to each stream involved.
    This ensures that errors are caught and managed where they occur.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating readable and writable streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating transform streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building stream pipelines* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating transform streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transform streams allow us to consume input data, process that data, and then
    output the data in its processed form. We can use transform streams to handle
    data manipulation functionally and asynchronously. It’s possible to pipe many
    transform streams together, allowing us to break complex processing down into
    sequential tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to create a transform stream using the Node.js core
    **stream** module.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **through2** module ( [https://www.npmjs.com/package/through2](https://www.npmjs.com/package/through2)
    ) is very popular and provides a wrapper for creating Node.js transform streams.
    However, over the past few years, there have been many simplifications and improvements
    to the Node.js core stream implementation. Today, the Node.js stream API provides
    simplified construction, as demonstrated in this recipe, which means we can achieve
    equivalent syntax using Node.js core directly, without the need for **through2**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory to work in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named **transform-stream.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need some sample data to transform. So, create a file named **file.txt**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some dummy text data to the **file.txt** file, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we’re ready to start this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll learn how to create a transform stream using the Node.js
    core **stream** module. The transform stream we will create will convert all the
    text from our file into uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the Node.js core **File system** module into **transform-stream.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to import the **Transform** class from the Node.js core **stream**
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a readable stream to read the **file.txt** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once our file content has been processed by our transform stream, we will write
    it to a new file named **newFile.txt** . Create a writable stream to write this
    file using the **createWriteStream()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to define our transform stream. We’ll name our transform stream
    **uppercase()** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, within our transform stream, we will add the logic to transform the chunk
    into an uppercase string. Below the **// Data processing** comment, add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This calls the transform stream callback function with the transformed chunk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we need to chain all our streams together. We will do this using
    the **pipe()** method. Add the following line to the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following command in your terminal to run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect **newFile.txt** to have been created by our program. You can confirm
    this by running the **cat** command, followed by the new file’s name, in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the contents are now in uppercase, indicating that the data has passed
    through the transform stream.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, we’ve learned how to create a transform stream to manipulate data.
    Our transform stream converted the input data into uppercase strings. After, we
    piped our readable stream to the transform stream and piped the transform stream
    to our writable stream.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transform streams are duplex streams, which means they implement both readable
    and writable stream interfaces. Transform streams are used to process (or transform)
    the input and then pass it as output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a transform stream, we must import the **Transform** class from the
    Node.js core **stream** module. The transform stream constructor accepts the following
    two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**transform** : The function that implements the data processing/transformation
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flush** : If the transform process emits additional data, the **flush** method
    is used to flush the data. This argument is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the **transform()** function that processes the stream input and produces
    the output. Note that it is not necessary for the number of chunks that are supplied
    via the input stream to be equal to the number output by the transform stream
    – some chunks could be omitted during the transformation/processing.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the **transform()** function gets attached to the **_transform()**
    method of the transform stream. The **_transform()** method is an internal method
    on the **Transform** class that is not intended to be called directly (hence the
    underscore prefix).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **_transform()** method accepts the following three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**chunk** : The data to be transformed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**encoding** : If the input is of the **String** type, the encoding will be
    of the **String** type. If it is of the **Buffer** type, this value is set to
    **buffer** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**callback(err, transformedChunk)** : The callback function to be called once
    the chunk has been processed. The callback function is expected to have two arguments
    – the first an error and the second the transformed chunk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, our **transform()** function called the **callback()** function
    with our processed data (where our processed data was **chunk.toString().toUpperCase()**
    to convert the input into an uppercase string).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Node.js comes with some built-in transform streams. Both the Node.js core **crypto**
    and **zlib** modules expose transform streams. As an example, the **zlib.createGzip()**
    method is a transform stream that’s exposed by the **zlib** module that compresses
    the file that’s been piped to it.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to create transform streams in **ECMAScript
    6** ( **ES6** ) syntax and how we can create an object mode transform stream.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting ES6 syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this recipe, we implemented a transform stream using the simplified constructor
    approach. It is also possible to implement these using the ES6 class syntax. The
    following steps will demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named **transform-stream-es6.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The transform stream from this recipe can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code, it is clearer that we’re overriding the **_transform()** method
    with our transformation logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This example uses ES6 syntax to create a custom transform stream that reads
    from **file.txt** , converts the content into uppercase, and writes it to **newFile.txt**
    . The **Uppercase** class, extending the **Transform** class, overrides the **_transform**
    method to process data chunks, converting them into uppercase with **chunk.toString().toUpperCase()**
    before pushing them to the write stream. The callback function, **callback()**
    , is invoked to indicate the completion of the current chunk’s processing, allowing
    the stream to handle the next chunk and maintain a regulated flow of data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating object mode transform streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Node.js streams operate on **String** , **Buffer** , or **Uint8Array**
    objects. However, it is also possible to work with Node.js streams in **object
    mode** . This allows us to work with other JavaScript values (except the **null**
    value). In object mode, the values that are returned from the stream are generic
    JavaScript objects. An example use case for object mode streaming could be implementing
    an application that queries a database for a large set of user records and then
    processes each user record individually.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference with object mode is that the **highWaterMark** value refers
    to the number of objects, rather than bytes. In previous recipes, we learned that
    the **highWaterMark** value dictates the maximum number of bytes that are stored
    in the internal buffer before the stream stops reading the input. For object mode
    streams, this value is set to **16** – meaning 16 objects are buffered at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a stream in object mode, we must pass **{ objectMode: true }** via the
    **options** object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate how to create a transform stream in object mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a folder called **object-streams** containing a file named **object-stream.js**
    and initialize the project with **npm** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the **ndjson** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **object-stream.js** , import the **Transform** class from the Node.js core
    **stream** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, import the **stringify()** method from the **ndjson** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the transform stream, specifying **{ objectMode:** **true }** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create our chain of streams. We will pipe the **Name** transform
    stream to the **stringify()** method (from **ndjson** ), and then pipe the result
    to **process.stdout** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, still in **object-stream.js** , we’ll write some data to the **Name**
    transform stream using the **write()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we created a transform stream called **Name** that aggregates
    the value of two JSON properties ( **forename** and **surname** ) and returns
    a new property ( **name** ) with the aggregated value. The **Name** transform
    stream is in object mode and both reads and writes objects.
  prefs: []
  type: TYPE_NORMAL
- en: We pipe our **Name** transform stream to the **stringify()** function provided
    by the **ndjson** module. The **stringify()** function converts the streamed JSON
    objects into newline-delimited JSON. The **stringify()** stream is a transform
    stream where the writable side is in object mode, but the readable side isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'With transform streams (and duplex streams), you can independently specify
    whether the readable or writable side of the stream is in object mode by supplying
    the following configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**readableObjectMode** : When **true** , the readable side of the duplex stream
    is in object mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**writableObjectMode** : When **true** , the writable side of the duplex stream
    is in object mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that it is also possible to set different **highWaterMark** values for
    the readable or writable side of a duplex stream using the following configuration
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**readableHighWaterMark** : Configures the **highWaterMark** value for the
    readable side of the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**writableHighWaterMark** : Configures the **highWaterMark** value for the
    writable side of the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **readableHighWaterMark** and **writableHighWaterMark** configuration values
    have no effect if a **highWaterMark** value is supplied because the **highWaterMark**
    value takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Using map and filter functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More recent versions of Node.js, later than version 16.4.0, provide **Experimental**
    array-like methods fo r readable streams. These methods can be used similarly
    to the array methods – for example, the **Readable.map()** and **Readable.filter()**
    methods provide similar functionality to **Array.prototype.map()** and **Array.prototype.filter()**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The **map()** method can be used to map over the stream. For every chunk in
    the stream, the specified function will be called. The **transform stream** we
    created in this recipe could be rewritten using the **map()** method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Readable.filter()** method can be used to filter a readable stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'These are two recent function additions that provide array-like methods on
    readable streams. Many more array-like methods are now available on streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.** **drop()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **every()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **filter()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **find()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **flatMap()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **forEach()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **map()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **reduce()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **some()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **take()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **toArray()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information, including the usage and parameters of these methods, can
    be found in the Node.js Stream API documentation: [https://nodejs.org/docs/latest-v22.x/api/stream.html](https://nodejs.org/docs/latest-v22.x/api/stream.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the array-like stream methods are designated with an
    **Experimental** status.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating readable and writable streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Piping streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building stream pipelines* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building stream pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Node.js core **stream** module provides a **pipeline()** method. Similar
    to how we can use the Node.js core stream **pipe()** method to pipe one stream
    to another, we can also use the **pipeline()** method to chain multiple streams
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the **pipe()** method, the **pipeline()** method also forwards errors,
    making it easier to handle errors in the stream’s flow.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe builds upon many of the stream concepts that were covered in the
    other recipes in this chapter. Here, we’ll create a stream pipeline using the
    **pipeline()** method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into this recipe, let’s set up our workspace by creating a directory
    and files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a directory to work in named **stream-pipelines** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named **pipeline.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need some sample data to transform. Create a file named **file.txt**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some dummy text data to the **file.txt** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we’re ready to start this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll create a stream pipeline using the **pipeline()** method.
    Our pipeline will read the **file.txt** file, convert the file’s contents into
    uppercase using a transform stream, and then write the new contents to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the Node.js core **fs** module into **pipeline.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to import the **pipeline()** method and the **Transform** class
    from the Node.js core **stream** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create our transform stream (refer to the *Creating transform streams*
    recipe in this chapter for more information on transform streams). This will convert
    the input into uppercase strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can start to create the stream pipeline. First, let’s call the **pipeline()**
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **pipeline()** method expects the first argument to be a readable stream.
    Our first argument will be a readable stream that will read the **file.txt** file,
    using the **createReadStream()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add our transform stream as the second argument to the **pipeline()**
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can add our writable stream to write the **newFile.txt** file to the
    pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the last argument to our pipeline is a callback function that will
    execute once the pipeline has finished running. This callback function will handle
    any errors in our pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your terminal, run the program with the following command. You should expect
    to see a message stating **Pipeline succeeded.** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To confirm that the stream pipeline was successful, verify that the **newFile.txt**
    file contains the contents of **file.txt** , but in uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we’ve created a stream pipeline using the **pipeline()** method that’s
    exposed by the Node.js core **stream** module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **pipeline()** method allows us to pipe streams to one another – forming
    a flow of streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass the following arguments to the stream’s **pipeline()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**source** : A source stream from which to read data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**...transforms** : Any number of transform streams to process data ( including
    **0** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**destination** : A destination stream to write the processed data to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**callback** : The function to be called when the pipeline is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass the **pipeline()** method to our series of streams, in the order they
    need to run, followed by using a callback function that executes once the pipeline
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The **pipeline()** method elegantly forwards errors that occur in the streams
    onto the callback. This is one of the benefits of using the **pipeline()** method
    over the **pipe()** method.
  prefs: []
  type: TYPE_NORMAL
- en: The **pipeline()** method also cleans up any unterminated streams by calling
    **stream.destroy()** .
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Node.js version 15 and later, there is a suite of asynchronous utility functions
    for streams that utilize **Promise** objects instead of callbacks. These functions
    can be found in the **stream/promises** core module. This module includes versions
    of **stream.pipeline()** and **stream.finished()** that are compatible with promises,
    providing a more modern and promise-friendly approach to stream handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s convert the stream pipeline from the main recipe so that it uses the
    **Promise** version of **stream.pipeline()** :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named **promise-pipeline.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to import the Node.js core **fs** and **stream/promises**
    modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the transform stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we’ll be awaiting **pipeline()** , we’ll need to wrap the **pipeline()**
    logic in an asynchronous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can call our **run()** function, catching any errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we’ve demonstrated how to use the stream **pipeline()** method with
    Promises by using the Streams Promises API.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Previously, the **pipeline()** method may have been converted into **Promise**
    form using the **util.promisify()** utility method. The **util.promisify()** method
    is used to convert a callback-style method into **Promise** form. The Streams
    Promises API replaces the need to use this.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating readable and writable streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Piping streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating transform streams* recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
