- en: Chapter 5. Creating Dynamic Websites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 创建动态网站
- en: Now that we have established a basic structure for our application, we can start
    to add more functionality and build a dynamic website that responds to user input.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经为我们的应用程序建立了一个基本结构，我们就可以开始添加更多功能，并构建一个能够响应用户输入的动态网站。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding a new module to our application for storing and deleting data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序添加一个新模块以存储和删除数据
- en: Exposing a JSON API to handle user-submitted data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供JSON API以处理用户提交的数据
- en: Implementing communication between the client and server using Ajax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ajax实现客户端和服务器之间的通信
- en: Building up more complex HTML views using partial templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用部分模板构建更复杂的HTML视图
- en: Handling user-submitted data
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户提交的数据
- en: We're going to implement the classic guessing game of Hangman (see [https://en.wikipedia.org/wiki/Hangman_(game)](https://en.wikipedia.org/wiki/Hangman_(game))).
    Users will be able to post new words to guess, and to guess words posted by others.
    We'll look at creating new games first.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现经典的猜字游戏——Hangman（见[https://en.wikipedia.org/wiki/Hangman_(game)](https://en.wikipedia.org/wiki/Hangman_(game)))。用户将能够发布新词进行猜测，以及猜测他人发布的词。我们将首先查看创建新游戏。
- en: First, we'll add a new module for managing our games. For now, we'll just store
    our games in the memory. If we want to put games in some persistent storage in
    future, this is the module we will change. The interface (that is, the functions
    added to `module.exports`) can remain the same though.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为管理我们的游戏添加一个新的模块。目前，我们只需将游戏存储在内存中。如果我们将来想要将游戏存储在某种持久存储中，这就是我们将要更改的模块。尽管如此，接口（即添加到`module.exports`中的函数）可以保持不变。
- en: 'We add the following code under `services/games.js`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`services/games.js`下添加以下代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now let's go through our application from the top down. In our index view (`views/index.hjs`),
    we'll add simple a HTML form for creating a new game.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从上到下查看我们的应用程序。在我们的索引视图（`views/index.hjs`）中，我们将添加一个简单的HTML表单来创建新游戏。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When submitted, this form will make a POST request to `/games`. At the moment,
    this would return a 404 error since we have nothing mounted at that route (you
    can try this in a browser it if you like). We can add a new games route to handle
    this request. We add the following code under `routes/games.js`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交此表单时，它将向`/games`发出POST请求。目前，这将返回一个404错误，因为我们没有在该路由上挂载任何内容（如果您喜欢，可以在浏览器中尝试）。我们可以添加一个新的游戏路由来处理此请求。我们在`routes/games.js`下添加以下代码：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is quite a lot going on in our new routing middleware:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新路由中间件中有很多事情在进行：
- en: '`router.post` creates a handler for an HTTP POST request.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.post`创建一个处理HTTP POST请求的处理程序。'
- en: '`req.body` contains form values, thanks to the `bodyParser` middleware in `app.js`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req.body`包含表单值，归功于`app.js`中的`bodyParser`中间件。'
- en: '`req.user.id` contains the current user, thanks to our users middleware.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req.user.id`包含当前用户，归功于我们的`users`中间件。'
- en: '`res.redirect()` issues a redirect to reload the page. It is important to always
    issue a redirect after a successful POST request. This avoids duplicate form submissions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.redirect()`发出重定向以重新加载页面。在成功的POST请求后始终发出重定向是很重要的。这避免了表单的重复提交。'
- en: '`res.status()` sets an alternative HTTP status code for the response, in this
    case a 400 for a validation failure.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.status()`为响应设置一个替代的HTTP状态码，在这种情况下是一个400，表示验证失败。'
- en: Our route looks for a field named `word` in the request body. It then checks
    this field is defined and not empty (both undefined and the empty string are *falsey*
    in JavaScript, so they behave as false in conditional tests). It also checks that
    the field matches a regular expression specifying our validity rule.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由在请求体中查找名为`word`的字段。然后检查该字段是否已定义且不为空（在JavaScript中，未定义和空字符串都是*falsey*，因此在条件测试中表现为false）。它还检查该字段是否与指定我们有效性规则的正则表达式匹配。
- en: Finally, the route makes use of our service module to actually create the new
    game. It is common practice for routing middleware to delegate application logic
    to other modules. Its main responsibility is to define the HTTP interface of the
    application. Other modules are responsible for implementing the actual application
    logic. In this way, our routes and middleware are comparable to controllers in
    MVC frameworks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该路由利用我们的服务模块实际创建新游戏。将应用逻辑委托给其他模块是路由中间件的常见做法。其主要责任是定义应用程序的HTTP接口。其他模块负责实现实际的应用逻辑。这样，我们的路由和中间件与MVC框架中的控制器相当。
- en: 'We also need to mount this route at the `/games` path. The following code is
    from `app.js`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `/games` 路径上挂载这个路由。以下代码来自 `app.js`：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Communicating via Ajax
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Ajax 进行通信
- en: Having created a game, we need a way of playing it. Since the whole point of
    a guessing game is that the word is secret, we don't want to send the whole word
    to the client. Instead, we just want to let clients know the length of the word
    and provide a way for them to verify their guesses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个游戏后，我们需要一种玩它的方法。既然猜词游戏的核心在于单词是保密的，我们不想将整个单词发送给客户端。相反，我们只想让客户端知道单词的长度，并提供一种方式让他们验证自己的猜测。
- en: 'To do this, we''ll first need to expand our games service module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要扩展我们的游戏服务模块：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can add two new routes to our games route:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的游戏路由中添加两个新的路由：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These two routes make use of a shared function for retrieving the game and returning
    a 404 status code if it does not exist. The GET handler renders a view, as with
    our index route. The POST handler calls `res.send()`, passing in a JavaScript
    object. Express will automatically turn this into a JSON response to the client.
    This makes it very easy to build JSON-based APIs in express.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个路由都使用了一个共享函数来检索游戏，如果游戏不存在则返回 404 状态码。GET 处理器渲染一个视图，就像我们的索引路由一样。POST 处理器调用
    `res.send()`，传入一个 JavaScript 对象。Express 会自动将其转换为客户端的 JSON 响应。这使得在 express 中构建基于
    JSON 的 API 非常容易。
- en: 'We''ll now create a view and client-side script for communicating with this
    API. We add the following code under `views/game.hjs`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个视图和客户端脚本，用于与这个 API 进行通信。我们在 `views/game.hjs` 下添加以下代码：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We add the following code under `public/scripts/game.js`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `public/scripts/game.js` 下添加以下代码：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that in the client-side script we drop back to the ECMAScript 5 standard
    (for example, `var` instead of `let`, and no arrow function). This ensures the
    widest possible compatibility. The latest versions of all mainstream browsers
    would support the elements of ES2015 syntax that we've been using so far though.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在客户端脚本中，我们退回到 ECMAScript 5 标准（例如，使用 `var` 而不是 `let`，以及没有箭头函数）。这确保了最大的兼容性。尽管如此，所有主流浏览器的最新版本都会支持我们迄今为止使用的
    ES2015 语法元素。
- en: Also note that we don't have Node.js modules available on the client side. We
    fall back to wrapping our code in a function to isolate the scope. We'll look
    at ways to make client-side code more modular in a later chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，客户端没有可用的 Node.js 模块。我们退回到将代码包裹在函数中来隔离作用域。我们将在后面的章节中探讨使客户端代码更模块化的方法。
- en: Our client-side script uses jQuery. We won't go into detail on client-side frameworks,
    but it's worth quickly explaining the features used here. The jQuery library provides
    a consistent API for DOM manipulation that works across all browsers, as well
    as a number of useful tools for client-side functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端脚本使用 jQuery。我们不会深入讨论客户端框架，但这里快速解释一下这里使用的功能。jQuery 库提供了一个跨所有浏览器的一致 API
    用于 DOM 操作，以及一些用于客户端功能的有用工具。
- en: 'The main jQuery API is available through the `$` object, which is a function.
    The first thing our script does is call `$` and pass it a callback, which jQuery
    will execute once the page has finished loading. Our other calls to `$` pass in
    a string or a DOM element. Strings are interpreted as a CSS selector for choosing
    elements. In both cases, `$` returns a wrapper around a set of DOM elements with
    some useful methods, for example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 jQuery API 通过 `$` 对象提供，它是一个函数。我们的脚本首先调用 `$` 并传递一个回调，jQuery 将在页面加载完成后执行这个回调。我们的其他
    `$` 调用传递一个字符串或一个 DOM 元素。字符串被解释为选择元素的 CSS 选择器。在两种情况下，`$` 都返回一组 DOM 元素的包装，并带有一些有用的方法，例如：
- en: The `data` method allows us to read the elements' `data-` attributes
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 方法允许我们读取元素的 `data-` 属性'
- en: The `append` method allows us to add new child elements
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append` 方法允许我们添加新的子元素'
- en: Methods such as `keydown` allow us to bind handler functions for events
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keydown` 等方法允许我们为事件绑定处理函数'
- en: There are also some utility methods defined on the `$` object itself. These
    are more like static methods and don't relate to a specific DOM element. The `post()`
    method is an example of this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` 对象本身还定义了一些实用方法。这些更像是静态方法，与特定的 DOM 元素无关。`post()` 方法就是这样的一个例子。'
- en: Our script uses jQuery's `post()` method to issue an Ajax POST request. This
    returns an object with a `done()` method, to which we can pass a callback to be
    executed when the request completes. Here, we can make use of the JSON data returned
    by our API. In this case, we fill in any positions that match our guessed letter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本使用jQuery的`post()`方法发出Ajax POST请求。这返回一个具有`done()`方法的对象，我们可以向其中传递一个回调，当请求完成时执行。在这里，我们可以利用我们的API返回的JSON数据。在这种情况下，我们填充任何与我们的猜测字母匹配的位置。
- en: 'If we run the application at this point, we have a (very) minimal working game.
    First, visit `http://localhost:3000/` and create a new game by submitting a valid
    word. Then visit `http://localhost:3000/games/1` to play. It should look something
    like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们将有一个（非常）最小的工作游戏。首先，访问`http://localhost:3000/`并提交一个有效的单词来创建一个新游戏。然后访问`http://localhost:3000/games/1`来玩游戏。它应该看起来像以下内容：
- en: '![Communicating via Ajax](img/image00215.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![通过Ajax进行通信](img/image00215.jpeg)'
- en: Implementing other data operations
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现其他数据操作
- en: So far, we have seen how to create or retrieve a single game, or submit a single
    guess for a game. Applications also commonly need to list data or delete entries.
    The principles here are much the same as we've seen already. But to implement
    these operations, we'll need some new syntax.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何创建或检索单个游戏，或者为游戏提交单个猜测。应用程序通常还需要列出数据或删除条目。这里的原理与我们之前看到的是一样的。但是，为了实现这些操作，我们需要一些新的语法。
- en: Listing data in views
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中列出数据
- en: 'Let''s first allow users to see a list of games they''ve created or that have
    been created by others. Our chosen view engine, Hogan, is based on Mustache, which
    has a very simple syntax for displaying lists. We can add these two lists to our
    `index.hjs` view, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先允许用户查看他们创建或他人创建的游戏列表。我们选择的视图引擎Hogan基于Mustache，它有一个非常简单的语法来显示列表。我们可以在`index.hjs`视图中添加这两个列表，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to populate these lists, we''ll need a couple of new methods in our
    `games.js` service module:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充这些列表，我们需要在我们的`games.js`服务模块中添加几个新方法：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we''ll need to expose these to our index view from our route:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要从我们的路由中公开这些内容到我们的首页：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, our index page shows games created by the current user and provides convenient
    links to games created by others. You can experiment with this functionality by
    using two separate browser sessions again to visit `http://localhost:3000`. The
    result should look something like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的首页显示了当前用户创建的游戏，并为其他用户创建的游戏提供了方便的链接。您可以通过再次使用两个独立的浏览器会话来访问`http://localhost:3000`来实验这个功能。结果应该类似于以下内容：
- en: '![Listing data in views](img/image00216.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![在视图中列出数据](img/image00216.jpeg)'
- en: Issuing a delete request from the client
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端发出删除请求
- en: 'To allow users to remove games that they have created, we''ll first need to
    add a method to our Game class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户删除他们创建的游戏，我们首先需要在我们的Game类中添加一个方法：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next we can create a new handler for `delete` requests in our games route:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在我们的游戏路由中创建一个新的`delete`请求处理程序：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we can make use of this from the client. The following code is from
    `views/index.hjs`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从客户端使用这个功能。以下代码来自`views/index.hjs`：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We add the following code under `public/scripts/index.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`public/scripts/index.js`下添加以下代码：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that, unlike GET and POST, jQuery has no convenience function for `delete`
    requests. So we drop back to the lower level `.ajax()` function and specify the
    HTTP method explicitly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与GET和POST不同，jQuery没有为`delete`请求提供便利函数。因此，我们退回到较低级别的`.ajax()`函数，并明确指定HTTP方法。
- en: If you visit the application in a browser and create a new game again, you should
    now see a link to delete the game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中访问应用程序并再次创建一个新游戏，您现在应该看到一个删除游戏的链接。
- en: Splitting up Express views using partials
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用部分拆分Express视图
- en: Deleting a game does not cause the page to refresh, but creating a new game
    does. We can fix this by creating games via an Ajax call, consistent with how
    we delete games. In order for this to work, the client-side script that handles
    the call needs to know which HTML to add to the page when a new game is created.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 删除游戏不会使页面刷新，但创建新游戏会。我们可以通过通过Ajax调用创建游戏来修复这个问题，这与我们删除游戏的方式一致。为了使这生效，处理调用的客户端脚本需要知道在创建新游戏时应该添加到页面的HTML。
- en: We could repeat the HTML structure of the view within the client-side JavaScript.
    However, it would be better for the server to return the correct HTML fragment,
    and to reuse the same template for this as it uses it to render the list on the
    page initially.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在客户端JavaScript中重复视图的HTML结构。然而，让服务器返回正确的HTML片段，并重用与最初在页面上渲染列表时相同的模板会更好。
- en: 'We can do this by splitting the HTML structure for a game within the list into
    a partial view. This is a view template for an HTML fragment rather than a complete
    page. We add the following code under `views/createdGame.hjs`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将游戏列表中的HTML结构拆分为部分视图来实现这一点。这是一个HTML片段的视图模板，而不是完整的页面。我们在`views/createdGame.hjs`下添加以下代码：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the view engine that we''re using (Hogan), we need to let views know about
    available partials when rendering them (other view engines allow partials to be
    resolved automatically). The following code is from `routes/index.js`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们正在使用的视图引擎（Hogan），在渲染视图时我们需要让视图知道可用的部分（其他视图引擎允许自动解析部分）。以下代码来自`routes/index.js`：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use the partial within our main view as follows. We''ll also add IDs
    to our HTML elements, which we will reference from our client-side JavaScript
    shortly. The following code is from `views/index.hjs`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在主视图中使用部分，我们还将为我们的HTML元素添加ID，我们将在稍后从客户端JavaScript中引用它们。以下代码来自`views/index.hjs`：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can update our games route to return only this fragment to the client
    when creating a new game. The following code is from `routes/games.js`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的游戏路由，在创建新游戏时只向客户端返回这个片段。以下代码来自`routes/games.js`：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we can make use of this in our client-side script. The following code
    is from `public/scripts/index.js`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在客户端脚本中使用它。以下代码来自`public/scripts/index.js`：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have started building out our own application by creating
    new middleware and service modules. We've read user-submitted data from forms
    and acted on it. We've implemented a JSON API on the server side and communicated
    with this from the client using Ajax. We've used partial views to render common
    components.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过创建新的中间件和服务模块开始构建自己的应用程序。我们从表单中读取用户提交的数据并对其进行了处理。我们在服务器端实现了JSON API，并使用Ajax从客户端与其通信。我们使用了部分视图来渲染常见组件。
- en: So far, we've seen how to write JavaScript code and implement various functionality
    in Node.js. This is good for prototyping, but isn't enough for a maintainable
    project. It's also important to write automated tests for our code, which is the
    subject of the next chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了如何编写JavaScript代码并在Node.js中实现各种功能。这对于原型设计来说很好，但对于可维护的项目来说还不够。编写自动化测试来测试我们的代码也同样重要，这是下一章的主题。
