- en: Chapter 5. Creating Dynamic Websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have established a basic structure for our application, we can start
    to add more functionality and build a dynamic website that responds to user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new module to our application for storing and deleting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing a JSON API to handle user-submitted data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing communication between the client and server using Ajax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building up more complex HTML views using partial templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user-submitted data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to implement the classic guessing game of Hangman (see [https://en.wikipedia.org/wiki/Hangman_(game)](https://en.wikipedia.org/wiki/Hangman_(game))).
    Users will be able to post new words to guess, and to guess words posted by others.
    We'll look at creating new games first.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll add a new module for managing our games. For now, we'll just store
    our games in the memory. If we want to put games in some persistent storage in
    future, this is the module we will change. The interface (that is, the functions
    added to `module.exports`) can remain the same though.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the following code under `services/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now let's go through our application from the top down. In our index view (`views/index.hjs`),
    we'll add simple a HTML form for creating a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When submitted, this form will make a POST request to `/games`. At the moment,
    this would return a 404 error since we have nothing mounted at that route (you
    can try this in a browser it if you like). We can add a new games route to handle
    this request. We add the following code under `routes/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is quite a lot going on in our new routing middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '`router.post` creates a handler for an HTTP POST request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.body` contains form values, thanks to the `bodyParser` middleware in `app.js`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req.user.id` contains the current user, thanks to our users middleware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.redirect()` issues a redirect to reload the page. It is important to always
    issue a redirect after a successful POST request. This avoids duplicate form submissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.status()` sets an alternative HTTP status code for the response, in this
    case a 400 for a validation failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our route looks for a field named `word` in the request body. It then checks
    this field is defined and not empty (both undefined and the empty string are *falsey*
    in JavaScript, so they behave as false in conditional tests). It also checks that
    the field matches a regular expression specifying our validity rule.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the route makes use of our service module to actually create the new
    game. It is common practice for routing middleware to delegate application logic
    to other modules. Its main responsibility is to define the HTTP interface of the
    application. Other modules are responsible for implementing the actual application
    logic. In this way, our routes and middleware are comparable to controllers in
    MVC frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to mount this route at the `/games` path. The following code is
    from `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Communicating via Ajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having created a game, we need a way of playing it. Since the whole point of
    a guessing game is that the word is secret, we don't want to send the whole word
    to the client. Instead, we just want to let clients know the length of the word
    and provide a way for them to verify their guesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll first need to expand our games service module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add two new routes to our games route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These two routes make use of a shared function for retrieving the game and returning
    a 404 status code if it does not exist. The GET handler renders a view, as with
    our index route. The POST handler calls `res.send()`, passing in a JavaScript
    object. Express will automatically turn this into a JSON response to the client.
    This makes it very easy to build JSON-based APIs in express.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now create a view and client-side script for communicating with this
    API. We add the following code under `views/game.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the following code under `public/scripts/game.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the client-side script we drop back to the ECMAScript 5 standard
    (for example, `var` instead of `let`, and no arrow function). This ensures the
    widest possible compatibility. The latest versions of all mainstream browsers
    would support the elements of ES2015 syntax that we've been using so far though.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we don't have Node.js modules available on the client side. We
    fall back to wrapping our code in a function to isolate the scope. We'll look
    at ways to make client-side code more modular in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Our client-side script uses jQuery. We won't go into detail on client-side frameworks,
    but it's worth quickly explaining the features used here. The jQuery library provides
    a consistent API for DOM manipulation that works across all browsers, as well
    as a number of useful tools for client-side functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main jQuery API is available through the `$` object, which is a function.
    The first thing our script does is call `$` and pass it a callback, which jQuery
    will execute once the page has finished loading. Our other calls to `$` pass in
    a string or a DOM element. Strings are interpreted as a CSS selector for choosing
    elements. In both cases, `$` returns a wrapper around a set of DOM elements with
    some useful methods, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: The `data` method allows us to read the elements' `data-` attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `append` method allows us to add new child elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods such as `keydown` allow us to bind handler functions for events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also some utility methods defined on the `$` object itself. These
    are more like static methods and don't relate to a specific DOM element. The `post()`
    method is an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: Our script uses jQuery's `post()` method to issue an Ajax POST request. This
    returns an object with a `done()` method, to which we can pass a callback to be
    executed when the request completes. Here, we can make use of the JSON data returned
    by our API. In this case, we fill in any positions that match our guessed letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the application at this point, we have a (very) minimal working game.
    First, visit `http://localhost:3000/` and create a new game by submitting a valid
    word. Then visit `http://localhost:3000/games/1` to play. It should look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communicating via Ajax](img/image00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing other data operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to create or retrieve a single game, or submit a single
    guess for a game. Applications also commonly need to list data or delete entries.
    The principles here are much the same as we've seen already. But to implement
    these operations, we'll need some new syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Listing data in views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first allow users to see a list of games they''ve created or that have
    been created by others. Our chosen view engine, Hogan, is based on Mustache, which
    has a very simple syntax for displaying lists. We can add these two lists to our
    `index.hjs` view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to populate these lists, we''ll need a couple of new methods in our
    `games.js` service module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll need to expose these to our index view from our route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our index page shows games created by the current user and provides convenient
    links to games created by others. You can experiment with this functionality by
    using two separate browser sessions again to visit `http://localhost:3000`. The
    result should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing data in views](img/image00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Issuing a delete request from the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow users to remove games that they have created, we''ll first need to
    add a method to our Game class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we can create a new handler for `delete` requests in our games route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can make use of this from the client. The following code is from
    `views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the following code under `public/scripts/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that, unlike GET and POST, jQuery has no convenience function for `delete`
    requests. So we drop back to the lower level `.ajax()` function and specify the
    HTTP method explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: If you visit the application in a browser and create a new game again, you should
    now see a link to delete the game.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up Express views using partials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting a game does not cause the page to refresh, but creating a new game
    does. We can fix this by creating games via an Ajax call, consistent with how
    we delete games. In order for this to work, the client-side script that handles
    the call needs to know which HTML to add to the page when a new game is created.
  prefs: []
  type: TYPE_NORMAL
- en: We could repeat the HTML structure of the view within the client-side JavaScript.
    However, it would be better for the server to return the correct HTML fragment,
    and to reuse the same template for this as it uses it to render the list on the
    page initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by splitting the HTML structure for a game within the list into
    a partial view. This is a view template for an HTML fragment rather than a complete
    page. We add the following code under `views/createdGame.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the view engine that we''re using (Hogan), we need to let views know about
    available partials when rendering them (other view engines allow partials to be
    resolved automatically). The following code is from `routes/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the partial within our main view as follows. We''ll also add IDs
    to our HTML elements, which we will reference from our client-side JavaScript
    shortly. The following code is from `views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update our games route to return only this fragment to the client
    when creating a new game. The following code is from `routes/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can make use of this in our client-side script. The following code
    is from `public/scripts/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have started building out our own application by creating
    new middleware and service modules. We've read user-submitted data from forms
    and acted on it. We've implemented a JSON API on the server side and communicated
    with this from the client using Ajax. We've used partial views to render common
    components.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've seen how to write JavaScript code and implement various functionality
    in Node.js. This is good for prototyping, but isn't enough for a maintainable
    project. It's also important to write automated tests for our code, which is the
    subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
