<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Creating Variables and Mixins"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Creating Variables and Mixins</h1></div></div></div><p>A question: how often have you created components such as buttons, where you've used very similar colors multiple times throughout your code? It's a real pain to manually alter. Using a preprocessor such as SASS or Less makes it easier, but with the overhead of a full-sized library.</p><p>Can we do it differently? Absolutely; throughout the next few chapters, we'll explore different elements of PostCSS, before pulling it all together to produce a preprocessor application later in the book. We'll begin our journey with a look at using variables and mixins; we'll explore the basics of creating them first, before transitioning to support using PostCSS. In this chapter, we'll cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of creating variables and mixins using existing preprocessors</li><li class="listitem" style="list-style-type: disc">Transitioning to using PostCSS equivalents</li><li class="listitem" style="list-style-type: disc">Adding mixin support to PostCSS</li><li class="listitem" style="list-style-type: disc">Examining the differences between standard preprocessors and PostCSS</li></ul></div><p>Let's get cracking!</p><div class="section" title="Introducing variables and mixins"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Introducing variables and mixins</h1></div></div></div><p>So far, we've <a id="id51" class="indexterm"/>covered the basics of installing and configuring PostCSS—although there are a few steps involved, it's an easy process to get started with using the processor. To really <a id="id52" class="indexterm"/>get to know it though, there is no substitute for using it in anger; it's amazing how much you can automate, with just a little care and planning!</p><p>Let's put that to the test and use it to create a couple of simple examples using variables, functions, and mixins. We'll start with creating the original version using SASS, before converting it to use PostCSS plugins. The demos do assume a level of prior knowledge around using SASS, so if you are at all unfamiliar, then you may like to refer to my book, <span class="emphasis"><em>SASS Essentials</em></span>, available from Packt Publishing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>A word of note: we will make good use of the project folders we created back in <a class="link" href="ch01.html" title="Chapter 1. Introducing PostCSS">Chapter 1</a>, <span class="emphasis"><em>Introducing PostCSS</em></span>, where <code class="literal">src</code> will be our in-tray, and <code class="literal">dest</code> will contain the compiled code. Make sure you have this open in a window somewhere on your desktop!</p></div></div><p>Okay, the first step <a id="id53" class="indexterm"/>in this process is to get SASS installed, so let's take a look at <a id="id54" class="indexterm"/>that now.</p><div class="section" title="Setting up SASS"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Setting up SASS</h2></div></div></div><p>Setting up SASS is really easy <a id="id55" class="indexterm"/>when using Gulp; we can use the same format of command to install it as we do for other plugins. The source code for the plugin is available at <a class="ulink" href="https://github.com/dlmanning/gulp-sass">https://github.com/dlmanning/gulp-sass</a>; it's a lightweight frontend for <code class="literal">node-sass</code>, which <a id="id56" class="indexterm"/>in turn is a Node binding for the C+ library, <code class="literal">libsass</code>.</p><p>Let's dive in and take a look at getting it installed:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start, as usual, with Node. Fire up a Node.js command prompt session, then change to the working directory.</li><li class="listitem">At the command prompt, enter the following, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install --save-dev gulp-sass</strong></span>
</pre></div></li><li class="listitem">If all is well, we should see something akin to this screenshot:<div class="mediaobject"><img src="graphics/BO5194_02_01.jpg" alt="Setting up SASS"/></div></li></ol></div><p>Before we continue, though, I would recommend clearing out or saving the contents of the <code class="literal">dest</code> folder elsewhere for safe keeping, after each exercise:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Next up, open a copy of <code class="literal">gulpfile.js</code> in Sublime Text; we need to make a number of changes, beginning with adding a reference to the <code class="literal">gulp-sass</code> plugin (as highlighted):<div class="informalexample"><pre class="programlisting">var reporter = require('postcss-reporter');
var sass = require('gulp-sass');</pre></div><p>SASS will, by default, produce code in unminified format; the addition of <code class="literal">{outputStyle: 'compressed'}</code> in the task will automatically compress the output code. This makes this line redundant, so go ahead and remove it:</p><div class="informalexample"><pre class="programlisting">var cssnano = require('cssnano');</pre></div></li><li class="listitem">We also need to remove the reference to <code class="literal">cssnano</code> on or around line 19, so go ahead and remove this line:<div class="informalexample"><pre class="programlisting">.pipe(postcss([ cssnano ]))</pre></div></li><li class="listitem">On or around line 10, change the name of the styles task to <code class="literal">autoprefixer</code> and the dependency <a id="id57" class="indexterm"/>name to <code class="literal">lint-styles</code>:<div class="informalexample"><pre class="programlisting">gulp.task('autoprefixer', ['lint-styles'], function() {
return gulp.src('src/*.css')</pre></div><p>Then remove these two lines:</p><div class="informalexample"><pre class="programlisting">.pipe(sourcemaps.init())
.pipe(sourcemaps.write('maps/'))</pre></div></li><li class="listitem">In the rename task, modify the <code class="literal">rename</code> task to match this:<div class="informalexample"><pre class="programlisting">gulp.task('rename', ['lint-styles'], function () {
  return gulp.src('dest/*.css')
    .pipe(rename('style.min.css'))
    .pipe(sourcemaps.init())
    .pipe(sourcemaps.write('maps/'))
    .pipe(gulp.dest("dest/"));
});</pre></div></li><li class="listitem">On or around line 25, we need to add in the <code class="literal">lint-styles</code> task—go ahead and add in this block of code, which will check our styles for consistency:<div class="informalexample"><pre class="programlisting">gulp.task("lint-styles", ['sass'], function() {
  return gulp.src("src/*.css")
    .pipe(postcss([ stylelint({
      "rules": {
        "color-no-invalid-hex": 2,
        "declaration-colon-space-before": [2, "never"],
        "indentation": [2, 2],
        "number-leading-zero": [2, "always"]
      }
    }),
    reporter({
      clearMessages: true,
    })
  ]))
});</pre></div></li><li class="listitem">We're almost done. Add in the next task; this tells Gulp about how we should compile any SASS files presented to the task runner:<div class="informalexample"><pre class="programlisting">gulp.task('sass', function () {
  gulp.src('src/*.scss')
    .pipe(sass({outputStyle: 'compressed'}).on('error', sass.logError))
    .pipe(gulp.dest('src/'));
});</pre></div></li><li class="listitem">We need to make a couple more changes. The key task that fires off a call to each of the sub tasks needs to be updated, to reflect the changes to our tasks:<div class="informalexample"><pre class="programlisting">gulp.task('default', ['<span class="strong"><strong>sass</strong></span>', 'lint-styles', '<span class="strong"><strong>autoprefixer</strong></span>', 'rename']);</pre></div></li><li class="listitem">Our last change is to alter the watch facility to check for SASS files, and not pure CSS; go ahead and change the configuration object as shown:<div class="informalexample"><pre class="programlisting">var watcher = gulp.watch('src/<span class="strong"><strong>*.scss</strong></span>', ['default']);</pre></div></li></ol></div><p>At this point, we have set up our <a id="id58" class="indexterm"/>processor to compile SASS files to valid CSS. We can prove this by compiling any SASS file. If all is well, our processor will produce valid style sheets and accompanying source map files automatically. Let's put this to the test as part of our next exercise, where we create an intriguing hover effect for images.</p></div></div></div>
<div class="section" title="Creating a hover effect example"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Creating a hover effect example</h1></div></div></div><p>If you've seen any of my <a id="id59" class="indexterm"/>previous books, then you will see I have a thing about flowers, and in particular orchids; indeed, the cover on my first book was that of a phalaenopsis, or moth orchid! We'll use a couple of images of orchids as the basis for our next demo, as shown in the screenshot over the page, where it shows our desired effect in motion for the top image.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>If you prefer using Less, then please skip to the end of this demo for an example using Less CSS.</p></div></div><p>For this demo, we will need a copy of the <code class="literal">tutorial1A</code> folder from the code download that accompanies this book; make sure you dig that out before continuing:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open up a copy of <code class="literal">style.scss</code> from the <code class="literal">src</code> folder within <code class="literal">tutorial1A</code>; let's take a look at its contents.</li><li class="listitem">At the top of the file, we have a small handful of variables. These define some of the colors used within the code, and set the <code class="literal">$fullsize</code> variable to 100%:<div class="mediaobject"><img src="graphics/BO5194_02_02.jpg" alt="Creating a hover effect example"/></div><p>The sharp-eyed among you will spot that not all colors have been given a value; the reason for this will become clearer later in this chapter.</p></li><li class="listitem">Next up comes an <a id="id60" class="indexterm"/>example of a simple mixin, which converts pixel values to their rem unit equivalents, using <code class="literal">16px</code> as the base equivalent for <code class="literal">1rem</code> unit:<div class="mediaobject"><img src="graphics/BO5194_02_04.jpg" alt="Creating a hover effect example"/></div></li><li class="listitem">To complete the exercise, we need to download a font. The demo uses the Source Sans Pro font <a id="id61" class="indexterm"/>available at <a class="ulink" href="http://www.fontsquirrel.com/fonts/source-sans-pro">http://www.fontsquirrel.com/fonts/source-sans-pro</a>. Go ahead and download it; you will need to <a id="id62" class="indexterm"/>use the <span class="strong"><strong>Generator</strong></span> option available from the black menu to produce a version that can be used online (it creates the CSS we've used in our demo).</li><li class="listitem">At this point, go ahead and drop a copy of the <code class="literal">style.scss</code> file from the <code class="literal">tutorial1A</code> folder into the <code class="literal">src</code> folder in our project area.</li><li class="listitem">We also need the <code class="literal">img</code> folder and the <code class="literal">index.html</code> file—go ahead and copy both across to the root of our project area.</li><li class="listitem">Fire up a Node.js command prompt window, then enter this at the prompt and press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>gulp</strong></span>
</pre></div></li><li class="listitem">If all is well, we should see compressed CSS files and source maps appear in the <code class="literal">dest</code> folder in our project area—copy the <code class="literal">maps</code> folder and <code class="literal">style.min.css</code> into the <code class="literal">css</code> folder of <code class="literal">tutorial1A</code>.</li><li class="listitem">Go ahead and preview the results in a browser. If all is well, we should see two orchid images appear on screen; if you hover over either one, you will see it fly to the left or right, to reveal an information box with information about the orchid:<div class="mediaobject"><img src="graphics/BO5194_02_03.jpg" alt="Creating a hover effect example"/></div></li></ol></div><p>Interesting effect, huh? It's a <a id="id63" class="indexterm"/>simple animation that uses <code class="literal">scale()</code> to shrink the image to <code class="literal">0.5</code> (or 50%) of its size and slides it to the right, before sliding in the <code class="literal">infobox</code> immediately behind it. Take the mouse off the image and the reverse happens—it's the sample principle for the second image—but in reverse; the code sets an <code class="literal">ltr</code> and <code class="literal">rtl</code> <a id="id64" class="indexterm"/>class to determine which direction the image should move in the demo.</p><div class="section" title="Using Less CSS as an alternative"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Using Less CSS as an alternative</h2></div></div></div><p>A copy of this <a id="id65" class="indexterm"/>demo using the equivalent code from the Less CSS pre-processor is available in the code download that accompanies <a id="id66" class="indexterm"/>this book. It's in the <code class="literal">Tutorial1B</code> folder if your preference is to use the Less CSS pre-processor; you will need to install the <code class="literal">gulp-less</code> <a id="id67" class="indexterm"/>plugin from <a class="ulink" href="https://github.com/plus3network/gulp-less">https://github.com/plus3network/gulp-less</a>, using NodeJS (in the same manner as other plugins that we've installed). An updated copy of the Gulp task file is also included in this folder, along with completed versions of the CSS code.</p></div></div>
<div class="section" title="Transitioning to using PostCSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Transitioning to using PostCSS</h1></div></div></div><p>Up until now, we've used <a id="id68" class="indexterm"/>SASS to build our demo; granted, it's not a particularly complex one, but as I always say, we must start somewhere!</p><p>Our demo is a perfect example of how we can introduce PostCSS to provide replacements for the SASS variables and mixins we've used—for this, we will avail ourselves of three plugins, namely <code class="literal">postcss-variables</code>, <code class="literal">postcss-mixins</code>, and <code class="literal">postcss-calc</code>. The first two should be self-explanatory; the third is required in the replacement font mixin that we've used in our code.</p><p>Okay, enough chit-chat, let's get stuck in and begin to alter our code; we'll start with adding variable support.</p></div>
<div class="section" title="Adding variable support to PostCSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Adding variable support to PostCSS</h1></div></div></div><p>The beauty of <a id="id69" class="indexterm"/>PostCSS plugins is that most (if not all) can be <a id="id70" class="indexterm"/>installed using the same method as PostCSS itself, we can use the package manager of Node.js to handle the process.</p><p>We'll start with <code class="literal">postcss-css-variables</code>, which we will use to handle variable support; the source for this plugin is available from <a class="ulink" href="https://github.com/MadLittleMods/postcss-css-variables">https://github.com/MadLittleMods/postcss-css-variables</a>. Let's get it installed:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Fire up a NodeJS command prompt, then change the working directory to our project area.</li><li class="listitem">At the command prompt, enter the following command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install --save-dev postcss-css-variables</strong></span>
</pre></div></li><li class="listitem">If all is well, we should see the results of the installation appear, as shown in this screenshot:<div class="mediaobject"><img src="graphics/BO5194_02_08.jpg" alt="Adding variable support to PostCSS"/></div></li></ol></div><p>At this point, Node <a id="id71" class="indexterm"/>will have also added an entry to the <code class="literal">package.json</code> file for the new plugin. Perfect—we can now put it to good use and switch to using <a id="id72" class="indexterm"/>the plugin in place of using SASS. Let's take a look at how to achieve this, as part of the upcoming exercise.</p></div>
<div class="section" title="Updating our hover effect demo"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Updating our hover effect demo</h1></div></div></div><p>If we're altering code to <a id="id73" class="indexterm"/>use PostCSS for the first time, it naturally makes sense to start with something simple; incorporating variables and mixins into our code is the perfect place to begin.</p><p>For this next exercise, we're going to create a handful of variables to store some values, then add a mixin to handle styles for the fonts used in the demo. Let's make a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by opening up a copy of <code class="literal">gulpfile.js</code> from the root of our project area—we first need to make some changes to accommodate using the new plugin.</li><li class="listitem">In <code class="literal">gulpfile.js</code>, add this line immediately below the first block of <code class="literal">var</code> statements—this should be on or around line 9:<div class="informalexample"><pre class="programlisting">var cssvariables = require('postcss-css-variables');</pre></div></li><li class="listitem">We now need to make some changes to our gulp task file—we'll start with the simplest, which is to remove the <code class="literal">var</code> reference to SASS, as we will no longer need it:<div class="informalexample"><pre class="programlisting">var sass = require('gulp-sass');</pre></div><p>Now that we have a reference to the <code class="literal">postcss-css-variables</code> plugin, we need to make use of it in our tasks. Go ahead and amend the highlighted lines of code in the <code class="literal">autoprefixer</code> task, as indicated; this also removes the dependency on the lint-styles task, as this is no longer needed:</p><div class="informalexample"><pre class="programlisting">gulp.task('autoprefixer', function() {
  return gulp.src('src/*.css')
  .pipe(postcss([ autoprefixer, cssnano, <span class="strong"><strong>cssvariables(/* options */)</strong></span> ]))
  <span class="strong"><strong>.pipe(gulp.dest('dest/'));</strong></span>
</pre></div></li><li class="listitem">Note that we've also reinstated the <code class="literal">cssnano</code> command—you will also need to add this line in as a variable declaration, as indicated:<div class="informalexample"><pre class="programlisting">var rename = require('gulp-rename');
<span class="strong"><strong>var cssnano = require('cssnano');</strong></span>
</pre></div></li><li class="listitem">A little further down, on <a id="id74" class="indexterm"/>or around line 25, change the code as highlighted, as we will no longer use SASS to compile our code; we can tweak the order in which each task is run:<div class="informalexample"><pre class="programlisting">gulp.task("lint-styles", [<span class="strong"><strong>'autoprefixer'</strong></span>], function() {</pre></div></li><li class="listitem">Next up, we can remove the SASS task in its entirety:<div class="informalexample"><pre class="programlisting">gulp.task('sass', function () {
  gulp.src('src/*.scss')
  .pipe(sass({outputStyle: 'compressed'})
    .on('error', sass.logError))
    .pipe(gulp.dest('src/'));
});</pre></div></li><li class="listitem">Toward the end of the file, go ahead and alter the default task as indicated—we don't need to call the SASS task, as it has now been removed:<div class="informalexample"><pre class="programlisting">gulp.task('default', ['lint-styles', 'autoprefixer', 'rename']);</pre></div></li><li class="listitem">Alter the <code class="literal">gulp.watch</code> command to look for plain CSS files in the <code class="literal">src</code> folder—we're not using SASS, so the reference to <code class="literal">scss</code> format files is now invalid and needs to be changed:<div class="informalexample"><pre class="programlisting">var watcher = gulp.watch('<span class="strong"><strong>src/*.css</strong></span>', ['default']);
watcher.on('change', function(event) {</pre></div><p>At this point, if all is well, we should have a working gulp task file that we can now use to compile our code. Let's go ahead and start to convert the code in our orchid demo, to use PostCSS:</p></li><li class="listitem">We'll start by saving a copy of the <code class="literal">Tutorial2</code> folder from the code download that accompanies this book, locally, to within the project area we created under <code class="literal">c:\wamp\www</code>, back in <a class="link" href="ch01.html" title="Chapter 1. Introducing PostCSS">Chapter 1</a>, <span class="emphasis"><em>Introducing PostCSS</em></span>.</li><li class="listitem">Open up a copy of <code class="literal">style.css</code> from within the <code class="literal">src</code> folder of the <code class="literal">Tutorial2</code> folder. At the top of the file, remove lines 1 to 14 (the variables and mixin code), so that the file starts with the <code class="literal">font-face</code> declaration.</li><li class="listitem">In its place, add the following lines—these are the replacement variable assignments:<div class="informalexample"><pre class="programlisting">:root {
  --dark-grayish-green: #868a7b;
  --very-dark-gray: #333333;
  --white: #fff;
  
  --fullsize: 100%;
}</pre></div></li><li class="listitem">Further down, look <a id="id75" class="indexterm"/>for the <code class="literal">html</code>, <code class="literal">body {</code> declaration, and alter it as indicated—note the syntax used for the <code class="literal">var</code> statements; this is not the same as standard SASS. We've changed it to the format supported by the <code class="literal">postcss-css-variables </code>plugin:<div class="informalexample"><pre class="programlisting">html, body {
  width: var(--fullsize);
  padding: 0;
  margin: 0;
  height: var(--fullsize);
  min-width: var(--fullsize);
  max-width: var(--fullsize);
  overflow: hidden;
  background: var(--dark-grayish-green);
}</pre></div></li><li class="listitem">We added the <code class="literal">--fullsize</code> variable at the top of our style sheet—let's make use of it now and update the <code class="literal">img</code> rule accordingly:<div class="informalexample"><pre class="programlisting">img {
  width: var(--fullsize);
  height: var(--fullsize);
}</pre></div></li><li class="listitem">The final change we will make is to the <code class="literal">.info</code> class—go ahead and alter the background attribute as indicated:<div class="informalexample"><pre class="programlisting">/* ------ Hover Effect Styles ------ */
.info {
  background: var(--very-dark-gray);
}</pre></div><p>Our code changes are complete, so go ahead and save the file—once done, fire up a NodeJS command prompt, and change to the project working area.</p></li><li class="listitem">Save the file as <code class="literal">styles.css</code> into the <code class="literal">src</code> folder of our project area.</li><li class="listitem">Switch to the NodeJS command prompt, then enter the usual command at the prompt, and press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>gulp</strong></span>
</pre></div></li><li class="listitem">Copy the compiled code back to the <code class="literal">css</code> folder within <code class="literal">Tutorial2</code>. If all is well, when we preview the results in a browser, we should see our demo continue to work as shown at the start of the first part of this exercise.</li></ol></div><p>Phew, there were a fair few steps there! There is a copy of the completed stylesheets, both prior to and post <a id="id76" class="indexterm"/>compilation, available in the code download that accompanies this book: they can be found in the <code class="literal">css</code> | <code class="literal">completed</code> folder. You will need to rename the two style sheet files to just <code class="literal">style.css</code> for them to work correctly.</p><p>If you want to see the effects of compiling variables, without committing changes to code, then have a look at the playground offered with this plugin, at <a class="ulink" href="https://madlittlemods.github.io/postcss-css-variables/playground/">https://madlittlemods.github.io/postcss-css-variables/playground/</a>. It's a great way to get accustomed to using the <code class="literal">postcss-css-variables</code> plugin, before diving in and editing production code.</p><p>Okay, let's change tack; we've covered a number of key concepts in our demo, so let's take a moment to let the proverbial dust settle, and explore what we've learned through the demo.</p><div class="section" title="Taking it a step further"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Taking it a step further</h2></div></div></div><p>Over the last few pages, we've created a simple demo, which shows off animated information boxes for a couple of orchid images. There's nothing outrageous or complex about what we've done, but nevertheless, it serves to illustrate some key points about using this plugin, and PostCSS in general:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Although we used SASS to precompile our CSS code prior to conversion, we could easily have used another pre-processor, such as Less CSS or Stylus. The key here is to work as much as possible within the confines of a task runner such as Gulp, so that we don't need to introduce another technology into the mix.</li><li class="listitem" style="list-style-type: disc">It is essential to note that although converting the code <span class="emphasis"><em>looks</em></span> straightforward, the plugin does not compile in the same manner as pre-processors such as SASS would compile. It makes a direct translation from SASS to Less CSS difficult for anything more than simple code.</li><li class="listitem" style="list-style-type: disc">In this example, the key to understanding how it works is to follow the CSS Custom Properties <a id="id77" class="indexterm"/>Module Level 1 document from the W3C, which is available at <a class="ulink" href="https://drafts.csswg.org/css-variables/">https://drafts.csswg.org/css-variables/</a>. The trick here is to be aware of CSS specificity, or which element takes precedence over others; in this respect, PostCSS does not simply replace variables with values, but compiles code based on calculating CSS specificity. When using PostCSS, it is likely you will see the <code class="literal">:root</code> pseudo-element being used frequently—it's worth getting acquainted with how it works!<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>For an explanation of how CSS specificity works, please refer to <a class="ulink" href="http://vanseodesign.com/css/css-specificity-inheritance-cascade/">http://vanseodesign.com/css/css-specificity-inheritance-cascade/</a>. If needed, we can consider using a plugin to increase specificity—check out the <code class="literal">postcss-increase-specificity</code> plugin at <a class="ulink" href="https://github.com/MadLittleMods/postcss-increase-specificity">https://github.com/MadLittleMods/postcss-increase-specificity</a>.</p></div></div></li><li class="listitem" style="list-style-type: disc">The modular nature of PostCSS means that we can be selective about the plugins we use—in this instance we used the <code class="literal">postcss-css-variables</code> plugin, which gives more flexibility than others such as <code class="literal">postcss-custom-properties</code>. As an <a id="id78" class="indexterm"/>alternative, we might consider separating our variables into a separate document, and import them in using the <code class="literal">postcss-constants</code> plugin (which is available at <a class="ulink" href="https://github.com/macropodhq/postcss-constants">https://github.com/macropodhq/postcss-constants</a>).</li><li class="listitem" style="list-style-type: disc">If we use the <code class="literal">postcss-css-variables</code> plugin, we can either store the values in the code itself, or hive them off into the gulp task file; an example of the latter would look like this:<div class="informalexample"><pre class="programlisting">var postcss = require('postcss');
var cssvariables = require('postcss-css-variables');

postcss([
  cssvariables({
    variables: {
      '—foo-var': { '100px', isImportant: true },
      '--other-var': { value: '#00CC00' },
      '--important-var': { value: '#ffCC00' }
    }
  })
])
.process(css, opts);</pre></div></li></ul></div><p>In short, we create a reference to each variable within the configuration object for <code class="literal">cssvariables</code>, as the alias for the <code class="literal">postcss-css-variables</code> plugin.</p><p>Creating an object map using this approach can have mixed benefits. For some, it reduces issues around <span class="strong"><strong>separation </strong></span><a id="id79" class="indexterm"/>
<span class="strong"><strong>of concerns</strong></span>, where we can keep more PostCSS code within the task file, and less within our style sheet. This can make for a task file that is harder to read; it's not a good route to take if you have lots of variables to define. In this instance, we would be better off exporting them to an import file and referencing them at compilation.</p><p>If there is one important message at this point, it can be that of flexibility—the modular nature of PostCSS means that we can be free to pick and choose how we proceed; it really is a case of weighing up the pros and cons of using a plugin, and making a decision as to whether this best fits our <a id="id80" class="indexterm"/>needs, or if we need to look for an alternative solution.</p></div></div>
<div class="section" title="Setting the order of plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Setting the order of plugins</h1></div></div></div><p>At this point, there is a key <a id="id81" class="indexterm"/>part of PostCSS we need to cover: the order we use when calling plugins in our task runner file. This might seem a little odd, but there are two good reasons for considering this when developing with PostCSS:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first reason is simple—it's about making sure that we maintain a logical order of when tasks are completed at compilation.</li><li class="listitem" style="list-style-type: disc">The second is a little more obscure, and will come with experience—some plugins need to be defined in the task file in a certain order, for them to work correctly.</li></ul></div><p>Let's explore what this means:</p><p>If we take a look at the gulp task file that we've slowly been building up, you will notice a key difference between lines 13 and 19; and no, it's not the task name, before you ask! The difference is the <code class="literal">['lint-styles']</code> constraint—this forces Gulp not to run this task until its predecessor has completed:</p><div class="mediaobject"><img src="graphics/BO5194_02_06.jpg" alt="Setting the order of plugins"/></div><p>I know this might sound like common sense, and that I am only preaching what you may already know, but getting the order that plugins are called in PostCSS is critical to the successful compilation of your file.</p><p>As an example, when researching for this book, I frequently found that either my source map was only being produced for an uncompressed version of my style sheet, or that the minified style sheet wasn't being created at the right point. Simple issues, but tweaking the order can have a serious impact on what happens and when!</p><p>Continuing with the theme of order, it is likely you may see notes akin to this when browsing the source site of a PostCSS plugin:</p><div class="mediaobject"><img src="graphics/BO5194_02_07.jpg" alt="Setting the order of plugins"/></div><p>This underlines why getting the <a id="id82" class="indexterm"/>order of your plugins is essential for an effective result: not only will tasks be completed in the right order and produce the expected results, but some plugins won't even work. This should not necessarily be taken as being a fault; there will be a valid reason that means plugin <span class="emphasis"><em>X</em></span> must come before plugin <span class="emphasis"><em>Y</em></span>. The key thing here is that we take any constraints into consideration. It is worth checking, as others may add patch support to remove constraints, or fix it through forking their own version of the plugin.</p><p>Okay, time to change focus and take a look at some different functionality: mixins. For the uninitiated, this is a key function frequently used in preprocessors such as SASS, where we can <span class="emphasis"><em>mix-in</em></span> (yes, pun intended!) blocks of code.</p><p>The idea here being that we can create anything, from a simple few lines to a complex, dynamic code excerpt that PostCSS will compile into our code and use to produce valid CSS. Let's dive in and take a closer look.</p></div>
<div class="section" title="Creating mixins with PostCSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Creating mixins with PostCSS</h1></div></div></div><p>Our orchid <a id="id83" class="indexterm"/>demo so far uses a number of variables to define values in our code. While this works well, it is somewhat limiting; after all, creating lots of variables to handle different values is an expensive use of resources!</p><p>A smarter approach is <a id="id84" class="indexterm"/>using mixins; this works well when we can group several statements together as a single definition, then clone this definition into multiple rule sets. Users of pre-processors will of course recognize this functionality; the PostCSS team have created a plugin to offer similar functionality within PostCSS.</p><p>The plugin source is available from <a class="ulink" href="https://github.com/postcss/postcss-mixins">https://github.com/postcss/postcss-mixins</a>, and can be installed via Node, using the same method we've covered throughout this chapter. We will also make use of the <code class="literal">postcss-calc</code> plugin (from <a class="ulink" href="https://github.com/postcss/postcss-calc">https://github.com/postcss/postcss-calc</a>) to create a simple mixin that handles pixel fall-back for rem values in our code. Let's dive in and see how it works in action:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start—as always—by installing the <code class="literal">postcss-mixins</code> plugin; for this, fire up a NodeJS command prompt, then change the working folder to our project area.</li><li class="listitem">At the prompt, enter each command separately, pressing <span class="emphasis"><em>Enter</em></span> after each:<div class="informalexample"><pre class="programlisting">npm install --save-dev postcss-mixins
npm install --save-dev postcss-calc</pre></div></li><li class="listitem">If all is well, we <a id="id85" class="indexterm"/>should see the results of the <a id="id86" class="indexterm"/>output on-screen, as shown in this screenshot:<div class="mediaobject"><img src="graphics/BO5194_02_08.jpg" alt="Creating mixins with PostCSS"/></div></li></ol></div><div class="section" title="Updating our hover effect demo"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Updating our hover effect demo</h2></div></div></div><p>At this point we <a id="id87" class="indexterm"/>will have support for mixins within PostCSS installed. Let's make use of them by updating our gulp task file and style sheet. We'll begin with the gulp task file:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's start by opening a copy of <code class="literal">gulpfile.js</code> from our project area, then adding the following lines immediately below the block of <code class="literal">var</code> declarations (on or around line 10):<div class="informalexample"><pre class="programlisting">var cssmixins = require('postcss-mixins');
var calc = require('postcss-calc');</pre></div></li><li class="listitem">Next, go ahead and alter this line, from within the <code class="literal">autoprefixer</code> task:<div class="informalexample"><pre class="programlisting">.pipe(postcss([ autoprefixer, cssvariables(/* options */), <span class="strong"><strong>cssmixins(/* options */), calc(/*options*/)</strong></span> ]))</pre></div></li><li class="listitem">Save the file. We now need a copy of the demo files from the code download that accompanies this book—go ahead and save a copy of <code class="literal">Tutorial3</code> to within our project area.</li><li class="listitem">Open a copy of <code class="literal">style.css</code> from within the <code class="literal">src</code> folder, then add this block of code immediately after the variable declarations declared in the <code class="literal">--root</code> rule:<div class="informalexample"><pre class="programlisting">@define-mixin fontstyle $size, $color {
  font-size: $(size)px;
  font-size: calc($size/16)rem;
  color: $color;
}</pre></div></li><li class="listitem">With the <a id="id88" class="indexterm"/>mixin in place, we now need to adjust our code to make use of the mixin; this requires a few changes. The first change is in the <code class="literal">h3</code> rule declaration:<div class="informalexample"><pre class="programlisting">h3 {
  <span class="strong"><strong>@mixin fontstyle 32, #fff;</strong></span>
  text-transform: uppercase;</pre></div></li><li class="listitem">A little further down, go ahead and change the first two lines of the <code class="literal">.info h3</code> rule, as indicated:<div class="informalexample"><pre class="programlisting">.info h3 {
  <span class="strong"><strong>@mixin fontstyle 20, #fff;</strong></span>
</pre></div></li><li class="listitem">The third and final change is in the rule for <code class="literal">.info p</code>. Change it as shown:<div class="informalexample"><pre class="programlisting">.info p {
  <span class="strong"><strong>@mixin fontstyle 12, #bbb;</strong></span>
  padding: 50px 5px;</pre></div></li><li class="listitem">Save the file, then copy it to the <code class="literal">src</code> folder in our project area.</li><li class="listitem">Fire up a NodeJS command prompt, then switch to the project area, enter the usual command at the prompt, and press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>gulp</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>You may see some option messages from stylelint: these can be safely ignored for now, but we will explore how to optimize this later in the book.</p></div></div></li><li class="listitem">Copy the compiled code back to the <code class="literal">src</code> folder within <code class="literal">Tutorial3</code>. If all is well, when we preview the results in a browser, we should see our demo continue to work as shown at the start of the first part of this exercise.</li></ol></div><p>Although our demo won't appear any different, there will be a noticeable difference in the code—a quick peek using a DOM inspector such as Firebug shows the use of <code class="literal">rem</code> values:</p><div class="mediaobject"><img src="graphics/BO5194_02_09.jpg" alt="Updating our hover effect demo"/></div><p>The use of mixins <a id="id89" class="indexterm"/>does raise some important points. Indeed, one might be forgiven for thinking they simply replicate functionality from SASS. The plugin we've used does not follow the same format, even if the principles are the same; let's pause for a moment and take a look at how these stack up against standard processors.</p></div><div class="section" title="Comparing PostCSS to standard processors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Comparing PostCSS to standard processors</h2></div></div></div><p>The use <a id="id90" class="indexterm"/>of mixins is a great way to automatically insert pre-defined blocks of code, either static or dynamic, into our stylesheet, at the compilation phase.</p><p>The key thing to note is that, although the end result may be similar, the similarity is just in name; the mixin plugin we've used was not designed to replicate existing functionality available within SASS. Instead, this plugin exposes the power of JavaScript within PostCSS, and should be used to define function mixins, as a replacement for if or while statements that are not available within PostCSS.</p><p>This is particularly true if we need to change any property names within the mixin; an example of this would be when referencing multiple images that each need similar style classes to be applied:</p><div class="informalexample"><pre class="programlisting">require('postcss-mixins')({
  mixins: {
    icons: function (mixin, dir) {
      fs.readdirSync('/images/' + dir).forEach(function (file) {
        var icon = file.replace(/\.svg$/, '');
        var rule = postcss.rule('.icon.icon-' + icon);
        rule.append({
          prop:  'background',
          value: 'url(' + dir + '/' + file + ')'
        });
        mixin.replaceWith(rule);
      });
    }
  }
});</pre></div><p>If we were to call this mixin with <code class="literal">@mixin icons signin;</code> from our code, we would see this as a result:</p><div class="informalexample"><pre class="programlisting">.icon.icon-back { background: url(signin/back.svg) }
.icon.icon-secret { background: url(signin/secret.svg) }</pre></div><p>This does pose <a id="id91" class="indexterm"/>an interesting question: where should the cut-off point between using JavaScript in our task file be, in comparison to our CSS? Taking this approach does mean that we have the benefit of using standard JavaScript, but at the expense of simplicity!</p><p>This is one of the decisions you will need to make as a developer. PostCSS's flexibility means that not only do we need to choose the right plugin, but that the order they are all called in can also have an effect on the outcome of our code. In this instance, an alternative plugin—<code class="literal">postcss-simple-vars</code>—shares the same syntax as <code class="literal">postcss-mixins</code>, but does not support changing of property names.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>We can also consider using the <code class="literal">postcss-nested</code> plugin if our mixins are stored within nested statements; this is something we will cover in the next chapter.</p></div></div><p>But, to bring it back to our example: we used the classic mixin for providing pixel fall-back when using older versions of IE.</p><p>We could have used an alternative plugin here, in the form of <code class="literal">postcss-simple-mixins</code> (available from <a class="ulink" href="https://www.npmjs.com/package/postcss-simple-mixin">https://www.npmjs.com/package/postcss-simple-mixin</a>). This is designed to provide simple support for mixins, and doesn't have the baggage associated with <code class="literal">postcss-mixins</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>A word of note though: the <code class="literal">postcss-simple-mixins</code> plugin has been deprecated, although it is still available for use. It does not support nesting or the use of arguments.</p></div></div><p>The key consideration, though, will depend on what you plan to achieve within your code; choosing the right plugin will reduce the inclusion of redundant functionality and help keep our custom processor as lean as possible.</p><p>There is another reason why choosing plugins is critical: instead of using a mixin to just support older versions of IE, we can use the <code class="literal">postcss-pxtorem</code> plugin to generate <code class="literal">rem</code> values during <a id="id92" class="indexterm"/>compilation. After all, although most browsers have supported <code class="literal">rem</code> units for some time, there is always one that is late to the party:</p><div class="mediaobject"><img src="graphics/BO5194_02_10.jpg" alt="Comparing PostCSS to standard processors"/><div class="caption"><p>Screenshot taken from the CanIUse site, at <a class="ulink" href="http://www.caniuse.com">http://www.caniuse.com</a>
</p></div></div><p>Switching to using this plugin has the added benefit of simplifying our code, as the server can handle the grunt work of replacing pixel values with the equivalent <code class="literal">rem</code> units. The grunt work can be shifted to a central location, so that anyone using it will receive consistent results.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>It's important to also note that the cross over between mixins and functions also exists within PostCSS. We will explore using functions more in <a class="link" href="ch05.html" title="Chapter 5. Managing Colors, Images, and Fonts">Chapter 5</a>, <span class="emphasis"><em>Managing Colors, Images, and Fonts</em></span>, when we learn how PostCSS can be used to make our lives easier when working with colors or media.</p></div></div><p>Okay, onwards we go. Time to switch topics completely, and take a look at another key part of PostCSS: creating loops. Anyone familiar with SASS or Less will be aware of how mundane it can get when applying very similar styles to identical objects; a perfect example are the classic social media icons that frequently grace posts on a page. PostCSS has a plugin that allows us to mimic this functionality, so let's explore how to use it in action.</p></div></div>
<div class="section" title="Looping content with PostCSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Looping content with PostCSS</h1></div></div></div><p>A question: how <a id="id93" class="indexterm"/>often have you come across instances where you have a <a id="id94" class="indexterm"/>number of very similar images that share styles, but at the same time need to have individual styles applied? Sound familiar?</p><p>I am of course talking about instances such as list items, grid layouts, and the classic social media icons we see littered all over the Internet. We can of course simply write rules to cover each image, but as I am sure you will agree, it's not the smartest approach! Instead, we can use the power of the <code class="literal">@each</code> statement to iterate through each item and apply each style using string interpolation.</p><p>The <code class="literal">@each</code> plugin, by Alexander Madyankin, is one of two ways to incorporate a facility to loop through content; the source for this plugin is available from <a class="ulink" href="https://github.com/outpunk/postcss-each">https://github.com/outpunk/postcss-each</a>. The other plugin, postcss-for (available from <a class="ulink" href="https://github.com/antyakushev/postcss-for">https://github.com/antyakushev/postcss-for</a>), takes a different approach—the difference between the two is that the former works on objects, while the latter must use a range of numbers to apply styles.</p><p>If we take the second plugin for a moment, we have to loop through a consecutive range of numbers in order to produce our result. So, something akin to this:</p><div class="informalexample"><pre class="programlisting">@for $x from 1 to 3 {
  .grid-$x { width: $(x)px; }
}</pre></div><p>…would produce this, when compiled:</p><div class="informalexample"><pre class="programlisting">.grid-1 {
  width: 1px
}
.grid-2 {
  width: 2px
}
.grid-3 {
  width: 3px
}</pre></div><p>Seems pretty straightforward, right? Here comes the rub, though: unlike SASS, we can't use variables to define that range by default; this plugin must be defined <span class="strong"><strong>before any instance of</strong></span> <code class="literal">postcss-nested</code> and <code class="literal">postcss-simple-vars</code> plugins. In PostCSS, we iterate through <span class="strong"><strong>all</strong></span> of the values inclusively (that is, one to three in our example), which is not the same as in SASS.</p><p>It's in cases like this that we must decide between using this plugin on its own, or with <code class="literal">postcss-custom-properties</code> and <code class="literal">postcss-for-variables</code>. This is why it is key to fully understand what you need to achieve, and the capabilities of plugins available, so that we can choose the most effective combination to suit our needs. The great thing about PostCSS is its flexibility, speed, and modular design; this modularity and flexibility can also be seen as its Achilles heel, as tweaking the choice and order of plugins can have a real impact on our code!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>We can of course change completely, and use a separate fork of the postcss-for plugin, available from <a class="ulink" href="https://github.com/xori/postcss-for">https://github.com/xori/postcss-for</a>. This caters for dollar variables.</p></div></div><p>Let's put some of this <a id="id95" class="indexterm"/>into practice. Before we get stuck in to nesting with PostCSS in the next chapter, we'll round out this one with a simple demo that uses a group of social media icons and PostCSS to set up styling automatically for us.</p><div class="section" title="Iterating through @each statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Iterating through @each statements</h2></div></div></div><p>Staying with the <a id="id96" class="indexterm"/>looping theme, but on a different tack, in place of using the <code class="literal">for</code> statement, we can achieve similar effects with <code class="literal">@each</code>, but only if the target is an element on the page.</p><p>I am of course talking <a id="id97" class="indexterm"/>about elements such as buttons or menu items; these elements will share the same styling, but require unique IDs to allow us to interact with them. It goes without saying that we could simply create a shared base class and add multiple classes for each element…</p><p>But we can do better than that: most preprocessors have in-built functionality that allows us to iterate through elements and apply CSS styling to each element. Thankfully, PostCSS is no different; we can achieve the same result using the postcss-each plugin, available from <a class="ulink" href="https://github.com/outpunk/postcss-each">https://github.com/outpunk/postcss-each</a>. It's a cinch to install, and we can use it to add elements such as social media icons to the foot of a page, and style them. I feel a demo coming on, so let's dive in and take a look:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start with installing the plugin, so go ahead and fire up a NodeJS command prompt, and change the working directory to our project area.</li><li class="listitem">At the prompt, enter this command to install the <code class="literal">postcss-each</code> plugin, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install --save-dev postcss-each</strong></span>
</pre></div></li><li class="listitem">If all is well, we should see the customary confirmation that the plugin is installed:<div class="mediaobject"><img src="graphics/BO5194_02_11.jpg" alt="Iterating through @each statements"/></div></li></ol></div><p>With the plugin now in place, let's move on and update our gulp file:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to make three changes to our gulp file, so go ahead and open a copy from the project area in your usual text editor.</li><li class="listitem">First, go ahead and remove lines 9 to 11; they contain the variable declarations <a id="id98" class="indexterm"/>for the <code class="literal">postcss-css-variables</code> and <code class="literal">postcss-mixins</code> plugins.</li><li class="listitem">On or around what <a id="id99" class="indexterm"/>is now line 8, we should see the variable declaration for <code class="literal">postcss-calc</code>. Immediately, below, add the following line:<div class="informalexample"><pre class="programlisting">var eachloop = require('postcss-each');</pre></div></li><li class="listitem">In the main <code class="literal">autoprefixer</code> task, we need to alter the <code class="literal">postcss</code> call; remove this from line 13:<div class="informalexample"><pre class="programlisting">cssvariables(/* options */), cssmixins(/* options */), calc(/*options*/),</pre></div><p>We should be left with this (changes have been highlighted):</p><div class="informalexample"><pre class="programlisting">.pipe(postcss([ autoprefixer, cssnano(), foreach(/*options*/) ]))</pre></div></li></ol></div><p>At this point, we can save the file. It is now ready for us to process the CSS required for our next demo. For this next exercise, we will need to avail ourselves of some suitable social media icons. I've used the ones by Nathan Brown, available at <a class="ulink" href="http://wegraphics.net/downloads/free-stained-and-faded-social-media-icons/">http://wegraphics.net/downloads/free-stained-and-faded-social-media-icons/</a>. We'll use the Twitter, LinkedIn, and YouTube images.</p><p>Let's make a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start with a look at the SASS version of this demo. It's a simple example, but illustrates perfectly how we can use the <code class="literal">@each</code> function to iterate through each image and apply the appropriate style:<div class="informalexample"><pre class="programlisting">$social: twitter, linkedin, youtube;

.social-icon {
  // shared information here
  background: 50% no-repeat;
  background-size: 100%;
  float: left;
  height: 50px;
  width: 50px;
   
  // unique information loops here
  @each $network in $social {
    &amp;.#{$network} {
      background-image: url("../img/#{$network}.png");
    }
  }
}</pre></div></li><li class="listitem">To compile the code, go ahead and copy the <code class="literal">Tutorial4</code> folder to our project area.</li><li class="listitem">Replace the existing <code class="literal">gulpfile.js</code> with a copy from the <code class="literal">Tutorial1A</code> folder—this contains the appropriate commands to compile the code—we need to use the original version built to compile SASS code, not PostCSS, hence the change.</li><li class="listitem">Take a copy of <a id="id100" class="indexterm"/><code class="literal">style.scss</code> from the <code class="literal">src</code> folder of the <code class="literal">Tutorial4</code> folder, then drop it into the <code class="literal">src</code> folder of our project area.</li><li class="listitem">Next, fire up a NodeJS <a id="id101" class="indexterm"/>command prompt window, then change the working folder to our project area.</li><li class="listitem">At the prompt, enter this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>gulp</strong></span>
</pre></div><p>Keep the command prompt window open for now, we will use it again shortly.</p></li><li class="listitem">Once the code has compiled, copy the contents of the <code class="literal">dest</code> folder back to the <code class="literal">css</code> folder in the <code class="literal">Tutorial4</code> folder.</li></ol></div><p>If all is well, we should have three icons showing, when previewing the results in a browser. Nothing outrageous here: we have the base rule that applies to all of the icons, which is followed by the individual classes required to handle each icon itself:</p><div class="informalexample"><pre class="programlisting">.social-icon {
  background: 50% no-repeat;
  background-size: 100%;
  float: left;
  height: 50px;
  width: 50px;
}

.social-icon.twitter {
  background-image: url("../img/twitter.png");
}

.social-icon.linkedin {
  background-image: url("../img/linkedin.png");
}

.social-icon.youtube {
  background-image: url("../img/youtube.png");
}</pre></div><p>So, how would this <a id="id102" class="indexterm"/>look in PostCSS? Well, surprising as <a id="id103" class="indexterm"/>it may be, there isn't a great deal of change needed.</p></div><div class="section" title="Switching to using PostCSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Switching to using PostCSS</h2></div></div></div><p>We only need to <a id="id104" class="indexterm"/>change it in two places within our CSS file. I've also separated the nested code, to make it easier to view:</p><div class="informalexample"><pre class="programlisting">.social-icon {
  // shared information here
  background: 50% no-repeat;
  background-size: 100%;
  float: left;
  height: 50px;
  width: 50px;
}</pre></div><p>The changes we need to make are highlighted in this block of code:</p><div class="informalexample"><pre class="programlisting">@each $media in twitter, linkedin, youtube {
  . $(img) {
    background: url('../img/$(media).png');
  }
}</pre></div><p>Our gulp file also needs to change. Let's work through the steps involved to make the switch to PostCSS:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We first need to replace the gulp file—go ahead and delete the copy at the root of the project area, then replace it with a copy from the <code class="literal">Tutorial4</code> folder in the code download.</li><li class="listitem">From the code download that accompanies this book, extract a copy of <code class="literal">style</code>—<code class="literal">pre compile.css</code>, and rename it as <code class="literal">style.css</code>. Drop it in the <code class="literal">src</code> folder of our project area.</li><li class="listitem">Revert back to the command prompt, then enter <code class="literal">gulp</code> at the prompt and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should see the compiled style sheets appear in the <code class="literal">dest</code> folder, along with the source maps.</li><li class="listitem">Copy the contents of the <code class="literal">dest</code> folder in project area to the <code class="literal">css</code> folder within our local copy of the <code class="literal">Tutorial4</code> folder.</li><li class="listitem">Try <a id="id105" class="indexterm"/>previewing the results in a browser; if all is working as expected, we should see these icons appear:<div class="mediaobject"><img src="graphics/BO5194_02_12.jpg" alt="Switching to using PostCSS"/></div></li></ol></div><p>Granted, it is a simple exercise, but then I've always been a fan of keeping things simple! Anyone can write CSS styles, but for me the "step up" is knowing that quantity does not always beat quality, and that there is something to be said for following the <span class="emphasis"><em>KISS</em></span> principle, <span class="emphasis"><em>Keep It Simple…</em></span> Yes, you get the idea!</p><p>But, just to show how flexible this plugin is, try this as an exercise:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Browse to <a class="ulink" href="http://dataurl.net/">http://dataurl.net/</a>, then upload each of the icons in turn, and use the site to generate data-URI equivalent code for each image.</li><li class="listitem" style="list-style-type: disc">In the CSS, remove the existing background-image links, and replace them with the code from the <code class="literal">dataurl.net</code> site.</li><li class="listitem" style="list-style-type: disc">Go ahead and compile the code using the same principles we've used throughout this chapter. Looks identical, doesn't it? We've removed the need to pull in separate resources, as we're using a pure CSS solution...</li></ul></div><p>But, there is a catch: when the file has been compiled, check the file size. It should tell you that it is significantly larger than the one which doesn't contain data-URI equivalent code. This is to be expected: it's the trade-off between sizes versus the number of resources we call. It only shows how critical the order of our PostCSS plugins would be, to get the desired results!</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>Anyone who has spent time using pre-processors such as SASS will no doubt be familiar with variables and mixins; these make up an integral part of using PostCSS. We've covered a lot of material relating to their use throughout this chapter, so let's take a breather and review what we have learned.</p><p>We kicked off with a brief introduction to variables and mixins in SASS, before setting up an example demo in SASS (and Less CSS) as a basis for conversion to PostCSS.</p><p>Next up came the start of the transition process to PostCSS. We first looked at adding variable support in, before updating our hover demo to use the new plugin and remove a dependency on using SASS. We then covered some benefits and considerations of using PostCSS, before discovering how a simple tweak in the order of plugins can have a big impact on the end result.</p><p>We moved swiftly on with a look at mixins. We covered the install of the postcss-mixins plugin, before using it to update our demo. At this point, we paused for a moment to consider some of the differences between standard processors and PostCSS, and covered how one of the key points to bear in mind is PostCSS's flexibility and power.</p><p>We then rounded out the chapter with a look at looping content. We first explored the use of the for statement, before moving on and taking a look at how we can easily style content using the <code class="literal">@each</code> function. We then covered its use in a simple demo for styling social media icons. This started in SASS, but finished with the converted results using PostCSS.</p><p>Phew, let's move on! Our next stop on this whistlestop tour of mastering PostCSS is a look at nesting, and no, not for our feathered friends, but how we can (dramatically) reduce the content we write, or at least make it easier to read!</p></div></body></html>