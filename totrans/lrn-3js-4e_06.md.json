["```js\nconst generatePoints = () => {\n  const spGroup = new THREE.Object3D()\n  spGroup.name = 'spGroup'\n  const points = []\n  for (let i = 0; i < 20; i++) {\n    const randomX = -5 + Math.round(Math.random() * 10)\n    const randomY = -5 + Math.round(Math.random() * 10)\n    const randomZ = -5 + Math.round(Math.random() * 10)\n    points.push(new THREE.Vector3(randomX, randomY, randomZ))\n  }\n  const material = new THREE.MeshBasicMaterial({ color:\n    0xff0000, transparent: false })\n  points.forEach(function (point) {\n    const spGeom = new THREE.SphereGeometry(0.04)\n    const spMesh = new THREE.Mesh(spGeom, material)\n    spMesh.position.copy(point)\n    spGroup.add(spMesh)\n  })\n  return {\n    spGroup,\n    points\n  }\n}\n```", "```js\nconst convexGeometry = new THREE.ConvexGeometry(points);\n```", "```js\nconst generatePoints = () => {\n  ...\n  const points = []\n  const height = 0.4\n  const count = 25\n  for (let i = 0; i < count; i++) {\n    points.push(new THREE.Vector3((Math.sin(i * 0.4) +\n      Math.cos(i * 0.4)) * height + 3, i / 6, 0))\n  }\n  ...\n}\n// use the same points to create a LatheGeometry\nconst latheGeometry = new THREE.LatheGeometry (points,\n  segments, phiStart, phiLength);\nlatheMesh = createMesh(latheGeometry);\nscene.add(latheMesh);\n}\n```", "```js\nimport { BoxLineGeometry } from 'three/examples/jsm/\n  geometries/BoxLineGeometry'\nconst material = new THREE.LineBasicMaterial({ color:\n  0x000000 }),\nconst geometry = new BoxLineGeometry(width, height, depth,\n  widthSegments, heightSegments, depthSegments)\nconst lines = new THREE.LineSegments(geometry, material)\nscene.add(lines)\n```", "```js\nimport { TeapotGeometry } from 'three/examples/jsm/\n  geometries/TeapotGeometry'\n...\nconst geom = new TeapotGeometry(size, segments, bottom,\n  lid, body, fitLid, blinn)\n```", "```js\nconst geometry = new THREE.ExtrudeGeometry(drawShape(), {\n    curveSegments,\n    steps,\n    depth,\n    bevelEnabled,\n    bevelThickness,\n    bevelSize,\n    bevelOffset,\n    bevelSegments,\n    amount\n  })\n```", "```js\nconst points = ... // array of THREE.Vector3 objects\nconst tubeGeometry = new TubeGeometry(\n  new THREE.CatmullRomCurve3(points),\n  tubularSegments,\n  radius,\n  radiusSegments,\n  closed\n)\n```", "```js\n<svg version=\"1.0\" xmlns=\"http://www.w3.org/2000/svg\"   xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"1152px\" height=\"1152px\" xml:space=\"preserve\">\n  <g>\n    <path   id=\"batman-path\" style=\"fill:rgb(0,0,0);\" d=\"M 261.135 114.535 C 254.906 116.662 247.491 118.825 244.659 119.344 C\n    229.433 122.131 177.907 142.565 151.973 156.101 C   111.417\n    177.269 78.9808 203.399 49.2992 238.815 C 41.0479   248.66\n    26.5057 277.248 21.0148 294.418 C 14.873 313.624    15.3588\n    357.341 21.9304 376.806 C 29.244 398.469 39.6107    416.935\n    52.0865 430.524 C 58.2431 437.23 63.3085 443.321    63.3431\n    444.06 ... 261.135 114.535 \"/>\n  </g>\n</svg>\n```", "```js\n// returns a promise\nconst batmanShapesPromise = new SVGLoader().loadAsync('/assets/svg/batman.svg')\n// when promise resolves the svg will contain the shapes\nbatmanShapes.then((svg) => {\n  const shapes = SVGLoader.createShapes(svg.paths[0])\n  // based on the shapes we can create an extrude geometry\n    as we've seen earlier\n  const geometry = new THREE.ExtrudeGeometry(shapes, {\n    curveSegments,\n    steps,\n    depth,\n    bevelEnabled,\n    bevelThickness,\n    bevelSize,\n    bevelOffset,\n    bevelSegments,\n    amount\n  })\n  ...\n}\n```", "```js\n        plane: function ( width, height ) {\n            return function ( u, v, target ) {\n                const x = u * width;\n                const y = 0;\n                const z = v * height;\n                target.set( x, y, z );\n            };\n        },\n```", "```js\nconst radialWave = (u, v, optionalTarget) => {\n  var result = optionalTarget || new THREE.Vector3()\n  var r = 20\n  var x = Math.sin(u) * r\n  var z = Math.sin(v / 2) * 2 * r + -10\n  var y = Math.sin(u * 4 * Math.PI) + Math.cos(v * 2 *\n    Math.PI)\n  return result.set(x, y, z)\n}\nconst geom = new THREE.ParametricGeometry(radialWave, 120,\n  120);\n```", "```js\nu:0/5, v:0/4\nu:1/5, v:0/4\nu:2/5, v:0/4\nu:3/5, v:0/4\nu:4/5, v:0/4\nu:5/5, v:0/4\nu:0/5, v:1/4\nu:1/5, v:1/4\n...\nu:5/5, v:3/4\nu:5/5, v:4/4\n```", "```js\nconst baseGeometry = new RoundedBoxGeometry(3, 3, 3, 10, 0.4)\nconst edgesGeometry = THREE.EdgesGeometry(baseGeometry, 1.5)\n}\n```", "```js\nconst material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true })\n```", "```js\nconst baseGeometry = new THREE.TorusKnotBufferGeometry(3, 1, 100, 20, 6, 9)\nconst wireframeGeometry = new THREE.WireframeGeometry(baseGeometry)\n```", "```js\nimport { FontLoader } from 'three/examples/jsm/\n  loaders/FontLoader'\nimport { TextGeometry } from 'three/examples/jsm/\n  geometries/TextGeometry'\n...\nnew FontLoader()\n  .loadAsync('/assets/fonts/helvetiker_regular.typeface.json')\n  .then((font) => {\n      const textGeom =  new TextGeometry('Some Text', {\n          font,\n          size,\n          height,\n          curveSegments,\n          bevelEnabled,\n          bevelThickness,\n          bevelSize,\n          bevelOffset,\n          bevelSegments,\n          amount\n    })\n    ...\n  )\n```", "```js\n{\"glyphs\":{\"¦\":{\"x_min\":359,\"x_max\":474,\"ha\":836,\"o\":\"m 474 971 l 474 457 l\n359 457 l 359 971 l 474 971 m 474 277 l 474 -237 l 359 -237 l 359 277 l 474\n277 \"},\"Ž\":{\"x_min\":106,\"x_max\":793,\"ha\":836,\"o\":\"m 121 1013 l 778 1013 l\n778 908 l 249 115 l 793 115 l 793 0 l 106 0 l 106 104 l 620 898 l 121 898 l\n121 1013 m 353 1109 l 211 1289 l 305 1289 l 417 1168 l 530 1289 l 625 1289\nl 482 1109 l 353 1109 \"},\"Á\":{\"x_min\":25,\"x_max\":811,\"ha\":836,\"o\":\"m 417\n892 l 27 ....\n```", "```js\nimport { Text } from 'troika-three-text'\nconst troikaText = new Text()\ntroikaText.text = 'Text rendering with Troika!\\nGreat for\n  2D labels'\ntroikaText.fontSize = 2\ntroikaText.position.x = -3\ntroikaText.color = 0xff00ff\ntroikaText.sync()\nscene.add(troikaText)\n```"]