<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Adding Detail</h1></div></div></div><p>This chapter explains how to manage external assets such as 3D models, as well as add details to your worlds with particle systems, sound, and graphic effects. It will also elaborate on the arena first-person shooter game we built in <a class="link" href="ch03.html" title="Chapter 3. Exploring and Interacting">Chapter 3</a>, <em>Exploring and Interacting</em>, to turn it into a Capture-the-Flag game.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Setting up CTF</h1></div></div></div><p>In order to have a<a class="indexterm" id="id392"/> proper Capture-the-Flag game, we first need to have teams. There are several things that need to be associated<a class="indexterm" id="id393"/> with a given team:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flags (and the flag color)</li><li class="listitem" style="list-style-type: disc">Players (and the player skins)</li><li class="listitem" style="list-style-type: disc">Spawn points</li><li class="listitem" style="list-style-type: disc">Bullets (if you want to avoid same-team damage)</li><li class="listitem" style="list-style-type: disc">Potentially map decorations/materials</li></ul></div><p>The simplest way to associate each of these elements with a team is to just add a property with a simple value such as <code class="literal">R</code> or <code class="literal">B</code> to represent Red or Blue (or some other team name). A more advanced approach could be to create a <code class="literal">Team</code> class<a class="indexterm" id="id394"/> that holds references to everything that belongs to that team, since that could offer optimizations such as limiting the number of collision checks that need to be performed. If you do that, however, make sure you remove all the appropriate references from the <code class="literal">Team</code> container when removing something (such as a bullet) from the world in order to avoid memory leaks.</p><p>Next, we need to modify our map<a class="indexterm" id="id395"/> to add flags for the Red and Blue teams, which we'll represent as <code class="literal">R</code> and <code class="literal">B</code>, respectively:</p><div><pre class="programlisting">var map = "XXXXXXX   \n" +
          "X  S  X   \n" +
          "X  R  X   \n" +
          "X     XX  \n" +
          "X      XXX\n" +
          "XXX      X\n" +
          "  XX     X\n" +
          "   X  B  X\n" +
          "   X  S  X\n" +
          "   XXXXXXX";</pre></div><p>Now we need to actually add those flags to the world. Flags are not simple geometric primitive shapes though,<a class="indexterm" id="id396"/> so we'll want to import a more complex mesh.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Asset management</h1></div></div></div><p>Primitive geometric shapes <a class="indexterm" id="id397"/>are great for tests, but any serious game these days will likely make heavy use of 3D models created in a specialized program such as Blender, Maya, or 3ds Max. These models need to be imported into Three.js scenes and converted to <code class="literal">THREE.Mesh</code> objects<a class="indexterm" id="id398"/> with geometry and materials. Luckily, Three.js provides importers called <strong>loaders</strong> for a variety of file formats.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>Loaders</h2></div></div></div><p>For our flags, we'll <a class="indexterm" id="id399"/>use a simple mesh in Collada format. (Collada is an XML-based format for storing <a class="indexterm" id="id400"/>3D mesh and animation data, with files ending in <code class="literal">.dae</code>.) You can download our flag mesh from the Packt Publishing website. The <code class="literal">ColladaLoader</code> is not included in the main Three.js library, but can be copied from <code class="literal">examples/js/loaders/ColladaLoader.js</code> and then included in your HTML as:</p><div><pre class="programlisting">&lt;script src="img/ColladaLoader.js"&gt;&lt;/script&gt;</pre></div><p>Then the model can be loaded like this:</p><div><pre class="programlisting">var loader = new THREE.ColladaLoader();
loader.load('flag.dae', function(result) {
  scene.add(result.scene);
});</pre></div><p>Often imported models need to be resized and repositioned, so you will probably want to set <code class="literal">result.scene.scale</code> and <code class="literal">result.scene.position</code> before adding the mesh to the world. You can see the loaded model in the next screenshot:</p><div><img alt="Loaders" src="img/8539_04_01.jpg"/><div><p>The Blue team's flag</p></div></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>By default, importing meshes will not work on local <code class="literal">file:///</code> URLs. This is because when JavaScript requests the file, browsers' default security settings refuse to return local system files. To get around this restriction, you can either run a local HTTP server or change your browser's security settings as described at <a class="ulink" href="https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally">https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally</a>.</p></div></div><p>There are many other loaders<a class="indexterm" id="id401"/> for models in other file formats, including<a class="indexterm" id="id402"/> CTM, OBJ, MTL, PLY, STL, UTF8, VRML, and VTK. These are located in the <code class="literal">examples/js/loaders</code> folder. Almost all of the loaders have a <code class="literal">load</code> method<a class="indexterm" id="id403"/>, like the <code class="literal">ColladaLoader</code> method<a class="indexterm" id="id404"/> mentioned previously, which takes a function to call when loading is finished. However, loaders do not have a standardized format, and some of them work in slightly different ways. In particular, the parameters passed to the callback depend on the file type. You should check the <code class="literal">examples</code> folder for demos of the loader you want to use to make sure you handle the returned result correctly.</p><p>In our case, we get a group of sub-meshes (in the <code class="literal">result.scene</code>) back from the <code class="literal">ColladaLoader</code> because Collada files can contain multiple meshes. We need to modify the flag's materials to make sure each flag reflects its team's color:</p><div><pre class="programlisting">result.scene.children[1].material = new THREE.MeshLambertMaterial({
  color: type === 'R' ? 0xee1100 : 0x0066ee,
  side: THREE.DoubleSide,
});</pre></div><p>Recall that when we set up our camera to follow the player around in the last chapter, we added the camera to the <code class="literal">player</code> object<a class="indexterm" id="id405"/>. Whenever objects are grouped together this way, they can be accessed through the parent's <code class="literal">children</code> array<a class="indexterm" id="id406"/>. In this case, we're using that array to alter the material for the cloth part of the flag to make it blue or red depending on which team it belongs to.</p><p>In addition to loaders for standard 3D model file formats, there are a number of Three.js-specific loaders included <a class="indexterm" id="id407"/>directly in the library. In particular, <code class="literal">THREE.JSONLoader</code> <a class="indexterm" id="id408"/>is designed to load single meshes, while <code class="literal">THREE.SceneLoader</code> <a class="indexterm" id="id409"/>can load<a class="indexterm" id="id410"/> entire scenes (including lighting, cameras, and other Three.js entities).</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>There are also built-in loaders for assets other than 3D models. For example, we've already seen <code class="literal">THREE.TextureLoader</code> at work behind the scenes of <code class="literal">THREE.ImageUtils.loadTexture</code>. You can also directly load pieces of meshes, including geometry, images, and materials. Other objects such as lights, cameras, and even arbitrary resources can be loaded as well. However, these loaders are normally invoked under the hood of the library rather than directly by developers because it usually makes more sense to load entire models or scenes rather than the individual pieces. As a result, we will not cover these loaders here, but you can find them in the <code class="literal">src/loaders</code> folder if you would like to learn more.</p></div></div><p>Like <code class="literal">ColladaLoader</code>, the <code class="literal">JSONLoader</code> uses a <code class="literal">load</code> method<a class="indexterm" id="id411"/> with a callback. However, the callback receives a <code class="literal">THREE.Geometry</code> object<a class="indexterm" id="id412"/> as its first parameter. Not all 3D models have associated materials, but if the object does have materials, they will be passed to the callback in an array as the second parameter:</p><div><pre class="programlisting">var loader = new THREE.JSONLoader();
loader.load('model.js', function(geometry, materials) {
  var material = materials &amp;&amp; materials.length ?
    new THREE.MeshFaceMaterial(materials) :
    new THREE.MeshBasicMaterial({ color: 0x000000 });
  var mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
});</pre></div><p>As explained in <a class="link" href="ch02.html" title="Chapter 2. Building a World">Chapter 2</a>, <em>Building a World</em>, <code class="literal">MeshFaceMaterial</code> <a class="indexterm" id="id413"/>is a container that maps multiple materials to different faces of the mesh.</p><p>The <code class="literal">SceneLoader</code> <a class="indexterm" id="id414"/>is a little different from other loaders because it can use other loaders to handle specific parts of the scene:</p><div><pre class="programlisting">var loader = new THREE.SceneLoader();
loader.addGeometryHandler('ctm', THREE.CTMLoader);
loader.addHierarchyHandler('dae', THREE.ColladaLoader);
loader.load('scene.js', function(result) {
scene.add(result.scene);
});</pre></div><p>If a scene includes an <a class="indexterm" id="id415"/>external model, the <code class="literal">SceneLoader</code> will try to import it using the appropriate handler. Use the <code class="literal">addGeometryHandler</code> method<a class="indexterm" id="id416"/> to add<a class="indexterm" id="id417"/> loaders for file formats that only support single meshes, and use <code class="literal">addHierarchyHandler</code> to add loaders for file formats that support multimesh scenes (DAE, OBJ, and UTF8). In this example, CTM and DAE files will be loaded correctly.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Exporting to Three.js</h2></div></div></div><p>The Three.js project includes<a class="indexterm" id="id418"/> extensions for the 3ds Max, Maya, and Blender 3D modeling programs to make exporting models to the Three.js<a class="indexterm" id="id419"/> JSON format easier. These extensions have some limitations; for example, some modifiers such as smoothing groups are not supported. There are two common alternatives to avoid these issues. The first is to export models to a format such as DAE and use the corresponding Three.js importer. Another approach is to export models to OBJ format and then run the Python converter script in the <code class="literal">utils/converters</code> folder to transform the model to Three.js JSON format. Choosing a file format is mostly a trade-off in file size (how long the file will take to retrieve) and initialization (how long the file will take to parse). You may need to test different formats for performance-sensitive projects.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>The Python converters were written for Python 2.x and may not work in 3.x.</p></div></div><p>The most common problems that arise when importing models are due to not exporting all the required properties. In your modeling program's export dialog, if given a choice, make sure to check the boxes for these properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Vertices</li><li class="listitem" style="list-style-type: disc">Faces</li><li class="listitem" style="list-style-type: disc">Normals</li><li class="listitem" style="list-style-type: disc">Skinning / Materials / Texture Maps / Texture Coordinates / UVs / Colors</li><li class="listitem" style="list-style-type: disc">Flip YZ</li><li class="listitem" style="list-style-type: disc">Morph animation (if applicable)</li><li class="listitem" style="list-style-type: disc">All meshes (if applicable)</li></ul></div><p>Your modeling software may not have all these options, and you may need to check other boxes as well.</p><p>To be on the safe side, you may<a class="indexterm" id="id420"/> also want to make sure<a class="indexterm" id="id421"/> the model you're exporting is a top-level object rather than grouped with other things, that the model is not translated or rotated, that the scaling is set to <code class="literal">1</code>, and that you've deleted the model's history.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Exporting from Three.js</h2></div></div></div><p>Three.js provides several exporters in the <code class="literal">examples/js/exporters</code> folder that allow saving scenes or objects in <a class="indexterm" id="id422"/>various formats, including OBJ, STL, and JSON. Like with loaders, more or less any Three.js entity can be exported,<a class="indexterm" id="id423"/> but the most common approach is to export a complete mesh or scene. The <code class="literal">SceneExporter</code> tool<a class="indexterm" id="id424"/> is the most common tool here, and using it is fairly straightforward:</p><div><pre class="programlisting">var exporter = new THREE.SceneExporter();
var output = JSON.stringify(exporter.parse(scene), null, "\t");</pre></div><p>Then <code class="literal">output</code> value can be saved into a JSON file that <code class="literal">SceneLoader</code> <a class="indexterm" id="id425"/>can read later. The one major issue to watch out for is that custom properties won't get exported. That includes nonstandard properties added to object instances, properties provided by subclasses of Three.js classes, custom classes that don't inherit from Three.js classes, and anything that isn't part of the <code class="literal">scene</code>. If you need any of these things to be exported, you may be better off writing a custom exporter and importer, possibly starting with one of the ones Three.js provides.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Managing loaders</h2></div></div></div><p>Right now, when our CTF map<a class="indexterm" id="id426"/> is initialized, we ask a loader to<a class="indexterm" id="id427"/> fetch the flag model. This works fine because the model is pretty small and we only have the one model to load. However, if we had many models or if they were bigger, we may notice them popping into the map when they finished loading, even after we've started playing. To fix this, larger projects should preload assets before the player can start playing the game. All that's required to do so is to disallow entering the map until the last model's callback has been executed. Unfortunately, if we have a lot of models and we have to load them one by one, it can be hard to keep track of how many models are remaining. Users may also lose interest if nothing is happening while models are loading.</p><p>Usually, this is resolved by loading all the models at once with the <a class="indexterm" id="id428"/>
<code class="literal">SceneLoader</code>. The <code class="literal">SceneLoader</code> objects have a <code class="literal">callbackProgress</code> property<a class="indexterm" id="id429"/> that holds a function which is invoked after each object in the scene has completed loading. The callback takes two parameters, <code class="literal">progress</code> <a class="indexterm" id="id430"/>and <code class="literal">result</code>.<a class="indexterm" id="id431"/> The <code class="literal">progress</code> object<a class="indexterm" id="id432"/> has four numeric properties that can be used to display a progress bar: <a class="indexterm" id="id433"/>
<code class="literal">totalModels</code>,<a class="indexterm" id="id434"/> <code class="literal">totalTextures</code>, <a class="indexterm" id="id435"/>
<code class="literal">loadedModels</code>, and <a class="indexterm" id="id436"/>
<code class="literal">loadedTextures</code>. The result object contains all of the entities that have been loaded so far, and it's also the value passed to the <code class="literal">onLoad</code> parameter<a class="indexterm" id="id437"/> of the loader's <code class="literal">load</code> callback when all loading has been completed.</p><p>Consider HTML<a class="indexterm" id="id438"/> like this for a loading bar, where the outer div has a defined width:</p><div><pre class="programlisting">&lt;div id="bar"&gt;&lt;div id="progress"&gt;&lt;/div&gt;&lt;/div&gt;</pre></div><p>In this case, you might include <a class="indexterm" id="id439"/>code like this in a <a class="indexterm" id="id440"/>
<code class="literal">callbackProgress</code> handler:</p><div><pre class="programlisting">var total = progress.totalModels + progress.totalTextures,
    loaded = progress.loadedModels + progress.loadedTextures,
    progressBar = document.getElementById('progress');
progressBar.style.width = Math.round(100 * loaded / total) + '%';</pre></div><p>If you can't use a <code class="literal">SceneLoader</code> or don't want to use it for other reasons, you will have to chain together your loaders manually. However, Three.js will start using <strong>loading managers</strong><a class="indexterm" id="id441"/> in the future. Loading managers are just objects that work together with loaders to track when multiple resources have finished loading. The loading manager API is not yet stable as of Three.js version r61 and it is not implemented in many of the loaders.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Mesh animation</h2></div></div></div><p>Using animated models is<a class="indexterm" id="id442"/> not very different from using normal models.<a class="indexterm" id="id443"/> There are essentially two types of animation to consider (in addition to manually changing the position of a mesh's geometry in Three.js).</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>If all you need is to smoothly transition properties between different values—for example, changing the rotation of a door in order to animate it opening—you can use the Tween.js library at <a class="ulink" href="https://github.com/sole/tween.js">https://github.com/sole/tween.js</a> to do so instead of animating the mesh itself. <em>Jerome Etienne</em> has a nice tutorial on doing this at <a class="ulink" href="http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/">http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/</a>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Morph animation</h3></div></div></div><p>Morph animation<a class="indexterm" id="id444"/> stores animation data as a sequence of positions. For example, if you had a cube with a <em>shrink</em> animation, your model could hold the positions <a class="indexterm" id="id445"/>of the vertices of the cube at full size and at the shrunk size. Then animation would consist of interpolating between those states during each rendering or <strong>keyframe</strong><a class="indexterm" id="id446"/>. The data representing each state can hold either vertex targets or face normals.</p><p>To use morph animation, the easiest approach is to use a <code class="literal">THREE.MorphAnimMesh</code> class<a class="indexterm" id="id447"/>, which is a subclass of the normal mesh. In the following example, the highlighted lines should only be included if the model uses normals:</p><div><pre class="programlisting">var loader = new THREE.JSONLoader();
loader.load('model.js', function(geometry) {
  var material = new THREE.MeshLambertMaterial({
    color: 0x000000,
    morphTargets: true,
<strong>    morphNormals: true,</strong>
  });
  if (geometry.morphColors &amp;&amp; geometry.morphColors.length) {
    var colorMap = geometry.morphColors[0];
    for (var i = 0; i &lt; colorMap.colors.length; i++) {
      geometry.faces[i].color = colorMap.colors[i];
    }
    material.vertexColors = THREE.FaceColors;
  }
<strong>  geometry.computeMorphNormals();</strong>
  var mesh = new THREE.MorphAnimMesh(geometry, material);
  mesh.duration = 5000; // in milliseconds
  scene.add(mesh);
  morphs.push(mesh);
});</pre></div><p>The first thing we do is set our material <a class="indexterm" id="id448"/>to be aware that the mesh will be animated with the <code class="literal">morphTargets</code> properties<a class="indexterm" id="id449"/> and optionally with <code class="literal">morphNormal</code> properties<a class="indexterm" id="id450"/>. Next, we check whether colors will change during the animation, and set the mesh faces to their initial color if so (if you know your model doesn't have <code class="literal">morphColors</code>, you can leave out that block). Then the normals are computed (if we have them) and our <code class="literal">MorphAnimMesh</code> animation<a class="indexterm" id="id451"/> is created. We set the <code class="literal">duration</code> value of the full animation, and finally store the mesh in the global <code class="literal">morphs</code> array<a class="indexterm" id="id452"/> so that we can update it during our physics loop:</p><div><pre class="programlisting">for (var i = 0; i &lt; morphs.length; i++) {
  morphs[i].updateAnimation(delta);
}</pre></div><p>Under the hood, the <code class="literal">updateAnimation</code> method<a class="indexterm" id="id453"/> just changes which set of positions<a class="indexterm" id="id454"/> in the animation the mesh<a class="indexterm" id="id455"/> should be interpolating between. By default, the animation will start immediately and loop indefinitely. To stop animating, just stop calling <code class="literal">updateAnimation</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Skeletal animation</h3></div></div></div><p>Skeletal animation<a class="indexterm" id="id456"/> moves a group of vertices in a mesh together by making them follow the movement of <code class="literal">bone</code>. This is generally easier to design because<a class="indexterm" id="id457"/> artists only have to move a few bones instead of potentially thousands of vertices. It's also typically less memory-intensive for the same reason.</p><p>To use morph animation, use a <code class="literal">THREE.SkinnedMesh</code> class<a class="indexterm" id="id458"/>, which is a subclass of the normal mesh:</p><div><pre class="programlisting">var loader = new THREE.JSONLoader();
loader.load('model.js', function(geometry, materials) {
  for (var i = 0; i &lt; materials.length; i++) {
    materials[i].skinning = true;
  }
  var material = new THREE.MeshFaceMaterial(materials);
  THREE.AnimationHandler.add(geometry.animation);
  var mesh = new THREE.SkinnedMesh(geometry, material, false);
  scene.add(mesh);
  var animation = new THREE.Animation(mesh, geometry.animation.name);
  animation.interpolationType = THREE.AnimationHandler.LINEAR; // or CATMULLROM for cubic splines (ease-in-out)
  animation.play();
});</pre></div><p>The model we're using in this<a class="indexterm" id="id459"/> example already has materials, so unlike in the morph animation examples, we have to change the existing materials instead of creating a new one. For skeletal animation we have to enable <strong>skinning</strong><a class="indexterm" id="id460"/>, which refers to how the materials are wrapped around the mesh as it moves. We use the <code class="literal">THREE.AnimationHandler</code> utility<a class="indexterm" id="id461"/> to track where we are in the current animation and a <code class="literal">THREE.SkinnedMesh</code> utility<a class="indexterm" id="id462"/> to properly handle our model's bones. Then we use the mesh to create a new <code class="literal">THREE.Animation</code> and play it. The animation's <code class="literal">interpolationType</code> determines how the mesh transitions between states. If you want cubic spline easing (slow then fast then slow), use <code class="literal">THREE.AnimationHandler.CATMULLROM</code> instead of the <code class="literal">LINEAR</code> easing.</p><p>We also need to update the animation in our physics loop:</p><div><pre class="programlisting">THREE.AnimationHandler.update(delta);</pre></div><p>It is possible to use both<a class="indexterm" id="id463"/> skeletal and morph animations at the same time. In this case, the best approach is to treat the <a class="indexterm" id="id464"/>animation as skeletal and manually update the mesh's <code class="literal">morphTargetInfluences</code> array<a class="indexterm" id="id465"/> as demonstrated in <code class="literal">examples/webgl_animation_skinning_morph.html</code> in the Three.js<a class="indexterm" id="id466"/> project.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Particle systems</h1></div></div></div><p>Now that our flags are in place and we've learned how to manage the resources we'll need to decorate our world,<a class="indexterm" id="id467"/> let's add some additional visual effects. The first type of effect we'll look at is particle systems.</p><p>Particles are planes that always face the camera, usually grouped together into a <em>system</em> to create some effect like fire or steam. They are essential for creating great visuals like this colorful heart:</p><div><img alt="Particle systems" src="img/8539_04_02.jpg"/><div><p>Particles from examples/webgl_particles_shapes.html with shapes by zz85</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Capturing the flag</h2></div></div></div><p>We'd like to set off a<a class="indexterm" id="id468"/> celebratory fireworks-style display when the player captures<a class="indexterm" id="id469"/> a flag, so if you haven't already done so, go ahead and add the mechanics of capturing flags. The core logic should be in a function we'll call for each player in our physics loop:</p><div><pre class="programlisting">function checkHasFlag(unit) {
  var otherFlag = unit.team === TEAMS.R ? TEAMS.B.flag : TEAMS.R.flag;
  if (unit.hasFlag) {
    var flag = unit.team === TEAMS.R ? TEAMS.R.flag : TEAMS.B.flag;
    if (flag.mesh.visible &amp;&amp; isPlayerInCell(flag.row, flag.col)) {
      otherFlag.mesh.traverse(function(node) {
        node.visible = true;
      });
      unit.hasFlag = false;
    }
  }
  else if (otherFlag.mesh.visible &amp;&amp; isPlayerInCell(otherFlag.row, otherFlag.col)) {
    otherFlag.mesh.traverse(function(node) {
      node.visible = false;
    });
    unit.hasFlag = true;
  }
}</pre></div><p>If the player has the opponent's flag, we're checking if they're standing on their own flag so that they can score; if the player doesn't have the flag, we're checking if they're standing on the other flag so that they can steal it. When a flag is stolen it is marked as invisible, and it is marked as visible again when it is returned. (The code for this is not included in the preceding<a class="indexterm" id="id470"/> example, but flags also need to be returned when<a class="indexterm" id="id471"/> a flag carrier dies.)</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>Objects' <code class="literal">visible</code> property<a class="indexterm" id="id472"/> is a Boolean controlling whether or not they are rendered. In the WebGL renderer, setting this property does not affect child objects, though it does affect child objects in other renderers. This is important to know for multipart meshes, which are often imported in a hierarchy. To set the visibility for an object and all its children, you can use the <code class="literal">traverse</code> method<a class="indexterm" id="id473"/>, which invokes a callback for each object in the hierarchy:</p><div><pre class="programlisting">object.traverse(function(node) {
  node.visible = false;
});</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Particles and Sprites</h2></div></div></div><p><code class="literal">CanvasRenderer</code> <a class="indexterm" id="id474"/>and <code class="literal">WebGLRenderer</code> <a class="indexterm" id="id475"/>use<a class="indexterm" id="id476"/> different objects to represent individual particles. When <a class="indexterm" id="id477"/>using canvas, use <code class="literal">THREE.Particle</code>:</p><div><pre class="programlisting">var material = new THREE.ParticleBasicMaterial({
  color: 0x660000,
  map: null, // or an image texture
});
var particle = new THREE.Particle(material);</pre></div><p>As you can see, particles<a class="indexterm" id="id478"/> are basically just made up of a color or an image. Similarly, when using WebGL, use <code class="literal">THREE.Sprite</code>:</p><div><pre class="programlisting">var material = new THREE.SpriteMaterial({
  color: 0x660000,
  map: null, // or an image texture
  opacity: 1.0,
  blending: THREE.AdditiveBlending,
});
var sprite = new THREE.Sprite(material);</pre></div><p>Sprites are basically the <a class="indexterm" id="id479"/>same as particles except that they also support different blending modes. Supported blending modes<a class="indexterm" id="id480"/> are shown in the following screenshot:</p><div><img alt="Particles and Sprites" src="img/8539_04_03.jpg"/><div><p>Different blending modes, as displayed in examples/webgl_materials_blending.html</p></div></div><p>In both cases, you can use the <code class="literal">position</code> <a class="indexterm" id="id481"/>and <code class="literal">scale</code> vectors<a class="indexterm" id="id482"/> the same way we've been using them for meshes,<a class="indexterm" id="id483"/> except that <code class="literal">scale.z</code> has no effect.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Particle systems</h2></div></div></div><p>Particle systems are a way to <a class="indexterm" id="id484"/>create and manage lots of particles at once. They use geometry to place a particle on each vertex. This has the benefit that you can use built-in tools we've already seen to manipulate the geometry. For example, you can use a particle system with imported animated geometry. However, they also have several limitations. First, creating dynamic effects can be difficult because you have to code them manually, for example by updating the velocity of each individual particle in each frame. Second, you can't add and remove particles (although you can set their opacity to zero), so you have to pre-allocate as many particles as you might need. Third, you can only use a single material per particle system, so all the particles in a given system will have the same<a class="indexterm" id="id485"/> image, size, and rotation (though you can independently change their color).</p><p>For the purposes of our CTF game,<a class="indexterm" id="id486"/> we'll create a celebratory particle system when we create our flags:</p><div><pre class="programlisting">var geometry = new THREE.IcosahedronGeometry(200, 2);
var mat = new THREE.ParticleBasicMaterial({
  color: type === 'R' ? TEAMS.R.color : TEAMS.B.color,
  size: 10,
});
var system = new THREE.ParticleSystem(geometry, mat);
system.sortParticles = true;
system.position.set(x, VERTICAL_UNIT * 0.5, z);
scene.add(system);</pre></div><p>This will create small particles in a roughly spherical shape around the flag we're initializing. The <code class="literal">sortParticles</code> property<a class="indexterm" id="id487"/> indicates whether particles should be sorted by depth so that particles closer to the camera appear in front of those that are farther away. Sometimes sorting particles can create a strange popping effect when particles are moving and overlapping, so you may want to test and see what looks better to you. Additionally, enabling sorting when you have many thousands of particles can be computationally expensive, though it should be fine with the few hundred particles in our example.</p><p>To complete the effect, we actually want to make the system invisible with <code class="literal">system.visible = false</code>, then temporarily make it visible when a flag is captured later. Also, our particles will also be more interesting if they move around. We can rotate the whole particle system by changing its rotation vector:</p><div><pre class="programlisting">system.rotation.y += delta * 1.5;</pre></div><p>You can see the result in the following screenshot:</p><div><img alt="Particle systems" src="img/8539_04_04.jpg"/><div><p>A celebratory particle effect</p></div></div><p>We can also move the geometry's vertices directly if we want. To do this, we first need to set <code class="literal">geometry.dynamic = true</code> before creating the particle system, then set <code class="literal">geometry.verticesNeedUpdate = true</code> every time we change vertex positions.</p><p>We don't need to do this for our game, but it's also possible to change the color of individual particles by<a class="indexterm" id="id488"/> changing the <code class="literal">geometry.colors</code> array<a class="indexterm" id="id489"/>. You can fill this array with one color for each vertex (at the same index) and that color will be blended with the color or image of the particle's material.</p><p>Some things you<a class="indexterm" id="id490"/> may want to do with particles can get quite complicated. For example, to simulate spray from a waterfall, you might use particles with some physics applied. To simplify similar advanced use cases, two libraries have emerged. One of them, called <strong>Sparks</strong><a class="indexterm" id="id491"/>, is actually included with Three.js in the <code class="literal">examples/js</code> folder. It's also available online at <a class="ulink" href="https://github.com/zz85/sparks.js">https://github.com/zz85/sparks.js</a> and is written by <em>zz85</em>. A newer library written by <em>Luke Moody</em> and <em>Lee Stemkoski</em> is available at <a class="ulink" href="https://github.com/squarefeet/ShaderParticleEngine">https://github.com/squarefeet/ShaderParticleEngine</a>, and while relatively untested, the API is simpler and it's somewhat lighter in weight.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Sound</h1></div></div></div><p>Although Three.js is<a class="indexterm" id="id492"/> a graphics library,<a class="indexterm" id="id493"/> there is an experimental <code class="literal">THREE.AudioObject</code> class<a class="indexterm" id="id494"/> at <code class="literal">examples/js/AudioObject.js</code> that uses the Web Audio API to support 3D sound effects. This object inherits from <code class="literal">Object3D</code> so it can be attached to other objects and placed in the world. It is designed to use spatially accurate 3D sound. The main caveat is that the class only works with Chrome as of Three.js version r61 due to browser incompatibilities.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>Like with external models, audio is loaded with AJAX, so local file URLs won't work by default.</p></div></div><p>That said, let's go ahead and try adding some cheering sounds when a flag is captured. First, we'll create our <code class="literal">AudioObject</code> instances when we initialize our flags:</p><div><pre class="programlisting">var cheering = new THREE.AudioObject('cheering.ogg', 0, 1, false);
scene.add(cheering);</pre></div><p>This code creates an object to play the <code class="literal">cheering.ogg</code> file with a volume of <code class="literal">0</code>, a playback rate of <code class="literal">1</code>, and no looping. We set the volume to zero initially because <code class="literal">AudioObject</code> <a class="indexterm" id="id495"/>plays the sound immediately, and we only want it to play when we capture a flag. To that end, let's trigger the sound to play when we capture a flag:</p><div><pre class="programlisting">THREE.AudioObject.call(cheering, 'cheering.ogg', 1, 1, false);</pre></div><p><code class="literal">AudioObject</code> does not provide<a class="indexterm" id="id496"/> a way to play a sound again, so we have to call the constructor to force it to do that. This time, we set the volume to <code class="literal">1</code>. The crowd <a class="indexterm" id="id497"/>goes wild!</p><p>If you set the final parameter to <code class="literal">true</code> instead of <code class="literal">false</code>, you can also use this to play looping sounds or even music.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Renderer effects and postprocessing</h1></div></div></div><p>Sometimes, effects that<a class="indexterm" id="id498"/> change the entire display can give <a class="indexterm" id="id499"/>a game or area a lot of personality. Three.js supports two major kinds of effects: renderer and <a class="indexterm" id="id500"/>postprocessing.</p><p>Renderer effects <a class="indexterm" id="id501"/>can be found in <code class="literal">examples/js/effects</code>. They change what the renderer outputs, usually by rendering the scene multiple times with different settings. For example, the Anaglyph effect produces the familiar red-and-blue shadows that work with 3D glasses to make the scene pop out of the screen, and it does this by rendering the scene once for the left eye, once for the right eye, and once combined. Setting this up is easy:</p><div><pre class="programlisting">effect = new THREE.AnaglyphEffect(renderer);
effect.setSize(renderer.domElement.width, renderer.domElement.height);</pre></div><p>Then just call <code class="literal">effect.render(scene, camera)</code> instead of <code class="literal">renderer.render(scene, camera)</code>. All of the other renderer effects work the same way except the ASCII effect, which requires adding a separate canvas so it can render the scene to text characters.</p><p>Postprocessing effects work by applying a GLSL shader over the scene. There are many shaders that can be used in the <code class="literal">examples/js</code>, <code class="literal">examples/js/postprocessing</code>, and <code class="literal">examples/js/shaders</code> folders. Most of these are just fun, but a few are useful in games. The <strong>DOF</strong> (<strong>depth-of-field</strong>) effect<a class="indexterm" id="id502"/>, for example, blurs distant objects and brings closer ones into focus.</p><p>The <code class="literal">EffectComposer</code> <a class="indexterm" id="id503"/>in <code class="literal">examples/js/postprocessing</code> makes applying post-processing easier and allows using multiple effects. For example, to use the <code class="literal">EdgeShader</code>, <a class="indexterm" id="id504"/>start by<a class="indexterm" id="id505"/> adding the necessary<a class="indexterm" id="id506"/> files in your HTML:</p><div><pre class="programlisting">&lt;script src="img/EdgeShader.js"&gt;&lt;/script&gt;
&lt;script src="img/CopyShader.js"&gt;&lt;/script&gt;
&lt;script src="img/ShaderPass.js"&gt;&lt;/script&gt;
&lt;script src="img/RenderPass.js"&gt;&lt;/script&gt;
&lt;script src="img/MaskPass.js"&gt;&lt;/script&gt;
&lt;script src="img/EffectComposer.js"&gt;&lt;/script&gt;</pre></div><p>Then set up <a class="indexterm" id="id507"/>the effect:</p><div><pre class="programlisting">composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
var effect = new THREE.ShaderPass(THREE.EdgeShader);
effect.uniforms['aspect'].value.x = renderer.domElement.width;
effect.uniforms['aspect'].value.y = renderer.domElement.height;
composer.addPass(effect);
effect = new THREE.ShaderPass(THREE.CopyShader);
effect.renderToScreen = true;
composer.addPass(effect);</pre></div><p>This code requests two<a class="indexterm" id="id508"/> postprocessing rendering passes during which the edge and copy shaders will both be applied. The edge effect requires knowledge of the canvas size, and the effects will be rendered after the copy shader is applied. The final step is to replace our <code class="literal">renderer.render(scene, camera)</code> call with <code class="literal">composer.render()</code>,<a class="indexterm" id="id509"/> and we get a pretty dramatic result, as you can see in the next screenshot:</p><div><img alt="Renderer effects and postprocessing" src="img/8539_04_05.jpg"/><div><p>Our game with the edge shader postprocessor</p></div></div><p>As previously <a class="indexterm" id="id510"/>mentioned, shaders<a class="indexterm" id="id511"/> are written in GLSL instead of JavaScript, and they can get pretty complex. As a result, we won't talk about how to write them here. However,<a class="indexterm" id="id512"/> you can<a class="indexterm" id="id513"/> browse and fork some <a class="indexterm" id="id514"/>shaders other people<a class="indexterm" id="id515"/> have written at <a class="ulink" href="https://glsl.heroku.com/">https://glsl.heroku.com/</a>. Three.js author <em>Mr.doob</em> has also written a shader editor at <a class="ulink" href="http://www.mrdoob.com/projects/glsl_sandbox/">http://www.mrdoob.com/projects/glsl_sandbox/</a>, and <em>Thibaut Despoulain</em> has written one as well at <a class="ulink" href="http://shdr.bkcore.com/">http://shdr.bkcore.com/</a>. Note that shaders can be used to display pretty<a class="indexterm" id="id516"/> much anything, and most shaders don't make sense as postprocessors.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we learned how to manage 3D models and animation. We also explored particle systems, sound, and visual effects. Additionally, we used what we learned to transform our first-person shooter game from <a class="link" href="ch03.html" title="Chapter 3. Exploring and Interacting">Chapter 3</a>, <em>Exploring and Interacting</em> into a Capture-the-Flag game. In the next chapter, we'll discuss game design concepts, workflow processes, performance considerations, and networking.</p></div></body></html>