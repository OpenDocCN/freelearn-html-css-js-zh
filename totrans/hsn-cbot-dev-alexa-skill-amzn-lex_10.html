<html><head></head><body>
        

                            
                    <h1 class="header-title">Appendix A</h1>
                
            
            
                


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 1</h1>
                
            
            
                
<ol>
<li class="mce-root">Intents, slots, and utterances</li>
<li>Any two from:
<ul>
<li>They are both Amazon services</li>
<li>They are both chatbots</li>
<li>They both use Natural Language Understanding/NLU/NLP</li>
</ul>
</li>
<li>Any two from:
<ul>
<li>Alexa uses voice interaction, whereas Lex can be voice- or text-triggered</li>
<li>Alexa uses skills, whereas Lex can be applied to lots of applications</li>
<li>Lex can be triggered by other services, whereas Alexa only works on Alexa devices</li>
</ul>
</li>
<li>You should start with a perfect conversation and build from there</li>
<li><strong>Tone of voice</strong> is about the words and phrases that your chatbot uses and making sure that it suits the user</li>
<li>Missed utterances, external API errors, and errors in your code</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 2</h1>
                
            
            
                
<ol>
<li>Using the Lambda console on AWS, using Cloud9, on a local development setup</li>
<li>Amazon Web Services</li>
<li>No easy way to deploy or update Lambdas, and difficulty working on multiple machines or as part of a team</li>
<li>AWS-CLI, Bash/build scripts, Git, and GitHub/Bitbucket</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 3</h1>
                
            
            
                
<ol>
<li><kbd>alexa-sdk</kbd>.</li>
<li>All three:
<ul>
<li>Copy the Lambda ARN into the Skill Endpoint default region</li>
<li>Copy the skill ARN into the Lambda code in the <kbd>exports.handler</kbd> function setup</li>
<li>Select Alexa Skills Kit as a trigger for the Lambda and copy the skill ARN into the setup</li>
</ul>
</li>
<li><kbd>s3.getObject()</kbd>.</li>
<li>You have to do <kbd>JSON.parse(data.body)</kbd> because the body of the reply is sent as a buffer, so it needs to be transformed into a usable JSON format.</li>
<li>Click the dropdown next to Test in the Lambda console and select Configure test events. You can then create a new test or modify an existing one.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 4</h1>
                
            
            
                
<ol>
<li>An API is an <strong>Application Programming Interface</strong>, which allows the functionality of a program to be accessed from external sources.</li>
<li><kbd>axios</kbd> is a promise-based library, whereas <kbd>HTTP</kbd> is callback-based.</li>
<li>Using <kbd>try</kbd>/<kbd>catch</kbd> and the <kbd>to</kbd> function method.</li>
<li><kbd>this.attributes.colour = colour</kbd>.</li>
<li>Currently, only strings are allowed to be stored on session attributes.</li>
<li>You would use SSML to change the way that Alexa says something. This can be changing tone, emphasis, adding pauses, or a few other changes.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 5</h1>
                
            
            
                
<ol>
<li>Yes, you can create the responses in the Lex console's Intent Response section</li>
<li>You need to wrap the name of the slot in curly brackets within the response</li>
<li>Lex can use one Lambda per intent, whereas Alexa handles all requests with a single Lambda</li>
<li>5</li>
<li><kbd>ElicitSlot</kbd>, <kbd>ElicitIntent</kbd>, <kbd>ConfirmIntent</kbd>, <kbd>Close</kbd>, <kbd>Delegate</kbd></li>
<li><kbd>`S3.getObject()</kbd></li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 6</h1>
                
            
            
                
<ol>
<li>A complex flow is made up of lots of different paths that the user can take, while a simple flow usually has a single path the user can take.</li>
<li>We can break the flow diagrams into sections. These sections can connect to other sections to create the total flow.</li>
<li><kbd>ElicitSlot</kbd>, <kbd>Close</kbd>, <kbd>ElicitIntent</kbd>, <kbd>ConfirmIntent</kbd>, and <kbd>Delegate</kbd>.</li>
<li>The DynamoDB DocumentClient.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 7</h1>
                
            
            
                
<ol>
<li>We want to integrate into other platforms and services to make it easier for our users to access our chatbots. Integrating with services that they already use makes accessing our chatbot much easier for them.</li>
<li>API Gateway and AWS Lambda.</li>
<li>Resources and methods.</li>
<li>We need to deploy the API onto a stage.</li>
<li>HTML file, JavaScript script, and a CSS file.</li>
<li>When a script file loads, it should check whether the DOM has fully loaded. If not, then it should wait for that to happen before running any functions that need to manipulate the DOM.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 8</h1>
                
            
            
                
<ol>
<li>Cards are a great way to provide more information to the user without large blocks of text. Adding cards also allows you to provide buttons that give the user options for how to respond.</li>
<li>No, all of the attributes are optional, but a title and subtitle are recommended.</li>
<li>You'd use a search query slot type when there is a huge range of values that a user could enter. Creating a slot with everything would take too long and would still miss a lot of possible values.</li>
<li>Yes, but you can't populate a search query slot and another slot in the same utterance.</li>
<li>In Lex, the monitoring tab has a menu where it displays all of the missed intents. These can be looked through and added directly to an intent if needed.</li>
</ol>


            

            
        
    </body></html>