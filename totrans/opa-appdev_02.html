<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Basic Syntax"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Basic Syntax</h1></div></div></div><p>In this chapter, we will introduce the basic syntax<a id="id43" class="indexterm"/> of Opa. This chapter will not cover every little tiny thing about Opa,<a id="id44" class="indexterm"/> but it is something you should know. It's also assumed that you have some basic knowledge about computer programming.</p><div class="section" title="Basic datatypes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Basic datatypes</h1></div></div></div><p>Datatypes<a id="id45" class="indexterm"/> are the <a id="id46" class="indexterm"/>shapes of data manipulated by an application. Opa uses datatypes to perform sanity and security checks on your application. Opa also uses datatypes to perform a number of optimizations. There are three basic datatypes in Opa: integers, floats, and strings. Also, you can define your type with the keyword <code class="literal">type</code>:</p><div class="informalexample"><pre class="programlisting">type Student = {string name, int age, float score}
Student stu = { name:"li", age:28, score:80.0}</pre></div><p>Actually, thanks to a mechanism of type inference, Opa can work in most cases even if you do not provide any type information. For example:</p><div class="informalexample"><pre class="programlisting">x = 10        // the same as: int x = 10
x = {a:1,b:2} // the type of x is: {a:int, b:int}</pre></div><p>So in the rest of this chapter, we will not address type information before variable, but you should know <a id="id47" class="indexterm"/>what type it is in your mind. In actual coding, a best practice is to provide the datatypes of our main functions and to let the inference engine pick up the datatypes of all the local variables and minor functions.</p><div class="section" title="Integers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Integers</h2></div></div></div><p>It is<a id="id48" class="indexterm"/> quite<a id="id49" class="indexterm"/> simple to write integer literals; there are a number of ways to do so:</p><div class="informalexample"><pre class="programlisting">x = 10     // 10 in base 10
x = 0xA    // 10 in base 16, any case works (0Xa, 0XA, Oxa)
x = 0o12   // 10 in base 8
x = 0b1010 // 10 in base 2</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The tailing semicolon is optional in Opa; you can add it if you want.</p></div></div><p>Opa provides the <a id="id50" class="indexterm"/>module <code class="literal">Int</code> (<a class="ulink" href="http://doc.opalang.org/module/stdlib.core/Int">http://doc.opalang.org/module/stdlib.core/Int</a>) to operate on integers. The following are the most used functions:</p><div class="informalexample"><pre class="programlisting">i1 = Int.abs(-10)        // i1 = 10
i2 = Int.max(10,8)       // i2 = 10</pre></div><p>There is no automatic type conversion between <code class="literal">float</code>, <code class="literal">int</code>, and <code class="literal">String</code>. So, use the following functions to convert between <code class="literal">int</code>, <code class="literal">float</code>, and <code class="literal">String</code>.</p><div class="informalexample"><pre class="programlisting">i3 = Int.of_float(10.6)      // i3 = 10
i4 = Int.of_string("0xA")    // i4 = 10, 0xA is 10 in dec
f1 = Int.to_float(10) 	       // f1 = 10.0, f1 is a float
s1 = Int.to_string(10)       // s1 = "10", s1 is a string</pre></div></div><div class="section" title="Floats"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Floats</h2></div></div></div><p>It is also <a id="id51" class="indexterm"/>easy to<a id="id52" class="indexterm"/> define floats. They can be written in the following ways:</p><div class="informalexample"><pre class="programlisting">x = 12.21   // the normal one
x = .12     // omitting the leading zero
x = 12.     // to indicate this is a float, not an integer
x = 12.5e10 // scientific notation</pre></div><p>Opa provides the <a id="id53" class="indexterm"/>module <code class="literal">Float</code> (<a class="ulink" href="http://doc.opalang.org/module/stdlib.core/Float">http://doc.opalang.org/module/stdlib.core/Float</a>) to operate on floats. The following are the most used functions:</p><div class="informalexample"><pre class="programlisting">f1 = Float.abs(-10.0)        //f1 = 10.0
f2 = Float.ceil(10.5)        //f2 = 11.0
f3 = Float.floor(10.5)	       //f3 = 10.0
f4 = Float.round(10.5)       //f4 = 11.0
f5 = Float.of_int(10)        //f5 = 10.0
f6 = Float.of_string("10.5") //f6 = 10.5
i1 = Float.to_int(10.5)      //i1 = 10, i1 is an integer
s1 = Float.to_string(10.5)   //s1 = "10.5", s1 is a string</pre></div></div><div class="section" title="Strings"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Strings</h2></div></div></div><p>In Opa, text<a id="id54" class="indexterm"/> is represented by immutable utf8-encoded character strings. <a id="id55" class="indexterm"/>String literals follow roughly the same syntax used in C language, Java, or JavaScript. Note that you will have to escape special characters with backslashes.</p><div class="informalexample"><pre class="programlisting">x = "hello!"
x = "\"" // special characters can be escaped with backslashes</pre></div><p>Opa has a feature called string insertions, which can put arbitrary expressions into a string. You can <a id="id56" class="indexterm"/>do that by embedding an expression between curly braces into a string. For example:</p><div class="informalexample"><pre class="programlisting">x = "1 + 2 = {1+2}"   //will produce "1 + 2 = 3"
lang = "Opa"
y = "I love {lang}!"  //will produce "I love Opa!"</pre></div><p>Opa provides the <a id="id57" class="indexterm"/>module <code class="literal">String</code> (<a class="ulink" href="http://doc.opalang.org/module/stdlib.core/String">http://doc.opalang.org/module/stdlib.core/String</a>) to operate on strings. The most commonly used are as follows:</p><div class="informalexample"><pre class="programlisting">s = "I love Opa! "              //Note there is a space at the end.
len = String.length(s)          //get length, len = 12
isEmpty = String.is_empty(s)    //test if a string is empty, false
isBlank = String.is_blank(s)    //test if a string is blank, false
cont = String.contains(s,"Opa") //check if a string contains a 
                                 //substring,true
idx1 = String.index("love",s)   //found, idx1 = {some:2}
idx2 = String.index("loving",s) //not found, idx2 = {none}
ch = String.get(0,s)            //get nth char, ch = 'I'
s2 = String.trim(s)             //do trim, s2 = "I love Opa!"
s3 = String.replace("I","We",s2)//s3 = "We love Opa!"</pre></div></div><div class="section" title="Sum"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Sum</h2></div></div></div><p>A value<a id="id58" class="indexterm"/> has a<a id="id59" class="indexterm"/> sum type <code class="literal">t</code> or <code class="literal">u</code>, meaning that the values of this type are either of the two variants, a value of type <code class="literal">t</code> or a value of type <code class="literal">u</code>.</p><p>A good example <a id="id60" class="indexterm"/>of sum type are Boolean values, which are defined as follows:</p><div class="informalexample"><pre class="programlisting">type bool = {true} or {false}</pre></div><p>Thus, a variable of type <code class="literal">bool</code> can be either <code class="literal">{true}</code> or <code class="literal">{false}</code>. Another commonly used sum type is the <code class="literal">option</code> type, which is defined as:</p><div class="informalexample"><pre class="programlisting">type option('a) = {none} or {'a some}</pre></div><p>The <code class="literal">option(`a)</code> value<a id="id61" class="indexterm"/> is either <code class="literal">none</code> or <code class="literal">some</code> (a value x of type <code class="literal">`a</code>). Type <code class="literal">`a</code> means any type. This is a type-safe way to deal with possibly non-existing values. The <code class="literal">option</code> type is widely used; let's take <code class="literal">String.index</code> for example:</p><div class="informalexample"><pre class="programlisting">idx1 = String.index("love","I love Opa!")   //idx1 = {some:2}
idx2 = String.index("loving","I love Opa!") //idx2 = {none}</pre></div><p>The return type of <code class="literal">String.index</code> is the option (<code class="literal">int</code>), which means it will return a <code class="literal">{some:int}</code> record if a substring appears or a <code class="literal">{none}</code> record if it doesn't.</p><p>Note that the sum datatypes are not limited to two cases; they can have tens of cases.</p></div></div></div>
<div class="section" title="Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Functions</h1></div></div></div><p>Opa is a functional language. <a id="id62" class="indexterm"/>One of its features is that functions<a id="id63" class="indexterm"/> are regular values, which means a function may be passed as a parameter or returned as a result. As such, they follow the same naming rules as any other value.</p><div class="informalexample"><pre class="programlisting">function f(x,y){      // function f with the two parameters x and y
  x + y + 1
}
function int f(x,y){  // explicitly indicates the return type
  x + y + 1
}</pre></div><div class="section" title="Last expression return"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Last expression return</h2></div></div></div><p>You may <a id="id64" class="indexterm"/>notice that<a id="id65" class="indexterm"/> there is no return inside the body of a function. That's because Opa uses last expression return, which means the last expression of a function is the return value. For example:</p><div class="informalexample"><pre class="programlisting">function max(x,y){
  if(x &gt;= y) x else y
}</pre></div><p>If <code class="literal">x</code> is greater than or equal to <code class="literal">y</code>, then <code class="literal">x</code> is the last expression and <code class="literal">x</code> will be returned; if <code class="literal">y</code> is greater than <code class="literal">x</code>, then <code class="literal">y</code> is the last expression and <code class="literal">y</code> will be returned.</p></div><div class="section" title="Modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Modules</h2></div></div></div><p>Functionalities<a id="id66" class="indexterm"/> are <a id="id67" class="indexterm"/>usually regrouped into modules; for example:</p><div class="informalexample"><pre class="programlisting">module  M {
  x = 1
  y = x
  function test(){ jlog("testing") }
}</pre></div><p>We can access the content of a module by using the dot operator (<code class="literal">.</code>); for instance, <code class="literal">M.x</code>, <code class="literal">M.y</code>, and <code class="literal">M.test</code>. Actually, the content of a module is not field definitions, but bindings. In this example, we bind integer <code class="literal">1</code> to variable <code class="literal">x</code>, and bind the value of variable <code class="literal">x</code> to variable <code class="literal">y</code>.</p></div></div>
<div class="section" title="Data structures"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Data structures</h1></div></div></div><p>The only way to <a id="id68" class="indexterm"/>build data structures<a id="id69" class="indexterm"/> in Opa is to use records, which we will talk about later on. All other data structures, such as tuples and lists, are based on records. Opa provides different modules to help the user to manipulate lists and maps. Let's first have a look at records.</p><div class="section" title="Records"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Records</h2></div></div></div><p>Simply <a id="id70" class="indexterm"/>speaking, a record<a id="id71" class="indexterm"/> is a collection of data. Here is how to <a id="id72" class="indexterm"/>build a record:</p><div class="informalexample"><pre class="programlisting">x = {} // the empty record
x = {a:2,b:3} //a record with field "a" and "b"</pre></div><p>The empty record,<code class="literal">{}</code>, has a synonym, <code class="literal">void</code>, which means the same thing. There are a number of syntactic shortcuts available to write records concisely. First, if you give a field name without the field value, it means the value of this field is <code class="literal">void</code>:</p><div class="informalexample"><pre class="programlisting">x = {a}      // means {a:void}
x = {a, b:2} // means {a:void b:2}</pre></div><p>The second shorthand we always use is the sign <code class="literal">~</code>. It means if the field value is left empty, assign it with a variable having the same name as the field name:</p><div class="informalexample"><pre class="programlisting">x = {~a, b:2}    // means {a:a, b:2}
x = ~{a, b}      // means {a:a, b:b}
x = ~{a, b, c:4} // means {a:a, b:b, c:4}
x = ~{a:{b}, c}  // means {a:{b:void}, c:c}, NOT {a:{b:b}, c:c}
//Consider this more meaningful example
name = "Li"; sex  = "Male"; age  = 28; 
person = ~{name, sex, age} //means {name:"Li", sex:"Male", age: 28}</pre></div><p>We can also build a record deriving from an existing record using the keyword <code class="literal">with</code>:</p><div class="informalexample"><pre class="programlisting">x = {a:1,b:2,c:3}
y = {x with a:"1",b:5} // y = {a:"1", b:5, c:3}</pre></div><p>Note that <a id="id73" class="indexterm"/>you can redefine as many fields as you want. In the example we saw just now, the field <code class="literal">a</code> in <code class="literal">y</code> is a string, but the field <code class="literal">a</code> in <code class="literal">x</code> is an integer. Here are some more examples about deriving:</p><div class="informalexample"><pre class="programlisting">X = {a:1, b:{c:"2", d:3.0}}
// you can update fields deep in the record
y = {x with b.c:"200"}  // y = {a:1, b:{c:"200", d:3.0}}
// you can use the same syntactic shortcuts as used before
y = {x with a}          // means {x with a:void}
y = {x with ~a}         // means {x with a:a}
y = ~{x with a, b:{e}}  // means {x with a:a, b:{e}}</pre></div><div class="section" title="Tuples"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Tuples</h3></div></div></div><p>An N-tuple<a id="id74" class="indexterm"/> is <a id="id75" class="indexterm"/>a sequence of <span class="emphasis"><em>n</em></span> elements, where N is a positive integer. In Opa, an N-tuple is just a record with fields <code class="literal">f1</code> to <code class="literal">fN</code>:</p><div class="informalexample"><pre class="programlisting">x = (1,)          // a tuple of size 1, the same as {f1:1}
x = (1,"2",{a:3}) // a size 3 tuple, the same as {f1:1, f2:"2", f3:{a:3}} 
y = {x with f1:2} // we can manipulate a tuple the same way as a 
                    //record
// y = {f1:2, f2:"2", f3:{a:3}}</pre></div><p>Note the trailing comma in the first case; it differentiates a 1-tuple from a parenthesized expression. The trailing comma is allowed for any other tuple, although, it makes no difference whether you write it or not in these cases.</p></div></div><div class="section" title="Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Lists</h2></div></div></div><p>In Opa, <a id="id76" class="indexterm"/>a list (linked list) is <a id="id77" class="indexterm"/>an immutable data structure, meant to contain finite or infinite sets of elements of the same type. Actually, list is just a record with special structures, which is defined as:</p><div class="informalexample"><pre class="programlisting">type list('a) = {nil} or {'a hd, list('a) tl}</pre></div><p>Here is<a id="id78" class="indexterm"/> how to build lists:</p><div class="informalexample"><pre class="programlisting">x = []      // the empty list, equals to {nil}
x = [2,3,4] // a three element list, the same as a record: 
             // {hd:2, tl:{hd:3, tl:{hd:4, tl:{nil}}}}
y = [0,1|x] // this will put 0,1 on top of x: [0,1,2,3,4]</pre></div><p>Lists in Opa are much like arrays in C language and Java. But there are differences. First, lists are immutable in Opa, which means elements of a list cannot be changed by assignment. Second, the way we manipulate lists are different. We use the<a id="id79" class="indexterm"/> module <code class="literal">List</code> (<a class="ulink" href="http://doc.opalang.org/module/stdlib.core/List">http://doc.opalang.org/module/stdlib.core/List</a>) to manage lists in Opa. The following are the most commonly used operations on lists (which will be explained in the subsequent sections):</p><div class="informalexample"><pre class="programlisting">l = [1,2,3]
len = List.length(l)       // return the length of a list
isEmpty = List.is_empty(l) // test if a list is empty
head = List.head(l)        // get the first element, will fail if 
                             // the list is empty
element = List.get(0,l)    // get nth element, return option('a)
l1 = List.add(4,l)         // adding an element at the head of a 
                             //list
l2 = 4 +&gt; l                // a shortcut for List.add
l3 = List.remove(3,l)      // removing an element
l4 = List.drop(2,l)        // drop the first n elements</pre></div><div class="section" title="Iterating through a list"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Iterating through a list</h3></div></div></div><p>In C language<a id="id80" class="indexterm"/> or Java, we use a <code class="literal">for</code> or a <code class="literal">while</code> loop to iterate through lists or arrays. They look something like this:</p><div class="informalexample"><pre class="programlisting">int[] numbers = [1,2,3,4,5]
for(int i=0; i&lt;numbers.length; i++){ //do something }</pre></div><p>But in Opa, it is totally different. To loop through a list, we use <code class="literal">List.fold</code> <a id="id81" class="indexterm"/>or <code class="literal">List.foldi</code>. <code class="literal">List.fold</code>
<a id="id82" class="indexterm"/> is a powerful function that you can use to do almost anything you want on a list. Here is a simple example of getting the length of a list:</p><div class="informalexample"><pre class="programlisting">len = List.fold(function(_,i){ i+1 }, ["a","b","c"], 0)</pre></div><p>
<code class="literal">List.fold</code> takes three parameters. The first is a function, the second is the list, and the third is an initial value. It loops through the list and applies the function on each element. So, if we name the function <code class="literal">f</code>, it is executed something like this:</p><div class="informalexample"><pre class="programlisting">len = f("c", f("b", f("a",0)))</pre></div><p>First, <code class="literal">f("a",0)</code> will be executed and will return 1, here <code class="literal">0</code> is the initial value and <code class="literal">a</code> is the first element. Then <code class="literal">f("b",1)</code> will return 2 and at last <code class="literal">f("c",2)</code> will return 3. Here is a little more complicated example:</p><div class="informalexample"><pre class="programlisting">//find the max natural number in the list
max = List.fold(function(x,a){ 
  if(x &gt; a) x else a
},[1,4,3,2,7,8,5],0)</pre></div></div><div class="section" title="Finding elements"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Finding elements</h3></div></div></div><p>We have <a id="id83" class="indexterm"/>many ways to find an element in a list. <code class="literal">List.index</code>
<a id="id84" class="indexterm"/> searches the first occurrence of an element and returns its index. <code class="literal">List.index_p</code> <a id="id85" class="indexterm"/>searches the first occurrence of any element matching a given function and returns its index. <code class="literal">List.find</code>
<a id="id86" class="indexterm"/> is the same as <code class="literal">List.index_p</code>, but returns the element itself but not its index. For example:</p><div class="informalexample"><pre class="programlisting">l = ["a","b","c"]
r1 = List.index("b",l)                      // r1 = {some:1}
r2 = List.index("x",l)                      // r2 = {none}
r3 = List.index_p(function(x){ x == "b"},l) // r3 = {some:1}
r4 = List.find(function(x){ x == "b"},l)    // r4 = {some:"b"}</pre></div></div><div class="section" title="Transforming lists"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Transforming lists</h3></div></div></div><p>If you<a id="id87" class="indexterm"/> want to project elements to a new list, for example doubling the number in a list or selecting the odd numbers, you can do this with <code class="literal">List.map</code>
<a id="id88" class="indexterm"/> and <code class="literal">List.filter</code><a id="id89" class="indexterm"/>. Here are some examples:</p><div class="informalexample"><pre class="programlisting">l1 = [1,2,3,4,5]
l2 = List.map(function(x){ 2*x }, l1); //l2 = [2,4,6,8,10]
l3 = List.filter(function(x){mod(x,2) == 0},l1); // l3 = [2,4]</pre></div></div><div class="section" title="Sorting a list"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Sorting a list</h3></div></div></div><p>Call the<a id="id90" class="indexterm"/> function <code class="literal">List.sort</code>
<a id="id91" class="indexterm"/> to sort a list in the usual order. The usual order means the default order, that is, numbers from small to big and strings in alphabetical order. Consider the following code:</p><div class="informalexample"><pre class="programlisting">l1 = List.sort(["by","as","of","At"]) //l1 = ["At","as","by","of"]
l2 = List.sort([1,3,4,6,2])           //l2 = [1,2,3,4,6]</pre></div><p>
<code class="literal">List.sort_by</code>
<a id="id92" class="indexterm"/> uses the usual order, but it projects elements, for example, converting strings to <a id="id93" class="indexterm"/>lower-case before comparing them. <code class="literal">List.sort_with</code>
<a id="id94" class="indexterm"/> allows us to use our own comparing function.</p><p>To make that clear, suppose there are three points, P1 (1, 3), P2 (3, 2), and P3 (2, 1), and we want to sort them in two different ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By their Y coordinates</li><li class="listitem" style="list-style-type: disc">By distance from the origin of the coordinates (0, 0)</li></ul></div><p>Let's see how to do that in Opa:</p><div class="informalexample"><pre class="programlisting">p = [{x:1,y:3},{x:3,y:2},{x:2,y:1}]
l1 = List.sort_with(function(p1,p2){  // sort by Y corordination
  if(p1.y &gt;= p2.y) {gt} else {lt}
},p)
l2 = List.sort_by(function(p){        //sort by distance
  p.x*p.x + p.y*p.y    
},p)</pre></div></div></div><div class="section" title="Maps"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Maps</h2></div></div></div><p>Maps<a id="id95" class="indexterm"/> are an important data structure just like lists. The most common<a id="id96" class="indexterm"/> cases of maps in Opa are <code class="literal">stringmap</code>
<a id="id97" class="indexterm"/> and<a id="id98" class="indexterm"/> <code class="literal">intmap</code>. <code class="literal">stringmap</code> <a id="id99" class="indexterm"/>is a map from string to value of some type, while<a id="id100" class="indexterm"/> <code class="literal">intmap</code> is a map from numbers to value of some type.</p><p>The way we manipulate maps is almost the same as lists, it is unwise to repeat it again. Here are some of the most used operations:</p><div class="informalexample"><pre class="programlisting">m1 = Map.empty                 // create an empty map
m2 = StringMap.empty           // create an empty stringmap
m3 = IntMap.empty              // create an empty intmap
m4 = Map.add("key1","val1",m1) // adding a key-val pair
v1 = Map.get("key1",m4)        // getting a value
m5 = Map.remove("key1",m4)     // removing a key</pre></div></div></div>
<div class="section" title="Pattern matching"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Pattern matching</h1></div></div></div><p>Pattern matching <a id="id101" class="indexterm"/>is a <a id="id102" class="indexterm"/>generalization of C language or Java's <code class="literal">switch</code> statement. In C language and Java, the <code class="literal">switch</code> statement only allows you to choose from many statements based on an integer (including <code class="literal">char</code>) or an <code class="literal">enum</code> value. While in Opa, pattern matching is more powerful than that. The more general syntax for pattern matching is:</p><div class="informalexample"><pre class="programlisting">match(&lt;expr&gt;){
case &lt;case_1&gt;: &lt;expression_1&gt;
case &lt;case_2&gt;: &lt;expression_2&gt;
case &lt;case_n&gt;: &lt; expression_n&gt;
}</pre></div><p>When a pattern is executed, <code class="literal">&lt;expr&gt;</code> is evaluated to a value, which is then matched against each pattern in order until a case is found. You can think about it this way:</p><div class="informalexample"><pre class="programlisting">if (case_1 matched) expression_1 else {
  if (case_2 matched) expression_2 else {
    ...
         if (case_n matched) expression_n else no_matches
         ...
  }
}</pre></div><p>The <a id="id103" class="indexterm"/>rules of pattern matching are simple and are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule 1</strong></span>: Any value matches the pattern <code class="literal">_</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule 2</strong></span>: Any value matches the variable pattern <code class="literal">x</code>, and the value is bound to the identifier <code class="literal">x</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule 3</strong></span>: An integer/float/string matches an integer/float/string pattern when they are equal</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule 4</strong></span>: A record (including tuples and lists) matches a closed record pattern when both records have the same fields and the value of the fields matches the pattern component-wise</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule 5</strong></span>: A record (including tuples and lists) matches an open record pattern when the value has all the fields of the pattern (but can have more) and the value of the common fields matches the pattern component-wise</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule 6</strong></span>: A value matches a pattern as <code class="literal">x</code> pattern when the value matches the pattern, and additionally it binds <code class="literal">x</code> to the value</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule 7</strong></span>: A value matches an <code class="literal">OR</code> pattern if one of the values matches one of the two subpatterns</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule 8</strong></span>: In all the other cases, the matching fails</li></ul></div><p>The first three and the last three rules (rule 1, 2, 3, 6, 7, 8) are easy to understand. Let's take a look at them:</p><div class="informalexample"><pre class="programlisting">match(y){
case 0:       //if y == 0, match [rule 3]
case 1 as x:  //if y == 1, match and 1 is bound to x [rule 6]
case 2 | 3 :  //if y is 2 or 3, match [rule 7]
case x:       //any value will match and the value is bound
                //to x [rule 2]
case _:       //match, we do not care about the value.
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>This code will not compile, we just used it to illustrate the rules.</p></div></div><p>Rule 4 and rule 5<a id="id104" class="indexterm"/> are a little more complicated. A close record pattern is a record with fixed fields. An open record pattern is a record that ends with <code class="literal">…</code> to indicate that it may have other fields we do not care about. The following examples may make that clearer:</p><div class="informalexample"><pre class="programlisting">x = {a:1, b:2, c:3}
match(x){
case {a:1,b:2}:     //a close record pattern, but will not match //cause they do not have the same fields [rule 4]
case {a:1,b:2,c:2}: //a close record pattern, still will not match //cause c is not equal [rule 4]
case {a:1,b:2,...}: //An open record pattern, matches [rule 5]
}</pre></div><p>We can also match tuples and lists (since tuples and lists are special records, they are not hard to understand). For example:</p><div class="informalexample"><pre class="programlisting">t = (1,"2",3.0)
match(t){         //matching a tuple
case (1,"2",3.1): //not match, 3.1 != 3.0
case (1,"2",_):   //match, _ matches anything
case (1,"2",x):   //match, now x = 3.0
case {f1:1 ...}:  //match, remember tuples are just records
}
y = [1,2,3]
match(y){         //matching a list
case [1,2]:       //not match
case [1,2,_]:     //match, _ matches anything
case [1,2,x]:     //match, now x = 3
case [2,|_]:      //not match, '|_' means the rest of the list
case [1,|_]:      //match 
case [1,2,|_]:    //match
case [1,x|_]:     //match, now x = 2
}</pre></div></div>
<div class="section" title="Text parsers"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Text parsers</h1></div></div></div><p>Parsing is <a id="id105" class="indexterm"/>something that web apps need to do quite often. Opa features a built-in syntax for building <a id="id106" class="indexterm"/>text parsers<a id="id107" class="indexterm"/>, which<a id="id108" class="indexterm"/> are first class values just as functions. The parser is based on parsing expression grammar (<a class="ulink" href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">http://en.wikipedia.org/wiki/Parsing_expression_grammar</a>), which may look like regular expressions at first, but do not behave anything like them. One big advantage of text parsers over regular expressions is that you can easily combine parsers. A good example is parsing URLs. Let's start right away with our first Opa parser:</p><div class="informalexample"><pre class="programlisting">first_parser = parser { 
case "Opa"  : 1 
}</pre></div><p>For <code class="literal">first_parser</code>, <a id="id109" class="indexterm"/>the expressions are just literal strings, which means this parser will succeed only if fed with the string <code class="literal">"Opa"</code>. Then how to use this parser? The module <code class="literal">Parser</code> (<a class="ulink" href="http://doc.opalang.org/module/stdlib.core.parser/Parser">http://doc.opalang.org/module/stdlib.core.parser/Parser</a>) has a bunch of functions to deal with parsers. The most important one is:</p><div class="informalexample"><pre class="programlisting">Parser.try_parse : Parser.general_parser('a), string -&gt; option('a)</pre></div><p>It takes a parser and a string as parameters and produces an optional value of some type. Let's see how to use this function:</p><div class="informalexample"><pre class="programlisting">x = Parser.try_parse(parser1,"Opa")  //x = {some: 1}
y = Parser.try_parse(parser1,"Java") //y = {none}</pre></div><p>Now let's consider the following parsers:</p><div class="informalexample"><pre class="programlisting">digit1 = parser { case x=[0-9]+: x }
digit2 = parser { case x=([0-9]+): x }</pre></div><p>Both <code class="literal">digit1</code> and <code class="literal">digit2</code> accept a number string like <code class="literal">"5","100"</code>, and both will assign the value to the identifier <code class="literal">x</code>. If we feed the parser <code class="literal">digit1</code> with the string <code class="literal">"100"</code>, x will be the parsing result of the string: a list of characters [<code class="literal">'1','0','0'</code>]. If we feed the string <code class="literal">"100"</code> to parser <code class="literal">digit2</code>, <code class="literal">x</code> will be the input string: <code class="literal">100</code>. So, if we want to get hold of the input string, we need to put the expression in parentheses.</p><p>Let's move it a little further; consider the following parser:</p><div class="informalexample"><pre class="programlisting">abs_parser = parser{
  case x=("+"?[0-9]+): Int.of_string("{x}")
  case x=("-"[0-9]+) : 0 – Int.of_string("{x}")
}
x = Parser.try_parse(abs_parser,"-100") // x = {some: 100}</pre></div><p>This parser accepts<a id="id110" class="indexterm"/> an integer string and returns the absolute value. You may figure out how it works with the previous knowledge. Note that even if the expression of PEG looks like a regular expression, they are different.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>This chapter has introduced you to the basic syntax in Opa programming, including datatypes, functions, records, tuples, lists, maps, patterns, and parsers. This is the basic knowledge that we should know to make a good Opa program. With the previous knowledge, we will see how to develop a web application in the next chapter.</p></div></body></html>