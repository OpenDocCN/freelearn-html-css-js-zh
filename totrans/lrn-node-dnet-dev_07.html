<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Setting up an Automated Build" id="aid-181NK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Setting up an Automated Build</h1></div></div></div><p>In the previous chapter, we took a major step from a demo application to a maintainable codebase by starting to write automated tests. Another important component of real-world software projects is build automation.</p><p>Automated builds allow a whole team to work on a project in a consistent manner. A standardized way of executing common tasks makes it easier for new developers to get started. It also avoids annoying issues with developers getting different results for spurious reasons.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configuring an integration server to build and run our tests automatically</li><li class="listitem">Setting up an automated task runner to simplify the execution of our tests</li><li class="listitem">Automating more tasks to help maintain coding standards and test coverage</li></ul></div><div class="section" title="Setting up an integration server"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec35"/>Setting up an integration server</h1></div></div></div><p>Build and test automation allow code <a id="id245" class="indexterm"/>changes to be verified by an <span class="strong"><strong>integration server</strong></span>, an<a id="id246" class="indexterm"/> automated server independent of individual developers' machines. This helps keep the project stable by catching errors or regressions early on. The integration server can automatically alert the developer who introduced the problem. They then have a chance to fix the problem before it causes issues for the rest of the team or the project as a whole.</p><p>Building the codebase and running tests automatically on each commit is called <span class="strong"><strong>Continuous Integration</strong></span> (<span class="strong"><strong>CI</strong></span>). There are many CI/build servers available. These can be self-hosted or <a id="id247" class="indexterm"/>provided as a third-party service. Examples that you may have used before include Jenkins (formerly Hudson), Atlassian Bamboo, JetBrains TeamCity, and Microsoft's Team Foundation Server.</p><p>We're going to be using <a id="id248" class="indexterm"/>Travis CI (<a class="ulink" href="https://travis-ci.org/">https://travis-ci.org/</a>), which is a <a id="id249" class="indexterm"/>hosted service for running automated builds. It is free for use with public source code repositories. In order to use Travis CI's free service, we need to host <a id="id250" class="indexterm"/>our application's code in a public GitHub repository.</p><div class="section" title="Setting up a public GitHub repository"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec37"/>Setting up a public GitHub repository</h2></div></div></div><p>If you have <a id="id251" class="indexterm"/>your own version of the example application <a id="id252" class="indexterm"/>code from following along with the book so far, and are already familiar with GitHub, you can push your code to a new GitHub repository of your own. Otherwise, you can fork one of the example chapter repositories.</p><p>Use <a class="ulink" href="https://github.com/NodeJsForDevelopers/chapter06/">https://github.com/NodeJsForDevelopers/chapter06/</a> if you want to follow along with the changes in this chapter. This contains the example code from the end of <a class="link" title="Chapter 6. Testing Node.js Applications" href="part0034.xhtml#aid-10DJ41">Chapter 6</a>, <span class="emphasis"><em>Testing Node.js Applications</em></span>, which we will build on in this chapter. You can create your own fork of this repository using the <span class="strong"><strong>Fork</strong></span> button on GitHub. This should be visible at the top-right of the screen when visiting the URL mentioned earlier:</p><div class="mediaobject"><img src="../Images/image00219.jpeg" alt="Setting up a public GitHub repository"/></div><p style="clear:both; height: 1em;"> </p><p>This will create a new repository under your own GitHub account, using the example code as a starting point.</p><div class="note" title="Note"><h3 class="title"><a id="note09"/>Note</h3><p>This is all you need to get started in this chapter. However, if you are not already familiar with Git and/or <a id="id253" class="indexterm"/>GitHub and would like to know more, you can find more information at <a class="ulink" href="https://help.github.com/">https://help.github.com/</a>.</p></div></div><div class="section" title="Building a project on Travis CI"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec38"/>Building a project on Travis CI</h2></div></div></div><p>We'll now <a id="id254" class="indexterm"/>set up a build for our application on<a id="id255" class="indexterm"/> Travis CI. If you created your own public repository<a id="id256" class="indexterm"/> in the previous section, you can try this out for yourself. Visit <a class="ulink" href="https://travis-ci.org">https://travis-ci.org</a> and sign in with GitHub. You should see a profile page listing your repositories. Enable the repository you just created.</p><p>We have to create a simple <code class="literal">config</code> file to tell Travis CI in what environment(s) to build our application. Create a file in the root of the project as follows (note the leading dot in the file name <code class="literal">.travis.yml</code>):</p><div class="informalexample"><pre class="programlisting">language: node_js
node_js:
 - 6
 - 4</pre></div><p>This tells TravisCI to build our project with the current stable and long-term support versions of Node.js (at the time of writing). If you're familiar with Git, you can make this change in a<a id="id257" class="indexterm"/> local clone of your repository, commit,<a id="id258" class="indexterm"/> and push it to master. If you're new to Git, the easiest way to create this file is to navigate to your repository on <a class="ulink" href="https://github.com">https://github.com</a> and <a id="id259" class="indexterm"/>click on the <span class="strong"><strong>New file</strong></span> button. This will open a web-based editor from which you can create and commit the file.</p><p>Once you have added this file to <a id="id260" class="indexterm"/>your repository, visit <a class="ulink" href="https://travis-ci.org">https://travis-ci.org</a> again. You should now see a passing build for your repository:</p><div class="mediaobject"><img src="../Images/image00220.jpeg" alt="Building a project on Travis CI"/></div><p style="clear:both; height: 1em;"> </p><p>TravisCI built our project twice, once for each version of Node.js that we specified. If you click on either build you can see the command-line output. Notice that TravisCI automatically ran our tests using the standard <code class="literal">npm test</code> command.</p></div></div></div>
<div class="section" title="Automating the build process with Gulp" id="aid-190861"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Automating the build process with Gulp</h1></div></div></div><p>It's great that <a id="id261" class="indexterm"/>TravisCI runs our tests automatically. But<a id="id262" class="indexterm"/> that's not the only task we want to automate. Of course, as JavaScript is an interpreted language, we don't have a compile step in our build process. There are other tasks we want to carry out though, for example, checking our code style, running integration tests, and gathering code coverage. We can make use of a build tool to automate these tasks and allow us to run them in a consistent manner. You may have used MSBuild for this in .NET before or Java tools such as Maven or Gradle.</p><p>There are <a id="id263" class="indexterm"/>several different build tools available for <a id="id264" class="indexterm"/>Node.js. The two most popular by far are Grunt and Gulp. Both have large communities and an extensive range of plugins for performing different operations. Grunt's model has each operation reading in files and writing back to the filesystem. Gulp uses Node.js streams to pipe processing from one operation to the next.</p><p>Grunt's model is slightly simpler and may be easier to get started with, especially if you have modest build requirements. Gulp's model is potentially faster for some types of task and can reduce the amount of build configuration code you need to write. Both are excellent, well-supported build tools. We'll be using Gulp, but everything we do in this chapter could be achieved with Grunt as well.</p><div class="section" title="Running tests using Gulp"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec39"/>Running tests using Gulp</h2></div></div></div><p>We first <a id="id265" class="indexterm"/>need to install Gulp, both globally (to add it to our path) and into <a id="id266" class="indexterm"/>the project. Then we add Gulp plugins for controlling Mocha and environment variables:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install -g gulp-cli</strong></span>
<span class="strong"><strong>&gt; npm install gulp@~3.x --save-dev</strong></span>
<span class="strong"><strong>&gt; npm install gulp-mocha --save-dev</strong></span>
<span class="strong"><strong>&gt; npm install gulp-env --save-dev</strong></span>
</pre></div><p>We now add a configuration file for Gulp to our project. Gulp will look for a file with this name by convention as <code class="literal">gulpfile.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

const gulp = require('gulp');
const mocha = require('gulp-mocha');
const env = require('gulp-env');

gulp.task('test', function() {
  env({ vars: { NODE_ENV: 'test' } });
  return gulp.src('test/**/*.js')
    .pipe(mocha());
});

gulp.task('default', ['test']);</pre></div><p>This creates a test task and makes an empty default task to run it. The <code class="literal">'default'</code> task name is<a id="id267" class="indexterm"/> special and will be invoked when we run <code class="literal">gulp</code> from the<a id="id268" class="indexterm"/> command line. We can now remove our test script from <code class="literal">package.json</code> and update our <code class="literal">.travis.yml</code> file to run Gulp:</p><div class="informalexample"><pre class="programlisting">language: node_js
<span class="strong"><strong>before_script:</strong></span>
<span class="strong"><strong>  - npm install -g gulp</strong></span>
<span class="strong"><strong>script: gulp</strong></span>
node_js:
 - 6
 - 4 </pre></div><p>This hasn't gained us much yet. We now just have a slightly shorter command to execute our tests. However, the use of a build tool will become more valuable as we add more tasks to automate. Let's look at some of the other processes we may want to make part of our build.</p></div></div>
<div class="section" title="Checking code style with ESLint" id="aid-19UOO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Checking code style with ESLint</h1></div></div></div><p>Although <a id="id269" class="indexterm"/>we don't need a compiler, we can still benefit <a id="id270" class="indexterm"/>from having the computer perform static analysis of our code. Linting tools are common in many languages for spotting common programming errors that may lead to subtle bugs or confusing code. You may be familiar with CodeRush, StyleCop, and others for .NET, or CheckStyle, Findbugs, Sonar, and others for Java.</p><p>We'll be using a JavaScript/ECMAScript linting tool called ESLint. Let's first install it globally:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install -g eslint</strong></span>
</pre></div><p>Now create a config file to tell ESLint what rules to use as <code class="literal">.eslintrc.json</code>:</p><div class="informalexample"><pre class="programlisting">{
    "extends": "eslint:recommended",
    "env": {
        "node": true,
        "es6": true,
        "mocha": true,
        "browser": true,
        "jquery": true
	},
    "rules": {
        "semi": [2, "always"],
        "quotes": [2, "single"]
    }
}</pre></div><p>Here, we tell ESLint to use its standard recommended rules for the environments that we are using in our scripts. We also tell it to check for semicolons at the ends of statements and to prefer single quotes. You can run ESLint as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; eslint **/*.js</strong></span>
</pre></div><p>ESLint outputs<a id="id271" class="indexterm"/> any errors it finds, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">An<a id="id272" class="indexterm"/> unused <code class="literal">favicon</code> local variable in app.js</li><li class="listitem">The unused <code class="literal">next</code> parameter in various middleware functions</li><li class="listitem">The use of <code class="literal">console.log</code> in our PhantomJS integration test</li><li class="listitem">The use of the <code class="literal">phantom</code> variable in our PhantomJS integration test</li></ul></div><p>The first of these is trivial to solve: we can just remove the variable declaration (this was created for us by the express application template in <a class="link" title="Chapter 2. Getting Started with Node.js" href="part0018.xhtml#aid-H5A41">Chapter 2</a>, <span class="emphasis"><em>Getting Started with Node.js</em></span>). We could do the same for the <code class="literal">next</code> parameters on our middleware functions. However, I prefer middleware functions to have a standard and easily identifiable signature. Instead of removing this parameter, we can tell ESLint to ignore this particular parameter as follows:</p><div class="informalexample"><pre class="programlisting">    "rules": {
        "semi": [2, "always"],
        "quotes": [2, "single"],
<span class="strong"><strong>        "no-unused-vars": [2, {"argsIgnorePattern": "next"}]</strong></span>
    }</pre></div><p>The last two bullet points both relate to our PhantomJS integration test. This is quite a special file, so here we'll change ESLint's behavior for this file specifically, using a comment directive. We can add the following directives at the very top of the offending file, <code class="literal">integration-test/game.js</code>:</p><div class="informalexample"><pre class="programlisting">/*eslint-env phantomjs */
/*eslint-disable no-console */</pre></div><p>The first of these directives tells ESLint that this script file will run in the PhantomJS environment, where the <code class="literal">phantom</code> variable will be provided for us, so ESLint does not need to warn us against referencing it. The second directive disable's ESLint's rule against using console logging.</p><p>If you run ESLint again, you should find that the errors listed previously have disappeared. Any remaining errors should be smaller issues such as missing semicolons or inconsistent use of quotes. These should be quick to fix manually, but in fact, ESLint can do<a id="id273" class="indexterm"/> this <a id="id274" class="indexterm"/>for us, as we'll see in the next section.</p><div class="section" title="Automatically fixing issues in ESLint"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec40"/>Automatically fixing issues in ESLint</h2></div></div></div><p>ESLint is<a id="id275" class="indexterm"/> able to automatically correct some of the issues it finds. If ESLint is not currently reporting any errors, try removing a semicolon from one of the project's source files. Run ESLint and you should see an error for this.</p><p>Now run ESLint with the <code class="literal">--fix</code> option as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; eslint **/*.js --fix</strong></span>
</pre></div><p>ESLint replaces the semicolon for us. Not all of ESLint's rules can be fixed in this way, but many of them can. It depends on whether a rule's errors always have a single unambiguous fix. The full list of rules, including which ones are fixable, can be found on the ESLint site <a id="id276" class="indexterm"/>at <a class="ulink" href="http://eslint.org/docs/rules/">http://eslint.org/docs/rules/</a>.</p><p>You should now be able to run ESLint with no errors or warnings. ESLint is now ready to pick up errors in any new code that we write.</p></div><div class="section" title="Running ESLint from Gulp"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec41"/>Running ESLint from Gulp</h2></div></div></div><p>It's slightly <a id="id277" class="indexterm"/>messy to specify special exclusions for our Phantom integration test. It's also unfortunate that we're enabling the Node.js, Mocha, browser, and jQuery<a id="id278" class="indexterm"/> environments globally. The Mocha environment is only needed for our test code. The browser and jQuery environments are only need for our client-side code, where the Node.js environment is not needed.</p><p>This would be easier to manage if we ran ESLint separately on different sets of files. This would start to become tedious and error-prone if we did it manually. But it's a great use case for a build tool. We can set up separate ESLint profiles for different sets of files using Gulp. First, install the Gulp ESLint plugin:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install gulp-eslint --save-dev</strong></span>
</pre></div><p>Now we can create Gulp tasks to lint each set of sources. By default, the <code class="literal">gulp-eslint</code> plugin uses rules from our <code class="literal">.eslintrc.json</code> file. So, we can cut this down to just the rules that are relevant to all sources:</p><div class="informalexample"><pre class="programlisting">{
    "extends": "eslint:recommended",
    "rules": {
        "no-unused-vars": [2, { "args": "after-used" }],
        "quotes": [2, "single"],
        "semi": [2, "always"]
    }
}</pre></div><p>We can then specify the relevant rules or environments for each set of sources in their own<a id="id279" class="indexterm"/> Gulp task. This also allows us to remove the special directive <a id="id280" class="indexterm"/>comments from the top of our integration test script:</p><div class="informalexample"><pre class="programlisting">const eslint = require('gulp-eslint');

gulp.task('lint-server', function() {
    return gulp.src(['src/**/*.js', '!src/public/**/*.js'])
        .pipe(eslint({
            envs: [ 'es6', 'node' ],
            rules: {
                'no-unused-vars': [2, {'argsIgnorePattern': 'next'}]
            }
        }))
        .pipe(eslint.format())
        .pipe(eslint.failAfterError());
});
        
gulp.task('lint-client', function() {
    return gulp.src('src/public/**/*.js')
        .pipe(eslint({ envs: [ 'browser', 'jquery' ] }))
        .pipe(eslint.format())
        .pipe(eslint.failAfterError());
});

gulp.task('lint-test', function() {
    return gulp.src('test/**/*.js')
        .pipe(eslint({ envs: [ 'es6', 'node', 'mocha' ] }))
        .pipe(eslint.format())
        .pipe(eslint.failAfterError());
});

gulp.task('lint-integration-test', function() {
    return gulp.src('integration-test/**/*.js')
        .pipe(eslint({
            envs: [ 'browser', 'phantomjs', 'jquery' ],
            rules: { 'no-console': 0 }
        }))
        .pipe(eslint.format())
        .pipe(eslint.failAfterError());
});</pre></div><p>Finally, we wire up the dependencies between our tasks:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>gulp.task('test', ['lint-test'], function() {</strong></span>
  env({ vars: { NODE_ENV: 'test' } });
  return gulp.src('test/**/*.js')
    .pipe(mocha());
});

<span class="strong"><strong>gulp.task('lint', [</strong></span>
<span class="strong"><strong>  'lint-server', 'lint-client', 'lint-test', 'lint-integration-test'</strong></span>
<span class="strong"><strong>]);</strong></span>
gulp.task('default', ['lint', 'test']);</pre></div><p>Here, we <a id="id281" class="indexterm"/>make the <code class="literal">test</code> task depend on <code class="literal">lint-test</code> and create a <a id="id282" class="indexterm"/>new overall <code class="literal">lint</code> task to run all of the others as part of the default build. Try running Gulp and observe the output. Note that it kicks off all the lint tasks in parallel, but waits for <code class="literal">lint-test</code> to complete before running tests. By default, Gulp will run tasks concurrently if possible. If a task returns a stream (the object obtained from <code class="literal">gulp.src</code>) at the end, Gulp is able to use this to detect when the task finishes. Gulp will wait for a task to finish before starting any tasks that depend on it.</p><p>To see how ESLint failures affect Gulp, let's add another ESLint rule to ensure the use of JavaScript's strict mode, as described in <a class="link" title="Chapter 3. A JavaScript Primer" href="part0022.xhtml#aid-KVCC1">Chapter 3</a>, <span class="emphasis"><em>A JavaScript Primer</em></span>. The following code is from <code class="literal">.eslintrc.json</code>:</p><div class="informalexample"><pre class="programlisting">{
    "extends": "eslint:recommended",
    "rules": {
        "no-unused-vars": [2, { "args": "after-used" }],
        "quotes": [2, "single"],
        "semi": [2, "always"],
<span class="strong"><strong>        "strict": [2, "safe"]</strong></span>
    }
}</pre></div><p>ESLint is clever enough to make use of the specified environment for each set of files to work out how strict mode should be applied: at the top of functions for client-side scripts and globally for files that will become Node.js modules. It also spots when we unnecessarily specify strict mode multiple times, globally or in nested functions.</p><p>When you execute Gulp, notice that failures in the ESLint tasks prevent the dependent test tasks from running. If you fix the strict mode errors, then Gulp will run successfully again.</p></div></div>
<div class="section" title="Gathering code coverage statistics" id="aid-1AT9A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Gathering code coverage statistics</h1></div></div></div><p>Although <a id="id283" class="indexterm"/>we have some tests for our application, they are certainly not yet comprehensive. It would be useful to be able to see what parts of our code are covered by tests. For this, we'll use Istanbul, a JavaScript code coverage tool. First, install the <code class="literal">gulp-instanbul</code> plugin:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install gulp-istanbul --save-dev</strong></span>
</pre></div><p>Now we need to add a Gulp task to instrument our production code for coverage:</p><div class="informalexample"><pre class="programlisting">const istanbul = require('gulp-istanbul');

...

gulp.task('instrument', function() {
    return gulp.src('src/**/*.js')
        .pipe(istanbul())
        .pipe(istanbul.hookRequire())
});</pre></div><p>Finally, we need to update our test task to output a coverage report and fail the build if we are below our threshold:</p><div class="informalexample"><pre class="programlisting">gulp.task('test', ['lint-test', 'instrument'], function() {
    gulp.src('test/**/*.js')
        .pipe(mocha())
<span class="strong"><strong>        .pipe(istanbul.writeReports())</strong></span>
<span class="strong"><strong>        .pipe(istanbul.enforceThresholds({</strong></span>
<span class="strong"><strong>            thresholds: { global:90 }</strong></span>
<span class="strong"><strong>        }));</strong></span>
});</pre></div><p>Now, when we run Gulp, three new results occur:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A coverage summary appears on the command line</li><li class="listitem">A set of coverage reports appear under the <code class="literal">coverage</code> folder</li><li class="listitem">The build fails because we are below the coverage threshold</li></ul></div><p>The build summary on the command line is very useful. There is even more detail in the HTML report that appears at <code class="literal">coverage/lcov-report/index.html</code> (in the project directory).</p><p>Although we need to improve our test coverage, we don't want to leave our build failing. For now, we'll set the coverage target just below our current level so it doesn't drop further. We can do this with the options passed to <code class="literal">istanbul.enforceThresholds</code>:</p><div class="informalexample"><pre class="programlisting">gulp.task('test', ['lint-test', 'instrument'], function() {
    return gulp.src('test/**/*.js')
        .pipe(mocha())
        .pipe(istanbul.writeReports())
        .pipe(istanbul.enforceThresholds({
<span class="strong"><strong>            thresholds: {</strong></span>
<span class="strong"><strong>                global: {</strong></span>
<span class="strong"><strong>                    statements: 70,</strong></span>
<span class="strong"><strong>                    branches: 50</strong></span>
<span class="strong"><strong>                }</strong></span>
<span class="strong"><strong>            }</strong></span>
        }));
});</pre></div></div>
<div class="section" title="Running integration tests from Gulp" id="aid-1BRPS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Running integration tests from Gulp</h1></div></div></div><p>Gulp tasks <a id="id284" class="indexterm"/>are just ordinary JavaScript functions, so<a id="id285" class="indexterm"/> can contain any functionality we like. Let's look at a more complex use case. We'll create a task that starts up our server, runs integration tests, and then closes the server. For this, we'll need the Gulp Shell plugin:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install gulp-shell --save-dev</strong></span>
</pre></div><p>First, we update our integration test script so that we can pass in the port number of the test server. This makes use of the PhantomJS <code class="literal">'system'</code> module as follows (in <code class="literal">integration-test/game.js</code>):</p><div class="informalexample"><pre class="programlisting">var rootUrl = 'http://localhost:' +
                  require('system').env.TEST_PORT || 3000;</pre></div><p>Now we can define a Gulp task to run the server and the integration test:</p><div class="informalexample"><pre class="programlisting">const shell = require('gulp-shell');

...

gulp.task('integration-test',
          ['lint-integration-test', 'test'], (done) =&gt; {
  const TEST_PORT = 5000;
  let server = require('http')
    .createServer(require('./src/app.js'))
    .listen(TEST_PORT, function() {
      gulp.src('integration-test/**/*.js')
        .pipe(shell('node node_modules/phantomjs-prebuilt/bin/phantomjs &lt;%=file.path%&gt;', {
            env: { 'TEST_PORT': TEST_PORT }
        }))
        .on('error', () =&gt; server.close(done))
        .on('end', () =&gt; server.close(done))
    });
});</pre></div><p>This launches the application and then makes use of the <code class="literal">gulp-shell</code> plugin to execute our integration test scripts. Finally, we make sure we close the server when done, passing in Gulp's async callback. Like returning a stream, using this callback allows Gulp to know when the task<a id="id286" class="indexterm"/> has completed.</p><p>We make this<a id="id287" class="indexterm"/> task depend on the <code class="literal">test</code> task so that they don't interfere with one another. We don't make this part of our default task as it's a more heavyweight operation. We do want it to run on our build server though, so we'll add it to <code class="literal">.travis.yml</code> along with the default task:</p><div class="informalexample"><pre class="programlisting">language: node_js
before_script:
  - npm install -g gulp
<span class="strong"><strong>script: gulp default integration-test</strong></span>
node_js:
 - 5
 - 4</pre></div><p>Now, if we push to the remote master, TravisCI will run static analysis on our code, execute all of our unit and integration tests, and check the unit test coverage.</p></div>
<div class="section" title="Summary" id="aid-1CQAE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we have set up an integration build using Travis CI, added static analysis of our code using ESLint, automated our tests and other tasks using Gulp, and started measuring our test coverage using the Istanbul tool.</p><p>Now that we have the infrastructure in place for stable development, we can start expanding our project. In the next chapter, we'll introduce persistent data stores to the application.</p></div></body></html>