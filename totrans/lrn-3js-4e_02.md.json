["```js\n// create a camera\nconst camera = new THREE.PerspectiveCamera(\n  75,\n  window.innerWidth / window.innerHeight,\n  0.1,\n  1000\n);\n// create a renderer\nconst renderer = new THREE.WebGLRenderer({ antialias: true\n  });\n// create a scene\nconst scene = new THREE.Scene();\n// create the lights\nscene.add(new THREE.AmbientLight(0x666666));\nscene.add(THREE.DirectionalLight(0xaaaaaa));\n// create the floor\nconst geo = new THREE.BoxBufferGeometry(10, 0.25, 10, 10,\n  10, 10);\nconst mat = new THREE.MeshStandardMaterial({ color:\n  0xffffff,});\nconst mesh = new THREE.Mesh(geo, mat);\nscene.add(mesh);\n```", "```js\nconst addCube = (scene) => {\n  const color = randomColor();\n  const pos = randomVector({\n    xRange: { fromX: -4, toX: 4 },\n    yRange: { fromY: -3, toY: 3 },\n    zRange: { fromZ: -4, toZ: 4 },\n  });\n  const rotation = randomVector({\n    xRange: { fromX: 0, toX: Math.PI * 2 },\n    yRange: { fromY: 0, toY: Math.PI * 2 },\n    zRange: { fromZ: 0, toZ: Math.PI * 2 },\n  });\n  const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);\n  const cubeMaterial = new THREE.MeshStandardMaterial({\n    color: color,\n    roughness: 0.1,\n    metalness: 0.9,\n  });\n  const cube = new THREE.Mesh(geometry, cubeMaterial);\n  cube.position.copy(pos);\n  cube.rotation.setFromVector3(rotation);\n  cube.castShadow = true;\n  scene.add(cube);\n};\n```", "```js\nconst removeCube = (scene) => {\n  scene.children.pop();\n};\n```", "```js\nscene.fog = new THREE.Fog( 0xffffff, 1, 20 );\n```", "```js\nscene.fog = new THREE.FogExp2( 0xffffff, 0.01 );\n```", "```js\nnew THREE.WebGLRenderer({ alpha: true }}\n```", "```js\n// remove any background by setting the background to null\nscene.background = null;\n// if you want a simple color, just set the background to a\n  color\nscene.background = new THREE.Color(0x44ff44);\n// a texture can be loaded with a THREE.TextureLoader\nconst textureLoader = new THREE.TextureLoader();\ntextureLoader.load(\n  \"/assets/textures/wood/abstract-antique-\n    backdrop-164005.jpg\",\n  (loaded) => {\n    scene.background = loaded;\n  }\n// a cubemap can also be loaded with a THREE.TextureLoader\n     textureLoader.load(\"/assets/equi.jpeg\", (loaded) => {\n  loaded.mapping = THREE.EquirectangularReflectionMapping;\n  scene.background = loaded;\n});\n```", "```js\nconst geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);\nconst cubeMaterial = new THREE.MeshStandardMaterial({\n  color: color,\n  roughness: 0.1,\n  metalness: 0.9,\n});\nconst cube = new THREE.Mesh(geometry, cubeMaterial);\n```", "```js\ntextureLoader.load(\"/assets/equi.jpeg\", (loaded) => {\n  loaded.mapping = THREE.EquirectangularReflectionMapping;\n  scene.environment = loaded;\n});\n```", "```js\nconst sphereGeometry = new THREE.SphereGeometry(4, 20, 20);\nconst sphereMaterial = new THREE.MeshBasicMaterial({color:\n  0x7777ff);\nconst sphere = new THREE.Mesh(sphereGeometry,\n  sphereMaterial);\nscene.add(sphere);\n```", "```js\nconst v = [\n    [1, 3, 1],\n    [1, 3, -1],\n    [1, -1, 1],\n    [1, -1, -1],\n    [-1, 3, -1],\n    [-1, 3, 1],\n    [-1, -1, -1],\n    [-1, -1, 1]]\nconst faces = new Float32Array([\n  ...v[0], ...v[2], ...v[1],\n  ...v[2], ...v[3], ...v[1],\n  ...v[4], ...v[6], ...v[5],\n  ...v[6], ...v[7], ...v[5],\n  ...v[4], ...v[5], ...v[1],\n  ...v[5], ...v[0], ...v[1],\n  ...v[7], ...v[6], ...v[2],\n  ...v[6], ...v[3], ...v[2],\n  ...v[5], ...v[7], ...v[0],\n  ...v[7], ...v[2], ...v[0],\n  ...v[1], ...v[3], ...v[4],\n  ...v[3], ...v[6], ...v[4]\n]);\nconst bufferGeometry = new THREE.BufferGeometry();\nbufferGeometry.setAttribute(\"position\", new THREE.BufferAttribute(faces, 3));\nbufferGeometry.computeVertexNormals();\n```", "```js\nmesh.geometry.attributes.position.needsUpdate = true;\nmesh.geometry.computeVertexNormals();\n```", "```js\nconst cloneGeometry = (scene) => {\n  const clonedGeometry = bufferGeometry.clone();\n  const backingArray = clonedGeometry.getAttribute\n    (\"position\").array;\n  // change the position of the x vertices so it is placed\n  // next to the original object\n  for (const i in backingArray) {\n    if ((i + 1) % 3 === 0) {\n      backingArray[i] = backingArray[i] + 3;\n    }\n  }\n  clonedGeometry.getAttribute(\"position\").needsUpdate =\n    true;\n  const cloned = meshFromGeometry(clonedGeometry);\n  cloned.name = \"clonedGeometry\";\n  const p = scene.getObjectByName(\"clonedGeometry\");\n  if (p) scene.remove(p);\n  scene.add(cloned);\n};\n```", "```js\nconst meshFromGeometry = (geometry) => {\n  var materials = [\n    new THREE.MeshBasicMaterial({ color: 0xff0000,\n      wireframe: true }),\n    new THREE.MeshLambertMaterial({\n      opacity: 0.1,\n      color: 0xff0044,\n      transparent: true,\n    }),\n  ];\n  var mesh = createMultiMaterialObject(geometry, materials);\n  mesh.name = \"customGeometry\";\n  mesh.children.forEach(function (e) {\n    e.castShadow = true;\n  });\n  return mesh;\n};\n```", "```js\ncube.position.x = 10;\ncube.position.y = 3;\ncube.position.z = 1;\n```", "```js\ncube.position.set(10,3,1);\n```", "```js\ncube.position = new THREE.Vector3(10,3,1)\n```", "```js\ncube.rotation.x = 0.5*Math.PI;\ncube.rotation.set(0.5*Math.PI, 0, 0);\ncube.rotation = new THREE.Vector3(0.5*Math.PI,0,0);\n```", "```js\nconst degrees = 45;\nconst inRadians = degrees * (Math.PI / 180);\n```", "```js\ncamera.lookAt(new THREE.Vector3(x, y, z));\n```", "```js\nconst helper = new THREE.CameraHelper(camera);\nscene.add(helper);\n// in the render loop\nhelper.update();\n```"]