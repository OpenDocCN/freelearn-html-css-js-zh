<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-172">8. <a id="_idTextAnchor210"/>Dependency Injection in TypeScript</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>) in TypeScript. It demonstrates how to implement the DI design pattern. You will also see some common use cases for the DI pattern, including ones from libraries such as Angular and Nest.js. This chapter will teach you how to build a simple Angular application that uses DI. You will also learn some basics of InversifyJS and how to use it in your TypeScript applications. By the end of this chapter, you will be able to build a calculator application that utilizes DI using InversifyJS.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor211"/>Introduction</h1>
			<p>A design pattern is a general, repeatable way to solve a commonly recurring problem in software design. It is not just code that you can paste and use in your own code, but a guideline to writing code. It is usually not tied to any specific language, so a given pattern can be transformed from language to language, with its implementation changed to match the desired language and environment.</p>
			<p>Design patterns can usually be used in many different situations and help you solve a lot of different problems. For example, if you want to make sure you only have one active connection to a database, you may want to use the Singleton design pattern, which basically ensures that only a single instance of something exists, or if you want to write an ORM tool (an object-relational mapping tool, for abstracting away a database) that allows the use of multiple databases, you may want to use the Adapter design pattern, which allows the ORM tool to talk to multiple types of database drivers using a "common language."</p>
			<p>Using design patterns can speed up development, since they are battle-tested through decades of prior usages, in a variety of problems. Furthermore, if working in a team, it is easier to explain a solution to a given problem compared with conventional methods. Design patterns serve as a sort of "common language."</p>
			<p>Note that when beginning to learn the concepts of design patterns, it may be difficult to wrap your head around them, and you may find it harder to solve problems with them than without them. This is because it's not straightforward to spot when a specific design pattern fits a given problem, especially when you don't have experience using it, or don't understand either the pattern or the problem completely. There are also some patterns that are commonly easier to understand than others (for example, the Singleton pattern is easier to understand than the Adapter pattern).</p>
			<p>Furthermore, if you're just beginning to use a design pattern, its usefulness may not be apparent until further down the project lifetime, where you might actually want to add features that you may have not initially thought of or even just fix bugs. Lastly, it's important to note that not every problem can be solved using a design pattern, and using the wrong one may entail more issues than it solves. Also, not every problem requires a design pattern – you can add as many patterns as you want to a "Hello World" program, but their usefulness will be doubtful. So, it's important to take a step back and see whether using it really fits the problem you're trying to solve.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor212"/>The DI Design Pattern</h1>
			<p>DI is a technique whereby one object supplies the dependencies of another object. A dependency of an object is <em class="italic">anything</em> required in order to perform its operation in the application. Before diving into an explanation of what DI is, let's try to understand the fundamental element in the preceding definition with an example.</p>
			<p>Let's say we have two classes:</p>
			<div><div><img src="img/B14508_08_01.jpg" alt="Figure 8.1: A simple class dependency&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1: A simple class dependency</p>
			<p>As shown in the preceding diagram, Class A uses some properties/methods of Class B. Thus, we can say that <code>ClassB</code> is a dependency of <code>ClassA</code>.</p>
			<p>Let's look at a more real-world example (albeit simplified). Most websites, whether social media websites, government websites for disbursal of services, or e-commerce platforms, require a user to register in order to use the services offered by the website. Imagine you are developing one such website. You require a <code>UserRegistrationService</code> class to gather user details, save them in a database, a file, or any other repository, and then send an email to the user informing them of a successful registration.</p>
			<p>Your website's method for handling the registration process would therefore probably look something like this:</p>
			<pre>class UserRegistrationService {
    registerUser(email: string, password: string) {
        // TODO: process registration
        // TODO: send registration success email
    }
}</pre>
			<p>This service has two primary responsibilities – saving the user's details to persistent storage and sending them an email. For now, you are not concerned with whether the details are stored in a database, SaaS, or a file. In the same vein, you are not concerned if the registration email is automated or done manually. Thus, we just want to get <em class="italic">some</em> <code>UserRepository</code>, and <em class="italic">some</em> <code>EmailService</code>, as shown here:</p>
			<pre>interface User {
    email: string;
    password: string;
}
interface UserRepository {
    save(user: User): Promise&lt;User&gt;;
}
interface EmailService {
    sendEmail(to: string, subject: string, body?: string): Promise&lt;void&gt;;
}</pre>
			<p>As mentioned, we don't care about their implementation, or even creating them; we want someone else to do that, so our implementation of <code>UserRegistrationService</code> could look something like this:</p>
			<pre>class UserRegistrationService {
    constructor(
        private userRepository: UserRepository,
        private emailService: EmailService
    ) {}
    async registerUser(email: string, password: string){
        await this.userRepository.save({
            email,
            password,
        });
        await this.emailService.sendEmail(email, 'Welcome to my website!');
    }
}</pre>
			<p>Note that we don't know what the actual implementation behind <code>UserRepository</code> or <code>EmailService</code> is; we just know their structure.</p>
			<p>Now, if we change how users are saved, for example, deciding to migrate from a file to a MySQL database, or if we change our email provider from Mailchimp to SendGrid, the <code>UserRegistrationService</code> class stays intact and should still function as before as long as any implementation thereof conforms to the same <code>UserRepository</code> and <code>EmailService</code> interfaces (for example, have the same structure – same method signatures, with the same parameters, and so on) and provide the same functionality as described previously.</p>
			<p>For example, in the following code snippets, notice both the file-based and the MySQL-based implementations, implement <code>UserRepository</code>, which is the only thing that <code>UserRegistrationService</code> is aware of.</p>
			<p>The file-based implementation is as follows:</p>
			<pre>// FileUserRepository.ts
import * as fs from 'fs';
class FileUserRepository implements UserRepository {
  save(user: User): Promise&lt;User&gt; {
    return new Promise((resolve, reject) =&gt; {
      fs.appendFile('users.txt', JSON.stringify(user), err =&gt; {
        if (err) return reject(err);
        resolve(user);
      });
    });
  }
}</pre>
			<p>The MySQL-based implementation is as follows:</p>
			<pre>// MySqlUserRepository.ts
import mysql from 'mysql';
class MySqlUserRepository implements UserRepository {
  connection = mysql.createConnection({
    // connection details
  });
  save(user: User): Promise&lt;User&gt; {
    return new Promise((resolve, reject) =&gt; {
      return this.connection.query(
        `INSERT INTO users (email, password)
        VALUES (?, ?)`,
        [user.email, user.password],
        (err, data) =&gt; {
          if (err) return reject(err);
          resolve(data);
        }
      );
    });
  }
}</pre>
			<p>To put it simply, DI allows us to separate the <em class="italic">what</em> from the <em class="italic">how</em>. The dependent class only needs to know <em class="italic">how</em> to interact with <em class="italic">a user repository</em> – by calling a method called <code>save</code>, with a single parameter of the <code>User</code> type), as well as with <em class="italic">an email sender</em> – by calling a method called <code>sendEmail</code> that takes in two parameters; a <em class="italic">to</em> email address, of the <code>string</code> type, a second parameter for the email's subject, also of the <code>string</code> type, and an optional third parameter for the email's body (also of the <code>string</code> type). </p>
			<p>Then, these services can handle the <em class="italic">what should (actually) be done</em> portion – saving the user's details to a file, to a MySQL database, or an entirely different thing, and then sending the email automatically using an SaaS service, queuing them for manual sending later, or anything else.</p>
			<p>Going back to the dependency chart, in this example, the dependencies are as follows:</p>
			<div><div><img src="img/B14508_08_02.jpg" alt="Figure 8.2: UserRegistrationService dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2: UserRegistrationService dependencies</p>
			<p>Another benefit of having used DI here is that it simplifies testing our implementations separately from their dependencies. For example, when testing the <code>registerUser</code> method of <code>UserRegistrationService</code>, we only want to test the <code>registerUser</code> method; we don't care about how its dependencies behave in production (we will test these separately). We can just mock them with any implementation while testing to have them behave how we want. Remember that the whole point of DI is that we don't care about what the dependencies do and how they do it, as long as they conform to the agreed-upon interface – <code>UserRepository</code> and <code>EmailService</code> in this case. Here is how we would test the <code>registerUser</code> method in code:</p>
			<pre>interface User {
  email: string;
  password: string;
}
test('User registration', async () =&gt; {
  const mockUserRepository: UserRepository = {
    async save(user: User) {
      return user;
    },
  };
  const mockEmailService: EmailService = {
    async sendEmail(to: string, subject: string, body?: string) {},
  };
  const userRegistrationService = new UserRegistrationService(
    mockUserRepository,
    mockEmailService
  );
  await userRegistrationService.registerUser(
    'example@domain.com',
    'super-secret-password'
  );
  expect(mockUserRepository.save).toHaveBeenCalled();
  expect(mockEmailService.sendEmail).toHaveBeenCalled();
  // ...
});</pre>
			<p>Even though the preceding examples only demonstrate classes, dependencies can be of any type – classes, functions, plain objects, and even simple constants (depending on the language and specific implementation). </p>
			<p>For example, if <code>UserRegistrationService</code> were to require a constant value, for example, a salt to hash the user's password with, it would be provided in the constructor, too, as another argument, as shown here:</p>
			<pre>import * as bcrypt from 'bcrypt';
class UserRegistrationService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService,
    private passwordHashSalt: string
  ) {}
  async registerUser(email: string, password: string) {
    const hashedPassword = await bcrypt.hash(password, this.passwordHashSalt);
    await this.userRepository.save({
      email,
      password: hashedPassword,
    });
    await this.emailService.sendEmail(email, 'Welcome to my website!');
  }
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The following sections will be using decorators, covered in <em class="italic">Chapter 7. Decorators</em>. Please make sure that you have read and understood them before continuing, as decorators are an essential part of how all DI libraries covered next are built on.</p>
			<p>Another concept related to DI is <code>UserRepository</code> abstraction over the <code>MySqlUserRepository</code> implementation), in IoC, the concern is to let the consumer decide what should be done by the component/library. For example, in our implementation of <code>UserRegistrationService</code> above, we used IoC, since we allow how the user's details are sent, as well as how an email is sent by the consumer, to be specified. In the application's case, it could decide whether it wanted to use <code>FileUserRepository</code> or <code>MySqlUserRepository</code>, and in the test code we decided that both of them should do nothing. This was also decided at the consumer (test code) level. </p>
			<p>To summarize, DI concerns itself with letting a class know about abstractions over implementations, while IoC's concerns revolve around letting the consumer decide about the implementation(s) that should be used.</p>
			<p>Some popular frameworks, both in the frontend as well as the backend, have embraced DI as a core part of their framework – the most popular ones are Angular in frontend development and Nest.js in the backend. DI allows applications built on top of these frameworks to be very robust and flexible, especially in large applications due to the nature of DI, which allows the creation of classes (and other dependencies) to be separated from their usage.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor213"/>DI in Angular</h2>
			<p>Another actual real-world example of DI can be found in the Angular framework – a modern framework for building frontend applications using TypeScript. Angular has its own implementation for a DI library. Furthermore, the Angular framework itself, as well as apps built on it, heavily relies on this DI implementation.</p>
			<p>Let's take a look at a simple Angular app and see how DI makes it straightforward to build an easy-to-maintain, scalable application.</p>
			<p>An Angular app is made up of several <code>NgModule</code>, each of which is usually a logical part of an app – this can be a feature, a UI components library, or anything else. Each <code>NgModule</code> can have two types of "things:"</p>
			<ol>
				<li>Declarations (<code>Component</code> and <code>Directive</code>)</li>
				<li>Providers (usually <code>Service</code>)</li>
			</ol>
			<p><em class="italic">Declarations</em> are what constitute the UI of the app, things such as the <code>WelcomeMessageComponent</code> class (shown in the following snippet), which takes in <code>name</code> as an input (using the <code>@Input</code> decorator, which is kind of like passing in parameters to a function or a constructor of a class, just with components), and displays it in an HTML <code>h1</code> tag (an HTML tag to display a main header):</p>
			<pre>import { Component, Input } from '@angular/core';
@Component({
    selector: 'welcome-message',
    template: `
        &lt;h1&gt;Welcome {{ name }}!&lt;/h1&gt;
    `,
})
export class WelcomeMessageComponent {
    @Input() name: string;
}</pre>
			<p>The preceding code will yield the following output:</p>
			<div><div><img src="img/B14508_08_03.jpg" alt="Figure 8.3: Displayed output of rendering WelcomeMessageComponent &#13;&#10;with &quot;John&quot; passed in to the name input&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: Displayed output of rendering WelcomeMessageComponent with "John" passed in to the name input</p>
			<p>Providers are usually services, which hold the main logic of the app and are usually used for anything that's not specifically related to the UI. </p>
			<p>For example, you could have a <code>UsersService</code> class that handles fetching a list of users from a backend, as shown here:</p>
			<pre>import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
export interface User {
    name: string;
}
@Injectable()
export class UsersService {
    getUsers(): Observable&lt;User[]&gt; {
        return of([
            { name: 'Alice' },
            { name: 'Bob' },
            { name: 'Charlie' }
        ]);
    }
}</pre>
			<p>The preceding code has a <code>UsersService</code> class that has a single method – <code>getUsers()</code>, which returns a static array of <code>User</code> objects. Note that we wrap our static array with <code>of()</code>, which takes a static value and wraps it in an <code>Observable</code>, so we can later change the behavior of this method to asynchronously return data (for example, from a remote endpoint, as we'll see next).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">An observable is an asynchronous stream of data, basically allowing data to be passed between "publishers" and "subscribers." This data can be a one-time operation, such as with an HTTP call, can have multiple emits (for example, emit an increasing number from 1 through 10, in sequence, every 1 second), or can even be infinite (for example, emitting an event every time the user clicks a specific button). It is part of the Observer pattern.</p>
			<p>We would then use <code>UsersService</code> in our <code>UsersList</code> component, which displays the users in a list, as shown here:</p>
			<pre>import { Component } from "@angular/core";
import { Observable } from "rxjs";
import { UsersService, User } from "./users.service";
@Component({
  selector: 'users-list',
  template: `
    &lt;ul&gt;
      &lt;li *ngFor="let user of (users$ | async)"&gt;
        {{ user.name }}
      &lt;/li&gt;
    &lt;/ul&gt;
  `
})
export class UsersListComponent {
  readonly users$: Observable&lt;User[]&gt;;
  constructor(private usersService: UsersService) {
    this.users$ = usersService.getUsers();
  }
}</pre>
			<p>Here, we create a simple component, <code>UsersListComponent</code>, that displays a list of users, which it gets from <code>UsersService</code> that's <em class="italic">injected</em> into it at creation time by the Angular DI.</p>
			<p>Once the service is injected, we call <code>getUsers()</code> and store the returned <code>Observable</code> in a <code>users$</code> member so we can later access it from the template, which utilizes the <code>async</code> pipe to tell Angular to subscribe to the <code>Observable</code> and update the template when its underlying value changes:</p>
			<div><div><img src="img/B14508_08_04.jpg" alt="Figure 8.4: The output from running the app&#13;&#10;"/>
				</div>
			</div>
			<p> </p>
			<p class="figure-caption">Figure 8.4: The output from running the app</p>
			<p>We won't dive into Angular's template engine or change detection mechanisms – those are two big topics in themselves – but you can refer to the Angular documentation for more information on that. Instead, let's focus on what's going on with regard to DI – notice that we asked for a <code>UsersService</code> object in the <code>UsersListComponents</code> constructor; we didn't specify that we wanted to get a specific instance of the service and so on, just that we want one. This is very powerful, since this offloads the logic of how and where this service is instantiated to a dedicated place (the <code>NgModule</code>) and opens up a lot of possibilities. We could test the component more easily (by providing a fake <code>UsersService</code>), or even just replace the <code>UsersService</code> implementation at runtime with another one.</p>
			<p>Angular providers can also require other providers; for example, we could have a generic HTTP client service that knows how to make HTTP calls, and then inject that into our <code>UsersService</code>, which can focus on more high-level details such as the endpoint, which it needs to use in order to fetch the users. In fact, Angular has such an HTTP service built in, called <code>HttpClient</code>. You can use it and fix the mock implementation we had for the users with a real one, utilizing DI further as shown here:</p>
			<pre>import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
export interface User {
    name: string;
}
@Injectable()
export class UsersService {
    constructor(private httpClient: HttpClient) {}
    getUsers(): Observable&lt;User[]&gt; {
        return this.httpClient.get&lt;User[]&gt;('/api/users');
    }
}</pre>
			<p>Here, we ask for an <code>HttpClient</code> and use its <code>get()</code> method to make a <code>GET</code> request to the <code>/api/users</code> endpoint in our site, which should return an array of <code>User</code> objects – that is, objects with a property called <code>name</code>, with a <code>string</code> type.</p>
			<p>This replaces the mock implementation we had earlier with a more real-world use case by calling an external endpoint instead of returning a static list of users. </p>
			<p>Again, notice that we just asked for an <code>HttpClient</code> interface again. We don't care about how it's implemented (this could involve using <code>XMLHttpRequest</code>, <code>fetch</code>, or even another underlying library), as long as it conforms to the <code>HttpClient</code> interface.</p>
			<p>You may have noticed that the path that we request from <code>HttpClient</code> is a relative one. This works if our backend is on the same domain as our frontend (for example, <a href="https://example.com">https://example.com</a> is our website and <a href="https://example.com/api/users">https://example.com/api/users</a> would return the users). However, if we want to move our backend to a different server, this will break our website. In the next exercise, we will fix this, using Angular's DI mechanism and by adding <code>HttpInterceptor</code>. </p>
			<p><code>HttpInterceptor</code> is an interface Angular provides that we can implement in order to "hook," or even change network requests, either on their way out (the request), or on their way back (the response), before any other consumer "sees" the response. This will work wherever <code>HttpClient</code> is used in the application, without requiring any more code modifications in other services that use <code>HttpClient</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The example discussed in this section is the basis of our next exercise. </p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor214"/>Exercise 8.01: Adding HttpInterceptor to an Angular App</h2>
			<p>In this exercise, we'll add <code>HttpInterceptor</code> to our existing Angular application, which we built in the preceding section, to allow our backend service to sit on a different domain from our frontend application. This allows the two applications to be separated completely, and very easily, without requiring any extra changes in the rest of the application. Here are the steps to complete this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you run <code>npm install</code> in the <code>exercise-starter</code> directory. The code files for this exercise can be found here: <a href="https://packt.link/avWRA">https://packt.link/avWRA</a>. This repository contains two folders, <code>exercise-starter</code> and <code>exercise-solution</code>. The former contains the template files that you can use to code along with this exercise, whereas the latter contains the final code of this exercise for your reference.</p>
			<ol>
				<li value="1">Start by cloning the application we have written so far in this section. This can be found at <a href="https://packt.link/JAgZ7">https://packt.link/JAgZ7</a>.</li>
				<li>Create a class, <code>ApiHttpInterceptor</code>, in a new file, <code>api-http.interceptor.ts</code>, and save the file in the <code>exercise-starter</code>/<code>src/app/interceptors/</code> folder. This file implements the <code>HttpInterceptor</code> interface (imported from <code>@angular/common/http</code>). Be sure to mark it with the <code>@Injectable</code> decorator so that Angular knows it's a service that can be used in DI:<pre>import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
@Injectable()
export class ApiHttpInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    throw new Error('Method not implemented.');
  }
}</pre><p>Angular will call the <code>intercept()</code> method of <code>ApiHttpInterceptor</code> when a request is made by any <code>HttpClient</code>. We get the request (<code>req</code>) and <code>HttpHandler</code> (<code>next</code>), which we need to call when we're finished to let Angular call any other <code>HttpInterceptor</code> in the chain.</p></li>
				<li>Update the code to change the URL path:<pre>import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from "@angular/common/http";
import { Injectable } from "@angular/core";
import { Observable } from "rxjs";
@Injectable()
export class ApiHttpInterceptor implements HttpInterceptor {
    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    if (!req.url.startsWith('/api/')) {
      return next.handle(req);
    }
    const relativeUrl = req.url.replace('/api/', '');
    const newRequest = req.clone({
url: `https://jsonplaceholder.typicode.com/${relativeUrl}`
    });
    return next.handle(newRequest);
  }
}</pre><p>The preceding code checks the URL path. For each request, if it's issued to a relative path, starting with <code>/api</code>, the code changes it. It does so by looking at the <code>url</code> property of <code>HttpRequest</code>. If the URL doesn't start with <code>/api</code>, you don't need to do anything, just call <code>next.handle()</code> with the original request. Otherwise, clone the original request with a new URL, and then call <code>next.handle()</code> with the new request. This is the request that will actually be sent out. We're using <a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a> here, a free service that has some predefined endpoints we can use to get data from, for testing purposes. In an actual application, this would be your backend service's endpoint.</p><p>Lastly, we also need to register this interceptor in our <code>AppModule</code> so that it can know what interceptors to inject into <code>HttpClient</code>. We do this by adding <code>ApiHttpInterceptor</code>, which we created as a provider, and we tell Angular to use it when looking for <code>HTTP_INTERCEPTORS</code> – this is the DI symbol that Angular uses when it asks for all the interceptors it needs to use when making a network request via the <code>HttpClient</code> service. </p></li>
				<li>Open the <code>app.module.ts</code> file present in the <code>exercise-starter/src/app</code> folder and update it with the code given here: <pre>import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { ApiHttpInterceptor } from './interceptors/api-http.interceptor';
import { UsersListComponent } from './users-list.component';
import { UsersService } from './users.service';
import { WelcomeMessageComponent } from './welcome-message.component';
@NgModule({    
  imports: [BrowserModule, HttpClientModule],
  declarations: [AppComponent, WelcomeMessageComponent, UsersListComponent],   
  providers: [UsersService, { <code>HTTP_INTERCEPTORS</code> list (notice the bold line).</p></li>
				<li>Run the new app by running <code>npm start -- --open</code> in the <code>exercise-starter</code> directory. Your default browser should open up at <code>http://localhost:4200</code>, and you should see a list of 10 users:</li>
			</ol>
			<div><div><img src="img/B14508_08_05.jpg" alt="Figure 8.5: Output of the exercise&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5: Output of the exercise</p>
			<p>If you open the DevTools, you should see only one request to the <code>users</code> endpoint, which is for <a href="https://jsonplaceholder.typicode.com/users">https://jsonplaceholder.typicode.com/users</a> (and not <a href="http://localhost:4200/users">http://localhost:4200/users</a>):</p>
			<div><div><img src="img/B14508_08_06.jpg" alt="Figure 8.6: Requests to the users endpoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: Requests to the users endpoint</p>
			<p>Notice that our <code>UsersService</code> didn't change at all here (and you can imagine the benefits if we had dozens of services like it), but it is still working as expected from its point of view.</p>
			<p>All the code explained in this section and the exercise is just some examples of how DI comes into play in Angular. However, there is much more. You can register any value as a dependency to be injected (not just classes). You can control the instantiation of the providers to be Singletons for the entire app, creating a new instance for every <code>NgModule</code> or even for every <code>Component</code> instance. You can also create them using some more complex logic via factories and more. You have just scratched the surface of the very powerful DI library that Angular offers.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor215"/>DI in Nest.js</h2>
			<p>Another framework to look at, also heavily inspired by Angular's architecture, is Nest.js, which also heavily utilizes DI. Nest.js is a framework for building backend applications using Node.js and TypeScript. Like Angular, Nest.js also has <code>Modules</code> (equivalent to Angular's <code>NgModule</code>), and <code>Providers</code>. It also has <code>Controller</code>, which handles incoming requests from clients and returns responses. These are similar to Angular's components – both are what the consumers see. In Angular, <code>Component</code> and <code>Directive</code> make up the UI, and in Nest.js, <code>Controller</code> makes up the API to be consumed.</p>
			<p>We won't dive into Nest.js' architecture, but here's a small example of a couple of things that it leverages DI for:</p>
			<pre>import { Controller, Get, Param } from '@nestjs/common';
import { HelloService } from './hello.service';
@Controller('hello')
export class HelloController {
  constructor(private helloService: HelloService) {}
  @Get(':username')
  async getByUsername(@Param('username') username: string) {
    const message = await this.helloService.getHello(username);
    return { message };
  }
}</pre>
			<p>This is a simple "Hello World" controller, which, for a <code>GET</code> request to <code>/hello/foo</code>, will return <code>{ message: "Hello foo" }</code>. A controller is a container for endpoints under a given prefix (so in this case, any request that starts with <code>"/hello"</code> will end up going to this controller), and the <code>@Get</code> decorator around the <code>getByUserName()</code> function tells Nest.js to call that method when a <code>GET</code> method is performed to the given path (the paths of the individual methods/decorators are concatenated to those of the controller) – <code>"/hello/:username"</code> in this case (anything starting with a <code>:</code> is a placeholder for dynamic content. In this case, <code>:username</code> is the placeholder, and we can get it by using the <code>Param</code> decorator, giving it the placeholder's name).</p>
			<p>Notice that we get <code>HelloService</code> in the constructor, similar to Angular, via DI. We also get the username param from the <code>Param</code> decorator, which also leverages DI behind the scenes to get the current <code>Request</code> object. Lastly, the framework is responsible for creating both <code>HelloService</code> and <code>HelloController</code> for us; we don't need to do so ourselves. This, like in Angular, makes testing <code>HelloController</code> easy, since you can just fake <code>HelloService</code> in your tests with a mock implementation to either assert or modify the behavior of the controller. This is a very simple example, but you can imagine <code>HelloService</code> replaced with something like an authentication service, or an ORM tool for accessing the database.</p>
			<p>In the next section, we'll cover InversifyJS – an IoC container for TypeScript (and JavaScript) applications. Unlike Angular, which is only for the frontend, or Nest.js, which is only for the backend, and which are both frameworks that dictate what your application's architecture will be (at least at some level), InversifyJS is a generic library that only does IoC and allows you to use DI in any application.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor216"/>InversifyJS</h1>
			<p>InversifyJS is an implementation of an IoC container (inversion of control, which DI is part of) for TypeScript (and JavaScript) applications. It is one of many implementations and, as we've seen above, some frameworks come with their own DI solution, such as Angular or Nest.js.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Other alternatives to InversifyJS for general-purpose projects include <code>TypeDI</code> and <code>TSyringe</code>, as well as <code>typescript-ioc</code>.</p>
			<p>The basic idea in InversifyJS, as in most other implementations for an IoC container, is to have one place that defines all the concrete implementations of functionality, and the rest of the app only depends on abstractions (for example, interfaces). This greatly reduces coupling, and changing one implementation to another doesn't affect the entire app or require lots of code changes.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Coupling is about how tightly integrated/dependent two components (usually classes) are, in the sense that if we change one of them, how likely is the other to break without applicable changes to it too? The more tightly integrated/connected two components are to one another, the more coupled they are, and vice versa.</p>
			<p class="callout">Ideally, changing one class should not require changes in others. In such cases, the classes are considered decoupled (or loosely coupled).</p>
			<p>To make InversifyJS work, we first need to add a <code>typeof</code> and <code>instanceof</code> operators.</p>
			<p>In addition, since InverisfyJS works through decorators, you need to enable them by setting <code>experimentalDecorators</code> and <code>emitDecoratorMetadata</code> to <code>true</code> in your project's <code>tsconfig.json</code> file (note the <strong class="bold">bold</strong> lines):</p>
			<pre>{
    "compilerOptions": {
        "target": "es5",
        "lib": ["es6", "dom"],
        "types": ["reflect-metadata"],
        "module": "commonjs",
        "moduleResolution": "node",
<strong class="bold">        "experimentalDecorators": true,</strong>
<strong class="bold">        "emitDecoratorMetadata": true</strong>
    }
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">There are additional requirements in order for InversifyJS to work, but all modern browsers and Node.js versions should be able to use it without further polyfills. For more details, visit the following link: <a href="https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md">https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md</a>.</p>
			<p>Just as with Angular and Nest.js' DI containers (<code>NgModule</code> and <code>Module</code>, respectively), InversifyJS also needs to know how to resolve dependencies. This is generally configured in a single place, usually in a file named <code>inversify.config.ts</code> in the root of the project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is the recommendation, but this file can be placed anywhere and named anything, or split into multiple files; for example, for separating the registration of classes of different features or domains, similar to <code>NgModules</code> in Angular or <code>Modules</code> in Nest.js.</p>
			<p>This file should be the only place in the application where there is coupling. The rest of the app should only be dependent on abstractions.</p>
			<p>These abstractions will usually be interfaces, but you can also depend on a specific implementation, or a <code>class</code> (which can then be injected with a compatible subclass).</p>
			<p>In addition, since interfaces in TypeScript only exist at compile time (see <em class="italic">Chapter 7</em>, <em class="italic">Inheritance and Interfaces</em>), InversifyJS also requires a runtime abstraction token to know what to resolve.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor217"/>Exercise 8.02: "Hello World" Using InversifyJS</h2>
			<p>In this exercise, we'll create a simple "hello world" application using InversifyJS. We'll implement all the basic building blocks for a typical use case. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/bXSTd">https://packt.link/bXSTd</a>.</p>
			<ol>
				<li value="1">First, create the abstraction for our logger using an <code>interface</code> in a new file called <code>logger.interface.ts</code> in the <code>src</code> folder. This is what consumers will reference later:<pre>export interface Logger {
    log(message: string): void;
}</pre></li>
				<li>Next, create a concrete implementation for <code>Logger</code>. This implementation is what the consumers of the code will get injected with when they require <code>Logger</code> later on:<pre>import { injectable } from "inversify";
import { Logger } from "./logger.interface";
@injectable()
export class ConsoleLogger implements Logger {
    log(message: string) {
        console.log(message);
    }
}</pre><p>Note that <code>ConsoleLogger</code> implements <code>Logger</code>. This ensures that we write a compatible implementation to what our consumers expect, and that they don't break at runtime. In addition, the <code>@injectable</code> decorator is used to indicate to InversifyJS that this implementation can be used <em class="italic">as a dependency</em>, and also that it can be injected to <em class="italic">other dependencies</em>. This is how we make InversifyJS aware that <code>ConsoleLogger</code> is something that it should be aware of.</p></li>
				<li>Create a new file called <code>types.ts</code> in the <code>src</code> folder. Then, define an injection token that consumers can rely on later to ask InversifyJS to inject whatever implementation is behind it at runtime: <pre>export const TYPES = {
    Logger: Symbol.for("Logger"),
};</pre><p>In this exercise, we'll stick with the recommended approach of creating a <code>TYPES</code> object that resolves to a <code>Symbol</code> for each type (using an injection token is required in most DI libraries in TypeScript, since interfaces don't exist at runtime, so InversifyJS can't rely on them).</p><p class="callout-heading">Note</p><p class="callout">If your target environment doesn't support <strong class="bold">symbols</strong>, you can instead use a plain string. Just ensure that you don't have the same string registered for multiple types.</p></li>
				<li>Create a new file called <code>ioc.config.ts</code> in the <code>src</code> folder. Then, configure the IoC container using the following code: <pre>import { Container } from "inversify";
import { ConsoleLogger } from "./console-logger";
import { Logger } from "./logger.interface";
import { TYPES } from "./types";
<code>console-logger</code>, <code>logger.interface</code>, and <code>types</code>) together:</p></li>
				<li>Create a consumer for the logger in a new file called <code>main.ts</code> in the <code>src</code> folder. Notice that we use the <code>@inject</code> decorator to tell InversifyJS that we want the <code>Logger</code> type:<pre>import "reflect-metadata";
import { inject, injectable } from "inversify";
import { container } from "./ioc.config";
import { Logger } from "./logger.interface";
import { TYPES } from "./types";
@injectable()
class Main {
    constructor(@inject(TYPES.Logger) private logger: Logger) {}
    run() {
        this.logger.log('Hello from InversifyJS!');
    }
}
// Run the app:
const main = container.resolve(Main);
main.run();</pre><p class="callout-heading">Note</p><p class="callout">The interface type annotation is just for TypeScript to be able to type check the <code>logger</code> instance, but since interfaces only exist at compile time, this is irrelevant for runtime, in which the argument passed to <code>@inject</code> is what matters.</p></li>
				<li>Now, run the app by executing <code>npm start</code> in the parent directory. You should get the following output on your console:<pre>Hello from InversifyJS!</pre></li>
			</ol>
			<p>Of course, for such a simple example, it would have been better to just have a single line as follows:</p>
			<pre>console.log('Running');</pre>
			<p>However, in more complex applications, and even simple ones, DI can help, especially if the application is expected to be actively maintained, with the addition of features and the fixing of bugs happening all the time.</p>
			<p>In the next activity, you will be tasked with creating a more complex app to demonstrate how DI can help us develop applications while keeping best practices in mind to make the app easy to maintain.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor218"/>Activity 8.01: DI-Based Calculator</h2>
			<p>As a TypeScript developer, you are tasked with creating a calculator. Like any calculator, you need your app to do the four basic math operations of addition (+), subtraction (-), multiplication (*), and division (/). </p>
			<p class="callout-heading">Note </p>
			<p class="callout">To keep things simple and focused solely on DI, you won't be adding support for additional operators (for example, power (^)), or support the order of operations, so your calculator will just walk through the expression from left to right and perform the relevant operation. For example, the expression (<code>13+5*3-7</code> will result in <code>47</code> and not the mathematically correct <code>21</code>). </p>
			<p>To complete this activity, you will have to implement InversifyJS and utilize IoC to provide the math operators that the calculator can operate on. </p>
			<p>You can start with the starter project and build it up by following the high-level steps provided here. This activity will challenge the skills that you have developed not only in this chapter but also in preceding ones. Hence, feel free to glance at the solution to debug any issues you may have with your implementation or code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This activity is based on the last section, on InversifyJS, so be sure you understand it fully before moving on to this one. You can find both the activity starter and solution at <a href="https://packt.link/Pt3Vq">https://packt.link/Pt3Vq</a>. The <code>activity-starter</code> folder contains the template files you can use to code along with this activity. The <code>activity-solution</code> folder contains the files representing the solution of this activity. </p>
			<p>Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">You will have to start off by creating the basic building block of your calculator – an operator defined via an interface.</li>
				<li>Then, create operators for addition, subtraction, multiplication, and division.<p>For the preceding two steps, note that you need to create the requisite abstract interface and injection token.</p></li>
				<li>Implement a calculator class that uses these operators via InversifyJS. This file represents your main app. You might need to map all expression parts and parse them. For this, you can refer to the <code>maths.ts</code> file placed in the <code>src/utils</code> folder, which creates and exports two such functions – <code>tryParseNumberString</code> and <code>tryParseOperatorSymbol</code>.</li>
				<li>Configure the IoC container (present in the <code>src/ioc.config.ts</code> file) so that <code>Calculator</code> can receive <code>AddOperator</code>, <code>SubtractOperator</code>, and so on when it asks for <code>TYPES.AddOperator</code>, for example. You can simplify the <code>ioc.config.ts</code> file further by using barrels. The code for this can be found in the <code>operator/index.ts</code> file. You can use the code in the aforementioned file to configure and then simplify your IoC container.</li>
				<li>Create the <code>main.ts</code> file that will kick-start your calculator.<p>After solving the preceding steps, the expected output should look like the following:</p><pre>result is 150</pre></li>
				<li><strong class="bold">Bonus Steps:</strong><p>As a bonus, let's say that you want some reporting on the operations performed in the calculator. You can add logging (console- and file-based) easily without too many changes:</p></li>
				<li>For console-based logging, you need to add a logger via DI that the calculator will write to on every expression evaluation. You can follow the given sequence to do so. First, you need to define the <code>Logger</code> interface. Then, create the console-based implementation of <code>Logger</code>. Next, create an injection token for it and register it in our container. Then, use the logger in the code for the main calculator app.</li>
				<li>Now, let's say we want to replace our console-based logger with a file-based one, which will persist across runs so that we can track the calculator's evaluation history.</li>
				<li>To do this, you first need to create a <code>FileLogger</code> class that implements <code>Logger</code> in a new file in the <code>src/logger</code> folder. Then, you need to make a single-line change in the <code>ioc.config.ts</code> file, which you used for console-based logging.<p>For console-based logging, use this command:</p><pre>container.bind&lt;Logger&gt;(TYPES.Logger).to(ConsoleLogger);</pre><p>For file-based logging, use this command:</p><pre>container.bind&lt;Logger&gt;(TYPES.Logger).to(FileLogger);</pre><p>However, note that you will have to correctly import all <code>Logger</code> interfaces across all files.</p><p>The output for the console-based logger is as follows:</p><pre>[LOG] Calculated result of expression:13*10+20 is 150</pre><p>The output for the file-based logger is as follows:</p><div><img src="img/B14508_08_07.jpg" alt="Figure 8.7: Final output of the file-based logger in activity-starter/src/tmp/calculator.log, after changing the app to use it&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.7: Final output of the file-based logger in activity-starter/src/tmp/calculator.log, after changing the app to use it</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor421">this link</a>.</p>
			<p>The solution to this activity (<code>activity-solution</code>) also includes unit tests for everything, so you can see how easy testing is when IoC is used as well as check that your own implementation passes the tests. In addition, <code>activity-solution</code> also includes a file that creates a <code>ConfigurationService</code> to supply <code>FileLogger</code> with a dynamic <code>loggerPath</code>, with implementations for an in-memory one, or an environment variables-based one.</p>
			<p>There is a lot more ground to cover on InversifyJS. However, this chapter serves as a good start. We encourage you to take a look at the official documentation to learn more about what it can offer and to see further examples, including factories, container modules, and middlewares. However, these topics are beyond the scope of this chapter.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor219"/>Summary</h1>
			<p>This chapter equipped you first with the fundamentals of DI in TypeScript by explaining how you can implement the DI design pattern and by taking you through a number of use cases. You also learned how to build a basic Angular app using DI. </p>
			<p>This chapter also introduced some basics of InversifyJS and explained how to use it in your applications. You have seen how easy it is to add or change dependencies without breaking the code for other consumers, along with the power of IoC and DI to replace one implementation with another in a very simple manner, for all consumers.</p>
			<p>Of course, there's a lot more to this topic in general than this chapter covered. However, this chapter serves as a good start in getting up and running with DI in TypeScript. In the next chapter, you will learn about generics in TypeScript.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>