<html><head></head><body>
		<div>
			<div id="_idContainer096" class="Content">
			</div>
		</div>
		<div id="_idContainer097" class="Content">
			<h1 id="_idParaDest-172">8. <a id="_idTextAnchor210"/>Dependency Injection in TypeScript</h1>
		</div>
		<div id="_idContainer105" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>) in TypeScript. It demonstrates how to implement the DI design pattern. You will also see some common use cases for the DI pattern, including ones from libraries such as Angular and Nest.js. This chapter will teach you how to build a simple Angular application that uses DI. You will also learn some basics of InversifyJS and how to use it in your TypeScript applications. By the end of this chapter, you will be able to build a calculator application that utilizes DI using InversifyJS.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor211"/>Introduction</h1>
			<p>A design pattern is a general, repeatable way to solve a commonly recurring problem in software design. It is not just code that you can paste and use in your own code, but a guideline to writing code. It is usually not tied to any specific language, so a given pattern can be transformed from language to language, with its implementation changed to match the desired language and environment.</p>
			<p>Design patterns can usually be used in many different situations and help you solve a lot of different problems. For example, if you want to make sure you only have one active connection to a database, you may want to use the Singleton design pattern, which basically ensures that only a single instance of something exists, or if you want to write an ORM tool (an object-relational mapping tool, for abstracting away a database) that allows the use of multiple databases, you may want to use the Adapter design pattern, which allows the ORM tool to talk to multiple types of database drivers using a "common language."</p>
			<p>Using design patterns can speed up development, since they are battle-tested through decades of prior usages, in a variety of problems. Furthermore, if working in a team, it is easier to explain a solution to a given problem compared with conventional methods. Design patterns serve as a sort of "common language."</p>
			<p>Note that when beginning to learn the concepts of design patterns, it may be difficult to wrap your head around them, and you may find it harder to solve problems with them than without them. This is because it's not straightforward to spot when a specific design pattern fits a given problem, especially when you don't have experience using it, or don't understand either the pattern or the problem completely. There are also some patterns that are commonly easier to understand than others (for example, the Singleton pattern is easier to understand than the Adapter pattern).</p>
			<p>Furthermore, if you're just beginning to use a design pattern, its usefulness may not be apparent until further down the project lifetime, where you might actually want to add features that you may have not initially thought of or even just fix bugs. Lastly, it's important to note that not every problem can be solved using a design pattern, and using the wrong one may entail more issues than it solves. Also, not every problem requires a design pattern – you can add as many patterns as you want to a "Hello World" program, but their usefulness will be doubtful. So, it's important to take a step back and see whether using it really fits the problem you're trying to solve.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor212"/>The DI Design Pattern</h1>
			<p>DI is a technique whereby one object supplies the dependencies of another object. A dependency of an object is <em class="italic">anything</em> required in order to perform its operation in the application. Before diving into an explanation of what DI is, let's try to understand the fundamental element in the preceding definition with an example.</p>
			<p>Let's say we have two classes:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B14508_08_01.jpg" alt="Figure 8.1: A simple class dependency&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1: A simple class dependency</p>
			<p>As shown in the preceding diagram, Class A uses some properties/methods of Class B. Thus, we can say that <strong class="source-inline">ClassB</strong> is a dependency of <strong class="source-inline">ClassA</strong>.</p>
			<p>Let's look at a more real-world example (albeit simplified). Most websites, whether social media websites, government websites for disbursal of services, or e-commerce platforms, require a user to register in order to use the services offered by the website. Imagine you are developing one such website. You require a <strong class="source-inline">UserRegistrationService</strong> class to gather user details, save them in a database, a file, or any other repository, and then send an email to the user informing them of a successful registration.</p>
			<p>Your website's method for handling the registration process would therefore probably look something like this:</p>
			<p class="source-code">class UserRegistrationService {</p>
			<p class="source-code">    registerUser(email: string, password: string) {</p>
			<p class="source-code">        // TODO: process registration</p>
			<p class="source-code">        // TODO: send registration success email</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This service has two primary responsibilities – saving the user's details to persistent storage and sending them an email. For now, you are not concerned with whether the details are stored in a database, SaaS, or a file. In the same vein, you are not concerned if the registration email is automated or done manually. Thus, we just want to get <em class="italic">some</em> <strong class="source-inline">UserRepository</strong>, and <em class="italic">some</em> <strong class="source-inline">EmailService</strong>, as shown here:</p>
			<p class="source-code">interface User {</p>
			<p class="source-code">    email: string;</p>
			<p class="source-code">    password: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">interface UserRepository {</p>
			<p class="source-code">    save(user: User): Promise&lt;User&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">interface EmailService {</p>
			<p class="source-code">    sendEmail(to: string, subject: string, body?: string): Promise&lt;void&gt;;</p>
			<p class="source-code">}</p>
			<p>As mentioned, we don't care about their implementation, or even creating them; we want someone else to do that, so our implementation of <strong class="source-inline">UserRegistrationService</strong> could look something like this:</p>
			<p class="source-code">class UserRegistrationService {</p>
			<p class="source-code">    constructor(</p>
			<p class="source-code">        private userRepository: UserRepository,</p>
			<p class="source-code">        private emailService: EmailService</p>
			<p class="source-code">    ) {}</p>
			<p class="source-code">    async registerUser(email: string, password: string){</p>
			<p class="source-code">        await this.userRepository.save({</p>
			<p class="source-code">            email,</p>
			<p class="source-code">            password,</p>
			<p class="source-code">        });</p>
			<p class="source-code">        await this.emailService.sendEmail(email, 'Welcome to my website!');</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Note that we don't know what the actual implementation behind <strong class="source-inline">UserRepository</strong> or <strong class="source-inline">EmailService</strong> is; we just know their structure.</p>
			<p>Now, if we change how users are saved, for example, deciding to migrate from a file to a MySQL database, or if we change our email provider from Mailchimp to SendGrid, the <strong class="source-inline">UserRegistrationService</strong> class stays intact and should still function as before as long as any implementation thereof conforms to the same <strong class="source-inline">UserRepository</strong> and <strong class="source-inline">EmailService</strong> interfaces (for example, have the same structure – same method signatures, with the same parameters, and so on) and provide the same functionality as described previously.</p>
			<p>For example, in the following code snippets, notice both the file-based and the MySQL-based implementations, implement <strong class="source-inline">UserRepository</strong>, which is the only thing that <strong class="source-inline">UserRegistrationService</strong> is aware of.</p>
			<p>The file-based implementation is as follows:</p>
			<p class="source-code">// FileUserRepository.ts</p>
			<p class="source-code">import * as fs from 'fs';</p>
			<p class="source-code">class FileUserRepository implements UserRepository {</p>
			<p class="source-code">  save(user: User): Promise&lt;User&gt; {</p>
			<p class="source-code">    return new Promise((resolve, reject) =&gt; {</p>
			<p class="source-code">      fs.appendFile('users.txt', JSON.stringify(user), err =&gt; {</p>
			<p class="source-code">        if (err) return reject(err);</p>
			<p class="source-code">        resolve(user);</p>
			<p class="source-code">      });</p>
			<p class="source-code">    });</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The MySQL-based implementation is as follows:</p>
			<p class="source-code">// MySqlUserRepository.ts</p>
			<p class="source-code">import mysql from 'mysql';</p>
			<p class="source-code">class MySqlUserRepository implements UserRepository {</p>
			<p class="source-code">  connection = mysql.createConnection({</p>
			<p class="source-code">    // connection details</p>
			<p class="source-code">  });</p>
			<p class="source-code">  save(user: User): Promise&lt;User&gt; {</p>
			<p class="source-code">    return new Promise((resolve, reject) =&gt; {</p>
			<p class="source-code">      return this.connection.query(</p>
			<p class="source-code">        `INSERT INTO users (email, password)</p>
			<p class="source-code">        VALUES (?, ?)`,</p>
			<p class="source-code">        [user.email, user.password],</p>
			<p class="source-code">        (err, data) =&gt; {</p>
			<p class="source-code">          if (err) return reject(err);</p>
			<p class="source-code">          resolve(data);</p>
			<p class="source-code">        }</p>
			<p class="source-code">      );</p>
			<p class="source-code">    });</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>To put it simply, DI allows us to separate the <em class="italic">what</em> from the <em class="italic">how</em>. The dependent class only needs to know <em class="italic">how</em> to interact with <em class="italic">a user repository</em> – by calling a method called <strong class="source-inline">save</strong>, with a single parameter of the <strong class="source-inline">User</strong> type), as well as with <em class="italic">an email sender</em> – by calling a method called <strong class="source-inline">sendEmail</strong> that takes in two parameters; a <em class="italic">to</em> email address, of the <strong class="source-inline">string</strong> type, a second parameter for the email's subject, also of the <strong class="source-inline">string</strong> type, and an optional third parameter for the email's body (also of the <strong class="source-inline">string</strong> type). </p>
			<p>Then, these services can handle the <em class="italic">what should (actually) be done</em> portion – saving the user's details to a file, to a MySQL database, or an entirely different thing, and then sending the email automatically using an SaaS service, queuing them for manual sending later, or anything else.</p>
			<p>Going back to the dependency chart, in this example, the dependencies are as follows:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B14508_08_02.jpg" alt="Figure 8.2: UserRegistrationService dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2: UserRegistrationService dependencies</p>
			<p>Another benefit of having used DI here is that it simplifies testing our implementations separately from their dependencies. For example, when testing the <strong class="source-inline">registerUser</strong> method of <strong class="source-inline">UserRegistrationService</strong>, we only want to test the <strong class="source-inline">registerUser</strong> method; we don't care about how its dependencies behave in production (we will test these separately). We can just mock them with any implementation while testing to have them behave how we want. Remember that the whole point of DI is that we don't care about what the dependencies do and how they do it, as long as they conform to the agreed-upon interface – <strong class="source-inline">UserRepository</strong> and <strong class="source-inline">EmailService</strong> in this case. Here is how we would test the <strong class="source-inline">registerUser</strong> method in code:</p>
			<p class="source-code">interface User {</p>
			<p class="source-code">  email: string;</p>
			<p class="source-code">  password: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">test('User registration', async () =&gt; {</p>
			<p class="source-code">  const mockUserRepository: UserRepository = {</p>
			<p class="source-code">    async save(user: User) {</p>
			<p class="source-code">      return user;</p>
			<p class="source-code">    },</p>
			<p class="source-code">  };</p>
			<p class="source-code">  const mockEmailService: EmailService = {</p>
			<p class="source-code">    async sendEmail(to: string, subject: string, body?: string) {},</p>
			<p class="source-code">  };</p>
			<p class="source-code">  const userRegistrationService = new UserRegistrationService(</p>
			<p class="source-code">    mockUserRepository,</p>
			<p class="source-code">    mockEmailService</p>
			<p class="source-code">  );</p>
			<p class="source-code">  await userRegistrationService.registerUser(</p>
			<p class="source-code">    'example@domain.com',</p>
			<p class="source-code">    'super-secret-password'</p>
			<p class="source-code">  );</p>
			<p class="source-code">  expect(mockUserRepository.save).toHaveBeenCalled();</p>
			<p class="source-code">  expect(mockEmailService.sendEmail).toHaveBeenCalled();</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">});</p>
			<p>Even though the preceding examples only demonstrate classes, dependencies can be of any type – classes, functions, plain objects, and even simple constants (depending on the language and specific implementation). </p>
			<p>For example, if <strong class="source-inline">UserRegistrationService</strong> were to require a constant value, for example, a salt to hash the user's password with, it would be provided in the constructor, too, as another argument, as shown here:</p>
			<p class="source-code">import * as bcrypt from 'bcrypt';</p>
			<p class="source-code">class UserRegistrationService {</p>
			<p class="source-code">  constructor(</p>
			<p class="source-code">    private userRepository: UserRepository,</p>
			<p class="source-code">    private emailService: EmailService,</p>
			<p class="source-code">    private passwordHashSalt: string</p>
			<p class="source-code">  ) {}</p>
			<p class="source-code">  async registerUser(email: string, password: string) {</p>
			<p class="source-code">    const hashedPassword = await bcrypt.hash(password, this.passwordHashSalt);</p>
			<p class="source-code">    await this.userRepository.save({</p>
			<p class="source-code">      email,</p>
			<p class="source-code">      password: hashedPassword,</p>
			<p class="source-code">    });</p>
			<p class="source-code">    await this.emailService.sendEmail(email, 'Welcome to my website!');</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The following sections will be using decorators, covered in <em class="italic">Chapter 7. Decorators</em>. Please make sure that you have read and understood them before continuing, as decorators are an essential part of how all DI libraries covered next are built on.</p>
			<p>Another concept related to DI is <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>), a programming principle in which the control flow is inverted, as the name suggests. While DI's concern is to decouple dependencies via abstractions (such as our <strong class="source-inline">UserRepository</strong> abstraction over the <strong class="source-inline">MySqlUserRepository</strong> implementation), in IoC, the concern is to let the consumer decide what should be done by the component/library. For example, in our implementation of <strong class="source-inline">UserRegistrationService</strong> above, we used IoC, since we allow how the user's details are sent, as well as how an email is sent by the consumer, to be specified. In the application's case, it could decide whether it wanted to use <strong class="source-inline">FileUserRepository</strong> or <strong class="source-inline">MySqlUserRepository</strong>, and in the test code we decided that both of them should do nothing. This was also decided at the consumer (test code) level. </p>
			<p>To summarize, DI concerns itself with letting a class know about abstractions over implementations, while IoC's concerns revolve around letting the consumer decide about the implementation(s) that should be used.</p>
			<p>Some popular frameworks, both in the frontend as well as the backend, have embraced DI as a core part of their framework – the most popular ones are Angular in frontend development and Nest.js in the backend. DI allows applications built on top of these frameworks to be very robust and flexible, especially in large applications due to the nature of DI, which allows the creation of classes (and other dependencies) to be separated from their usage.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor213"/>DI in Angular</h2>
			<p>Another actual real-world example of DI can be found in the Angular framework – a modern framework for building frontend applications using TypeScript. Angular has its own implementation for a DI library. Furthermore, the Angular framework itself, as well as apps built on it, heavily relies on this DI implementation.</p>
			<p>Let's take a look at a simple Angular app and see how DI makes it straightforward to build an easy-to-maintain, scalable application.</p>
			<p>An Angular app is made up of several <strong class="source-inline">NgModule</strong>, each of which is usually a logical part of an app – this can be a feature, a UI components library, or anything else. Each <strong class="source-inline">NgModule</strong> can have two types of "things:"</p>
			<ol>
				<li>Declarations (<strong class="source-inline">Component</strong> and <strong class="source-inline">Directive</strong>)</li>
				<li>Providers (usually <strong class="source-inline">Service</strong>)</li>
			</ol>
			<p><em class="italic">Declarations</em> are what constitute the UI of the app, things such as the <strong class="source-inline">WelcomeMessageComponent</strong> class (shown in the following snippet), which takes in <strong class="source-inline">name</strong> as an input (using the <strong class="source-inline">@Input</strong> decorator, which is kind of like passing in parameters to a function or a constructor of a class, just with components), and displays it in an HTML <strong class="source-inline">h1</strong> tag (an HTML tag to display a main header):</p>
			<p class="source-code">import { Component, Input } from '@angular/core';</p>
			<p class="source-code">@Component({</p>
			<p class="source-code">    selector: 'welcome-message',</p>
			<p class="source-code">    template: `</p>
			<p class="source-code">        &lt;h1&gt;Welcome {{ name }}!&lt;/h1&gt;</p>
			<p class="source-code">    `,</p>
			<p class="source-code">})</p>
			<p class="source-code">export class WelcomeMessageComponent {</p>
			<p class="source-code">    @Input() name: string;</p>
			<p class="source-code">}</p>
			<p>The preceding code will yield the following output:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B14508_08_03.jpg" alt="Figure 8.3: Displayed output of rendering WelcomeMessageComponent &#13;&#10;with &quot;John&quot; passed in to the name input&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: Displayed output of rendering WelcomeMessageComponent with "John" passed in to the name input</p>
			<p>Providers are usually services, which hold the main logic of the app and are usually used for anything that's not specifically related to the UI. </p>
			<p>For example, you could have a <strong class="source-inline">UsersService</strong> class that handles fetching a list of users from a backend, as shown here:</p>
			<p class="source-code">import { Injectable } from '@angular/core';</p>
			<p class="source-code">import { Observable, of } from 'rxjs';</p>
			<p class="source-code">export interface User {</p>
			<p class="source-code">    name: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">@Injectable()</p>
			<p class="source-code">export class UsersService {</p>
			<p class="source-code">    getUsers(): Observable&lt;User[]&gt; {</p>
			<p class="source-code">        return of([</p>
			<p class="source-code">            { name: 'Alice' },</p>
			<p class="source-code">            { name: 'Bob' },</p>
			<p class="source-code">            { name: 'Charlie' }</p>
			<p class="source-code">        ]);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding code has a <strong class="source-inline">UsersService</strong> class that has a single method – <strong class="source-inline">getUsers()</strong>, which returns a static array of <strong class="source-inline">User</strong> objects. Note that we wrap our static array with <strong class="source-inline">of()</strong>, which takes a static value and wraps it in an <strong class="source-inline">Observable</strong>, so we can later change the behavior of this method to asynchronously return data (for example, from a remote endpoint, as we'll see next).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">An observable is an asynchronous stream of data, basically allowing data to be passed between "publishers" and "subscribers." This data can be a one-time operation, such as with an HTTP call, can have multiple emits (for example, emit an increasing number from 1 through 10, in sequence, every 1 second), or can even be infinite (for example, emitting an event every time the user clicks a specific button). It is part of the Observer pattern.</p>
			<p>We would then use <strong class="source-inline">UsersService</strong> in our <strong class="source-inline">UsersList</strong> component, which displays the users in a list, as shown here:</p>
			<p class="source-code">import { Component } from "@angular/core";</p>
			<p class="source-code">import { Observable } from "rxjs";</p>
			<p class="source-code">import { UsersService, User } from "./users.service";</p>
			<p class="source-code">@Component({</p>
			<p class="source-code">  selector: 'users-list',</p>
			<p class="source-code">  template: `</p>
			<p class="source-code">    &lt;ul&gt;</p>
			<p class="source-code">      &lt;li *ngFor="let user of (users$ | async)"&gt;</p>
			<p class="source-code">        {{ user.name }}</p>
			<p class="source-code">      &lt;/li&gt;</p>
			<p class="source-code">    &lt;/ul&gt;</p>
			<p class="source-code">  `</p>
			<p class="source-code">})</p>
			<p class="source-code">export class UsersListComponent {</p>
			<p class="source-code">  readonly users$: Observable&lt;User[]&gt;;</p>
			<p class="source-code">  constructor(private usersService: UsersService) {</p>
			<p class="source-code">    this.users$ = usersService.getUsers();</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Here, we create a simple component, <strong class="source-inline">UsersListComponent</strong>, that displays a list of users, which it gets from <strong class="source-inline">UsersService</strong> that's <em class="italic">injected</em> into it at creation time by the Angular DI.</p>
			<p>Once the service is injected, we call <strong class="source-inline">getUsers()</strong> and store the returned <strong class="source-inline">Observable</strong> in a <strong class="source-inline">users$</strong> member so we can later access it from the template, which utilizes the <strong class="source-inline">async</strong> pipe to tell Angular to subscribe to the <strong class="source-inline">Observable</strong> and update the template when its underlying value changes:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B14508_08_04.jpg" alt="Figure 8.4: The output from running the app&#13;&#10;"/>
				</div>
			</div>
			<p> </p>
			<p class="figure-caption">Figure 8.4: The output from running the app</p>
			<p>We won't dive into Angular's template engine or change detection mechanisms – those are two big topics in themselves – but you can refer to the Angular documentation for more information on that. Instead, let's focus on what's going on with regard to DI – notice that we asked for a <strong class="source-inline">UsersService</strong> object in the <strong class="source-inline">UsersListComponents</strong> constructor; we didn't specify that we wanted to get a specific instance of the service and so on, just that we want one. This is very powerful, since this offloads the logic of how and where this service is instantiated to a dedicated place (the <strong class="source-inline">NgModule</strong>) and opens up a lot of possibilities. We could test the component more easily (by providing a fake <strong class="source-inline">UsersService</strong>), or even just replace the <strong class="source-inline">UsersService</strong> implementation at runtime with another one.</p>
			<p>Angular providers can also require other providers; for example, we could have a generic HTTP client service that knows how to make HTTP calls, and then inject that into our <strong class="source-inline">UsersService</strong>, which can focus on more high-level details such as the endpoint, which it needs to use in order to fetch the users. In fact, Angular has such an HTTP service built in, called <strong class="source-inline">HttpClient</strong>. You can use it and fix the mock implementation we had for the users with a real one, utilizing DI further as shown here:</p>
			<p class="source-code">import { Injectable } from '@angular/core';</p>
			<p class="source-code">import { HttpClient } from '@angular/common/http';</p>
			<p class="source-code">import { Observable } from 'rxjs';</p>
			<p class="source-code">export interface User {</p>
			<p class="source-code">    name: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">@Injectable()</p>
			<p class="source-code">export class UsersService {</p>
			<p class="source-code">    constructor(private httpClient: HttpClient) {}</p>
			<p class="source-code">    getUsers(): Observable&lt;User[]&gt; {</p>
			<p class="source-code">        return this.httpClient.get&lt;User[]&gt;('/api/users');</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we ask for an <strong class="source-inline">HttpClient</strong> and use its <strong class="source-inline">get()</strong> method to make a <strong class="source-inline">GET</strong> request to the <strong class="source-inline">/api/users</strong> endpoint in our site, which should return an array of <strong class="source-inline">User</strong> objects – that is, objects with a property called <strong class="source-inline">name</strong>, with a <strong class="source-inline">string</strong> type.</p>
			<p>This replaces the mock implementation we had earlier with a more real-world use case by calling an external endpoint instead of returning a static list of users. </p>
			<p>Again, notice that we just asked for an <strong class="source-inline">HttpClient</strong> interface again. We don't care about how it's implemented (this could involve using <strong class="source-inline">XMLHttpRequest</strong>, <strong class="source-inline">fetch</strong>, or even another underlying library), as long as it conforms to the <strong class="source-inline">HttpClient</strong> interface.</p>
			<p>You may have noticed that the path that we request from <strong class="source-inline">HttpClient</strong> is a relative one. This works if our backend is on the same domain as our frontend (for example, <a href="https://example.com">https://example.com</a> is our website and <a href="https://example.com/api/users">https://example.com/api/users</a> would return the users). However, if we want to move our backend to a different server, this will break our website. In the next exercise, we will fix this, using Angular's DI mechanism and by adding <strong class="source-inline">HttpInterceptor</strong>. </p>
			<p><strong class="source-inline">HttpInterceptor</strong> is an interface Angular provides that we can implement in order to "hook," or even change network requests, either on their way out (the request), or on their way back (the response), before any other consumer "sees" the response. This will work wherever <strong class="source-inline">HttpClient</strong> is used in the application, without requiring any more code modifications in other services that use <strong class="source-inline">HttpClient</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The example discussed in this section is the basis of our next exercise. </p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor214"/>Exercise 8.01: Adding HttpInterceptor to an Angular App</h2>
			<p>In this exercise, we'll add <strong class="source-inline">HttpInterceptor</strong> to our existing Angular application, which we built in the preceding section, to allow our backend service to sit on a different domain from our frontend application. This allows the two applications to be separated completely, and very easily, without requiring any extra changes in the rest of the application. Here are the steps to complete this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you run <strong class="source-inline">npm install</strong> in the <strong class="source-inline">exercise-starter</strong> directory. The code files for this exercise can be found here: <a href="https://packt.link/avWRA">https://packt.link/avWRA</a>. This repository contains two folders, <strong class="source-inline">exercise-starter</strong> and <strong class="source-inline">exercise-solution</strong>. The former contains the template files that you can use to code along with this exercise, whereas the latter contains the final code of this exercise for your reference.</p>
			<ol>
				<li value="1">Start by cloning the application we have written so far in this section. This can be found at <a href="https://packt.link/JAgZ7">https://packt.link/JAgZ7</a>.</li>
				<li>Create a class, <strong class="source-inline">ApiHttpInterceptor</strong>, in a new file, <strong class="source-inline">api-http.interceptor.ts</strong>, and save the file in the <strong class="source-inline">exercise-starter</strong>/<strong class="source-inline">src/app/interceptors/</strong> folder. This file implements the <strong class="source-inline">HttpInterceptor</strong> interface (imported from <strong class="source-inline">@angular/common/http</strong>). Be sure to mark it with the <strong class="source-inline">@Injectable</strong> decorator so that Angular knows it's a service that can be used in DI:<p class="source-code">import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';</p><p class="source-code">import { Injectable } from '@angular/core';</p><p class="source-code">import { Observable } from 'rxjs';</p><p class="source-code">@Injectable()</p><p class="source-code">export class ApiHttpInterceptor implements HttpInterceptor {</p><p class="source-code">  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {</p><p class="source-code">    throw new Error('Method not implemented.');</p><p class="source-code">  }</p><p class="source-code">}</p><p>Angular will call the <strong class="source-inline">intercept()</strong> method of <strong class="source-inline">ApiHttpInterceptor</strong> when a request is made by any <strong class="source-inline">HttpClient</strong>. We get the request (<strong class="source-inline">req</strong>) and <strong class="source-inline">HttpHandler</strong> (<strong class="source-inline">next</strong>), which we need to call when we're finished to let Angular call any other <strong class="source-inline">HttpInterceptor</strong> in the chain.</p></li>
				<li>Update the code to change the URL path:<p class="source-code">import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from "@angular/common/http";</p><p class="source-code">import { Injectable } from "@angular/core";</p><p class="source-code">import { Observable } from "rxjs";</p><p class="source-code">@Injectable()</p><p class="source-code">export class ApiHttpInterceptor implements HttpInterceptor {</p><p class="source-code">    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {</p><p class="source-code">    if (!req.url.startsWith('/api/')) {</p><p class="source-code">      return next.handle(req);</p><p class="source-code">    }</p><p class="source-code">    const relativeUrl = req.url.replace('/api/', '');</p><p class="source-code">    const newRequest = req.clone({</p><p class="source-code">url: `https://jsonplaceholder.typicode.com/${relativeUrl}`</p><p class="source-code">    });</p><p class="source-code">    return next.handle(newRequest);</p><p class="source-code">  }</p><p class="source-code">}</p><p>The preceding code checks the URL path. For each request, if it's issued to a relative path, starting with <strong class="source-inline">/api</strong>, the code changes it. It does so by looking at the <strong class="source-inline">url</strong> property of <strong class="source-inline">HttpRequest</strong>. If the URL doesn't start with <strong class="source-inline">/api</strong>, you don't need to do anything, just call <strong class="source-inline">next.handle()</strong> with the original request. Otherwise, clone the original request with a new URL, and then call <strong class="source-inline">next.handle()</strong> with the new request. This is the request that will actually be sent out. We're using <a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a> here, a free service that has some predefined endpoints we can use to get data from, for testing purposes. In an actual application, this would be your backend service's endpoint.</p><p>Lastly, we also need to register this interceptor in our <strong class="source-inline">AppModule</strong> so that it can know what interceptors to inject into <strong class="source-inline">HttpClient</strong>. We do this by adding <strong class="source-inline">ApiHttpInterceptor</strong>, which we created as a provider, and we tell Angular to use it when looking for <strong class="source-inline">HTTP_INTERCEPTORS</strong> – this is the DI symbol that Angular uses when it asks for all the interceptors it needs to use when making a network request via the <strong class="source-inline">HttpClient</strong> service. </p></li>
				<li>Open the <strong class="source-inline">app.module.ts</strong> file present in the <strong class="source-inline">exercise-starter/src/app</strong> folder and update it with the code given here: <p class="source-code">import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';</p><p class="source-code">import { NgModule } from '@angular/core';</p><p class="source-code">import { BrowserModule } from '@angular/platform-browser';</p><p class="source-code">import { AppComponent } from './app.component';</p><p class="source-code">import { ApiHttpInterceptor } from './interceptors/api-http.interceptor';</p><p class="source-code">import { UsersListComponent } from './users-list.component';</p><p class="source-code">import { UsersService } from './users.service';</p><p class="source-code">import { WelcomeMessageComponent } from './welcome-message.component';</p><p class="source-code">@NgModule({    </p><p class="source-code">  imports: [BrowserModule, HttpClientModule],</p><p class="source-code">  declarations: [AppComponent, WelcomeMessageComponent, UsersListComponent],   </p><p class="source-code">  providers: [UsersService, { <strong class="bold">provide: HTTP_INTERCEPTORS, useClass: ApiHttpInterceptor, multi: true</strong> }],</p><p class="source-code">  bootstrap: [AppComponent],</p><p class="source-code">})</p><p class="source-code">export class AppModule { }</p><p>Since we want Angular to know about our interceptor, we add it to the <strong class="source-inline">HTTP_INTERCEPTORS</strong> list (notice the bold line).</p></li>
				<li>Run the new app by running <strong class="source-inline">npm start -- --open</strong> in the <strong class="source-inline">exercise-starter</strong> directory. Your default browser should open up at <strong class="source-inline">http://localhost:4200</strong>, and you should see a list of 10 users:</li>
			</ol>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B14508_08_05.jpg" alt="Figure 8.5: Output of the exercise&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5: Output of the exercise</p>
			<p>If you open the DevTools, you should see only one request to the <strong class="source-inline">users</strong> endpoint, which is for <a href="https://jsonplaceholder.typicode.com/users">https://jsonplaceholder.typicode.com/users</a> (and not <a href="http://localhost:4200/users">http://localhost:4200/users</a>):</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B14508_08_06.jpg" alt="Figure 8.6: Requests to the users endpoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: Requests to the users endpoint</p>
			<p>Notice that our <strong class="source-inline">UsersService</strong> didn't change at all here (and you can imagine the benefits if we had dozens of services like it), but it is still working as expected from its point of view.</p>
			<p>All the code explained in this section and the exercise is just some examples of how DI comes into play in Angular. However, there is much more. You can register any value as a dependency to be injected (not just classes). You can control the instantiation of the providers to be Singletons for the entire app, creating a new instance for every <strong class="source-inline">NgModule</strong> or even for every <strong class="source-inline">Component</strong> instance. You can also create them using some more complex logic via factories and more. You have just scratched the surface of the very powerful DI library that Angular offers.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor215"/>DI in Nest.js</h2>
			<p>Another framework to look at, also heavily inspired by Angular's architecture, is Nest.js, which also heavily utilizes DI. Nest.js is a framework for building backend applications using Node.js and TypeScript. Like Angular, Nest.js also has <strong class="source-inline">Modules</strong> (equivalent to Angular's <strong class="source-inline">NgModule</strong>), and <strong class="source-inline">Providers</strong>. It also has <strong class="source-inline">Controller</strong>, which handles incoming requests from clients and returns responses. These are similar to Angular's components – both are what the consumers see. In Angular, <strong class="source-inline">Component</strong> and <strong class="source-inline">Directive</strong> make up the UI, and in Nest.js, <strong class="source-inline">Controller</strong> makes up the API to be consumed.</p>
			<p>We won't dive into Nest.js' architecture, but here's a small example of a couple of things that it leverages DI for:</p>
			<p class="source-code">import { Controller, Get, Param } from '@nestjs/common';</p>
			<p class="source-code">import { HelloService } from './hello.service';</p>
			<p class="source-code">@Controller('hello')</p>
			<p class="source-code">export class HelloController {</p>
			<p class="source-code">  constructor(private helloService: HelloService) {}</p>
			<p class="source-code">  @Get(':username')</p>
			<p class="source-code">  async getByUsername(@Param('username') username: string) {</p>
			<p class="source-code">    const message = await this.helloService.getHello(username);</p>
			<p class="source-code">    return { message };</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This is a simple "Hello World" controller, which, for a <strong class="source-inline">GET</strong> request to <strong class="source-inline">/hello/foo</strong>, will return <strong class="source-inline">{ message: "Hello foo" }</strong>. A controller is a container for endpoints under a given prefix (so in this case, any request that starts with <strong class="source-inline">"/hello"</strong> will end up going to this controller), and the <strong class="source-inline">@Get</strong> decorator around the <strong class="source-inline">getByUserName()</strong> function tells Nest.js to call that method when a <strong class="source-inline">GET</strong> method is performed to the given path (the paths of the individual methods/decorators are concatenated to those of the controller) – <strong class="source-inline">"/hello/:username"</strong> in this case (anything starting with a <strong class="source-inline">:</strong> is a placeholder for dynamic content. In this case, <strong class="source-inline">:username</strong> is the placeholder, and we can get it by using the <strong class="source-inline">Param</strong> decorator, giving it the placeholder's name).</p>
			<p>Notice that we get <strong class="source-inline">HelloService</strong> in the constructor, similar to Angular, via DI. We also get the username param from the <strong class="source-inline">Param</strong> decorator, which also leverages DI behind the scenes to get the current <strong class="source-inline">Request</strong> object. Lastly, the framework is responsible for creating both <strong class="source-inline">HelloService</strong> and <strong class="source-inline">HelloController</strong> for us; we don't need to do so ourselves. This, like in Angular, makes testing <strong class="source-inline">HelloController</strong> easy, since you can just fake <strong class="source-inline">HelloService</strong> in your tests with a mock implementation to either assert or modify the behavior of the controller. This is a very simple example, but you can imagine <strong class="source-inline">HelloService</strong> replaced with something like an authentication service, or an ORM tool for accessing the database.</p>
			<p>In the next section, we'll cover InversifyJS – an IoC container for TypeScript (and JavaScript) applications. Unlike Angular, which is only for the frontend, or Nest.js, which is only for the backend, and which are both frameworks that dictate what your application's architecture will be (at least at some level), InversifyJS is a generic library that only does IoC and allows you to use DI in any application.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor216"/>InversifyJS</h1>
			<p>InversifyJS is an implementation of an IoC container (inversion of control, which DI is part of) for TypeScript (and JavaScript) applications. It is one of many implementations and, as we've seen above, some frameworks come with their own DI solution, such as Angular or Nest.js.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Other alternatives to InversifyJS for general-purpose projects include <strong class="source-inline">TypeDI</strong> and <strong class="source-inline">TSyringe</strong>, as well as <strong class="source-inline">typescript-ioc</strong>.</p>
			<p>The basic idea in InversifyJS, as in most other implementations for an IoC container, is to have one place that defines all the concrete implementations of functionality, and the rest of the app only depends on abstractions (for example, interfaces). This greatly reduces coupling, and changing one implementation to another doesn't affect the entire app or require lots of code changes.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Coupling is about how tightly integrated/dependent two components (usually classes) are, in the sense that if we change one of them, how likely is the other to break without applicable changes to it too? The more tightly integrated/connected two components are to one another, the more coupled they are, and vice versa.</p>
			<p class="callout">Ideally, changing one class should not require changes in others. In such cases, the classes are considered decoupled (or loosely coupled).</p>
			<p>To make InversifyJS work, we first need to add a <strong class="bold">polyfill</strong> for <strong class="bold">reflect-metadata</strong>, which allows libraries to perform runtime reflection on objects to get their types in a more powerful manner than the (currently) built-in <strong class="source-inline">typeof</strong> and <strong class="source-inline">instanceof</strong> operators.</p>
			<p>In addition, since InverisfyJS works through decorators, you need to enable them by setting <strong class="source-inline">experimentalDecorators</strong> and <strong class="source-inline">emitDecoratorMetadata</strong> to <strong class="source-inline">true</strong> in your project's <strong class="source-inline">tsconfig.json</strong> file (note the <strong class="bold">bold</strong> lines):</p>
			<p class="source-code">{</p>
			<p class="source-code">    "compilerOptions": {</p>
			<p class="source-code">        "target": "es5",</p>
			<p class="source-code">        "lib": ["es6", "dom"],</p>
			<p class="source-code">        "types": ["reflect-metadata"],</p>
			<p class="source-code">        "module": "commonjs",</p>
			<p class="source-code">        "moduleResolution": "node",</p>
			<p class="source-code"><strong class="bold">        "experimentalDecorators": true,</strong></p>
			<p class="source-code"><strong class="bold">        "emitDecoratorMetadata": true</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are additional requirements in order for InversifyJS to work, but all modern browsers and Node.js versions should be able to use it without further polyfills. For more details, visit the following link: <a href="https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md">https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md</a>.</p>
			<p>Just as with Angular and Nest.js' DI containers (<strong class="source-inline">NgModule</strong> and <strong class="source-inline">Module</strong>, respectively), InversifyJS also needs to know how to resolve dependencies. This is generally configured in a single place, usually in a file named <strong class="source-inline">inversify.config.ts</strong> in the root of the project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is the recommendation, but this file can be placed anywhere and named anything, or split into multiple files; for example, for separating the registration of classes of different features or domains, similar to <strong class="source-inline">NgModules</strong> in Angular or <strong class="source-inline">Modules</strong> in Nest.js.</p>
			<p>This file should be the only place in the application where there is coupling. The rest of the app should only be dependent on abstractions.</p>
			<p>These abstractions will usually be interfaces, but you can also depend on a specific implementation, or a <strong class="source-inline">class</strong> (which can then be injected with a compatible subclass).</p>
			<p>In addition, since interfaces in TypeScript only exist at compile time (see <em class="italic">Chapter 7</em>, <em class="italic">Inheritance and Interfaces</em>), InversifyJS also requires a runtime abstraction token to know what to resolve.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor217"/>Exercise 8.02: "Hello World" Using InversifyJS</h2>
			<p>In this exercise, we'll create a simple "hello world" application using InversifyJS. We'll implement all the basic building blocks for a typical use case. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found at <a href="https://packt.link/bXSTd">https://packt.link/bXSTd</a>.</p>
			<ol>
				<li value="1">First, create the abstraction for our logger using an <strong class="source-inline">interface</strong> in a new file called <strong class="source-inline">logger.interface.ts</strong> in the <strong class="source-inline">src</strong> folder. This is what consumers will reference later:<p class="source-code">export interface Logger {</p><p class="source-code">    log(message: string): void;</p><p class="source-code">}</p></li>
				<li>Next, create a concrete implementation for <strong class="source-inline">Logger</strong>. This implementation is what the consumers of the code will get injected with when they require <strong class="source-inline">Logger</strong> later on:<p class="source-code">import { injectable } from "inversify";</p><p class="source-code">import { Logger } from "./logger.interface";</p><p class="source-code">@injectable()</p><p class="source-code">export class ConsoleLogger implements Logger {</p><p class="source-code">    log(message: string) {</p><p class="source-code">        console.log(message);</p><p class="source-code">    }</p><p class="source-code">}</p><p>Note that <strong class="source-inline">ConsoleLogger</strong> implements <strong class="source-inline">Logger</strong>. This ensures that we write a compatible implementation to what our consumers expect, and that they don't break at runtime. In addition, the <strong class="source-inline">@injectable</strong> decorator is used to indicate to InversifyJS that this implementation can be used <em class="italic">as a dependency</em>, and also that it can be injected to <em class="italic">other dependencies</em>. This is how we make InversifyJS aware that <strong class="source-inline">ConsoleLogger</strong> is something that it should be aware of.</p></li>
				<li>Create a new file called <strong class="source-inline">types.ts</strong> in the <strong class="source-inline">src</strong> folder. Then, define an injection token that consumers can rely on later to ask InversifyJS to inject whatever implementation is behind it at runtime: <p class="source-code">export const TYPES = {</p><p class="source-code">    Logger: Symbol.for("Logger"),</p><p class="source-code">};</p><p>In this exercise, we'll stick with the recommended approach of creating a <strong class="source-inline">TYPES</strong> object that resolves to a <strong class="source-inline">Symbol</strong> for each type (using an injection token is required in most DI libraries in TypeScript, since interfaces don't exist at runtime, so InversifyJS can't rely on them).</p><p class="callout-heading">Note</p><p class="callout">If your target environment doesn't support <strong class="bold">symbols</strong>, you can instead use a plain string. Just ensure that you don't have the same string registered for multiple types.</p></li>
				<li>Create a new file called <strong class="source-inline">ioc.config.ts</strong> in the <strong class="source-inline">src</strong> folder. Then, configure the IoC container using the following code: <p class="source-code">import { Container } from "inversify";</p><p class="source-code">import { ConsoleLogger } from "./console-logger";</p><p class="source-code">import { Logger } from "./logger.interface";</p><p class="source-code">import { TYPES } from "./types";</p><p class="source-code"><strong class="bold">export const container = new Container();</strong></p><p class="source-code"><strong class="bold">container.bind&lt;Logger&gt;(TYPES.Logger).to(ConsoleLogger);</strong></p><p>This is what ties all three things (<strong class="source-inline">console-logger</strong>, <strong class="source-inline">logger.interface</strong>, and <strong class="source-inline">types</strong>) together:</p></li>
				<li>Create a consumer for the logger in a new file called <strong class="source-inline">main.ts</strong> in the <strong class="source-inline">src</strong> folder. Notice that we use the <strong class="source-inline">@inject</strong> decorator to tell InversifyJS that we want the <strong class="source-inline">Logger</strong> type:<p class="source-code">import "reflect-metadata";</p><p class="source-code">import { inject, injectable } from "inversify";</p><p class="source-code">import { container } from "./ioc.config";</p><p class="source-code">import { Logger } from "./logger.interface";</p><p class="source-code">import { TYPES } from "./types";</p><p class="source-code">@injectable()</p><p class="source-code">class Main {</p><p class="source-code">    constructor(@inject(TYPES.Logger) private logger: Logger) {}</p><p class="source-code">    run() {</p><p class="source-code">        this.logger.log('Hello from InversifyJS!');</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">// Run the app:</p><p class="source-code">const main = container.resolve(Main);</p><p class="source-code">main.run();</p><p class="callout-heading">Note</p><p class="callout">The interface type annotation is just for TypeScript to be able to type check the <strong class="source-inline">logger</strong> instance, but since interfaces only exist at compile time, this is irrelevant for runtime, in which the argument passed to <strong class="source-inline">@inject</strong> is what matters.</p></li>
				<li>Now, run the app by executing <strong class="source-inline">npm start</strong> in the parent directory. You should get the following output on your console:<p class="source-code">Hello from InversifyJS!</p></li>
			</ol>
			<p>Of course, for such a simple example, it would have been better to just have a single line as follows:</p>
			<p class="source-code">console.log('Running');</p>
			<p>However, in more complex applications, and even simple ones, DI can help, especially if the application is expected to be actively maintained, with the addition of features and the fixing of bugs happening all the time.</p>
			<p>In the next activity, you will be tasked with creating a more complex app to demonstrate how DI can help us develop applications while keeping best practices in mind to make the app easy to maintain.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor218"/>Activity 8.01: DI-Based Calculator</h2>
			<p>As a TypeScript developer, you are tasked with creating a calculator. Like any calculator, you need your app to do the four basic math operations of addition (+), subtraction (-), multiplication (*), and division (/). </p>
			<p class="callout-heading">Note </p>
			<p class="callout">To keep things simple and focused solely on DI, you won't be adding support for additional operators (for example, power (^)), or support the order of operations, so your calculator will just walk through the expression from left to right and perform the relevant operation. For example, the expression (<strong class="source-inline">13+5*3-7</strong> will result in <strong class="source-inline">47</strong> and not the mathematically correct <strong class="source-inline">21</strong>). </p>
			<p>To complete this activity, you will have to implement InversifyJS and utilize IoC to provide the math operators that the calculator can operate on. </p>
			<p>You can start with the starter project and build it up by following the high-level steps provided here. This activity will challenge the skills that you have developed not only in this chapter but also in preceding ones. Hence, feel free to glance at the solution to debug any issues you may have with your implementation or code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This activity is based on the last section, on InversifyJS, so be sure you understand it fully before moving on to this one. You can find both the activity starter and solution at <a href="https://packt.link/Pt3Vq">https://packt.link/Pt3Vq</a>. The <strong class="source-inline">activity-starter</strong> folder contains the template files you can use to code along with this activity. The <strong class="source-inline">activity-solution</strong> folder contains the files representing the solution of this activity. </p>
			<p>Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">You will have to start off by creating the basic building block of your calculator – an operator defined via an interface.</li>
				<li>Then, create operators for addition, subtraction, multiplication, and division.<p>For the preceding two steps, note that you need to create the requisite abstract interface and injection token.</p></li>
				<li>Implement a calculator class that uses these operators via InversifyJS. This file represents your main app. You might need to map all expression parts and parse them. For this, you can refer to the <strong class="source-inline">maths.ts</strong> file placed in the <strong class="source-inline">src/utils</strong> folder, which creates and exports two such functions – <strong class="source-inline">tryParseNumberString</strong> and <strong class="source-inline">tryParseOperatorSymbol</strong>.</li>
				<li>Configure the IoC container (present in the <strong class="source-inline">src/ioc.config.ts</strong> file) so that <strong class="source-inline">Calculator</strong> can receive <strong class="source-inline">AddOperator</strong>, <strong class="source-inline">SubtractOperator</strong>, and so on when it asks for <strong class="source-inline">TYPES.AddOperator</strong>, for example. You can simplify the <strong class="source-inline">ioc.config.ts</strong> file further by using barrels. The code for this can be found in the <strong class="source-inline">operator/index.ts</strong> file. You can use the code in the aforementioned file to configure and then simplify your IoC container.</li>
				<li>Create the <strong class="source-inline">main.ts</strong> file that will kick-start your calculator.<p>After solving the preceding steps, the expected output should look like the following:</p><p class="source-code">result is 150</p></li>
				<li><strong class="bold">Bonus Steps:</strong><p>As a bonus, let's say that you want some reporting on the operations performed in the calculator. You can add logging (console- and file-based) easily without too many changes:</p></li>
				<li>For console-based logging, you need to add a logger via DI that the calculator will write to on every expression evaluation. You can follow the given sequence to do so. First, you need to define the <strong class="source-inline">Logger</strong> interface. Then, create the console-based implementation of <strong class="source-inline">Logger</strong>. Next, create an injection token for it and register it in our container. Then, use the logger in the code for the main calculator app.</li>
				<li>Now, let's say we want to replace our console-based logger with a file-based one, which will persist across runs so that we can track the calculator's evaluation history.</li>
				<li>To do this, you first need to create a <strong class="source-inline">FileLogger</strong> class that implements <strong class="source-inline">Logger</strong> in a new file in the <strong class="source-inline">src/logger</strong> folder. Then, you need to make a single-line change in the <strong class="source-inline">ioc.config.ts</strong> file, which you used for console-based logging.<p>For console-based logging, use this command:</p><p class="source-code">container.bind&lt;Logger&gt;(TYPES.Logger).to(ConsoleLogger);</p><p>For file-based logging, use this command:</p><p class="source-code">container.bind&lt;Logger&gt;(TYPES.Logger).to(FileLogger);</p><p>However, note that you will have to correctly import all <strong class="source-inline">Logger</strong> interfaces across all files.</p><p>The output for the console-based logger is as follows:</p><p class="source-code">[LOG] Calculated result of expression:13*10+20 is 150</p><p>The output for the file-based logger is as follows:</p><div id="_idContainer104" class="IMG---Figure"><img src="image/B14508_08_07.jpg" alt="Figure 8.7: Final output of the file-based logger in activity-starter/src/tmp/calculator.log, after changing the app to use it&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.7: Final output of the file-based logger in activity-starter/src/tmp/calculator.log, after changing the app to use it</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor421">this link</a>.</p>
			<p>The solution to this activity (<strong class="source-inline">activity-solution</strong>) also includes unit tests for everything, so you can see how easy testing is when IoC is used as well as check that your own implementation passes the tests. In addition, <strong class="source-inline">activity-solution</strong> also includes a file that creates a <strong class="source-inline">ConfigurationService</strong> to supply <strong class="source-inline">FileLogger</strong> with a dynamic <strong class="source-inline">loggerPath</strong>, with implementations for an in-memory one, or an environment variables-based one.</p>
			<p>There is a lot more ground to cover on InversifyJS. However, this chapter serves as a good start. We encourage you to take a look at the official documentation to learn more about what it can offer and to see further examples, including factories, container modules, and middlewares. However, these topics are beyond the scope of this chapter.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor219"/>Summary</h1>
			<p>This chapter equipped you first with the fundamentals of DI in TypeScript by explaining how you can implement the DI design pattern and by taking you through a number of use cases. You also learned how to build a basic Angular app using DI. </p>
			<p>This chapter also introduced some basics of InversifyJS and explained how to use it in your applications. You have seen how easy it is to add or change dependencies without breaking the code for other consumers, along with the power of IoC and DI to replace one implementation with another in a very simple manner, for all consumers.</p>
			<p>Of course, there's a lot more to this topic in general than this chapter covered. However, this chapter serves as a good start in getting up and running with DI in TypeScript. In the next chapter, you will learn about generics in TypeScript.</p>
		</div>
		<div>
			<div id="_idContainer106" class="Content">
			</div>
		</div>
	</body></html>