<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 2. A Primer on DOM, SVG, and CSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. A Primer on DOM, SVG, and CSS</h1></div></div></div><p>In this chapter, we'll take a look at the core technologies that make d3.js tick: the <span class="strong"><strong>Document Object Model</strong></span> (<span class="strong"><strong>DOM</strong></span>), <span class="strong"><strong>Scalable Vector Graphics</strong></span> (<span class="strong"><strong>SVG</strong></span>), and <span class="strong"><strong>Cascading Style Sheets</strong></span> (<span class="strong"><strong>CSS</strong></span>).</p><p>You're <a id="id19" class="indexterm"/>probably <a id="id20" class="indexterm"/>used <a id="id21" class="indexterm"/>to manipulating DOM and CSS with libraries such as jQuery or MooTools, but d3.js has a full suite of manipulation tools as well.</p><p>SVG is at the core of building truly great visualizations, so we'll take special care to understand it; everything from manually drawing shapes to transformations and path generators.</p><div class="section" title="DOM"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>DOM</h1></div></div></div><p>The Document Object Model is a language-agnostic model for representing structured documents built in HTML, XML, or similar standards. You can think of it as a tree of nodes that closely resembles the document parsed by the browser.</p><p>At the top, there is an implicit <code class="literal">document</code> node, which represents the <code class="literal">&lt;html&gt;</code> tag; browsers create this tag even if you don't specify it and then build the tree off this root node according to what your document looks like. If you have a simple HTML file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;title&gt;A title&lt;/title&gt;

&lt;div&gt;
  &lt;p&gt;A paragraph of text&lt;/p&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;List item&lt;/li&gt;
  &lt;li&gt;List item 2, &lt;em&gt;&lt;strong&gt;italic&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>Chrome<a id="id22" class="indexterm"/> will parse the preceding code to DOM as follows:</p><div class="mediaobject"><img src="images/0007_02_01.jpg" alt="DOM"/></div><p>In the latest Chrome builds, I can print and play with this in the <span class="strong"><strong>Console</strong></span> tab; you might have to use the <span class="strong"><strong>Elements</strong></span> tab to get the same effect. Moving the cursor over each element will show you where exactly it is placed on the page, which is very handy for debugging.</p><div class="section" title="Manipulating the DOM with d3.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Manipulating the DOM with d3.js</h2></div></div></div><p>Every<a id="id23" class="indexterm"/> node in a DOM tree comes with a slew of methods <a id="id24" class="indexterm"/>and properties that you can use to change the look of the rendered document.</p><p>Take for instance the HTML code in our previous example. If we want to change the word <code class="literal">italic</code> to make it underlined as well as bold and italic (the result of the <code class="literal">&lt;em&gt;</code> and <code class="literal">&lt;strong&gt;</code> tags), we would do it using the following code:</p><div class="informalexample"><pre class="programlisting">document.getElementsByTagName('strong')[0].style.setProperty('text-decoration', 'underline')</pre></div><p>Wow! What a mouthful.</p><p>We took the root <code class="literal">document</code> node and found every node created from a <code class="literal">&lt;strong&gt;</code> tag; then we took the first item in this array and added a <code class="literal">text-decoration</code> property to its <code class="literal">style</code> property.</p><p>The sheer <a id="id25" class="indexterm"/>amount of code it took to do something this simple<a id="id26" class="indexterm"/> in a document with only eleven nodes is the reason why few people today use the DOM API directly—not to mention all the subtle differences between browsers.</p><p>Since we'd like to keep our lives simple and avoid using the DOM directly, we need a library. jQuery is a good choice, but to make things even simpler, we can use d3.js. It comes with everything we need.</p><p>That means we can treat HTML as just another type of data visualization. Let that one sink in. HTML is data visualization.</p><p>In practice, this means we can use similar techniques to present data as a table or an interactive image. Most of all, we can use the same data.</p><p>Let's rewrite the previous example in d3.js:</p><div class="informalexample"><pre class="programlisting">d3.select('strong').style('text-decoration', 'underline')</pre></div><p>Much simpler! We selected the <code class="literal">strong</code> element and defined a <code class="literal">style</code> property. Job done!</p><p>By the way, any property you set with d3.js can be dynamic, so you can assign a function as well as a value. This is going to come in handy later.</p><p>What we just did is called a <span class="strong"><strong>selection</strong></span>. Since selections are the core of everything we do with d3.js, let's take a closer look.</p></div><div class="section" title="Selections"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Selections</h2></div></div></div><p>A selection<a id="id27" class="indexterm"/> is an array of elements pulled from the current document<a id="id28" class="indexterm"/> according to a particular CSS selector. Selectors let you apply different functions to the whole selection at once so you never have to loop through the elements manually.</p><p>Using CSS selectors to decide which elements to work on gives us a simple language for defining elements in the document. It's actually the same as you're used to from jQuery and CSS itself.</p><p>To get the first element with ID as <code class="literal">graph</code>, we use <code class="literal">.select('#graph')</code>; to get all the elements with the class <code class="literal">blue</code>, we write <code class="literal">.selectAll('.blue')</code>; and to get all the paragraphs in a document, we use <code class="literal">.selectAll('p')</code>.</p><p>We can combine these to get a more complex matching. Think of it as set operations. You can perform an AND operation with <code class="literal">".this.that"</code>; it will get elements with classes <code class="literal">this</code> and <code class="literal">that</code>. Alternatively, you might perform an OR operation with <code class="literal">".this, .that"</code> to get<a id="id29" class="indexterm"/> elements having either the <code class="literal">this</code> or <code class="literal">that</code> class.</p><p>But what if you<a id="id30" class="indexterm"/> want to select children elements? Nested selections to the rescue. You can do it with a simple selector such as <code class="literal">"tbody td"</code>, or you can chain two <code class="literal">selectAll</code> calls as <code class="literal">.selectAll('tbody').selectAll('td')</code>. Both will select all the cells in a table body. Keep in mind that nested selections maintain the hierarchy of selected elements, which gives us some interesting capabilities. Let's look at a short example.</p><div class="section" title="Selections example"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Selections example</h3></div></div></div><p>Take the <a id="id31" class="indexterm"/>base HTML from our play environment in the first chapter and add a simple table:</p><div class="informalexample"><pre class="programlisting">&lt;table class="table"&gt;
  &lt;thead&gt;
    &lt;tr&gt;&lt;td&gt;One&lt;/td&gt;&lt;td&gt;Two&lt;/td&gt;&lt;td&gt;Three&lt;/td&gt;&lt;td&gt;Four&lt;/td&gt;&lt;td&gt;Five&lt;/td&gt;&lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;&lt;td&gt;q&lt;/td&gt;&lt;td&gt;w&lt;/td&gt;&lt;td&gt;e&lt;/td&gt;&lt;td&gt;r&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;a&lt;/td&gt;&lt;td&gt;s&lt;/td&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;f&lt;/td&gt;&lt;td&gt;g&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;z&lt;/td&gt;&lt;td&gt;x&lt;/td&gt;&lt;td&gt;c&lt;/td&gt;&lt;td&gt;v&lt;/td&gt;&lt;td&gt;b&lt;/td&gt;&lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</pre></div><p>Pretty much the standard markup for a table, <code class="literal">&lt;thead&gt;</code> and <code class="literal">&lt;tbody&gt;</code> define the head and body of the table where each <code class="literal">&lt;tr&gt;</code> is a row and each <code class="literal">&lt;td&gt;</code> is a cell. Adding the <code class="literal">table</code> class tells bootstrap to make the table look pretty for us.</p><p>Let's jump into the console and have some fun with selections:</p><div class="informalexample"><pre class="programlisting">d3.selectAll('td').style('color', 'red')</pre></div><p>The text will promptly turn red. Now let's make everything in the table head bold by chaining two <code class="literal">selectAll</code> calls:</p><div class="informalexample"><pre class="programlisting">d3.selectAll('thead').selectAll('td').style('font-weight', 'bold')</pre></div><p>Great! Let's take nested selections a bit further and make table body cells green in the second and fourth column:</p><div class="informalexample"><pre class="programlisting">d3.selectAll('tbody tr').selectAll('td')
  .style('color', function (d, i) { return i%2 ? 'green' : 'red'; })</pre></div><p>The two <code class="literal">selectAll</code> calls gave us all the instances of <code class="literal">td</code> in the body, separated by rows, giving us an array of three arrays with five elements: <code class="literal">[ Array[5], Array[5], Array[5] ]</code>. Then we used <code class="literal">style</code> to change the color of every selected element.</p><p>Using a<a id="id32" class="indexterm"/> function instead of a static property gave us the fine-grained control we needed. The function is called with a data attribute (we'll discuss more on that later) and an index of the column it's in, that is, the <code class="literal">i</code> variable. Since we're using nested selections, a third parameter would give us the row. Then we simply return either <code class="literal">'green'</code> or <code class="literal">'red'</code> based on the current index.</p><p>One thing to keep in mind is that chaining selections can be more efficient than OR selectors when it comes to very large documents. This is because each subsequent selection only searches through the elements matched previously.</p></div></div><div class="section" title="Manipulating content"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Manipulating content</h2></div></div></div><p>We can do <a id="id33" class="indexterm"/>far more than just playing around with selections<a id="id34" class="indexterm"/> and changing the properties of the elements. We can manipulate things.</p><p>With d3.js, we can change the contents of an element, add new elements, or remove elements we don't want.</p><p>Let's add a new column to the table from our previous example:</p><div class="informalexample"><pre class="programlisting">var newCol = d3.selectAll('tr').append('td')</pre></div><p>We selected all the table rows and then appended a new cell to each using <code class="literal">.append()</code>. All d3.js actions return the current selection—new cells in this case—so we can chain actions or assign the new selection to a variable (<code class="literal">newCol</code>) for later use.</p><p>We have an empty invisible column on our hands. Let's add some text to spruce things up:</p><div class="informalexample"><pre class="programlisting">newCol.text('a')</pre></div><p>At least now that it's full of instances of <code class="literal">a</code>, we can say a column is present. But that's kind of pointless, so let's follow the pattern set by other columns:</p><div class="informalexample"><pre class="programlisting">newCol.text(function (d, i) { return ['Six', 'y', 'h', 'n'][i] })</pre></div><p>The trick of dynamically defining the content via a function helps us pick the right string from a list of values depending on the column we're in, which we identify by the index <code class="literal">i</code>.</p><p>Figured out the pattern yet? Read the top row of the table body.</p><p>Similarly, we can remove elements using <code class="literal">.remove()</code>. To get rid of the last row in the table, you'd write something as follows:</p><div class="informalexample"><pre class="programlisting">d3.selectAll('tr')[0][3].remove()</pre></div><p>You <a id="id35" class="indexterm"/>have to use <code class="literal">[0][3]</code> instead of just <code class="literal">[3]</code> because selections <a id="id36" class="indexterm"/>are arrays of arrays.</p></div><div class="section" title="Joining data to selections"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Joining data to selections</h2></div></div></div><p>We've made<a id="id37" class="indexterm"/> it to the fun part of our DOM shenanigans. Remember <a id="id38" class="indexterm"/>when I said HTML is data visualization? Joining data to selections is how that happens.</p><p>To join <a id="id39" class="indexterm"/>data with a selection, we use the <code class="literal">.data()</code> function. It takes a data argument in the form of a function or an array, and optionally a function telling d3.js how to differentiate between various parts of the data.</p><p>When you <a id="id40" class="indexterm"/>join data to a selection, one of the following three things will happen:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is more data than was already joined (the length of the data is longer than the <a id="id41" class="indexterm"/>length of a selection). You can reference the new entries with the <code class="literal">.enter()</code> function.</li><li class="listitem" style="list-style-type: disc">There is exactly the same amount of data as before. You can use the selection returned by <code class="literal">.data()</code> itself to update element states.</li><li class="listitem" style="list-style-type: disc">There<a id="id42" class="indexterm"/> is less data than before. You can reference these using the <code class="literal">.exit()</code> function.</li></ul></div><p>You can't chain <code class="literal">.enter()</code> and <code class="literal">.exit()</code> because they are just references and don't create a new selection. This means you will usually want to focus on <code class="literal">.enter()</code> and <code class="literal">.exit()</code> and handle the three cases separately. Mind you, all three can happen at once.</p><p>You must be wondering, "But how's it possible for there to be both more and less data than before?" That's because selection elements are bound to instances of datum, not their number. If you shifted an array and then pushed a new value, the previous first item would go to the <code class="literal">.exit()</code> reference and the new addition would go to the <code class="literal">.enter()</code> reference.</p><p>Let's build something cool with data joins and HTML.</p></div><div class="section" title="An HTML visualization example"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>An HTML visualization example</h2></div></div></div><p>We'll start off <a id="id43" class="indexterm"/>with the same HTML file as usual. I'd suggest<a id="id44" class="indexterm"/> coding in the <code class="literal">code.js</code> file from now on because things can get pretty involved. Refresh frequently to keep an eye on what's going on.</p><p>Every great visualization needs a dataset; we'll be using the list of all Dr. Who monsters and villains since 1963. It's been published by the <span class="emphasis"><em>Guardian Datablog</em></span> in late December, 2012. You can get the CSV file from <a class="ulink" href="https://github.com/Swizec/d3.js-book-examples/blob/master/ch2/villains.csv">https://github.com/Swizec/d3.js-book-examples/blob/master/ch2/villains.csv</a>.</p><p>We are going to make a table. Not very exciting for sure, but very practical for HTML visualizations.</p><p>We begin with a global data variable.</p><p>Add the following line at the top of your <code class="literal">code.js</code> file:</p><div class="informalexample"><pre class="programlisting">var Data;</pre></div><p>Then we<a id="id45" class="indexterm"/> append an empty table to our <code class="literal">graph</code> div using the <a id="id46" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">var table = d3.select('#graph')
  .append('table')
  .attr('class', 'table');

var thead = table.append('thead'),
  tbody = table.append('tbody');</pre></div><p>As you can imagine from previous examples, this code selects the target <code class="literal">&lt;div&gt;</code> tag with ID as <code class="literal">graph</code> and appends a <code class="literal">table</code> element with a <code class="literal">class='table'</code> attribute so that Bootstrap will make it attractive.</p><p>The next two lines append empty <code class="literal">thead</code> and <code class="literal">tbody</code> elements and assign them to variables for later use.</p><p>Now we're going to load our data and assign it to the <code class="literal">Data</code> variable:</p><div class="informalexample"><pre class="programlisting">var reload = function () {
  d3.csv('villains.csv', function (data) {
    Data = data;
    redraw();
  });
};
reload();</pre></div><p>We'll be messing with the dataset later, so it's handy to have a function that we can call when we want to reload the data without having to refresh the page.</p><p>Because our dataset is in CSV format, we use the <code class="literal">csv</code> function of d3.js to load and parse it. d3.js is smart enough to understand that the first row in our dataset is not data but a set of labels, so it populates the <code class="literal">data</code> variable with an array of dictionaries as follows:</p><div class="informalexample"><pre class="programlisting">{
  "Villain": "Abzorbaloff (Victor Kennedy)",
  "Year first": "2006",
  "Year last": "2006",
  "Doc. no.": "10",
  "Doctor actor": "David Tennant",
  "Epi- sodes": "1",
  "Stories, total": "1",
  "Motivation (invasion earth, end of universe, etc)": "Kill humans",
  "Story titles": "Love and Monsters"
}</pre></div><p>If you run the code right now, Chrome <a id="id47" class="indexterm"/>will complain that the <code class="literal">redraw()</code> function doesn't exist. Let's write one as follows:</p><div class="informalexample"><pre class="programlisting">var redraw = function () {
};</pre></div><p>We defined a <code class="literal">redraw</code> variable and assigned an empty function to it.</p><p>Our next <a id="id48" class="indexterm"/>step is to make this function do something. Let's<a id="id49" class="indexterm"/> go into its body (between the two curly braces) and add some code:</p><div class="informalexample"><pre class="programlisting">var tr = tbody.selectAll('tr')
              .data(Data);

  tr.enter()
    .append('tr');

  tr.exit()
    .remove();</pre></div><p>The code is divided into three parts. The first part selects all the table rows (of which none exist yet) and joins our <code class="literal">Data</code> using the <code class="literal">.data()</code> function. The resulting selection is saved in the <code class="literal">tr</code> variable.</p><p>Next we create a table row for every new datum in the dataset using the <code class="literal">.enter()</code> reference. Right now, that's for all of them.</p><p>The last part of this code doesn't do anything yet but will remove any <code class="literal">&lt;tr&gt;</code> element in the <code class="literal">.exit()</code> reference once we change the data later.</p><p>After execution, the <code class="literal">tr</code> variable will hold an array of <code class="literal">&lt;tr&gt;</code> elements, each bound to its respective place in the dataset. The first <code class="literal">&lt;tr&gt;</code> element holds the first datum, the second holds the second datum, and so on.</p><p>Rows are useless without cells. Let's add some by relying on the fact that data stays joined to elements even after a new selection:</p><div class="informalexample"><pre class="programlisting">tr.selectAll('td')
  .data(function (d) { return d3.values(d); })
  .enter()
  .append('td')
  .text(function (d) { return d; });</pre></div><p>We selected all the <code class="literal">&lt;td&gt;</code> children of each row (none exist yet). We then had to call the <code class="literal">.data()</code> function with the same data transformed into a list of values using <code class="literal">d3.values()</code>. This gave us a new chance to use <code class="literal">.enter()</code>.</p><p>From then on it's more of the same. Each new entry gets its own table cell, and the text is set to the current datum.</p><p>Running<a id="id50" class="indexterm"/> this code will give you an utterly confusing<a id="id51" class="indexterm"/> table specifying all the Dr. Who monsters and villains televised since 1963.</p><p>Let's make it clearer. You can write this code at the bottom of the <code class="literal">redraw()</code> function or right in Chrome's JavaScript console if you want to see some live updating magic.</p><p>To sort the table by the villain's first appearance, we write the following code:</p><div class="informalexample"><pre class="programlisting">tbody.selectAll('tr')
  .sort(function (a, b) { return d3.ascending(a['Year first'], b['Year first']); });</pre></div><p>Without doing anything else, this code will redraw the table with the new ordering—no refreshing the page, no manually adding or removing elements. Because all our data is joined to the HTML, we didn't even need a reference to the original <code class="literal">tr</code> selection or the data. Pretty nifty if you ask me.</p><p>The <code class="literal">.sort()</code> function<a id="id52" class="indexterm"/> takes only a comparator function. The comparator is given two pieces of data and must decide how to order them: <code class="literal">-1</code> for being less than <code class="literal">b</code>, <code class="literal">0</code> for being equal, and <code class="literal">1</code> for being more than <code class="literal">b</code>. You can also use <code class="literal">d3.ascending</code> and <code class="literal">d3.descending</code> comparators of d3.js.</p><p>That's still pretty unclear though. Let's limit our table only to the latest Doctor:</p><div class="informalexample"><pre class="programlisting">Data = Data.filter(function (d) { return d['Doctor actor'] == 'Matt Smith'; })
redraw()</pre></div><p>We filtered the dataset so that it only contains rows where the actor is Matt Smith, and then we called the <code class="literal">redraw()</code> function. The <code class="literal">.exit()</code> selection does its job and a few hundred rows are removed from the table. Wait… we ended up with a mishmash of actors. Took me a while to figure out what's going on.</p><p>JavaScript is a language with instance-based identity, which means that d3.js can't use <code class="literal">a == b</code> to decide whether two complex objects are the same. Instead, it relies on indexes to identify objects. So when we filtered our data, the first <span class="emphasis"><em>x</em></span> number of indexes had something in them and were considered unchanged, and the rest were removed. The data already attached to elements doesn't get updated, and we have a bad table on our hands. We can get out of this in two ways.</p><p>We could first sort the table and then filter the data as follows:</p><div class="informalexample"><pre class="programlisting">tbody.selectAll('tr').sort(function (a, b) {
  return d3.descending(Number(a['Doc. no.']), Number(b['Doc. no.']));
});</pre></div><p>As before, we used a comparator to sort; we used a numerical comparison between <code class="literal">a['Doc. no.']</code> and <code class="literal">b['Doc. no.']</code> to sort the rows in descending order with the highest number on top.</p><p>Running the same code as before will give the desired result:</p><div class="informalexample"><pre class="programlisting">Data = Data.filter(function (d) { return d['Doctor actor'] == 'Matt Smith'; })
redraw()</pre></div><p>This <a id="id53" class="indexterm"/>worked because Matt Smith was in the first <span class="emphasis"><em>x</em></span> places of <a id="id54" class="indexterm"/>the dataset. But the approach only works for this example. We can use a more robust approach, but it doesn't happen automatically when we change the data. Remember to refresh the page or run <code class="literal">reload()</code> to get the whole dataset back.</p><p>Now we can filter the table directly as follows:</p><div class="informalexample"><pre class="programlisting">tbody.selectAll('tr')
  .filter(function (d) { return d['Doctor actor'] != 'Matt Smith'; })
  .remove()</pre></div><p>The <code class="literal">.filter()</code> function<a id="id55" class="indexterm"/> takes a single selector as its argument and feeds the current datum to it. When the function returns <code class="literal">false</code>, the element is removed from the selection; when it returns <code class="literal">true</code>, the element remains. In the end, we use the <code class="literal">.remove()</code> function<a id="id56" class="indexterm"/> to remove every row we caught. Much more robust, but playing with the data itself is often more elegant. Choose wisely.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="SVG"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>SVG</h1></div></div></div><p>Scalable Vector Graphics is a vector graphics format that describes images with XML. It's been<a id="id57" class="indexterm"/> around since 1999 and is supported by all major browsers these days. Unfortunately, Internet Explorer has been a laggard and provides only limited support since Version 9. Vector images can be rendered in any size without becoming fuzzy. This means you can render the same image on a large retina display or a small mobile phone, and it will look great in both cases.</p><p>SVG images are made up of shapes you can create from scratch using paths, or put together from basic shapes defined in the standard, for example, a line or a circle. The format itself represents shapes with XML elements and some attributes.</p><p>As such, SVG code is just a bunch of text you can edit manually, inspect with your browser's<a id="id58" class="indexterm"/> normal debugging tools, and compress with standard text compression algorithms. Being text based also means you can use d3.js to create an image in your browser, then copy and paste the resulting XML to a <code class="literal">.svg</code> file, and open it with any SVG viewer.</p><p>Another consequence is that browsers can consider SVG to be a normal part of the document. You can use CSS for styling, listening for mouse events on specific shapes, and even scripting the image to make animations where images are interactive.</p><div class="section" title="Drawing with SVG"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Drawing with SVG</h2></div></div></div><p>To draw <a id="id59" class="indexterm"/>with d3.js, you can add shapes manually by defining the appropriate SVG elements, or you can use helper functions that help you create advanced shapes easily.</p><p>Now we're going to go through the very core of what d3.js does. Everything else builds from this, so pay attention.</p><p>Let's start by preparing a drawing area in our usual environment. Put this code at the top of a fresh <code class="literal">code.js</code> file:</p><div class="informalexample"><pre class="programlisting">var svg = d3.select('#graph')
  .append('svg')
  .style('width', 1024)
  .style('height', 768);</pre></div><p>We appended an <code class="literal">&lt;svg&gt;</code> element to the main <code class="literal">&lt;div&gt;</code> tag and adjusted its size. From now on, we'll be using the <code class="literal">svg</code> variable for drawing.</p><div class="section" title="Manually adding elements and shapes"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Manually adding elements and shapes</h3></div></div></div><p>An <a id="id60" class="indexterm"/>SVG image<a id="id61" class="indexterm"/> is a collection of<a id="id62" class="indexterm"/> elements rendered as shapes and comes with a set of seven basic<a id="id63" class="indexterm"/> elements. All but one of these are just an easier way to define a path:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Text<a id="id64" class="indexterm"/> (the only one that isn't a path)</li><li class="listitem" style="list-style-type: disc">Straight lines<a id="id65" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Rectangles<a id="id66" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Circles<a id="id67" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Ellipses<a id="id68" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Polylines<a id="id69" class="indexterm"/> (a set of straight lines)</li><li class="listitem" style="list-style-type: disc">Polygons<a id="id70" class="indexterm"/> (a set of straight lines, closing in on itself)</li></ul></div><p>You build SVG images by adding these elements to the canvas and defining some attributes. All<a id="id71" class="indexterm"/> of them can have a <code class="literal">stroke</code> style defining how the<a id="id72" class="indexterm"/> edge is rendered, a <code class="literal">fill</code> style defining how the shape is filled, and all of them can be rotated, skewed, or moved using the <code class="literal">transform</code> attribute.</p><div class="section" title="Text"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec01"/>Text</h4></div></div></div><p>Text is the only <a id="id73" class="indexterm"/>element that is neither a shape nor does it translate to a path<a id="id74" class="indexterm"/> in the background like the others. Let's look at it first so the rest of this chapter can be about shapes:</p><div class="informalexample"><pre class="programlisting">svg.append('text')
  .text("A picture!")
  .attr({x: 10,
    y: 150,
      'text-anchor': 'start'});</pre></div><p>We took our <code class="literal">svg</code> element and appended a <code class="literal">text</code> element. Then we defined its actual text and added some attributes to position the text at the <code class="literal">(x, y)</code> point and anchored the text at start.</p><p>The <code class="literal">text-anchor</code> attribute defines the horizontal positioning of rendered text in relation to the anchor point defined by <code class="literal">(x, y)</code>. The positions it understands are the start, the middle, and the end.</p><p>We can also fine tune the text's position with an offset defined by the <code class="literal">dx</code> and <code class="literal">dy</code> attributes. This is especially handy when adjusting the text margin and baseline relative to the font size because it understands the <code class="literal">em</code> unit.</p><p>Our image looks as follows:</p><div class="mediaobject"><img src="images/0007_02_02.jpg" alt="Text"/></div></div><div class="section" title="Shapes"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec02"/>Shapes</h4></div></div></div><p>Now that <a id="id75" class="indexterm"/>text is out of the way, let's look at something useful—shapes, the heart of the rest of this book.</p><p>We begin by drawing a <a id="id76" class="indexterm"/>straight line using the following code:</p><div class="informalexample"><pre class="programlisting">svg.append('line')
  .attr({x1: 10,
    y1: 10,
    x2: 100,
    y2: 100,
    stroke: 'blue',
    'stroke-width': 3});</pre></div><p>As before, we took the <code class="literal">svg</code> element, appended a line, and defined some attributes. A line is drawn between two points: <code class="literal">(x1, y1)</code> and <code class="literal">(x2, y2)</code>. To make the line visible, we have to define the stroke color and <code class="literal">stroke-width</code> attributes as well.</p><div class="mediaobject"><img src="images/0007_02_03.jpg" alt="Shapes"/></div><p>Our line points downwards even though <code class="literal">y2</code> is bigger than <code class="literal">y1</code>. Hmm… that's because the origin in most image formats lies in the top-left corner. This means <code class="literal">(x=0, y=0)</code> defines the top-left corner of the image.</p><p>To draw<a id="id77" class="indexterm"/> a <a id="id78" class="indexterm"/>rectangle, we can use the <code class="literal">rect</code> element:</p><div class="informalexample"><pre class="programlisting">svg.append('rect')
  .attr({x: 200,
    y: 50,
    width: 300,
    height: 400});</pre></div><p>We appended a <code class="literal">rect</code> element to the <code class="literal">svg</code> element and defined some attributes. A rectangle is defined by its upper-left corner (<code class="literal">x</code>, <code class="literal">y</code>), <code class="literal">width</code>, and <code class="literal">height</code>.</p><p>Our image<a id="id79" class="indexterm"/> now <a id="id80" class="indexterm"/>looks as follows:</p><div class="mediaobject"><img src="images/0007_02_04.jpg" alt="Shapes"/></div><p>We have an unwieldy black rectangle. We can make it prettier by defining three more properties as follows:</p><div class="informalexample"><pre class="programlisting">svg.select('rect')
  .attr({stroke: 'green',
    'stroke-width': 0.5,
    fill: 'white',
    rx: 20,
    ry: 40});</pre></div><div class="mediaobject"><img src="images/0007_02_05.jpg" alt="Shapes"/></div><p>This <a id="id81" class="indexterm"/>is much <a id="id82" class="indexterm"/>better. Our rectangle has a thin, green outline. Rounded corners come from the <code class="literal">rx</code> and <code class="literal">ry</code> attributes, which define the corner radius along the x and y axis:</p><p>Let's try adding a circle:</p><div class="informalexample"><pre class="programlisting">svg.append('circle')
  .attr({cx: 350,
    cy: 250,
    r: 100,
    fill: 'green',
    fill-opacity': 0.5,
    stroke: 'steelblue',
    'stroke-width': 2});</pre></div><p>A circle is <a id="id83" class="indexterm"/>defined by a central point <code class="literal">(cx, cy)</code> and a radius <code class="literal">r</code>. In this instance, we<a id="id84" class="indexterm"/> get a <code class="literal">green</code> circle with a <code class="literal">steelblue</code> outline in the middle of our rectangle. The <code class="literal">fill-opacity</code> attribute tells the circle to be slightly transparent so it doesn't look too strong against the light rectangle:</p><div class="mediaobject"><img src="images/0007_02_06.jpg" alt="Shapes"/></div><p>Mathematically <a id="id85" class="indexterm"/>speaking, a circle is just a special form of ellipse. By adding another radius and<a id="id86" class="indexterm"/> changing the element, we can draw one of these:</p><div class="informalexample"><pre class="programlisting">svg.append('ellipse')
  .attr({cx: 350,
    cy: 250,
    rx: 150,
    ry: 70,
    fill: 'green',
    'fill-opacity': 0.3,
    stroke: 'steelblue',
    'stroke-width': 0.7});</pre></div><p>We added an <code class="literal">ellipse</code> element and defined some well-known attributes. The ellipse shape needs a central point <code class="literal">(cx, cy)</code> and two radii, <code class="literal">rx</code> and <code class="literal">ry</code>. Setting a low <code class="literal">fill-opacity</code> attribute makes the circle visible under the ellipse:</p><div class="mediaobject"><img src="images/0007_02_07.jpg" alt="Shapes"/></div><p>That's nice, <a id="id87" class="indexterm"/>but we can make it more interesting using the following <a id="id88" class="indexterm"/>code:</p><div class="informalexample"><pre class="programlisting">svg.append('ellipse')
  .attr({cx: 350,
    cy: 250,
    rx: 20,
    ry: 70});</pre></div><p>The only trick here is that <code class="literal">rx</code> is smaller than <code class="literal">ry</code>, creating a vertical ellipse. Lovely!</p><div class="mediaobject"><img src="images/0007_02_08.jpg" alt="Shapes"/></div><p>A strange green eye with a random blue line is staring at you, all thanks to manually adding basic SVG elements to the canvas and defining some attributes.</p><p>The <a id="id89" class="indexterm"/>generated SVG looks in XML form as follows:</p><div class="informalexample"><pre class="programlisting">&lt;svg style="width: 1024px; height: 768px;"&gt;
  &lt;text x="10" y="150" text-anchor="start"&gt;A picture!&lt;/text&gt;
  &lt;line x1="10" y1="10" x2="100" y2="100" stroke="blue" stroke-width="3"&gt;&lt;/line&gt;
  &lt;rect x="200" y="50" width="300" height="400" stroke="green" stroke-width="0.5" fill="white" rx="20" ry="40"&gt;&lt;/rect&gt;
  &lt;circle cx="350" cy="250" r="100" fill="green" fill-opacity="0.5" stroke="steelblue" stroke-width="2"&gt;&lt;/circle&gt;
  &lt;ellipse cx="350" cy="250" rx="150" ry="70" fill="green" fill-opacity="0.3" stroke="steelblue" stroke-width="0.7"&gt;&lt;/ellipse&gt;
  &lt;ellipse cx="350" cy="250" rx="20" ry="70"&gt;&lt;/ellipse&gt;
&lt;/svg&gt;</pre></div><p>Yeah, I wouldn't <a id="id90" class="indexterm"/>want to write that by hand either.</p><p>But you can see all the elements and attributes we added before. Being able to look at an image file and understand what's going on might come in handy some day. It's certainly cool. Usually when you open an image in a text editor, all you get is binary gobbledygook.</p><p>Now, I know I <a id="id91" class="indexterm"/>mentioned earlier that polylines and polygons are also basic <a id="id92" class="indexterm"/>SVG elements. The only reason I'm leaving off the<a id="id93" class="indexterm"/> explanation of these basic elements is because with d3.js, we have some <a id="id94" class="indexterm"/>great tools to work with them. Trust me, you don't want to do them manually.</p></div></div><div class="section" title="Transformations"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Transformations</h3></div></div></div><p>Before jumping onto more complicated things, we have to look at transformations.</p><p>Without going <a id="id95" class="indexterm"/>into too much mathematical detail, it suffices to say<a id="id96" class="indexterm"/> that transformations, as used in SVG, are affine transformations of coordinate systems used by shapes in our drawing. The beautiful thing is they can be defined as matrix multiplications, making them very efficient to compute.</p><p>But, unless <a id="id97" class="indexterm"/>your <a id="id98" class="indexterm"/>brain is <a id="id99" class="indexterm"/>made<a id="id100" class="indexterm"/> out of linear algebra, using <a id="id101" class="indexterm"/>transformations as matrices can get very tricky. SVG helps out by coming with a set of predefined transformations, namely, <code class="literal">translate()</code>, <code class="literal">scale()</code>, <code class="literal">rotate()</code>, <code class="literal">skewX()</code>, and <code class="literal">skewY()</code>.</p><p>According to Wikipedia, an affine transformation is any transformation that preserves points, straight lines, and planes, while keeping sets of parallel lines parallel. They don't necessarily preserve distances but do preserve ratios of distances between points on a straight line. This means if you take a rectangle, you can use affine transformations to rotate it, make it bigger, and even turn it into a parallelogram; however, no matter what you do, it will never become a trapezoid.</p><p>Computers handle transformations as matrix multiplication because any sequence of transformations can be collapsed into a single matrix. This means they only have to apply a single <a id="id102" class="indexterm"/>transformation that encompasses your sequence of transformations <a id="id103" class="indexterm"/>when drawing the shape, which is handy.</p><p>We will apply transformations with the <code class="literal">transform</code> attribute. We can define multiple transformations that are applied in order. The order of operations can change the result. You'll notice this in the following examples.</p><p>Let's move our eye to the edge of the rectangle:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('ellipse, circle')
  .attr('transform', 'translate(150, 0)');</pre></div><p>We selected everything our eye is made of (two ellipses and a circle), and then applied the <code class="literal">translate</code> transformation. It moved the shape's origin along the <code class="literal">(150, 0)</code> vector, moving the shape 150 pixels to the right and 0 pixels down.</p><p>If you try moving it again, you'll notice new transformations are applied according to the original state of our shape. That's because there can only be one <code class="literal">transform</code> attribute per shape.</p><p>Our picture looks as follows:</p><div class="mediaobject"><img src="images/0007_02_08.jpg" alt="Transformations"/></div><p>Let's rotate the eye by 45 degrees:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('ellipse, circle')
  .attr('transform', 'translate(150, 0) rotate(45)');</pre></div><div class="mediaobject"><img src="images/0007_02_10.jpg" alt="Transformations"/></div><p>That's not <a id="id104" class="indexterm"/>what we wanted at all.</p><p>What tricked <a id="id105" class="indexterm"/>us is that rotations happen around the origin of the image, not the shape. We have to define the rotation axis ourselves:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('ellipse, circle')
  .attr('transform', 'translate(150, 0) rotate(-45, 350, 250)');</pre></div><p>By adding two more arguments to <code class="literal">rotate()</code>, we defined the rotation axis and achieved the desired result:</p><div class="mediaobject"><img src="images/0007_02_11.jpg" alt="Transformations"/></div><p>Let's make the eye a little bigger with the <code class="literal">scale()</code> transformation:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('ellipse, circle')
  .attr('transform', 'translate(150, 0) rotate(-45, 350, 250) scale(1.2)');</pre></div><p>This will make our object <code class="literal">1.2</code> times bigger along both the axes; two arguments would have scaled by different factors along the x and y axes:</p><div class="mediaobject"><img src="images/0007_02_12.jpg" alt="Transformations"/></div><p>Once again, we<a id="id106" class="indexterm"/> pushed the position of the eye because scaling is <a id="id107" class="indexterm"/>anchored at the zeroth point of the whole image. We have to use another <code class="literal">translate</code> to move it back. But the coordinate system we're working on is now rotated by 45 degrees and scaled. This makes things tricky. We need to translate between the two coordinate systems to move the eye correctly. To move the eye 70 pixels to the left, we have to move it along each axis by <span class="emphasis"><em>70*sqrt(2)/2</em></span> pixels, which is the result of cosine and sine at an angle of 45.</p><p>But that's just messy. The number looks funny, and we worked way too much for something so simple. Let's change the order of operations instead:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('ellipse, circle')
  .attr('transform', 'translate(150, 0) scale(1.2) translate(-70, 0) rotate(-45, '+(350/1.2)+', '+(250/1.2)+')');</pre></div><p>Much better! We get exactly what we wanted:</p><div class="mediaobject"><img src="images/0007_02_13.jpg" alt="Transformations"/></div><p>A lot has changed, let's take a look.</p><p>First we <a id="id108" class="indexterm"/>translate to our familiar position and then scale by <code class="literal">1.2</code>, pushing <a id="id109" class="indexterm"/>the eye out of position. We fix this by translating back to the left by <code class="literal">70</code> pixels and then finally performing the <code class="literal">45</code> degree rotation, making sure to divide the pivot point by <code class="literal">1.2</code>.</p><p>There's one more thing we can do to the poor eye; skew it. Two skew transformations exist: <code class="literal">skewX</code> and <code class="literal">skewY</code>. Both skew along their respective axis:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('ellipse, circle')
  .attr('transform', 'translate(150, 0) scale(1.2) translate(-70, 0) rotate(-45, '+(350/1.2)+', '+(250/1.2)+') skewY(20)');</pre></div><p>We just bolted <code class="literal">skewY(20)</code> on to the end of the <code class="literal">transform</code> attribute.</p><div class="mediaobject"><img src="images/0007_02_14.jpg" alt="Transformations"/></div><p>We have once more destroyed our careful centering. Fixing this is left as an exercise for the reader (I've always wanted to say that).</p><p>All said, transformations really are just matrix multiplication. In fact, you can define any transformation<a id="id110" class="indexterm"/> you want with the <code class="literal">matrix()</code> function. I suggest <a id="id111" class="indexterm"/>taking a look at exactly what kind of matrix produces each of the preceding effects. The W3C<a id="id112" class="indexterm"/> specification available at <a class="ulink" href="http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace">http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace</a> can help.</p></div><div class="section" title="Using paths"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Using paths</h3></div></div></div><p>Path elements<a id="id113" class="indexterm"/> define outlines of shapes that can be filled, stroked, and <a id="id114" class="indexterm"/>so on. They are generalizations of all other shapes and can be used to draw nearly anything.</p><p>Most of the path's magic<a id="id115" class="indexterm"/> stems from the <code class="literal">d</code> attribute; it uses a mini language of three basic commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">M</code><a id="id116" class="indexterm"/>, meaning moveto</li><li class="listitem" style="list-style-type: disc"><code class="literal">L</code>, meaning<a id="id117" class="indexterm"/> lineto</li><li class="listitem" style="list-style-type: disc"><code class="literal">Z</code><a id="id118" class="indexterm"/>, meaning closepath</li></ul></div><p>To create a rectangle, we might write something as follows:</p><div class="informalexample"><pre class="programlisting">svg.append('path')
  .attr({d: 'M 100 100 L 300 100 L 200 300 z',
    stroke: 'black',
    'stroke-width': 2,
    fill: 'red',
    'fill-opacity': 0.7});</pre></div><p>We appended a new element to our <code class="literal">svg</code> and then defined some attributes. The interesting bit is the <code class="literal">d</code> attribute, <code class="literal">M 100 100 L 300 100 L 200 300 z</code>. Breaking this down, you can see we<a id="id119" class="indexterm"/> first moved to (<code class="literal">100</code>, <code class="literal">100</code>), drew a line on (<code class="literal">300</code>, <code class="literal">100</code>), another <a id="id120" class="indexterm"/>line on (<code class="literal">200</code>, <code class="literal">300</code>), and then closed the path.</p><div class="mediaobject"><img src="images/0007_02_15.jpg" alt="Using paths"/></div><p>The power of paths doesn't stop there, though. Commands beyond the <code class="literal">M</code>, <code class="literal">L</code>, <code class="literal">Z</code> combination give us tools to create curves and arcs. But creating complex shapes by hand is beyond tediousness.</p><p>d3.js comes with some helpful path generator functions that take JavaScript and turn it into path definitions. We'll be looking at those next.</p><p>Our image is getting pretty crowded, so let's restart the environment.</p><p>To start things off, we'll draw the humble sine function. Once again, we begin by preparing the drawing area:</p><div class="informalexample"><pre class="programlisting">var width = 1024,
  height = 768,
  margin = 10;

var svg = d3.select('#graph')
  .append('svg')
  .attr('width', width+2*margin)
  .attr('height', height+2*margin);

var g = svg.append('g')
  .attr('transform', 'translate('+margin+', '+margin+')');</pre></div><p>We appended an <code class="literal">svg</code> element to our <code class="literal">#graph</code> div and set a large enough <code class="literal">width</code> and <code class="literal">height</code> for our evil plans. Then, we appended a <code class="literal">g</code> element to put our chart in. The <code class="literal">g</code> element is a logical grouping of SVG shapes, improving the semantics of our document and making it easier to use.</p><p>Next, we <a id="id121" class="indexterm"/>need some data, which is the <code class="literal">sine</code> function.</p><div class="informalexample"><pre class="programlisting">var sine = d3.range(0,10).map(
  function (k) { return [0.5*k*Math.PI,
                         Math.sin(0.5*k*Math.PI)]; });</pre></div><p>Using <code class="literal">d3.range(0,10)</code> gives us a list of integers from zero to nine. We map over them and turn<a id="id122" class="indexterm"/> each into a tuple, actually a 2-length array representing the maxima, minima, and zeroes of the curve. You might remember from your math class that sine starts at (0,0), then goes to (Pi/2, 1), (Pi, 0), (3Pi/2, -1), and so on.</p><p>We'll feed these as data into a path generator.</p><p>Path generators are really the meat of d3.js's magic. We'll discuss the gravy of the magic in <a class="link" href="ch05.html" title="Chapter 5. Layouts – d3's Black Magic">Chapter 5</a>, <span class="emphasis"><em>Layouts – d3's Black Magic</em></span>. They are essentially a function that takes some data (joined to elements) and produces a path definition in SVG's path mini language. All path generators can be told how to use our data. We also get to play with the final output a great deal.</p><div class="section" title="Line"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec03"/>Line</h4></div></div></div><p>To create a line<a id="id123" class="indexterm"/> we use the <code class="literal">d3.svg.line()</code> generator and define the x- and y-accessor<a id="id124" class="indexterm"/> functions. Accessors tell the generator how to read the x and y coordinates from datapoints.</p><p>We begin by defining two scales. Scales are functions that map from a domain to a range; we'll talk more about them in the next chapter:</p><div class="informalexample"><pre class="programlisting">var x = d3.scale.linear()
  .range([0, width/2-margin])
  .domain(d3.extent(sine, function (d) { return d[0]; })),
  y = d3.scale.linear().range([height/2-margin, 0]).domain([-1, 1]);</pre></div><p>Now we get to define a simple path generator:</p><div class="informalexample"><pre class="programlisting">var line = d3.svg.line()
  .x(function (d) { return x(d[0]); })
    .y(function (d) { return y(d[1]); });</pre></div><p>It is just a matter of taking the basic line generator and attaching some accessors to it. We told the generator to use our <code class="literal">x</code> scale on the first element and the <code class="literal">y</code> scale on the second element of every tuple. By default, it assumes our dataset as a collection of arrays defining points directly so that <code class="literal">d[0]</code> is <code class="literal">x</code> and <code class="literal">d[1]</code> is <code class="literal">y</code>.</p><p>All that's left <a id="id125" class="indexterm"/>now is drawing the actual line:</p><div class="informalexample"><pre class="programlisting">g.append('path')
  .datum(sine)
  .attr("d", line)
  .attr({stroke: 'steelblue',
        'stroke-width': 2,
         fill: 'none'});</pre></div><p>Append a<a id="id126" class="indexterm"/> path, and add the <code class="literal">sine</code> data using <code class="literal">.datum()</code>. Using this instead of <code class="literal">.data()</code> means we can render the function as a single element instead of creating a new line for every point. We let our generator define the <code class="literal">d</code> attribute. The rest just makes things visible.</p><p>Our graph looks as follows:</p><div class="mediaobject"><img src="images/0007_02_16.jpg" alt="Line"/></div><p>If you look at the generated code, you'll see this sort of gobbledygook:</p><div class="informalexample"><pre class="programlisting">d="M0,192L56.88888888888889,0L113.77777777777779,191.99999999999994L170.66666666666669,384L227.55555555555557,192.00000000000006L284.44444444444446,0L341.33333333333337,191.99999999999991L398.2222222222223,384L455.11111111111114,192.00000000000009L512,0"</pre></div><p>See! I told you nobody wants to write that by hand.</p><p>That's a very jagged <code class="literal">sine</code> function we've got there, nothing similar to what the math teacher used to draw in high school. We can make it better with interpolation.</p><p>Interpolation is the act of guessing where unspecified points of a line should appear, considering the points we do know. By default, we're using the <code class="literal">linear</code> interpolator that just draws straight lines between points.</p><p>Let's try something else:</p><div class="informalexample"><pre class="programlisting">g.append('path')
  .datum(sine)
  .attr("d", line.interpolate('step-before'))
  .attr({stroke: 'black',
    'stroke-width': 1,
    fill: 'none'});</pre></div><p>It is the same <a id="id127" class="indexterm"/>code as before, but we used the <code class="literal">step-before</code> interpolator and <a id="id128" class="indexterm"/>changed the styling to produce this:</p><div class="mediaobject"><img src="images/0007_02_17.jpg" alt="Line"/></div><p>d3.js offers 12 line interpolators in total, which I am not going to list here. You can look them up on the official wiki page at <a class="ulink" href="https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate">https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate</a>.</p><p>I suggest trying out all of them to get a feel of what they do.</p></div><div class="section" title="Area"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec04"/>Area</h4></div></div></div><p>An area is the <a id="id129" class="indexterm"/>colored part between two lines, a polygon really.</p><p>We define an area<a id="id130" class="indexterm"/> similar to how we define a line, so take a path generator and tell it how to use our data. For a simple horizontal area, we have to define one x accessor and two y accessors, <code class="literal">y0</code> and <code class="literal">y1</code>, for both the bottom and the top.</p><p>We'll compare different generators side by side, so let's add a new graph:</p><div class="informalexample"><pre class="programlisting">var g2 = svg.append('g')
  .attr('transform', 'translate('+(width/2+margin)+', '+margin+')');</pre></div><p>Now we define an <code class="literal">area</code> generator and draw an area.</p><div class="informalexample"><pre class="programlisting">var area = d3.svg.area()
  .x(function (d) { return x(d[0]); })
  .y0(height/2)
  .y1(function (d) { return y(d[1]); })
  .interpolate('basis');

g2.append('path')
  .datum(sine)
  .attr("d", area)
  .attr({fill: 'steelblue',
    'fill-opacity': 0.4});</pre></div><p>We took a vanilla <code class="literal">d3.svg.area()</code> path generator and told it to get the coordinates through the <code class="literal">x</code> and <code class="literal">y</code> scales we defined earlier. The <code class="literal">basis</code> interpolator will use a B-spline to create a <a id="id131" class="indexterm"/>smooth curve from our data.</p><p>To draw the<a id="id132" class="indexterm"/> bottom edge, we defined <code class="literal">y0</code> as the bottom of our graph and produced a colored sine approximation:</p><div class="mediaobject"><img src="images/0007_02_19.jpg" alt="Area"/></div><p>Areas are often used together with lines that make an important edge stand out. Let's try that:</p><div class="informalexample"><pre class="programlisting">g2.append('path')
  .datum(sine)
  .attr("d", line.interpolate('basis'))
  .attr({stroke: 'steelblue',
    'stroke-width': 2,
    fill: 'none'});</pre></div><p>We could re-use the same line generator as before; we just need to make sure that we use the same interpolator as for the area. This way, the image looks much better:</p><div class="mediaobject"><img src="images/0007_02_20.jpg" alt="Area"/></div></div><div class="section" title="Arc"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec05"/>Arc</h4></div></div></div><p>An arc<a id="id133" class="indexterm"/> is a circular path with an inner and outer radius, going from one angle to <a id="id134" class="indexterm"/>another. They are often used for pie and donut charts.</p><p>Everything works as before; we just tell the base generator how to use our data. The only difference is that this time the default accessors expect named attributes instead of 2-value arrays we've gotten used to.</p><p>Let's draw an arc:</p><div class="informalexample"><pre class="programlisting">var arc = d3.svg.arc();

var g3 = svg.append('g')
        .attr('transform', 'translate('+margin+', '+(height/2+margin)+')');

g3.append('path')
  .attr("d", arc({outerRadius: 100,
    innerRadius: 50,
    startAngle: -Math.PI*0.25,
    endAngle: Math.PI*0.25}))
  .attr('transform', 'translate(150, 150)')
  .attr('fill', 'lightslategrey');</pre></div><p>This time we could get away with using the default <code class="literal">d3.svg.arc()</code> generator. Instead of using data, we calculated the angles by hand and also nudged the arc towards the center.</p><div class="mediaobject"><img src="images/0007_02_21.jpg" alt="Arc"/></div><p>See, a simple arc. Rejoice!</p><p>Even <a id="id135" class="indexterm"/>though SVG normally uses degrees, the start and end angles use radians. The<a id="id136" class="indexterm"/> zero angle points upwards with negative values going anticlockwise and positive values going the other way. Every <span class="emphasis"><em>2Pi</em></span> we come back to zero.</p></div><div class="section" title="Symbol"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec06"/>Symbol</h4></div></div></div><p>Sometimes <a id="id137" class="indexterm"/>when visualizing data, we need a simple way to mark datapoints. That's where symbols come in, tiny glyphs used to distinguish between datapoints.</p><p>The <code class="literal">d3.svg.symbol()</code> generator takes a <code class="literal">type</code> accessor and a <code class="literal">size</code> accessor, and leaves the positioning<a id="id138" class="indexterm"/> to us. We are going to add some symbols to our area chart showing where the function is going when it crosses zero.</p><p>As always, we start with a path generator:</p><div class="informalexample"><pre class="programlisting">var symbols = d3.svg.symbol()
    .type(function (d, i) {
      if (d[1] &gt; 0) {
        return 'triangle-down';
      }else{
        return 'triangle-up';
      }
    })
    .size(function (d, i) {
      if (i%2) {
        return 0;
      }else{
        return 64;
      }
    });</pre></div><p>We've given the <code class="literal">d3.svg.symbol()</code> generator a <code class="literal">type</code> accessor telling it to draw a downward pointing triangle when the y coordinate is positive and an upward one when not positive. This works because our <code class="literal">sine</code> data isn't mathematically perfect due to <code class="literal">Math.PI</code> not being infinite and due to floating point precision; we get infinitesimal numbers close to zero whose signedness depends on whether the <code class="literal">Math.sin</code> argument is slightly less or slightly more than the perfect point for <code class="literal">sin=0</code>.</p><p>The <code class="literal">size</code> accessor tells <code class="literal">symbol()</code> how much area each symbol should occupy. Because every <a id="id139" class="indexterm"/>other datapoint is close to zero, we hide the others with an area equal to <a id="id140" class="indexterm"/>zero.</p><p>Now we can draw some symbols:</p><div class="informalexample"><pre class="programlisting">g2.selectAll('path')
  .data(sine)
  .enter()
  .append('path')
  .attr('d', symbols)
  .attr('transform', function (d) { return 'translate('+x(d[0])+','+y(d[1])+')'; })
  .attr({stroke: 'steelblue',
      'stroke-width': 2,
      fill: 'white'});</pre></div><p>Go through the data, append a new path for each entry, and turn it into a symbol moved into position. The result looks as follows:</p><div class="mediaobject"><img src="images/0007_02_22.jpg" alt="Symbol"/></div><p>You can see other available symbols by printing <code class="literal">d3.svg.symbolTypes</code>.</p></div><div class="section" title="Chord"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec07"/>Chord</h4></div></div></div><p>Good <a id="id141" class="indexterm"/>news! We are leaving the world of simple charts and entering the world of <a id="id142" class="indexterm"/>magic.</p><p>Chords are most often used to display relations between group elements when arranged in a circle. They use quadratic Bezier curves to create a closed shape connecting two points on an arc.</p><p>If you don't have a strong background in computer graphics, that tells you nothing. A basic chord looks similar to half a villain's moustache:</p><div class="mediaobject"><img src="images/0007_02_23.jpg" alt="Chord"/></div><p>To draw that, we use the following piece of code:</p><div class="informalexample"><pre class="programlisting">g3.append('g').selectAll('path')
  .data([{
    source: {radius: 50,
                  startAngle: -Math.PI*0.30,
                  endAngle: -Math.PI*0.20},
    target: {radius: 50,
                  startAngle: Math.PI*0.30,
                  endAngle: Math.PI*0.30}}])
  .enter()
  .append('path')
  .attr("d", d3.svg.chord());</pre></div><p>This code adds a new grouping element, defines a dataset with a single datum, and appends a path using the default <code class="literal">d3.svg.chord()</code> generator for the <code class="literal">d</code> attribute.</p><p>The data itself plays right into the hands of the default accessors. <code class="literal">Source</code> defines where the chord begins and <code class="literal">target</code> where it ends. Both are fed to another set of accessors, specifying the arc's <code class="literal">radius</code>, <code class="literal">startAngle</code>, and <code class="literal">endAngle</code>. As with the arc generator, angles are defined using radians.</p><p>Let's make up some data and draw a chord diagram:</p><div class="informalexample"><pre class="programlisting">var data = d3.zip(d3.range(0, 12),
                            d3.shuffle(d3.range(0, 12))),
  colors = ['linen', 'lightsteelblue', 'lightcyan',
                   'lavender', 'honeydew', 'gainsboro'];</pre></div><p>Nothing too fancy. We defined two arrays of numbers, shuffled one, and merged them into an array of pairs; we will look at the details in the next chapter. Then we defined some colors.</p><div class="informalexample"><pre class="programlisting">var chord = d3.svg.chord()
    .source(function (d) { return d[0]; })
    .target(function (d) { return d[1]; })
    .radius(150)
    .startAngle(function (d) { return -2*Math.PI*(1/data.length)*d; })
    .endAngle(function (d) {
      return -2*Math.PI*(1/data.length)*((d-1)%data.length); });</pre></div><p>All of this just defines the generator. We're going to divide a circle into sections and connect<a id="id143" class="indexterm"/> random pairs with chords.</p><p>The <code class="literal">.source()</code> and <code class="literal">.target()</code> accessors tell us the first item in every pair is the source and the second is the target. For <code class="literal">startAngle</code>, we remember a full circle is <span class="emphasis"><em>2Pi</em></span> and divide it by the <a id="id144" class="indexterm"/>number of sections. Finally, to pick a section, we multiply by the current datum. The <code class="literal">endAngle</code> accessor is more of the same, except with datums offset by one.</p><div class="informalexample"><pre class="programlisting">g3.append('g')
  .attr('transform', 'translate(300, 200)')
  .selectAll('path')
  .data(data)
  .enter()
  .append('path')
  .attr('d', chord)
  .attr('fill', function (d, i) { return colors[i%colors.length]; })
  .attr('stroke', function (d, i) { return colors[(i+1)%colors.length]; });</pre></div><p>To draw the actual diagram we create a new grouping, join the dataset, and then append a path for each datum. The <code class="literal">chord</code> generator gives it a shape. To make everything look better, we define colors dynamically with the <code class="literal">colors</code> array.</p><p>The end result changes with every refresh but looks something like this:</p><div class="mediaobject"><img src="images/0007_02_24.jpg" alt="Chord"/></div></div><div class="section" title="Diagonal"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec08"/>Diagonal</h4></div></div></div><p>The <code class="literal">diagonal</code>
<a id="id145" class="indexterm"/> generator creates cubic Bezier curves—smooth curves between<a id="id146" class="indexterm"/> two points. It is very useful for visualizing trees with a node-link diagram.</p><p>Once again, the default accessors assume your data is a dictionary with keys named after the specific accessor. You need <code class="literal">source</code> and <code class="literal">target</code>, which are fed into <code class="literal">projection</code>, which then projects Cartesian coordinates into whatever coordinate space you like. By default, it just returns Cartesian coordinates.</p><p>Let's draw a moustache. Trees are hard without <code class="literal">d3.layouts</code> and we'll do those later:</p><div class="informalexample"><pre class="programlisting">var g4 = svg.append('g')
    .attr('transform', 'translate('+(width/2)+','+(height/2)+')');

var moustache = [
  {source: {x: 250, y: 100}, target: {x: 500, y: 90}},
  {source: {x: 500, y: 90}, target: {x: 250, y: 120}},
  {source: {x: 250, y: 120}, target: {x: 0, y: 90}},
  {source: {x: 0, y: 90}, target: {x: 250, y: 100}},
  {source: {x: 500, y: 90}, target: {x: 490, y: 80}},
  {source: {x: 0, y: 90}, target: {x: 10, y: 80}}
];</pre></div><p>We started off with a fresh graph on our drawing area and defined some data that should create a sweet 'stache:</p><div class="informalexample"><pre class="programlisting">g4.selectAll('path')
  .data(moustache)
  .enter()
  .append('path')
  .attr("d", d3.svg.diagonal())
  .attr({stroke: 'black',
              fill: 'none'});</pre></div><p>The rest is a<a id="id147" class="indexterm"/> simple matter of joining data to our drawing and using the <code class="literal">d3.svg.diagonal()</code> generator for the <code class="literal">d</code> attribute:</p><div class="mediaobject"><img src="images/0007_02_25.jpg" alt="Diagonal"/></div><p>Okay, it's a bit <a id="id148" class="indexterm"/>Daliesque. It may be, but it doesn't really look anything like a moustache. That's because the tangents defining how Bezier curves bend are tweaked to create good-looking fan-out in tree diagrams. Unfortunately d3.js doesn't give us a simple way of changing these, and manually defining Bezier curves through SVG's path mini language is tedious at best.</p><p>Either way, we have created a side-by-side comparison of path generators:</p><div class="mediaobject"><img src="images/0007_02_26.jpg" alt="Diagonal"/></div></div><div class="section" title="Axes"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec09"/>Axes</h4></div></div></div><p>But we haven't done anything useful with our paths and shapes yet. One way we can do that is<a id="id149" class="indexterm"/> using lines and text to create graph axes. It would be tedious though, so d3.js makes our lives easier with axis generators. They take care of drawing a line, putting <a id="id150" class="indexterm"/>on some ticks, adding labels, evenly spacing them, and so on.</p><p>A d3.js axis is just a combination of path generators configured for awesomeness. All we have to do for a simple linear axis is create a scale and tell the axis to use it. That's it!</p><p>For a more customized axis, we might have to define the desired number of ticks and specify the labels, perhaps something even more interesting. There are even ways to make circular axes.</p><p>Using a<a id="id151" class="indexterm"/> fresh version of the environment, let's create an axis.</p><p>We begin<a id="id152" class="indexterm"/> with a drawing area:</p><div class="informalexample"><pre class="programlisting">  var width = 800,
  height = 600,
  margin = 20,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
                  height: height});</pre></div><p>We also need a linear scale:</p><div class="informalexample"><pre class="programlisting">var x = d3.scale.linear().domain([0, 100]).range([margin, width-margin]);</pre></div><p>Our axis is going to use the following to translate data points (<code class="literal">domain</code>) tocoordinates (<code class="literal">range</code>):</p><div class="informalexample"><pre class="programlisting">var axis = d3.svg.axis()
    .scale(x);
var a = svg.append('g')
  .attr('transform', 'translate(0, 30)')
  .data(d3.range(0, 100))
  .call(axis);</pre></div><p>We've told the <code class="literal">d3.svg.axis()</code> generator to use our <code class="literal">x</code> scale. Then, we simply created a new grouping element, joined some data, and called the axis. It's very important to call the <code class="literal">axis</code> generator on all of the data at once so it can handle appending its own element.</p><div class="mediaobject"><img src="images/0007_02_27.jpg" alt="Axes"/></div><p>The result doesn't look good at all.</p><p>Axes are complex objects, so fixing this problem is convoluted without CSS, which comes in the next section.</p><p>For now, adding this code will be sufficient:</p><div class="informalexample"><pre class="programlisting">a.selectAll('path')
  .attr({fill: 'none',
       stroke: 'black',
       'stroke-width': 0.5});
a.selectAll('line')
  .attr({fill: 'none',
        stroke: 'black',
        'stroke-width': 0.3});</pre></div><p>An axis is a<a id="id153" class="indexterm"/> collection of paths and lines; we give them some swagger and get a<a id="id154" class="indexterm"/> nice-looking axis in return:</p><div class="mediaobject"><img src="images/0007_02_28.jpg" alt="Axes"/></div><p>If you play around with the amount, make sure the scale's domain and the range's max value match, and you'll notice axes are smart enough to always pick the perfect amount of ticks.</p><p>Let's compare what the different settings do to axes. We're going to loop through several axes and render the same data.</p><p>Wrap your axis-drawing code in a loop by adding this line just above <code class="literal">svg.append('g')</code>. Don't forget to close off the loop just after the last <code class="literal">stroke-width</code>:</p><div class="informalexample"><pre class="programlisting">axes.forEach(function (axis, i) {</pre></div><p>You should also change the <code class="literal">.attr('transform', …)</code> line to put each axis 50 pixels below the previous one.</p><div class="informalexample"><pre class="programlisting">.attr('transform', 'translate(0, '+(i*50+margin)+')')</pre></div><p>Now that's done, we can start defining an array of axes:</p><div class="informalexample"><pre class="programlisting">var axes = [
  d3.svg.axis().scale(x),

  d3.svg.axis().scale(x)
    .ticks(5)
];</pre></div><p>Two for now: one is the plain vanilla version and the other will render with exactly <code class="literal">5</code> ticks:</p><div class="mediaobject"><img src="images/0007_02_29.jpg" alt="Axes"/></div><p>It worked! The <code class="literal">axis</code> generator figured out which ticks are best left off and relabeled everything without us doing much.</p><p>Let's add <a id="id155" class="indexterm"/>more <a id="id156" class="indexterm"/>axes to the array and see what happens:</p><div class="informalexample"><pre class="programlisting">  d3.svg.axis().scale(x)
    .tickSubdivide(3)
    .tickSize(10, 5, 10)</pre></div><p>With <code class="literal">.tickSubdivide()</code>, we instruct the generator to add some subdivisions between the major ticks; <code class="literal">.tickSize()</code> tells it to make the minor ticks smaller. The arguments are major, minor, and end tick size:</p><div class="mediaobject"><img src="images/0007_02_30.jpg" alt="Axes"/></div><p>For our final trick, let's define some custom ticks and place them above the axis. We'll add another axis to the array:</p><div class="informalexample"><pre class="programlisting">  d3.svg.axis().scale(x)
    .tickValues([0, 20, 50, 70, 100])
    .tickFormat(function (d, i) {
      return ['a', 'e', 'i', 'o', 'u'][i];
    })
    .orient('top')</pre></div><p>Three things happen here: <code class="literal">.tickValues()</code>exactly defines which values should have a tick, <code class="literal">.tickFormat()</code> specifies how to render the labels—d3 comes with a slew of helpful formatters in <code class="literal">d3.format</code> by the way—and finally <code class="literal">.orient('top')</code> puts the labels above their axis.</p><p>You might have guessed the default orient is <code class="literal">'bottom'</code>. For a vertical axis, you can use <code class="literal">'left'</code> or <code class="literal">'right'</code> but don't forget to assign an appropriate scale.</p><div class="mediaobject"><img src="images/0007_02_31.jpg" alt="Axes"/></div></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="CSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>CSS</h1></div></div></div><p>Cascading Stylesheets have been with us since 1996, making them one of the oldest staples of the <a id="id157" class="indexterm"/>Web, even though they only reached widespread popularity with the tables versus CSS wars of the early 2000s.</p><p>You're probably familiar with using CSS for styling HTML. So this section will be a refreshing breeze after all that SVG stuff.</p><p>My favorite thing about CSS is its simplicity; refer to the following code.</p><div class="informalexample"><pre class="programlisting">selector {
      attribute: value;
}</pre></div><p>And that's it. Everything you need to know about CSS in three lines.</p><p>The selectors can get fairly complicated and are beyond the scope of this book.I suggest looking around the Internet for a good guide. We just need to know some basics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">path</code>: Selects all the <code class="literal">&lt;path&gt;</code> elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">.axis</code>: Selects all the elements with a <code class="literal">class="axis"</code> attribute</li><li class="listitem" style="list-style-type: disc"><code class="literal">.axis line</code>: Selects all the <code class="literal">&lt;line&gt;</code> elements that are children of <code class="literal">class="axis"</code> elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">.axis, line</code>: Selects all the <code class="literal">class="axis"</code> and <code class="literal">&lt;line&gt;</code> elements</li></ul></div><p>Right now you might be thinking, "Oh hey! That's the same as selectors for d3.js selections." Yes! It is exactly the same. d3.js selections are a subset of CSS selectors.</p><p>We can invoke CSS with d3.js in three ways: define a class attribute with the <code class="literal">.attr()</code> method<a id="id158" class="indexterm"/>, which can be brittle; use the <code class="literal">.classed()</code> method, the preferred way<a id="id159" class="indexterm"/> to define<a id="id160" class="indexterm"/> classes; or define styling directly with the <code class="literal">.style()</code> method.</p><p>Let's improve the axes example from before and make the styling less cumbersome.</p><p>Go into the HTML and add some CSS right before the <code class="literal">&lt;div id="graph"&gt;</code> tag as follows:</p><div class="informalexample"><pre class="programlisting">&lt;style&gt;
  .axis path,
  .axis line {
    fill: none;
    stroke: black;
    stroke-width: 1px;
    shape-rendering: crispEdges;
  }

  .axis text {
    font-size: 11px;
  }

  .axis.red line,
  .axis.red path {
    stroke: red;
  }
&lt;/style&gt;</pre></div><p>It is very <a id="id161" class="indexterm"/>similar to changing SVG attributes directly, but with CSS. We used <code class="literal">stroke</code> and <code class="literal">fill</code> to define the shape of the line and set <code class="literal">shape-rendering</code> to <code class="literal">crispEdges</code>. This will make things better.</p><p>We've also defined an extra type of axis with red lines.</p><p>Now we fix the drawing loop to look as follows:</p><div class="informalexample"><pre class="programlisting">axes.forEach(function (axis, i) {
  var a = svg.append('g')
      .classed('axis', true)
      .classed('red', i%2 == 0)
      .attr('transform', 'translate(0, '+(i*50+margin)+')')
      .data(d3.range(0, 100))
      .call(axis);
});</pre></div><p>None of that foolishness with specifying the same looks five times in a row. Using the <code class="literal">.classed()</code> function, we add the <code class="literal">axis</code> class to each axis and every second axis is red. <code class="literal">.classed()</code> adds the specified class if the second argument is true and removes it otherwise.</p><div class="mediaobject"><img src="images/0007_02_32.jpg" alt="CSS"/></div><div class="section" title="Colors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Colors</h2></div></div></div><p>Beautiful visualizations often involve color beyond the basic names you can think of off the top of your head. Sometimes you want to play with colors depending on what the data looks like.</p><p>d3.js has us<a id="id162" class="indexterm"/> covered with a slew of functions devoted to manipulating<a id="id163" class="indexterm"/> color in four popular color spaces: RGB, HSL, HCL, and L*a*b. The most useful for us are going to be RGB (red green blue) and HSL (hue saturation lightness), which is secretly just another way of looking at RGB. Either way, all color spaces use the same functions, so you can use what fits your needs best.</p><p>To construct an RGB color, we use <code class="literal">d3.rgb(r, g, b)</code> where <code class="literal">r</code>, <code class="literal">g</code>, and <code class="literal">b</code> specify the channel values for red, green, and blue. We can also replace the triplet with a simple CSS color argument. Then we get to make the color darker or brighter, which is much better than shading by hand.</p><p>Time to play with color in a fresh environment. We'll draw two color wheels with their brightness changing from the center towards the outside.</p><p>As always, we begin with some variables and a drawing area:</p><div class="informalexample"><pre class="programlisting">var width = 1024,
    height = 768,
    rings = 15;

var svg = d3.select('#graph')
        .append('svg')
        .style({width: width,
                    height: height});</pre></div><p>The main variable henceforth will be <code class="literal">rings</code>; it will tell the code how many levels of brightness we want. We also need some basic colors and a way to calculate angles:</p><div class="informalexample"><pre class="programlisting">var colors = d3.scale.category20b();
var angle = d3.scale.linear().domain([0, 20]).range([0, 2*Math.PI]);</pre></div><p>
<code class="literal">colors</code> is technically a scale, but we'll use it as data. Category20b is one of four predefined color scales that come with d3.js—an easy way to get a list of well picked colors.</p><p>To calculate <a id="id164" class="indexterm"/>angles, we're using a linear scale that maps the <code class="literal">[0, 20]</code> domain to a<a id="id165" class="indexterm"/> full circle <code class="literal">[0, 2*pi]</code>.</p><p>Next we need an <code class="literal">arc</code> generator and two data accessors to change the color shade for every ring:</p><div class="informalexample"><pre class="programlisting">var arc = d3.svg.arc()
    .innerRadius(function (d) { return d*50/rings; })
    .outerRadius(function (d) { return 50+d*50/rings; })
    .startAngle(function (d, i, j) { return angle(j); })
    .endAngle(function (d, i, j) { return angle(j+1); });

var shade = {
  darker: function (d, j) { return d3.rgb(colors(j)).darker(d/rings); },
  brighter: function (d, j) { return d3.rgb(colors(j)).brighter(d/rings); }
};</pre></div><p>The arc will calculate the inner and outer radii from a simple ring counter, and the angles will use the <code class="literal">angle</code> scale, which will automatically calculate the correct radian values. The <code class="literal">j</code> argument tells us which arc section is currently being drawn.</p><p>Since we're making two pictures, we can simplify the code by using two different shaders from a dictionary.</p><p>Each shader will take a <code class="literal">d3.rgb()</code> color from the colors scale and then darken or brighten it by the appropriate number of steps, depending on which ring it's drawing. Once again, the <code class="literal">j</code> argument tells us which arc section we're in, and the <code class="literal">d</code> argument tells us which ring we're at.</p><p>Finally, we draw the two color wheels:</p><div class="informalexample"><pre class="programlisting">[[100, 100, shade.darker],
 [300, 100, shade.brighter]].forEach(function (conf) {
  svg.append('g')
    .attr('transform', 'translate('+conf[0]+', '+conf[1]+')')
    .selectAll('g')
    .data(colors.range())
    .enter()
    .append('g')
    .selectAll('path')
    .data(function (d) { return d3.range(0, rings); })
    .enter()
    .append('path')
    .attr("d", arc)
    .attr('fill', function (d, i, j) { return conf[2](d, j); });
});</pre></div><p>Wow! That's quite a bit of code.</p><p>We take two triplets, each defining the color wheel's position and which shader to use; then call a function that draws a shiny colorful circle with each.</p><p>For <a id="id166" class="indexterm"/>each circle, we append a <code class="literal">&lt;g&gt;</code> element and move it into position, and then<a id="id167" class="indexterm"/> use <code class="literal">colors.range()</code> to get a full list of colors and join it as data. For every new color, we create another <code class="literal">&lt;g&gt;</code> element and select all the <code class="literal">&lt;path&gt;</code> elements it contains.</p><p>Here things get magical. We join more data but just an array of numbers going from <code class="literal">0</code> to <code class="literal">rings</code> this time. For every element in this array, we append a <code class="literal">&lt;path&gt;</code> element and use the <code class="literal">arc</code> generator to define its shape. Finally we calculate the <code class="literal">fill</code> attribute with an appropriately shaded color.</p><p>The result looks as follows:</p><div class="mediaobject"><img src="images/0007_02_33.jpg" alt="Colors"/></div><p>Our main trick was that joining a second dimension of data retains the knowledge of the first dimension via the third attribute supplied to data accessors.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>Wow! We've gone through so much in this chapter.</p><p>You should now have a firm grasp of the basics that go into great visualizations. We've gone through DOM manipulation and looked at SVG in great detail, everything from drawing shapes manually to path generators. Finally we looked at CSS as a better alternative for making things pretty.</p><p>Everything we look at from now on is going to build on these basics, but you now have the tools to draw anything you can think of. The rest of this book just shows you more elegant ways of doing it.</p></div></div>
</body></html>