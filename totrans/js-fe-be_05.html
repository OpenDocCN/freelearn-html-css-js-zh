<html><head></head><body>
		<div><h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor072"/>Chapter 3</em>: Getting Started with Vue.js</h1>
			<p>The JavaScript world is constantly changing. In recent years, a new concept has emerged: that of developing applications by creating components.</p>
			<p>New JavaScript libraries for developing component-based apps have emerged, the main ones being Angular, React, Svelte, and <strong class="bold">Vue.js</strong>. Among all these libraries, which are quite similar to each other, we have chosen to present Vue.js to you because it is widely used and quite simple to implement. The other libraries mentioned operate according to the same principles.</p>
			<p class="callout-heading">Why Use Vue.js?</p>
			<p class="callout">The main advantage of Vue.js is the possibility of developing an application using components. We cut the web application into a set of components (actually JavaScript files) and then assemble them to form the final application. Vue.js can test each component independently of the others and can also reuse them in other applications.</p>
			<p>In this chapter, we will study how to build our first application with Vue.js, by creating and using our first component.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Using Vue.js in an HTML page</li>
				<li>Creating our first Vue.js application</li>
				<li>Using reactivity</li>
				<li>Creating our first component</li>
				<li>Adding methods in components</li>
				<li>Using attributes in components</li>
				<li>Using directives</li>
			</ul>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%203.zip">https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%203.zip</a>.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Using Vue.js in an HTML page</h1>
			<p>To use Vue.js in an HTML page, simply insert the library file into it using the <code>&lt;script&gt;</code> tag.</p>
			<p>To check that <a id="_idIndexMarker243"/>Vue.js is correctly integrated into the page, let’s <a id="_idIndexMarker244"/>display the version number of the library in the <code>Vue.version</code> variable:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying Vue.js version number (index.html file)</p>
			<pre class="source-code">&lt;html&gt;</pre>
			<pre class="source-code">  &lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="utf-8" /&gt;</pre>
			<pre class="source-code"><strong class="bold">    &lt;script src="img/vue@next"&gt;&lt;/script&gt;</strong></pre>
			<pre class="source-code">  &lt;/head&gt;</pre>
			<pre class="source-code">  &lt;body&gt;</pre>
			<pre class="source-code">  &lt;/body&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">  &lt;script&gt;</pre>
			<pre class="source-code"><strong class="bold">    alert(`Vue.version = ${Vue.version}`);</strong></pre>
			<pre class="source-code">  &lt;/script&gt;</pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>If Vue.js is accessible in the page, the <code>Vue</code> object provides access to the version number in its <code>version</code> property as we can see in the following figure:</p>
			<div><div><img src="img/Figure_3.1_B17416.jpg" alt="Figure 3.1 – Displaying the Vue.js version number&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Displaying the Vue.js version number</p>
			<p>Now that <a id="_idIndexMarker245"/>we have integrated Vue.js into our HTML page, let’s go <a id="_idIndexMarker246"/>about creating our first application.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Creating our first Vue.js application</h1>
			<p>Once Vue.js has been inserted into the HTML page, you must define the HTML elements of the page in which <a id="_idIndexMarker247"/>Vue.js will be used.</p>
			<p>In general, you want to use Vue.js on the whole HTML page, but it is possible to use it only on certain elements of the page as well. This would allow us, for example, to manage an HTML page with jQuery, except for a particular <code>&lt;div&gt;</code> element, which would be managed with Vue.js.</p>
			<p>To illustrate this, let us create an HTML page with two <code>&lt;div&gt;</code> elements, only the first of which will be managed by Vue.js:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating an HTML page partially managed by Vue.js</p>
			<pre class="source-code">&lt;html&gt;</pre>
			<pre class="source-code">  &lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="utf-8" /&gt;</pre>
			<pre class="source-code">    &lt;script src="img/vue@next"&gt;&lt;/script&gt;</pre>
			<pre class="source-code">  &lt;/head&gt;</pre>
			<pre class="source-code">  &lt;body&gt;</pre>
			<pre class="source-code"><strong class="bold">    &lt;div id="app"&gt;First div&lt;/div&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">    &lt;div&gt;The rest of the page is not managed by </strong></pre>
			<pre class="source-code"><strong class="bold">    Vue.js&lt;/div&gt;</strong></pre>
			<pre class="source-code">  &lt;/body&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">  &lt;script&gt;</pre>
			<pre class="source-code"> <strong class="bold">   var app = Vue.createApp({</strong></pre>
			<pre class="source-code"><strong class="bold">      template : "This div is managed with Vue.js"</strong></pre>
			<pre class="source-code"><strong class="bold">    });</strong></pre>
			<pre class="source-code"><strong class="bold">    // mount the Vue.js application on the &lt;div&gt; having the </strong></pre>
			<pre class="source-code"><strong class="bold">    // id "app"</strong></pre>
			<pre class="source-code"><strong class="bold">    var vm = app.mount("div#app");    </strong></pre>
			<pre class="source-code">&lt;/script&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>In the preceding code, we have used the <code>Vue.createApp(options)</code> method defined on the <code>Vue</code> object. The <code>options</code> object is used to set options for creating the Vue.js application. One of the options of <code>Vue.createApp(options)</code> is the <code>template</code> option, which allows us to define the view (that is to say the HTML display) that will be displayed on the page, thanks to the call of the <code>app.mount(element)</code> method:</p>
			<ul>
				<li>The <code>app</code> object is the one obtained as a result of the <code>Vue.createApp()</code> method call.</li>
				<li>The <code>element</code> parameter represents the HTML element on which Vue.js will act.</li>
			</ul>
			<p>Let’s run the <a id="_idIndexMarker248"/>previous program; we should see the following output:</p>
			<div><div><img src="img/Figure_3.2_B17416.jpg" alt="Figure 3.2 – First Vue.js app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – First Vue.js app</p>
			<p>On the preceding screen, we can see the result of using Vue.js on the page. The content of the first <code>&lt;div&gt;</code> is replaced by the template written in the <code>options</code> parameter of the <code>Vue.createApp(options)</code> method. The second <code>&lt;div&gt;</code> is not transformed.</p>
			<p>Thus, to manage an entire HTML page with Vue.js, just indicate in the <code>&lt;body&gt;</code> part of the page a single <code>&lt;div&gt;</code> element, which will be the one on which Vue.js will be activated.</p>
			<p>Now let’s see how to use an important concept of Vue.js, which is the correspondence between the variables defined in the program and their display on the HTML page. This concept is called reactivity.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Using reactivity</h1>
			<p>One of the objectives of Vue.js is to separate the management of the display (the <strong class="bold">view</strong>) and that of the data (the <strong class="bold">model</strong>). This is the concept that is frequently found in what is called <a id="_idIndexMarker249"/>the <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) model.</p>
			<p>To illustrate, suppose we <a id="_idIndexMarker250"/>want to display a counter that increments from 0. A good separation of view and model would be for the view to constantly display the value of the counter, even if that value is changed elsewhere. This concept makes it possible not to link the display with the management of the data displayed. For this, we <a id="_idIndexMarker251"/>use the reactivity offered by Vue.js, by creating so-called <strong class="bold">reactive variables</strong>.</p>
			<p class="callout-heading">Reactive Variables</p>
			<p class="callout">A variable will be said to be reactive if its modification in memory causes it to be modified automatically wherever the variable is displayed.</p>
			<p>Reactive variables are defined in the <code>options</code> object of the <code>Vue.createApp(options)</code> method. For this, we add in the <code>options</code> object, and the definition of the <code>data()</code> method, which will have to return an object containing the so-called reactive variables of the application.</p>
			<p>Let’s use a reactive variable named <code>count</code> in our Vue.js application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Defining a count reactive variable</p>
			<pre class="source-code">&lt;html&gt;</pre>
			<pre class="source-code">  &lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="utf-8" /&gt;</pre>
			<pre class="source-code">    &lt;script src="img/vue@next"&gt;&lt;/script&gt;</pre>
			<pre class="source-code">  &lt;/head&gt;</pre>
			<pre class="source-code">  &lt;body&gt;</pre>
			<pre class="source-code">    &lt;div id="app"&gt;&lt;/div&gt;</pre>
			<pre class="source-code">  &lt;/body&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">  &lt;script&gt;</pre>
			<pre class="source-code">    var app = Vue.createApp({</pre>
			<pre class="source-code"><strong class="bold">      template : "The counter is: {{count}}",</strong></pre>
			<pre class="source-code"><strong class="bold">      data() {</strong></pre>
			<pre class="source-code"><strong class="bold">        // return an object containing the reactive </strong></pre>
			<pre class="source-code"><strong class="bold">        // variables</strong></pre>
			<pre class="source-code"><strong class="bold">        return {</strong></pre>
			<pre class="source-code"><strong class="bold">          count : 0</strong></pre>
			<pre class="source-code"><strong class="bold">        }</strong></pre>
			<pre class="source-code"><strong class="bold">      }</strong></pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">    var vm = app.mount("div#app");</pre>
			<pre class="source-code">&lt;/script&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>In the preceding code, the <code>count</code> reactive variable is defined in the <code>data()</code> method, which returns the <code>{ count : 0 }</code> object containing the program’s reactive variable. Other variables can be defined afterward.</p>
			<p>This reactive variable can then be used in the template by means of the notation with <code>{{ and }}</code>. This notation is used to indicate a JavaScript expression, such as the value of a variable.</p>
			<p>The definition of <a id="_idIndexMarker252"/>a so-called reactive variable makes it possible to link the display to the value of the variable. As soon as the variable is modified, the display is also modified. We can see the counter value in the following figure:</p>
			<div><div><img src="img/Figure_3.3_B17416.jpg" alt="Figure 3.3 – Displaying a reactive variable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Displaying a reactive variable</p>
			<p>The counter remains positioned at its initial value: <code>count</code> variable is modified.</p>
			<p>To do this, let’s increment the value of the variable every second as shown in the following code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Incrementing count variable every second</p>
			<pre class="source-code">&lt;html&gt;</pre>
			<pre class="source-code">  &lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="utf-8" /&gt;</pre>
			<pre class="source-code">    &lt;script src="img/vue@next"&gt;&lt;/script&gt;</pre>
			<pre class="source-code">  &lt;/head&gt;</pre>
			<pre class="source-code">  &lt;body&gt;</pre>
			<pre class="source-code">    &lt;div id="app"&gt;&lt;/div&gt;</pre>
			<pre class="source-code">  &lt;/body&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">  &lt;script&gt;</pre>
			<pre class="source-code">    var app = Vue.createApp({</pre>
			<pre class="source-code">      template : "The counter is: {{count}}",</pre>
			<pre class="source-code">      data() {</pre>
			<pre class="source-code">        // return an object containing the reactive </pre>
			<pre class="source-code">        // variables</pre>
			<pre class="source-code">        return {</pre>
			<pre class="source-code">          count : 0</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">    var vm = app.mount("div#app");</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code"><strong class="bold">    setInterval(function() {</strong></pre>
			<pre class="source-code"><strong class="bold">      vm.count += 1;</strong></pre>
			<pre class="source-code"><strong class="bold">    }, 1000);</strong></pre>
			<pre class="source-code">&lt;/script&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>Using JavaScript’s <code>setInterval()</code> function, we increment the value of the <code>count</code> variable every second. Vue.js provides access to the <code>count</code> variable using <code>vm.count</code>, where <code>vm</code> is the object returned by the <code>app.mount()</code> method. Reactive variables become properties of this <code>vm</code> object. In the preceding code, we can see the separation of view and data processing, as advocated by the MVC pattern. The incrementation of the variable is done outside the view, which would not have been possible with a library such as jQuery.</p>
			<p>We can see <a id="_idIndexMarker253"/>the incrementation and the automatic update of the display, thanks to the reactivity offered by Vue.js, as evident in the following figure</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_3.4_B17416.jpg" alt="Figure 3.4 – Incrementing a reactive variable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Incrementing a reactive variable</p>
			<p>The previous program is very simple, but in reality, applications are of course more complex. As such, it is necessary to break down an application into small pieces, which will then be assembled. Now let’s learn how to write one of the small pieces of an application, called a component.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Creating our first component</h1>
			<p>Let’s see <a id="_idIndexMarker254"/>how to use Vue.js to create our own components. </p>
			<p>A Vue.js component will be similar to a new HTML element. It will be used in the form of HTML tags to which new attributes can be associated if necessary. To use the component, all you have to do is use the corresponding tag.</p>
			<p>The components are therefore a means of enriching the HTML code by creating our own tags.</p>
			<p class="callout-heading">How to Discover the Components to Use to Build Our Application</p>
			<p class="callout">All you have to do is visually cut the HTML page you want to display into the simplest possible elements (which will be the basic components of your application), then group several elements together to form a component that will group them, and so on until you have the main component, which will be your complete application.</p>
			<p>For example, if a list of elements is displayed on the HTML page, each element’s line of the list corresponds <a id="_idIndexMarker255"/>to a basic component, while the global list that groups these different components will be associated with another component. The set of all components of the HTML page corresponds to the main component, often named <code>&lt;App&gt;</code> or <code>&lt;GlobalApp&gt;</code>. Let’s see how to create and use the <code>&lt;counter&gt;</code> component corresponding to the previous counter by first learning how to insert the component.</p>
			<p>You can create the component directly into the HTML page or include it from an external file. Let’s look at these two ways to do it.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Inserting a component in the application file</h2>
			<p>A component <a id="_idIndexMarker256"/>can simply be embedded in the main application Vue.js file. Just use the <code>app.component(name, options)</code> method to create it as follows. The variable <code>app</code> corresponds to the object returned by <code>Vue.createApp()</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating the &lt;counter&gt; component directly in the application</p>
			<pre class="source-code">&lt;html&gt;</pre>
			<pre class="source-code">  &lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="utf-8" /&gt;</pre>
			<pre class="source-code">    &lt;script src="img/vue@next"&gt;&lt;/script&gt;</pre>
			<pre class="source-code">  &lt;/head&gt;</pre>
			<pre class="source-code">  &lt;body&gt;</pre>
			<pre class="source-code">    &lt;div id="app"&gt;&lt;/div&gt;</pre>
			<pre class="source-code">  &lt;/body&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">  &lt;script&gt;</pre>
			<pre class="source-code">    var app = Vue.createApp({</pre>
			<pre class="source-code">  <strong class="bold">    template : "&lt;counter /&gt;"</strong></pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">  <strong class="bold">  app.component("counter", {</strong></pre>
			<pre class="source-code"><strong class="bold">      template : "The counter is: {{count}}",</strong></pre>
			<pre class="source-code"><strong class="bold">      data() {</strong></pre>
			<pre class="source-code"><strong class="bold">        return {</strong></pre>
			<pre class="source-code"><strong class="bold">          count : 0</strong></pre>
			<pre class="source-code"><strong class="bold">        }</strong></pre>
			<pre class="source-code"><strong class="bold">      }</strong></pre>
			<pre class="source-code"><strong class="bold">    });</strong></pre>
			<pre class="source-code">    var vm = app.mount("div#app");</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">&lt;/script&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>In the preceding code, the variable <code>app</code> corresponds to the object returned by <code>Vue.createApp()</code>. </p>
			<p>The <code>app.component(name, options)</code> method works on the same principle as <code>Vue.createApp(options)</code>:</p>
			<ul>
				<li>The <code>name</code> parameter corresponds to the name of the component, which will then be used as tags in HTML templates.</li>
				<li>The <code>options</code> parameter is similar in both cases. There is the <code>template</code> section, <code>data</code>, and so on.</li>
			</ul>
			<p>The <code>&lt;counter&gt;</code> component can then be used in other templates, including the one defined <a id="_idIndexMarker257"/>for the application. When you run the preceding code, you will see the following screen:</p>
			<div><div><img src="img/Figure_3.5_B17416.jpg" alt="Figure 3.5 – The &lt;counter&gt; component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – The &lt;counter&gt; component</p>
			<p>As we can see in the preceding figure, for the moment, the counter remains at <code>0</code>. To increment the reactive variable <code>count</code> in the component, it is necessary to be able to write the instruction of incrementation once the component is created. For this, Vue.js provides internal methods allowing access to the life cycle of each component created.</p>
			<p>One of the methods of a component’s life cycle is the <code>created()</code> method. It is called when the component is created. You can use this method to write the increment of the variable <code>count</code> every second, using the <code>setInterval()</code> function.</p>
			<p>Let’s use <a id="_idIndexMarker258"/>the component’s <code>created()</code> method as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the component’s created() method</p>
			<pre class="source-code">&lt;html&gt;</pre>
			<pre class="source-code">  &lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="utf-8" /&gt;</pre>
			<pre class="source-code">    &lt;script src="img/vue@next"&gt;&lt;/script&gt;</pre>
			<pre class="source-code">  &lt;/head&gt;</pre>
			<pre class="source-code">  &lt;body&gt;</pre>
			<pre class="source-code">    &lt;div id="app"&gt;&lt;/div&gt;</pre>
			<pre class="source-code">  &lt;/body&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">  &lt;script&gt;</pre>
			<pre class="source-code">    var app = Vue.createApp({</pre>
			<pre class="source-code">      template : "&lt;counter /&gt;"</pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    app.component("counter", {</pre>
			<pre class="source-code">      template : "The counter is: {{count}}",</pre>
			<pre class="source-code">      data() {</pre>
			<pre class="source-code">        return {</pre>
			<pre class="source-code">          count : 0</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">      },</pre>
			<pre class="source-code">    <strong class="bold">  created() {</strong></pre>
			<pre class="source-code"><strong class="bold">        setInterval(()=&gt;{  // do not use the function()</strong></pre>
			<pre class="source-code"><strong class="bold">                           // form here,</strong></pre>
			<pre class="source-code"><strong class="bold">                           // otherwise the "this" object</strong></pre>
			<pre class="source-code"><strong class="bold">                           // would not be the same</strong></pre>
			<pre class="source-code"><strong class="bold">          this.count++;</strong></pre>
			<pre class="source-code"><strong class="bold">        }, 1000);</strong></pre>
			<pre class="source-code"><strong class="bold">      }</strong></pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">    var vm = app.mount("div#app");</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">  &lt;/script&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>In the <a id="_idIndexMarker259"/>preceding code, we have used the notation <code>()=&gt;</code> instead of <code>function()</code>. This notation (called a lambda function) was introduced in <a id="_idIndexMarker260"/>the latest versions of JavaScript in order to allow the value of <code>this</code> to be kept inside callback functions, which is necessary here. If you replace the lambda function <code>()=&gt;</code> with the <code>function()</code> keyword, the program won’t work, as the <code>this</code> value won’t be the same.</p>
			<p>On running the preceding code, you will see the following output:</p>
			<div><div><img src="img/Figure_3.6_B17416.jpg" alt="Figure 3.6 – Incrementing the counter in the component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Incrementing the counter in the component</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Inserting a component from an external file</h2>
			<p>Rather than defining the component directly in the HTML page, it is preferable to define it in an <a id="_idIndexMarker261"/>external file. The component can be used in the HTML page thanks to the inclusion of the external file in the HTML page. For this, we use the concept of modules provided by JavaScript.</p>
			<p class="callout-heading">The Advantage of Components Defined in an External File</p>
			<p class="callout">The advantage of defining the component in an external file is to be able to include this file in several different HTML pages, and therefore to use the component in several different applications.</p>
			<p>The <code>&lt;counter&gt;</code> component is defined in an external <code>counter.js</code> file as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">&lt;counter&gt; component definition (counter.js file)</p>
			<pre class="source-code">const Counter = {</pre>
			<pre class="source-code">  data() {</pre>
			<pre class="source-code">    return {</pre>
			<pre class="source-code">      count: 0</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  template : "The counter is: {{count}}",</pre>
			<pre class="source-code">  created() {</pre>
			<pre class="source-code">    setInterval(() =&gt; {</pre>
			<pre class="source-code">      this.count += 1;</pre>
			<pre class="source-code">    }, 1000)</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">export default Counter;</strong></pre>
			<p>The <code>&lt;counter&gt;</code> component is defined as an object, having <code>template</code>, <code>data</code>, and <code>created</code> properties. Its <a id="_idIndexMarker262"/>definition is similar to the one shown previously in the <code>app.component()</code> method.</p>
			<p>The <code>export default Counter</code> instruction makes the component accessible in the other files where this module is imported.</p>
			<p>The <code>&lt;counter&gt;</code> component can now be integrated into the main file of our application. We use the JavaScript <code>import</code> statement for this. The code will look as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Importing the component into the program (index.html file)</p>
			<pre class="source-code">&lt;html&gt;</pre>
			<pre class="source-code">  &lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="utf-8" /&gt;</pre>
			<pre class="source-code">    &lt;script src="img/vue@next"&gt;&lt;/script&gt;</pre>
			<pre class="source-code">  &lt;/head&gt;</pre>
			<pre class="source-code">  &lt;body&gt;</pre>
			<pre class="source-code">    &lt;div id="app"&gt;&lt;/div&gt;</pre>
			<pre class="source-code">  &lt;/body&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code"><strong class="bold">  &lt;script type="module"&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">  </strong></pre>
			<pre class="source-code"><strong class="bold">    import Counter from "./counter.js";</strong></pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    var app = Vue.createApp({</pre>
			<pre class="source-code">  <strong class="bold">    components : {</strong></pre>
			<pre class="source-code"><strong class="bold">        Counter:Counter</strong></pre>
			<pre class="source-code"><strong class="bold">      },</strong></pre>
			<pre class="source-code">      template : "&lt;counter /&gt;"   // or "&lt;Counter /&gt;"</pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    var vm = app.mount("div#app");</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">  &lt;/script&gt;</pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>In the <a id="_idIndexMarker263"/>preceding code, to import the <code>counter.js</code> file and use the corresponding component, the following takes place:</p>
			<ul>
				<li>The <code>type="module"</code> attribute is indicated in the <code>&lt;script&gt;</code> tag. This allows the use of the <code>import</code> statement in the JavaScript statements of the <code>&lt;script&gt;</code> tag.</li>
				<li>We use the <code>import</code> statement to import the corresponding module.</li>
				<li>We declare the imported components in the new <code>components</code> section. Components are declared as an object. The names of the properties in this object correspond to the name used by the component in the templates (<code>&lt;counter&gt;</code> or <code>&lt;Counter&gt;</code>), while the values correspond to the name of the imported component (<code>Counter</code>).<p class="callout-heading">Using HTTP Instead of the FILE Protocol</p><p class="callout">However, as we use the import of JavaScript modules, it is necessary to run our application on an HTTP server, and no longer with a simple drag and drop as before. Hence the use of the URL that begins with <code>http://localhost</code>. If you need to know how to install an HTTP server, you can, for example, use the documentation here: <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server">https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server</a>.</p></li>
			</ul>
			<p>In the <a id="_idIndexMarker264"/>following figure, we can see that creating a component directly in the HTML page or in an external file produces the same result:</p>
			<div><div><img src="img/Figure_3.7_B17416.jpg" alt="Figure 3.7 – Execution of the HTML file on an HTTP server (here, localhost)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Execution of the HTML file on an HTTP server (here, localhost)</p>
			<p>The current component only has a simple reactive variable. It is possible, in a component, to add methods to it that will be used in the component. Now let’s take a look at how to do it.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Adding methods in components</h1>
			<p>We have seen how to create reactive variables in a component, using the <code>data</code> section of the <a id="_idIndexMarker265"/>component. It is also possible to create methods in a component that can be used in the component template.</p>
			<p>There are two ways to add methods to a component:</p>
			<ul>
				<li>The first is to define the method in the <code>methods</code> section of the component.</li>
				<li>The second is to create a so-called computed property that will be defined in the <code>computed</code> section of the component.</li>
			</ul>
			<p>Let’s look at these two ways to do it.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Defining methods in the methods section</h2>
			<p>For each incrementation of the counter, it should be necessary to display the time at which <a id="_idIndexMarker266"/>it occurs. A <code>time()</code> function <a id="_idIndexMarker267"/>would be very useful in the component, allowing <a id="_idIndexMarker268"/>us to display the time in the form HH:MM:SS. This <code>time()</code> function will be defined in the <code>methods</code> section of the component.</p>
			<p>The <code>&lt;counter&gt;</code> component is modified to integrate the display of the time at the beginning of the line. We can achieve all this using the following code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">&lt;counter&gt; component displaying time (counter.js file)</p>
			<pre class="source-code">const Counter = {</pre>
			<pre class="source-code">  data() {</pre>
			<pre class="source-code">    return {</pre>
			<pre class="source-code">      count: 0</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  <strong class="bold">template : `{{time()}} &amp;nbsp;&amp;nbsp; The counter is: </strong></pre>
			<pre class="source-code"><strong class="bold">  {{count}}`,</strong></pre>
			<pre class="source-code">  created() {</pre>
			<pre class="source-code">    setInterval(() =&gt; {</pre>
			<pre class="source-code">      this.count += 1;</pre>
			<pre class="source-code">    }, 1000)</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code"> <strong class="bold"> methods : {</strong></pre>
			<pre class="source-code"><strong class="bold">    time() {</strong></pre>
			<pre class="source-code"><strong class="bold">     // return time as HH:MM:SS</strong></pre>
			<pre class="source-code"><strong class="bold">     var date = new Date();</strong></pre>
			<pre class="source-code"><strong class="bold">     var hour = date.getHours();</strong></pre>
			<pre class="source-code"><strong class="bold">     var min = date.getMinutes();</strong></pre>
			<pre class="source-code"><strong class="bold">     var sec = date.getSeconds();</strong></pre>
			<pre class="source-code"><strong class="bold">     if (hour &lt; 10) hour = "0" + hour;</strong></pre>
			<pre class="source-code"><strong class="bold">     if (min &lt; 10) min = "0" + min;</strong></pre>
			<pre class="source-code"><strong class="bold">     if (sec &lt; 10) sec = "0" + sec;</strong></pre>
			<pre class="source-code"><strong class="bold">     return "" + hour + ":" + min + ":" + sec + " ";</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code"><strong class="bold">  }</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">export default Counter;</pre>
			<p>In the <a id="_idIndexMarker269"/>preceding code, the <code>time()</code> method <a id="_idIndexMarker270"/>is defined in the <code>methods</code> section and <a id="_idIndexMarker271"/>is then directly used in the component template within the double braces <code>{{ and }}</code>.</p>
			<p>A method defined in the <code>methods</code> section can use the other methods of this section or the reactive variables of the <code>data</code> section by prefixing them with the <code>this</code> keyword.</p>
			<p>The result is displayed in the following figure:</p>
			<div><div><img src="img/Figure_3.8_B17416.jpg" alt="Figure 3.8 – Time display in the component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Time display in the component</p>
			<p>Vue.js <a id="_idIndexMarker272"/>allows you to define, in the <a id="_idIndexMarker273"/>form of <a id="_idIndexMarker274"/>methods, new <a id="_idIndexMarker275"/>variables that will be reactive. They are called computed properties. Let’s see how to create and use them.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Defining computed properties in the computed section</h2>
			<p>A computed property is similar to a reactive variable. It is the result of the calculation performed <a id="_idIndexMarker276"/>on one or <a id="_idIndexMarker277"/>more reactive variables, and it will <a id="_idIndexMarker278"/>also be reactive. Any modification to one of the reactive variables associated with this computed property will cause it to be modified immediately.</p>
			<p>Let’s create a <code>countX2</code> property that calculates double the <code>count</code> variable as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Defining a computed property countX2 in the component (counter.js file)</p>
			<pre class="source-code">const Counter = {</pre>
			<pre class="source-code">  data() {</pre>
			<pre class="source-code">    return {</pre>
			<pre class="source-code">      count: 0</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code"> <strong class="bold"> template : `{{time()}} &amp;nbsp;&amp;nbsp; The counter is: </strong></pre>
			<pre class="source-code"><strong class="bold">  {{count}}, double is: {{countX2}}`,</strong></pre>
			<pre class="source-code">  created() {</pre>
			<pre class="source-code">    setInterval(() =&gt; {</pre>
			<pre class="source-code">      this.count += 1;</pre>
			<pre class="source-code">    }, 1000)</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  methods : {</pre>
			<pre class="source-code">    time() {</pre>
			<pre class="source-code">     // return time as HH:MM:SS</pre>
			<pre class="source-code">     var date = new Date();</pre>
			<pre class="source-code">     var hour = date.getHours();</pre>
			<pre class="source-code">     var min = date.getMinutes();</pre>
			<pre class="source-code">     var sec = date.getSeconds();</pre>
			<pre class="source-code">     if (hour &lt; 10) hour = "0" + hour;</pre>
			<pre class="source-code">     if (min &lt; 10) min = "0" + min;</pre>
			<pre class="source-code">     if (sec &lt; 10) sec = "0" + sec;</pre>
			<pre class="source-code">     return "" + hour + ":" + min + ":" + sec + " ";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code"><strong class="bold">  computed : {</strong></pre>
			<pre class="source-code"><strong class="bold">    countX2() {</strong></pre>
			<pre class="source-code"><strong class="bold">      return 2 * this.count;</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code"><strong class="bold">  }</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">export default Counter;</pre>
			<p>The output of the preceding code will look as follows:</p>
			<div><div><img src="img/Figure_3.9_B17416.jpg" alt="Figure 3.9 – Using a computed property&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Using a computed property</p>
			<p>In the <a id="_idIndexMarker279"/>preceding figure, we <a id="_idIndexMarker280"/>can see the modification <a id="_idIndexMarker281"/>of the <code>count</code> variable. Every second leads to the automatic modification of the <code>countX2</code> variable thanks to its definition in the <code>computed</code> section.</p>
			<p>We have seen how to define methods and reactive variables in a component. Now let’s see how to pass parameters to a component, using the component’s attributes for this.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Using attributes in components</h1>
			<p>Attributes in <a id="_idIndexMarker282"/>a component allow it to pass parameters <a id="_idIndexMarker283"/>for its use. For example, we could use in the <code>&lt;counter&gt;</code> component a <code>start</code> attribute indicating at what value we start counting. If this attribute is not indicated, it is considered to be 0 (that is, counting starts at 0 as in the preceding code example).</p>
			<p>For a component to be able to employ attributes during its use, it suffices to indicate the name of the <a id="_idIndexMarker284"/>attributes in the <code>props</code> section of the component. The component <a id="_idIndexMarker285"/>can access the attribute value using the <code>this</code> keyword (for example, <code>this.start</code> to access the <code>start</code> attribute in the component). We can see this in action in the following code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the start attribute in the component (index.html file)</p>
			<pre class="source-code">&lt;html&gt;</pre>
			<pre class="source-code">  &lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="utf-8" /&gt;</pre>
			<pre class="source-code">    &lt;script src="img/vue@next"&gt;&lt;/script&gt;</pre>
			<pre class="source-code">  &lt;/head&gt;</pre>
			<pre class="source-code">  &lt;body&gt;</pre>
			<pre class="source-code">    &lt;div id="app"&gt;&lt;/div&gt;</pre>
			<pre class="source-code">  &lt;/body&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">  &lt;script type="module"&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">    import Counter from "./counter.js";</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    var app = Vue.createApp({</pre>
			<pre class="source-code">      components : {</pre>
			<pre class="source-code">        Counter:Counter</pre>
			<pre class="source-code">      },</pre>
			<pre class="source-code">    <strong class="bold">  template : "&lt;counter start='10' /&gt;"</strong></pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    var vm = app.mount("div#app");</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">  &lt;/script&gt;</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>In the following code, the attribute is passed when using the component, as is traditionally <a id="_idIndexMarker286"/>done in HTML. The value of the attribute here <a id="_idIndexMarker287"/>will be a character string <code>"10"</code> and not the value <code>10</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Setting the start attribute in the &lt;counter&gt; component (counter.js file)</p>
			<pre class="source-code">const Counter = {</pre>
			<pre class="source-code">  data() {</pre>
			<pre class="source-code">    return {</pre>
			<pre class="source-code">      <strong class="bold">count : parseInt(this.start),  // we initialize the</strong></pre>
			<pre class="source-code"><strong class="bold">                                     // count to the value</strong></pre>
			<pre class="source-code"><strong class="bold">                                     // of start</strong></pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  template : `{{time()}} &amp;nbsp;&amp;nbsp; The counter is: </pre>
			<pre class="source-code">  {{count}}, double is: {{countX2}}`,</pre>
			<pre class="source-code">  created() {</pre>
			<pre class="source-code">    var timer = setInterval(() =&gt; {</pre>
			<pre class="source-code">      this.count += 1;</pre>
			<pre class="source-code">    }, 1000)</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  methods : {</pre>
			<pre class="source-code">    time() {</pre>
			<pre class="source-code">     // return time as HH:MM:SS</pre>
			<pre class="source-code">     var date = new Date();</pre>
			<pre class="source-code">     var hour = date.getHours();</pre>
			<pre class="source-code">     var min = date.getMinutes();</pre>
			<pre class="source-code">     var sec = date.getSeconds();</pre>
			<pre class="source-code">     if (hour &lt; 10) hour = "0" + hour;</pre>
			<pre class="source-code">     if (min &lt; 10) min = "0" + min;</pre>
			<pre class="source-code">     if (sec &lt; 10) sec = "0" + sec;</pre>
			<pre class="source-code">     return "" + hour + ":" + min + ":" + sec + " ";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  computed : {</pre>
			<pre class="source-code">    countX2() {</pre>
			<pre class="source-code">      return 2 * this.count;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code"><strong class="bold">  props : [</strong></pre>
			<pre class="source-code"><strong class="bold">    "start"</strong></pre>
			<pre class="source-code"><strong class="bold">  ]</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">export default Counter;</pre>
			<p>In the preceding code, notice the use of the <code>parseInt()</code> function (defined as standard in JavaScript) to retrieve the value of <code>this.start</code> in integer form. Indeed, the attributes are transmitted in the form of character strings, hence the need to transform <code>this.start</code> into an integer value.</p>
			<p>It is possible to avoid transforming the attribute value into an integer value. All you have to do is indicate <a id="_idIndexMarker288"/>when using the attribute that you want to <a id="_idIndexMarker289"/>keep the JavaScript value and not the character string. We prefix the name of the attribute with the character <code>:</code>, for example, <code>:start='10'</code>. In this case, the value <code>10</code> will be transmitted and not the string <code>"10"</code>.</p>
			<p>This makes it possible to be able to transmit in the attributes any types of values: numeric values, character strings, arrays, or objects.</p>
			<p>In the following figure we can see the counter has started from the value indicated in the <code>start</code> attribute:</p>
			<div><div><img src="img/Figure_3.10_B17416.jpg" alt="Figure 3.10 – Using the start attribute in the component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Using the start attribute in the component</p>
			<p>We have therefore seen how to create new attributes in a component. Vue.js has specific attributes as standard, which can be used in all components. These specific attributes, created by Vue.js, are <a id="_idIndexMarker290"/>called directives. We will study them now.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Using directives</h1>
			<p>Vue.js improves the writing of HTML code by offering to write its own components, as we have seen <a id="_idIndexMarker291"/>in the preceding section. The framework also makes it easier to write basic HTML code by adding new attributes to the HTML elements or to the components created. These new attributes are called directives.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Directives are used exclusively in HTML elements or created components, that is, in the <code>template</code> section of components.</p>
			<p>Their name begins with <code>v-</code>, so as not to be confused with other existing HTML attributes. The main directives are <code>v-if</code>, <code>v-else</code>, <code>v-show</code>, <code>v-for</code>, and <code>v-model</code>. They will be explained now.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>The v-if and v-else directives</h2>
			<p>The <code>v-if</code> directive is <a id="_idIndexMarker292"/>used to specify a condition. If true, the HTML <a id="_idIndexMarker293"/>element (or component) will be inserted into the HTML page. Otherwise, it will not be present.</p>
			<p>Let’s use the <code>v-if</code> directive to indicate that we want to display the value of the counter only for <a id="_idIndexMarker294"/>values less than or equal to 20. As soon as the value 20 is exceeded, the <a id="_idIndexMarker295"/>counter is no longer displayed.</p>
			<p>In the following snippet, we have only indicated the code of the <code>template</code> section of the component, knowing that the rest is not modified:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the v-if directive</p>
			<pre class="source-code">template : `</pre>
			<pre class="source-code">  {{time()}} &amp;nbsp;&amp;nbsp;</pre>
			<pre class="source-code">  <strong class="bold">&lt;span v-if='count&lt;=20'&gt;The counter is: {{count}}&lt;/span&gt;</strong></pre>
			<pre class="source-code">`,</pre>
			<p>Using backticks <code>'</code> and <code>'</code> to define the template avoids having to manage the concatenation of character strings on several lines.</p>
			<p>The <code>&lt;span&gt;</code> element on which the <code>v-if</code> directive is applied will be included in the HTML page only if the following condition is true: if <code>count&lt;=20</code>. Beyond 20, only the time will <a id="_idIndexMarker296"/>be displayed without the counter value.</p>
			<p>As long <a id="_idIndexMarker297"/>as the counter <a id="_idIndexMarker298"/>is less than or equal to 20, it is <a id="_idIndexMarker299"/>displayed as follows:</p>
			<div><div><img src="img/Figure_3.11_B17416.jpg" alt="Figure 3.11 – Display of the counter whose value is less than 20&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Display of the counter whose value is less than 20</p>
			<p>When the counter exceeds the value 20, it is no longer displayed:</p>
			<div><div><img src="img/Figure_3.12_B17416.jpg" alt="Figure 3.12 – Display as soon as the counter exceeds the value 20&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Display as soon as the counter exceeds the value 20</p>
			<p>The <code>v-else</code> directive is used to indicate an alternative when the condition expressed in <code>v-if</code> is <code>false</code>. The element on which the <code>v-else</code> directive is used will be inserted into the HTML page if the condition expressed in <code>v-if</code> is <code>false</code>.</p>
			<p>Let’s <a id="_idIndexMarker300"/>use the <code>v-else</code> directive to display another message <a id="_idIndexMarker301"/>when the counter exceeds the value 20:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the v-else directive</p>
			<pre class="source-code">template : `</pre>
			<pre class="source-code">  {{time()}} &amp;nbsp;&amp;nbsp;</pre>
			<pre class="source-code">  &lt;span v-if='count&lt;=20'&gt;The counter is: {{count}}&lt;/span&gt;</pre>
			<pre class="source-code">  <strong class="bold">&lt;span v-else&gt;The counter has exceeded 20, it is: </strong></pre>
			<pre class="source-code"><strong class="bold">  {{count}}&lt;/span&gt;</strong></pre>
			<pre class="source-code">`,</pre>
			<p>When <a id="_idIndexMarker302"/>the counter <a id="_idIndexMarker303"/>exceeds the value 20, we now get the following:</p>
			<div><div><img src="img/Figure_3.13_B17416.jpg" alt="Figure 3.13 – Counter having exceeded the value 20&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Counter having exceeded the value 20</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>The v-show directive</h2>
			<p>The <code>v-show</code> directive <a id="_idIndexMarker304"/>is similar to the <code>v-if</code> directive. A condition is <a id="_idIndexMarker305"/>given next. If the condition is <code>true</code>, the element that uses the directive is displayed; otherwise, it is not.</p>
			<p>The difference from the <code>v-if</code> directive is that the element, if not displayed, is only hidden, but it is still inserted into the page. Whereas with the <code>v-if</code> directive, the element is not inserted (if the condition is <code>false</code>).</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>The v-for directive</h2>
			<p>The <code>v-for</code> directive <a id="_idIndexMarker306"/>allows you to loop over a set of elements or <a id="_idIndexMarker307"/>over the properties of an object. For each iteration of the loop, it inserts the HTML element on which the directive is positioned.</p>
			<p>Let us assume the <code>&lt;counter&gt;</code> component is a set of counters associated with the variable <code>counts</code>, which is a JavaScript array. Each counter is, in our example, a character string (for example, <code>"Counter 1"</code>), and we want to display the whole in the form of a list (see the following code snippets).</p>
			<p>Let’s look at the two possible forms of the <code>v-for</code> directive.</p>
			<h3>Using the directive v-for=”count in counts”</h3>
			<p>Let’s use <a id="_idIndexMarker308"/>the first form of the <code>v-for</code> directive. It allows access to each element of the array indicated in the directive (in our example, the JavaScript <code>counts</code> array):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying counters as a list (counter.js file)</p>
			<pre class="source-code">const Counter = {</pre>
			<pre class="source-code">  data() {</pre>
			<pre class="source-code">    return {</pre>
			<pre class="source-code">      counts : ["Counter 1", "Counter 2", "Counter 3", </pre>
			<pre class="source-code">      "Counter 4", "Counter 5"]</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  template : `</pre>
			<pre class="source-code">    &lt;ul&gt;</pre>
			<pre class="source-code">      <strong class="bold">&lt;li v-for="count in counts"&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">        &lt;span&gt;{{count}}&lt;/span&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">      &lt;/li&gt;</strong></pre>
			<pre class="source-code">    &lt;/ul&gt;</pre>
			<pre class="source-code">  `,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">export default Counter;</pre>
			<p>In the <a id="_idIndexMarker309"/>preceding code, we have positioned the <code>v-for</code> directive on the element that we want to repeat (in this case, the <code>&lt;li&gt;</code> element). The value associated with the <code>v-for</code> directive is a character string of the form <code>"count in counts"</code>, knowing that <code>counts</code> is the variable on which we are iterating. The <code>count</code> variable thus corresponds to each of the elements of the <code>counts</code> array:</p>
			<div><div><img src="img/Figure_3.14_B17416.jpg" alt="Figure 3.14 – Using the v-for directive&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Using the v-for directive</p>
			<h3>Using the directive v-for=”(count, index) in counts”</h3>
			<p>A second <a id="_idIndexMarker310"/>form of the <code>v-for</code> directive gives access to each element of the array as before, but also to its index (starting from 0):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying counters and their index (counter.js file)</p>
			<pre class="source-code">const Counter = {</pre>
			<pre class="source-code">  data() {</pre>
			<pre class="source-code">    return {</pre>
			<pre class="source-code">      counts : ["Counter 1", "Counter 2", "Counter 3", </pre>
			<pre class="source-code">      "Counter 4", "Counter 5"]</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  template : `</pre>
			<pre class="source-code">    &lt;ul&gt;</pre>
			<pre class="source-code">      <strong class="bold">&lt;li v-for="(count, index) in counts"&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">        &lt;span&gt;Index {{index}} : {{count}}&lt;/span&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">      &lt;/li&gt;</strong></pre>
			<pre class="source-code">    &lt;/ul&gt;</pre>
			<pre class="source-code">  `,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">export default Counter;</pre>
			<p>On running <a id="_idIndexMarker311"/>the preceding code, the following is displayed:</p>
			<div><div><img src="img/Figure_3.15_B17416.jpg" alt="Figure 3.15 – Using index in the v-for directive&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Using index in the v-for directive</p>
			<h3>Using the key attribute with the v-for directive</h3>
			<p>The <code>v-for</code> directive <a id="_idIndexMarker312"/>can also be used to display large lists, for which reactivity must be maintained. That is, changing the reactive variable specified in the <code>v-for</code> directive should update the corresponding displayed list.</p>
			<p>To perform the update as quickly as possible, Vue.js uses a special attribute (to be used only for this specific case) named <code>key</code>. This attribute can be positioned after the <code>v-for</code> directive. Its value must be unique for each item in the list. For example, the value of the index being unique for each list element can be used as a value in the <code>key</code> attribute:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the key attribute with the v-for directive</p>
			<pre class="source-code">&lt;li v-for="(count, index) in counts" <strong class="bold">:key="index"</strong>&gt;</pre>
			<p>In the <a id="_idIndexMarker313"/>preceding code, the value of the attribute is a JavaScript expression (the variable <code>index</code>). We use <code>:key</code> and not just <code>key</code>; otherwise, the attribute would constantly have the string <code>"index"</code> as its value (instead of the value of the variable <code>index</code>).</p>
			<p>Of course, adding the <code>key</code> attribute does not produce any display changes, but the performance will be visible on subsequent changes to the displayed list (it helps Vue.js to keep track of the element and prevent unnecessary re-rendering).</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>The v-model directive</h2>
			<p>The <code>v-model</code> directive is <a id="_idIndexMarker314"/>used to manage form elements during an <a id="_idIndexMarker315"/>interaction (input in a field, a click on a checkbox or radio button, the choice of an element in a list).</p>
			<p>The <code>v-model</code> directive is used to immediately retrieve the result of input or selection in a reactive variable without having to perform any particular processing. It’s the <code>v-model</code> directive that performs this update (of the reactive variable) for us.</p>
			<p>We use the <code>v-model</code> directive in the form <code>v-model="varname"</code>, where <code>varname</code> is the name of a reactive variable that will be updated on input or selection.</p>
			<p>Let’s use the <code>v-model</code> directive in a form input field. To clearly see what happens with or without its use, we display two input fields: one managed without <code>v-model</code>, the other with:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the v-model directive in an input field (counter.js file)</p>
			<pre class="source-code">const Counter = {</pre>
			<pre class="source-code">  data() {</pre>
			<pre class="source-code">    return {</pre>
			<pre class="source-code">      count : 10</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  template : `</pre>
			<pre class="source-code">   <strong class="bold"> Without v-model:</strong></pre>
			<pre class="source-code"><strong class="bold">      &lt;input type="text" :value="count" /&gt; &amp;nbsp;&amp;nbsp; </strong></pre>
			<pre class="source-code"><strong class="bold">      count = {{count}} &lt;br&gt;&lt;br&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">    With v-model:</strong></pre>
			<pre class="source-code"><strong class="bold">      &lt;input type="text" v-model="count" /&gt; &amp;nbsp;&amp;nbsp; </strong></pre>
			<pre class="source-code"><strong class="bold">      count = {{count}}</strong></pre>
			<pre class="source-code"><strong class="bold">  `,</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">export default Counter;</pre>
			<p>Here are<a id="_idIndexMarker316"/> some notes <a id="_idIndexMarker317"/>on the preceding program:</p>
			<ul>
				<li>The first <code>&lt;input&gt;</code> field does not use <code>v-model</code>, but only uses the <code>value</code> attribute, which will be updated based on the <code>count</code> variable.</li>
				<li>The second <code>&lt;input&gt;</code> field uses the <code>v-model</code> directive associated with the same <code>count</code> variable.</li>
				<li>The value of the <code>count</code> variable is displayed after the two input fields.</li>
			</ul>
			<p>When the program is launched, the value of the reactive variable <code>count</code> is transferred to the <code>value</code> attribute of the first input field, as well as to the second. This produces the initialization of the contents of the two input fields as seen here:</p>
			<div><div><img src="img/Figure_3.16_B17416.jpg" alt="Figure 3.16 – Display when starting the program&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – Display when starting the program</p>
			<p>If we <a id="_idIndexMarker318"/>change the contents of the first input field (which is not used with <code>v-model</code>), we will <a id="_idIndexMarker319"/>see something like this:</p>
			<div><div><img src="img/Figure_3.17_B17416.jpg" alt="Figure 3.17 – Editing an input field without v-model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.17 – Editing an input field without v-model</p>
			<p>Note that modifying the input field (without <code>v-model</code>) has no effect on the reactive variable associated with it.</p>
			<p>Now let’s modify the contents of the second input field, managed by <code>v-model</code>:</p>
			<div><div><img src="img/Figure_3.18_B17416.jpg" alt="Figure 3.18 – Editing an input field with v-model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – Editing an input field with v-model</p>
			<p>We now <a id="_idIndexMarker320"/>see that the use of <code>v-model</code> causes the immediate modification <a id="_idIndexMarker321"/>of the reactive variable to which it is associated, which then causes the modification of the <code>value</code> attribute of the first input field (because it is linked to the reactive variable).</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Summary</h1>
			<p>In this chapter, we have mainly studied how to create a component and methods or attributes associated with it.</p>
			<p>It is now necessary to study how to manage the actions of the user in a component, then how to assemble the components to form an application.</p>
		</div>
	</body></html>