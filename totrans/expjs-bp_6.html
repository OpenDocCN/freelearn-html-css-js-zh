<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Hacker News API on Koa.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Hacker News API on Koa.js</h1></div></div></div><p>In this chapter, we will build an API to power our own Hacker News! While technically this wouldn't be<a id="id244" class="indexterm"/> very different from the previous chapters, we will use a different framework altogether, Koa.js (<a class="ulink" href="http://koajs.com/">http://koajs.com/</a>).</p><p>Koa.js is a <a id="id245" class="indexterm"/>new web framework designed by the team behind Express. Why did they create a new framework? Because it is designed from the bottom up, with a minimalistic core for more modularity, and to make use of the new generator syntax, proposed in ECMAScript 6, but already implemented in node 0.11.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The odd version releases of node are considered unstable. At the time of writing, the latest stable release was version 0.10. However, when this book went to print, node 0.12 was finally released and is the latest stable version.</p></div></div><p>An alternative to node 0.11 would be io.js, which at the time of writing reached version 1.0, and also implements ES6 goodies (forked from Node.js and maintained by a handful of node core contributors). In this chapter, we will stick to node 0.11. (When this book went to print, node 0.12 was finally released and is the latest stable version of node.)</p><p>One <a id="id246" class="indexterm"/>of the main benefits of the generator syntax is that you can very elegantly avoid callback hell, without the use of complicated promise patterns. You can write your APIs even more cleanly than ever before. We'll go over the subtleties as well as some caveats that come with the bleeding edge.</p><p>Some things we will cover in this chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generator syntax</li><li class="listitem" style="list-style-type: disc">Middleware philosophy</li><li class="listitem" style="list-style-type: disc">Context, versus req,res</li><li class="listitem" style="list-style-type: disc">Centralized error handling</li><li class="listitem" style="list-style-type: disc">Mongoose models in Koa.js</li><li class="listitem" style="list-style-type: disc">Thunkify to use Express modules</li><li class="listitem" style="list-style-type: disc">Testing generator functions with Mocha</li><li class="listitem" style="list-style-type: disc">Parallel HTTP requests using co-mocha</li><li class="listitem" style="list-style-type: disc">Rendering <a id="id247" class="indexterm"/>views with koa-render</li><li class="listitem" style="list-style-type: disc">Serve static assets with koa-mount and koa-static</li></ul></div><div class="section" title="Generator syntax"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Generator syntax</h1></div></div></div><p>Generator<a id="id248" class="indexterm"/> functions are at the core of Koa.js, so let's dive right into dissecting this beast. Generators allow adept JavaScript users to implement functions in completely new ways. Koa.js makes use of the new syntax to write code in a synchronous-looking fashion while maintaining the performance benefits of an asynchronous flow.</p><p>The following defines a simple generator function in <code class="literal">src/helloGenerator.js</code> (note the asterisk syntax):</p><div class="informalexample"><pre class="programlisting">module.exports = function *() {
  return 'hello generator';
};</pre></div><p>To use Mocha with Koa.js:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You will need to include <code class="literal">co-mocha</code> to add generator support, requiring once at the first line of each test file is the safe way to do it. Now you can pass generator functions to Mocha's <code class="literal">it</code> function as follows:<div class="informalexample"><pre class="programlisting">require('co-mocha');
var expect = require('chai').expect;
var helloGenerator = require('../src/helloGenerator');

describe('Hello Generator', function() {
  it('should yield to the function and return hello', function *() {
    var ans = yield helloGenerator();
    expect(ans).to.equal('hello generator');
  });
});</pre></div></li><li class="listitem">In order to run this code, you will need to have node 0.11 installed, and use the <code class="literal">--harmony-generators</code> flag as you run Mocha:<div class="informalexample"><pre class="programlisting">./node_modules/mocha/bin/mocha --harmony-generators</pre></div></li><li class="listitem">If all is well, congratulations, you have just written your first generator function! Now let's explore the execution flow of generator functions a little more.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Note the <a id="id249" class="indexterm"/>magic use of the <code class="literal">yield</code> keyword. The <code class="literal">yield</code> keyword can only be used within a <code class="literal">Generator</code> function, and works somewhat similar to <code class="literal">return</code>, expecting a single value to be passed, that can also be a generator function (also accepts other yieldables—more on that later), and yields the process to that function.</p></div></div><p>When a <code class="literal">function*</code> is passed, the execution flow will wait until that function returns before it continues further down. In essence, it would be equivalent to the following callback pattern:</p><div class="informalexample"><pre class="programlisting">helloGenerator(function(ans) {
  expect(ans).to.equal('hello generator');
});</pre></div><p>Much cleaner, right? Compare the following code:</p><div class="informalexample"><pre class="programlisting">var A = yield foo();
var B = yield bar(A);
var C = yield baz(A, B);</pre></div><p>With the nasty callback hello if we didn't have generator functions:</p><div class="informalexample"><pre class="programlisting">var A, B, C;

foo(function(A) {
  bar(A, function(B) {
    baz(A, B, function(C) {
      return C;
    });
  });
});</pre></div><p>Another neat advantage is super clean error handling, which we will get into later.</p><p>The preceding example is not too interesting because the <code class="literal">helloGenerator()</code> function is a synchronous function anyway, so it would've worked the same, even if we didn't use generator functions!</p></li><li class="listitem">So let's<a id="id250" class="indexterm"/> make it more interesting and change <code class="literal">helloGenerator.js</code> to the following:<div class="informalexample"><pre class="programlisting">module.exports = function *() {
  setTimeout(function(){
    return 'hello generator';
  }, 1000);
}</pre></div><p>Wait! Your test is failing?! What is going on here? Well, <code class="literal">yield</code> should have given the flow to the <code class="literal">helloGenerator()</code> function, let it run asynchronously, and wait until it is done before continuing. Yet, <code class="literal">ans</code> is undefined. And nobody is lying.</p><p>The reason why it is undefined is because the <code class="literal">generator()</code> function returns immediately after calling the <code class="literal">setTimeout</code> function, which is set to <code class="literal">ans</code>. The message that should have returned from within the <code class="literal">setTimeout</code> function is broadcast into the infinite void, nowhere to be seen, ever again.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>One thing to keep in mind with generator functions is that once you use a generator function, you better commit, and not resort to callbacks down the stack! Recall that we mentioned that <code class="literal">yield</code> expects a generator function. The <code class="literal">setTimeout</code> function is not a generator function, so what do we do? The <code class="literal">yield</code> method can also accept a Promise or a Thunk (more on this later).</p></div></div></li><li class="listitem">The <code class="literal">setTimeout()</code> function isn't a Promise, so we have two options left; we can thunkify the function, which basically takes a normal node function with a callback pattern and returns a Thunk, so we can yield to it; alternatively, we use co-sleep, which is basically a minuscule node package that has done it for you as follows:<div class="informalexample"><pre class="programlisting">module.exports = sleep;
function sleep(ms) {
  return function (cb) {
    setTimeout(cb, ms);
  };
}</pre></div></li><li class="listitem">We will<a id="id251" class="indexterm"/> talk about how to thunkify later, so let's use <code class="literal">co-sleep</code>. Generally a good idea to reuse what's available is to just do a quick search in the npm registry. There are numerous <code class="literal">co</code> packages out there!<div class="informalexample"><pre class="programlisting">var sleep = require('co-sleep');

module.exports = function *() {
  yield sleep(1000);
  return 'hello generator';
}</pre></div></li><li class="listitem">Now all should be good; your tests should pass after sleeping for 1 second.</li><li class="listitem">Note that the <code class="literal">co</code> library is what's under the hood of Koa.js, giving it the generator-based control flow goodies. If you want to use this sort of flow outside Koa.js, you can use something like this:<div class="informalexample"><pre class="programlisting">var co = require('co');
var sleep = require('co-sleep');

co(function*(){
  console.log('1');
  yield sleep(10);
  console.log('3');
});

console.log('2');</pre></div></li></ol></div><div class="section" title="Middleware philosophy"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Middleware philosophy</h2></div></div></div><p>You <a id="id252" class="indexterm"/>should be familiar by now with the middlewares<a id="id253" class="indexterm"/> in Express. We used them a lot to dry out code, especially for validation and authentication. In Express, middleware is placed between the server that receives the request and the handler that responds to a request. The request flows one way, until it terminates at <code class="literal">res.send</code> or something equivalent.</p><p>In Koa.js, everything is a middleware, including the handler itself. As a matter of fact, a Koa.js application is just an object, which contains an array of middleware generator functions! The request flows all the way down the stack of middlewares, and back up again. This is best <a id="id254" class="indexterm"/>explained with a simple example:</p><div class="informalexample"><pre class="programlisting">var koa = require('koa');
var app = koa();

app.use(function *(next){
  var start = new Date();
  yield next;
  var ms = new Date() - start;
  this.set('X-Response-Time', ms + 'ms');
});

app.use(function *(){
  this.body = 'Hello World';
});

app.listen(3000);</pre></div><p>Here we<a id="id255" class="indexterm"/> have a Koa.js application with two middlewares. The first middleware adds an <code class="literal">X-Response-Time</code> header to the response, whereas the second middleware simply sets the response body to <code class="literal">Hello</code> <code class="literal">World</code> for each request. The flow is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The request comes in on port <code class="literal">3000</code>.</li><li class="listitem" style="list-style-type: disc">The first middleware receives the execution flow.</li><li class="listitem" style="list-style-type: disc">A new <code class="literal">Date</code> object is created and assigned to <code class="literal">start</code>.</li><li class="listitem" style="list-style-type: disc">The flow yields to the next middleware on the stack.</li><li class="listitem" style="list-style-type: disc">The second middleware sets <code class="literal">body</code> on the Context to <code class="literal">Hello</code> <code class="literal">World</code>.</li><li class="listitem" style="list-style-type: disc">Since there is no more middleware down the stack to be yielding to, the flow returns back upstream.</li><li class="listitem" style="list-style-type: disc">The first middleware receives the execution flow again and continues down.</li><li class="listitem" style="list-style-type: disc">The response time is calculated and the response header is set.</li><li class="listitem" style="list-style-type: disc">The request has reached the top and the Context is returned.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>The Koa.js does not use <code class="literal">req,</code> <code class="literal">res</code> anymore; they are encapsulated into a single Context.</p></div></div><p>To run this app, we can use the following command:</p><div class="informalexample"><pre class="programlisting">node --harmony app.js</pre></div></div><div class="section" title="Context versus req,res"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Context versus req,res</h2></div></div></div><p>A Koa.js<a id="id256" class="indexterm"/> Context is created for each incoming<a id="id257" class="indexterm"/> request. Within each middleware, you can access the Context using the <code class="literal">this</code> object. It includes the Request and Response object in <code class="literal">this.request</code> and <code class="literal">this.response</code>, respectively, although most methods and accessors are directly available from the Context.</p><p>The most important property is <code class="literal">this.body</code>, which sets the response body. The response status is automatically set to <code class="literal">200</code> when the response body is set. You may override this by setting <code class="literal">this.status</code> manually.</p><p>Another very useful syntactic sugar is <code class="literal">this.throw</code>, which allows you to return an error response by simply calling <code class="literal">this.throw(400)</code>, or if you want to override the standard HTTP error message, you may pass a second argument with the error message. We will get to Koa.js slick error handling later in this chapter.</p><p>Now that we've got the basics down, let's start building a Hacker News API!</p><div class="section" title="The link model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec01"/>The link model</h3></div></div></div><p>The <a id="id258" class="indexterm"/>following code describes the straightforward link document model in <code class="literal">src/models/links.js</code>:</p><div class="informalexample"><pre class="programlisting">var mongoose = require('mongoose');

var schema = new mongoose.Schema({
  title: { type: String, require: true },
  URL: { type: String, require: true },
  upvotes: { type: Number, require: true, 'default': 0 },
  timestamp: { type: Date, require: true, 'default': Date.now }
});

schema.statics.upvote = function *(linkId) {
  return yield this.findByIdAndUpdate(linkId, {
    $inc: {
      upvotes: 1
    }
  }).exec();
};

var Links = mongoose.model('links', schema);
module.exports = Links;</pre></div><p>Note that<a id="id259" class="indexterm"/> this is pretty much identical to how you would define a model in Express, with one exception: the <code class="literal">upvotes</code> static method. Since <code class="literal">findByIdAndUpdate</code> is an asynchronous I/O operation, we need to make sure that we <code class="literal">yield</code> to it, so as to make sure we wait for this operation to complete, before we continue the execution.</p><p>Earlier we noted that not only generator functions can be yielded to; it also accepts Promises, which is awesome, because they are quite ubiquitous. Using Mongoose, for example, we can turn Mongoose query instances into Promises by calling the <code class="literal">exec()</code> method.</p></div><div class="section" title="The link routes"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec02"/>The link routes</h3></div></div></div><p>With the <a id="id260" class="indexterm"/>link model in place, let's set up some routes in <code class="literal">src/routes/links.js</code>:</p><div class="informalexample"><pre class="programlisting">var model = require('../models/links');

module.exports = function(app) {
  app.get('/links', function *(next) {
    var links = yield model.find({}).sort({upvotes: 'desc'}).exec();
    this.body = links;
  });

  app.post('/links', function *(next) {
    var link = yield model.create({
      title: this.request.body.title,
      URL: this.request.body.URL
    });
    this.body = link;
  });

  app.delete('/links/:id', function *(next) {
    var link = yield model.remove({ _id: this.params.id }).exec();
    this.body = link;
  });

  app.put('/links/:id/upvote', function *(next) {
    var link = yield model.upvote(this.params.id);
    this.body = link;
  });
};</pre></div><p>This should <a id="id261" class="indexterm"/>start to look familiar. Instead of function handlers with the signature (<code class="literal">req, res</code>) that we are used to in Express, we simply use middleware generator functions and set the response body in <code class="literal">this.body</code>.</p></div><div class="section" title="Tying it together"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec03"/>Tying it together</h3></div></div></div><p>Now that we <a id="id262" class="indexterm"/>have our model and routes defined perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's tie it together in a Koa.js application in <code class="literal">src/app.js</code>:<div class="informalexample"><pre class="programlisting">var koa = require('koa'),
    app = koa(),
    bodyParser = require('koa-body-parser'),
    router = require('koa-router');

// Connect to DB
require('./db');

app.use(bodyParser());
app.use(router(app));
require('./routes/links')(app);

module.exports = app;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Note that we use <code class="literal">koa-body-parser</code> to parse the request body in <code class="literal">this.request.body</code> and <code class="literal">koa-router</code>, which allows you to define Express style routes, the kind you saw earlier.</p></div></div></li><li class="listitem">Next, we connect to the database, which isn't different from the previous chapters, so we will omit the code here.</li><li class="listitem">Finally, we define the Koa app, mount the middleware, and load the routes. Then, in the root folder, we have <code class="literal">/app.js</code> as given in the following:<div class="informalexample"><pre class="programlisting">var app = require('./src/app.js');
app.listen(3000);
console.log('Koa app listening on port 3000');</pre></div></li></ol></div><p>This just loads the app and starts an HTTP server, which listens on port <code class="literal">3000</code>. Now to start the server, make sure you use the <code class="literal">--harmony-generators</code> flag. You should now have a <a id="id263" class="indexterm"/>working Koa API to power a Hacker News-like website!</p></div></div></div></div>
<div class="section" title="Validation and error handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Validation and error handling</h1></div></div></div><p>Error-handling is <a id="id264" class="indexterm"/>one of the fortes of Koa.js. Using generator functions <a id="id265" class="indexterm"/>we don't need to deal with error handling in every level of the callbacks, avoiding the use of (<code class="literal">err,</code> <code class="literal">res</code>) signature callbacks popularized by Node.js. We don't even need to use the <code class="literal">.error</code> or <code class="literal">.catch</code> methods known to Promises. We can use plain old <code class="literal">try/catch</code> that ships with JavaScript out of the box.</p><p>The implication of this is that we can now have the following centralized error handling middleware:</p><div class="informalexample"><pre class="programlisting">var logger = console;

module.exports = function *(next) {
  try {
    yield next;
  } catch (err) {
    this.status = err.status || 500;
    this.body = err.message;
    this.app.emit('error', err, this);
  }
};</pre></div><p>When we include this as one of the first middlewares on the Koa stack, it will basically wrap the entire stack, which is yielded to downstream, in a giant <code class="literal">try/catch</code> clause. Now we don't need to worry about exceptions being thrown into the ether. In fact, you are now encouraged to <code class="literal">throw</code> common JavaScript errors, knowing that this middleware will gracefully unpack it for you, and present it to the client.</p><p>Now this may not always be exactly what you want though. For instance, if you try to upvote an ID that is not a valid BSON format, Mongoose will throw <code class="literal">CastError</code> with the message <code class="literal">Cast</code> <code class="literal">to</code> <code class="literal">ObjectId</code> <code class="literal">failed</code> <code class="literal">for</code> <code class="literal">value</code> <code class="literal">xxx</code> <code class="literal">at</code> <code class="literal">path</code> <code class="literal">_id'</code>. While informative for you, it is pretty dirty for the client. So here's how you can override the error by returning a <code class="literal">400</code> error with a nice, clean message:</p><div class="informalexample"><pre class="programlisting">app.put('/links/:id/upvote', function *(next) {
  var link;
  try {
    link = yield model.upvote(this.params.id);
  } catch (err) {
    if (err.name === 'CastError') {
      this.throw(404, 'link can not be found');
    }
  }

  // Check that a link document is returned
  this.assert(link, 404, 'link not found');

  this.body = link;
});</pre></div><p>We basically <a id="id266" class="indexterm"/>catch the error where it happens, as opposed to let it bubble <a id="id267" class="indexterm"/>up all the way to the error handler. While we could throw a JavaScript error object with the <code class="literal">status</code> and <code class="literal">message</code> fields set to pass it along to the errorHandler middleware, we can also handle it here directly with the <code class="literal">this.throw</code> helper of the Context object.</p><p>Now if you pass a valid BSON ID, but the link does not exist, Mongoose will not throw an error. Therefore, you still have to check whether the value of <code class="literal">link</code> is not <code class="literal">undefined</code>. Here is yet another gorgeous helper of the Context object: <code class="literal">this.assert</code>. It basically asserts whether a condition is met, and if not, it will return a <code class="literal">400</code> error with the message <code class="literal">link</code> <code class="literal">not</code> <code class="literal">found</code>, as passed in the second and third argument.</p><p>Here are a few more validations to the submission of links:</p><div class="informalexample"><pre class="programlisting">app.post('/links', function *(next) {
  this.assert(typeof this.request.body.title === 'string', 400, 'title is required');
  this.assert(this.request.body.title.length &gt; 0, 400, 'title is required');

  this.assert(utils.isValidURL(this.request.body.URL), 400, 'URL is invalid');

  // If the above assertion fails, the following code won't be executed.
  var link = yield model.create({
    title: this.request.body.title,
    URL: this.request.body.URL
  });
  this.body = link;
});</pre></div><p>We ensure that a title is being passed, as well as a valid URL, for which we use the following RegEx util:</p><div class="informalexample"><pre class="programlisting">module.exports = {
  isValidURL: function(url) {
    return /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?/;
  }
};</pre></div><p>Now <a id="id268" class="indexterm"/>there are still ways to refactor the validation checks into modular<a id="id269" class="indexterm"/> middleware; similar to what we did in <a class="link" href="ch03.html" title="Chapter 3. Multiplayer Game API – Connect 4">Chapter 3</a>, <span class="emphasis"><em>Multiplayer Game API – Connect</em></span> this is left as an exercise to the reader.</p></div>
<div class="section" title="Update route"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Update route</h1></div></div></div><p>A CRUD<a id="id270" class="indexterm"/> API is not complete with the update route! If you are a Hacker News frequenter, you'll know that titles of the submissions can change (but not the URL). This route should be straightforward, but there is one caveat! Yes, you could use <code class="literal">findByIdAndUpdate</code>, which is used by <code class="literal">upvote</code>, but what if you wanted to use Mongoose's instance method <code class="literal">.save()</code>?</p><p>Well, it does not return a Promise, so therefore we cannot <code class="literal">yield</code> to it. In fact, at the time of writing, there is still an open issue about this. Using <code class="literal">save()</code>, we can only use the traditional callback pattern. However, remember the rule—do not mix generator functions with callbacks!</p><p>So now what? Well, it will be quite common for certain node modules to be only available in the callback format. While most common modules are ported to a Koa version, you can still use Express packages; you just have to <code class="literal">thunkify</code> them. In fact, you could turn any callback style function into a thunk.</p><div class="informalexample"><pre class="programlisting">npm install --save thunkify</pre></div><p>Now here's how to turn a function that accepts a callback into a yieldable thunk:</p><div class="informalexample"><pre class="programlisting">var thunk = require('thunkify');

...

// Thunkify save method
Links.prototype.saveThunk = thunk(Links.prototype.save);</pre></div><p>Adding the preceding code to <code class="literal">model/links.js</code>, we can now do the following in the update route:</p><div class="informalexample"><pre class="programlisting">app.put('/links/:id', function *(next) {
  this.assert((this.request.body.title || '').length &gt; 0, 400, 'title is required');

  var link;
  try {
    link = yield model.findById(this.params.id).exec();
  } catch (err) {
    if (err.name === 'CastError') {
      this.throw(400, 'invalid link id');
    }
  }

  // Check that a link document is returned
  this.assert(link, 400, 'link not found');

  link.title = this.request.body.title;
  link = yield link.saveThunk()[0];
  this.body = link;
});</pre></div><p>Notice <a id="id271" class="indexterm"/>the use of <code class="literal">saveThunk()</code> near the bottom. It is basically a <code class="literal">thunkified</code> version of the original <code class="literal">save()</code> method. This means that an error that would originally be passed as the first argument in the callback is now thrown as an Error. We can afford not to wrap it in a <code class="literal">try/catch</code> block because the errorHandler middleware will catch it and throw a <code class="literal">500</code> error, which would be appropriate in this case.</p><p>Also, note how the thunk returns an array. This is because the original callback has an arity of <code class="literal">3</code>. The first argument is the error, the second argument is the new document, while the third argument is the number of affected documents. The array returned by the thunk contains the latter two values. If the arity of the callback was <code class="literal">2</code>, it would've just returned the value; something to keep in mind.</p></div>
<div class="section" title="Let's perform some tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Let's perform some tests</h1></div></div></div><p>In this<a id="id272" class="indexterm"/> chapter we omitted the disciplined TDD approach, since it has been covered multiple times in previous chapters. However, testing is slightly different in Koa.js, so let's highlight some of those differences.</p><p>We can still use supertest in the neat way that we did before, with one slight adjustment as follows:</p><div class="informalexample"><pre class="programlisting">var app = require('../src/app').callback();</pre></div><p>We need to call the <code class="literal">.callback()</code> method to return an object that we can pass to supertest. In fact, the returned object can even be mounted on top of an Express app.</p><p>Testing the<a id="id273" class="indexterm"/> routes to submit links is pretty straightforward:</p><div class="informalexample"><pre class="programlisting">var app = require('../src/app').callback(),
    Links = require('../src/models/links');

describe('Submit a link', function() {

  before(function(done) {
    Links.remove({}, function(err) {
      done();
    });
  });

  it('should successfully submit a link', function (done) {
    request(app).post('/links')
      .send({title: 'google', URL: 'http://google.com'})
      .expect(200, done);
  });</pre></div><p>At the start of this test suite, we clear the collection in the DB and submit a link using a post request. Nothing special here; note that we use Mocha's default callbacks for the asynchronous requests, and not <code class="literal">co-mocha</code>.</p><p>Let's submit a few more links, and check that they are indeed stored in the DB:</p><div class="informalexample"><pre class="programlisting">  it('should successfully submit another link', function (done) {
    request(app).post('/links')
      .send({title: 'Axiom Zen', URL: 'http://axiomzen.co'})
      .expect(200, done);
  });

  it('should successfully submit a third link', function (done) {
    request(app).post('/links')
      .send({title: 'Hacker News', URL: 'http://news.ycombinator.com'})
      .expect(200, done);
  });

  // To be used in next test
  var linkIDs = [];
  it('should list all links', function (done) {
    request(app).get('/links')
      .expect(200)
      .end(function(err, res) {
        var body = res.body;
        expect(body).to.have.length(3);

        // Store Link ids for next test
        for(var i = 0; i &lt; body.length; i++) {
          linkIDs.push(body[i]._id);
        }
        done();
      });
  });</pre></div><p>Notice <a id="id274" class="indexterm"/>that we store link IDs in an array for the next test case to demonstrate the final, most awesome bonus feature of Koa.js, parallel asynchronous requests, out of the box!</p><div class="section" title="Parallel requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Parallel requests</h2></div></div></div><p>The<a id="id275" class="indexterm"/> backend of Hacker News should be able to deal with the race<a id="id276" class="indexterm"/> condition, that is, it should handle hundreds of concurrent <code class="literal">upvote</code> requests without losing data (recall <a class="link" href="ch04.html" title="Chapter 4. MMO Word Game">Chapter 4</a>, <span class="emphasis"><em>MMO Word Game</em></span> on race conditions). So let's write a test case that simulates parallel requests.</p><p>Traditionally, you would immediately think of using the extremely powerful and popular <code class="literal">async</code> library, which has a lot of very useful tools to deal with complex asynchronous execution flows. One of the most useful tools that <code class="literal">async</code> offers is <code class="literal">async.parallel</code>, with which you can make asynchronous requests in parallel. It is used to be the go-to solution for parallel requests, but now Koa offers something out of the box and with a much cleaner syntax!</p><p>Recall that <code class="literal">co</code> is actually what gives Koa the power of generator functions, so refer to the readme page of the <code class="literal">co</code> project to read more about all the patterns that it has to offer.</p><p>So far we yielded to generator functions, Promises, and thunks. However, that is not all. You can also <code class="literal">yield</code> to an array of the preceding which would execute them in parallel! Here's how:</p><div class="informalexample"><pre class="programlisting">// Add to top of file
require('co-mocha');
var corequest = require('co-supertest');

…

  it('should upvote all links in parallel', function *() {
    
    var res = yield linkIDs.map(function(id) {
     return corequest(app)
        .put('/links/' + id + '/upvote')
        .end()
    });
;

    // Assert that all Links have been upvoted
    for(var i = 0; i &lt; res.length; i++) {
      expect(res[i].body.upvotes).to.equal(1);
    }

  });</pre></div><p>Firstly, notice<a id="id277" class="indexterm"/> how we use a generator function, so be sure that you<a id="id278" class="indexterm"/> have <code class="literal">require(co-mocha)</code> on top of your test file.</p><p>Secondly, <code class="literal">supertest</code> does not return a thunk or a promise, which we can yield to, so we require <code class="literal">co-supertest</code> for this test case:</p><div class="informalexample"><pre class="programlisting">npm install co-supertest --save-dev</pre></div><p>Thirdly, we build an array of requests to be executed later. We are basically pushing thunks into an array; they could be promises too. Now when we yield the array, it will execute all requests in parallel, and return an array of all the response objects!</p><p>Quite mind blowing if you're used to <code class="literal">async.parallel</code> for these things, right?</p></div><div class="section" title="Rendering HTML pages"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Rendering HTML pages</h2></div></div></div><p>At this<a id="id279" class="indexterm"/> point, we have a simple Koa API that has all the <a id="id280" class="indexterm"/>basic functionalities quite well tested. Let's add a simple view layer on top to show how you can serve static files from a Koa app as well. So if the app receives a request from a browser for HTML content, we'll serve a functional web page, where we can see the links submitted, submit a link, as well as upvote a link.</p><p>Let's pause here for a quick real-developer-life anecdote to implement the preceding. The tendency for modularity is an empowering force of the open source community. A modern day developer has access to a plethora of well-tested modules. Oftentimes, the majority of the developer's work is simply to compose an app of several such modules. We learn of these modules from prior experience, books, news websites, social media, and so on. So how do we go about choosing the right tools instead of reinventing the wheel?</p><p>It is always recommended to do a simple search to see whether a module is already available. In this case, we are interested in rendering views with Koa.js, so let's try the search term <code class="literal">koa-render</code> on <a class="ulink" href="http://www.npmjs.com">www.npmjs.com</a>. Two popular packages come up that seem to quite fit our needs, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B00818_06_01.jpg" alt="Rendering HTML pages"/></div><p>The <code class="literal">koa-views</code> is a template rendering middleware for Koa, supporting many template engines. Sounds promising! <code class="literal">koa-render</code> adds a <code class="literal">render()</code> method to Koa that allows you to render almost any templating engine. Not bad either. As shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B00818_06_02.jpg" alt="Rendering HTML pages"/></div><p>One of the <a id="id281" class="indexterm"/>things we can look at to guide our choice is <a id="id282" class="indexterm"/>the number of downloads; both packages have a decent amount of downloads, which shows some credibility. The <code class="literal">koa-views</code> has about 5 times more downloads than <code class="literal">koa-render</code> per month. While these badges are a minor touch, it does show that the author cared enough and is likely to support it. The number of recent commits is also a of good indicator that can be found on the GitHub page for the project, the number issues that have been resolved, and so on.</p><p>At the time of writing, both projects' GitHub links redirect to <code class="literal">koa-views</code>, which is unexpected, but good for us! Looking at the GitHub account of the author of koa-render, we cannot find the project anymore, so it's safe to assume it was discontinued; avoid it! When you can, try to avoid using non-maintainable packages as it might pose a threat given the fact that Node.js (and io.js) are rapidly evolving ecosystems.</p><p>Back to rendering HTML pages, Koa, unlike Express, has no pre-baked opinion about the rendering of views. However, it does provide us with some mechanisms for content negotiation, some of which we can use to enhance and reuse the routes we already have for our API. Let's see what our <code class="literal">/links</code> handler will look like:</p><div class="informalexample"><pre class="programlisting">  app.get('/links', function *(next) {
    var links = yield model.find({}).sort({upvotes: 'desc'}).exec();
    if( this.accepts('text/html') ){
      yield this.render('index', {links: links});
    } else {
      this.body = links;
    }</pre></div><p>Our use <a id="id283" class="indexterm"/>case is rather simple; we either serve JSON or HTML. When <a id="id284" class="indexterm"/>the request header <code class="literal">accepts</code> is set to <code class="literal">text/html</code>, something browsers set automatically, we'll render the HTML. For the rendering of dynamic jade views to work as expected, we must not forget to include the <code class="literal">koa-views</code> middleware in <code class="literal">app.js</code> somewhere before the router middleware:</p><div class="informalexample"><pre class="programlisting">var views = require('koa-views');

...

app.use(views('./views', {default: 'jade'}));</pre></div><p>The middleware points to a folder with a relative path that will contain the templates. Right now, we just need a single template <code class="literal">views/index.jade</code>:</p><div class="informalexample"><pre class="programlisting">doctype html
html(lang="en")
  head
    title Koa News
  body
    h1 Koa News
    div
      each link in links
        .link-row
          a(href='#', onclick="upvote('#{link._id}', $(this))") ^
          span &amp;nbsp;
          a(href=link.URL)= link.title
          .count= link.upvotes
            |  votes
    h2 Submit your link:
    form(action='/links', method='post')
      label Title:
      input(name='title', placeholder="Title")
      br
      label URL:
      input(name='URL', placeholder="https://")
      br
      br
      button.submit-btn Submit
    script(src="https://code.jquery.com/jquery-2.1.3.min.js")
    script.
      var upvote = function(id, elem) {
        $.ajax({url:'/links/'+id+'/upvote', type:'put' })
        .done(function(data) {
          elem.siblings('.count').text(data.upvotes + ' votes');
        })
      }</pre></div><p>It's a jade file <a id="id285" class="indexterm"/>similar to the ones presented before in this book. It loops<a id="id286" class="indexterm"/> over every link loaded at the controller, which has a single action to upvote. Links are displayed in the descending order of votes, which only happens when the page is reloaded. There is also a simple form that allows the user to submit new links.</p><p>We chose to load jQuery from a CDN simply in order to make the <code class="literal">PUT</code> request for upvotes. Notice that our use of inline JavaScript as well as adding a click event using the onclick element is highly discouraged, other than to make this example simple to digest.</p><p>Now if you have your app running and you go to <code class="literal">localhost:3000/links</code>, here's the result:</p><div class="mediaobject"><img src="graphics/B00818_06_03.jpg" alt="Rendering HTML pages"/></div><p>So that's a<a id="id287" class="indexterm"/> start from a functional standpoint! Clearly<a id="id288" class="indexterm"/> not good enough if we want to add more frontend JavaScript and CSS styling to it; we still need to be able to serve static files.</p></div><div class="section" title="Serving static assets"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Serving static assets</h2></div></div></div><p>Although <a id="id289" class="indexterm"/>usually you'd be incentivized to create a separate<a id="id290" class="indexterm"/> server for your assets, let's keep things simple and dive straight to the goal. We want to serve any files from a certain folder to a certain base path. For that purpose, we'll need two small middlewares, respectively, <code class="literal">koa-static</code> and <code class="literal">koa-mount</code>. In <code class="literal">src/app.js</code>, we add the following:</p><div class="informalexample"><pre class="programlisting">var serve = require('koa-static');
var mount = require('koa-mount');

// ..

app.use(mount('/public', serve('./public') ));</pre></div><p>The function <code class="literal">mount()</code> will namespace the request for each middleware that follows, in this particular case being combined with serve, which will serve any file inside the <code class="literal">public/</code> directory. If <a id="id291" class="indexterm"/>we decide not to mount to any particular URL, <a id="id292" class="indexterm"/>serving files would still work; it just won't have a nice namespace.</p><p>Now all you need to do is create a <code class="literal">public/</code> directory in the root folder with <code class="literal">filepublic/main.css</code> and it will able to serve a stylesheet.</p><p>This method allows to serve all static files you'd expect; CSS, JavaScript, images, and even videos.</p><p>To take it even further, there are many build tools and best practices for front-end assets, including ways to set up asset pipelines with Grunt, Gulp, Browserify, SASS, CoffeeScript, and many others tools. Not to mention front-end frameworks such as Angular, Ember, React, and so on. This is only the beginning.</p><p>Hope you enjoyed the introduction to Koa.js!</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Summary</h1></div></div></div><p>We built an API with which you can now host your own Hacker News of X! Obviously, we're still missing the sort and decay algorithm, as well as comments, but since you reached this far, it should be an easy exercise for you.</p><p>The purpose of this chapter was really to give you a taste of the neat features of Koa.js, and demonstrate the use of the generator function pattern, which will be available in ECMAScript 6. If you like being on the bleeding edge, and enjoy the generator syntax, it is definitely a good alternative to Express.js.</p></div></body></html>