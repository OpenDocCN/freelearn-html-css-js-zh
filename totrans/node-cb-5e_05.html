<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-140">
    <a id="_idTextAnchor139">
    </a>
    
     5
    
   </h1>
   <h1 id="_idParaDest-141">
    <a id="_idTextAnchor140">
    </a>
    
     Developing Node.js Modules
    
   </h1>
   <p>
    
     One of the main attractions of Node.js is the massive ecosystem of external third-party libraries.
    
    <strong class="bold">
     
      Node.js modules
     
    </strong>
    
     are
    
    <a id="_idIndexMarker261">
    </a>
    
     libraries or a set of functions you want to include in your application.
    
    
     Most modules will provide an API to expose functionality.
    
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry is where most Node.js modules are stored, where there are over a million Node.js
    
    
     
      modules available.
     
    
   </p>
   <p>
    
     This chapter will first cover how to consume existing Node.js modules from the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry for use within your applications using
    
    <a id="_idIndexMarker262">
    </a>
    
     the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    <strong class="bold">
     
      command-line
     
    </strong>
    
     <strong class="bold">
      
       interface
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       CLI
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     Later in this chapter, you’ll learn how to develop and publish your own Node.js module to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry.
    
    
     There will also be an introduction to using the
    
    <strong class="bold">
     
      ECMAScript Modules
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ESM
     
    </strong>
    
     ) syntax, which
    
    <a id="_idIndexMarker263">
    </a>
    
     is available in all currently supported versions of Node.js.
    
    
     The recipes in this chapter build upon each other, so it’s recommended you work through them
    
    
     
      in order.
     
    
   </p>
   <p>
    
     This chapter will cover the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Consuming
     
     
      
       Node.js modules
      
     
    </li>
    <li>
     
      Scaffolding
     
     
      
       a module
      
     
    </li>
    <li>
     
      Writing
     
     
      
       module code
      
     
    </li>
    <li>
     
      Publishing
     
     
      
       a module
      
     
    </li>
    <li>
     
      
       Using ESM
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-142">
    <a id="_idTextAnchor141">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     This chapter will require you to have Node.js, preferably the most recent Node.js 22 release, installed.
    
    
     You should also have the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI installed, which comes bundled with Node.js.
    
    
     Both
    
    <strong class="source-inline">
     
      node
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     should be in your path in your shell (
    
    
     
      or terminal).
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     It is recommended to install Node.js
    
    <a id="_idIndexMarker264">
    </a>
    
     with
    
    <strong class="bold">
     
      Node Version Manager
     
    </strong>
    
     (
    
    <strong class="bold">
     
      nvm
     
    </strong>
    
     ).
    
    
     It is a tool that enables you to easily switch Node.js versions on most Unix-like platforms.
    
    
     If you’re using Windows, you can install Node.js
    
    
     
      from
     
    
    <a href="https://nodejs.org/en/">
     
      
       https://nodejs.org/en/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     You can confirm which versions of Node.js and
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     are installed by typing the following command into
    
    
     
      your terminal:
     
    
   </p>
   <pre class="console">
$ node --version
v22.9.0
$ npm --version
10.8.3</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI is the default package manager bundled with Node.js, and we’ll be using the bundled
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI in this chapter to install and
    
    
     
      publish modules.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI is bundled with Node.js as the default package manager.
    
    
     npm, Inc.
    
    
     is also the name of the company that owns the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     
      registry (
     
    
    <a href="https://npmjs.org/">
     
      
       https://npmjs.org/
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     Note that as we will be downloading and publishing modules to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry, this chapter will require
    
    
     
      internet access.
     
    
   </p>
   <h1 id="_idParaDest-143">
    <a id="_idTextAnchor142">
    </a>
    
     Consuming Node.js modules
    
   </h1>
   <p>
    
     In this recipe, we are
    
    <a id="_idIndexMarker265">
    </a>
    
     going to learn how to consume
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     modules from the public
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry using the
    
    
     <strong class="source-inline">
      
       npm
      
     </strong>
    
    
     
      CLI.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      Yarn
     
    </strong>
    
     is a popular
    
    <a id="_idIndexMarker266">
    </a>
    
     alternative package manager for JavaScript and was created as an alternative to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI in 2016.
    
    
     When Yarn was released,
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     did not have the
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     feature to guarantee consistency of which specific versions of modules would be installed.
    
    
     This was one of the key features of Yarn.
    
    
     At the time of writing, the Yarn CLI offers a similar user experience to what the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI provides.
    
    
     Yarn maintains a registry that is a reverse proxy to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry.
    
    
     For more information about Yarn, check out their
    
    <em class="italic">
     
      Get Started
     
    </em>
    
     
      guide:
     
    
    
    
    <a href="https://yarnpkg.com/getting-started">
     
      
       https://yarnpkg.com/getting-started
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-144">
    <a id="_idTextAnchor143">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To get started, we first need to create a new directory to
    
    
     
      work in:
     
    
   </p>
   <pre class="console">
$ mkdir consuming-modules
$ cd consuming-modules</pre>
   <p>
    
     We will also need a file where we can attempt to execute the
    
    
     
      imported module:
     
    
   </p>
   <pre class="console">
$ touch require-express.js</pre>
   <h2 id="_idParaDest-145">
    <a id="_idTextAnchor144">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this section, we’re
    
    <a id="_idIndexMarker267">
    </a>
    
     going to set up a project and install the
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     module, a commonly used web framework for Node.js and often one of the first modules newcomers to the
    
    
     
      runtime learn.
     
    
   </p>
   <ol>
    <li>
     
      First, we’ll need to initialize a new project.
     
     
      Do this by typing
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">$ npm init</strong></pre>
    </li>
    <li>
     
      You will need to step through the utility to answer the questions in the command-line utility.
     
     
      If you are unsure, you can just hit
     
     <em class="italic">
      
       Enter
      
     </em>
     
      to accept
     
     
      
       the defaults.
      
     
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       npm init
      
     </strong>
     
      command should have generated a
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      file in your project directory.
     
     
      It should look
     
     
      
       like this:
      
     
     <pre class="source-code">
{
  "name": "consuming-modules",
  "version": "1.0.0",
  "main": "require-express.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp;
      exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": ""
}</pre>
    </li>
    <li>
     
      Now, we can install our module.
     
     
      To install the
     
     <strong class="source-inline">
      
       express
      
     </strong>
     
      module, type the following command
     
     <a id="_idIndexMarker268">
     </a>
     
      while in your
     
     
      
       project directory:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install express</strong></pre>
    </li>
    <li>
     
      If we look at the
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      file again, we should see that the module has been added to a
     
     
      <strong class="source-inline">
       
        dependencies
       
      </strong>
     
     
      
       field:
      
     
     <pre class="source-code">
<strong class="bold">{</strong>
<strong class="bold">  "name": "consuming-modules",</strong>
<strong class="bold">  "version": "1.0.0",</strong>
<strong class="bold">  "description": "",</strong>
<strong class="bold">  "main": "require-express.js",</strong>
<strong class="bold">  "scripts": {</strong>
<strong class="bold">    "test": "echo \"Error: no test specified\" &amp;&amp;</strong>
<strong class="bold">      exit 1"</strong>
<strong class="bold">  },</strong>
<strong class="bold">  "author": "",</strong>
<strong class="bold">  "license": "ISC",</strong>
<strong class="bold">  "dependencies": {</strong>
<strong class="bold">    "express": "^4.18.2"</strong>
<strong class="bold">  }</strong>
<strong class="bold">}</strong></pre>
     <p class="list-inset">
      
       Also, observe that both a
      
      <strong class="source-inline">
       
        node_modules
       
      </strong>
      
       directory and a
      
      <strong class="source-inline">
       
        package-lock.json
       
      </strong>
      
       file have now been created in your
      
      
       
        project directory.
       
      
     </p>
    </li>
    <li>
     
      Now, we can open our
     
     <strong class="source-inline">
      
       require-express.js
      
     </strong>
     
      file.
     
     
      We only need to add the following line to test whether we can import and use
     
     
      
       the module:
      
     
     <pre class="source-code">
const express = require('express');</pre>
    </li>
    <li>
     
      It is expected that the program executes and immediately terminates after requiring the
     
     <strong class="source-inline">
      
       express
      
     </strong>
     
      module.
     
     
      Should the module not have been installed successfully, we would have seen an error like
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">$ node require-express.js</strong>
<strong class="bold">internal/modules/cjs/loader.js:979</strong>
<strong class="bold">  throw err;</strong>
<strong class="bold">  ^</strong>
<strong class="bold">Error: Cannot find module 'express'</strong></pre>
    </li>
   </ol>
   <p>
    
     We’ve now successfully
    
    <a id="_idIndexMarker269">
    </a>
    
     downloaded a third-party module from the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry and imported it into our application so that it can
    
    
     
      be used.
     
    
   </p>
   <h2 id="_idParaDest-146">
    <a id="_idTextAnchor145">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The recipe made use of both
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     , the CLI bundled with Node.js, and the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     public registry to download the
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     
      third-party module.
     
    
   </p>
   <p>
    
     The first command of the recipe was
    
    <strong class="source-inline">
     
      npm init
     
    </strong>
    
     .
    
    
     This command initializes a new project in the current working directory.
    
    
     By default, running this command will open a CLI utility that will ask for some properties about your project.
    
    
     The following table defines the
    
    
     
      requested properties:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-3">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Property
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Definition
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Package name
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Specifies the name
        
        <a id="_idIndexMarker270">
        </a>
        
         of the project.
        
        
         It must be unique when publishing to the
        
        <strong class="source-inline">
         
          npm
         
        </strong>
        
         registry.
        
        
         A name can be prefixed by a scope; for
        
        
         
          example,
         
        
        
         <strong class="source-inline">
          
           @organization/package
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Version
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The initial version of the project.
        
        
         It is typical of Node.js modules to follow the Semantic Versioning standard.
        
        
         The default value
        
        
         
          is
         
        
        
         <strong class="source-inline">
          
           1.0.0
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Description
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A brief description of your project to help users understand what your project does and
        
        
         
          its purpose.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Entry point
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The entry point file of your Node.js application or module.
        
        
         It’s the path to the main file that will be executed when your module is required by another application.
        
        
         The default value
        
        
         
          is
         
        
        
         <strong class="source-inline">
          
           index.js
          
         </strong>
        
        
         
          .
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Test command
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Used to define the command to be run when executing
        
        <strong class="source-inline">
         
          npm test
         
        </strong>
        
         or
        
        <strong class="source-inline">
         
          npm run test
         
        </strong>
        
         .
        
        
         Typically, this will be the command that executes your
        
        
         
          test suite.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Git repository
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Specifies the location of your project’s source code repository.
        
        
         This is helpful for contributors and users who want to access the code, report issues,
        
        
         
          or contribute.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Keywords
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Keywords relating to
        
        
         
          your project.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Author
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A list of the author(s) of
        
        
         
          the project.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          License
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Indicates the license type under which the project is distributed.
        
        
         This is important for users to understand how they are permitted to use and share
        
        
         
          your project.
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 5.1 – Table detailing default properties of the package.json file
    
   </p>
   <p>
    
     The only properties
    
    <a id="_idIndexMarker271">
    </a>
    
     that are mandatory are the package name and version.
    
    
     It is also possible to skip the CLI utility and accept all defaults by typing
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
$ npm init --yes</pre>
   <p>
    
     It is possible to configure default answers using the
    
    <strong class="source-inline">
     
      npm config
     
    </strong>
    
     command.
    
    
     This can be achieved with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ npm config set init.author.name "Your Name"</pre>
   <p>
    
     Once the
    
    <strong class="source-inline">
     
      npm init
     
    </strong>
    
     command completes, it will generate a
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file in your current working directory.
    
    
     The
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file does
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      It lists the packages that your project depends on, acting as a
     
     <em class="italic">
      
       blueprint
      
     </em>
     
      or set of instructions as to which dependencies need to
     
     
      
       be installed
      
     
    </li>
    <li>
     
      Provides a mechanism for you to specify the versions of a package that your project can use – based on the Semantic
     
     <a id="_idIndexMarker272">
     </a>
     
      Versioning
     
     
      
       specification (
      
     
     <a href="https://semver.org/">
      
       
        https://semver.org/
       
      
     </a>
     
      
       )
      
     
    </li>
   </ul>
   <p>
    
     In the next step of the recipe, we used the
    
    <strong class="source-inline">
     
      npm install express
     
    </strong>
    
     command to install the
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     module.
    
    
     The command reaches out to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry to download the latest
    
    <a id="_idIndexMarker273">
    </a>
    
     version of the module with the
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     
      name identifier.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     By default, when supplying a module name, the
    
    <strong class="source-inline">
     
      npm install
     
    </strong>
    
     command will look for a module with that name and download it from the public
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry.
    
    
     But it is also possible to pass the
    
    <strong class="source-inline">
     
      npm install
     
    </strong>
    
     command other parameters, such as a GitHub URL, and the command will install the content available at the URL.
    
    
     For more information, refer to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI
    
    
     
      documentation:
     
    
    <a href="https://docs.npmjs.com/cli/v10/commands/npm-install">
     
      
       https://docs.npmjs.com/cli/v10/commands/npm-install
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     When the
    
    <strong class="source-inline">
     
      install
     
    </strong>
    
     command completes, it will put the module contents into a
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     directory.
    
    
     If there isn’t one in the current project, but there is
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     , the command will also create a
    
    
     <strong class="source-inline">
      
       node_modules
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <p>
    
     If you look at the contents of the
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     directory, you will notice that more than just the
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     module is present.
    
    
     This is because
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     has dependencies, and their dependencies may also
    
    
     
      have dependencies.
     
    
   </p>
   <p>
    
     When installing a module, you’re potentially, and often, installing a whole tree of modules.
    
    
     The following output shows a snippet of the structure of a
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     directory from
    
    
     
      the recipe:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">$ ls node_modules</strong>
     |-- accepts
     |-- escape-html
     |-- ipaddr.js
     |-- raw-body
     |-- array-flatten
     |-- etag
     |-- media-typer
     |-- safe-buffer
     |-- ...</pre>
   <p>
    
     You can also use the
    
    <strong class="source-inline">
     
      npm list
     
    </strong>
    
     command to list the contents of your
    
    
     <strong class="source-inline">
      
       node_modules
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <p>
    
     You may also notice that a
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     file has been created.
    
    
     Files of the
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     type were introduced in
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     version 5.
    
    
     The difference between
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     is that a
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     file defines specific versions of all modules in the
    
    
     <strong class="source-inline">
      
       node_modules
      
     </strong>
    
    
     
      tree.
     
    
   </p>
   <p>
    
     Due to the way dependencies are installed, two developers with the same
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file may experience different results when running
    
    <strong class="source-inline">
     
      npm install
     
    </strong>
    
     .
    
    
     This is mainly because a
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file can specify acceptable
    
    
     
      module ranges.
     
    
   </p>
   <p>
    
     For example, in our
    
    <a id="_idIndexMarker274">
    </a>
    
     recipe, we installed the latest version of
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     , and this resulted in the
    
    
     
      following range:
     
    
   </p>
   <pre class="source-code">
"express": "^4.18.2"</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ^
     
    </strong>
    
     character indicates that it will allow all versions above v4.18.2 to be installed, but not v5.x.x.
    
    
     If v4.18.3 were to be released in the time between when developer A and developer B run the
    
    <strong class="source-inline">
     
      npm install
     
    </strong>
    
     command, then it is likely that developer A will get v4.18.2 and developer B will
    
    
     
      get v4.18.3.
     
    
   </p>
   <p>
    
     If the
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     file is shared between the developers, they will be guaranteed the installation of the same version of
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     and the same versions of all the dependencies
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       express
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI can also generate a
    
    <strong class="source-inline">
     
      npm-shrinkwrap.json
     
    </strong>
    
     file using the
    
    <strong class="source-inline">
     
      npm shrinkwrap
     
    </strong>
    
     command.
    
    
     The
    
    <strong class="source-inline">
     
      npm-shrinkwrap.json
     
    </strong>
    
     file is identical in structure and serves a similar purpose to the
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     file.
    
    
     The
    
    <strong class="source-inline">
     
      package-lock.json
     
    </strong>
    
     file cannot be published to the registry, whereas the
    
    <strong class="source-inline">
     
      npm-shrinkwrap.json
     
    </strong>
    
     can.
    
    
     Typically, when publishing an
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     module, you’ll want to not include the
    
    <strong class="source-inline">
     
      npm-shrinkwrap.json
     
    </strong>
    
     file as it would prevent the module from receiving transitive
    
    
     
      dependency updates.
     
    
   </p>
   <p>
    
     The presence of
    
    <strong class="source-inline">
     
      npm-shrinkwrap.json
     
    </strong>
    
     in a package means that all installs of that package will generate the same dependencies.
    
    
     The
    
    <strong class="source-inline">
     
      npm-shrinkwrap.json
     
    </strong>
    
     file is useful for ensuring consistency across installations in
    
    
     
      production environments.
     
    
   </p>
   <p>
    
     In the final step of the recipe, we imported the
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     module to test whether it was installed
    
    
     
      and accessible:
     
    
   </p>
   <pre class="source-code">
const express = require('express');</pre>
   <p>
    
     Note that this is the same way in which you import Node.js core modules.
    
    
     The module-loading algorithm will first check to see whether you’re requiring a core Node.js module; it will then look in the
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     folder to find the module with
    
    
     
      that name.
     
    
   </p>
   <p>
    
     It is also possible
    
    <a id="_idIndexMarker275">
    </a>
    
     to use
    
    <strong class="source-inline">
     
      require()
     
    </strong>
    
     to import files by passing a path, such as
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
const file = require('./file.j<a id="_idTextAnchor146"/>s');</pre>
   <h2 id="_idParaDest-147">
    <a id="_idTextAnchor147">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Now that we’ve learned a bit about consuming Node.js modules, we’re going to look at development dependencies, global modules, and the considerations you should make when consuming
    
    
     
      Node.js modules.
     
    
   </p>
   <h3>
    
     Understanding development dependencies
    
   </h3>
   <p>
    
     In
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     , you
    
    <a id="_idIndexMarker276">
    </a>
    
     can distinguish between development
    
    <a id="_idIndexMarker277">
    </a>
    
     dependencies and regular dependencies.
    
    <strong class="bold">
     
      Development dependencies
     
    </strong>
    
     are typically used for tooling that supports you in developing
    
    
     
      your application.
     
    
   </p>
   <p>
    
     Development dependencies should not be required to run your application.
    
    
     Having a distinction between dependencies that are required for your application to run and dependencies that are required to develop your application is particularly useful when it comes to deploying your application.
    
    
     Your production application deployment can omit development dependencies, which makes the resulting production application smaller.
    
    
     A very common use of development dependencies is for linting
    
    
     
      and formatting.
     
    
   </p>
   <p>
    
     To install a development dependency, you need to supply the
    
    <strong class="source-inline">
     
      install
     
    </strong>
    
     command with the
    
    <strong class="source-inline">
     
      --save-dev
     
    </strong>
    
     parameter.
    
    
     For example, to install
    
    <strong class="source-inline">
     
      semistandard
     
    </strong>
    
     , we can use
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
$ npm install --save-dev --save-exact semistandard</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      --save-exact
     
    </strong>
    
     parameter pins the exact version in your
    
    
     <strong class="source-inline">
      
       package.json
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     Observe that there is a separate
    
    <a id="_idIndexMarker278">
    </a>
    
     section for development
    
    <a id="_idIndexMarker279">
    </a>
    
     dependencies that have been created
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       package.json
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
{
  "name": "consuming-modules",
  "version": "1.0.0",
  "description": "",
  "main": "require-express.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.2"
  },
<strong class="bold">  "devDependencies": {</strong>
<strong class="bold">    "semistandard": "17.0.0"</strong>
<strong class="bold">  }</strong>
}</pre>
   <p>
    
     You can then execute
    
    <a id="_idIndexMarker280">
    </a>
    
     the installed
    
    <strong class="source-inline">
     
      semistandard
     
    </strong>
    
     executable with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ ./node_modules/semistandard/bin/cmd.js</pre>
   <h3>
    
     Installing global modules
    
   </h3>
   <p>
    
     It is possible to globally
    
    <a id="_idIndexMarker281">
    </a>
    
     install Node.js modules.
    
    
     Typically, the
    
    <a id="_idIndexMarker282">
    </a>
    
     type of modules you’ll install globally are binaries or a program that you want to be accessible in your terminal.
    
    
     To globally install a module, you pass the
    
    <strong class="source-inline">
     
      --global
     
    </strong>
    
     command to the
    
    <strong class="source-inline">
     
      install
     
    </strong>
    
     command
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
$ npm install --global lolcatjs</pre>
   <p>
    
     This will not install
    
    <strong class="source-inline">
     
      lolcatjs
     
    </strong>
    
     into your
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     folder.
    
    
     Instead, it will be installed into the
    
    <strong class="source-inline">
     
      bin
     
    </strong>
    
     directory of your Node.js installation.
    
    
     To see where it was installed, you can use the
    
    <strong class="source-inline">
     
      which
     
    </strong>
    
     command (or
    
    <strong class="source-inline">
     
      where
     
    </strong>
    
     
      on Windows):
     
    
   </p>
   <pre class="console">
$ which lolcatjs
/Users/bgriggs/.nvm/versions/node/v20.11.0/bin/lolcatjs</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      bin
     
    </strong>
    
     directory is likely to already be in your path because that is where the
    
    <strong class="source-inline">
     
      node
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     binaries are stored.
    
    
     Therefore, any executable program that is globally installed will also be made available in your shell.
    
    
     Now, you should be able to call the
    
    <strong class="source-inline">
     
      lolcatjs
     
    </strong>
    
     module from
    
    
     
      your shell:
     
    
   </p>
   <pre class="console">
$ lolcatjs --help</pre>
   <p>
    
     In
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     v5.2,
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     added the
    
    <strong class="source-inline">
     
      npx
     
    </strong>
    
     command to their CLI.
    
    
     This command allows you to execute a global module without having it globally installed on your system.
    
    
     You could execute the
    
    <strong class="source-inline">
     
      lolcatjs
     
    </strong>
    
     module without storing it with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ npx lolcatjs</pre>
   <p>
    
     In general,
    
    <strong class="source-inline">
     
      npx
     
    </strong>
    
     should be sufficient for most modules that you wish to execute.
    
    
     Using
    
    <strong class="source-inline">
     
      npx
     
    </strong>
    
     can be preferable as it enables you to run packages without polluting your global namespace.
    
    
     It can also help when you need to execute different versions of a package on a per-project basis as it avoids any global
    
    
     
      version conflicts.
     
    
   </p>
   <h3>
    
     Responsibly consuming modules
    
   </h3>
   <p>
    
     You’ll likely want to
    
    <a id="_idIndexMarker283">
    </a>
    
     leverage the Node.js module ecosystem in your applications.
    
    
     Modules provide solutions and implementations of common problems and tasks, so reusing existing code can save you time when developing
    
    
     
      your applications.
     
    
   </p>
   <p>
    
     As you saw in the recipe, simply pulling in the web framework,
    
    <strong class="source-inline">
     
      express
     
    </strong>
    
     pulled in over 80 other modules.
    
    
     Pulling in this number of modules adds risk, especially if you’re using these modules for
    
    
     
      production workloads.
     
    
   </p>
   <p>
    
     There are many considerations you should make when choosing a Node.js module to include in your
    
    <a id="_idIndexMarker284">
    </a>
    
     application.
    
    
     The following three considerations should be made
    
    
     
      in particular:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Security
      
     </strong>
     
      : Can you depend on the module to fix security vulnerabilities?
     
     <a href="B19212_09.xhtml#_idTextAnchor274">
      
       <em class="italic">
        
         Chapter 9
        
       </em>
      
     </a>
     
      will go into more detail about how to check for known security issues in
     
     
      
       your modules.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Licenses
      
     </strong>
     
      : If you link with open source libraries and then distribute the software, your software needs to be compliant with the licenses of the linked libraries.
     
     
      Licenses can vary from restrictive/protective to permissive.
     
     
      In GitHub, you can navigate to the license file, and it will give you a basic overview of what the
     
     
      
       license permits:
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 5.1 – GitHub license information" src="img/B19212_05_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.1 – GitHub license information
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Maintenance
      
     </strong>
     
      : You’ll also need to consider how well maintained the module is.
     
     
      Many modules publish their source code to GitHub and have their bug reports viewable as GitHub issues.
     
     
      From viewing their issues and how/when the maintainers are responding to bug reports, you should be able to get some insight into how
     
     <a id="_idIndexMarker285">
     </a>
     
      maintained the
     
     
      
       module is.
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-148">
    <a id="_idTextAnchor148">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Scaffolding a module
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Writing module code
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Publishing a module
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     <em class="italic">
      
       Chapters 6
      
     </em>
     
      
       and
      
     
     
      <em class="italic">
       
        9
       
      </em>
     
    </li>
   </ul>
   <h1 id="_idParaDest-149">
    <a id="_idTextAnchor149">
    </a>
    
     Scaffolding a module
    
   </h1>
   <p>
    
     In this recipe, we’ll be
    
    <a id="_idIndexMarker286">
    </a>
    
     scaffolding our first module; that is, we will set up a typical file and directory structure for our module and learn how to initialize our project with the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI.
    
    
     We’ll also create a GitHub repository to store our module code.
    
    
     GitHub is a hosting provider that allows users to store
    
    <a id="_idIndexMarker287">
    </a>
    
     their
    
    <strong class="bold">
     
      Git
     
    </strong>
    
     -based repositories, where
    
    <a id="_idIndexMarker288">
    </a>
    
     Git is a
    
    <strong class="bold">
     
      version control
     
    </strong>
    
     <strong class="bold">
      
       system
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       VCS
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     The module we’re going to make will expose an API that converts the temperature in Fahrenheit to Celsius and
    
    
     
      vice versa.
     
    
   </p>
   <h2 id="_idParaDest-150">
    <a id="_idTextAnchor150">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     This recipe will require you to have a GitHub account (
    
    <a href="https://github.com/join">
     
      https://github.com/join
     
    </a>
    
     ) to publish source code and an
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     account (
    
    <a href="https://www.npmjs.com/signup">
     
      https://www.npmjs.com/signup
     
    </a>
    
     ) to publish
    
    
     
      your module.
     
    
   </p>
   <h2 id="_idParaDest-151">
    <a id="_idTextAnchor151">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll be using the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI to initialize our
    
    
     <strong class="source-inline">
      
       temperature-converter
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <ol>
    <li>
     
      Let’s create a GitHub repository to store our module code.
     
     
      To do this, you can click
     
     <strong class="bold">
      
       +
      
     </strong>
     
      |
     
     <strong class="bold">
      
       New repository
      
     </strong>
     
      from the GitHub navigation bar or navigate to
     
     <a href="https://github.com/new">
      
       https://github.com/new
      
     </a>
     
      .
     
     
      Specify the repository name as
     
     <strong class="source-inline">
      
       temperature-converter
      
     </strong>
     
      .
     
     
      Note that the repository name does not have to match the
     
     
      
       module name.
      
     
    </li>
    <li>
     
      While you’re here, it’s also recommended to add the default
     
     <strong class="source-inline">
      
       .gitignore
      
     </strong>
     
      file for Node.js and add the license file that matches the license field in
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      .
     
     
      You should expect to see the following GitHub
     
     <strong class="bold">
      
       user interface
      
     </strong>
     
      (
     
     <strong class="bold">
      
       UI
      
     </strong>
     
      ) for
     
     <a id="_idIndexMarker289">
     </a>
     
      creating a
     
     
      
       new repository:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.2 – The GitHub Create a new repository interface" src="img/B19212_05_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.2 – The GitHub Create a new repository interface
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     A
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     file informs Git which files to omit, or ignore, in a project.
    
    
     GitHub provides a default
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     file per language or runtime.
    
    
     GitHub’s default
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     file for Node.js is visible at
    
    <a href="https://github.com/github/gitignore/blob/master/Node.gitignore">
     
      https://github.com/github/gitignore/blob/master/Node.gitignore
     
    </a>
    
     .
    
    
     Note that
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     is automatically added to
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file instructs which modules need to be installed for a project, and it is typically expected that each developer would run the
    
    <strong class="source-inline">
     
      npm install
     
    </strong>
    
     command on their development environment rather than have the
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     directory committed to
    
    
     
      source control.
     
    
   </p>
   <ol>
    <li value="3">
     
      Now the repository is initialized, we can clone the repository using the Git CLI in our shell.
     
     
      Enter the
     
     <a id="_idIndexMarker290">
     </a>
     
      following command to clone the repository, substituting the reference to the repository with your
     
     
      
       GitHub username:
      
     
     <pre class="source-code">
<strong class="bold">$ git clone git@github.com:username/temperature-converter.git</strong>
Cloning into 'temperature-converter'...
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 5 (delta 0), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (5/5), done.</pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     It’s preferred to
    
    <a id="_idIndexMarker291">
    </a>
    
     use
    
    <strong class="bold">
     
      Secure Shell
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SSH
     
    </strong>
    
     ) to clone the repository.
    
    
     If you have not set up your SSH keys for GitHub, then you should follow the steps
    
    
     
      at
     
    
    <a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">
     
      
       https://docs.github.com/en/authentication/connecting-to-github-with-ssh
      
     
    </a>
    
     
      .
     
    
   </p>
   <ol>
    <li value="4">
     
      Change into the newly cloned directory and observe the
     
     
      
       files present:
      
     
     <pre class="source-code">
<strong class="bold">$ cd temperature-converter</strong>
<strong class="bold">$ ls</strong>
LICENSE   README.md</pre>
    </li>
    <li>
     
      You can also run the
     
     <strong class="source-inline">
      
       git status
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       git log
      
     </strong>
     
      commands to see what state
     
     
      
       we’re in:
      
     
     <pre class="source-code">
<strong class="bold">$ git status</strong>
On branch main
Your branch is up to date with 'origin/main'.
nothing to commit, working tree clean</pre>
    </li>
    <li>
     
      Now we’ve created our repository and have a copy locally to work from, we can initialize
     
     
      
       our module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm init</strong></pre>
    </li>
    <li>
     
      You can use
     
     <em class="italic">
      
       Enter
      
     </em>
     
      to accept defaults or complete the values as follows.
     
     
      The command will
     
     <a id="_idIndexMarker292">
     </a>
     
      create a
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      file for you.
     
     
      Open the file and expect to see output like
     
     
      
       the following:
      
     
     <pre class="source-code">
{
  "name": "temperature-converter",
  "version": "0.1.0",
  "description": "Converts temperatures between Fahrenheit and Celsius.",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": [
    "temperature",
    "converter",
    "utility"
  ],
  "author": "Beth Griggs",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/BethGriggs/temperature-converter.git"
  },
  "bugs": {
    "url": "https://github.com/BethGriggs/temperature-converter/issues"
  },
  "homepage": "https://github.com/BethGriggs/temperature-converter#readme"
}</pre>
    </li>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       README.md
      
     </strong>
     
      file and add, and then save, some simple text.
     
     
      For example, you
     
     <a id="_idIndexMarker293">
     </a>
     
      can
     
     <a id="_idIndexMarker294">
     </a>
     
      add a simple heading in
     
     <strong class="bold">
      
       Markdown
      
     </strong>
     
      format:
     
     <strong class="source-inline">
      
       #
      
     </strong>
     
      <strong class="source-inline">
       
        temperature-converter
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Now, we’re going to commit these changes with the
     
     
      
       following commands:
      
     
     <pre class="source-code">
<strong class="bold">$ git add package.json README.md</strong>
<strong class="bold">$ git commit --message "first commit"</strong>
<strong class="bold">$ git push origin main</strong></pre>
     <p class="list-inset">
      
       When this is successful, you should see output like
      
      
       
        the following:
       
      
     </p>
     <pre class="source-code">Enumerating objects: 6, done.
Counting objects: 100% (6/6), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 1020 bytes | 1020.00 KiB/s, done.
Total 4 (delta 1), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:username/temperature-converter.git
   c0f53ef..6d27a2a  main -&gt; main</pre>
    </li>
   </ol>
   <p>
    
     We’ve now seen how to use the Git and
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI to initialize our
    
    
     <strong class="source-inline">
      
       temperature-converter
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <h2 id="_idParaDest-152">
    <a id="_idTextAnchor152">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     To kick off our project, we
    
    <a id="_idIndexMarker295">
    </a>
    
     begin by setting up a GitHub repository, which serves as a central hub for storing and managing our code base.
    
    
     This involves creating a new repository on GitHub, where we’ll store our module code under a specified name – in this case,
    
    <strong class="source-inline">
     
      temperature-converter
     
    </strong>
    
     .
    
    
     Additionally, we take the opportunity to include a
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     file, which informs Git of files to exclude from version control and add a license file, defining how others can use
    
    
     
      our code.
     
    
   </p>
   <p>
    
     Once our repository is established, we clone it locally using the Git CLI.
    
    
     Cloning creates a copy of the repository on our local machine, allowing us to work on the code base offline and push changes back to the remote repository when ready.
    
    
     We navigate into the cloned directory to inspect its contents and review the repository’s status and history using
    
    <strong class="source-inline">
     
      git status
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       git log
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     With our local setup ready, we initialize our module using
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      npm init
     
    </strong>
    
     command guides us through creating a
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file, which contains essential metadata about our project, such as its name, version, and dependencies.
    
    
     This file serves as a blueprint for our module and ensures consistency across
    
    
     
      different environments.
     
    
   </p>
   <p>
    
     To finalize our initial setup, we commit our changes to the repository.
    
    
     This involves staging the
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      README.md
     
    </strong>
    
     files, committing them with a descriptive message, and pushing the changes to the remote repository on GitHub.
    
    
     This step ensures that our
    
    <a id="_idIndexMarker296">
    </a>
    
     project’s history is well documented and that our latest changes
    
    
     
      are published.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Git is a powerful tool that is commonly used for source control of software.
    
    
     If you’re unfamiliar with Git, GitHub provides an interactive guide for you to learn
    
    
     
      at
     
    
    <a href="https://guides.github.com/introduction/flow/">
     
      
       https://guides.github.
      
      
      
      
       com/introduction/flow/
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-153">
    <a id="_idTextAnchor154">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In the recipe, we specified the module version as v0.1.0 to adhere to Semantic Versioning.
    
    
     Let’s look at this in
    
    
     
      more detail.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Semantic Versioning
     
    </strong>
    
     , often
    
    <a id="_idIndexMarker297">
    </a>
    
     abbreviated to
    
    <strong class="bold">
     
      SemVer
     
    </strong>
    
     , is a well-known standard for versioning.
    
    
     Node.js itself tries to adhere to Semantic Versioning as much
    
    
     
      as possible.
     
    
   </p>
   <p>
    
     Semantic version numbers are in the form of
    
    <strong class="source-inline">
     
      X.Y.Z
     
    </strong>
    
     , where the
    
    
     
      following applies:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       X
      
     </strong>
     
      represents the
     
     
      
       major version
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Y
      
     </strong>
     
      represents the
     
     
      
       minor version
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Z
      
     </strong>
     
      represents the
     
     
      
       patch version
      
     
    </li>
   </ul>
   <p>
    
     Briefly, Semantic Versioning states that you increment the major version, the first value, when you make breaking API changes.
    
    
     The second number, the minor version, is incremented when new features have been added in a backward-compatible (or non-breaking) manner.
    
    
     The patch version, or the third number, is for bug fixes and non-breaking and
    
    
     
      non-additive updates.
     
    
   </p>
   <p>
    
     The major version 0 is reserved for initial development, and it is acceptable to make breaking changes up until v1 is released.
    
    
     It is often disputed what the initial version should be.
    
    
     In the recipe, we started with version v0.1.0 to allow us the freedom to make breaking changes in early development without having to increment the major
    
    
     
      version number.
     
    
   </p>
   <p>
    
     Following Semantic Versioning is commonplace in the Node.js module ecosystem.
    
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI takes this into account by allowing
    
    <strong class="source-inline">
     
      semver
     
    </strong>
    
     ranges in
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     – refer to the
    
    <em class="italic">
     
      There’s more…
     
    </em>
    
     section of the
    
    <em class="italic">
     
      Consuming Node.js modules
     
    </em>
    
     recipe or visit
    
    <a href="https://docs.npmjs.com/files/package.json#dependencies">
     
      https://docs.npmjs.com/files/package.json#dependencies
     
    </a>
    
     for more information on
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     
      version ranges.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI provides an API to support Semantic Versioning.
    
    
     The
    
    <strong class="source-inline">
     
      npm version
     
    </strong>
    
     command can be supplied with
    
    <strong class="source-inline">
     
      major
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      minor
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      patch
     
    </strong>
    
     to increment the appropriate version numbers in your
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file.
    
    
     There are further arguments that can be passed
    
    <a id="_idIndexMarker298">
    </a>
    
     to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     version command, including support for pre-versions – refer to
    
    <a href="https://docs.npmjs.com/cli/version">
     
      https://docs.npmjs.com/cli/version
     
    </a>
    
     for
    
    
     
      more information.
     
    
   </p>
   <h2 id="_idParaDest-154">
    <a id="_idTextAnchor155">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Writing module code
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Publishing a module
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-155">
    <a id="_idTextAnchor156">
    </a>
    
     Writing module code
    
   </h1>
   <p>
    
     In this recipe, we’re
    
    <a id="_idIndexMarker299">
    </a>
    
     going to start writing our module code.
    
    
     The module we will write will expose two APIs that will be used to convert the supplied temperature from Fahrenheit to Celsius and vice versa.
    
    
     We’ll also install a popular code formatter to keep our module code consistent and add some simple
    
    
     
      test cases.
     
    
   </p>
   <h2 id="_idParaDest-156">
    <a id="_idTextAnchor157">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Ensure you’re in the
    
    <strong class="source-inline">
     
      temperature-converter
     
    </strong>
    
     folder and that
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     is present, indicating that we have an initialized
    
    
     
      project directory.
     
    
   </p>
   <p>
    
     We’ll also need to create the first JavaScript file for
    
    
     
      our module:
     
    
   </p>
   <pre class="console">
$ touch index.js</pre>
   <p>
    
     Later, we’ll try testing importing and using the module, so let’s create two files ready
    
    
     
      for that:
     
    
   </p>
   <pre class="console">
$ touch test.js</pre>
   <h2 id="_idParaDest-157">
    <a id="_idTextAnchor158">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     We’re going to start this recipe by installing a code formatter to keep our module code styling consistent.
    
    
     By the end of this recipe, we will have created our first
    
    
     
      Node.js module.
     
    
   </p>
   <ol>
    <li>
     
      First, let’s add
     
     <strong class="source-inline">
      
       semistandard
      
     </strong>
     
      as a code formatter for our module.
     
     
      When we know that other users are going to be consuming or contributing to our modules, it’s important to have consistently formatted code
     
     
      
       for consistency:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install --save-dev --save-exact semistandard</strong></pre>
    </li>
    <li>
     
      For the initial implementation of this module, we will expose two APIs – one to be used to convert from Fahrenheit to Celsius which we will name
     
     <strong class="source-inline">
      
       fahrenheitToCelsius()
      
     </strong>
     
      , and another to be used for the opposite conversion named
     
     <strong class="source-inline">
      
       celsiusToFahrenheit()
      
     </strong>
     
      .
     
     
      We’ll be using the known mathematical formula for converting between the two temperature measures.
     
     
      Start by
     
     <a id="_idIndexMarker300">
     </a>
     
      opening
     
     <strong class="source-inline">
      
       index.js
      
     </strong>
     
      and adding the following to define the
     
     
      <strong class="source-inline">
       
        fahrenheitToCelsius()
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
// Convert Fahrenheit to Celsius
function fahrenheitToCelsius(fahrenheit) {
    return (fahrenheit - 32) * 5 / 9;
}</pre>
    </li>
    <li>
     
      Now, we can add the accompanying
     
     <strong class="source-inline">
      
       celsiusToFahrenheit()
      
     </strong>
     
      function to do the
     
     
      
       reverse conversion:
      
     
     <pre class="source-code">
// Convert Celsius to Fahrenheit
function celsiusToFahrenheit(celsius) {
    return (celsius * 9 / 5) + 32;
}</pre>
    </li>
    <li>
     
      Next, we’ll add the key line to the bottom of our file that makes the two
     
     
      
       functions available:
      
     
     <pre class="source-code">
// Export the conversion functions
module.exports = {
    fahrenheitToCelsius,
    celsiusToFahrenheit
};</pre>
    </li>
    <li>
     
      Now, we can test if our small program works from the command line with the
     
     
      
       following commands:
      
     
     <pre class="source-code">
<strong class="bold">$ node --print "require('./').fahrenheitToCelsius(100)"</strong>
37.77777777777778
<strong class="bold">$ node --print "require('./').celsiusToFahrenheit(37)"</strong>
98.6</pre>
    </li>
    <li>
     
      Now, let’s create a simple test file for our module.
     
     
      We’ll use the core
     
     <strong class="source-inline">
      
       assert
      
     </strong>
     
      module to
     
     <a id="_idIndexMarker301">
     </a>
     
      
       implement this:
      
     
     <pre class="source-code">
const assert = require('assert');
const { fahrenheitToCelsius, celsiusToFahrenheit }
  = require('./index');
// Test fahrenheitToCelsius
assert.strictEqual(fahrenheitToCelsius(32), 0, '32°F should be 0');
assert.strictEqual(fahrenheitToCelsius(212), 100, '212°F should be 100');
// Test celsiusToFahrenheit
assert.strictEqual(celsiusToFahrenheit(0), 32, '0°C should be 32');
assert.strictEqual(celsiusToFahrenheit(100), 212, '100°C should be 212');
console.log('All tests passed!');</pre>
     <p class="list-inset">
      
       Observe that we are requiring the module and testing the two temperature
      
      
       
        conversion functions.
       
      
     </p>
    </li>
    <li>
     
      Now, we can run our
     
     
      
       test file:
      
     
     <pre class="source-code">
<strong class="bold">$ node test.js</strong>
All tests passed!</pre>
    </li>
    <li>
     
      Now, let’s define
     
     <strong class="source-inline">
      
       npm run lint
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       npm run test
      
     </strong>
     
      scripts to run our linter and tests respectively.
     
     
      Open the
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      file and replace the
     
     <strong class="source-inline">
      
       scripts
      
     </strong>
     
      property with
     
     
      
       the following:
      
     
     <pre class="source-code">
  "scripts": {
    "lint": "semistandard *.js",
    "test": "node test.js"
  },</pre>
    </li>
    <li>
     
      We can now
     
     <a id="_idIndexMarker302">
     </a>
     
      run the linter with
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      <strong class="source-inline">
       
        run lint
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ npm run lint</strong>
&gt; temperature-converter@0.1.0 lint
&gt; semistandard *.js</pre>
     <p class="list-inset">
      
       If you had any lint issues,
      
      <strong class="source-inline">
       
        semistandard
       
      </strong>
      
       would alert you to these.
      
      
       They can be fixed by running
      
      
       
        the following:
       
      
     </p>
     <pre class="source-code"><strong class="bold">$ npm run lint -- --fix</strong></pre>
    </li>
    <li>
     
      We can also run our tests with the
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      <strong class="source-inline">
       
        test
       
      </strong>
     
     
      
       command:
      
     
     <pre class="source-code">
<strong class="bold">$ npm test</strong>
&gt; temperature-converter@0.1.0 test
&gt; node test.js
All tests passed!</pre>
    </li>
    <li>
     
      Now we’ve implemented, linted, and tested our code, we can commit the updates with Git and push our module code
     
     
      
       to GitHub:
      
     
     <pre class="source-code">
<strong class="bold">$ git add package.json package-lock.json index.js test.js</strong>
<strong class="bold">$ git commit --message 'implement temperature converter, add tests'</strong>
<strong class="bold">$ git push origin main</strong></pre>
    </li>
   </ol>
   <p>
    
     We’ve now created our first module that exposes two APIs and added a test case for
    
    
     
      good measure.
     
    
   </p>
   <h2 id="_idParaDest-158">
    <a id="_idTextAnchor159">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     To ensure consistency
    
    <a id="_idIndexMarker303">
    </a>
    
     and readability in our module’s code base, we begin by incorporating a popular code formatter,
    
    <strong class="source-inline">
     
      semistandard
     
    </strong>
    
     , as part of our development workflow.
    
    
     This ensures that our code follows a standardized style, making it easier for other developers to understand and collaborate on
    
    
     
      our project.
     
    
   </p>
   <p>
    
     With
    
    <strong class="source-inline">
     
      semistandard
     
    </strong>
    
     installed as a development dependency, we proceed to implement the core functionality of our module.
    
    
     We define two conversion functions,
    
    <strong class="source-inline">
     
      fahrenheitToCelsius()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      celsiusToFahrenheit()
     
    </strong>
    
     , leveraging well-known mathematical formulas for temperature conversion.
    
    
     These functions are encapsulated within our
    
    <strong class="source-inline">
     
      index.js
     
    </strong>
    
     file, making them accessible for use within
    
    
     
      our module.
     
    
   </p>
   <p>
    
     To expose these conversion functions externally, we add an
    
    <strong class="source-inline">
     
      export
     
    </strong>
    
     statement at the bottom of our file, allowing other modules to import and utilize them as needed.
    
    
     This establishes a clear interface for interacting with our
    
    
     
      module’s functionality.
     
    
   </p>
   <p>
    
     To validate the correctness of our implementation, we create a simple test file,
    
    <strong class="source-inline">
     
      test.js
     
    </strong>
    
     , using Node.js’s built-in
    
    <strong class="source-inline">
     
      assert
     
    </strong>
    
     module.
    
    
     This file contains test cases for each conversion function, ensuring that they produce the expected results under various
    
    
     
      input conditions.
     
    
   </p>
   <p>
    
     Upon running the test file, we confirm that all tests pass, indicating that our module’s functionality behaves as intended.
    
    
     We then enhance our development workflow by defining
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     scripts for linting and testing, streamlining the process of code formatting
    
    
     
      and validation.
     
    
   </p>
   <p>
    
     Running
    
    <strong class="source-inline">
     
      npm run lint
     
    </strong>
    
     checks our code base for adherence to coding standards, while
    
    <strong class="source-inline">
     
      npm test
     
    </strong>
    
     executes our test suite to verify the correctness of our implementation.
    
    
     Any deviations from the coding standards or failing tests are highlighted for resolution.
    
    
     It is possible to create as many custom scripts as is suitable for
    
    
     
      your project.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI supports many shortcuts.
    
    
     For example,
    
    <strong class="source-inline">
     
      npm install
     
    </strong>
    
     can be shortened to
    
    <strong class="source-inline">
     
      npm i
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      npm test
     
    </strong>
    
     command can be shortened to
    
    <strong class="source-inline">
     
      npm t
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      npm run-script
     
    </strong>
    
     command can be shortened to
    
    <strong class="source-inline">
     
      npm run
     
    </strong>
    
     .
    
    
     For more details, refer to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI
    
    
     
      documentation:
     
    
    <a href="https://docs.npmjs.com/cli-documentation/cli">
     
      
       https://docs.npmjs.com/cli-documentation/cli
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Finally, with our
    
    <a id="_idIndexMarker304">
    </a>
    
     code base implemented, validated, and organized, we commit our changes using Git and push them to our GitHub repository.
    
    
     This ensures that our project’s history is well documented and that our latest updates are available
    
    
     
      to collaborators.
     
    
   </p>
   <h2 id="_idParaDest-159">
    <a id="_idTextAnchor160">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Publishing a module
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     <a href="B19212_08.xhtml#_idTextAnchor243">
      
       <em class="italic">
        
         Chapter 8
        
       </em>
      
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-160">
    <a id="_idTextAnchor161">
    </a>
    
     Publishing a module
    
   </h1>
   <p>
    
     This recipe will walk you
    
    <a id="_idIndexMarker305">
    </a>
    
     through how to prepare and publish your module to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry.
    
    
     Publishing your module to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry will make it available for other developers to find and include in their applications.
    
    
     This is how the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     ecosystem operates: developers will author and publish modules to
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     for other developers to consume and reuse in their
    
    
     
      Node.js application.
     
    
   </p>
   <p>
    
     In the recipe, we will be publishing the
    
    <strong class="source-inline">
     
      temperature-converter
     
    </strong>
    
     module that we created in the
    
    <em class="italic">
     
      Writing module code
     
    </em>
    
     recipe of this chapter to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry.
    
    
     Specifically, we’ll be publishing our module to a scoped namespace, so you can expect your module to be available
    
    
     
      at
     
    
    
     <strong class="source-inline">
      
       @npmusername/temperature-converter
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-161">
    <a id="_idTextAnchor162">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     This recipe relies on the
    
    <em class="italic">
     
      Writing module code
     
    </em>
    
     recipe of this chapter.
    
    
     We will be publishing the
    
    <strong class="source-inline">
     
      temperature-converter
     
    </strong>
    
     module that we created in that recipe to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry.
    
    
     You can obtain the module code from the
    
    <em class="italic">
     
      Writing module code
     
    </em>
    
     recipe from the GitHub repository
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter05/temperature-converter">
     
      
       https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter05/temperature-converter
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     This recipe also will require you to have an
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     account.
    
    
     Go to
    
    <a href="https://www.npmjs.com/signup">
     
      https://www.npmjs.com/signup
     
    </a>
    
     to sign up for an account.
    
    
     Keep note of your
    
    
     <strong class="source-inline">
      
       npm
      
     </strong>
    
    
     
      username.
     
    
   </p>
   <h2 id="_idParaDest-162">
    <a id="_idTextAnchor163">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     This recipe will
    
    <a id="_idIndexMarker306">
    </a>
    
     walk through the process of publishing a module to the
    
    
     <strong class="source-inline">
      
       npm
      
     </strong>
    
    
     
      registry.
     
    
   </p>
   <ol>
    <li>
     
      Once you have signed up for an
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      account, you can authorize your
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      client with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ npm login</strong>
npm notice Log in on https://registry.npmjs.org/
Login at:
https://www.npmjs.com/login?next=/login/cli/{UUID}
Press ENTER to open in the browser...
Logged in on https://registry.npmjs.org/.</pre>
    </li>
    <li>
     
      Let’s update the
     
     <strong class="source-inline">
      
       README.md
      
     </strong>
     
      file that was automatically created for us when we initialized the GitHub repository in the
     
     <em class="italic">
      
       Scaffolding a module
      
     </em>
     
      recipe.
     
     
      Having an appropriate and clear
     
     <strong class="source-inline">
      
       README.md
      
     </strong>
     
      file is important so that users who stumble upon the module can understand what it does and whether it suits their use case.
     
     
      Open the
     
     <strong class="source-inline">
      
       README.md
      
     </strong>
     
      file in your editor and update the following, remembering
     
     <a id="_idIndexMarker307">
     </a>
     
      to change the
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      username to
     
     
      
       your own:
      
     
     <pre class="source-code">
# Temperature Converter Module
 A simple Node.js module for converting temperatures between Fahrenheit and Celsius.
# Example usage
```js
const { fahrenheitToCelsius, celsiusToFahrenheit }
  = require('@npmusername/temperature-converter');
const celsius = fahrenheitToCelsius(100);
console.log(`100°F is ${celsius}°C`);
const fahrenheit = celsiusToFahrenheit(37);
console.log(`37°C is ${fahrenheit}°F`);
```
# Running Tests
 To run tests and ensure the module is working as expected, navigate to the module's root directory and execute:
```sh
$ npm run test
```
# License
This project is licensed under the MIT License.</pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      README
     
    </strong>
    
     file we’ve just created is written using Markdown.
    
    
     The
    
    <strong class="source-inline">
     
      .md
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      .MD
     
    </strong>
    
     ending indicates that it is a Markdown file.
    
    
     Markdown is a documentation syntax that is commonly used across GitHub.
    
    
     To learn more about Markdown, check out GitHub’s guide at
    
    <a href="https://guides.github.com/features/mastering-markdown/">
     
      https://guides.github.com/features/mastering-markdown/
     
    </a>
    
     .
    
    
     Many of the popular editors have plugins available so that you can render Markdown in
    
    
     
      your editor.
     
    
   </p>
   <ol>
    <li value="3">
     
      Now, we need to update the name of our module in the
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      file to match our scoped module name.
     
     
      Let’s also make this version
     
     <strong class="source-inline">
      
       1.0.0
      
     </strong>
     
      of the module.
     
     
      You can either manually edit
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      or rerun the
     
     <strong class="source-inline">
      
       npm init
      
     </strong>
     
      command to
     
     <a id="_idIndexMarker308">
     </a>
     
      overwrite it with any new values.
     
     
      Remember to change the
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      username to
     
     
      
       your own:
      
     
     <pre class="source-code">
{
  "name": "@npmusername/temperature-converter",
  "version": "1.0.0",
  "description": "Converts temperatures between Fahrenheit and Celsius.",
  "main": "index.js",
  "scripts": {
    "lint": "semistandard *.js",
    "test": "node test.js"
  },
  "keywords": [
    "temperature",
    "converter",
    "utility"
  ],
  "author": "Forename Surname",
  "license": "MIT",
  "devDependencies": {
    "semistandard": "17.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/username/temperature-converter.git"
  },
  "bugs": {
    "url": "https://github.com/username/te<a id="_idTextAnchor164"/>mperature-converter/issues"
  },
  „homepage": „https://github.com/username/temperature-converter#readme"
}</pre>
    </li>
    <li>
     
      It is ideal to keep
     
     <a id="_idIndexMarker309">
     </a>
     
      your public GitHub repository up to date.
     
     
      Typically, module authors will create a tag on GitHub that matches the version that is pushed to
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      .
     
     
      This can act as an audit trail for users wishing to see the source code of the module at a particular version, without having to download it via
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      .
     
     
      However, please note that nothing is enforcing that the code you publish to
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      must match the code you publish
     
     
      
       to GitHub:
      
     
     <pre class="source-code">
<strong class="bold">$ git add .</strong>
<strong class="bold">$ git commit --message "v1.0.0"</strong>
<strong class="bold">$ git push origin main</strong>
<strong class="bold">$ git tag v1.0.0</strong>
<strong class="bold">$ git push origin v1.0.0</strong></pre>
    </li>
    <li>
     
      Now, we’re ready to publish our module to the
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      registry using the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ npm publish --access=public</strong></pre>
    </li>
    <li>
     
      You can check that your publish was successful by navigating to
     
     <a href="https://www.npmjs.com/package/@npmusername/temperature-converter">
      
       https://www.npmjs.com/package/@npmusername/temperature-converter
      
     </a>
     
      .
     
     
      Expect to see
     
     <a id="_idIndexMarker310">
     </a>
     
      the following information about
     
     
      
       your module:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 5.3 – npm module information on npmjs.com" src="img/B19212_05_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.3 – npm module information on npmjs.com
    
   </p>
   <h2 id="_idParaDest-163">
    <a id="_idTextAnchor165">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We first authenticated our local
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     client using the
    
    <strong class="source-inline">
     
      npm login
     
    </strong>
    
     command.
    
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     client provides the ability to set up access controls so that certain users can publish to specific modules
    
    
     
      or scopes.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      npm login
     
    </strong>
    
     command identifies who you are and where you’re entitled to publish.
    
    
     It is also possible to log out using
    
    
     <strong class="source-inline">
      
       npm logout
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The command that did the actual publishing to the registry was
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
$ npm publish --access=public</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      npm publish
     
    </strong>
    
     command attempts to publish the package at the location identified by the
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     field in the
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file.
    
    
     In the recipe, we published it to a scoped package – specifically, we used our own username’s scope.
    
    
     Scoped packages help to avoid naming conflicts.
    
    
     It is possible to publish your package to the global scope by not passing it a named scope – but you’re likely to run into name conflicts if your package has a
    
    
     
      common name.
     
    
   </p>
   <p>
    
     We also passed the
    
    <strong class="source-inline">
     
      --access=public
     
    </strong>
    
     flag.
    
    
     When publishing to a scoped package, we explicitly need
    
    <a id="_idIndexMarker311">
    </a>
    
     to indicate that we want the module to be public.
    
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI allows you to publish your modules as either public or private for scoped packages.
    
    
     To publish a module privately, you need to have a paid
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     account.
    
    
     Note that the
    
    <strong class="source-inline">
     
      --access=public
     
    </strong>
    
     flag is not required when publishing to the global scope because all modules in the global namespace
    
    
     
      are public.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      npm publish
     
    </strong>
    
     command packaged up our module code and uploaded it to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry.
    
    
     Because the
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file generated from the
    
    <strong class="source-inline">
     
      npm init
     
    </strong>
    
     command is generated with consistent properties,
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     can extract and render that information on the module’s page.
    
    
     As shown in the recipe,
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     automatically populated the
    
    <strong class="source-inline">
     
      README
     
    </strong>
    
     file, version, and GitHub links in the UI based on the
    
    <a id="_idTextAnchor166">
    </a>
    
     information in our
    
    
     <strong class="source-inline">
      
       package.json
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <h2 id="_idParaDest-164">
    <a id="_idTextAnchor167">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Next, we’ll consider prepublish scripts and the
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     file and look at how to publish to
    
    
     
      private registries.
     
    
   </p>
   <h3>
    
     Using prepublish scripts
    
   </h3>
   <p>
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI
    
    <a id="_idIndexMarker312">
    </a>
    
     supports a
    
    <strong class="source-inline">
     
      prepublishOnly
     
    </strong>
    
     script.
    
    
     This script will only run before the module is packaged
    
    <a id="_idIndexMarker313">
    </a>
    
     and published.
    
    
     This is useful for catching mistakes before publishing.
    
    
     Should a mistake be made, it may be necessary to publish a second version to correct this mistake, causing potentially avoidable inconvenience to your
    
    
     
      module consumers.
     
    
   </p>
   <p>
    
     Let’s add a
    
    <strong class="source-inline">
     
      prepublishOnly
     
    </strong>
    
     script to our module.
    
    
     Our
    
    <strong class="source-inline">
     
      prepublishOnly
     
    </strong>
    
     script will just run our
    
    <strong class="source-inline">
     
      lint
     
    </strong>
    
     script for now.
    
    
     Add a
    
    <strong class="source-inline">
     
      prepublishOnly
     
    </strong>
    
     script
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
  "scripts": {
    "prepublishOnly": "npm run lint",
    "lint": "semistandard *.js",
    "test": "node test.js"
  }</pre>
   <p>
    
     Typically, module authors will include rerunning their test suite in their
    
    
     <strong class="source-inline">
      
       prepublishOnly
      
     </strong>
    
    
     
      scripts:
     
    
   </p>
   <pre class="console">
"prepublishOn<a id="_idTextAnchor168"/>ly": "npm run lint &amp;&amp; npm test",</pre>
   <h3>
    
     Using .npmignore and package.json “files” properties
    
   </h3>
   <p>
    
     As with a
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     file, which
    
    <a id="_idIndexMarker314">
    </a>
    
     specifies
    
    <a id="_idIndexMarker315">
    </a>
    
     which files
    
    <a id="_idIndexMarker316">
    </a>
    
     should not
    
    <a id="_idIndexMarker317">
    </a>
    
     be tracked or committed to a repository,
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     omits the files listed in it from the package.
    
    
     Files of the
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     type are not mandatory, and if you do not have one but do have a
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     file, then
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     will omit the files and directories matched by the
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     file.
    
    
     The
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     file will override
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     if such a
    
    
     
      file exists.
     
    
   </p>
   <p>
    
     The types of files and directories that are often added to
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     files are test files.
    
    
     If you have a particular large test suite in terms of size, then you should consider excluding these files by adding them to your
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     file.
    
    
     Users consuming your module do not tend to need the test suite bundled into their applications – excluding these and other superfluous files reduces the size of your module for
    
    
     
      all consumers.
     
    
   </p>
   <p>
    
     A
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     file that excludes just the
    
    <strong class="source-inline">
     
      test
     
    </strong>
    
     directory would look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
# Dependency directories
test/</pre>
   <p>
    
     Remember that once the
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     file is created, it will be considered the
    
    <strong class="bold">
     
      source of truth
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SOT
     
    </strong>
    
     ) of which files
    
    <a id="_idIndexMarker318">
    </a>
    
     should be ignored from the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     package.
    
    
     It’s worth going through your
    
    <strong class="source-inline">
     
      .gitignore
     
    </strong>
    
     file and ensuring items that you’ve added there are also added
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       .npmignore
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file, you can also define a
    
    <strong class="source-inline">
     
      "files"
     
    </strong>
    
     property that allows you to specify an array of file paths or patterns that should be included when the package is published.
    
    
     Rather than an exclusion list, this acts as an inclusion list for what
    
    
     
      is published.
     
    
   </p>
   <p>
    
     For instance, if you have a Node.js module containing various utility functions, but you only want to expose the main functionality and documentation, you can specify “
    
    <strong class="source-inline">
     
      files": ["lib/", "docs/", "README.md"]
     
    </strong>
    
     in your
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file.
    
    
     This ensures that only the files within the specified directories and the
    
    <strong class="source-inline">
     
      README.md
     
    </strong>
    
     file are included when users install your package, while all other internal files or directories are excluded from the
    
    
     
      published package.
     
    
   </p>
   <p>
    
     Providing an allow list by defining
    
    <strong class="source-inline">
     
      "files"
     
    </strong>
    
     in the
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file rather than an exclusion list with
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     may be preferable as it removes the risk of forgetting to exclude a file in the
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       npmignore
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     To ensure
    
    <a id="_idIndexMarker319">
    </a>
    
     that
    
    <a id="_idIndexMarker320">
    </a>
    
     your
    
    <a id="_idIndexMarker321">
    </a>
    
     package
    
    <a id="_idIndexMarker322">
    </a>
    
     includes only the desired files upon publication, you can execute the
    
    <strong class="source-inline">
     
      npm pack
     
    </strong>
    
     command in your local environment.
    
    
     This command creates a tarball in your current working directory, mirroring the process used
    
    
     
      for publishing.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     While TypeScript and other transpilers are not covered in detail in this book, it is typical when publishing to
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     to only publish the output files, such as JavaScript files, and not the source files, such as TypeScript files.
    
    
     This practice ensures that the package consumers receive only the necessary files to run the module.
    
    
     To achieve this, you can use the
    
    <strong class="source-inline">
     
      .npmignore
     
    </strong>
    
     file or the
    
    <strong class="source-inline">
     
      "files"
     
    </strong>
    
     property in
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     to exclude source files and include only the
    
    
     
      compiled output.
     
    
   </p>
   <h3>
    
     Private registries
    
   </h3>
   <p>
    
     The
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     CLI supports
    
    <a id="_idIndexMarker323">
    </a>
    
     being configured to point to a
    
    <strong class="bold">
     
      private registry
     
    </strong>
    
     .
    
    
     A private
    
    <a id="_idIndexMarker324">
    </a>
    
     registry is a registry that has been set up with some form of access control.
    
    
     Typically, these are set up by businesses and organizations that wish to keep some of their code off the public registry, potentially due to policy restrictions determined by their business.
    
    
     This enables the business to share its modules among members of the same organization while adhering to the business policy.
    
    
     Equally, a private registry can be used as a
    
    
     
      caching mechanism.
     
    
   </p>
   <p>
    
     You can change which registry you’re pointing to with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ npm config set registry https://registry.your-registry.npme.io/</pre>
   <p>
    
     You can see which registry you’re pointing to with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ npm config get registry
https://registry.npmjs.org/</pre>
   <p>
    
     Note that these both use the
    
    <strong class="source-inline">
     
      npm config
     
    </strong>
    
     command.
    
    
     You can list all your
    
    <strong class="source-inline">
     
      npm config
     
    </strong>
    
     settings with
    
    <a id="_idIndexMarker325">
    </a>
    
     
      the following:
     
    
   </p>
   <pre class="console">
$ npm config list
; "user" config from /Users/bgriggs/.npmrc
; node bin location = /Users/bgriggs/.nvm/versions/node/v22.9.0/bin/node
; node version = v22.9.0
; npm local prefix = /Users/bgriggs/Node.js-Cookbook/Chapter05/temperature-converter
; npm version = 10.2.4
; cwd = /Users/bgriggs/Node.js-Cookbook/Chapter05/temperature-converter
; HOME = /Users/bgriggs
; Run `npm config ls -l` to show all defaults</pre>
   <p>
    
     A
    
    <strong class="source-inline">
     
      .npmrc
     
    </strong>
    
     file is a configuration file for
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     that can be used to set various
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     configurations globally or on a per-project basis.
    
    
     This file allows you to persistently configure
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     settings, such as registry URLs and authentication tokens.
    
    
     For example, to point
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     to a private registry, you can add the following line to a
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       npmrc
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
registry= https://registry.your-registry.npme.io/</pre>
   <p>
    
     There are many other configurable settings and customizations in this file; refer to the
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     documentation
    
    <a id="_idIndexMarker326">
    </a>
    
     for
    
    <a id="_idIndexMarker327">
    </a>
    
     more
    
    
     
      information:
     
    
    <a href="https://docs.npmjs.com/cli/v10/configuring-npm/npmrc">
     
      
       https://docs.npmjs.com/cli/v10/configuring-npm/npmrc
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-165">
    <a id="_idTextAnchor169">
    </a>
    
     Using ECMAScript modules
    
   </h1>
   <p>
    
     ESM represents
    
    <a id="_idIndexMarker328">
    </a>
    
     the official standard for packaging JavaScript code for reuse.
    
    
     ESM was introduced in
    
    <strong class="bold">
     
      ECMAScript 2015
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ES6
     
    </strong>
    
     ) to bring
    
    <a id="_idIndexMarker329">
    </a>
    
     a unified module system to the JavaScript language, a featu
    
    <a id="_idTextAnchor170">
    </a>
    
     re that was absent and in much demand for years.
    
    
     Unlike
    
    <strong class="bold">
     
      CommonJS
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CJS
     
    </strong>
    
     ) modules, which were adopted by Node.js for server-side
    
    <a id="_idIndexMarker330">
    </a>
    
     development, ESM provides a way to statically analyze code for imports and exports, allowing for optimizations such as tree shaking, which eliminates
    
    
     
      unused code.
     
    
   </p>
   <p>
    
     The introduction of ESM into the Node.js ecosystem marked a significant milestone, offering developers the benefits of a standardized module system that is compatible across different environments, including browsers, where modules can be natively loaded without the need for
    
    
     
      bundling tools.
     
    
   </p>
   <p>
    
     Configuring Node.js to use ESM involves understanding and setting up project structures to accommodate the new syntax and module resolution strategy.
    
    
     By default, Node.js treats
    
    <strong class="source-inline">
     
      .js
     
    </strong>
    
     files as CJS modules, but with the inclusion of a
    
    <strong class="source-inline">
     
      "type": "module"
     
    </strong>
    
     entry in a project’s
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file, Node.js switches to treating files with the
    
    <strong class="source-inline">
     
      .js
     
    </strong>
    
     extension
    
    
     
      as ESM.
     
    
   </p>
   <p>
    
     Alternatively, developers can use the
    
    <strong class="source-inline">
     
      .mjs
     
    </strong>
    
     extension for JavaScript files intended to be treated as modules.
    
    
     This setup phase is crucial as it lays the foundation for importing and exporting modules using the
    
    <strong class="source-inline">
     
      import
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      export
     
    </strong>
    <a id="_idTextAnchor171">
    </a>
    
     keywords, respectively, moving away from the
    
    <strong class="source-inline">
     
      require
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      module.exports
     
    </strong>
    
     syntax of CJS.
    
    
     The enablement of ESM in Node.js not only aligns server-side development with frontend practices but also opens new possibilities for code sharing and modularization across the
    
    
     
      JavaScript ecosystem.
     
    
   </p>
   <h2 id="_idParaDest-166">
    <a id="_idTextAnchor172">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     The core ESM support is enabled by default and designated with stable status in all currently supported Node.js versions.
    
    
     However, some individual ESM capabilities
    
    
     
      remain experimental.
     
    
   </p>
   <p>
    
     In this recipe, we will create a mini-project that calculates various geometric shapes’ areas and perimeters.
    
    
     This recipe will serve as an introduction to using ESM in Node.js and demonstrate the use of named and
    
    
     
      default exports.
     
    
   </p>
   <p>
    
     To get started, ensure you’re using Node.js 22 and create a directory to
    
    
     
      work in:
     
    
   </p>
   <pre class="console">
$ mkdir ecmascript-modules
$ cd ecmascript-modules</pre>
   <p>
    
     We will also prepare some files for our geometric
    
    
     
      shape modules:
     
    
   </p>
   <pre class="console">
$ touch index.js circle.js rectangle.js</pre>
   <h2 id="_idParaDest-167">
    <a id="_idTextAnchor173">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll
    
    <a id="_idIndexMarker331">
    </a>
    
     create modules for calculating the area and perimeter of geometric shapes such as circles and rectangles.
    
    
     We will also create a utility
    
    
     
      for rounding.
     
    
   </p>
   <ol>
    <li>
     
      First, we need to initialize our module.
     
     
      For this recipe, we’ll just accept
     
     
      
       the defaults:
      
     
     <pre class="source-code">
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      Now, as we plan to use ESM syntax throughout, we should set the
     
     <strong class="source-inline">
      
       "type": "module"
      
     </strong>
     
      entry in the
     
     
      <strong class="source-inline">
       
        package.json
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
{
  "name": "ecmascript-modules",
  "version": "1.0.0",
  "description": "",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}</pre>
    </li>
    <li>
     
      Now, let’s create a
     
     <em class="italic">
      
       circle module
      
     </em>
     
      .
     
     
      This module will use a default
     
     <strong class="source-inline">
      
       export
      
     </strong>
     
      statement for the main function – which is to calculate the area.
     
     
      It will also expose a function to calculate the circumference of the circle as a named export.
     
     
      Add the following
     
     <a id="_idIndexMarker332">
     </a>
     
      code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        circle.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const PI = Math.PI;
function area(radius) {
  return PI * radius * radius;
}
function circumference(radius) {
  return 2 * PI * radius;
}
export default area;
export { circumference };</pre>
     <p class="list-inset">
      
       Note that we are making use of the
      
      <strong class="source-inline">
       
        Math
       
      </strong>
      
       namespace object for the value
      
      
       
        of Pi.
       
      
     </p>
    </li>
    <li>
     
      Next, we’ll create a
     
     <em class="italic">
      
       rectangle module
      
     </em>
     
      (
     
     <strong class="source-inline">
      
       rectangle.js
      
     </strong>
     
      ).
     
     
      This module will export area and perimeter functions but this time using only named exports.
     
     
      Add the following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        rectangle.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
function area(length, width) {
  return length * width;
}
function perimeter(length, width) {
  return 2 * (length + width);
}
export { area, perimeter };</pre>
    </li>
    <li>
     
      Next, we’ll implement a small
     
     <em class="italic">
      
       mathematical utility
      
     </em>
     
      .
     
     
      We’ll just add one function that rounds
     
     <a id="_idIndexMarker333">
     </a>
     
      values.
     
     
      Create a file
     
     
      
       called
      
     
     
      <strong class="source-inline">
       
        mathUtils.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch mathUtils.js</strong></pre>
    </li>
    <li>
     
      Add the following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        mathUtils.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
export function round(number, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(number * factor) / factor;
}</pre>
    </li>
    <li>
     
      Finally, we’ll implement the
     
     <em class="italic">
      
       main module
      
     </em>
     
      (
     
     <strong class="source-inline">
      
       index.js
      
     </strong>
     
      ).
     
     
      This module will import and use the functions from the geometry modules and the utility module.
     
     
      This module will demonstrate the various ways in which we
     
     
      
       can import:
      
     
     <pre class="source-code">
import circleArea, { circumference } from './circle.js';
import * as rectangle from './rectangle.js';
import { round } from './mathUtils.js';
function calculateCircleMetrics(radius) {
  console.log(`Circle with radius ${radius}:`);
  console.log(`Area: ${round(circleArea(radius),
    2)}`);
  console.log(`Circumference:
    ${round(circumference(radius), 2)}`);
}
function calculateRectangleMetrics(length, width) {
  console.log(`\nRectangle with length ${length}
    and width ${width}:`);
  console.log(`Area: ${round(rectangle.area(length,
    width), 2)}`);
  console.log(`Perimeter:
    ${round(rectangle.perimeter(length, width),
    2)}`);
}
calculateCircleMetrics(5);
calculateRectangleMetrics(10, 5);</pre>
     <p class="list-inset">
      
       This module demonstrates
      
      <a id="_idIndexMarker334">
      </a>
      
       importing a default export without braces, named exports with braces, and importing all named exports from a module as an object using the
      
      <strong class="source-inline">
       
        import *
       
      </strong>
      
       <strong class="source-inline">
        
         as
        
       </strong>
      
      
       
        syntax.
       
      
     </p>
    </li>
    <li>
     
      Execute your application by running
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">$ node index.js</strong>
Circle with radius 5:
Area: 78.54
Circumference: 31.42
Rectangle with length 10 and width 5:
Area: 50
Perimeter: 30</pre>
     <p class="list-inset">
      
       You should see calculated metrics for a circle and a rectangle, showcasing how to use both default and named exports in a modular
      
      
       
        Node.js application.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     This project illustrates the flexibility and efficiency of using ESM for organizing and structuring JavaScript code in Node.js projects.
    
    
     Through the example of calculating geometric shapes’ metrics, we’ve seen how to properly use default and named exports to make our code
    
    <a id="_idIndexMarker335">
    </a>
    
     modular
    
    
     
      and reusable.
     
    
   </p>
   <h2 id="_idParaDest-168">
    <a id="_idTextAnchor174">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The tutorial is structured around the concept of modular programming using ESM in a Node.js environment.
    
    
     The primary goal of the recipe is to demonstrate how ESM can be leveraged to build a well-organized, maintainable, and scalable project.
    
    
     We achieve this through the development of a small application designed to calculate the area and perimeter of
    
    
     
      geometric shapes.
     
    
   </p>
   <p>
    
     The project is initiated as a standard Node.js application with a
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file.
    
    
     By setting
    
    <strong class="source-inline">
     
      "type": "module"
     
    </strong>
    
     in the
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file, we instruct Node.js to treat files with the
    
    <strong class="source-inline">
     
      .js
     
    </strong>
    
     extension as
    
    
     
      ESM files.
     
    
   </p>
   <p>
    
     The geometry calculations are divided into separate modules for each shape.
    
    
     This modular approach demonstrates the concept of single responsibility, where each module is tasked with a specific set of functionalities related to a particular geometric shape.
    
    
     This approach will be familiar to those who have worked with other
    
    <strong class="bold">
     
      object-oriented programming
     
    </strong>
    
     (
    
    <strong class="bold">
     
      OOP
     
    </strong>
    
     ) languages
    
    <a id="_idIndexMarker336">
    </a>
    
     such
    
    
     
      as Java.
     
    
   </p>
   <p>
    
     For the circle module (
    
    <strong class="source-inline">
     
      circle.js
     
    </strong>
    
     ), we implemented functions to calculate the area (exposed as the default export) and circumference (exposed as a named export) of a circle.
    
    
     The use of a default export for the primary function illustrates how to expose a module’s main functionality, while named exports tend to be used for
    
    
     
      secondary functions.
     
    
   </p>
   <p>
    
     For the rectangle module (
    
    <strong class="source-inline">
     
      rectangle.js
     
    </strong>
    
     ), we only included named exports for functions calculating the area and perimeter of a rectangle.
    
    
     The use of named exports highlights how multiple related functionalities can be grouped within a single module and
    
    
     
      exported individually.
     
    
   </p>
   <p>
    
     We introduced a utility module (
    
    <strong class="source-inline">
     
      mathUtils.js
     
    </strong>
    
     ) to perform rounding operations.
    
    
     This module’s existence emphasizes the utility of having shared functionalities abstracted into their modules, making them reusable across
    
    
     
      a project.
     
    
   </p>
   <p>
    
     The main module,
    
    <strong class="source-inline">
     
      index.js
     
    </strong>
    
     , serves as the entry point to the application.
    
    
     It dynamically imports the geometry modules and the utility module, using their functionalities to perform calculations based on user input or predefined values.
    
    
     While a simplified example, it
    
    <a id="_idIndexMarker337">
    </a>
    
     demonstrates how to import both default and named exports from modules, highli
    
    <a id="_idTextAnchor175">
    </a>
    
     ghting the versatility of ESM in handling various
    
    
     
      export types.
     
    
   </p>
   <h2 id="_idParaDest-169">
    <a id="_idTextAnchor176">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     CJS remains widely used in Node.js applications due to its long history in the vast ecosystem of
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     modules.
    
    
     ESM is being increasingly adopted for new projects due to its native browser support, module optimization capabilities, and alignment with the
    
    
     
      ECMAScript standard.
     
    
   </p>
   <p>
    
     Understanding these differences is critical for developers navigating the Node.js and wider JavaScript ecosystem, especially when working on applications and projects that may require integrating both
    
    
     
      module types.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     In the current state of Node.js development, developers often have to navigate both module systems.
    
    
     Therefore, some recipes in subsequent chapters of this book will utilize the ESM syntax.
    
    
     In some cases, this is required due to certain
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     modules now exclusively
    
    
     
      supporting ESM.
     
    
   </p>
   <h3>
    
     Differences between CJS and ESM
    
   </h3>
   <p>
    
     The differences
    
    <a id="_idIndexMarker338">
    </a>
    
     between CJS and ESM in Node.js are
    
    <a id="_idIndexMarker339">
    </a>
    
     foundational to
    
    <a id="_idIndexMarker340">
    </a>
    
     understanding how to effectively use modules in JavaScript applications.
    
    
     Let’s take a closer look
    
    
     
      at these:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table002-1">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           CJS
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           ESM
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Uses
        
        <strong class="source-inline">
         
          require()
         
        </strong>
        
         for importing modules and
        
        <strong class="source-inline">
         
          module.exports
         
        </strong>
        
         or
        
        <strong class="source-inline">
         
          exports
         
        </strong>
        
         
          for exporting.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Uses the
        
        <strong class="source-inline">
         
          import
         
        </strong>
        
         and
        
        <strong class="source-inline">
         
          export
         
        </strong>
        
         statements for importing and
        
        
         
          exporting modules.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Loads
        
        
         
          modules synchronously.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Supports asynchronous loading, allowing for dynamic
        
        
         <strong class="source-inline">
          
           import()
          
         </strong>
        
        
         
          statements.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Supports non-static, runtime module resolution allowing for conditional imports based on
        
        
         
          runtime conditions.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Static structure enables
        
        <strong class="source-inline">
         
          import
         
        </strong>
        
         /
        
        <strong class="source-inline">
         
          export
         
        </strong>
        
         statements to be analyzed at compile time, leading to potential optimizations by
        
        
         
          JavaScript engines.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         CJS modules can use ESM through dynamic
        
        <strong class="source-inline">
         
          import()
         
        </strong>
        
         statements or by creating wrapper modules, but attention is required to avoid issues such as the dual
        
        
         
          package hazard.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         ESM can import CJS modules using
        
        
         
          default imports.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Exports are copied upon import, meaning changes to the exported value after import are not reflected in the
        
        
         
          importing module.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Supports live bindings, allowing imported values to update if they change in the
        
        
         
          exporting module.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Does not support
        
        <strong class="bold">
         
          top-level await
         
        </strong>
        
         as it relies on synchronous
        
        
         
          module loading.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Enables Top-level Await, enabling modules to wait for asynchronous operations
        
        
         
          before proceeding.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Typically uses the
        
        <strong class="source-inline">
         
          .js
         
        </strong>
        
         extension, although an explicit
        
        <strong class="source-inline">
         
          .cjs
         
        </strong>
        
         extension may
        
        
         
          be used.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         While
        
        <strong class="source-inline">
         
          .js
         
        </strong>
        
         can be used (with
        
        <strong class="source-inline">
         
          "type": "module"
         
        </strong>
        
         in
        
        <strong class="source-inline">
         
          package.json
         
        </strong>
        
         ), the
        
        <strong class="source-inline">
         
          .mjs
         
        </strong>
        
         extension can be used to explicitly mark files
        
        
         
          as ESM.
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Modules have their
        
        <a id="_idIndexMarker341">
        </a>
        
         own scope but share a
        
        
         
          global object.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Modules are executed
        
        <a id="_idIndexMarker342">
        </a>
        
         in
        
        <strong class="bold">
         
          strict mode
         
        </strong>
        
         by default
        
        <a id="_idIndexMarker343">
        </a>
        
         and have their own scope, with a more
        
        
         
          isolated environment.
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 5.2 – Key differences between CJS and ESM modules
    
   </p>
   <h3>
    
     Interoperability with CJS modules
    
   </h3>
   <p>
    
     One of the crucial
    
    <a id="_idIndexMarker344">
    </a>
    
     aspects of adopting
    
    <a id="_idIndexMarker345">
    </a>
    
     ESM modules in Node.js projects is understanding how they can interoperate with the traditional CJS module system.
    
    
     Given the vast ecosystem of existing Node.js packages and applications that use CJS, it is essential to grasp how to work with both module systems in a single project.
    
    
     This section explores the mechanisms and practices for achieving interoperability between ESM and CJS modules, ensuring a smooth transition and
    
    
     
      integration process.
     
    
   </p>
   <p>
    
     ESM can import CJS modules using the
    
    <strong class="source-inline">
     
      import
     
    </strong>
    
     statement, thanks to Node.js’s built-in interoperability support.
    
    
     However, because CJS modules are not statically analyzable in the same way as ESM, there are some nuances to be
    
    
     
      aware of:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Default imports
      
     </strong>
     
      : When importing a CJS module in an ESM file, the entire module’s exports are treated as a single default export.
     
     
      This means you cannot use named imports directly from a
     
     
      
       CJS module:
      
     
     <pre class="source-code">
// Importing a CommonJS module in ESM
import cjsModule from './module.cjs';
console.log(cjsModule.someFunction());</pre>
    </li>
    <li>
     <strong class="bold">
      
       Dynamic imports
      
     </strong>
     
      : You can dynamically import CJS modules using the
     
     <strong class="source-inline">
      
       import()
      
     </strong>
     
      function.
     
     
      This approach returns a
     
     <strong class="source-inline">
      
       Promise
      
     </strong>
     
      that resolves with the CJS module’s exports, allowing for asynchronous
     
     
      
       module loading:
      
     
     <pre class="source-code">
// Dynamically importing a CommonJS module
import('./module.cjs').then((cjsModule) =&gt; {
  console.log(cjsModule.someFunction());
});</pre>
    </li>
    <li>
     <strong class="bold">
      
       Exporting ESM modules for use in CJS
      
     </strong>
     
      : When it comes to using ESM modules in CJS code, the process is somewhat more constrained due to the synchronous nature of CJS’s
     
     <strong class="source-inline">
      
       require()
      
     </strong>
     
      function, which does not support ESM’s asynchronous module loading.
     
     
      However, there
     
     
      
       are workarounds.
      
     
    </li>
   </ul>
   <p>
    
     One common approach is
    
    <a id="_idIndexMarker346">
    </a>
    
     to create a CJS wrapper module that dynamically imports the ESM module and then exports its functionalities.
    
    
     This requires using asynchronous patterns such as
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     ,
    
    
     
      or promises:
     
    
   </p>
   <pre class="source-code">
// CJS wrapper for an ESM module
const esmModule = await import('./module.mjs');
module.exports = esmModule.default;</pre>
   <p>
    
     Projects that offer both ESM and CJS entry points need to be aware of the dual package hazard, where a single package loaded in both formats might lead to state issues or
    
    
     
      duplicated instances.
     
    
   </p>
   <p>
    
     When producing a module, it is recommended that you document if your package or application supports both ESM and CJS, with guidance on how consumers can import it into their projects.
    
    
     Should
    
    <a id="_idIndexMarker347">
    </a>
    
     you dual publish, it is
    
    <a id="_idIndexMarker348">
    </a>
    
     also recommended that you thoroughly test your module in both ESM and CJS environments to catch any
    
    
     
      interoperability issues.
     
    
   </p>
   <p class="callout-heading">
    
     Important Note:
    
   </p>
   <p class="callout">
    
     Node.js now offers Experimental support for loading ES modules using
    
    <strong class="source-inline">
     
      require()
     
    </strong>
    
     with the
    
    <strong class="source-inline">
     
      --experimental-require-module
     
    </strong>
    
     flag.
    
    
     This feature enables CommonJS modules to load ES modules under specific conditions, such as when the file has a
    
    <strong class="source-inline">
     
      .mjs
     
    </strong>
    
     extension or when
    
    <strong class="source-inline">
     
      "type": "module"
     
    </strong>
    
     is set in the nearest package.json.
    
    
     However, if the module or its dependencies contain top-level await, the
    
    <strong class="source-inline">
     
      ERR_REQUIRE_ASYNC_MODULE
     
    </strong>
    
     error will be thrown, requiring
    
    <strong class="source-inline">
     
      import()
     
    </strong>
    
     for
    
    
     
      asynchronous modules.
     
    
   </p>
   <p class="callout">
    
     This functionality is designed to improve interoperability between CommonJS and ES modules, but as an experimental feature, it may change in future Node.js versions.
    
    
     For more information,
    
    
     
      visit:
     
    
    <a href="https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require">
     
      
       https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require
      
     
    </a>
    
     
      .
     
    
   </p>
   <h3>
    
     Advanced topics in ECMAScript Modules
    
   </h3>
   <p>
    
     Advancing your
    
    <a id="_idIndexMarker349">
    </a>
    
     understanding of ESM within Node.js involves exploring more complex features and strategies that can optimize and enhance the functionality of your applications.
    
    
     There are some further advanced topics you can explore for benefits and considerations for developers working
    
    
     
      with ESM:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Dynamic import expressions
      
     </strong>
     
      : Dynamic
     
     <a id="_idIndexMarker350">
     </a>
     
      imports allow you to load modules on an as-needed basis, using the
     
     <strong class="source-inline">
      
       import()
      
     </strong>
     
      function that returns a
     
     <strong class="source-inline">
      
       Promise
      
     </strong>
     
      .
     
     
      This feature is particularly useful for reducing initial load times and optimizing resource utilization in applications by splitting the code into smaller chunks that are loaded only
     
     
      
       when required.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Module caching and preloading
      
     </strong>
     
      : Node.js caches imported modules to avoid reloading them each time they are required in the application, enhancing performance.
     
     
      Preloading modules involves loading modules before they are needed, potentially speeding up application startup by reducing delays associated with loading modules
     
     
      
       at runtime.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Tree shaking
      
     </strong>
     
      : Tree shaking is a term commonly associated with static code analysis tools and bundlers (such
     
     <a id="_idIndexMarker351">
     </a>
     
      as
     
     <strong class="bold">
      
       Webpack
      
     </strong>
     
      ).
     
     
      It refers to the elimination of unused code from a final bundle.
     
     
      For tree shaking to be effective, modules must use static
     
     <strong class="source-inline">
      
       import
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       export
      
     </strong>
     
      statements, as this allows the bundler to determine which exports are used and which can be safely removed, leading to smaller and more
     
     
      
       efficient bundles.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Module resolution customization
      
     </strong>
     
      : It is also possible to customize module resolution by configuring how import specifiers are resolved to actual module files.
     
     
      Node.js provides an experimental feature named
     
     <strong class="bold">
      
       customization hooks
      
     </strong>
     
      , which allows you to
     
     <a id="_idIndexMarker352">
     </a>
     
      customize module resolution and loading by registering a file that exports
     
     <a id="_idIndexMarker353">
     </a>
     
      hooks.
     
     
      For more information, refer to the Node.js API documentation for the
     
     
      
       feature:
      
     
     <a href="https://nodejs.org/api/module.html#customization-hooks">
      
       
        https://nodejs.org/api/module.html#customization-hooks
       
      
     </a>
     
      
       .
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-170">
    <a id="_idTextAnchor177">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Scaffolding a module
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Writing module code
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     <a href="B19212_08.xhtml#_idTextAnchor243">
      
       <em class="italic">
        
         Chapter 8
        
       </em>
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>