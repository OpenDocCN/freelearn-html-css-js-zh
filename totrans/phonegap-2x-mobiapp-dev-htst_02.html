<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Let's Get Social!</h1></div></div></div><p>Social networking<a id="id131" class="indexterm"/> has changed the way we share information in our world. Where it used to be an e-mail to a friend (or even a letter!), now it's a Twitter or a Facebook post, often for the world to see. What's even more amazing is how relatively young the various social networks are and how quickly they have changed the way we communicate and consume information. Because of this transformation, our apps need to support sharing to social networks, lest our app appears dated.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>What do we build?</h1></div></div></div><p>In this <a id="id132" class="indexterm"/>project, we will build an app that illustrates both sides of the social network equation. The first is that of consuming the information from various <a id="id133" class="indexterm"/>sources; we'll be using Twitter streams for this. The second is that of sharing information; we'll be using each platform's native sharing capabilities for this, except for iOS where we'll be using a project called ShareKit<a id="id134" class="indexterm"/> to implement sharing. (Note that iOS 5 supports Twitter sharing and iOS 6 expands that to Facebook. Sooner or later a plugin is bound to appear that supports these functions, but ShareKit provides more targets.)</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec40"/>What does it do?</h2></div></div></div><p>Our app, called Socializer,<a id="id135" class="indexterm"/> will display the Twitter streams from five pre-set Twitter accounts. The user can then read these streams, and should they find an interesting tweet, they can tap on it to do more with it. For example, they may wish to view a link embedded in the tweet. More importantly, the end user may wish to share the information using their own social network of choice, and the app will offer a Share button to do just that.</p><p>To accomplish this,<a id="id136" class="indexterm"/> we'll be working with Twitter's JSON API, a natural fit for an app already written largely in JavaScript. The only downside is that Twitter has a pretty low cap for rate-limiting API requests, so we'll also have to build some basic support for when this occurs. (To be honest, this is far more likely to occur to us as a developer than the user because we often reload the app to test a new feature, which incurs new API requests far faster than an end user would typically incur them.)</p><p>We'll also introduce the concept of PhoneGap plugins, as sharing functionality is not present in the typical PhoneGap install by default. A plugin is essentially a bridge between some amount of native code (such as Java, Objective C, or C#) and our JavaScript code.</p><p>For this project, we'll be using two plugins for each platform we support. One, <code class="literal">ChildBrowser</code>
<a id="id137" class="indexterm"/>, is supported across most platforms, which makes it far easier to write code that uses it. The second is based upon the platform's sharing capabilities and what plugins are available for the platform and PhoneGap. Since this varies, we'll have to deal with separate code paths for each platform, but the idea will be the same—to share content.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Why is it great?</h2></div></div></div><p>This<a id="id138" class="indexterm"/> project is a great introduction to handling APIs using JSON, including Twitter's API. While we're using a very small subset of Twitter's API, the lessons learned in this project can be expanded to deal with the rest of the APIs. Furthermore, JSON APIs are frequently used by many web platforms, and learning how to deal with Twitter's API is a great way to learn how to deal with any JSON API.</p><p>We'll also be dealing with how to share content. While Android provides a shared mechanism between all apps that provide a nice list of sharing apps, iOS does not. So we'll also have to write code that is platform specific to handle the differences in how each platform (and the corresponding plugin) supports sharing.</p><p>We'll also be working with PhoneGap plugins, something many apps will eventually require in one way or another. For example, our app should be able to handle links to external websites; the best way to do this is to have the <code class="literal">ChildBrowser</code> plugin handle it. This lets the user stay inside our app and easily return to our app when they are done. Without it, we'd be taking the user out of the app and into the default browser.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How are we going to do it?</h2></div></div></div><p>To do this, we're<a id="id139" class="indexterm"/> going to break down the creation of our app into several different parts, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing the app – UI/interaction design</li><li class="listitem" style="list-style-type: disc">Designing the app – the data model</li><li class="listitem" style="list-style-type: disc">Implementing the data model</li><li class="listitem" style="list-style-type: disc">Configuring the plugins</li><li class="listitem" style="list-style-type: disc">Implementing the social view</li><li class="listitem" style="list-style-type: disc">Implementing the tweet view</li></ul></div><p>Just like in the previous project, we'll focus on the design of the app before we handle the implementation.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec43"/>What do I need to get started?</h2></div></div></div><p>You'll need <a id="id140" class="indexterm"/>to go ahead and create your project, just like we did in the last project. You can, to some degree, copy the previous project and replace the necessary files and settings as well. There is one additional iOS setting that should be modified, but it's really a matter of taste (whether or not you like your status bars black or grey):</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">Socializer-info.plist</code>.</li><li class="listitem">Add <code class="literal">Status Bar style</code> and set it to <code class="literal">UIStatusBarStyleOpaqueBlack</code>.</li></ol></div><p>We'll also be using the same directory structure as the previous project, with two exceptions: we'll be adding a <code class="literal">www/childbrowser</code> directory and a <code class="literal">www/plugins</code> directory. Underneath the <code class="literal">www/plugins</code> directory, we'll have a directory for each platform: namely, <code class="literal">/www/plugins/Android</code> and <code class="literal">/www/plugins/iOS</code>. We'll fill these directories later, but go ahead and create them now.</p><p>We'll be using the same framework, so be sure to copy the framework files. We won't worry about localizing the content, but even so, we'll use all the localization functions so that it would be easy to do so. We'll also use a script to deal with scrolling in <code class="literal">www/framework</code> called <code class="literal">scroller.js</code>. You'll need to add this to your index files in order to use it correctly, as shown in the following code snippet:</p><div><pre class="programlisting">    &lt;script type="application/javascript" charset="utf-8" src="img/scroller.js"&gt;&lt;/script&gt;</pre></div><p>You'll also need to download the PhoneGap plugins repository available at <a class="ulink" href="http://www.github.com/phonegap/phonegap-plugins">http://www.github.com/phonegap/phonegap-plugins</a>. This will ensure you have all the necessary plugins we'll need as well as any plugins you might be interested in working with<a id="id141" class="indexterm"/> on your own.</p><p>Finally, for iOS, we'll need to get the ShareKit 2.0 plugin available at <a class="ulink" href="https://github.com/ShareKit/ShareKit">https://github.com/ShareKit/ShareKit</a>. Due to the way it is distributed, you'll need to install Git and make sure you enable Git for the project. (Alternatively, you can use the <code class="literal">/Submodules</code> directory in the download files).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Designing the app – UI/interaction design</h1></div></div></div><p>Our first task is to<a id="id142" class="indexterm"/> design our user interface and the<a id="id143" class="indexterm"/> interaction between the various widgets and views. Like in the previous task, we will have three views: the start view, the social view, and the tweet view.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec44"/>Getting on with it</h2></div></div></div><p>We'll begin with the start view. As in the last project, this will be a very simple view and is entirely optional in this app. All we'll be doing is explaining the app and providing a way to move to the main view.</p><p>With that in mind, following is our screenshot for the start view:</p><div><img src="img/9403OS_02_01.jpg" alt="Getting on with it"/></div><p>In this screenshot, <a id="id144" class="indexterm"/>we have a <strong>Start</strong> button (1) that will push<a id="id145" class="indexterm"/> the social view on to the view stack. We also have some explanatory text (2).</p><p>Our next view is the social view, shown in the following screenshot:</p><div><img src="img/9403OS_02_02.jpg" alt="Getting on with it"/></div><p>The social view is essentially a list of tweets, one after the other. We'll display several tweets at a time, and, as such, we'll have to deal with scrolling at some point. While you can use various libraries to accomplish this, we'll be using our own minimalist scrolling library.</p><p>Each tweet will consist of a profile image (1), the screen name and real name (if available) (2), and the text of the tweet (3). When the user taps a tweet, we'll transition to the tweet view.</p><p>At the bottom of the view (4), we have a series of profile images for five different Twitter accounts. The images will be retrieved from Twitter itself; we won't be storing the images ourselves. When an image is tapped, we'll load the respective Twitter stream.</p><p>Our tweet view looks like the following screenshot:</p><div><img src="img/9403OS_02_03.jpg" alt="Getting on with it"/></div><p>First, note that our <a id="id146" class="indexterm"/>tweet view repeats the tweet (1) <a id="id147" class="indexterm"/>that the user tapped on in the stream view. The same information is repeated, but we also list out the various web links (2) that the tweet might have, any hashtags (3), and any user mentions (4). Items (2) to (4) are intended to be tappable: that is, if a user taps on (2), they should be taken to the particular website. If they tap on (3), they should be taken back to the social view with a stream of tweets referencing the hashtag<a id="id148" class="indexterm"/>. The same should happen if they tap on (4), except that it would be that particular user's stream.</p><p>We also have a <strong>Back</strong> button in our navigation bar to take the user back to the previous view, and a <strong>Share</strong> button (5) in our toolbar. This button, when tapped, should display a list (6) of various social network services. What this list will look like will depend upon the platform the app is on, and what social networks are installed on the device.</p><p>Now that we've created our mockup, we need to define some of the resources we'll need. Let's open up our editing program and get busy designing our app.</p><div><img src="img/9403_02_20.jpg" alt="Getting on with it"/></div><p>The preceding screenshot is a pretty good representation of how our final product will look. A lot of it<a id="id149" class="indexterm"/> can be accomplished with CSS . The <a id="id150" class="indexterm"/>background of the Twitter stream and the navigation bar are the only two components that will be difficult, so we should save those out to our <code class="literal">www/images</code> directory as <code class="literal">Background.png</code> and <code class="literal">NavigationBar.png</code> respectively. Notice that, both have a texture, so make sure to save them in a way that they will tile without visible seams.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec45"/>What did we do?</h2></div></div></div><p>For this task, we've defined how our UI should look, and the various interactions between widgets and views. We also generated a mockup of the app in our graphics editor and created some image resources for our later use.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Designing the app – the data model</h1></div></div></div><p>In this task,<a id="id151" class="indexterm"/> we will design our data model for handling Twitter <a id="id152" class="indexterm"/>users and streams. Our model will, to some extent, rely on Twitter's model as well. The results that it returns from its API we will use unmodified. The rest of the model we will define in this task.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>Getting on with it</h2></div></div></div><p>Let's take a look at our data model:</p><div><img src="img/9403OS_02_04.jpg" alt="Getting on with it"/></div><p>We'll be using <code class="literal">TWITTER</code> as the namespace and within it, we'll have two objects we'll be using a lot: <code class="literal">TwitterUser</code> and <code class="literal">TwitterStream</code>. The idea behind <code class="literal">TwitterUser</code>
<a id="id153" class="indexterm"/> is to be an instance of a particular user, which we'll represent by an image on the toolbar in the streams view. The <code class="literal">TwitterStream</code> object<a id="id154" class="indexterm"/> will be a representation of a single stream.</p><p>Let's examine <code class="literal">TwitterUser</code> more closely. The object has two properties: <code class="literal">screenName</code> and <code class="literal">userData</code>. The <code class="literal">screenName</code> property holds the user's Twitter username. The <code class="literal">userData</code> property<a id="id155" class="indexterm"/> will hold the response from Twitter's API. It will have lots of different information about the user, including their profile image URL, their real name, and more.</p><p>The constructor <a id="id156" class="indexterm"/>will return an initialized <code class="literal">TwitterUser</code> based upon the supplied screen name. Internally, the constructor just calls the <code class="literal">setScreenName()</code> method,<a id="id157" class="indexterm"/> which will request the user data from Twitter. The <code class="literal">getScreenName()</code> method <a id="id158" class="indexterm"/>simply returns the screen name. The <code class="literal">getProfileImageUrl()</code> method<a id="id159" class="indexterm"/> will return the URL to the user's profile image. The <code class="literal">getUserData()</code> method<a id="id160" class="indexterm"/> will return the data that Twitter returned, and the <code class="literal">getTimeline()</code> method will create a <code class="literal">TwitterStream</code> object for the particular user.</p><p>The <code class="literal">TwitterStream</code> object operates on a similar idea: it will house the data returned by Twitter. The <code class="literal">TwitterStream</code> object also provides us the ability to get a stream for a particular user as well as the ability to return a stream for any search (such as a hashtag).</p><p>When constructed, we pass three options: the screen name or the search phrase, the maximum number of tweets to return (up to 200), and a function to call when the stream is fully loaded. It will call the <code class="literal">loadStream()</code> method<a id="id161" class="indexterm"/> to do the actual loading.</p><p>We have some methods related to the properties in the object such as <code class="literal">setScreenName()</code>
<a id="id162" class="indexterm"/>, <code class="literal">setSearchPhrase()</code>
<a id="id163" class="indexterm"/>, <code class="literal">getSearchPhrase()</code>
<a id="id164" class="indexterm"/>, <code class="literal">setMaxCount()</code>
<a id="id165" class="indexterm"/>, <code class="literal">getMaxCount()</code>
<a id="id166" class="indexterm"/>, and <code class="literal">getStream()</code>
<a id="id167" class="indexterm"/>.</p><p>The <code class="literal">setScreenName()</code> method does the same thing as setting a <code class="literal">searchPhrase()</code> method except that it adds an <code class="literal">@</code> character to the name. The <code class="literal">loadStream()</code> method<a id="id168" class="indexterm"/> then can decide which API to call when loading a stream, either by calling the API to return the user's stream, or by calling the search API.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>What did we do?</h2></div></div></div><p>We created and defined our data model for our app. We've defined two objects: namely, <code class="literal">TwitterUser</code> and <code class="literal">TwitterStream</code>, and saw how they interact.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Implementing the data model</h1></div></div></div><p>We'll be<a id="id169" class="indexterm"/> creating<a id="id170" class="indexterm"/> two files: namely, <code class="literal">twitter.js</code> and <code class="literal">twitterUsers.js</code>. Place these in the <code class="literal">www/models</code> directory.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>Getting on with it</h2></div></div></div><p>Let's start with the <code class="literal">twitter.js</code> file:</p><div><pre class="programlisting">var TWITTER = TWITTER || {};</pre></div><p>As always, we define our namespace, in this case, <code class="literal">TWITTER</code>, as seen in the following code snippet:</p><div><pre class="programlisting">TWITTER._baseURL = "http://api.twitter.com/1/";
TWITTER._searchBase = "http://search.twitter.com/";</pre></div><p>We define two <a id="id171" class="indexterm"/>variables global to the <code class="literal">TWITTER</code> namespace: namely, <code class="literal">_baseURL</code> and <code class="literal">_searchBase</code>. These two URLs point at Twitter's JSON API; <a id="id172" class="indexterm"/>the first is for API requests such as user lookups, user streams, and such, while the latter is only for searching. We define them here for two reasons: to make the URLs a little less nasty in the following code, and if Twitter should ever decide to have a different version of the API (and you want to change it), you can do so here.</p><p>Next, we define our first object, <code class="literal">TwitterUser</code>:</p><div><pre class="programlisting">TWITTER.TwitterUser = function ( theScreenName, completion )
{
    var self = this;

    self._screenName = "";
    self._userData   = {};</pre></div><p>We've defined our two properties: <code class="literal">_screenName</code> and <code class="literal">_userData</code>. Unlike in the last project, we're using underscores in front to indicate that these are internal (private) variables that no outside object should access. Instead, an outside object should use the <code class="literal">get</code>/<code class="literal">set</code> methods we define next:</p><div><pre class="programlisting">    self.getScreenName = function ()
    {
       return self._screenName;
    }</pre></div><p>This one's simple enough, it just returns the private member when asked. But the next one's more complicated:</p><div><pre class="programlisting">    self.setScreenName = function ( theScreenName, completion 
         )
    {
        self._screenName = theScreenName;</pre></div><p>Like with a normal <code class="literal">set</code> method, we've assigned <code class="literal">theScreenName</code> to <code class="literal">_screenName</code>. But when this happens, we want to load in the user information from Twitter. This is why it is important to have <code class="literal">get</code>/<code class="literal">set</code> methods in front of private methods. You might just need to do something important when the value changes or is read.</p><div><pre class="programlisting">        var getUserURL = TWITTER._baseURL + "users/lookup.json?screen_name=" + encodeURIComponent(theScreenName);</pre></div><p>Here we've defined our URL that we're going to use to ask Twitter to look up the user in question. For<a id="id173" class="indexterm"/> more information about how this particular URL works, see the Twitter documentation at <a class="ulink" href="https://dev.twitter.com/docs/api/1/get/users/lookup">https://dev.twitter.com/docs/api/1/get/users/lookup</a>. You can see a full example of what is returned at the bottom of the page.</p><p>Now that we have<a id="id174" class="indexterm"/> our URL, we're going to use another utility function defined for us in <code class="literal">PKUTIL</code> (<a class="ulink" href="http://www/framework/utility.js">www/framework/utility.js</a>) called <code class="literal">loadJSON()</code>
<a id="id175" class="indexterm"/>. It uses AJAX to send a request to the preceding URL, and Twitter then sends a response back, in the form of JSON. When it is finished, the function will call the <code class="literal">completion</code> function we're passing as the second parameter after <code class="literal">getUserURL</code>. This method can check if the request succeeded or not, and set any private members that are necessary. We'll also call the <code class="literal">completion</code> function passed to the <code class="literal">setScreenName()</code> method. These actions are defined in the following code snippet:</p><div><pre class="programlisting">        PKUTIL.loadJSON ( getUserURL, function ( 
                success, data )
        {
            if (success)
            {
              self._userData = data;</pre></div><p>If success is true, then the JSON has been properly returned and parsed into the data parameter. We just assign it to the private <code class="literal">_userData</code> member as seen in the preceding code block.</p><div><pre class="programlisting">            }
            else
            {
              self._userData = { "error": "Twitter error; rate 
                  limited?" };</pre></div><p>But if success is false, then something's gone wrong. Any number of things could have happened, Twitter might be down (not unheard of), the network connection might have failed, or Twitter might have rate limited us. For now we're just going to assume the latter, but you could certainly build more complicated error-detection schemes to figure out which is which.</p><div><pre class="programlisting">            }
            if (completion)
            {
                completion ();
            }</pre></div><p>Finally, regardless of success or failure, we call the <code class="literal">completion</code> function passed to us. This is important so that we know when we can safely access the <code class="literal">_userData</code> member (via <code class="literal">getUserData</code> a little lower down).</p><div><pre class="programlisting">            }
        );
    }
    
    self.getProfileImageURL = function ()
    {
        if (self._userData[0])
        {
            return self._userData[0].profile_image_url;
        }
        return "";
    }</pre></div><p>In the preceding<a id="id176" class="indexterm"/> code snippet, the method <code class="literal">getProfileImageURL()</code>
<a id="id177" class="indexterm"/> is a convenience function that <a id="id178" class="indexterm"/>returns the user's profile image URL. This is a link to the avatar being used for Twitter. First we check to see if <code class="literal">_userData[0]</code> exists, and if so, return <code class="literal">profile_image_url</code>, a value defined by the Twitter API. If it doesn't, we'll just return an empty string.</p><div><pre class="programlisting">    self.getUserData = function ()
    {
        return self._userData;
    }</pre></div><p>Next, <code class="literal">getUserData()</code>
<a id="id179" class="indexterm"/> is used to return the <code class="literal">_userData</code> member. If it has been properly loaded, it will have a lot of values in it, all determined by Twitter. If it has failed to load, it'll have an error property in it, and if it hasn't been loaded at all, it'll be empty.</p><div><pre class="programlisting">    self.getTimeline = function ( theMaxCount, completion )
    {
        return new TWITTER.TwitterStream ( "@" + 
            self._theScreenName, completion, theMaxCount || 25 
            );
    }</pre></div><p>
<code class="literal">getTimeline()</code>
<a id="id180" class="indexterm"/> is also a convenience function used to get the timeline for the Twitter user. <code class="literal">theMaxCount</code> is the maximum number of tweets to return (up to 200), and <code class="literal">completion</code> is a function to call when it's all done. We do this by creating a new <code class="literal">TwitterStream</code> object (defined in the following code snippet) with the Twitter screen name prepended by an <code class="literal">@</code> character.</p><p>If <code class="literal">theMaxCount</code> isn't specified, we use a little <code class="literal">||</code> trick to indicate the default value, <code class="literal">25</code> tweets.</p><div><pre class="programlisting">    self.setScreenName ( theScreenName, completion );
}</pre></div><p>The last thing we do is actually call the <code class="literal">setScreenName()</code> method with <code class="literal">theScreenName</code> and <code class="literal">completion</code> functions passed in to the constructor. If you remember your JavaScript, this <a id="id181" class="indexterm"/>whole function, while we can think of it as<a id="id182" class="indexterm"/> defining an object, is also the constructor of that object. In this case, as soon as you create the <code class="literal">TwitterUser</code> object, we'll fire off a request to Twitter to load in the user's data and set it to <code class="literal">_userData</code>.</p><p>Our next object is the <code class="literal">TwitterStream</code> object defined as follows:</p><div><pre class="programlisting">TWITTER.TwitterStream = function ( 
    theScreenNameOrSearchPhrase, completion, theMaxCount )
{
    var self = this;

    self._searchPhrase  = "";
    self._stream        = {};
    self._theMaxCount   = 25;</pre></div><p>Here we've defined three properties, namely, <code class="literal">_searchPhrase</code>, <code class="literal">_stream</code>, and <code class="literal">_theMaxCount</code>. The <code class="literal">_searchPhrase</code> property can be either the screen name of a user or a literal search term, such as a hashtag. The <code class="literal">_stream</code> property is the actual collection of tweets obtained from Twitter, and the <code class="literal">_theMaxCount</code> property is the maximum number of tweets to ask for. (Keep in mind that Twitter is free to return less than this amount.)</p><p>You may ask why we're storing either a search phrase or a screen name. The reason is that we're attempting to promote some code re-use. It's only logical to assume that a Twitter stream is a Twitter stream, regardless of how it was found, either by asking for a particular user's stream or by searching for a word. Nice assumption, right?</p><p>Yeah, totally wrong too. The streams are close, close enough that we can work around the differences, but still, not the same. So even though we're treating them here as one-and-the-same, they really aren't, at least until Twitter decides to change their search API to better match their non-search API.</p><div><pre class="programlisting">    self.setMaxCount = function ( theMaxCount )
    {
        self._theMaxCount = theMaxCount;
    }
    self.getMaxCount = function ()
    {
        return self._theMaxCount;
    }</pre></div><p>Here we have the <code class="literal">get</code>/<code class="literal">set</code> methods for <code class="literal">_theMaxCount</code>. All we do is <code class="literal">set</code> and retrieve the value. One thing to note is that this should be called before we actually load a stream; this value is part of the ultimate URL we sent to Twitter.</p><div><pre class="programlisting">    self.setScreenName = function ( theScreenName )
    {
        self._searchPhrase = "@" + theScreenName;
    }
    
    self.setSearchPhrase = function ( theSearchPhrase )
    {
        self._searchPhrase = theSearchPhrase;
    }
    self.getSearchPhrase = function ()
    {
        return self._searchPhrase;
    }</pre></div><p>Notice that <a id="id183" class="indexterm"/>we have two <code class="literal">set</code> methods that act on <code class="literal">_searchPhrase</code> while we only have one <code class="literal">get</code> method. <a id="id184" class="indexterm"/>What we're doing here is permitting someone to call <code class="literal">setScreenName()</code> without the <code class="literal">@</code> character. The <code class="literal">_searchPhrase</code> property will then be set to <code class="literal">@</code> prepended to the screen name. The next <code class="literal">set</code> method (<code class="literal">setSearchPhrase()</code>) is intended to be used when setting real search terms (such as a hashtag).</p><p>Internally, we'll use that <code class="literal">@</code> at the front to mean something special, but you'll see that in a second.</p><div><pre class="programlisting">    self.getStream = function ()
    {
        return self._stream;
    }</pre></div><p>The <code class="literal">getStream()</code> method<a id="id185" class="indexterm"/> just returns our <code class="literal">_stream</code>, which if we haven't loaded one, will be blank. So let's look at the <code class="literal">loadStream()</code> method:</p><div><pre class="programlisting">    self.loadStream = function ( completion )
    {
        var theStreamURL;
        var forScreenName = false;</pre></div><p>The <code class="literal">loadStream()</code> method<a id="id186" class="indexterm"/> takes a <code class="literal">completion</code> function; we'll call this at the end of the operation no matter what. It lets the rest of our code know when it is safe to access the <code class="literal">_stream</code> member via <code class="literal">getStream()</code>.</p><p>The other component is the <code class="literal">forScreenName</code> variable; if true, we'll be asking Twitter for the stream that belongs to the screen name stored in <code class="literal">_searchPhrase</code>; otherwise, we'll ask Twitter to do an actual search for <code class="literal">_searchPhrase</code>. This variable is defined in the following code snippet:</p><div><pre class="programlisting">        if (self._searchPhrase.substr(0,1)=="@")
        {
            theStreamURL = TWITTER._baseURL + 
            "statuses/user_timeline.json?include_entities=
             true&amp;include_rts=true&amp;count=" +
            self._theMaxCount + "&amp;screen_name=" + 
                encodeURIComponent(self._searchPhrase);
            forScreenName = true;
        }
        else
        {
            theStreamURL = TWITTER._searchBase + 
                "search.json?q=" + 
                encodeURIComponent(self._searchPhrase) + 
                "&amp;include_entities=true" + 
                "&amp;include_rts=true&amp;rpp=" + self._theMaxCount;
            forScreenName = false;
        }</pre></div><p>All we've <a id="id187" class="indexterm"/>done so far is define <code class="literal">theStreamURL</code> to point either at the search API (for a search term)<a id="id188" class="indexterm"/> or the non-search API (for a screen name's stream). Next we'll load it with <code class="literal">loadJSON(</code>
<a id="id189" class="indexterm"/>
<code class="literal">)</code>, as shown in the following code snippet:</p><div><pre class="programlisting">        PKUTIL.loadJSON ( theStreamURL, function (success, 
           data)
        {
            if (success)
            {
                if (forScreenName)
                  {
                    self._stream = data;
                  }
                else
                  {
                    self._stream = data.results;
                  }
            }</pre></div><p>Here's another reason why we need to know if we're processing for a screen name or for a search, the JSON we get back is slightly different. When searching, Twitter helpfully includes other information (such as the time it took to execute the search). In our case, we're not interested in anything but the results, hence the two separate code paths.</p><div><pre class="programlisting">            else
            {
              self._stream = { "error": "Twitter error; rate 
                  limited?" };
            }</pre></div><p>Again, if we have a failure, we're assuming that we are rate-limited.</p><div><pre class="programlisting">            if (completion)
            {
              completion( self._stream );
            }</pre></div><p>When done, we call the <code class="literal">completion</code> method, helpfully passing along the data stream.</p><div><pre class="programlisting">            }
        );
    }
    self.setSearchPhrase ( theScreenNameOrSearchPhrase );
    self.setMaxCount ( theMaxCount || 25 );
    self.loadStream ( completion );
}</pre></div><p>Just like at the<a id="id190" class="indexterm"/> end of the last object, we call some methods at the end of this object too. First we set <a id="id191" class="indexterm"/>the incoming search phrase, then set the maximum number of tweets to return (or 25, if it isn't given to us), and then call the <code class="literal">loadStream()</code> method with the <code class="literal">completion</code> function. This means that the moment we create a new <code class="literal">TwitterStream</code> object, it's already working on loading all the tweets we'll be wanting to have access to.</p><p>We've taken care of almost all our data model, but we've just a little bit left to do in <code class="literal">twitterUsers.js</code>:</p><div><pre class="programlisting">TWITTER.users = Array();</pre></div><p>First, we create a <code class="literal">users()</code> array in the <code class="literal">TWITTER</code> namespace. We're going to use this to store our predefined Twitter users, which will be loaded with the <code class="literal">loadTwitterUsers()</code> method<a id="id192" class="indexterm"/> as follows:</p><div><pre class="programlisting">TWITTER.loadTwitterUsers = function ( completion )
{
  TWITTER.users.push ( new TWITTER.TwitterUser ( "photoKandy"  , function () 
    { TWITTER.users.push ( new TWITTER.TwitterUser ( "CNN"  , 
    function ()
        { TWITTER.users.push ( new TWITTER.TwitterUser ( 
      "BBCWorld" , function ()
        { TWITTER.users.push ( new TWITTER.TwitterUser ( 
        "espn", function ()
            { TWITTER.users.push ( new TWITTER.TwitterUser ( 
          "lemondefr", completion ) ); }
            ) ); }
        ) ) ; }
      ) ) ; }
    ) ) ;
}</pre></div><p>What we've done here essentially is just chained together five requests for five different Twitter accounts. You can store these in an array and ask for them all at once, yes, but our app needs to know when they've all loaded. You could also do this by using recursion through an array of users, but we'll leave it as an example to you, the reader.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>What did we do?</h2></div></div></div><p>We implemented our data model and predefined the five Twitter accounts we want to use. We also went over the <code class="literal">loadJSON()</code> method<a id="id193" class="indexterm"/> in <code class="literal">PKUTIL</code> which helps with the entire process. We've also been introduced to the Twitter API.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>What else do I need to know?</h2></div></div></div><p>Before we go on, let's take a look at the <code class="literal">loadJSON()</code> method you've been introduced to. It's been added to this project's <code class="literal">www/framework/utility.js</code> file, and is defined as follows:</p><div><pre class="programlisting">PKUTIL.loadJSON = function ( theURL, completion )
{
  PKUTIL.load( theURL, true, function ( success, data )
    {</pre></div><p>First off, this is a pretty simple function to begin with. What we're really doing is utilizing <code class="literal">PKUTIL.load()</code> to do the hard work of calling out to the URL and passing us the response, but when the response is received, it's going to be coming back to us in the data variable.</p><div><pre class="programlisting">      var theParsedData = {};</pre></div><p>The <code class="literal">theParsedData</code> variable<a id="id194" class="indexterm"/> will store the actual JSON data, fully parsed.</p><div><pre class="programlisting">      if (success)
      {
        try
        {
          theParsedData = JSON.parse ( data );</pre></div><p>If the URL returns something successfully, we try to parse the data. Assuming it is a valid JSON string, it'll be put into <code class="literal">theParsedData</code>. If it isn't, <code class="literal">JSON.parse()</code> will throw an exception, as shown in the following code block:</p><div><pre class="programlisting">        }
        catch (err)
        {
          console.log ("Failed to parse JSON from " + theURL);
          success = COMPLETION_FAILURE;
        }</pre></div><p>Any exceptions will be logged to the console, and we'll end up telling our <code class="literal">completion</code> function that the request failed, as shown in the following code block:</p><div><pre class="programlisting">      }
      if (completion)
      {
        completion (success, theParsedData);
      }</pre></div><p>At the end, we call our <code class="literal">completion</code> function and tell it if the request failed or succeeded, and what the JSON data was (if successfully parsed).</p><div><pre class="programlisting">    }
  );
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Configuring the plugins</h1></div></div></div><p>Most <a id="id195" class="indexterm"/>PhoneGap plugins aren't terribly hard to install or configure, <a id="id196" class="indexterm"/>but they will undoubtedly play a vital role in your app, especially if you need to use a feature that PhoneGap doesn't provide on its own.</p><p>In our case, we need two plugins, one to display websites within our app and another to share the content. For <a id="id197" class="indexterm"/>the first, we'll be using a plugin called <code class="literal">ChildBrowser</code> across all the platforms we support, but for the latter, we'll have to use a separate plugin for iOS and Android.</p><p>Here's what each sharing plugin will look like when we're done, starting with iOS:</p><div><img src="img/9403_02_28.jpg" alt="Configuring the plugins"/></div><p>For Android the sharing plugin will look like the following:</p><div><img src="img/9403_02_29.jpg" alt="Configuring the plugins"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Getting ready</h2></div></div></div><p>If you haven't <a id="id198" class="indexterm"/>already, you should download the entire community PhoneGap plugin repository located at <a class="ulink" href="https://github.com/phonegap/phonegap-plugins">https://github.com/phonegap/phonegap-plugins</a>. This will provide you with nearly all the content necessary to use the plugins.</p><p>If you wish<a id="id199" class="indexterm"/> to support sharing on iOS, you also need to download ShareKit 2.0<a id="id200" class="indexterm"/>, which is available at <a class="ulink" href="https://github.com/ShareKit/ShareKit">https://github.com/ShareKit/ShareKit</a>, or use the fork bundled with the code available for this book. It is located outside of the directories for each project in a directory labeled <code class="literal">Submodules</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec52"/>Getting on with it</h2></div></div></div><p>We're going to split this one up into what we have to do for each platform, as the steps and environments are all quite different.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Plugin configuration for iOS</h3></div></div></div><p>You wouldn't know it<a id="id201" class="indexterm"/>, but our first platform is also the <a id="id202" class="indexterm"/>hardest. In fact, it'll make the remaining two platforms feel a bit like child's play. </p><p>The <code class="literal">ChildBrowser</code> plugin itself is easy to install and configure, but ShareKit 2.0 is, well, anything but, especially when used in conjunction with PhoneGap. The problem stems from the fact that when you compile the project with PhoneGap and ShareKit 2.0 together, s<a id="id203" class="indexterm"/>ome symbols are duplicated, and the linker throws out a nasty little error. Long story short, your app doesn't compile. Not good.</p><p>Let's look first at the steps necessary for installing the <code class="literal">ChildBrowser</code> plugin, as these are far more typical of most plugins:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the collection of plugins you downloaded and navigate to <code class="literal">iOS/ChildBrowser</code>.</li><li class="listitem">Drag <code class="literal">ChildBrowser.bundle</code>, <code class="literal">ChildBrowserCommand.h</code>, <code class="literal">ChildBrowserCommand.m</code>, <code class="literal">ChildBrowserViewController.h</code>, <code class="literal">ChildBrowserViewController.m</code>, and <code class="literal">ChildBrowserViewController.xib</code> into XCode to <code class="literal">Socializer/Plugins</code>, as shown in the following screenshot:<div><img src="img/9403_02_06.jpg" alt="Plugin configuration for iOS"/></div></li><li class="listitem"> At the prompt, make sure to copy the files (instead of linking to them). This can be done<a id="id204" class="indexterm"/> by checking the <strong>Copy items into destination group's folder</strong> entry, as shown in the following screenshot:<div><img src="img/9403_02_07.jpg" alt="Plugin configuration for iOS"/></div></li><li class="listitem">Copy <code class="literal">ChildBrowser.js</code> to your <code class="literal">www/plugins/iOS</code> directory. You can do this in XCode or in Finder.</li><li class="listitem">Add the<a id="id205" class="indexterm"/> plugin to <code class="literal">Cordova.plist</code> in <code class="literal">Socializer/Supporting Files</code> in XCode. Find the <code class="literal">Plugins</code> row, and add a new entry of the order as seen in the following table:<div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong> </strong>
<code class="literal">ChildBrowserCommand</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">String</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ChildBrowserCommand</code>
</p>
</td></tr></tbody></table></div><p>This can be better explained with the help of the following screenshot:</p><div><img src="img/9403_02_05.jpg" alt="Plugin configuration for iOS"/></div></li></ol></div><p>There, that was easy, wasn't it? Now comes the hard part, getting ShareKit 2.0 installed and working. For that, <a id="id206" class="indexterm"/>we're going to refer to <a class="link" href="apb.html" title="Appendix B. InstallingShareKit 2.0">Appendix B</a>, <em>Installing ShareKit 2.0</em> as the process is rather long.</p><p>When that's done, we need to duplicate the plugin setup that we did for <code class="literal">ChildBrowser</code>, except for ShareKit<a id="id207" class="indexterm"/>, using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Navigate to the <code class="literal">iOS/ShareKitPlugin</code> directory in your plugin repository.</li><li class="listitem">Copy <code class="literal">ShareKitPlugin.h</code>, <code class="literal">ShareKitPlugin.m</code>, <code class="literal">SHKSharer+Phonegap.h</code>, <code class="literal">SHKSharer+Phonegap.m</code> to the <code class="literal">Plugins</code> folder in your project.</li><li class="listitem">Copy <code class="literal">ShareKitPlugin.js</code> to your <code class="literal">www/plugins/iOS</code> folder.</li><li class="listitem">Modify <code class="literal">Cordova.plist</code> to add this new plugin to the list.</li><li class="listitem">Find the <strong>Plugins</strong> row, and add a new entry, as in the following table:<div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ShareKitPlugin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">String</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ShareKitPlugin</code>
</p>
</td></tr></tbody></table></div><p>This can be better explained with the help of the following screenshot:</p><div><img src="img/9403_02_19.jpg" alt="Plugin configuration for iOS"/></div></li></ol></div><p>The final step is to update our <code class="literal">www/index.html</code> file to include these two plugins for our app. Add the following lines after the line that is loading the <code class="literal">cordova-2.2.0-ios.js</code> script:</p><div><pre class="programlisting">&lt;script type="application/javascript" charset="utf-8"   
    src="img/ShareKitPlugin.js"&gt;&lt;/script&gt;
&lt;script type="application/javascript" charset="utf-8" 
    src="img/ChildBrowser.js"&gt;&lt;/script&gt;</pre></div><p>Whew! We did it, we've got two plugins installed for iOS devices. Now, let's tackle the remaining platform. Don't faint. Android's a lot easier.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Plugin configuration for Android</h3></div></div></div><p>For Android, we'll be <a id="id208" class="indexterm"/>using two plugins: namely, <code class="literal">ChildBrowser</code> and <code class="literal">Share</code>. Both are located in the repository you should have already downloaded<a id="id209" class="indexterm"/> from GitHub. Let's start with installing and configuring <code class="literal">ChildBrowser</code> first, using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new package (<strong>File</strong> | <strong>New</strong> | <strong>Package</strong>) under your project's <code class="literal">src</code> folder. Name it <code class="literal">com.phonegap.plugins.childBrowser</code>.</li><li class="listitem">Navigate to <code class="literal">Android/ChildBrowser/src/com/phonegap/plugins/childBrowser</code> and drag <code class="literal">ChildBrowser.java</code> to the newly created package in Eclipse.</li><li class="listitem">Go to <code class="literal">res/xml</code> in your project and open <code class="literal">plugins.xml</code> with the text editor (usually this is done by a right-click and then navigating to <strong>Open With</strong> | <strong>Text Editor</strong>).</li><li class="listitem">Add the following line at the bottom of the file, just above the <code class="literal">&lt;/plugins&gt;</code> ending tag:<div><pre class="programlisting">&lt;plugin name="ChildBrowser" value="com.phonegap.plugins.childBrowser.ChildBrowser"/&gt;</pre></div></li><li class="listitem">Navigate to the <code class="literal">Android/ChildBrowser/www</code> folder in the repository.</li><li class="listitem">Copy <code class="literal">childbrowser.js</code> to <code class="literal">assets/www/plugins/Android</code>.</li><li class="listitem">Copy the <code class="literal">childbrowser</code> folder to <code class="literal">assets/www</code> (copy the folder, not the contents, and you should end up with <code class="literal">assets/www/childbrowser</code> when done).</li></ol></div><p>For our next plugin, <code class="literal">Share</code>, use <a id="id210" class="indexterm"/>the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a package <a id="id211" class="indexterm"/>in Eclipse under your project's <code class="literal">src </code>directory named <code class="literal">com.schaul.plugins.share</code>.</li><li class="listitem">Navigate to <code class="literal">Android/Share </code>in the plugin repository and copy <code class="literal">Share.java</code> to the package in Eclipse.</li><li class="listitem">Add the following line at the bottom of the <code class="literal">plugins.xml </code>file:<div><pre class="programlisting">&lt;plugin name="Share" value="com.schaul.plugins.share.Share"/&gt;</pre></div></li><li class="listitem"><code class="literal">Copy share.js</code> to your project's <code class="literal">assets/www/plugins/Android </code>directory.</li><li class="listitem">The last step is to update our <code class="literal">www/index_Android.html</code> file by adding the following lines just below the portion that is loading the <code class="literal">cordova-2.2.0-android.js</code> file:<div><pre class="programlisting">    &lt;script type="application/javascript" charset="utf-8" src="img/childbrowser.js"&gt;&lt;/script&gt;
    &lt;script type="application/javascript" charset="utf-8" src="img/share.js"&gt;&lt;/script&gt;</pre></div></li></ol></div><p>That's it! Our plugins are<a id="id212" class="indexterm"/> correctly installed and configured for Android.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec53"/>What did we do?</h2></div></div></div><p>We set up the <code class="literal">ChildBrowser</code> plugin on both of our supported platforms. We set up ShareKit 2.0 and the <code class="literal">ShareKitPlugin</code> for iOS, and the <code class="literal">Share</code> plugin for Android.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec54"/>What else do I need to know?</h2></div></div></div><p>We've not actually dealt with how to use the plugins; we just installed them. We'll be dealing with that as we come to the necessary steps when implementing our project. But there is one important detail to pay attention to: the plugin's <code class="literal">readme</code> file, if available.</p><p>This file will often indicate the installation steps necessary, or any quirks that you might need to watch out for. The proper use of the plugin is also usually detailed. Unfortunately, some plugins don't come with instructions. At that point, the best thing to do is to try installing it in the <em>normal</em> fashion (as we've done earlier for <code class="literal">ChildBrowser</code> and all the other plugins except for ShareKit) and see if it works.</p><p>The other thing to remember is that PhoneGap is an ongoing project. It means that there are plugins that are out-of-date (and indeed, some have had to be updated by the author for this book) and won't work correctly with the most recent versions of PhoneGap. You'll need to pay attention to the plugins so that you know which version it supports, and if it will need to be modified to work with a newer version of PhoneGap. Modifications usually aren't terribly difficult, but it does involve getting into the native code, so you may want to ask the community for help in the modification. (See the end of the project for links to the community.)</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Implementing the social view</h1></div></div></div><p>While our <a id="id213" class="indexterm"/>app has three views, the start view is so<a id="id214" class="indexterm"/> similar to the previous project's start view that we won't go into great detail in this project about how it works. You're welcome to take a look at the code in the <code class="literal">www/views/startView.html</code> file.</p><p>The bulk of our code is going to reside in the social view and the tweet view, so that's where our primary focus will be. So let's get started!</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec55"/>Getting ready</h2></div></div></div><p>Go ahead and create the <code class="literal">socialView.html</code> file now based on what we have discussed. Then we'll go over the portions you haven't seen before.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec56"/>Getting on with it</h2></div></div></div><p>When we're finished with this task, we should have a view that looks like this for iOS:</p><div><img src="img/9403_02_22.jpg" alt="Getting on with it"/></div><p>The view for <a id="id215" class="indexterm"/>Android will be as follows:</p><div><img src="img/9403_02_23.jpg" alt="Getting on with it"/></div><p>As with all our views to this point, we're going to start with the HTML portion that describes the actual view; it is given as follows:</p><div><pre class="programlisting">&lt;div class="viewBackground"&gt;
 &lt;div class="navigationBar"&gt;
  &lt;div id="socialView_title"&gt;&lt;/div&gt;
  &lt;button class="barButton backButton"   
      id="socialView_backButton" style="left:10px" &gt;&lt;/button&gt;
 &lt;/div&gt;
 &lt;div class="content avoidNavigationBar avoidToolBar" 
     style="padding:0; overflow: scroll;" 
     id="socialView_scroller"&gt;
   &lt;div id="socialView_contentArea" style="padding: 0; 
     height: auto; position: relative;"&gt;
   &lt;/div&gt;
 &lt;/div&gt;
 &lt;div class="toolBar" id="socialView_toolbar" style="text-
      align: center"&gt;
 &lt;/div&gt;
&lt;/div&gt;</pre></div><p>Generally, this <a id="id216" class="indexterm"/>looks very much like our previous views, except that there are a couple of critical details. We've added a style to the inner <code class="literal">div</code> element. This takes away our default <code class="literal">div</code> styling (from <code class="literal">www/framework/base.css</code>) and forces the height to fit to the content (instead of to the screen). This means that when we want to scroll, we'll have the whole content to scroll through.</p><p>This is the first time we've<a id="id217" class="indexterm"/> talked about scrolling in our apps at all, actually, and for good reason: it's often hard on mobile platforms. In a perfect world, we could just rely on <code class="literal">overflow:scroll</code> to work on all our platforms, but that simply doesn't work. We can rely on native scrolling in iOS 5 and later, but that has its own share of problems (depending on the version of PhoneGap and various other WebKit gotchas), and rules out any lower platform, and of course, it doesn't work on Android at any version. So for iOS and Android, we'll have to use our own implementation for scrolling or use a third-party scrolling library such as iScroll 4. In this case, we're using our own implementation, which we'll cover a little later.</p><p>First we need to determine how our toolbar will show its profile images using the following template:</p><div><pre class="programlisting">&lt;div class="hidden" id="socialView_profileImageIcon"&gt;
 &lt;a class="profileImage" style="background-
     image:url(%PROFILE_IMAGE_URL%)"
   href="javascript:socialView.loadStreamFor
     ('@%SCREEN_NAME%');"&gt;&lt;/a&gt;
&lt;/div&gt;</pre></div><p>Note that we have a little bit of JavaScript that fires when the user touches the image, this is to load the appropriate stream for that image.</p><p>Next, we need to define what the tweets should look like within our view. This is done by using the following code snippet:</p><div><pre class="programlisting">&lt;div class="hidden" id="socialView_twitterTemplate"&gt;
 &lt;div class="twitterItem" onclick="socialView.selectTweet(%INDEX%);"&gt;
  &lt;img src="img/%PROFILE_IMAGE_URL%" width=32 height=32 border=0  
   /&gt;
  &lt;div class="twitterName"&gt;
   &lt;span class="twitterRealName"&gt;%REAL_NAME%&lt;/span&gt;
   &lt;span class="twitterScreenName"&gt;@%SCREEN_NAME%&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="twitterTweet"&gt;%TWEET%&lt;/div&gt;
 &lt;/div&gt;
&lt;/div&gt;</pre></div><p>In this segment of HTML, we've defined what the rest of a tweet should look like. We've given every <code class="literal">div</code> and <code class="literal">span</code> a <a id="id218" class="indexterm"/>class so that we can target them in our <code class="literal">style.css</code> file (located in <code class="literal">www/style</code>). That is mainly to keep the display of the tweet as<a id="id219" class="indexterm"/> separate from the content of the tweet as possible and to make it easy to change the look of a tweet whenever we want. Go ahead and take a look at the <code class="literal">style.css</code> file to get a good idea of how they will work to give our tweets some style.</p><p>Next up is our code:</p><div><pre class="programlisting">  var socialView = $ge("socialView") || {};
  socialView.firstTime = true;
  socialView.currentStream = {}; 
  socialView.lastScrollTop = 0;
  socialView.myScroll = {};</pre></div><p>As always, we give ourselves a namespace, in this case <code class="literal">socialView</code>. We also declare a few properties: <code class="literal">firstTime</code>, which will track if this is the first time our view is being displayed or not, and <code class="literal">currentStream</code>, which will hold the current visible stream from Twitter. The <code class="literal">lastScrollTop</code> property<a id="id220" class="indexterm"/> will record the position the user has scrolled to on our current page so we can restore it when they return from looking an individual tweet, and <code class="literal">myScroll</code> will hold our actual scroller.</p><div><pre class="programlisting">  socialView.initializeView = function ()
  {
<strong>    PKUTIL.include ( ["./models/twitterStreams.js", </strong>
<strong>        "./models/twitterStream.js"], function ()</strong>
<strong>                     {</strong>
<strong>                        // load our toolbar</strong>
<strong>                        TWITTER.loadTwitterUsers ( </strong>
<strong>                        socialView.initializeToolbar );</strong>
<strong>                     }</strong>
<strong>                   );</strong>

    socialView.viewTitle = $ge("socialView_title");
    socialView.viewTitle.innerHTML = __T("APP_TITLE");

    socialView.backButton = $ge("socialView_backButton");
    socialView.backButton.innerHTML = __T("BACK");
    PKUI.CORE.addTouchListener(socialView.backButton, 
        "touchend", function () { PKUI.CORE.popView(); });

<strong>    if (device.platform != "WinCE")</strong>
<strong>    {</strong>
<strong>        socialView.myScroll = new SCROLLER. </strong>
<strong>            GenericScroller ('socialView_contentArea');</strong>
<strong>    }    </strong>
    
  }</pre></div><p>Our <code class="literal">initializeView()</code> method<a id="id221" class="indexterm"/> isn't terribly different from our previous project. I've highlighted a couple lines, <a id="id222" class="indexterm"/>however – note that we load our models and when<a id="id223" class="indexterm"/> they are complete, we call <code class="literal">TWITTER.loadTwitterUsers()</code>. We pass along a completion function, which we define next so that when Twitter has returned the user data for all five of our Twitter users, we can call it.</p><p>We've also defined our scroller. If you want to see the complete code take a look in <code class="literal">www/framework/scroller.js</code>, but it should suffice to say, it is a reasonably nice scroller that is simple to use. It doesn't beat native scrolling, but nothing will. You're free to replace it with any library you'd like, but for the purposes of this project, we've gone this route.</p><div><pre class="programlisting">  socialView.initializeToolbar = function ()
  {
    
    var toolbarHtml = "";
    var profileImageTemplate = 
        $ge("socialView_profileImageIcon").innerHTML;
    var users = TWITTER.users;
    
    if (users.error)
    {
        console.log (streams.error);
        alert ("Rate limited. Please try again later.");
    }</pre></div><p>One of the first things we do after obtaining the template's HTML is to check on our <code class="literal">TWITTER.users</code> array. This array should have been filled with all sorts of user data, but if Twitter has rate-limited us for some reason, it may not be. So we check to see if there is an error condition, and if so, we let the user know. Granted, it's not the best method to let a user know, but for our example app, it suffices.</p><div><pre class="programlisting">    // go through each stream and request the profile image
    for (var i=0; i&lt;users.length; i++)
    {
        var theTemplate = profileImageTemplate.replace 
           ("%SCREEN_NAME%", users[i].getScreenName())
                          .replace ("%PROFILE_IMAGE_URL%", 
                             users[i].getProfileImageURL());
        toolbarHtml += theTemplate;
    }</pre></div><p>Next, we iterate <a id="id224" class="indexterm"/>through each of the users. There should be five, but you could configure it for a different number and build up an HTML string that we'll put into the toolbar as follows:</p><div><pre class="programlisting">    $ge("socialView_toolbar").innerHTML = toolbarHtml;
  }</pre></div><p>Our next function, <code class="literal">loadStreamFor()</code> does the really hard work in this view. It requests a stream from Twitter and then processes it for display. The code snippet for it is as follows:</p><div><pre class="programlisting">  socialView.loadStreamFor = function ( searchPhrase )
  {
    var aStream = new TWITTER.TwitterStream ( searchPhrase, 
    function ( theStream )
      {</pre></div><p>Something to note<a id="id225" class="indexterm"/> is that we are now inside the <code class="literal">completion</code> function, the function that will be called when the Twitter stream is obtained.</p><div><pre class="programlisting">        var theTweetTemplate = 
           $ge("socialView_twitterTemplate").innerHTML;
        var theContentArea = $ge("socialView_contentArea");
        var theStreamHTML = "";
        if (theStream.error)
        {
            console.log (theStream.error);
            alert ("Rate limited. Please try again later.");
        }</pre></div><p>Because Twitter may rate-limit us at any time, we check again for any error in the stream in the preceding code snippet.</p><div><pre class="programlisting">        for (var i=0; i&lt;theStream.length; i++)
        {
          var theTweet = theStream[i];
          var theTemplate = 
              theTweetTemplate.replace("%INDEX%", i)
                           .replace ("%PROFILE_IMAGE_URL%",  
                            theTweet.profile_image_url ||    
                            theTweet.user.profile_image_url)
                           .replace ("%REAL_NAME%", 
                            theTweet.from_user || 
                            theTweet.user.name)
                           .replace ("%SCREEN_NAME%", 
                            theTweet.from_user || 
                            theTweet.user.screen_name)
                           .replace ("%TWEET%", 
                            theTweet.text);
          theStreamHTML += theTemplate;
        }</pre></div><p>Here we're iterating through each item in the stream and building up a large HTML string from the template we defined earlier.</p><p>One important <a id="id226" class="indexterm"/>part to <a id="id227" class="indexterm"/>notice is how we're obtaining the data of the tweet, using <code class="literal">theTweet.from_user || theTweet.user.screen_name</code> and such. This is to deal with how Twitter returns a slightly different data format when searching for a word or a hashtag versus the data format when returning a user's timeline. Should one be undefined, we'll load the other, and since we can only get one or the other, it's easier than building a lot of if statements to take care of it.</p><div><pre class="programlisting">        theContentArea.innerHTML = theStreamHTML;
        socialView.currentStream = theStream;
        if (socialView.myScroll.scrollTo)
        {
            socialView.myScroll.scrollTo ( 0, 0 );
        }</pre></div><p>Once our stream HTML is built, we assign it to the content area so that the user can see it. We also store the stream into the <code class="literal">currentStream</code> property so we can reference it later. When that's done, we scroll to the top of the page so that the user can see the most recent tweets.</p><div><pre class="programlisting">}
      , 100
    );
  }</pre></div><p>That last <code class="literal">100</code>? Well, it's actually part of the call to <code class="literal">TwitterStream()</code>. It's the number of items to return in the stream.</p><p>Our next function deals with what should happen when a user taps on a displayed tweet:</p><div><pre class="programlisting">  socialView.selectTweet = function ( theIndex )
  {
     var theTweet = socialView.currentStream[theIndex];
     tweetView.setTweet ( theTweet );
     PKUI.CORE.pushView ( tweetView );
  }</pre></div><p>This function is pretty simple. All we do is tell the tweet view what tweet was tapped, and then push it on to the view stack.</p><div><pre class="programlisting">  socialView.viewWillAppear = function ()
  {
    document.addEventListener("backbutton", 
        socialView.backButtonPressed, false );
    if (socialView.firstTime)
    {
        socialView.loadStreamFor ( "@photokandy" ); 
        socialView.firstTime = false;
    }
    if (socialView.myScroll.scrollTo)
    {
      PKUTIL.delay ( 50, function ()
        {
          socialView.myScroll.scrollTo ( 0, 
             socialView.lastScrollTop );
        }
      );
    }
  }</pre></div><p>This <code class="literal">viewWillAppear()</code> method<a id="id228" class="indexterm"/>
<a id="id229" class="indexterm"/> is pretty similar to the last project except for the middle and the last portion. In the middle we're checking<a id="id230" class="indexterm"/> if this is the first time the view has been displayed. If it is, we want to load a default stream for the user. Remember, up till now we've only loaded a stream when the user taps on a profile image in the toolbar. But we don't want to reload this stream every time our view displays; we could be coming back from the tweet view and the user might want to continue where they left off in the previous stream. In the final portion, we're checking to see if we had a previous scroll position, and if so, we scroll the view to that point. We have to create a delay here, since if we set it too early, the view will be offscreen (and won't scroll), or it will be onscreen, and it'll be noticeable to the user.</p><p>The remaining two functions, <code class="literal">viewWillHide()</code>
<a id="id231" class="indexterm"/> and <code class="literal">backButtonPressed()</code>
<a id="id232" class="indexterm"/> present no new functionality, so while you do need them in your code, we won't go over them here.</p><p>That's it, not terribly difficult, but it does what we need–display a list of tweets. Once a user taps on the tweet, they'll be taken to the tweet view to do more, and that's what we'll look at in the next task.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec57"/>What did we do?</h2></div></div></div><p>In this task we defined the HTML code and templates for our social view. We also used the Twitter-stream data to construct a Twitter stream that the end user can interact with.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Implementing the tweet view</h1></div></div></div><p>Our tweet view <a id="id233" class="indexterm"/>will be where the user interacts with a given tweet.<a id="id234" class="indexterm"/> They can open any links within the tweet using the <code class="literal">ChildBrowser</code> plugin, or they can search any hashtags contained within the tweet (or any mentions, too). The view also gives the user the opportunity to share the tweet to any of their social networks.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec58"/>Getting ready</h2></div></div></div><p>Go ahead and create your own <code class="literal">www/tweetView.html</code> file based on the one we discussed. We'll go<a id="id235" class="indexterm"/> over the code that is new, while<a id="id236" class="indexterm"/> leaving the rest to you to review.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec59"/>Getting on with it</h2></div></div></div><p>For this next task, we should end up with a view that looks like the following on iOS:</p><div><img src="img/9403_02_25.jpg" alt="Getting on with it"/></div><p>For Android, the view will be as follows:</p><div><img src="img/9403_02_26.jpg" alt="Getting on with it"/></div><p>This time, we're not going to display the HTML for defining the layout of our view. You may ask why? This is because you've seen it several times before and can look it up in the code for this project. We're going to start with the templates that will define the content instead:</p><div><pre class="programlisting">&lt;div class="hidden" id="tweetView_tweetTemplate"&gt;
 &lt;div class="twitterItem" onclick="tweetView.selectTweet(%INDEX%);"&gt;
<strong>  &lt;img src="img/%PROFILE_IMAGE_URL%" width=64 height=64 </strong>
<strong>   border=0 /&gt;</strong>
  &lt;div class="twitterRealName"&gt;%REAL_NAME%&lt;/div&gt;
  &lt;div class="twitterScreenName"&gt;@%SCREEN_NAME%&lt;/div&gt;
  &lt;div class="twitterTweet"&gt;%TWEET%&lt;/div&gt;
<strong>  &lt;div class="twitterEntities"&gt;%ENTITIES%&lt;/div&gt;</strong>
 &lt;/div&gt;
&lt;/div&gt;</pre></div><p>This code is pretty similar to the template in the previous view with a couple of exceptions: one that we've made the profile image larger, and two, we've added a <code class="literal">div</code> element that lists all the <em>entities</em> in the tweet. Twitter defines an entity as a URL, a hashtag, or a mention of another twitter user. We'll display any of these that are in a tweet so that the user can tap on them to get more information.</p><div><pre class="programlisting">&lt;div class="hidden" id="tweetView_entityTemplate"&gt;
  &lt;DIV class="entity %TYPE%"&gt;%ENTITY%&lt;/DIV&gt;
&lt;/div&gt;</pre></div><p>Here's our template for any entity. Notice that we've given it the class of <code class="literal">entity</code>, so that all our entities can have a similar appearance.</p><p>Next up, we define what each particular entity looks like, in this case, the URL template.</p><div><pre class="programlisting">&lt;div class="hidden" id="tweetView_urlEntityTemplate"&gt;
 &lt;a href="javascript:PKUTIL.showURL('%URL%');" 
  class="openInNewWindow url" target="_blank"&gt;%DISPLAYURL%&lt;/a&gt;
&lt;/div&gt;</pre></div><p>Note the use <a id="id237" class="indexterm"/>of <code class="literal">PKUTIL.showURL()</code> in this template. <a id="id238" class="indexterm"/>It is a convenience method we've defined in <code class="literal">PKUTIL</code> to use <code class="literal">ChildBrowser</code> to show a webpage. We've done the work of combining how it works on each platform and put it into one function so that it is easy to call. We'll take a look at it a little later.</p><div><pre class="programlisting">&lt;div class="hidden" id="tweetView_hashEntityTemplate"&gt;
 &lt;a href="javascript:socialView.loadStreamFor('%23%HASHTAG%'); 
  PKUI.CORE.popView();" class="hash"&gt;#%TEXT%&lt;/a&gt;
&lt;/div&gt;</pre></div><p>This template is for a hashtag. The big difference between this and the previous template is that it is actually referring back to our previous view! It does this to tell it to load a stream for the hashtag, and then we call <code class="literal">popView()</code> to go back to the view. Chances are the view won't have the loaded information from Twitter just yet, but give it a second and it'll reload with the new stream.</p><p>Similarly, the code for a mention is as follows:</p><div><pre class="programlisting">&lt;div class="hidden" id="tweetView_userEntityTemplate"&gt;
 &lt;a href="javascript:socialView.loadStreamFor('@%USER%'); 
  PKUI.CORE.popView();" class="user" &gt;@%TEXT%&lt;/a&gt;
&lt;/div&gt;</pre></div><p>So that defines how our tweet looks and works, let's see how the view actually creates the tweet itself:</p><div><pre class="programlisting">  var tweetView = $ge("tweetView") || {};
  tweetView.theTweet = {};
  tweetView.setTweet = function ( aTweet )
  {
      tweetView.theTweet = aTweet;
  }</pre></div><p>Here, we've defined the <code class="literal">setTweet()</code> method<a id="id239" class="indexterm"/>, which stores a given tweet into our <code class="literal">theTweet</code> property<a id="id240" class="indexterm"/>. Remember, this is called from the Twitter stream view when a tweet is tapped to send us the tweet to display.</p><p>The next method of interest is <code class="literal">loadTweet()</code>. We'll skip the <code class="literal">initializeView()</code> method as it is similar to the previous view. The <code class="literal">loadTweet()</code> method<a id="id241" class="indexterm"/> is given as follows:</p><div><pre class="programlisting">  tweetView.loadTweet = function ()
  {
    var theTweet = tweetView.theTweet;
    
    var theTweetTemplate = 
        $ge("tweetView_tweetTemplate").innerHTML;
    var theEntityTemplate = 
        $ge("tweetView_entityTemplate").innerHTML;
    var theURLEntityTemplate = 
        $ge("tweetView_urlEntityTemplate").innerHTML;
    var theHashEntityTemplate = 
        $ge("tweetView_hashEntityTemplate").innerHTML;
    var theUserEntityTemplate = 
        $ge("tweetView_userEntityTemplate").innerHTML;</pre></div><p>First, we obtain the HTML for each template we need—and there are several! These are given as follows:</p><div><pre class="programlisting">    var theContentArea = $ge("tweetView_contentArea");
    var theTweetHTML = "";
    var theEntitiesHTML = "";    

    var theURLEntities = theTweet.entities.urls;
    for (var i=0;i&lt;theURLEntities.length;i++)
    {
        var theURLEntity = theURLEntities[i];
        theEntitiesHTML += theEntityTemplate.replace 
                                 ("%TYPE%", "url")
                                .replace ("%ENTITY%",
            theURLEntityTemplate.replace ("%URL%", 
                                 theURLEntity.url )
                                .replace ("%DISPLAYURL%", 
                                 theURLEntity.display_url )
                           );
    }</pre></div><p>In this code, <a id="id242" class="indexterm"/>we've gone through every URL entity that Twitter has sent us and added it to our entity <a id="id243" class="indexterm"/>HTML string. We'll repeat that for hashtags and for mentions, but the code is so similar, we won't repeat it here.</p><div><pre class="programlisting">    var theTemplate = theTweetTemplate
                      .replace ("%PROFILE_IMAGE_URL%", 
                       theTweet.profile_image_url || 
                       theTweet.user.profile_image_url)
                      .replace ("%REAL_NAME%", 
                       theTweet.from_user || 
                       theTweet.user.name)
                      .replace ("%SCREEN_NAME%", 
                       theTweet.from_user || 
                       theTweet.user.screen_name)
                      .replace ("%TWEET%", theTweet.text)
                      .replace ("%ENTITIES%", theEntitiesHTML );
    theTweetHTML += theTemplate;        
    theContentArea.innerHTML = theTweetHTML;</pre></div><p>Once we've gone through all the entities, we handle the tweet itself. Note that we had to handle the entities first because we handle the substitution earlier. Just like with the previous view, we correctly handle if the tweet is from a search or from a timeline as well.</p><p>The next <a id="id244" class="indexterm"/>method<a id="id245" class="indexterm"/> of interest is the <code class="literal">share()</code> method, so we'll skip over <code class="literal">viewWillAppear()</code>, <code class="literal">viewWillHide()</code>, and <code class="literal">backButtonPressed()</code>. Suffice to say, the only different thing the <code class="literal">viewWIllAppear()</code> method<a id="id246" class="indexterm"/> does than any of the others is call the <code class="literal">loadTweet()</code> method<a id="id247" class="indexterm"/> to display the tweet when our view is shown.</p><p>The <code class="literal">share()</code> method<a id="id248" class="indexterm"/> is where we call each platform's plugin for sharing. Each platform has a slightly different syntax, so we have to check which platform we're on and decide which plugin to call based on that. We can do so using the following code snippet:</p><div><pre class="programlisting">  tweetView.share = function ()
  {
    switch (device.platform)
    {
case "Android": window.plugins.share.show(
          { subject: 'Share',
            text: tweetView.theTweet.text,
          },
          function() {},
          function() { alert ('Error sharing.'); }
          );
                break;</pre></div><p>For Android, we're using the <code class="literal">Share</code> plugin, and this is how we can share with it. Android will then display a list of services that support sharing, including Twitter and Facebook, if the user has them installed. The text we give it will be included in the message, and Android is nice enough to let us send a success and a failure function should we want to do something after the tweet.</p><div><pre class="programlisting">default:
                window.plugins.shareKit.share ( 
                     tweetView.theTweet.text );
    }
  }</pre></div><p>Our default method is for iOS, which will display an action sheet listing a few services, probably Twitter and Facebook, and the user can tap the button of the service they want to share to. Once they authenticate to the service, they can then send the message.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec60"/>What did we do?</h2></div></div></div><p>We displayed a single tweet and processed the various entities within it. We demonstrated loading an external site in the <code class="literal">ChildBrowser</code> plugin by using <code class="literal">PKUTIL.showURL()</code>. We also demonstrated how to use the various sharing plugins.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec61"/>What else do I need to know?</h2></div></div></div><p>Let's take a quick look at <code class="literal">PKUTIL.showURL()</code>, the method used to display a <code class="literal">ChildBrowser</code> with an external site. It's a pretty simple function, but since it takes three different ways to show <code class="literal">ChildBrowser</code>, we packaged it up into a function that makes it easy to use.</p><div><pre class="programlisting">PKUTIL.showURL = function ( theURL )
{
    switch (device.platform)
    {
case "Android":
        window.plugins.childBrowser.showWebPage( theURL );
        break;</pre></div><p>For Android, it's simple to call <code class="literal">ChildBrowser</code>. Typically this is how you call any plugin you want to use in PhoneGap.</p><div><pre class="programlisting">case "WinCE":
      var options = 
      {
       url:theURL,
       geolocationEnabled:false
      };
          Cordova.exec(null, null,"ChildBrowserCommand",
              "showWebPage", options);
        break;</pre></div><p>WP7 is here too, since the platform supports it, and is a little more difficult. We have to pack the URL into an options array and then send it to the plugin to show.</p><div><pre class="programlisting">default:
        cordova.exec("ChildBrowserCommand.showWebPage", 
            theURL);
    }
}</pre></div><p>For iOS, it's very similar to Android's method, except we call it directly instead of using <code class="literal">window.plugins.*</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Game Over..... Wrapping it up</h1></div></div></div><p>Well, you've done it.<a id="id249" class="indexterm"/> You've successfully written an app that displays information obtained from Twitter and that lets the user share it on their own social network. For some platforms, it wasn't too hard to configure the plugins necessary to do this work, while for iOS, you probably got a bit more familiar with Xcode and header paths and such than you wanted. The rest was easy; adding plugins gets easier the more you do it, and chances are pretty good you'll need at least the <code class="literal">ChildBrowser</code> plugin in nearly every project you do. Thankfully, it's also an easy install!</p><p>Some resources you might find valuable are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ShareKit: <a class="ulink" href="https://github.com/ShareKit/ShareKit">https://github.com/ShareKit/ShareKit</a></li><li class="listitem" style="list-style-type: disc">JSON: <a class="ulink" href="http://www.json.org/">http://www.json.org/</a></li><li class="listitem" style="list-style-type: disc">Twitter JSON documentation: <a class="ulink" href="https://dev.twitter.com/docs/api/1">https://dev.twitter.com/docs/api/1</a></li><li class="listitem" style="list-style-type: disc">Phonegap plugins: <a class="ulink" href="http://www.github.com/phonegap/phonegap-plugins">http://www.github.com/phonegap/phonegap-plugins</a></li><li class="listitem" style="list-style-type: disc">Phonegap community: <a class="ulink" href="http://groups.google.com/group/phonegap">http://groups.google.com/group/phonegap</a></li><li class="listitem" style="list-style-type: disc">iScroll 4: <a class="ulink" href="http://cubiq.org/iscroll-4">http://cubiq.org/iscroll-4</a></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Can you take the HEAT? The Hotshot Challenge</h1></div></div></div><p>As a project, Socializer does what it is set out to do, but there's actually so much more that you could do to it to make it truly useful. Why don't you try one or more of the following challenges<a id="id250" class="indexterm"/>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Let the end user select their own initial Twitter accounts, instead of our initial five.</li><li class="listitem" style="list-style-type: disc">Display a loading graphic while the Twitter stream is loading so that the user knows that the app is working on something.</li><li class="listitem" style="list-style-type: disc">Style any links, mentions, or hashtags in the Twitter stream to make them stand out more.</li><li class="listitem" style="list-style-type: disc">Try your hand at working with the API of any other social network you like.</li><li class="listitem" style="list-style-type: disc">Try to add OAuth authentication.</li></ul></div></div></body></html>