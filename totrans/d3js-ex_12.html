<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Creating Maps with GeoJSON and TopoJSON"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Creating Maps with GeoJSON and TopoJSON</h1></div></div></div><p>D3.js provides extensive capabilities for creating maps and to facilitate you in presenting data as part of the map or as an overlay. The functions for mapping within D3.js leverage a data format known as GeoJSON, a form of JSON that encodes geographic information.</p><p>Another common <a id="id538" class="indexterm"/>type of data for maps in D3.js is TopoJSON. TopoJSON is a more compressed form of GeoJSON. Both these formats are used to represent the cartographic information required to create a map, and D3.js processes this data and performs its usual magic of converting this information into SVG paths that visualize the map.</p><p>This chapter wills start with a brief overview of GeoJSON and TopoJSON. This will give you the foundation to understand how maps are represented and rendered with D3.js. We will then jump into many examples using both data formats for rendering maps of various types, coloring the geometries within the map based upon data, and for overlaying information at specific locations on those maps.</p><p>The specific topics that we will cover in this chapter include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A brief overview of TopoJSON and GeoJSON</li><li class="listitem" style="list-style-type: disc">Drawing a map of the United States with GeoJSON</li><li class="listitem" style="list-style-type: disc">Using TopoJSON to draw the countries of the world</li><li class="listitem" style="list-style-type: disc">Styling the geometries that comprise a map</li><li class="listitem" style="list-style-type: disc">Panning and zooming of a map</li><li class="listitem" style="list-style-type: disc">Interaction with a globe</li><li class="listitem" style="list-style-type: disc">Highlighting the boundaries of geometries on <code class="literal">mouseover</code> events</li><li class="listitem" style="list-style-type: disc">Adding symbols to a map at specific locations</li><li class="listitem" style="list-style-type: disc">Rendering maps of regions based upon data (using a choropleth)</li></ul></div><div class="section" title="Introducing TopoJSON and GeoJSON"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec56"/>Introducing TopoJSON and GeoJSON</h1></div></div></div><p>Almost every <a id="id539" class="indexterm"/>map example in D3.js will use either <span class="strong"><strong>GeoJSON</strong></span> or <span class="strong"><strong>TopoJSON</strong></span>. GeoJSON is an open, standard, JSON-based format for representing basic geographical <a id="id540" class="indexterm"/>features as well as the non-spatial properties for those features (such as the name of a city or a landmark).</p><p>The core geometries in GeoJSON are points, line strings, and polygons. The basic description of a GeoJSON entity uses the following syntax:</p><div class="informalexample"><pre class="programlisting">{ 
    "type": name of the type of geometry (point, line string, ...)
    "coordinates": one or more tuple of latitude / longitude
}</pre></div><p>Let's take a look at the four basic types of geometry types available in GeoJSON. A <span class="strong"><strong>point</strong></span> represents a position in two-dimensional space, and consists of a pair of one latitude and longitude. A point is normally used to specify the location of a feature on a map (such as a building):</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Example</p>
</th><th style="text-align: left" valign="bottom">
<p>Representative GeoJSON</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B04230_12_01.jpg" alt="Introducing TopoJSON and GeoJSON"/></div>
</td><td style="text-align: left" valign="top">
<p>

</p><div class="informalexample"><pre class="programlisting">{
    "type": "Point", 
    "coordinates": [30, 10]
}</pre></div><p>
</p>
</td></tr></tbody></table></div><p>
<code class="literal">LineString</code> describes a sequence of points which have a line drawn between them, starting at the first, through all intermediate points, and ending at the last coordinate. The name conjures up visions of stretching a string caught between all the points. These shapes are normally used to represent items such as, roads or rivers:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Example</p>
</th><th style="text-align: left" valign="bottom">
<p>Representative GeoJSON</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B04230_12_02.jpg" alt="Introducing TopoJSON and GeoJSON"/></div>
</td><td style="text-align: left" valign="top">
<p>

</p><div class="informalexample"><pre class="programlisting">{ 
    "type": "LineString", 
    "coordinates": [
        [30, 10], [10, 30], 
        [40, 40] ]
}</pre></div><p>
</p>
</td></tr></tbody></table></div><p>A <span class="strong"><strong>polygon</strong></span> is a <a id="id541" class="indexterm"/>closed shape normally consisting of three or more points, where the last point is the same as the first and forms a closed shape. The JSON representation is shown as follows; note that the coordinates are an array of arrays of tuples:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Example</p>
</th><th style="text-align: left" valign="bottom">
<p>Representative GeoJSON</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B04230_12_03.jpg" alt="Introducing TopoJSON and GeoJSON"/></div>
</td><td style="text-align: left" valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">{ 
    "type": "Polygon", 
    "coordinates": 
    [
        [[30, 10], [40, 40],
         [20, 40], [10, 20], 
         [30, 10]] 
    ]
}</pre></div><p>
</p>
</td></tr></tbody></table></div><p>The purpose of an array of <a id="id542" class="indexterm"/>arrays of tuples is to allow multiple polygons to be defined, which exclude each other, thereby allowing the exclusions of one or more polygonal regions within one another:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Example</p>
</th><th style="text-align: left" valign="bottom">
<p>Representative GeoJSON</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B04230_12_04.jpg" alt="Introducing TopoJSON and GeoJSON"/></div>
</td><td style="text-align: left" valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">{ 
    "type": "Polygon", 
    "coordinates": 
        [
          [[35, 10], [45, 45], 
           [15, 40], [10, 20], 
           [35, 10]], 
          [[20, 30], [35, 35],
           [30, 20], [20, 30]] 
        ]
}</pre></div><p>
</p>
</td></tr></tbody></table></div><p>It is possible to define multi-part geometries where a particular geometry type is reused, and where the coordinates describe multiple instances of the type of geometry. These types are the previous types prefaced with <span class="emphasis"><em>Multi</em></span>—<code class="literal">MultiPoint</code>, <code class="literal">MultiLineString</code>, and <code class="literal">MultiPolygon</code>. Each is demonstrated as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th><th style="text-align: left" valign="bottom">
<p>Representative GeoJSON</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>MultiPoint</p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B04230_12_05.jpg" alt="Introducing TopoJSON and GeoJSON"/></div>
</td><td style="text-align: left" valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">{ 
    "type": "MultiPoint", 
    "coordinates": 
     [[10, 40], [40, 30], 
      [20, 20], [30, 10]]
}</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MultiLineString</p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B04230_12_06.jpg" alt="Introducing TopoJSON and GeoJSON"/></div>
</td><td style="text-align: left" valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">{ 
"type": MultiLineString", 
   "coordinates": 
   [
     [[10, 10], [20, 20],
      [10, 40]], 
    [[40, 40], [30, 30], 
     [40, 20], [30, 10]] 
   ]
}</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MultiPolygon</p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B04230_12_08.jpg" alt="Introducing TopoJSON and GeoJSON"/></div>
</td><td style="text-align: left" valign="top">
<p>
</p><div class="informalexample"><pre class="programlisting">{ 
    "type": "MultiPolygon", 
    "coordinates": [
        [ [[40, 40], [20, 45], [45, 30], [40, 40]] ], 
        [ [[20, 35], [10, 30], [10, 10], [30, 5], [45, 20],
           [20, 35]], 
          [[30, 20], [20, 15], [20, 25], [30, 20]]  ]  ]
}</pre></div><p>
</p>
</td></tr></tbody></table></div><p>These basic geometries can be wrapped within a <span class="strong"><strong>feature</strong></span>. A feature contains a geometry and also a set of properties. As an example, the following defines a feature which consists of a point geometry, and which has a single property, <code class="literal">name</code>, which can be used to describe a name for that feature:</p><div class="informalexample"><pre class="programlisting">{
  "type": "Feature",
  "geometry": {
    "type": "Point",
    "coordinates": [46.862633, -114.011593]   
  },
  "properties": {
    "name": "Missoula"  
   }
}</pre></div><p>We can go up one more <a id="id543" class="indexterm"/>level in the hierarchy, and define what is known as a <span class="strong"><strong>feature </strong></span><a id="id544" class="indexterm"/>
<span class="strong"><strong>collection</strong></span>:</p><div class="informalexample"><pre class="programlisting">{ 
    "type": "FeatureCollection",
    "features": [
      { "type": "Feature",
        "geometry": {"type": "Point", 
        "coordinates": [102.0, 0.5]},
        "properties": {"prop0": "value0"} },
      { "type": "Feature",
        "geometry": {
          "type": "LineString",
          "coordinates": [
            [102.0, 0.0], [103.0, 1.0],[104.0, 0.0], [105.0, 1.0]]
          },
        "properties": { "prop0": "value0", "prop1": 0.0 }
        },
      { "type": "Feature",
         "geometry": {
           "type": "Polygon",
           "coordinates": [
             [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
               [100.0, 1.0], [100.0, 0.0] ]  ]
         },
         "properties": {
           "prop0": "value0", "prop1": {"this": "that"} }
         }
       ]
     }</pre></div><p>By combining geometries, features, and feature collections, it is possible to describe very complex shapes such as maps.</p><p>But one of the problems with GeoJSON is that it is very verbose, and particular geometries and features cannot be reused. If the same geometry is required in multiple locations, it must be completely specified a second time.</p><p>To help fix this situation, TopoJSON was created. TopoJSON provides additional constructs for the encoding of topology and reuse. Instead of discretely describing each geometry, TopoJSON allows you to define geometries, and then stitch them together using concepts known <a id="id545" class="indexterm"/>as <span class="strong"><strong>arcs</strong></span>.</p><p>Arcs allows TopoJSON to eliminate redundancy, and to provide a much more compact representation as compared to GeoJSON. It is stated that TopoJSON can commonly provide 80 percent compression over GeoJSON. With every millisecond of the download time of a web page being important, this can be significant for user experience when using large sets of geometry.</p><p>A full explanation of TopoJSON is a bit beyond the scope of this book, but to briefly demonstrate it, we can look at the following and briefly examine its content:</p><div class="informalexample"><pre class="programlisting">{
  "type": "Topology",
  "objects": {
    "example": {
      "type": "GeometryCollection",
      "geometries": [
        { "type": "Point",
          "properties": {
            "prop0": "value0" },
          "coordinates": [102, 0.5]
        },
        { "type": "LineString",
          "properties": {
            "prop0": "value0",
            "prop1": 0 },
          "arcs": [0]
        },
        { "type": "Polygon",
          "properties": {
            "prop0": "value0",
            "prop1": {
              "this": "that"
            }
          },
          "arcs": [[-2]]
        }
      ]
    }
  },
  "arcs": [
    [[102, 0], [103, 1], [104, 0], [105, 1]],
    [[100, 0], [101, 0], [101, 1], [100, 1], [100, 0]]  ]
}</pre></div><p>This TopoJSON object has three properties: <code class="literal">type</code>, <code class="literal">objects</code>, and <code class="literal">arcs</code>. The value of <code class="literal">type</code> is always <code class="literal">"topology"</code>. The <code class="literal">objects</code> property consists of a geometry collection similar to those in GeoJSON, with the difference that instead of specifying coordinates, the object can, instead, specify one or more arcs.</p><p>Arcs are the big difference in TopoJSON versus GeoJSON, and represent the means of reuse. The arcs property provides an array of arrays of positions, where a position is essentially a coordinate.</p><p>These arcs are referenced by geometries of 0-based array semantics. Hence, the <code class="literal">LineString</code> geometry in the preceding code is referencing the first arc in the topology object by specifying <code class="literal">arcs[0]</code>.</p><p>The polygon object is referencing an arc with value <code class="literal">-2</code>. A negative arc value specifies that the one's complement of the arc that should be utilized. This essentially infers that the positions in the arc should be reversed. Therefore, <code class="literal">-2</code> instructs to get the reversed position of the second arc. This is one of the strategies that TopoJSON uses to reuse and compress data.</p><p>There are other options, <a id="id546" class="indexterm"/>such as transforms and bounding boxes, and other rules. For a more detailed specification, please see <a class="ulink" href="https://github.com/mbostock/topojson-specification">https://github.com/mbostock/topojson-specification</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note138"/>Note</h3><p>An important thing to note about TopoJSON is that D3.js itself only uses GeoJSON data. To use <a id="id547" class="indexterm"/>data in the TopoJSON format, you will need to use the TopoJSON plugin available at <a class="ulink" href="https://github.com/mbostock/topojson">https://github.com/mbostock/topojson</a>. This plugin will convert TopoJSON into GeoJSON that can be used by D3.js functions, thereby affording the capabilities of TopoJSON to your D3.js application.</p></div></div></div></div>
<div class="section" title="Creating a map of the United States"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec57"/>Creating a map of the United States</h1></div></div></div><p>Our first examples <a id="id548" class="indexterm"/>will examine creating a map of the United States. We will start with an example that loads the data and gets the map rendered, and then we will examine styling the map to make it more visible, followed by examples of modifying the projection used to render the content more effectively.</p><div class="section" title="Creating our first map of the United States with GeoJSON"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec72"/>Creating our first map of the United States with GeoJSON</h2></div></div></div><p>Our first <a id="id549" class="indexterm"/>map will render the United States. We will <a id="id550" class="indexterm"/>use a GeoJSON data file, <code class="literal">us-states.json</code>, available at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-states.json">https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-states.json</a>. The following are the first few lines of this file, and demonstrate how the shapes of the states are organized within the file:</p><div class="informalexample"><pre class="programlisting">{"type":"FeatureCollection","features":[
  { "type": "Feature",
    "id": "01",
    "properties": { "name": "Alabama" },
    "geometry": {
      "type": "Polygon",
      "coordinates": [ [
          [ -87.359296, 35.00118 ], [ -85.606675, 34.984749 ], 
          [ -85.431413, 34.124869 ], [ -85.184951, 32.859696 ], 
          [ -85.069935, 32.580372 ], [ -84.960397, 32.421541 ],
          [ -85.004212, 32.322956 ], [ -84.889196, 32.262709 ], 
...</pre></div><p>
<code class="literal">FeatureCollection</code> at the top level consists of an array of features, each element of which is a state (or territory) as well as Washington D.C. Each state is a feature, has a single property <code class="literal">Name</code>, and a polygon geometry representing the outline of the state expressed in latitude and longitude tuples.</p><p>The code for the example is available at the following link:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note139"/>Note</h3><p>bl.ock (12.1): <a class="ulink" href="http://goo.gl/dzKsVd">http://goo.gl/dzKsVd</a>
</p></div></div><p>On opening the URL, you will see the following map:</p><div class="mediaobject"><img src="graphics/B04230_12_09.jpg" alt="Creating our first map of the United States with GeoJSON"/></div><p>The code required to take this data and render a map is sublimely simple (by design). It begins by <a id="id551" class="indexterm"/>creating the main SVG element:</p><div class="informalexample"><pre class="programlisting">var width = 950, height = 500;
var svg = d3.select('body')
    .append('svg')
    .attr({
        width: width,
        height: height
    });</pre></div><p>GeoJSON is simply <a id="id552" class="indexterm"/>JSON and can be loaded with <code class="literal">d3.json()</code>:</p><div class="informalexample"><pre class="programlisting">var url = 'https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-states.json';
d3.json(url, function (error, data) {
    var path = d3.geo.path();
    svg.selectAll('path')
        .data(data.features)
        .enter()
        .append('path')
        .attr('d', path);
});
d3.json("/data/us-states.json", function (error, data) {</pre></div><p>Once we have the data, we can then create a <code class="literal">d3.geo.path()</code>. This object has the smarts for taking the features in the GeoJSON and converting them into an SVG path. The code then adds a path to the main SVG element, binds the data, and sets the <code class="literal">d</code> property of the path to our <code class="literal">d3.geo.path()</code> object.</p><p>Wow, with just <a id="id553" class="indexterm"/>a few lines of code, we have drawn a <a id="id554" class="indexterm"/>map of the United States!</p></div></div>
<div class="section" title="Styling the map of the United States"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec58"/>Styling the map of the United States</h1></div></div></div><p>Overall, this image <a id="id555" class="indexterm"/>is dark, and the borders between the states are not particularly visible. We can change this by providing a style for the fill and stroke values used to render the map.</p><p>The code for this example is available at the following link:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note140"/>Note</h3><p>bl.ock (12.2): <a class="ulink" href="https://goo.gl/chhKjz">https://goo.gl/chhKjz</a>
</p></div></div><p>When opening this URL, you will see the following map:</p><div class="mediaobject"><img src="graphics/B04230_12_10.jpg" alt="Styling the map of the United States"/></div><p>The only change to the previous example is to set the fill to transparent, and the borders to black:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('path')
   .data(data.features)
   .enter()
   .append('path')
   .attr('d', path)
      .style({ fill: 'none', stroke: 'black' });</pre></div><div class="section" title="Using the albersUsa projection"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec73"/>Using the albersUsa projection</h2></div></div></div><p>You may have a <a id="id556" class="indexterm"/>few questions about the map in the previous two examples. First, how is the map scaled to the size of the SVG element? Second, can I change this scale? And why are Alaska and Hawaii drawn down where Mexico would <a id="id557" class="indexterm"/>normally be?</p><p>These are related to some underlying assumptions about a <span class="strong"><strong>projection</strong></span>. A projection is a way of taking geographic data, which is 2D data (latitude and longitude), but which is really on a three dimensional sphere (the earth), and rendering it onto a 2D surface with specific dimensions (your computer screen or viewport in the browser).</p><p>In this example, D3.js made some implicit assumptions on these factors. To help exemplify these assumptions, suppose we change the SVG element to be of size 500 x 250. When running this, we get the following output:</p><div class="mediaobject"><img src="graphics/B04230_12_11.jpg" alt="Using the albersUsa projection"/></div><p>The code that creates this is available at the following location. The only change from the previous example is that the height and width of the SVG element have each been halved:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note141"/>Note</h3><p>bl.ock (12.3): <a class="ulink" href="http://goo.gl/41wyCY">http://goo.gl/41wyCY</a>
</p></div></div><p>The result is that the actual rendering is the same size, and we have clipped the lower and rightmost three-quarters of the map due to the smaller container.</p><p>Why is this? It is because, by default, D3.js uses a projection known as an <span class="strong"><strong>albersUsa</strong></span> projection, which has a number of assumptions that come with it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The dimensions of the resulting map are 1024 x 728</li><li class="listitem" style="list-style-type: disc">The map is centered at half of the width and height (512, 364)</li><li class="listitem" style="list-style-type: disc">The projection also places Alaska and Hawaii in the lower-left side of the map (aha!)</li></ul></div><p>To change these assumptions, we can create our own <code class="literal">albersUsa</code> projection using a <code class="literal">d3.geo.albersUsa()</code> projection object. This object can be used to specify both a translation and scaling of the rendering of the results.</p><p>The following example <a id="id558" class="indexterm"/>creates an <code class="literal">albersUsa</code> projection and centers the map:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note142"/>Note</h3><p>bl.ock (12.4): <a class="ulink" href="http://goo.gl/1e4DGp">http://goo.gl/1e4DGp</a>
</p></div></div><p>With the following <a id="id559" class="indexterm"/>result:</p><div class="mediaobject"><img src="graphics/B04230_12_12.jpg" alt="Using the albersUsa projection"/></div><p>The code creates a <code class="literal">d3.geo.albersUsa</code> projection, and tells it to center the map of the United States at <code class="literal">[width/2, height/2]</code>:</p><div class="informalexample"><pre class="programlisting">var projection = d3.geo.albersUsa()
    .translate([width / 2, height / 2]);</pre></div><p>The projection object then needs to be assigned to the <code class="literal">d3.geo.path()</code> object using its <code class="literal">.projection()</code> function:</p><div class="informalexample"><pre class="programlisting">var path = d3.geo.path()
    .projection(projection);</pre></div><p>We have translated the center of the map, but the scale is still the same size. To change the scale, we use the projection's <code class="literal">.scale()</code> function. The following example sets the scale to the width, telling D3.js that the width of the map should not be 1024, but the value of <code class="literal">width</code> and <code class="literal">height</code>:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note143"/>Note</h3><p>bl.ock (12.5): <a class="ulink" href="http://goo.gl/O51jPN">http://goo.gl/O51jPN</a>
</p></div></div><p>The preceding example results in a properly scaled map:</p><div class="mediaobject"><img src="graphics/B04230_12_13.jpg" alt="Using the albersUsa projection"/></div><p>The only difference in the code is the call to <code class="literal">.scale()</code> on the projection:</p><div class="informalexample"><pre class="programlisting">var projection = d3.geo.albersUsa()
    .translate([width / 2, height / 2])
    .scale([width]);</pre></div><p>Note that we only pass a <a id="id560" class="indexterm"/>single value to scale. The projection scales along the width, and then automatically and proportionately along the height.</p></div></div>
<div class="section" title="Creating a flat map of the world"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec59"/>Creating a flat map of the world</h1></div></div></div><p>The <span class="strong"><strong>albersUsa</strong></span> <a id="id561" class="indexterm"/>projection is one of many D3.js supplied projection objects. You can see the full list of these projections at <a class="ulink" href="https://github.com/mbostock/d3/wiki/Geo-Projections">https://github.com/mbostock/d3/wiki/Geo-Projections</a>.</p><p>We don't have space to demonstrate all of these in this book, but a few are worth the effort to demonstrate a couple of TopoJSON concepts. Specifically, we will demonstrate the rendering of a map of the countries of the world, sourced from TopoJSON, and projected onto both flat and spherical surfaces.</p><p>For data in these examples, will use the <code class="literal">world-110m.json</code> data file provided with the TopoJSON data library source code available at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/world-110m.json">https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/world-110m.json</a>.</p><p>This data represents country data with features, specified at a 110-meter resolution.</p><div class="section" title="Loading and rendering with TopoJSON"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec74"/>Loading and rendering with TopoJSON</h2></div></div></div><p>Now let's examine <a id="id562" class="indexterm"/>loading and rendering of TopoJSON. The following example <a id="id563" class="indexterm"/>demonstrates the process:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note144"/>Note</h3><p>bl.ock (12.6): <a class="ulink" href="http://goo.gl/aLhKKe">http://goo.gl/aLhKKe</a>
</p></div></div><p>The code does not vary much from the previous example. The change comes after the data is loaded:</p><div class="informalexample"><pre class="programlisting">var path = d3.geo.path();
var countries = topojson.feature(world,
                           world.objects.countries).features;
svg.selectAll('path')
    .data(countries)
    .enter()
    .append('path')
    .attr('d', path)
    .style({
        fill: 'black',
        stroke: 'white'
    });</pre></div><p>The example still uses a <code class="literal">d3.geo.path()</code> object, but this object cannot directly be given the TopoJSON. What needs to be done is to first extract the portion of this data that represents the countries, which is done by calling the <code class="literal">topojson.feature()</code> function.</p><p>The <code class="literal">topojson</code> variable is globally declared in the <code class="literal">topojson.js</code> file. Its <code class="literal">.feature()</code> function, when given a TopoJSON object (in this case, <code class="literal">world</code>), and a <code class="literal">GeometryCollection</code> (in this case, <code class="literal">world.objects.countries</code>), returns a GeoJSON feature that can be used by a path.</p><p>The selection to render the map then binds to this result, giving us the following map:</p><div class="mediaobject"><img src="graphics/B04230_12_14.jpg" alt="Loading and rendering with TopoJSON"/></div><p>Whoops! That's not what we expected (but as we will see, it is exactly what we coded). Why is everything <a id="id564" class="indexterm"/>globed together? It is because we are still using the default <a id="id565" class="indexterm"/>projection, a <code class="literal">d3.geo.albersUsa()</code> projection.</p></div><div class="section" title="Creating a map of the world using a Mercator projection"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec75"/>Creating a map of the world using a Mercator projection</h2></div></div></div><p>To fix this, we <a id="id566" class="indexterm"/>simply need to create a Mercator <a id="id567" class="indexterm"/>projection object, and apply it to the path. This is a well known projection that renders the map of the globe in a rectangular area.</p><p>The process is demosntrated in the following example:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note145"/>Note</h3><p>bl.ock (12.7): <a class="ulink" href="http://goo.gl/IWQPte">http://goo.gl/IWQPte</a>
</p></div></div><p>The only difference in this code is the setup of the path to use a Mercator projection object:</p><div class="informalexample"><pre class="programlisting">    var projection = d3.geo.mercator()
        .scale((width + 1) / 2 / Math.PI)
        .translate([width / 2, height / 2]);
    var path = d3.geo.path().projection(projection);</pre></div><p>We need to give the projection object a little information about the width and height of our rendering, and the resulting map is now the following, which looks a lot more like the familiar world map:</p><div class="mediaobject"><img src="graphics/B04230_12_15.jpg" alt="Creating a map of the world using a Mercator projection"/></div></div><div class="section" title="Creating spherical maps with orthographic projection"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec76"/>Creating spherical maps with orthographic projection</h2></div></div></div><p>Now let's <a id="id568" class="indexterm"/>change our projection <a id="id569" class="indexterm"/>to an <span class="strong"><strong>orthographic</strong></span> projection. This projection maps data on to a simulated sphere. This is demonstrated by the following example:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note146"/>Note</h3><p>bl.ock (12.8): <a class="ulink" href="http://goo.gl/M464W8">http://goo.gl/M464W8</a>
</p></div></div><p>This example simply changes the previous one by using a <code class="literal">d3.geo.orthographic()</code> projection object:</p><div class="informalexample"><pre class="programlisting">    var projection = d3.geo.orthographic();
    var path = d3.geo.path().projection(projection);</pre></div><p>The preceding example code gives us this beautiful rendering of the planet:</p><div class="mediaobject"><img src="graphics/B04230_12_16.jpg" alt="Creating spherical maps with orthographic projection"/></div><p>If you examine this closely, you will notice that it is not quite perfect. Notice that Australia seems to be colliding with Africa and Madagascar, and New Zealand is seen in the South Atlantic ocean.</p><p>This is because <a id="id570" class="indexterm"/>this projection renders through all 360 degrees of the globe, and we are essentially seeing through a <a id="id571" class="indexterm"/>clear globe to the backside of the land masses on the far side.</p><p>To fix this, we can use the <code class="literal">.clipAngle()</code> function of the Mercator projection. The parameter is the number of degrees around the center point to which the landmasses should be rendered.</p><p>The following example demonstrates this in action:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note147"/>Note</h3><p>bl.ock (12.9): <a class="ulink" href="http://goo.gl/G28ir0">http://goo.gl/G28ir0</a>
</p></div></div><p>This changes one line of code:</p><div class="informalexample"><pre class="programlisting">var projection = d3.geo.orthographic()
   .clipAngle(90);</pre></div><p>And gives us the following result:</p><div class="mediaobject"><img src="graphics/B04230_12_17.jpg" alt="Creating spherical maps with orthographic projection"/></div><p>It may not be apparent in the image provided in the book, but this image of the globe on the web page is fairly small. We can change the scaling of the rendering using the <code class="literal">.scale()</code> function of the projection. The default value for scale is 150, and the corresponding values will make the rendering larger or smaller.</p><p>The following <a id="id572" class="indexterm"/>example makes the <a id="id573" class="indexterm"/>globe twice as large along with setting the center of the globe to not be clipped by the SVG container:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note148"/>Note</h3><p>bl.ock (12.10): <a class="ulink" href="http://goo.gl/EVsHgU">http://goo.gl/EVsHgU</a>
</p></div></div><div class="informalexample"><pre class="programlisting">var projection = d3.geo.orthographic()
    .scale(300)
    .clipAngle(90)
    .translate([width / 2, height / 2]); </pre></div><p>This orthographic projection, by default, centers the view on the globe at latitude and longitude (<span class="strong"><strong>0,0</strong></span>). If we want to center on another location, we need to <code class="literal">.rotate()</code> the projection by a number of degrees of latitude and longitude.</p><p>The following example rotates the globe to show the United States prominently:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note149"/>Note</h3><p>bl.ock (12.11): <a class="ulink" href="http://goo.gl/1acSjF">http://goo.gl/1acSjF</a>
</p></div></div><p>The one change to the projection is the following:</p><div class="informalexample"><pre class="programlisting">var projection = d3.geo.orthographic()
    .scale(300)
    .clipAngle(90)
    .translate([width / 2, height / 2])
    .rotate([90, -40]);</pre></div><p>This change <a id="id574" class="indexterm"/>in the projection <a id="id575" class="indexterm"/>gives us the following result:</p><div class="mediaobject"><img src="graphics/B04230_12_19.jpg" alt="Creating spherical maps with orthographic projection"/></div></div></div>
<div class="section" title="Spicing up a globe"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec60"/>Spicing up a globe</h1></div></div></div><p>Although this <a id="id576" class="indexterm"/>globe is quite impressive for the amount of code used to create it, it feels a little dull. Let's differentiate the countries a little more, and also add the lines of latitude and longitude.</p><div class="section" title="Coloring the countries on a globe"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec77"/>Coloring the countries on a globe</h2></div></div></div><p>We can <a id="id577" class="indexterm"/>color the countries on the globe using a <code class="literal">d3.scale.category20()</code> color scale. But we can't simply rotate through the colors, as there will be cases where adjacent countries will be filled with the same color.</p><p>To avoid this, we will take advantage of another function of TopoJSON, <code class="literal">topojson.neighbors()</code>. This function will return, given a set of geometries (like the countries), a data structure that identifies which geometries are adjacent to each other. We can then utilize this data to prevent the potential problem with colors.</p><p>The process is demonstrated in the following example:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note150"/>Note</h3><p>bl.ock (12.12): <a class="ulink" href="http://goo.gl/9UimER">http://goo.gl/9UimER</a>
</p></div></div><p>The projection in this example remains the same. The remainder of the code is changed.</p><p>We start by using the same projection as the last example so that code is not repeated here. The following creates the data structure of the colors, the countries, and the neighbors:</p><div class="informalexample"><pre class="programlisting">var color = d3.scale.category20();
var countries = topojson.feature(world,
                         world.objects.countries).features;
var neighbors = topojson.neighbors(
                         world.objects.countries.geometries);</pre></div><p>The creation of the globe then uses the following statement:</p><div class="informalexample"><pre class="programlisting">var color = d3.scale.category20();
svg.selectAll('.country')
    .data(countries)
    .enter()
    .append('path')
    .attr('d', path)
    .style('fill', function (d, i) {
        return color(d.color = d3.max(neighbors[i],
            function (n) { 
                return countries[n].color; 
            })
            + 1 | 0);
    });</pre></div><p>Our resulting globe is the following:</p><div class="mediaobject"><img src="graphics/B04230_12_20.jpg" alt="Coloring the countries on a globe"/></div><p>Pretty nice! But it's still lacking in the lines of longitude or latitude, and you can't really tell what the extents of the globe are. Let's fix that now by adding the lines of latitude and longitude.</p><p>You'll be really surprised at how easy it is to add the latitudes and longitudes. In D3.js, these are referred to as <span class="strong"><strong>graticules</strong></span>. We create them by instantiating a <code class="literal">d3.geo.graticules()</code> object, and then by appending a separate path prior to the path for the countries.</p><p>This is <a id="id578" class="indexterm"/>demonstrated in the following example:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note151"/>Note</h3><p>bl.ock (12.13): <a class="ulink" href="http://goo.gl/5eJOai">http://goo.gl/5eJOai</a>
</p></div></div><p>The only code added to the previous example is the following:</p><div class="informalexample"><pre class="programlisting">var graticule = d3.geo.graticule();
svg.append('path')
    .datum(graticule)
    .attr('d', path)
    .style({
        fill: 'none',
        stroke: '#777',
        'stroke-width': '.5px',
        'stroke-opacity': 0.5
    });</pre></div><p>The change in <a id="id579" class="indexterm"/>code results in the following:</p><div class="mediaobject"><img src="graphics/B04230_12_21.jpg" alt="Coloring the countries on a globe"/></div><p>Voila! And as they say, easy-peasy!</p></div></div>
<div class="section" title="Adding interactivity to maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec61"/>Adding interactivity to maps</h1></div></div></div><p>What good is <a id="id580" class="indexterm"/>a map if the user is not able to pan and zoom around the map to change the focus, and take a closer look at things? Fortunately, because of D3.js, this becomes very simple to implement. We will look at three different examples of interactivity and maps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Panning and zooming a world map</li><li class="listitem" style="list-style-type: disc">Highlighting country borders on <code class="literal">mouseover</code></li><li class="listitem" style="list-style-type: disc">Rotating a globe with the mouse</li></ul></div><div class="section" title="Panning and zooming a world map"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec78"/>Panning and zooming a world map</h2></div></div></div><p>To demonstrate <a id="id581" class="indexterm"/>panning and zooming of a world map, we will make a few <a id="id582" class="indexterm"/>modifications to our world Mercator projection example. These modifications will be for using the mouse wheel to zoom in and out, and to be able to drag the map to move it to another center.</p><p>A possible image with this version of the map code could look like the following, which is centered just east of Brazil, and brought up several factors of zoom:</p><div class="mediaobject"><img src="graphics/B04230_12_23.jpg" alt="Panning and zooming a world map"/></div><p>There are a couple of considerations that we should take into account when panning and zooming a map:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can only zoom in and out between two extents so that we do not zoom out too far as to lose sight of the map, or too close as to get lost in a single country</li><li class="listitem" style="list-style-type: disc">We can only drag the map to a certain extent to ensure that it is constrained and not dragged off some edge</li></ul></div><p>The example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note152"/>Note</h3><p>bl.ock (12.14): <a class="ulink" href="http://goo.gl/jjouGK">http://goo.gl/jjouGK</a>
</p></div></div><p>Much of the code is reused from the Mercator projection example, and also adds the code to uniquely color the countries.</p><p>The creation of the main SVG element differs to allow for drag and zoom. This starts with creating a zoom behavior, and assigning it to the main SVG element. Additionally, since we need to zoom <a id="id583" class="indexterm"/>the client elements, we add a group to facilitate this action:</p><div class="informalexample"><pre class="programlisting">var zoom = d3.behavior.zoom()
    .scaleExtent([1, 5])
    .on('zoom', moveAndZoom);

var svg = d3.select('body')
    .append('svg')
    .attr({
        width: width,
        height: height
     })
    .call(zoom);
var mainGroup = svg.append('g');</pre></div><p>The rest of the main part of the code loads the data and renders the map, and is identical to the previous examples.</p><p>The <code class="literal">moveAndZoom</code> <a id="id584" class="indexterm"/>function, which will be called on any drag and zoom events, is given as follows:</p><div class="informalexample"><pre class="programlisting">function moveAndZoom() {
    var t = d3.event.translate;
    var s = d3.event.scale;

    var x = Math.min(
        (width / height) * (s - 1),
        Math.max(width * (1 - s), t[0]));

    var h = height / 4;
    var y = Math.min(
        h * (s - 1) + h * s,
        Math.max(height * (1 - s) - h * s, t[1]));

    mainGroup.attr('transform', 'translate(' + x + ',' + y +
                                        ')scale(' + s + ')');
}</pre></div><p>From these values, we need to adjust the SVG translate on the map based upon the current mouse position, while taking into account the scale level. We also do not want this to translate the map in any direction such that there is padding between the map and the boundaries; this is handled by combined calls to <code class="literal">Math.min</code> and <code class="literal">Math.max</code>.</p><p>Congratulations, you now have a fully pan and scan map!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note153"/>Note</h3><p>Note that as you zoom in, the boundaries on the countries are fairly ragged. This is due to the 110-<a id="id585" class="indexterm"/>meter resolution of the data. To have <a id="id586" class="indexterm"/>more accurate graphics, use the files with the finer details. Even better, dynamically change to higher resolution data depending upon the zoom level.</p></div></div></div><div class="section" title="Highlighting country borders on mouse hover"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec79"/>Highlighting country borders on mouse hover</h2></div></div></div><p>Now let's add <a id="id587" class="indexterm"/>another interactivity effect to our map: highlighting the border of a country which has the mouse currently over its geometry. This will help us accentuate the country the user is currently examining. A quick demonstration of this is the following, where Peru has a thin white border:</p><div class="mediaobject"><img src="graphics/B04230_12_24.jpg" alt="Highlighting country borders on mouse hover"/></div><p>The example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note154"/>Note</h3><p>bl.ock (12.15): <a class="ulink" href="http://goo.gl/DTtJ2A">http://goo.gl/DTtJ2A</a>
</p></div></div><p>This is implemented with a few modifications to the previous example. The modifications start with the creation of the top-level group element:</p><div class="informalexample"><pre class="programlisting">mainGroup.style({
    stroke: 'white',
    'stroke-width': 2,
    'stroke-opacity': 0.0
});</pre></div><p>This code informs D3.js that all SVG elements contained within the group will have a 2-pixel white border, which is initially transparent. When we hover the mouse, we will make this visible on the appropriate geometry.</p><p>Now we need to hook up mouse event handlers on each of the path elements that represent countries. On the <code class="literal">mouseover</code> event, we make the <code class="literal">stroke-opacity</code> opaque, and set it back to <a id="id588" class="indexterm"/>transparent when the mouse exits:</p><div class="informalexample"><pre class="programlisting">mainGroup.selectAll('path')
    .on('mouseover', function () {
        d3.select(this).style('stroke-opacity', 1.0);
    });
mainGroup.selectAll('path')
    .on('mouseout', function () {
        d3.select(this).style('stroke-opacity', 0.0);
    });</pre></div><p>There is one more small change that we will want to make whenever the zoom level changes. As the zoom level goes up, the country borders get disproportionately thick. To prevent this, we can add the following statement to the end of the <code class="literal">moveAndZoom</code> function:</p><div class="informalexample"><pre class="programlisting">g.style("stroke-width", ((1 / s) * 2) + "px");</pre></div><p>This is stating that the border of a country should always stay at what is visually <code class="literal">2px</code> thick, no matter what the zoom level.</p></div><div class="section" title="Rotating a globe using the mouse"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec80"/>Rotating a globe using the mouse</h2></div></div></div><p>Interactivity <a id="id589" class="indexterm"/>can also be applied to other projections. We will examine rotating an orthographic globe using the mouse. The example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note155"/>Note</h3><p>bl.ock (12.16): <a class="ulink" href="http://goo.gl/cpH0LN">http://goo.gl/cpH0LN</a>
</p></div></div><p>To save a little space, we won't show an image here, as it looks the same as the earlier example in the chapter, except that it rotates following the mouse. That, and the rotation effect is lost in a print medium.</p><p>But the way this works is very simple. The technique involves creating two scales, one for longitude and the other for latitude. Longitude is calculated as mapping the mouse position from <code class="literal">0</code> to the width of the graphic to <code class="literal">-180</code> and <code class="literal">180</code> degrees of longitude. The latitude is a mapping of the vertical mouse position to <code class="literal">90</code> and <code class="literal">-90</code> degrees:</p><div class="informalexample"><pre class="programlisting">var scaleLongitude = d3.scale.linear()
    .domain([0, width])
    .range([-180, 180]);

var scaleLatitude = d3.scale.linear()
    .domain([0, height])
    .range([90, -90]);</pre></div><p>When the mouse is moved over the SVG element, we capture it and scale the mouse position into a <a id="id590" class="indexterm"/>corresponding latitude and longitude; we then set the rotation of the projection:</p><div class="informalexample"><pre class="programlisting">svg.on('mousemove', function() {
    var p = d3.mouse(this);
    projection.rotate([scaleLongitude(p[0]), 
                       scaleLatitude(p[1])]);
    svg.selectAll('path').attr('d', path);
});</pre></div><p>It's a pretty cool little trick of mathematics and scales that allows us to be able to see every position on the entire globe.</p></div></div>
<div class="section" title="Annotating a map"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec62"/>Annotating a map</h1></div></div></div><p>Our final examples <a id="id591" class="indexterm"/>of working with maps will demonstrate making annotations to a map. The first two will demonstrate placing labels and markers on a map, and the third will demonstrate the use of gradient colors to color regions all the way down to a state level.</p><p>All of these techniques would normally involve some fairly complex math if we had to do it on our own, but thankfully, D3.js again comes to help us solve this with just a few statements.</p><div class="section" title="Labelling states using centroids"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec81"/>Labelling states using centroids</h2></div></div></div><p>The maps <a id="id592" class="indexterm"/>of the United States we've created up to this point feel a little lacking in content, as they have not had the names of the states placed over their geometries. It would be very helpful to many reading a map to have the names visible. The example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note156"/>Note</h3><p>bl.ock (12.17): <a class="ulink" href="http://goo.gl/3vChcR">http://goo.gl/3vChcR</a>
</p></div></div><p>The result of the example is the following:</p><div class="mediaobject"><img src="graphics/B04230_12_27.jpg" alt="Labelling states using centroids"/></div><p>This is actually fairly easy to implement, with only the addition of one statement to our United States <a id="id593" class="indexterm"/>Mercator projection example. The following code is placed immediately after the <code class="literal">.selectAll()</code> statement that creates the boundaries for all the states:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('text')
    .data(data.features)
    .enter()
    .append('text')
    .text(function(d) { return d.properties.name; })
    .attr({
        x: function(d) { return path.centroid(d)[0]; },
        y: function(d) { return path.centroid(d)[1]; },
        'text-anchor': 'middle',
        'font-size': '6pt'
    });</pre></div><p>This statement creates a text element for each geometric feature in the data file, and sets the text to be the value of the <code class="literal">name</code> property of the geometry object.</p><p>The position of the text uses a function of the path that calculates the <span class="strong"><strong>centroid</strong></span> of the geometry. The centroid is the mathematical center of the geometry, and can be calculated using the <code class="literal">.centroid()</code> function of a path.</p><p>For most states, especially rectangular ones, this works well. For others with irregular shapes, take Michigan for example, the placement is perhaps not optimal for aesthetics. There are various ways to fix this, but those are beyond the scope of this book (a hint: it involves adding <a id="id594" class="indexterm"/>additional data to represent location offsets for each geometry).</p></div><div class="section" title="Placing symbols at specific geographic locations"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec82"/>Placing symbols at specific geographic locations</h2></div></div></div><p>The last <a id="id595" class="indexterm"/>example with maps that we will look at will be to place SVG elements on the map at specific coordinates. Specifically, we will place circles at the position of the 50 most populous cities, and size the circle relative to the population.</p><p>The data we will use is in <code class="literal">us-cities.csv</code>, which is available at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-cities.csv">https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-cities.csv</a>. The data is straightforward; the following are the first few lines:</p><div class="informalexample"><pre class="programlisting">name,population,latitude,longitude
New York,8491079,40.6643,-73.9385
Los Angeles,3792621,34.0194,-118.4108
Chicago,2695598,41.8376,-87.6818</pre></div><p>The example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note157"/>Note</h3><p>bl.ock (12.18): <a class="ulink" href="http://goo.gl/Y9MN5q">http://goo.gl/Y9MN5q</a>
</p></div></div><p>The resulting visualization is the following:</p><div class="mediaobject"><img src="graphics/B04230_12_26.jpg" alt="Placing symbols at specific geographic locations"/></div><p>The preceding example leverages the United States Mercator examples code. This example does, however, need to load two data files. To facilitate this, we will use a library called <span class="strong"><strong>queue</strong></span> created by Mike Bostock to load these files asyncronously, and when both are complete, execute the <code class="literal">ready()</code> function. You can get this library and documentation <a id="id596" class="indexterm"/>at <a class="ulink" href="https://github.com/mbostock/queue">https://github.com/mbostock/queue</a>:</p><div class="informalexample"><pre class="programlisting">queue()
    .defer(d3.json, usDataUrl)
    .defer(d3.csv, citiesDataUrl)
    .await(function (error, states, cities) {</pre></div><p>The map is then rendered as in the earlier examples. Then we need to place the circles. To do this, we will need to convert the latitude and longitude values to <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> pixel locations. We can do this in D3.js using the projection object:</p><div class="informalexample"><pre class="programlisting">svg.selectAll('circle')
    .data(cities)
    .enter()
    .append('circle')
    .each(function(d) {
        var location = projection([d.longitude, d.latitude]);
        d3.select(this).attr({
            cx: location[0],
            cy: location[1],
            r: Math.sqrt(+d.population * 0.00004)
        });
    })
    .style({
        fill: 'blue',
        opacity: 0.75
    });</pre></div><p>For each circle that is created, this code calls the projection function passing it the latitude and longitude for each city. The return value is the <code class="literal">x</code> and <code class="literal">y</code> location of the pixel representing that location. So we just set the center of the circle to this result, and assign the circle a radius that is a scale value of the population.</p></div><div class="section" title="Creating a choropleth"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec83"/>Creating a choropleth</h2></div></div></div><p>Our last map <a id="id597" class="indexterm"/>example is for creating a <span class="strong"><strong>choropleth</strong></span>. A choropleth is a map with areas filled in with different colors to reflect the underlying data values—not just differing colors to represent different geographic boundaries. These are quite common types of visuals, and they commonly show a difference in opinion amongst the populations in adjacent regions, or how economic factors differ along neighbors.</p><p>The example is available at the following location:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note158"/>Note</h3><p>bl.ock (12.19): <a class="ulink" href="http://goo.gl/ZeTh4o">http://goo.gl/ZeTh4o</a>
</p></div></div><p>The resulting visualization is the following:</p><div class="mediaobject"><img src="graphics/B04230_12_22.jpg" alt="Creating a choropleth"/></div><p>This choropleth represents the unemployment rate in the US counties for the year 2008. The shade of blue varies from darker, representing lower unemployment, to lighter and higher unemployment.</p><p>The data for <a id="id598" class="indexterm"/>unemployment is available at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/unemployment.tsv">https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/unemployment.tsv</a>. The first few lines are the following:</p><div class="informalexample"><pre class="programlisting">id    rate
1001  .097
1003  .091
1005  .134
1007  .121
1009  .099
1011  .164</pre></div><p>The data consists of a pair of a county identifier and the respective unemployment rate. The county ID will be matched to county IDs in the <code class="literal">us.json</code> file available at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us.json">https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us.json</a>.</p><p>This file consists of TopoJSON describing the shape of all of the counties in the US, each with the same county ID in the unemployment file. A snippet of this file is the following, which shows for country <code class="literal">1001</code> the arcs that should be used to render it:</p><div class="informalexample"><pre class="programlisting">{
  "type": "Polygon",
  "id": 1001,
  "arcs": [ [ -8063, 8094, 8095, -8084, -7911 ] ]
},</pre></div><p>Our goal is to quantize the unemployment rates, and then fill each geometry with a color mapped to that quantile. It's actually easier to do than it may seem.</p><p>In this example, we <a id="id599" class="indexterm"/>will map our unemployment rates into ten quantiles. The color used for each will be specified using a style with a specific name. These are declared as follows:</p><div class="informalexample"><pre class="programlisting">&lt;style&gt;
    .q0-9 { fill:rgb(247,251,255); }
    .q1-9 { fill:rgb(222,235,247); }
    .q2-9 { fill:rgb(198,219,239); }
    .q3-9 { fill:rgb(158,202,225); }
    .q4-9 { fill:rgb(107,174,214); }
    .q5-9 { fill:rgb(66,146,198); }
    .q6-9 { fill:rgb(33,113,181); }
    .q7-9 { fill:rgb(8,81,156); }
    .q8-9 { fill:rgb(8,48,107); }
&lt;/style&gt;</pre></div><p>The data is loaded using the <code class="literal">queue()</code> function:</p><div class="informalexample"><pre class="programlisting">queue()
    .defer(d3.json, usDataUrl)
    .defer(d3.tsv, unempDataUrl, function(d) { 
                      rateById.set(d.id, +d.rate); 
     })
    .await(function(error, us) {</pre></div><p>This code uses an alternate form of <code class="literal">.defer()</code> for the unemployment data, which calls a function for each data item that is loaded (another cool thing about queue). This builds a <code class="literal">d3.map()</code> object (like a dictionary object) that maps the county ID to its unemployment rate, and we use this map later during rendering.</p><p>The county data is rendered first. To do this, we need to create a quantile scale which maps the domain from <code class="literal">0</code> to <code class="literal">0.15</code>. This will be used to map the unemployment levels to one of the styles. The range is then configured to generate the names of the nine styles:</p><div class="informalexample"><pre class="programlisting">var quantize = d3.scale.quantize()
    .domain([0, .15])
    .range(d3.range(9).map(function(i) { 
        return 'q' + i + '-9'; 
}));</pre></div><p>Next, the code creates the <code class="literal">albersUsa</code> projection and an associated path:</p><div class="informalexample"><pre class="programlisting">var projection = d3.geo.albersUsa()
    .scale(1280)
    .translate([width / 2, height / 2]);

var path = d3.geo.path()
    .projection(projection);</pre></div><p>The next step is to <a id="id600" class="indexterm"/>create a group to hold the shaded counties. Then, to this group, we will add a path for each county by binding it to the <code class="literal">counties</code> features:</p><div class="informalexample"><pre class="programlisting">svg.append('g')
    .attr('class", "counties")
    .selectAll("path")
    .data(topojson.feature(us, us.objects.counties).features)
    .enter()
    .append("path")
    .attr("class", function(d) { 
        return quantize(rateById.get(d.id)); 
     })
    .attr("d", path);</pre></div><p>Finally, we overlay the outlines of the states using a <code class="literal">white</code> stroke for the borders to help us differentiate the state borders:</p><div class="informalexample"><pre class="programlisting">svg.append('path')
    .datum(topojson.mesh(us, us.objects.states)
    .attr({
        'class': 'states',
        fill: 'none',
        stroke: '#fff',
        'stroke-linejoin': 'round',
        'd': path
    });</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note159"/>Note</h3><p>This particular piece of code also uses the <code class="literal">topojson.mesh</code> function to extract the <span class="strong"><strong>MultiPolygon</strong></span> (GeoJSON) data for all of the states from the TopoJSON object.</p></div></div><p>And that's all! We've <a id="id601" class="indexterm"/>created a choropleth, and used a coding pattern that can be reused easily with other types of data.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec63"/>Summary</h1></div></div></div><p>We started this chapter by looking briefly at GeoJSON and TopoJSON. If you do anything with maps in D3.js, you will be using one or both of these. We covered it just enough to give an understanding of its structure, and how it is used to define data that can be rendered as a map.</p><p>From there, we dove into creating several maps and covered many of the concepts that you will use in their creation. These included loading the data, creating projections, and rendering the geometries within the data.</p><p>We examined two projections, Mercator and orthographic, to give an idea of how these present data. Along the way, we also looked at how to style elements on the map, filling geometries with color, and highlighting geometries on <code class="literal">mouseover</code>.</p><p>Then we examined how to annotate our maps with labels as well as color elements based upon data (choropleths), and to place symbols on the map at specific geographic positions, with a size that is based upon the data.</p><p>At this point in the book, we have been pretty thorough in covering much of the core of D3.js, at least enough to make you very dangerous with it. But we have also only ever created stand-alone visualizations, ones that do not interact with other visualizations.</p><p>In the next chapter, the final one of this book, we will look at combining multiple D3.js visualizations using AngularJS, and where those visuals also react to the user manipulating other content on their page.</p></div></body></html>