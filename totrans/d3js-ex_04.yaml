- en: Chapter 4. Creating a Bar Graph
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。创建条形图
- en: Now that we have examined binding data and generating SVG visuals with D3, we
    will turn our attention to creating a bar graph using SVG in this chapter. The
    examples in this chapter will utilize an array static of integers, and use that
    data to calculate the height of bars, their positions, add labels to the bars,
    and add margins and axes to the graph to assist the user in understanding the
    relationships in the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了绑定数据和用D3生成SVG视觉元素，我们将在本章中关注使用SVG创建条形图。本章的示例将使用一个静态整数数组，并使用该数据来计算条形的高度、位置，为条形添加标签，以及添加边距和坐标轴以帮助用户理解数据中的关系。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a series of bars that are bound to data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建与数据绑定的条形系列
- en: Calculating the position and height of the bars
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算条形的位置和高度
- en: Using a group to uniformly position multiple elements representing a bar
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组来均匀定位表示条形的多个元素
- en: Adding margins to the graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向图表添加边距
- en: Creating and manipulating the style and labels in an axis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作坐标轴的样式和标签
- en: Adding an axis to the graph
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向图表添加坐标轴
- en: The basic bar graph
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本条形图
- en: We have explored everything that we need to draw a series of bars based upon
    data in the first three chapters. The first example in this chapter will leverage
    using SVG rectangles for drawing the bars. What we need to do now is calculate
    the size and position of the bars based upon the data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在第一、二、三章中基于数据绘制一系列条形所需的所有内容。本章的第一个例子将利用SVG矩形来绘制条形。我们现在需要做的是根据数据计算条形的大小和位置。
- en: The code for our bar graph is available at the following location. Open this
    link in your browser, and we will walk through how the code creates the visual
    that follows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们条形图的代码可在以下位置找到。在您的浏览器中打开此链接，我们将逐步讲解代码是如何创建随后的视觉效果的。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.1): [http://goo.gl/TQo2sX](http://goo.gl/TQo2sX)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.1): [http://goo.gl/TQo2sX](http://goo.gl/TQo2sX)'
- en: '![The basic bar graph](img/B04230_04_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![基本条形图](img/B04230_04_01.jpg)'
- en: 'The code starts with a declaration of the data that is to be represented as
    a graph. This example uses a hard-coded array of integers. We will look at more
    complex data types later in the book; for now, we simply start with this to get
    used to the process of binding and that of creating the bars:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从声明要表示为图的数据库开始。这个例子使用了一个硬编码的整数数组。我们将在本书的后面部分探讨更复杂的数据类型；现在，我们只是从这开始，以便熟悉绑定过程以及创建条形的过程：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we define two variables that define the width of each bar and the amount
    of spacing between each bar:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义两个变量，分别定义每个条形的宽度和每个条形之间的间距：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to scale the height of each bar relative to the maximum value in the
    data. This is determined by using the `d3.max()` function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将每个条形的高度相对于数据中的最大值进行缩放。这是通过使用`d3.max()`函数来确定的。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we create the main SVG element by placing it inside the body of the document,
    and assign a width and height that we know will hold our visual. Finally, and
    as a matter of practice that will be used throughout this book, we will append
    a top-level group element in the SVG tag. We will then place our bars within this
    group instead of placing them directly in the SVG element:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过将其放置在文档的主体内部来创建主要的SVG元素，并分配一个宽度和高度，我们知道这将容纳我们的视觉元素。最后，作为一个将在整本书中使用的实践，我们将在SVG标签中附加一个顶级组元素。然后，我们将条形放置在这个组内，而不是直接放置在SVG元素中：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I find this practice of using a top-level group useful as it facilitates placing
    multiple complex visuals in the same SVG, such as in the case of creating a dashboard.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现使用顶级组进行这种做法很有用，因为它便于在同一SVG中放置多个复杂的视觉元素，例如在创建仪表板的情况下。
- en: In this example, we are not going to scale the data, and use an assumption that
    the container is the proper size to hold the graph. We will look at better ways
    of doing this, as also for calculating the positions of the bars, in [Chapter
    5](ch05.html "Chapter 5. Using Data and Scales"), *Using Data and Scales*. We
    simply strive to keep it simple for the moment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不会缩放数据，并假设容器是适当的大小以容纳图表。我们将在[第5章](ch05.html "第5章。使用数据和比例")中探讨更好的方法来做这件事，包括计算条形的位置，*使用数据和比例*。我们只是力求目前保持简单。
- en: 'We need to perform two pieces of math to be able to calculate the *x* and *y*
    location of the bars. We are positioning these bars at pixel locations starting
    at the bottom and the left of `graphGroup`. We need two functions to calculate
    these. The first one calculates the *x* location of the left side of the bar:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行两步数学运算才能计算出条形的*x*和*y*位置。我们将这些条形定位在`graphGroup`的底部和左侧的像素位置。我们需要两个函数来计算这些值。第一个函数计算条形左侧的*x*位置：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: During binding, this will be passed the current datum and its position within
    the `data` array. We do not actually need the value for this calculation. We simply
    calculate a multiple of the sum of the width and padding for the bar based upon
    the array position.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定过程中，这将传递当前数据项及其在`data`数组中的位置。实际上我们不需要这个值来进行计算。我们只需根据数组位置计算条形宽度与填充之和的倍数。
- en: 'Since SVG uses an upper-left origin, we need to calculate the distance from
    the top of the graph as the location from where we start drawing the bar down
    towards the bottom of the visual:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SVG使用左上角为原点，我们需要计算从图表顶部到我们开始绘制条形向下到视觉底部位置的距离：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we position each bar, we will use a translate transform that takes advantage
    of each of these functions. We can facilitate this by declaring a function which,
    given the current data item and its array position, returns the calculated string
    for the transform property based upon this data and the functions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定位每个条形时，我们将使用一个translate变换，利用这些函数中的每一个。我们可以通过声明一个函数来实现这一点，该函数给定当前数据项及其数组位置，根据这些数据和函数返回计算出的transform属性字符串：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'All we need to do now is generate the SVG visuals from the data:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的是从数据中生成SVG视觉元素：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pretty good for just a few lines of code. But all we can tell from the graph
    is the relative sizes of the data. We need more information than this to get an
    effective data visualization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 只用几行代码就做得相当不错。但从图表中我们只能看出数据的相对大小。为了得到有效的数据可视化，我们需要比这更多的信息。
- en: Adding labels to the bars
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为条形添加标签
- en: 'Now we will add a label holding the value of the datum right at the top of
    each bar. The code for this example is available at the following link:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在每个条形的顶部添加一个标签，该标签包含数据项的值。此示例的代码可在以下链接找到：
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.2): [http://goo.gl/3ltkHT](http://goo.gl/3ltkHT)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.2): [http://goo.gl/3ltkHT](http://goo.gl/3ltkHT)'
- en: 'The following image demonstrates the resulting visual:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了生成的视觉效果：
- en: '![Adding labels to the bars](img/B04230_04_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![为条形添加标签](img/B04230_04_02.jpg)'
- en: 'To accomplish this, we will modify our SVG generation such that:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将修改我们的SVG生成方式：
- en: Each bar is represented by an SVG group instead of a `rect`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个条形都由一个SVG组而不是`rect`表示。
- en: Inside each group that represents a bar, we add an SVG and a text element.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代表条形的每个组内部，我们添加一个SVG元素和一个文本元素。
- en: The group is then positioned, hence positioning the child elements as well.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将该组定位，因此也定位了子元素。
- en: The size of the `rect` is set as before, causing the containing group to expand
    to the same size.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rect`的大小设置如前，导致包含组扩展到相同的大小。'
- en: The text is positioned relative to the upper-left corner of its containing group.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本相对于其包含组的左上角定位。
- en: By grouping these elements in this manner, we can reuse the previous code for
    positioning, and utilize the benefit of the group for locating all the child visuals
    for a bar. Moreover, we only need to size and position those child elements relative
    to their own group, making that math very simple. The code for this is identical
    to the previous example through the declaration of the positioning functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式将这些元素分组，我们可以重用之前的定位代码，并利用组定位所有条形子视觉元素的优势。此外，我们只需要根据它们自己的组来调整子元素的大小和位置，这使得数学运算非常简单。此代码与之前的示例通过声明定位函数是相同的。
- en: 'The first change is in the creation of the selector that represents the bars:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变化是在创建表示条形的选择器：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead of creating a `rect`, the code now creates a group element. The group
    is initially empty, and it is assigned the transform that moves it into the appropriate
    position.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在不是创建`rect`，而是创建一个组元素。该组最初为空，并赋予将其移动到适当位置的变换。
- en: Using the selector referred to by `barGroups`, the code now appends a `rect`
    into each group while also setting the appropriate attributes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`barGroups`引用的选择器，代码现在将`rect`追加到每个组中，同时设置适当的属性。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next step is to add a `text` element to show the value of the datum. We
    are going to position this text such that it is right at the top of the bar, and
    centered in the bar.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加一个 `text` 元素来显示数据的值。我们将把这个文本放置在条形的最上方，并在条形中居中。
- en: 'To accomplish this, we need a translate transform that represents an offset
    halfway into the bar and at the top. This is common for each bar, so we can define
    a variable that is reused for each:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要一个表示条形中点偏移的平移变换。这对于每个条形都是常见的，因此我们可以定义一个可重复使用的变量：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, the we append a text element into each group, setting its text (the string
    value of the datum), the appropriate attributes for the text, and finally, the
    style for the font.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在每个组中添加一个文本元素，设置其文本（数据的字符串值）、适当的文本属性，最后是字体样式。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That was pretty easy, and it is nice to have the labels on the bars, but our
    graph could still really use axes. We will look at adding those next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，而且条形上的标签看起来很漂亮，但我们的图表仍然非常需要轴。我们将在下一节中探讨如何添加这些轴。
- en: Margins and axes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边距和轴
- en: Adding axes to the graph will give the reader a much better understanding of
    the scope of the graph and the relationship between the values in the data. D3.js
    has very powerful constructs built in for allowing us to create axes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中添加轴将使读者更好地理解图表的范围和数据值之间的关系。D3.js 内置了非常强大的结构，允许我们创建轴。
- en: Axes in D3.js are based upon another concept known as scales. While scales are
    by themselves very useful (we will cover scales in more detail in [Chapter 5](ch05.html
    "Chapter 5. Using Data and Scales"), *Using Data and Scales*), for the remainder
    of this chapter, we will examine using them to create basic axes in our bar chart.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 中的轴是基于另一个称为刻度的概念。虽然刻度本身非常有用（我们将在第 5 章[使用数据和刻度](ch05.html "第 5 章。使用数据和刻度")中更详细地介绍刻度），但在本章的剩余部分，我们将探讨如何使用它们在我们的条形图中创建基本轴。
- en: However, before we get to axes, we will first take a short but important diversion
    into the concept of margins, and that of adding a margin to our bar chart to make
    room for the axes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们讨论轴之前，我们首先简要但重要地探讨一下边距的概念，以及为我们的条形图添加边距以留出空间的概念。
- en: Creating margins in the bar graph
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在条形图中创建边距
- en: Margins have several practical uses in a graph. They can be used to provide
    spacing between the graph and other content on the page, giving the reader clean
    sightlines between their visualization and the other content. However, the real
    practical use of margins is to provide space on one or more sides of the visualization
    for providing axes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中，边距有几个实际用途。它们可以用来在图表和其他页面内容之间提供空间，使读者在他们的可视化内容和其他内容之间有清晰的视线。然而，边距的实际用途是为一或多个边的可视化提供空间，以便提供轴。
- en: 'The following image demonstrates what we want to accomplish with margins:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了我们希望通过边距实现的效果：
- en: '![Creating margins in the bar graph](img/B04230_04_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![在条形图中创建边距](img/B04230_04_03.jpg)'
- en: The grey portion is where we will place our existing graph. Then, depending
    upon the axes that we decide to use (left, top, right, bottom), we need to provide
    space in our visualization for rendering those axes just outside the graph. Note
    that a single graph could use any or all of the margins for different axes, so
    it is a good practice to build code that plans for all of them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色部分是我们将放置现有图表的位置。然后，根据我们决定使用的轴（左、上、右、下），我们需要在我们的可视化中为渲染这些轴提供空间。请注意，单个图表可以使用任何或所有边距为不同的轴，因此为所有这些构建代码是一个好习惯。
- en: In D3.js applications, this is generally performed using a concept referred
    to as **margin convention**. We will step through an example of using this concept
    to add margins to our graph. Additionally, instead of using a static size for
    our layout, we will compute the height and width of the graph based upon the number
    of data points in this example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 D3.js 应用中，这通常是通过一个称为 **边距约定** 的概念来执行的。我们将通过一个示例来展示如何使用这个概念为我们的图表添加边距。此外，我们不会使用布局的静态大小，而是将根据示例中的数据点的数量计算图表的高度和宽度。
- en: To get started, load the example from the following information box.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请从以下信息框中加载示例。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.3): [http://goo.gl/HTZ2NG](http://goo.gl/HTZ2NG)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.3): [http://goo.gl/HTZ2NG](http://goo.gl/HTZ2NG)'
- en: 'The resulting visualization for the code is seen in the following graph:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结果可视化可以在以下图表中看到：
- en: '![Creating margins in the bar graph](img/B04230_04_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![在条形图中创建边距](img/B04230_04_04.jpg)'
- en: Besides the margins, this example adds a grey background to the area behind
    the chart. This highlights the area used for the chart, and emphasizes it relative
    to the margins that are added. It also puts a rectangle around the main SVG element
    to highlight its boundaries, as it helps us see the extent of the margins added
    to the graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了边距之外，这个例子还在图表后面的区域添加了一个灰色背景。这突出了用于图表的区域，并相对于添加的边距强调了它。它还在主要 SVG 元素周围添加了一个矩形，以突出其边界，因为它有助于我们看到添加到图形中的边距范围。
- en: 'Let''s step through this example and examine how it differs from the previous
    example. We start with calculating the actual width of the area of the bars:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这个示例，并检查它与上一个示例有何不同。我们首先计算条形区域的实际宽度：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we declare a JavaScript object that will represent the size of our margins:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们声明一个代表我们边距大小的 JavaScript 对象：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using these values, we can calculate the total size of the entire visualization:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些值，我们可以计算整个可视化的总大小：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can create the main SVG element, and set it to the exact size that it
    needs to be:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建主要的 SVG 元素，并将其设置为所需的精确大小：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the visual effect, the following adds a rectangle that shows us the boundaries
    of the main SVG element:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了视觉效果，以下代码添加了一个矩形，显示了主要 SVG 元素的边界：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we add a group to hold the main part of the graph:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一个组来包含图形的主要部分：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To emphasize the area of the actual graph, a grey `rect` is added to the group:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调实际图形的区域，我们在组中添加了一个灰色的 `rect`：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The remainder of the code remains the same.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分保持不变。
- en: At this point, we have added margins around the graph, and made room on the
    left side for an axis to be drawn. Before we put that in the visualization, let's
    first take a look at an example of creating an axis to learn some of the concepts
    involved.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在图形周围添加了边距，并在左侧为绘制坐标轴腾出了空间。在我们将其放入可视化之前，让我们先看看创建坐标轴的示例，以了解其中涉及的一些概念。
- en: Creating an axis
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建坐标轴
- en: To demonstrate the creation of an axis, we will start with creating an axis
    appropriate for placement at the bottom of the graph, referred to as a **bottom**
    axis. This is the default type of axis created with D3.js. So we will start with
    it, and then examine changing the orientation after looking at a few concepts
    related to axes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示坐标轴的创建，我们将从创建一个适合放置在图形底部的坐标轴开始，称为**底部坐标轴**。这是 D3.js 默认创建的坐标轴类型。因此，我们将从这里开始，然后在查看一些与坐标轴相关的概念之后，再检查如何更改方向。
- en: 'The following is the code for the example that we will walk through, and which
    results in the generation of the subsequent axis:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要逐步讲解的示例代码，它将生成后续的坐标轴：
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.4): [http://goo.gl/TyDAH6](http://goo.gl/TyDAH6)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.4): [http://goo.gl/TyDAH6](http://goo.gl/TyDAH6)'
- en: '![Creating an axis](img/B04230_04_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![创建坐标轴](img/B04230_04_05.jpg)'
- en: 'In our example, we create the scale and axis with the following lines of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用以下代码行创建比例和坐标轴：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To create an axis, we first need to create a **scale** object using `d3.scale()`.
    A scale informs the axis about the range of values it will represent (known as
    the **domain**), and the overall size for which the axis should be rendered in
    the visual (referred to as the **range**). In this example, we are using a **linear**
    scale. A linear scale informs the axis that the values will be linearly interpolated
    from the lower to the higher value, in this case, 0 to 210.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建坐标轴，我们首先需要使用 `d3.scale()` 创建一个**比例**对象。比例会告知坐标轴它将表示的值的范围（称为**域**），以及坐标轴在视觉中应该渲染的整体大小（称为**范围**）。在这个例子中，我们使用的是**线性**比例。线性比例会告知坐标轴，值将从较低值线性插值到较高值，在这种情况下，从
    0 到 210。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: D3.js scales have uses for things other than axes. We will examine these uses
    in [Chapter 5](ch05.html "Chapter 5. Using Data and Scales"), *Using Data and
    Scales*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 比例除了用于坐标轴之外还有其他用途。我们将在第 5 章[使用数据和比例](ch05.html "第 5 章。使用数据和比例")中探讨这些用途。
- en: The axis is then created using the `d3.svg.axis()` function, and by passing
    it the scale by chaining a call to `.scale()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `d3.svg.axis()` 函数创建坐标轴，并通过调用 `.scale()` 方法传递比例。
- en: The axis scale then needs to be associated with a selection, which is performed
    using the `.call()` function. This informs D3.js that when it renders the visual
    that it should call the axis function to render itself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标轴比例随后需要与一个选择关联，这通过使用 `.call()` 函数来完成。这通知 D3.js，当它渲染视觉元素时，应该调用坐标轴函数来渲染自身。
- en: This feels a little different than the way we have created visual elements so
    far. This technique is used by D3.js because an axis is a complex set of SVG elements
    that need to be generated. The use of `.call()` allows us to separate complex
    rendering logic into a function call during the rendering pipeline, and the design
    of D3.js was made to render axes in this manner.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种感觉与我们迄今为止创建视觉元素的方式略有不同。D3.js 使用这种技术，因为坐标轴是一组复杂的 SVG 元素，需要生成。`.call()` 的使用允许我们在渲染管道中将复杂的渲染逻辑分离成函数调用，D3.js
    的设计就是为了以这种方式渲染坐标轴。
- en: The labels on the axis are automatically generated by D3.js, and are based upon
    the values of the domain. The visualized size of the axis is specified by the
    range. In this case, since this is a bottom axis, the labelling starts at the
    minimum value of 0, and D3.js uses intervals of 20 for the labels. The last label
    that fits is 200, so D3.js does not actually create a label for the maximum value
    of 210.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标轴上的标签是由 D3.js 自动生成的，并基于域的值。坐标轴的可视化大小由范围指定。在这种情况下，由于这是一个底部坐标轴，标签从 0 的最小值开始，D3.js
    使用 20 的间隔来生成标签。最后一个适合的标签是 200，因此 D3.js 实际上并没有为 210 的最大值创建标签。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the output, the label 0 is clipped. This is because the axis is positioned
    flush to the left of the SVG element. This orientation is such that the line in
    the axis is flush. Since the text for the first label is center-justified on the
    tick, its left half gets clipped. This can be fixed easily with a translation,
    which we will examine when we place the axis next to our graph.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，标签 0 被裁剪了。这是因为坐标轴位于 SVG 元素的左侧。这种方向使得轴上的线是平齐的。由于第一个标签的文本在刻度上是居中对齐的，其左半部分被裁剪了。这可以通过平移轻松修复，我们将在将坐标轴放置在我们图表旁边时进行考察。
- en: 'Inspecting the rendered axis using Developer tools, you will see the effort
    that D3.js has made to generate the axis:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开发者工具检查渲染后的坐标轴，你会看到 D3.js 在生成坐标轴上所付出的努力：
- en: '![Creating an axis](img/B04230_04_06.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![创建坐标轴](img/B04230_04_06.jpg)'
- en: What D3.js has done is generate a group for each tick on the axis and a single
    path that renders the line of the axis. Each tick group itself consists of a line
    that represents the tick on the axis and the label on the tick.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 所做的是为坐标轴上的每个刻度生成一个组，以及一个渲染坐标轴线的单个路径。每个刻度组本身由表示坐标轴刻度的线和刻度上的标签组成。
- en: Examining the output, you will notice that we do not actually see any ticks
    along the axis. This makes it difficult to realize the actual point on the axis
    that is associated with the label. This is due to the default styling that is
    used. We will make this axis look better in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输出，你会注意到实际上我们没有在轴上看到任何刻度。这使你难以意识到与标签关联的实际坐标轴上的点。这是由于默认的样式造成的。我们将在下一节中使这个坐标轴看起来更好。
- en: The reason we could not see the ticks on our axis is due to the default thickness
    of the path representing the axis. We can change this by simply modifying the
    style of the path representing the axis as well as the style of the ticks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么看不到坐标轴上的刻度，是因为表示坐标轴的路径的默认厚度。我们可以通过简单地修改表示坐标轴的路径以及刻度的样式来更改它。
- en: 'Open the following example in your browser to learn how to accomplish this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开以下示例，了解如何完成这项任务：
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.5): [http://goo.gl/xmSf2g](http://goo.gl/xmSf2g)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.5): [http://goo.gl/xmSf2g](http://goo.gl/xmSf2g)'
- en: '![Creating an axis](img/B04230_04_07.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![创建坐标轴](img/B04230_04_07.jpg)'
- en: 'This code makes a few small modifications to be able to change the style as
    shown in the following section of code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码进行了一些小的修改，以便能够像以下代码部分所示那样更改样式：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first change is that we create a group, represented by the variable `axisGroup`,
    to hold the axis that is generated. This will be used so that we can select the
    SVG elements in the axis representing the ticks and the axis line, and change
    their styles.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变化是，我们创建了一个组，用变量 `axisGroup` 表示，来保存生成的坐标轴。这将用于选择表示刻度和坐标轴线的 SVG 元素，并更改它们的样式。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's good practice to always put the axes in a group. This facilitates style
    changes like the one we are performing in this example. Moreover, it is almost
    always the case that the axis needs to be translated into a specific position
    in the visualization. An axis itself cannot be translated, so placing it in a
    group element and then transforming the group accomplishes this task.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 总是将轴放入一个组中是一个好的做法。这有助于进行像我们在本例中执行的风格更改。此外，几乎总是需要将轴转换到可视化中的特定位置。轴本身不能转换，所以将其放入一个组元素中，然后转换组来完成这个任务。
- en: 'Secondly, the code captures the nodes that result from the generation of the
    axis in the `axisNodes` variable. Using `axisNode`, we can then perform two more
    selections to find specific elements in the axis: one for the element with the
    `domain` class, and the other for the line elements with the `line` class. Using
    the results of each of these two selections, the code then sets the `fill`, `stroke`,
    and `stroke-width` properties to make them all one pixel thick black lines.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，代码捕获了在 `axisNodes` 变量中生成的轴的节点。使用 `axisNode`，我们可以进行两个额外的选择来找到轴中的特定元素：一个用于具有
    `domain` 类的元素，另一个用于具有 `line` 类的线条元素。使用这两个选择的每个结果，代码随后设置 `fill`、`stroke` 和 `stroke-width`
    属性，使它们都变成一像素厚的黑色线条。
- en: Changing the axis orientation
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变轴的方向
- en: 'D3.js axes can be rendered into four different orientations using the `.orient()`
    function on the axis, passing it the name of the orientation that is desired.
    The following table shows the orientation names that can be used:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 轴可以使用 `.orient()` 函数渲染成四种不同的方向，该函数将方向名称传递给轴。以下表格显示了可以使用的方向名称：
- en: '| `''top''` | Horizontal axis, with ticks and labels above the axis line. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `''top''` | 水平轴，刻度和标签位于轴线的上方。 |'
- en: '| `''bottom''` | Horizontal axis, with ticks and labels below the axis line
    (default) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `''bottom''` | 水平轴，刻度和标签位于轴线的下方（默认） |'
- en: '| `''left''` | Vertical axis, with ticks and labels to the left of the axis
    line |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `''left''` | 垂直轴，刻度和标签位于轴线的左侧 |'
- en: '| `''right''` | Vertical axis, with ticks and labels to the right of the axis
    line |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `''right''` | 垂直轴，刻度和标签位于轴线的右侧 |'
- en: Essentially, each of these relate to one of the four sides of a graph, such
    as the margins that were covered earlier. There is no effect of this function
    on the location of the axis in the visual (we have to do that ourselves). Instead,
    it decides whether the axis line is horizontal or vertical, and also if the labels
    are on the top or bottom of a horizontal axis or to the left or right of a vertical
    axis.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些都与图表的四个侧面之一有关，例如之前提到的边距。这个函数对轴在视觉中的位置没有影响（我们必须自己完成）。相反，它决定了轴线的水平或垂直，以及水平轴的标签是在顶部还是底部，或者垂直轴的标签是在左侧还是右侧。
- en: 'To demonstrate this, we will quickly inspect the top, right, and left orientations.
    Open the following link for an example of a top axis:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将快速检查顶部、右侧和左侧的方向。打开以下链接查看顶部轴的示例：
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.6): [http://bl.ocks.org/d3byex/8791783ee37ab76a8517](http://bl.ocks.org/d3byex/8791783ee37ab76a8517)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.6): [http://bl.ocks.org/d3byex/8791783ee37ab76a8517](http://bl.ocks.org/d3byex/8791783ee37ab76a8517)'
- en: 'There are two small modifications from the previous example. The primary change
    is that when we create the axis, we make a call to `.orient(''top'')`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例相比，这里有两个小的修改。主要变化是我们创建轴时调用了 `.orient('top')`：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second change is that we need to translate the axis down the *Y* axis.
    We do this using the following statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变化是我们需要将轴沿 *Y* 轴向下平移。我们使用以下语句来完成这个操作：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result of the preceding example is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的结果如下：
- en: '![Changing the axis orientation](img/B04230_04_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![改变轴的方向](img/B04230_04_08.jpg)'
- en: The orientation has moved the label and ticks to the top of the axis line instead
    of below.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 方向的改变使得标签和刻度移动到了轴线的顶部而不是下方。
- en: The need for a transform is perhaps a little more subtle. If the axis was not
    transformed, all that we would see in the result is a single black line at the
    top of the rendering. This is because the positioning of an axis is relative to
    the path rendering the axis line. In this case, the line would be at *y = 0*,
    and the ticks and text would be clipped as they are above the line and not visible.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 转换的需求可能稍微有点微妙。如果轴没有被转换，我们在渲染结果中看到的将是一条位于顶部的黑色线条。这是因为轴的位置是相对于绘制轴线的路径而言的。在这种情况下，线条将位于
    *y = 0*，刻度和文本会被裁剪，因为它们位于线条之上且不可见。
- en: Now open the code for the following example, which renders a right-oriented
    axis. We will not examine the code, as it is a single simple change of calling
    `.orient('right')`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开以下示例的代码，它渲染了一个右侧方向的坐标轴。我们不会检查代码，因为它只是调用 `.orient('right')` 的一个简单更改。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.7): [http://goo.gl/H16kEo](http://goo.gl/H16kEo)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.7): [http://goo.gl/H16kEo](http://goo.gl/H16kEo)'
- en: 'The result of the preceding code is the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '![Changing the axis orientation](img/B04230_04_09.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![改变坐标轴方向](img/B04230_04_09.jpg)'
- en: The following example demonstrates a left-oriented axis. This is again a simple
    change of the parameter to `.orient()`. Additionally, the code also translates
    the axis to the right a bit, as the the ticks and labels would be clipped off
    the left.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一个左侧方向的坐标轴。这又是一个简单的参数更改到 `.orient()`。此外，代码还将坐标轴向右移动一点，因为刻度和标签会被截断在左侧。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.8): [http://goo.gl/CNEFyV](http://goo.gl/CNEFyV)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.8): [http://goo.gl/CNEFyV](http://goo.gl/CNEFyV)'
- en: 'And the results are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Changing the axis orientation](img/B04230_04_10.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![改变坐标轴方向](img/B04230_04_10.jpg)'
- en: Inverting the labels on an axis
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转坐标轴上的标签
- en: We want to place a left axis on our bar chart, essentially the output of example
    *4.8*. But if you examine the axis. you will notice that the labels are increasing
    from the top to the bottom. Our graph represents **0** at the bottom with values
    increasing upwards. This axis will not be appropriate for our graph.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在条形图上放置一个左侧坐标轴，本质上就是示例 *4.8* 的输出。但如果你检查坐标轴，你会注意到标签是从上到下递增的。我们的图表在底部表示 **0**，值向上递增。这个坐标轴对我们图表来说不合适。
- en: 'This inversion of labels is a very simple change to the code. Open the following
    example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种标签反转是代码中的一个非常简单的更改。打开以下示例：
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.9): [http://goo.gl/wsm9Ab](http://goo.gl/wsm9Ab)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.9): [http://goo.gl/wsm9Ab](http://goo.gl/wsm9Ab)'
- en: The code is identical to example *4.8* except for one change.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与示例 *4.8* 相同，除了一个更改。
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We change the order of the values passed to the domain, which will essentially
    reverse the order of the labels. This gives us the following result:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改传递给域的值的顺序，这将基本上反转标签的顺序。这给我们以下结果：
- en: '![Inverting the labels on an axis](img/B04230_04_11.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![反转坐标轴上的标签](img/B04230_04_11.jpg)'
- en: The labels have been reversed into the order that we desire. Note now that the
    label 0 is clipped at the bottom. We will fix this in our next example when we
    combine the axis with the bar graph.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 标签已经反转成我们想要的顺序。注意现在标签 0 在底部被截断。我们将在下一个示例中修复这个问题，当我们把坐标轴与条形图结合起来时。
- en: Adding the axis to the graph
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将坐标轴添加到图表中
- en: 'We now have everything that we need to create a bar graph with an axis. Essentially,
    we only need to combine the code from example *4.3* with the axis code from example
    *4.9*. The following example does exactly this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建带有坐标轴的条形图所需的一切。基本上，我们只需要将示例 *4.3* 中的代码与示例 *4.9* 中的坐标轴代码结合起来。以下示例正是这样做的：
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (4.10): [http://goo.gl/MsKhUk](http://goo.gl/MsKhUk)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (4.10): [http://goo.gl/MsKhUk](http://goo.gl/MsKhUk)'
- en: 'And the result is the following graph, which is exactly what we wanted:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示，这正是我们想要的图表：
- en: '![Adding the axis to the graph](img/B04230_04_12.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![将坐标轴添加到图表中](img/B04230_04_12.jpg)'
- en: 'The code in this example is identical to the one in example *4.3* up to the
    point where we create the group to contain the axis:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的代码与示例 *4.3* 中的代码相同，直到我们创建包含坐标轴的组为止：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The change here is the translation of the axis along the *X* axis by the width
    of the left margin, and down the *Y* axis by the size of the top margin. For aesthetics,
    the code simply renders the axis with three pixels of padding.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的更改是将坐标轴沿 *X* 轴平移左边缘的宽度，沿 *Y* 轴平移顶边缘的大小。为了美观，代码只是简单地用三个像素的填充渲染坐标轴。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also note that since we have margin space at the bottom, the **0** label is
    no longer truncated.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，由于我们在底部有边距空间，**0** 标签不再被截断。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you extended your knowledge of using D3 to create a bar graph
    from a collection of integers. You learned how to position and size each element
    of the graph according to its data, and how to position groups of data that contain
    multiple visuals representing a single bar—specifically, how to add a label that
    represents the value of the underlying datum at the top of a bar.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你扩展了使用 D3 从整数集合创建条形图的知识。你学习了如何根据数据定位和调整每个元素的大小，以及如何定位包含多个表示单个条形的多视觉数据组——具体来说，如何在条形的顶部添加表示底层数据的值的标签。
- en: We then examined the facilities in D3.js for creating axes. We introduced the
    concept of a scale, which is an important facet of implementing axes. We further
    examined the different orientations available for an axis, and how to invert the
    order of the labels on an axis. Finally, we combined the axis and the bar graph
    together into an effective visualization of the data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后检查了 D3.js 中用于创建坐标轴的功能。我们介绍了比例的概念，这是实现坐标轴的一个重要方面。我们进一步探讨了坐标轴的不同方向，以及如何反转坐标轴上标签的顺序。最后，我们将坐标轴和条形图结合起来，有效地展示了数据可视化。
- en: As great as our bar chart looks in this example, we will still have several
    issues. The overall size of the graph was related to the actual values of the
    data. This was convenient for demonstrating the construction of a bar graph visualization,
    but what if the values are not integers, or if the values are extremely small
    or large? We might not see the bars at all, or the bars may be so large as to
    exceed the size of the main SVG element.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的条形图在这个例子中看起来很棒，但我们仍然会面临几个问题。图表的整体大小与数据的实际值相关。这对于演示条形图可视化的构建是方便的，但如果我们处理的数据不是整数，或者数据值非常小或非常大呢？我们可能根本看不到条形，或者条形可能太大，以至于超过了主
    SVG 元素的大小。
- en: In the next chapter, we will address these issues by learning more about scales.
    Scales will provide an exceptionally easy means of mapping data into the physical
    dimensions of a visualization. You will also learn about loading data from external
    sources, and about working with data that is more complex in structure than simple
    integers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习更多关于比例的知识来解决这些问题。比例将提供一种特别简单的方法，将数据映射到可视化的物理尺寸。你还将了解如何从外部源加载数据，以及如何处理比简单整数结构更复杂的数据。
