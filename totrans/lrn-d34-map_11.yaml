- en: Shaping Maps with Data - Hexbin Maps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different pieces of data afford different visualizations. When you want to show
    a timeline, you rarely build a vertical bar chart. You would more likely use a
    horizontal line chart. You should, of course, give yourself some freedom of expression
    when encoding data to position, shape, or color. However, the data at hand, the
    meaning you want to convey, and the cognitive decoding processes at play are important
    guides when deciding how to encode your data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on a specific map-visualization technique: **hexagonal
    binning** **maps** (**hexbin maps**). We will start with a brief journey through
    various map visualization techniques before focusing on hexbin maps. You will
    learn the conceptual and cognitive benefits of hexbin maps, what hexagons are
    useful for in comparison to other shapes, and how they are calculated.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Most of the chapter will, however, be hands on, building a hexbin map from scratch.
    Most of the attention will go into data preparation and shaping. D3 will make
    the actual visualization a breeze with the **D3-hexbin** module. We will focus
    on a pipeline of data preparation and visualization tasks that aim to be easy
    to follow. Let’s go!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing map visualization techniques
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to represent geographical data. Not surprisingly, maps are
    often involved. While maps are a compelling way to present data that can be deciphered
    effortlessly by most people, they can be overused. If you want to show which country
    has the highest percentage of forest cover, you might decide to show a globe and
    use color saturation to encode forest ratio. Alternatively, you could show a sorted
    vertical bar chart displaying the country with the highest forest cover on top
    and the country with the lowest at the bottom. The map version might look nicer
    and give your users a good intuition about locations of forest lack or riches.
    However, the bar chart gives a more concise overview over the distribution and
    country comparison of forest cover.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s assume that you have decided to use a map as the fundamental representation
    of your visual. What options are there?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Choropleth maps
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Widely known and potentially overused choropleth maps are a good choice if you
    need to compare standardized ratios across geographical units such as states,
    counties, or countries. You built a choropleth map in [chapter 4](c22382c6-84d9-411f-b795-681df2321005.xhtml),
    *Creating a Map* and in [chapter 10](328cc9b5-a87f-4492-b7ce-fa4c07cff7a1.xhtml),
    *Adding Interactivity to Your Canvas Map* comparing forest cover ratio per country
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The only visual channel you can encode your measure of choice with is color.
    The areas of the units are already given by the size of these units. This can
    draw the user’s attention away from the smaller, and toward, the larger units.
    Looking at our forest example, larger countries such as the US, Russia, or Brazil
    might get more initial attention than smaller countries, such as Luxembourg, Haiti,
    or Belize.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: To alleviate this attention problem, you should be fair to each country in the
    measure you visualize. The key rule is to not visualize absolute numbers, but
    standardized ratios related to the country. We adhered to this rule in our forest
    example by visualizing the percentage of forested area of the total country area.
    This measure has the same range for each country, independent of the country’s
    area (0 to 100%). It’s a standardized, and hence, fair measure. The absolute number
    of trees would be an unfair measure. A large country with a few trees could still
    have more trees than a small country full of trees, rendering our comparison problematic
    to pointless.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the geographical unit should define the measure you visualize.
    Tax rates, for example, are made by countries and make perfect sense to compare
    across countries. Forest cover is not (entirely) informed by a country’s actions
    and policies, and makes less sense to show in a choropleth. The countries’ actions
    still influence their forest cover, so I wouldn’t disregard it (the Dominican
    Republic, for example, has a much more conservative approach to its forests than
    neighboring Haiti), but this should be a conscious part of your choice of visualization
    technique.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'As choropleths are so omnipresent, let’s take a look at another example with
    different data: farmers'' markets in the US. They will accompany us for the rest
    of the chapter, so this is a good time to dive into it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The *farmers' markets* data we will use is published by the USDA at [https://www.ams.usda.gov/local-food-directories/farmersmarkets](https://www.ams.usda.gov/local-food-directories/farmersmarkets).
    After a bit of a clean up, we have a dataset of 8,475 markets on mainland US.
    Each market has a number of interesting variables, starting with longitude and
    latitude values we can use for the mapping, as well as name, state, and city they
    are located in. It also has 29 binary variables (as in yes/no) indicating the
    products that each market is selling. We will use this later to visualize subsets
    of markets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a choropleth of the US states (only mainland to keep it simple). It
    shows the number of farmers'' markets per 100,000 people. Light blue means few
    markets; dark blue means many markets per 100k people:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e17f4ec6-542b-4fec-a8a2-f2376a5a50a5.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: A choropleth map of farmers' markets
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: One question here has to be whether a state-wise comparison of farmers' markets
    makes much sense. Do the state-policies or cultures play a role in promoting or
    objecting to farmers' markets? Maybe. However, once we decided to go for a state-wise
    comparison of it, are we able to compare well? Texas with its size gets a lot
    of weight in the visual, suggesting southern farmers' market deprivation. We can
    see Vermont has the highest ratio (it helps that we’re pointing a red line at
    it), but what about Washington, D.C.? There are 8.5 markets per 100k people? We
    can’t even see it on the map.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Cartograms
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cartograms do away with the area problem, by encoding your values to area size.
    A cartogram of our farmers'' markets mapping the ratio to color and area size
    would look as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/153f9633-e05f-4bee-9d06-35fd343e9cc9.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: A contiguous cartogram of farmers' markets
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The area— and consequently the shape—of your map gets distorted in such a way
    that the area represents the value you want to visualize. It's great for Washington,
    D.C. which has been sized up significantly to be recognized as a farmers' markets
    heavyweight. In short, they solve the choropleth problem of attention theft, but
    create a new problem in that our geographical units are often hardly recognizable.
    Your users will be fine with this reality bend for counties, states, and countries
    they know well, but they will struggle to make sense of areas they don’t know
    the shape of. It’ll look too cryptic and reduce readability to a potential full
    loss of interest.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The contiguous cartogram has been produced with [https://github.com/shawnbot/topogram](https://github.com/shawnbot/topogram).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Dot density maps
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dot density maps are great if you want to show **counts of things** rather
    than ratios. Each thing is a dot displayed on the map. Here’s a dot density map
    of all farmers'' markets in the US:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51ee6872-ae5c-4e3d-a9a5-b303571679a9.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: A dot density map of farmers' markets
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of this visualization technique is obvious: it shows all the data.
    You can easily see where they all are and detect clusters of farmers'' markets
    across the country. The problem is that in fact it doesn’t show all the data.
    Some of the dots are overlapping in small, busy areas. A second potential problem
    is that many absolute measures in spatial analysis correlate highly with population
    distribution. So while you want to say *Look where all the farmers'' markets are*
    you are actually saying *Look where all the people are*. This doesn''t mean you
    shouldn''t show it, but you should be aware of it. By the way, our hexbin map
    will have the same problem, so be aware. Another caveat of showing all the data
    is that it might appear confusing for users to look at that amount of data and
    elements. We might want to focus the eye in a more orderly way to the clusters.
    This is where hexbin maps come in handy.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Note that this list of map visualization techniques is not complete. There are,
    of course, other map visualization techniques, such as heat maps, cluster maps,
    graduated circle, proportional symbol, or bubble maps, and non-contiguous cartograms.
    A good place to see what people visualize with and on maps is [https://flowingdata.com/category/visualization/mapping/](https://flowingdata.com/category/visualization/mapping/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Value and use of the hexagon
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hexagons can solve some of the problems we mentioned in the preceding section.
    They can help the unequal area problems of choropleth maps and can bring ordered
    focus to point clusters. Let’s look at a few first:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6006bc7d-d194-456a-bb3f-b7ab796a6924.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Hexagonal tiling
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, hexagons have equal length sides and fit nicely next to each
    other. However, they’re not just a pretty face, they also have properties we can
    leverage well in data visualization:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Hexagons divide a given area into equal-sized hexagons. This is called **tiling**
    and can also be done with other shapes such as circles, triangles, rectangles,
    or other polygons.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if you tile your wall with circles, you will end up with gaps between
    the circles. Covering a plane gap-free with repeating symmetric shapes is called
    a **regular** **tessellation** and is, in fact, only possible with squares, triangles,
    and hexagons.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these three shapes, hexagons are the highest-sided shape closest to a circle.
    Hence, they are best to represent—to **bin**—a cluster of points. Corner points
    of triangles or squares are further away from their center than corner points
    in hexagons, which make hexagons predestined for grouping dot data. Circles are
    optimal for binning, but then again, they can’t be tessellated.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s consider binning for an extra moment. **Binning** means grouping data
    together into equally sized categories. When we have a dataset of 100 people with
    varying ages, we can look at the frequency of each age, or we bin the data to
    more digestible age groups, such as 20-39, 40-69, and 70-99\. We take individual
    data points and aggregate them in larger and—usually—equally sized groups.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: In a mapping context, we can bin point location data to equally sized areas.
    Hexagons are well suited for this task as they group points well and also tessellate
    regularly across the plane. This is what a hexbin map as implemented with D3 can
    do for you. Instead of potentially piling points on top of each other as we do
    in dot density maps, we can define hexagonal areas of equal size, aggregating
    the points to a summary measure encoded with color. As such, **binning** represents
    the data for each hexagon area potentially better than individual points would
    do. The **hexagonal** **tessellation** supports the binning in that it creates
    the best possible, gap-free, and comparably fair bin shapes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'In the coming sections, we will very much focus on these **hexbin maps**, where
    each hexagon represents an equal area. Before we dive into hexbins, let’s quickly
    look at another use of hexagons you might have come across: **hexagonal choropleth
    maps**. The problem the classic choropleth map, as shown above poses, is that
    smaller states such as Vermont or Washington D.C can easily be overlooked, as
    they have such low visual weight. Other area-states such as Texas or Montana attract
    the eye through sheer size. To alleviate this, we can replace the state polygons
    with hexagons:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb4c1771-d420-4f9f-8e18-7aac5ac4dca5.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: Size emancipated US states in a hexagonal choropleth map
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Let's be clear, hexagons in a *hexbin map* as described in the preceding diagram
    and in the following sections represent equal areas. Hexagons in a *hexagonal
    choropleth map* as shown in this figure represent vastly different areas. However,
    in this case, we don’t want to focus on the spatial area of our chosen unit (US
    mainland states); we want to focus on the measure that is merely categorized by
    our chosen unit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that this comes with the cost of removing the area information entirely,
    as the US states differ greatly in area and no state looks like a hexagon. However,
    unlike the preceding classic choropleth example, this hexagonal choropleth allows
    us, for example, to easily identify Washington D.C. as a farmers' market hub and
    that might be the message we want to bring across above all.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Enough theory. Let’s make a hexbin map.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Making a hexbin map
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having improved our US state choropleth map with hexagons, let’s now use hexagons
    to alter our dot density map. There are benefits to a dot density map as we have
    seen previously, so the changes we are about to make are more alterations than
    clear improvements. Here’s what we will build:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1afbac36-728f-4032-8a1e-bb517d45dd17.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: A map of many hexagons in color
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: It’s a hexbin map showing the farmers' markets hotspots. Areas with no farmers'
    markets are shown as white hexagons, areas with many farmers' markets are shown
    in blue to dark purple. Lighter and less saturated yellow and green hexagons represent
    areas with fewer markets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the hexbin algorithm
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we want to achieve? There are two major steps we want to cover. First,
    we want to show the US as a hexagon tiling. Next, we want to highlight hexagons
    with farmers' markets, color encoding the number of markets within each hexagon.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could be content with showing a map of the US and only display
    the hexagons where farmers' markets reside. This would be less involved; however,
    it seems worthwhile to go the extra mile for esthetics and clarity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual drawing of the hexbin is simple, thanks to the `d3.hexbin()` module
    doing the hardwork of drawing the hexagons. More attention will be required when
    producing the hexagonal grid of the US. However, don’t worry; the process is straightforward
    and right here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Draw a map.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overlay the entire map with a symmetric grid of points.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only keep the grid points that are within the bounds of the map.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merge the grid points data with the location data we want to visualize.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the hexbin positions with the D3*-*hexbin module.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each hexagon, aggregate the summary statistic you want to visualize.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visualize the summary statistic (for example, by color encoding the hexagons):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/544ca0f5-3a1e-436b-b15c-a34183826271.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: The hexbin map evolution
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Setting it up
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The setup is simple. You have a single `<div>` with the `id="vis"` in the HTML
    for the visualization. In the JavaScript, you set up a global `projection` variable
    to fill soon and create an `svg` element:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Drawing the map
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, the first thing we do is to get your data into the app. So far, you
    only have the US data; however, in anticipation of the farmers'' markets point
    data, we will haul in a little later—let''s use `d3.queue()` to load our data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ready()` function gets called asynchronously as soon as the data is loaded:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In there, you check for errors, prepare the US data, and draw it. The data
    preparation is a one-liner, converting the `topo` to an array of GeoJSON polygons:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The drawing function takes the GeoJSON as its only argument. Create the projection
    and the path generator and draw the US. `projection` is a global variable as we
    will use it in other places later:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we are using the `d3.geoAlbers()` projection here. The *Albers* projection
    is a so-called **equal area-conic projection**, which distorts scale and shape
    but preserves area. This is essential when producing dot density or hexbin maps
    to not distort the perceived density of the dots across distorted areas. To put
    it differently, our hexbins represent equal areas on the projected plane, hence
    we need to make sure that the projected plane honors equal areas with an appropriate
    projection. Note that equal area-conic projections require the map maker to pick
    two parallels (circles of latitude) on which the projection is based. `d3.geoAlbers`
    has been already preconfigured, picking the two parallels *[29.5,* *45.5]*. This
    produces an optimized projection for the US. When visualizing other countries
    or map areas, you can overwrite this with the `.parallels()` method or set it
    up yourself with the `d3.geoConicEqualArea()` projection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is not too surprising:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6eff3b4a-b820-4834-a7ff-235be296018e.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: The US mainland
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: You can view this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-1](https://larsvers.github.io/learning-d3-mapping-11-1).
    Code example ;[11_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_01.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: At the conclusion of each step, you will find two links in an info box close
    to the relevant image. The first link brings you to a working implementation of
    this step that you can view in the browser. The second *code example* link brings
    you to the full code. If you're reading the print version, you can find all code
    examples at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)
    in their relevant chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let''s take one step back and look at how we produced the
    *TopoJSON* data on the command line. The original US map data comes in a shapefile
    from [https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html](https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html)
    and is converted from shapefile to TopoJSON in six steps as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `shapefile`, if you haven’t yet:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install `topojson`, if you haven’t yet:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Convert the shapefile to GeoJSON:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Convert the Geo to TopoJSON:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compress number precision:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Simplify the geometry:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can read more on command-line cartography at [http://bit.do/cl-carto](http://bit.do/cl-carto).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a point grid for our hexagons
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our aim is to draw a hexagon grid across the US map. D3-hexbin will do this
    for us later, but it can only draw a hexagon where there are points. So, we need
    to feed points to it. These points won’t have any information value for our users.
    They will only be used to produce the layout. As such, we can distinguish two
    types of points we will need:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**Layout points** to produce the hexbin tiling'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Datapoints** to render the color-scaled information'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll get to the datapoints soon, but at this stage, we’re only concerned with
    our layout points. Once done, you will have produced this wonderfully regular
    pattern of points stretching across our entire drawing area:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b810be4-f9ec-4357-a621-5257a95a216e.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: A grid of many points over the US
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: You can view this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-2](https://larsvers.github.io/learning-d3-mapping-11-2)
    and the code example at [11_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_02.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we will cut this grid to shape to fit the US silhouette,
    but let’s lay it out first. Note that this will be the most involved bit of the
    calculations. No rocket science, but don’t worry if it doesn’t click immediately.
    Things often become clearer once stepping through the code in the debugger and/or
    using a few `console.log()`’s. Anyway, here we go:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`getPointGrid()` takes only one argument: the number of columns of points we
    want. That’s enough for us to calculate the grid. First, we will get the distance
    in pixels between each dot. The distance between each dot stands in for the distance
    between the hexagon centers. `d3.hexbin()` will calculate this for us precisely
    later, but, for now, we want to get a good approximation. So, if we decide to
    have 160 columns of dots and our width is 840, the maximum distance will be *840
    / 160 = 5.25* pixels. We then calculate the number of rows. The height is 540,
    so we can fit in *540 / 5.25* rows, which equals 108 rows of dots if we round
    it down:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we will calculate the `hexRadius`. This might look funny. Why divide the
    distance by *1.5*? The D3-hexbin module will produce hexbins for us if we feed
    it **points** and a desired hexbin **radius**. The hexagon radius we set here
    should guarantee that the resulting hexagons are large enough to include at least
    one point of the grid we produce. We want a gap-free hexagon tiling after all.
    So, a tight grid should have a small radius, and a wide grid should have a wider
    radius. If we had a wide grid and a small radius, we wouldn’t get a hexagon for
    each point. There would be gaps.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, hexagons are regular shapes, and their dimensions and properties are
    nicely interconnected. The vertical distance between hexagon centers is 1.5 times
    its radius, the horizontal distance is √3 (roughly 1.73):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9b5bd24-0c14-4ba9-a787-650c1def453c.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: How hexagon distance and radius relate to each other
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Our grid points work as a proxy of hexagon centers. As such they are not 'perfectly'
    laid out in the sense that their vertical distance is the exact same as their
    horizontal distance with *5.25* pixels. In a perfect hexagon grid the vertical
    distance would be a little shorter than the horizontal distance as you can see
    in above figure. In order to get a relatively tight mesh of hexagons on the base
    of our proxy grid, we should chose a safe—meaning **wide—**radius to pass to the
    D3-hexbin module which indeed will deliver a perfect hexagon grid. We can calculate
    this radius with the formulae in the preceding figure as well as our distance
    (5.25 pixel) by solving for *Radius*. When re-shuffling the equation for the vertical
    distance *Distance = 1.5 * Radius* becomes *Radius = Distance / 1.5*. In our case
    the distance is *5.25 / 1.5 =* a radius of *3.5*. Using the horizontal distance
    would have given us a less safe—meaning tighter—radius with *5.25 / √3 = 3.03*,
    which in fact would produce a few gaps in our final tiling.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create and return the grid immediately—well, the coordinates
    for the grid that is:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`d3.range(rows * columns)` creates an array with one element per dot. We then
    iterate through each dot with `.map()` returning an object with three properties:
    `x`, `y`, and `datapoint`. These properties will define each of our grid points.
    The *x* coordinate will increase by the `hexDistance` every point and reset to
    *0* for each row (or put differently, after it runs through all columns). The
    *y* coordinate will increase by the `hexDistance` for each new row.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Equally important, each of these grid points will get a property called `datapoints`,
    which we will set to *0*. This property will distinguish all the layout points
    (*0*) from the data points (*1*) later, allowing us to focus on the latter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! This was the most difficult bit, and you’re still here proudly
    lifting a square grid of tomato-colored dots into the air.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that not crucial but extremely helpful is visualizing the grids and points
    we make on the way. Here’s a little function that draws points if they are stored
    in an array of objects with `x` and `y` properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keeping only the points within the map
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The square grid of points is still reasonably far away from the shape of the
    US. Let’s change that. Thanks to D3’s own `d3.polygonContains()` method, this
    is rather simple. The method takes screen coordinates of a polygon and a point,
    and for each point returns `true` if the point is in the polygon and `false` if
    it isn’t. It couldn’t be more helpful.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the polygon of our US map, we write a small function called `getPolygonPoints()`
    and use it as a next step in our `ready()` function, which so far looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The only argument we pass in is the array of GeoJSON objects for our map called
    `us`. For simplicity reasons, we decided to only look at the mainland US. So,
    the first thing we need to do is focus our data on the US mainland:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`data.features[0].geometry.coordinates` holds 11 arrays of polygon point pairs,
    describing mainland US as well as Alaska, Hawaii, and further offshore areas.
    We want to focus on mainland US, whose outline is represented by the first element
    in the **seventh** array. Note that this might be different if your data comes
    from a different source or is being assembled differently.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will loop through all `polygonPoints`, which are in longitude and latitude,
    and convert them into *x* and *y* coordinates for further use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have both the polygon boundaries of the US and our grid points in pixel
    coordinates. All we need to do now is to identify the grid points that lie within
    mainland US:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We pass the two arrays to a function we boldly name `keepPointsInPolygon()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In here, we create an empty array called `pointsInPolygon`, which will hold
    our US-exclusive points. We then loop through our grid points and check for each
    whether it’s within the US polygon or not. If it is, we wave it through into `pointsInPolygon.`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to draw these points, we would see a pointy US:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8318924b-196e-4f81-941e-7ef0bf4f3085.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: The US in points
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: You can view this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-3](https://larsvers.github.io/learning-d3-mapping-11-3)
    the and code example at [11_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_03.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Making the hex tile
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Points are nice and do look pretty, but we’re here for hexagons. So, let’s finally
    draw them and introduce the D3-hexbin plugin.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'It needs the following two things from us and returns two, surely more valuable,
    things:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We need to provide a **set of points** in screen coordinates and the **radius**
    we would like to see.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns a grid of **hexagon center points** (one for each hexagon) and a
    **hexagon path generator**.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then take the new center points and the path generator and—as is custom
    with D3—draw it ourselves with the renderer of our choice. Let’s first get the
    hexagon center points and then draw them with SVG. In our `ready()` function,
    we will add the following two lines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`getHexPoints()` retrieves the center points and `drawHexmap()` draws them.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the hexagon center points
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned fleetingly previously, `d3.hexbin()` has two heads. Its first use
    is as a D3 **layout function** such as the force-layout, the tree-layout, or the
    circle-pack-layout functions D3 offers. Data in, augmented data out. We pass our
    data and the desired hexagon radius to it, and, for each set of data points it
    can wrap its shape around, it will return the center coordinate of that hexagon.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: If we only gave it one data point, it would return one hexagon. If we gave it
    two data points close together so it fits into the hexagon’s width and height
    defined by the radius, it would also just return a single hexagon. If the second
    data point were far off the first one so that the hexagon couldn’t cover it with
    the given radius, `d3.hexbin()` would produce a second hexagon, embracing that
    second point.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we use its layouting powers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First, we configure the layout. We add our radius of 3.5 (the Distance of 5.25
    / 1.5) to it and guide its attention to where it can find the `x` and `y` coordinates.
    In the next row, we use it on our grid `points` and return the resulting array
    of objects that looks as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae453779-74aa-4d3c-8ffd-9edfe2f68e37.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Our hexPoints as returned by d3.hexbin()
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Our grid points are represented by 5,996 hexagonal center points, which we
    will just call **hex points** from now on. Let’s briefly go through this. The
    hexbin layout returns an array. Each element represents a single hexagon. In each
    element, each object represents a point the hexagon covers. Additionally, `d3.hexbin()`
    adds two keys to the array: `x` and `y`. Their values represent the hexagon’s
    center. So, for each hexagon, we have all point data as well as the hexagon’s
    center coordinates.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the first two hexagons cover only
    one grid point, whereas the third covers two grid points. You can also see how
    the center points in the array keys are slightly different from the layout points
    in the objects. Let’s visualize it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the hex tiles
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have our hexagons and now just need to draw them. We do this with a new
    function we call `drawHexmap(hexPoints)` in our `ready()` function. It does what
    it says on the tin:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We join the data (passed in as `points)` with our as yet virtual selection
    of `.hex` hexagons and use `d.x` and `d.y` to move to each hexagon’s center. At
    each center, we unwrap the second use of our hexbin instance: the **hexagon path
    generator**. `hexbin.hexagon()` will return the string the path’s `d` attribute
    requires to draw the shape. The dimensions of the hexagon will be based on the
    radius we have passed to it during configuration. The rest is basic styling.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '`hexbin.hexagon()` can also take a radius as an argument. Using an accessor
    function, we can even pass through a hexagon point-specific argument, meaning
    that we can change the size of each hexagon based on a data value. Yay! However,
    we haven’t got the time or the data for this now, so let’s get back to this later.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, then. Here’s your hex tiling; you deserve it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a29c8a40-31ab-48f7-92b4-1779ed48d5ee.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: A hextile map
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-4](https://larsvers.github.io/learning-d3-mapping-11-4)
    the and code example at [11_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_04.html).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Joining data points to the layout points
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we only had eyes for the base layer setup, visualising our layout points
    as hexagons. Now, we’ll finally add some real data to it. First, we need to load
    it to our `d3.queue()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `ready()` function, we just add another line to our visualization pipeline,
    triggering a function that will prepare the data for us:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`getDatapoints()` simply takes in the loaded CSV data and returns a more concise
    object boasting *x* and *y* screen coordinates as well as the `datapoint` flag,
    indicating that this is not a layout point but an actual data point. The rest
    is market-specific data, such as `name`, `state`, `city`, and `url`, we can use
    to add as info to each hexagon:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Back in the `ready()` function, you just concatenate these data points to the
    layout points for the complete dataset you will use for your final hexbin map:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the markets data visualized as a classic dot density map in blue as
    well as together with the grid layout data in red:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61b608af-681b-4e39-b645-756290bc4f96.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: The left image shows the farmers' markets points; the right image shows the
    farmers' markets points in blue and layout points in red.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-5](https://larsvers.github.io/learning-d3-mapping-11-5)
    the and code example at [11_05.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_05.html).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! We’re one final step away from our hexmap. We need to create a value
    we can visualize: the number of markets.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Dressing our data for the final act
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have some real data about farmer's markets joined with the hexagons, but
    you can’t use it yet. All your data is still tucked away in the array of objects
    per hexagon. Let’s roll this data up.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The measure we want to visualize is the number of farmer's markets in each hexagonal
    area. Hence, all we need to do is to count the objects that have their `datapoint`
    value set to *1*. While we’re at it, let’s also remove the layout point objects,
    that is, the objects with `datapoint` value *0*; we won’t need them anymore.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add our task to the `ready()` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Primarily, `rollupHexPoints()` will roll up the number of markets per hex point.
    It will turn the upper hexagon data into the lower hexagon data of the following
    figure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc65ca7e-4756-4dbf-a7ad-30153417b962.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: The hexagon data before and after roll-up
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`rollupHexPoints()` will perform the following things in an order:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Remove the layout grid points.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count the number of datapoints and add the count as a new property called `datapoints`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect key markets data in single array called `markets` for easy interaction
    access.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it will produce a color scale we so dearly need for the hexagon coloring.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here we go:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start by initializing a `maxCount` variable that will later have the maximum
    number of farmers' markets in a single hexagon. We’ll need this for the color
    scale.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll loop through all the layout and data points:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we will get rid of all the layout point objects with `splice()` if the
    `datapoint` property holds a `0`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create the rolled-up data. There will be two rolled-up data elements:
    an integer representing the total count of farmers'' markets within the hexagon
    and an array of market data we can use for later interaction. First, we will set
    up the variables:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We loop through each object within the hexagon array of objects, and once we’ve
    collected the data, we add it as keys to the array. This data is now on the same
    level as the *x* and *y* coordinates for the hex points.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could have taken a shortcut to summarize the count of markets.
    Our `datapoints` property just counts the number of elements in the array. This
    is exactly the same as what the in-built `Array.length` property does. However,
    this is a more conscious and descriptive way of doing it without adding much more
    complexity.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we do in the loop is to update `maxCount` if the count value
    of this particular hexagon is higher than the `maxCount` value of all previous
    hexagons we looped through:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The last thing we do in our roll-up function is to create our `colorScale`.
    We’re using the *Viridis* color scale, which has great properties for visualizing
    count data. Note that *Viridis* maps low numbers to purple and high numbers to
    yellow. However, we want high numbers to be darker (more purple) and low numbers
    to be lighter (more yellow). We will achieve this by just flipping our domain
    mapping.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'The way scales work internally is that each value we feed from our domain will
    be normalized to a value between *0* and *1*. The first number we set in the array
    we pass to `.domain()` will be normalized to *0—*that''s `maxCount` or 169 in
    our case. The second number (1) will be normalized to *1*. The output range will
    also be mapped to the range from *0* to *1*, which for *Viridis* means *0 = purple*
    and *1 = yellow*. When we send a value to our scale, it will normalize the value
    and return the corresponding range value between *0* and *1*. Here is what happens
    when we feed it the number 24:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The scale receives *24* as an input (as in `colorScale(24)`).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: According to the `.domain()` input (`[max, min]` rather than `[min, max]`),
    the scale normalizes *24* to *0.84.*
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the scale queries the *Viridis* interpolator about which color corresponds
    to the value of *0.84* on the *Viridis* color scale. The interpolator comes back
    with the color `#a2da37`, which is a light green. This makes sense, as 0.84 is
    closer to 1, which represents yellow. Light green is obviously closer to yellow
    than to dark purple, which is encoded as *0* by the interpolator.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That was is it!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Nearly. The very last thing we have to do is to jump into our `drawHexmap()`
    function and change the hexagon coloring to our `colorScale:`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the hexagons don’t cover any markets, their data points property will be
    0 and we won’t color it. Otherwise, we pick the appropriate Viridis color.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b646bfc-a4db-4f86-b792-babd53d1d1b6.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: A very yellow hexbin map
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Looks pretty yellow, doesn’t it? The problem is that we have a few outliers
    in our data. That single dark purple dot on the East Coast is New York, which
    has significantly more farmers'' markets than any other area (169). Washington
    and Boston are busy as well. However, that makes our visual less interesting.
    Looking at the distribution of numbers tells us that most hexagons enclose 20
    or less markets:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba805ff6-779c-4391-8b98-363890f4abfb.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Number of farmers' markets per hexagon
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The highest number of markets per hexagon, however, is currently 169\. We can
    do two things here. We can either choose a lower value as our maximum color scale
    value, say 20\. That would only scale our values from 1 to 20 to the *Viridis*
    spectrum. All hexagons with higher values would receive the maximum colour (purple)
    by default.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'A more elegant alternative is to use an **exponential interpolator** for the
    color scale. Our domain would map not linearly but exponentially to our color
    output, effectively reaching the end of our color spectrum (purple) with much
    lower values. To achieve this, we just need a new color scale with a custom interpolator.
    Let''s take a look at the code first:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What exactly are we doing here? Let''s reconsider the scaling steps we went
    through in the preceding code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The scale receives a number *24* (as in `colorScale(24)`).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: According to the `.domain()` input (`[max, min]` rather than `[min, max]`),
    the scale normalizes *24* to 0.84\. No change for points *1* and *2*.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the old `colorScale`, we just waved through this *linearly normalized value*
    between *1* and *0* without us interfering. Now, we catch it as an argument to
    a callback. Convention lets us call this `t`. Now, we can use and transform this
    however we desire. As we saw previously, many hexagons encircle 1 to 20 markets,
    very few encircle more. So we want to traverse the majority of the Viridis color
    space in the lower range of our values so that the color scale encodes the interesting
    part of our data. How do we do this?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we pass `t` to our color interpolator, we set it to the *power of 10*.
    We can use a different exponent, but *10* works fine. In general, taking the power
    of a number between *0* and *1* returns a smaller number. The higher the power,
    the smaller the output will be. Our linear `t` was *0.84*; our exponential `tNew`
    equals *0.23*.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we pass `tNew` to the *Viridis* interpolator, which spits out the respective—much
    darker—color.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s graph this transformation to clarify:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c99ded5-f9ee-434e-9985-91e0df2bce73.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Linear versus exponential color interpolation
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The *x axis* shows the input values, the *y axis* shows our scale-normalized
    value `t` that we send to the interpolator to retrieve a corresponding color.
    The **left graph** shows what a linear interpolation does. It linearly translates
    the increase of values to the decrease in `t`. The curve in the **right graph**
    shows us how our adjusted `tNew` behaves after setting `t` to the *power of 10*:
    we enter the lower regions of `t` (the more purple regions) with much smaller
    input values. Put differently, we traverse the color space from yellow to purple
    in a much smaller range of domain values. Piping our example value of 24 through
    a *linear interpolation* would return a yellowish green; piping it through our
    *exponential interpolation* already returns a purple value from the end of the
    color spectrum.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The main win this brings is that color differences can be seen where the data
    is rather than where the gap between the main data cluster and the outlier is.
    Here is our hexbin map with an exponential scale:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87e8893d-023b-44c8-aedb-ba89420c07ac.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: A more interestingly colored hexbin map
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-6](https://larsvers.github.io/learning-d3-mapping-11-6)
    the and code example at [11_06.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_06.html).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Let’s just revel in our achievement for a moment, but are we done? We’re itching
    to explore this map a little more. After all, people are used to playing with
    maps, trying to locate themselves in them or move from one area to the other with
    ease. That’s what we will allow for in our last step.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Turning our visual into an interactive app
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have officially built a hexbin map, and that was indeed the key focus of
    this chapter. However, in this last section, let’s leisurely consider how we might
    make this more engaging and informative for ourselves and our users. We won’t
    go into as much detail as in the previous sections, but will go through general
    steps about how to improve the app.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a list of what we can do:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Show the markets in a list on hover.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the user change the hexagon size.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the user change the exponent for the color scale interpolator.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show which markets sell specific products, e.g. cheese, wine, seafood, etc.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encode a second variable as hexagon size.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first is standard. The second and third point would be very helpful for
    exploration of the data. The fourth point is indeed possible, as the data also
    covers variables specifying what products each market sells. The last point would
    be good for our own practice with the `d3.hexbin()` module.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go into detail of each of these points, but do take a look at the finished
    app at [https://larsvers.github.io/learning-d3-mapping-11-8](https://larsvers.github.io/learning-d3-mapping-11-8).
    The code is commented and available as example [11_08.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html)
    in the `Chapter 11` folder at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional information on hover and click
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tooltips are a helpful exploration technique for most visualizations in order
    to give the user details on a certain data point or area. In this case, the smallest
    data units of the app are the hexagons. However, some of the hexagons contain
    more information that would fit on a tooltip—up to 169 as we’ve seen above. To
    allow the user to browse the markets per area, we will add a side panel listing
    all the markets in the hovered hexagon. This is how it could look:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ba70117-040b-469b-81c9-515964e91d8b.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: Interactive hexbin map with title, tooltip, and list of markets per hexagon
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-8](https://larsvers.github.io/learning-d3-mapping-11-8).
    the and code example at [11_08.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html).
    Please use a recent version of the Chrome browser to view or work along these
    examples.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The list changes rapidly when the user moves around, so a click on a hexagon
    would lock the list view so that the user can explore and potentially use the
    links to get to the markets' websites.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Changing the hexagon size
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A key advantage of hexbin maps compared to dot density maps is that interaction
    is easier. If you have many dots on a map, you might have to keep them small (1-3
    pixels) to convey a good sense of the data. Such small targets are hard to catch
    with the mouse. Furthermore, some dots will inevitably overlap, so you can’t get
    to them at all. In a hexbin map, each hexagon is reachable, if it’s not too small.
    I would even argue that our choice of hexagon size might be a little small with
    **3.5** pixels. Let’s add a drop-down control, allowing the user to change the
    size of area. Here are some hexagon size variants:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e27fd0fc-880f-403a-8b4c-61c813abb740.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: Different hex radii
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Two notes of caution here: when building a regularly tessellated hexbin map
    as we do, you might run into the **border problem**. Imagine a large hexagon just
    touching the tip of Florida. 5% of the hexagon is over land, 95% is over sea.
    However, the map readers can’t see the real coastal line. They assume the hexagon
    represents the coastal line, covering 100% land area. If that corner of Florida
    has a high point density, this hexagon should encode it. However, as it only covers
    5% of the land, and maybe around 5% of the dot density, it appears to the reader
    as though the coast of Florida is void of dots.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Another problem that becomes apparent when you look at the different sized hexagons
    above is the so-called **modifiable areal unit problem** (MAUD). The summary values
    we encode are highly dependent on the shape and the scale of our aggregation units.
    This is a problem, as the results might differ when the same analysis is applied
    to the same data. You can see the *scale effect* above; changing hexagon size
    results in a different perception of farmers markets’ density. The *shape* or
    *zone effect* can be more problematic. Using a different shape at the same scale,
    for example, 10-mile squares instead of 10-mile hexagons can change the aggregate
    and hence analysis. It then becomes an analysis of different bins rather than
    of the underlying data. This effect is particularly problematic when representing
    non-arbitrary units such as counties or census tracts, which might change in shape
    over time but remain consistent in the readers’ minds.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: You could solve the border problem by overlaying the country outline, but the
    key step to alleviate any of these problems is your awareness, explaining potential
    issues to readers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Changing the color scale interpolator
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In exploratory displays, it can be beneficial for users to change the scale
    in order to discover data areas of interest. By allowing our users to adjust the
    interpolator, they can focus on value ranges of their interest. The parameter
    we want to expose is the exponent our exponential interpolator uses:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbacf15b-4f7b-4172-b953-df84a6d96839.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Changing the color scale interpolator
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Browsing different datasets
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The farmers'' market data we are using here also offers over 29 binary variables,
    indicating what products or facilities markets offer. Multiple datasets showing
    the geographical distribution of markets with different produce would be a good
    option. Alternatively, we can add a drop-down menu for the users to choose what
    products they are most interested in. Here are some examples:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/128c37e6-c557-41f9-aeaf-6100359ecf15.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Hexbin maps of different datasets (we chose 20 of the 29 binary variables available
    for the app)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Encoding data as hexagon size
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have encoded data only as color. `d3.hexbin()` makes it very easy
    to encode data by hexagon size. Theoretically, you just have to go to your `drawHexmap()`
    function and change a single line:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You just add a hexagon-specific radius to your `hexbin` path generator (as an
    optional argument to the `.hexagon()` method), which in our case above makes sure
    that each hexagon gets a radius as little or large as this hexagon’s count of
    farmers' markets. However, that would look excessive as most would get a radius
    of *0* and some would get a radius of over *100*. I’ll spare you the visual.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we will add the variable `radiusScale` to the mix (in `rollUpHexPoints()`),
    which will scale sizes from between `3.5` to `15` pixels:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can now use it when you draw the hexagons, which you should also sort ascendingly
    so that the larger ones aren’t covered by the many small hexagons around them:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You get hexagons not only colored, but also sized by the number of markets
    within the hexagon:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e892f98-f863-496a-b7aa-4a1a57c309f1.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: Number of markets encoded as color AND radius size
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-7](https://larsvers.github.io/learning-d3-mapping-11-7)
    and the code example at [11_07.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_07.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We double encode the number of markets as color and size here. That’s sometimes
    useful, but you have two encoding channels at your disposal here, which you can
    use for two variables to produce a **bi-variate hexbin map**. It's your choice.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered a few options to improve and add to our hexbin map. There are
    certainly more options to have fun with. For example, we haven’t touched on zooming
    and panning, which is, of course, a standard map interaction technique and would
    be a good addition for people to dive into smaller hexagons. I’m sure that you
    can think of more ways to build on it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了几种改进和添加到我们的六边形地图的选项。当然，还有更多选项可以让我们玩得开心。例如，我们还没有涉及到缩放和平移，这当然是一种标准的地图交互技术，对于想要深入研究更小六边形的人来说，这将是一个很好的补充。我相信你还能想到更多构建它的方法。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started by comparing a few map visualization techniques. We covered the uses,
    benefits, and caveats of choropleth maps, cartograms, and dot density maps. We
    moved swiftly to the hexagon shape and explored how its geometrical properties
    can help choropleth and dot density maps.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先比较了几种地图可视化技术。我们介绍了等值线图、地图图和点密度图的使用、优点和注意事项。我们迅速转向六边形形状，并探讨了其几何属性如何帮助等值线图和点密度图。
- en: Most of the chapter was, however, spent in the mapping workshop, building a
    hexbin map from scratch. We could have built a simple hexbin map, just covering
    areas with datapoints, but our goal was to shape a map entirely of hexagons for
    the kicks and the aesthetics. That meant a little more data preparation—creating
    a map-shaped layout grid, joining the datapoints, and eventually adding and color-encoding
    the hexagons—but doesn’t it look pretty?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大部分时间都花在了制图工作坊中，从头开始构建一个六边形地图。我们本可以构建一个简单的六边形地图，只需覆盖有数据点的区域，但我们的目标是打造一个完全由六边形构成的地图，以追求乐趣和美观。这意味着需要更多的数据准备——创建地图形状的布局网格，连接数据点，最终添加并使用颜色编码六边形——但难道它看起来不漂亮吗？
- en: Finally, we turned our static map into an interactive application, handing significant
    control over shape and information gain to the user. A lot can be achieved with
    interaction, especially with maps!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将静态地图转换成了一个交互式应用程序，将形状和信息获取的控制权交给了用户。交互可以实现很多事情，尤其是对于地图来说！
- en: 'After having created a fully functional interactive visualization, you might
    want to show it to the world. There are many ways to claim some online real estate;
    in the next chapter, we''ll look at a conveniently simple one: *GitHub pages*.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一个完全功能性的交互式可视化之后，你可能想要向世界展示它。有许多方式可以在线占据一些空间；在下一章中，我们将探讨一个方便简单的方法：*GitHub页面*。
