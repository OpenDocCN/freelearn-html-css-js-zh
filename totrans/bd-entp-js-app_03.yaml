- en: Managing Version History with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, starting from [Chapter 4](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml),
    *Setting Up Development Tools*, we're going to be building a very simple user
    directory, which we've randomly named **hobnob**. We need a way for us to keep
    a versioned history of our code, so that if we've made some mistakes along the
    way, we can simply revert back to the last known good version and start again
    from there. This is known as **version control** (**VC**).
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to implement version control is to copy the entire codebase
    into date-stamped directories; however, this is tedious and may take up a lot
    of disk space. Instead, we can use a **Version Control System** (**VCS**) that'll
    manage these versions for us. We simply have to instruct the VCS when to create
    a snapshot of our code, and it will keep that version.
  prefs: []
  type: TYPE_NORMAL
- en: There have been many implementations of VCS, starting in 1972 with**Source Code
    Control System **(**SCCS**), which was superseded by** Revision Control System **(**RCS**,
    released in 1982), **Concurrent Versions System** (**CVS**, released in 1990),
    and **Apache ****Subversion** (**SVN**, released in 2000). Nowadays, we mainly
    use **Git** (released in 2005), a type of VCS known as **Distributed VCS **(**DVCS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Git was created by Linus Torvalds, who''s also the creator of the Linux kernel.
    It is used to track changes in the development of the Linux kernel, as well as
    the tens of millions of repositories currently on GitHub. In this chapter, we
    will guide you through setting up and configuring Git, as well as explaining basic
    Git concepts, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Different states in Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Git operations such as **staging**, **committing**, **merging**/**rebasing**,
    **pushing**, and ****pulling****
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a parallel development workflow using a branching model proposed
    by Vincent Driessen, commonly known as ****Git flow****
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a **GitHub** account to host our code remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the workflow when working with others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we must install Git.
  prefs: []
  type: TYPE_NORMAL
- en: Most installation instructions depend on your hardware architecture and operating
    system. It would be impractical for us to outline instructions for all of them.
    So, for this book, we'll assume you're running Ubuntu 16.04 / 18.04 on a 64-bit
    machine, using a user with `sudo` privileges.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide URL links to the documentation whenever possible, so that you
    can find installation instructions specific to your machine. However, due to the
    dynamic nature of the internet, URL addresses change and pages may get moved.
    If the link we provide appears to be dead, simply search for the instructions
    using a search engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git is available for macOS, Windows, and Linux. You can find download instructions
    for Git at [https://git-scm.com/downloads](https://git-scm.com/downloads). Since
    we are using Ubuntu, the `git` package will be available from our distribution''s
    package manager, **Advanced Packaging Tool** (**APT**). We should run `sudo apt
    update` to ensure that the list of repositories available to APT is up to date,
    before installing the `git` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Git is now available as the `git` **command-line interface** (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, create a directory, named `hobnob`, to house our project. Then, navigate
    inside and run `git init`. This will allow Git to start tracking changes to our
    project; a project tracked by Git is also known as a **repository**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we introduce new Git commands, I encourage you to read their full documentation,
    which you can find at [https://git-scm.com/docs](https://git-scm.com/docs).
  prefs: []
  type: TYPE_NORMAL
- en: Running `git init` creates a `.git` directory, which holds all version-control-related
    information about the project. When we interact with Git using its CLI, all it's
    doing is manipulating the content of this `.git` directory. We usually don't have
    to care about the contents of the `.git` directory, as we can interact with Git
    purely through the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Because Git keeps all files under the `.git` directory, deleting the `.git`
    directory will delete the repository, including any history.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can configure Git using the `git config` command. This command will manipulate
    the `.git/config` file on our behalf. In fact, if we print the content of the
    `.git/config` file, you''ll see that it is similar to the output of the `git config`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to examine the `.git` directory using a tool such as `tree`. First,
    install `tree` by running `sudo apt install tree`. Then, run `tree ~/projects/hobnob/.git`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure Git, we must first understand that there are three scopes, or
    levels, of configurations, each with a corresponding configuration file stored
    at different locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local**: Applies only to the current repository; the configuration file is
    stored at `<repository-root>/.git/config`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global**: Applies to all repositories under the user''s home directory; the
    configuration file is stored at `$HOME/.config/git/config` and/or at `$HOME/.gitconfig`,
    with the latter being only available in newer versions of Git. `$HOME/.gitconfig`
    will override `$HOME/.config/git/config`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System**: Applies to all repositories in your machine; the configuration
    file stored at `/etc/gitconfig`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local configuration settings will override the global settings, which, in
    turn, override the system settings.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we ask Git to take a snapshot of our code (also called **committing**),
    Git will record several pieces of information, such as the time and author of
    the commit. The information about the author is saved as Git configurations, which
    saves us from having to re-type them each time we commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, adding/updating the configuration would write to the local config
    file. However, since you are going to be the only person using your user account
    on your machine, it''s better to set the user settings in the global configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will cause future commits to be, by default, identified as `"Daniel Li"`
    whose email address is `"dan@danyll.com"`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a GitHub account (if not, we will create one later), you should
    use the same email address for Git. When you push your commits, GitHub will automatically
    associate your commits to your account.
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully set up Git and configured our user.
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this chapter, we will use dummy files to illustrate how
    Git works and the workflow we will follow. Everything you do for the rest of this
    chapter should be viewed as an educational exercise, and can be discarded afterward.
    At the beginning of the next chapter, we will start our project again from scratch,
    and you will use the things you learned in this chapter to keep your code base's
    history organized!
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of Git is to keep a history of changes, or revisions. To
    illustrate this, let's create a simple file and commit it to the history of the
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Committing to history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s confirm our repository''s Git history by running `git log`, which
    shows a history of past commits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The error correctly informs us that there are currently no commits. Now, let''s
    create a short `README.md` file, which represents the first change we want to
    commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created our first file and thus made our first change. We can now run
    `git status`, which will output information about the current state of our repository.
    We should see our `README.md` file being picked up by Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output tells us that we are on the default `master` branch (more on branching
    later), and that this is our *initial commit—*we have not committed anything to
    the repository yet. It then says we have untracked files. To understand what that
    means, we must understand the different states that a file can be in with Git.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used `git log` and `git status`, but there are many more CLI
    commands; to see a full list, run `git help`. To get details about a particular
    command, run `git help [command]`; for example, `git help status`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding file states in Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Git, every file can be in one of two generic states: **tracked** and **untracked**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, all files exists in the **workspace** (also known as **working tree** or **working
    directory**) and are in the **untracked** state. These untracked files are not
    part of the repository, and Git won''t pick up changes made to them. When we run `git
    status`, Git sees that there are files in our workspace that are untracked (not
    part of the repository) and asks whether we want to add them to the repository. When
    we commit a new file to the repository using `git add` and `git commit`, it transitions
    from untracked to tracked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`README.md` is now part of the repository and is in the tracked state.'
  prefs: []
  type: TYPE_NORMAL
- en: We are passing in `"Initial commit"` as a comment that describes the commit.
    Every commit should have an accompanying message that describes what changes were
    made. It should be informative and specific; for example, `"Fixed rounding error
    bug in calculateScore"` is a better commit message than `"fixed bugs"`.
  prefs: []
  type: TYPE_NORMAL
- en: However, since our commit does little other than initializing the repository,
    this message will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm this by looking at the Git commit history of the repository
    with the `git log` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The three tracked states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be more precise, the tracked state can be further subdivided into three substates: **modified**, **staged**,
    and **committed**. Our `README.md` file is in the committed state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git will pay attention to all the tracked files; if we modify any of them (which
    includes deletions and renames), they will change their state from committed to modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Modified files, alongside any untracked files, will be listed when we run `git
    status`. Modified files can be committed in the same manner as untracked files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering why we had to run `git add` before we ran `git commit`.
    `git add` places the untracked or modified file into what is known as the **staging
    area**, which is also known as the **index** or **cache**. When a file is placed
    into the staging area, it is in the staged state. When we commit, only changes
    in the staging area are added to the repository; changes that remain in the workspace
    are not committed.
  prefs: []
  type: TYPE_NORMAL
- en: Staging our changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By having a staging area, we can `git add` multiple related changes and `git
    commit` them all at the same time—as a single commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the staging area acts as a temporary environment to collect these related
    changes. For example, if we add a new feature into our application, we should
    also document this in our `README.md`. These changes are related to each other
    and should be committed together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Quick recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly summarize what we''ve learned so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Workspace/working directory**: All the files and directories currently in
    our filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Index/staging area/cache**: All the modifications you want to commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository** (the `.git` directory): Hosts a history of all your committed
    and tracked files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7f257635-9091-41eb-b69f-c3f88d3d1eae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Branching and merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been adding changes sequentially to the repository, resulting
    in a history with a linear structure. But what if you, or your team, want to work
    on different features/multiple tasks at the same time? If we continue with our
    current workflow, the Git commit history is going to look disjointed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/235bffc5-cf78-426d-ab48-c4dcc59cf28f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have commits relating to bug fixes interleaved between commits relating
    to features. This is not ideal. Git **branches** were created to deal with this
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Git branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've briefly mentioned, the default branch is called `master`, and we've
    been adding commits to this branch up to this point.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we develop a new feature or fix a particular bug, rather than adding
    those commits directory to `master`, we can instead create a branch from a certain
    commit from `master`. Any new commits to these bug fix and/or feature branches
    will be grouped together in a separate branch in the history tree, which does
    not affect the `master` branch. If and when the fix or feature is complete, we
    can merge this branch back into `master`.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is the same, but the Git history is now much easier to read and
    understand. Furthermore, branches allow you to write and commit experimental code
    in an isolated part of the repository, so your changes, which may introduce new
    bugs and regressions, won't affect others until they have been tested and peer-reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: Branching models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workflow we described is an example of a **branching model**, which is just
    a term that describes how you structure your branches. As you can imagine, there
    are many branching models, and most are more complex than the one we've outlined.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will follow a branching model put forward by Vincent Driessen
    in his article *A successful Git branching* *mode**l*, but you're free to explore
    other models and use the one that makes sense to you. The most important thing
    is that you and your team stick to the model consistently, so everyone on the
    team knows what is expected of them.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard Driessen's model described as *Git Flow*, but `gitflow` ([https://github.com/nvie/gitflow](https://github.com/nvie/gitflow))
    is actually a set of Git extensions that provides higher-level operations that
    follow Driessen's model.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the original post where Driessen proposed this model at [http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/).
  prefs: []
  type: TYPE_NORMAL
- en: The Driessen model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Driessen provided a detailed diagram of how his model works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/132cf42f-d48c-4d5f-98bf-59f33c203c56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Driessen''s model, there are two permanent branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev` (or `develop`, or `development`): The main branch that developers work
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`master`: Only production-ready code can be committed to this branch. Here,
    production-ready means the code has been tested and approved by the stakeholders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also other non-permanent branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature branches**: Branching from the `dev` branch, feature branches are
    used for developing new features, or fixing non-critical bugs. Feature branches
    will eventually be merged back into the `dev` branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release branches**: Once enough features or bug fixes havebeen implemented
    and merged into the `dev` branch, a release branch can be created from the `dev`
    branch to undergo more scrutiny before being released. For instance, the application
    can be deployed onto a staging server to be UI and manually tested. Any bugs uncovered
    during this process would then be fixed and committed directly to the release
    branch. Once the release branch is "free" of bugs, it can then be merged into
    the `master` branch and released into production. These fixes should also be merged
    back into the `dev` branch and any other release branches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hotfix (or patch) branches**: Hotfixes are issues (not always bugs) that
    are in production which must be fixed as soon as possible, before the next planned
    release. In these cases, the developer would create a branch from `master`, make
    the required changes, and merge directly back into `master`. These hotfix branches
    should also be merged back into the `dev` branch and any other release branches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a development branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the Driessen Model, we must first create the `dev` branch from
    the master branch. To check which branch we are currently on, we can run `git
    branch --list` or simply `git branch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This returns a list of all branches, with an asterisk (`*`) next to the currently
    active branch, which is currently `master`. To create a new `dev` branch from
    the current branch, we can run `git branch dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we are instead going to run `git checkout -b dev master`, which creates
    a new branch andmakes it active at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating feature branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any new features should be developed by branching off `dev`. Be sure to name
    the feature branch so that it clearly indicates the feature being worked on. For
    example, if you''re working on the social login feature, name your branch `social-login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If that feature has sub-features, you may create sub-branches from the main
    feature branch. For example, the `social-login` branch may include `facebook-login`
    and `twitter-login` sub-branches.
  prefs: []
  type: TYPE_NORMAL
- en: Naming sub-branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple valid ways to name these sub-branches, but the most popular
    convention uses **grouping tokens**, with various **delimiters**. For example,
    our Facebook and Twitter login sub-branches can be grouped under the `social-login` grouping
    token, with a period (`.`) as a delimiter, and a **sub-token** such as `facebook`
    or `twitter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use almost anything as a delimiter; the comma (`,`), hash (`#`), and
    greater-than sign (`>`) are all valid delimiters. However, there are several rules
    outlined under the `git-check-ref-format` part of the documentation that give
    valid reference names. For example, the following characters are unavailable:
    space, tilde (`~`), caret (`^`), colon (`:`), question mark (`?`), asterisk (`*`),
    and open bracket (`[`).'
  prefs: []
  type: TYPE_NORMAL
- en: See all the rules by visiting the documentation for `git-check-ref-format` at [https://git-scm.com/docs/git-check-ref-format](https://git-scm.com/docs/git-check-ref-format).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most conventions I have encountered use a forward slash (`/`) as the delimiter,
    and so we do the same here. However, this poses a problem because branches are
    stored as text files under `.git/refs/heads`. If we create a sub-branch called `social-login/facebook`,
    then it''d need to be created at `.git/refs/heads/social-login/facebook`, but
    this is impossible in our case because the `social-login` name is already used
    for the file, and thus cannot act as a directory at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, when we create a new feature branch, we need to provide a *default*
    sub-token, such as `main`. With that in mind, let''s delete our current feature
    branches and create them again with the `main` sub-token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are now on the `social-login/main` feature branch, and can start developing
    our social login feature.
  prefs: []
  type: TYPE_NORMAL
- en: We won't actually be writing any code; we will simply be adding text to a file
    to mimic new features being added. This allows us to focus on Git and not be bogged
    down by implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create that file and commit it to the `social-login/main` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are using `git add -A` here to add all changes to the staging area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create a sub-feature branch and develop our Facebook login
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, do the same for the Twitter login feature, making sure to branch from
    the main feature branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have two sub-feature branches, one main feature branch, one `dev` branch,
    and our original `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Even if you're working on your own, it's useful to create branches, because
    it helps you organize your code and be able to switch between working on different
    features very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that there is no "right" way to name branches, only wrong ones. For
    instance, you may choose to use an additional grouping for your branches, such
    as `feature/social-login/facebook`. If you are using issue-tracking tools such
    as JIRA, you may also wish to add the issue ID into the branch, such as `fix/HB-593/wrong-status-code`.
    What *is* important is to choose a flexible scheme and be consistent with it.
  prefs: []
  type: TYPE_NORMAL
- en: Merging branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have developed our Facebook and Twitter login features on two separate sub-feature
    branches; how can we get these changes back onto the `master` branch? Following
    the Driessen Model, we must merge the two sub-feature branches onto the main feature
    branch, then merge the feature branch into the `dev` branch, and then create a
    release branch off `dev` and merge that release branch into `master`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s merge the `social-login/facebook` branch into the `social-login/main`
    branch using `git merge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Git will attempt to automatically merge the changes from the `social-login/facebook`
    branch into the `social-login/main` branch. Now, our branch structure looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to do the same for our Twitter login sub-feature. However, when
    we attempt the merge, it fails due to a **merge conflict**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A merge conflict occurs when the changes from the two branches being merged
    overlap each other; Git doesn''t know which version is the most appropriate version
    to move forward with, and so it does not automatically merge them. Instead, it
    adds special Git markup into the file where the merge conflict occurs and expects
    you to manually resolve them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The part between `<<<<<<< HEAD` and `=======` is the version on our current
    branch, which is `social-login/main`; the part between `=======` and `>>>>>>>
    social-login/twitter` is the version on the `social-login/twitter` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must resolve this merge conflict before the merge is complete. To do that,
    we simply need to edit the file to the version we want, and remove the Git-specific
    sequences. In our example, we want to add the text for `twitter` after `facebook`,
    so we would edit the file to become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the conflict is resolved, we need to complete the merge by adding `social-login.txt`
    to the staging area and committing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we look again at our Git history, we can see that we''ve implemented
    the Facebook and Twitter login features on two separate branches, and then merged
    them together in a separate commit (the one with the hash `37eb1b9`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Examining more realistic examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example we went through previously is very simple and a bit contrived.
    In a more realistic working environment, the `dev` branch will be very active:
    there will be many feature/bug fix branches that stem from `dev` and ultimately
    merge back into it. To illustrate how that can cause issues, and to show you how
    those issues can be mitigated, we''re going back to the `dev` branch to create
    another feature branch; let''s call it `user-schema/main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a file, `user-schema.js`, which represents the entirety of
    our user schema feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can merge this feature branch back into `dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Git history tree now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re finding it hard to visualize the history, try using a Git client
    that visualizes the branches for you. For Mac and Windows, there''s a free client
    by Atlassian called Sourcetree. If you''re on Linux, you may want to try GitKraken.
    We will use GitKraken to illustrate the Git branch structure from here on. For
    example, the preceding figure looks like this on GitKraken:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b497310-12f5-46b5-a431-97d19ad1bd14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we could merge our `social-login/main` branch back into `dev`, which will
    produce the following branch structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f47cfd37-fdf3-49da-bc5f-3d74af8af0ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, we should not do this because:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breaking changes**: The implementation of the social login feature may depend
    on the user''s schema being of a certain shape. Therefore, blindly merging the `social-login/main`
    branch may result in the platform breaking. The `dev` branch is the one that others
    will develop new features from, and so it should be kept bug-free at all times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complicated Git history**: The history tree is already quite hard to read,
    and we''ve only implemented two features!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the dev Branch Bug-Free
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first issue can be tackled by merging the `dev` branch into `social-login/main`,
    testing that everything works as normal, and then merging it back into `dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This way, any bugs that arise due to the incompatibility of the branches will
    remain on the feature branch, and not on `dev`. This gives us a chance to fix
    these bugs before merging back into `dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this solved one issue, it exacerbated the other. Our Git history now
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3ab9b8e-5f91-4f51-9381-a2f2861264f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Merging the main branch first is not as important for sub-feature branches,
    because feature branches are not expected to be bug-free at all times. I'd leave
    it up to the developer responsible for the feature branch to decide how they'd
    want to work on their feature branch.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping our history clean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reason our Git history looks so complicated is because `git merge` creates
    a separate commit for the merge. This is good because it doesn''t alter the history
    of any of the branches; in other words, it is non-destructive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d10e089b-1475-4693-8bbf-f6feb8675036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To prevent the complicated history tree we have here, Git provides an alternative
    command, `rebase`, that allows us to merge changes, as well as keep our history
    clean.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping our history clean with git rebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `git rebase`, instead of creating a new commit for the merge, it will
    try to place the changes on the feature branch as if they were made directly after
    the last commit on the main branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d805d1e-7e97-48ab-809f-a92a84d35133.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see how we can work with `rebase`, let''s repeat everything we''ve done
    so far, but using `rebase` instead of `merge`. Create a new directory and open
    your Terminal, then copy and paste the following commands (which will replicate
    everything we''ve done so far):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Git history tree now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34816a4d-4702-4f40-8887-863ad082ffdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we can merge `social-login/facebook` into `social-login/main`. As no
    changes have been made on `social-login/main` since the branching occurred, it
    makes no difference whether we use `git merge` or `git rebase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After our merge, there is now a change on the `social-login/main` branch since
    `social-login/twitter` branched out from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/881a5e1d-00f3-474b-ad25-b14496273442.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s where `rebase` is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s still going to be a merge conflict, and you should resolve it the
    same way as before. But this time, use `git rebase --continue` instead of `git
    commit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is, this time, the `git` history for the social login feature
    is linear, as if the changes on the `social-login/twitter` branch were made straight
    after those on the `social-login/main` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to fast-forward the `social-login/main` branch to follow the
    `social-login/twitter` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce a much cleaner branch structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/499b21c5-8fe4-45f0-944f-6c5793fabf89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we can `rebase` our `social-login/main` branch onto the `dev` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a completely linear commit history on the `social-login/main`
    branch, even though they all originated from different branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd8b2921-edb7-4f3b-9e4c-a2965336c125.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last thing to do is to forward the `dev` branch to where the `social-login/main`
    branch is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using merge and rebase together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I might have given the impression that `git rebase` is cleaner, and thus better,
    than `git merge`. This is not the case; there are pros and cons for each method.
  prefs: []
  type: TYPE_NORMAL
- en: '`git rebase` rewrites, or alters, the existing history of the repository by
    trying to replicate changes on the sub-branch at the end of the main branch. This
    makes the history look cleaner and more linear, but loses the context of when
    and where changes are integrated together – we lose the information that `social-login/twitter`
    was originally branched off from `social-login/main`.'
  prefs: []
  type: TYPE_NORMAL
- en: So, I'd advise using `git rebase` for feature/bug-fix branches. This allows
    you to commit small and often, making **work-in-progress (WIP) commits**, without
    having to care too much about cleanliness. After your feature is complete, you
    can then clean up your commit history using `git rebase`, before merging into
    the permanent branches.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when integrating changes from a feature branch into the `dev` branch,
    or from the `dev` branch into `master`, use `git merge` because it provides context
    as to where and when those features were added. Furthermore, we should add a `--no-ff`
    flag to `git merge`, which ensures the merge will *always* create a new commit,
    even when fast-forwarding is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48001ea6-1778-4bf5-84ef-fee80690c1f6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By combining both `git merge` and `git rebase`, it is possible to end up with
    a nice Git history:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/666d284e-c689-475d-a5b6-98291aaf6985.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can even delete some branches to make the history even cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The branch structure is now much simpler to comprehend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5862a7ab-fcf5-4dfc-a3b0-003db63b30d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Releasing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a sizable chunk of features that we can release. We should create
    a release branch from `dev`. This release branch should be named after the version
    of the release, prefixed by `release/`, such as `release/0.1.0`. The code to be
    released should then be deployed to a staging server, where automated UI testing,
    manual testing, and acceptance testing should be conducted (more on these later).
    Any bug fixes should be committed on the release branch and merged back into the
    `dev` branch. When the release branch is ready, it can then be merged into `master`.
  prefs: []
  type: TYPE_NORMAL
- en: No new features should be added to the release branch except bug fixes and hotfixes.
    Any new features, non-critical bug fixes, or bug fixes that are unrelated to the
    release should be committed to a bug-fix branch.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first question is how do we name/version our releases? For this project,
    we'll use **semantic versioning**, or **semver**.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In semver, everything is versioned with three digits, `MAJOR.MINOR.PATCH`,
    which start at `0.1.0` and are incremented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Patch**: After a backward-compatible hotfix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: After a backward-compatible set of features/bug fixes have been
    implemented'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Major**: After a backward-incompatible change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be following semantic versioning for our releases.
  prefs: []
  type: TYPE_NORMAL
- en: As with naming feature branches, there are no "right" ways to name release branches.
    For example, you can suffix the release version with a brief description of what
    is included in this release, such as `release/0.1.0-social-login` or `release/0.1.0__social-login`.
    Again, the most important thing is to have a rule and be consistent with it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a release branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create our release branch and name it `release/0.1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If this was a real scenario, we''d deploy the branch onto a staging server
    for it to be more thoroughly tested. For now, let''s assume we have found a bug:
    the text for `facebook` and `twitter` inside `social-login.txt` should be capitalized
    to `Facebook` and `Twitter`. So, let''s make that fix and commit it directly on
    the release branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we would test the revised code again, and assuming there are no more bugs,
    we can merge it into `master`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we merge, it will ask us for a commit message; we can just stick with
    the default message, `Merge branch ''release/0.1.0''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/125a779d-fcaf-4d62-ab10-71152381fc3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, we should remember to apply the bug fixes we made on the release branch
    back into `dev`; if we have any other active release branches, we should apply
    it to those as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We end up with a Git branch structure similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c3309c6-df1a-4ce6-a8cf-1b899eb350ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Tagging releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, we should tag our release. **Tags**, in Git, are markers that highlight
    certain points in the commit history as being important. Releases are important,
    so the convention is to represent releases as tags on the `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of tags: **lightweight** and **annotated** tags. A lightweight
    tag is simply a pointer to a particular commit. Annotated tags are, on the other
    hand, full objects in the Git database, similar to a commit. Annotated tags contain
    information about the tagger, the date, and an optional message. We should use
    annotated tags to tag releases.
  prefs: []
  type: TYPE_NORMAL
- en: The Git Manual (accessible when you run `git tag --help`) states *"*Annotated
    tags are meant for release while lightweight tags are meant for private or temporary
    object labels."
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the `master` branch and add an annotated tag by running `git tag`
    with the `-a` flag. The name of the tag should be the semver version, and you
    should also add a message describing the release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Hotfixes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we need to cover for our Git workflow is how to deal with bugs
    we discover in production (on our `master` branch). Although our code should have
    already been thoroughly tested before being added to `master`, subtle bugs are
    bound to slip through, and we must fix them quickly. This is call a **hotfix**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working on a hotfix branch is very similar to working on a release branch;
    the only difference is that we are branching off `master` instead of `dev`. Like
    with release branches, we''d make the changes, test it, deploy it onto a staging
    environment, and perform more testing, before merging it back into `master`, `dev`,
    and any current release branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ded1335-7fee-4fa1-aa3d-459e093b9a07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, first we make the fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we merge it into `master`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have added something new to master, it essentially becomes a new release
    and therefore we need to increase the version number and tag this new commit.
    Since this is a bug fix and adds no new features to the platform, we should increase
    the patch version to `0.1.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, don''t forget to merge the hotfix changes back into `dev` and, if relevant,
    other release branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Git history tree now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21e31e8d-d5a3-440c-9234-2a40ed2c4bd5.png)'
  prefs: []
  type: TYPE_IMG
- en: You can clearly distinguish the two permanent branches, `master` and `dev`,
    as everything seems to revolve around them. However, it's also clear that adding
    a hotfix makes the Git history more complicated than before, and so hotfixes should
    only be made when absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Working with others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've outlined how to manage our Git repository when developing by ourselves;
    however, more often than not, you'll work as part of a team. In those instances,
    your team must work in a way that allows your colleagues to get the updates you
    have done, as well as update others on their own changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Git is a *distributed* VCS, which means any local repository can
    act as the remote repository for someone else. This means your colleagues can **pull** your
    changes onto their machine, and you can pull their changes onto yours:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d48350d-651b-48e7-8701-aed7f7e1181d.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this would mean you'd have to pull from everybody's machine regularly
    to get all the latest changes. Furthermore, where there are merge conflicts, one
    person might resolve them differently to another.
  prefs: []
  type: TYPE_NORMAL
- en: So while it is technically possible to follow this distributed workflow, most
    teams elect a single repository that they consider to be the central one.
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention, this remote repository is called `origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/201c4432-d7b1-491e-8290-6d5df17faa1c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you want to update your local repository with changes made by your colleagues,
    you *pull* from the `origin` repository. When you have changes that you think
    are ready to be incorporated, you push them into `origin`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a remote repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to host a remote repository. You can set up your own server,
    or you can use a hosted service such as Bitbucket or GitHub. We are going to use
    GitHub as it is the most popular, and is free for public repositories.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to keep your repository private, you can either pay for a personal
    plan from GitHub, which is currently set at $7 per month; or you can use BitBucket,
    which is free for both public and private repositories (although other limits
    apply).
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://github.com/](https://github.com/) and click on the Sign Up button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in your details to create an account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once logged in, click on the New Repository button or go to [https://github.com/new](https://github.com/new)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the details about the repository, but do *not* check the Initialize
    this repository with a README box or add a license:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/828c152c-7255-4b3e-b2ca-53f007cf6238.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you press Create repository, GitHub should show a Quick setup tooltip.
    This indicates that we have now successfully created our repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e0038e9c-ec93-4099-a58c-30a4b9d2bcde.png)'
  prefs: []
  type: TYPE_IMG
- en: Pulling and pushing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to update our local repository so it knows the address of the
    remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Don't use `https://github.com/d4nyll/hobnob.git`; create your own remote repository
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get a `fatal: Authentication failed for https://github.com/d4nyll/hobnob.git/`
    error, check that your GitHub username and password are entered properly. If you
    use two-factor authentication (2FA) on your GitHub account, you need to use an
    SSH key to push to the remote repository.'
  prefs: []
  type: TYPE_NORMAL
- en: The `-u` tag sets the upstream repository to be `origin`. Without it, we would
    have to specify which remote repository we want to push to or pull from every
    time we run `git push` and `git pull`; using the `-u` tag here will save us a
    lot of time in the future. Subsequent pushes and pulls can omit the `-u` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `git push` doesn''t push tags to remote repositories. So, we''d
    have to push tags manually. The syntax for pushing tags is similar to that of
    pushing branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you want to push all tags, you can run the following command
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Cloning a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our code is now publicly available on GitHub. Our colleagues and/or collaborators
    can now download the code using the `git clone` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new directory inside the directory where the `git clone`
    command was run, and copy the contents of the remote repository into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your collaborators can then work on this local copy of the repository, commit
    changes, and add new branches. Once they are ready to make their changes available
    to others, they can pull from the remote repository, resolve merge conflicts,
    and then push their changes back to `origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Conducting peer review through pull requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, it's fine to allow anyone to push to and pull from the repository.
    However, for more important projects, you may wish to prevent new or junior developers
    from pushing to important branches such as `dev` and `master`. In those instances,
    the owner of the repository may restrict push rights to only a small selection
    of trusted developers.
  prefs: []
  type: TYPE_NORMAL
- en: For non-trusted developers, in order to make a change to `dev` or `master`,
    they must create a new branch (such as a feature or bug-fix branch), push to that
    branch, and create a **pull request** (**PR**). This PR is a formal request for
    their branch to be merged back to `dev` or `master`.
  prefs: []
  type: TYPE_NORMAL
- en: Pull requests are a feature of platforms such as GitHub and BitBucket, and not
    of Git itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'After receiving a pull request, the owner or maintainer will review your work
    and provide feedback. On GitHub, this is done through comments. The contributor
    will then work with the maintainers and make changes to the code until both are
    happy with the changes. At this point, the maintainer will accept your pull request
    and merge it into the intended branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dccd81d3-74fb-4ba8-afea-c142101a1d61.png)'
  prefs: []
  type: TYPE_IMG
- en: Conversely, if the maintainers do not feel the changes are in line with the
    goals of the project, they can reject them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing pull requests in your development process has several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: You can notify your peers that a feature/bug fix has been completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a formal process where all comments and discussions are logged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can invite reviewers to peer-review the changes you've made. This allows
    them to help spot obvious errors, as well as to provide feedback on your code.
    This not only ensures the code quality of the source code is high, it also helps
    the developer learn from other people's experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we outlined how to manage your project's version history using
    Git. We started by understanding the different states in Git and practicing some
    basic Git commands, and using them to commit, branch, and merge our changes. We
    then set up a remote repository on GitHub, which allowed us to share our code
    and collaborate with others.
  prefs: []
  type: TYPE_NORMAL
- en: The workflow and conventions used here are opinionated, and you may come across
    different patterns in your workplace. There is no right way to use Git, only wrong
    ways, and the rules we used here are not perfect. For example, in the Driessen
    model, once a feature is merged into `dev`, it will be hard to extract it. Therefore,
    we have to be careful not to merge in features that are not meant for the current
    release. Therefore, the most important takeaway from this chapter is to establish
    a set of conventions with your team, and stick to it consistently.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start writing our first lines of code, setting
    up our development environments and tools, and integrating with JavaScript-specific
    tools, such as `npm`, `yarn`, Babel, and `nodemon`. For the rest of this book,
    as you work through the exercises and build the application, we expect you to
    use the workflow outlined here to keep a version history of your code.
  prefs: []
  type: TYPE_NORMAL
