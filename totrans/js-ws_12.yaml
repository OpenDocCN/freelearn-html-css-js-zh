- en: 12\. Using Next-Generation JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to identify and select from the
    tools available for advanced JavaScript development; use the latest JavaScript
    syntax in older browsers; select from useful frameworks for client-side and server-side
    application development; use `npm` and `Yarn` within a project; apply config-free
    asset management using `Parcel`; and implement configurable asset management using
    webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you looked at creating clean, maintainable code by
    utilizing coding best practices, ensuring pure function implementation, and keeping
    your code simple. Now, while your code may be concise and correct, there are numerous
    factors that can cause problems when it's time to deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing JavaScript applications is not natively a simple "**write and deploy**"
    practice. There are many caveats that need to be overcome; for instance, managing
    incorporated third-party modules, ensuring the proper directory structure of your
    project, and ensuring your code runs without error in all the necessary environments.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that JavaScript is a constantly evolving platform.
    Since its creation, JavaScript has always had differences between the available
    runtimes and, most notably, between browser types and versions. In the early years
    of its existence, JavaScript was quite unruly, with obvious differences between
    browsers. During those times, developers needed to repeatedly test their applications
    in each browser frequently to ensure it ran successfully and without bugs. Even
    now, each available modern browser has a different list of supported features
    and, awkwardly, very small variations in how similar features are implemented,
    which can trip up an unsuspecting developer. Attempting to write code that works
    in all modern browsers can be time-consuming and may require some patience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, there are ways to overcome these differences through tooling and
    libraries. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Polyfill** libraries, which add missing features to runtimes, ensuring a
    better match between environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries that support coding methodologies, ensuring a practical cross-runtime
    development experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transpilers**, which convert a singular language implementation into code
    supported in multiple different runtime environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By including these tools in your project workspaces, you can not only save hours
    of frustration and needless headaches when deploying your code but also ensure
    a pleasant development experience from its inception. The idea is to support your
    creativity rather than to fight with the tools.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will highlight those libraries and tools that make light work of
    coding with JavaScript, as well as to inform you of where to look so that you
    can customize your development experience.
  prefs: []
  type: TYPE_NORMAL
- en: Browser Differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user views a website or web application, it is important that it works
    as expected and, preferably, works similarly within all browsers. However, ensuring
    this occurs is a difficult task for many developers. Not only do browsers provide
    slightly varying implementations of JavaScript, but also of HTML5 features, **Cascading
    Style Sheet** (**CSS**) support, and more. Overcoming such differences have been
    an important task in every JavaScript developers working life, with experience
    playing a key part in ensuring applications work similarly in all environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what works on different browser types and versions, you can use the
    *Can I Use* website, which lists every browser''s features and their compatibility:
    [https://caniuse.com/](https://caniuse.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, Microsoft has worked to eradicate these differences. For instance,
    on iOS devices, Microsoft's Edge browser uses **WebKit**, which is the same technology
    that's used by Google's Chrome and Apple's Safari browsers. As such, the future
    of web application development is looking much brighter, with fewer caveats between
    browsers. The problem will be, though, that not all users are up to date with
    the latest versions of their internet browser, meaning backward compatibility
    is still a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: polyfills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution to browser incompatibilities is to use polyfills. These are libraries
    that are created by third parties to bridge the gaps between browsers, ensuring
    the functionality they provide is matched. There are many polyfill libraries,
    each asserting a given list of features across a range of browsers and browser
    versions. The most popular of these polyfills is **Polyfill.io** ([https://polyfill.io/v3](https://polyfill.io/v3)).
  prefs: []
  type: TYPE_NORMAL
- en: Polyfill.io was created by the *Financial Times* to cover a broad range of discrepancies
    among browsers. It is an open-source library that can be configured to include
    just the features you require, or you can simply import everything. By including
    it in your project, you can smooth over the cracks in browser differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Including Polyfill.io in your application is as simple as adding it with a
    `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, to make full use of Polyfill.io, it is best to appropriately configure
    it to your needs using the `Create a Polyfill Bundle` page on the Polyfill.io
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Transpilers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transpilers are tools that convert one language into another. They are similar
    to compilers, except compilers typically convert a language into machine code
    or into intermediate byte code. There are many transpilers that convert a different
    language into JavaScript, but one of the most popular in web development is the
    **Babel transpiler**, which converts JavaScript into JavaScript. This may sound
    strange but imagine being able to utilize all of the latest features of JavaScript,
    then transpile it to work on all major browsers from the last 5 years, without
    having to utilize a polyfill library. This is essentially what Babel does.
  prefs: []
  type: TYPE_NORMAL
- en: The Babel transpiler, as well as several other transpilers, will be discussed
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Development Methodology Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative to covering the cracks in browser differences is to utilize
    libraries that offer a uniform development methodology that is supported in older
    browsers. There are many libraries that provide an arsenal of functionality, thereby
    making it easier to code in a predefined, opinionated manner. Some of these include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Underscore**, **Lodash**, **RxJS**, and **Ramda** functional programming
    libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **React**, **Polymer**, and **Riot** component-based UI libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Backbone** and **Knockout MVC** frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **jQuery** and **MooTools DOM** manipulation libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the preceding libraries may be used in tandem with each other and with
    a transpiler, so choosing your libraries can be an important step to getting the
    results you require. We will be looking at some useful libraries later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Package Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Package managers are tools that provide managed support for your included libraries.
    These package managers may provide functionality that can be used in your production
    code, provide functionality externally to your application that helps test your
    code, or even provide tools you can use to make development easier but that is
    discarded from the eventual production code.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a package manager, a manifest is kept that keeps track of
    each of the libraries that have been imported into your project, as well as their
    version numbers. This way, if you were to remove all of the libraries from your
    project, you could easily reinstall the libraries that were used instantly. This
    is very useful when storing your application source code in a source repository
    such as GitHub, as you only need to store your own code. Any libraries you have
    used in the past can be easily installed by other developers in your team using
    the package manifest, ensuring your source repository is streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: For many years, the most popular package manager that's been used by JavaScript
    developers has been Node Package Manager (npm). However, additional managers are
    available, with some gaining popularity, including Yarn.
  prefs: []
  type: TYPE_NORMAL
- en: The Node Package Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The node package manager (npm) is automatically installed when you install
    Node.js. Therefore, if you followed along in *Chapter 9, Working with Node.js*,
    then you should already have it. To test for it, simply run the following in your
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output version information if you do indeed have it installed on
    your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: npm version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: npm version'
  prefs: []
  type: TYPE_NORMAL
- en: When using npm with a project, it creates a manifest file called `package.json`,
    which maintains a list of production and development libraries to be used with
    your project. Any installed packages are stored in a directory called `node_modules`,
    which npm also creates, and which lives in the root of your project. It is advisable
    to ensure that the `node_modules` directory is never stored in your project's
    source code repository, for streamlining purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin using npm, you simply navigate to your project directory using your
    Terminal and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will prompt you to answer a number of questions. It''s okay if you don''t
    know what to put for these, and you can simply press the Enter key to skip them
    and use the provided default values if you wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: npm initialization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: npm initialization'
  prefs: []
  type: TYPE_NORMAL
- en: Once completed, it will create a barebones `package.json` file containing the
    JSON code detailed in the preceding screenshot. Now, at this time, this JSON will
    not contain any modules, but that's fine. What it does and can contain is metadata
    about your project, such as its version, the initial index or starting script,
    and other such important information.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the predefined metadata properties is the `scripts` object. This is
    an important entry and one you will soon become familiar with. Each entry within
    this object is an executable command shortcut that you can invoke using the npm
    Terminal command. The one that''s provided initially doesn''t really do anything
    except output an error, but you can run it anyway if you wish so that you can
    see it in action. Do this by executing the following in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the current JSON, this will simply output the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Initial package.json output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Initial package.json output'
  prefs: []
  type: TYPE_NORMAL
- en: The `scripts` section of the `package.json` file is extremely useful for implementing
    your own shortcut commands so that you can run common tasks. You will be utilizing
    this a lot later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key task of a package manager is to install modules. As we stated previously,
    there are two primary ways to install a module into your project. The first is
    to install it as a production-level module. This means it may be incorporated
    into your deployment scripts during a build phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to install it as a development module, you would simply execute
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each installed module will be added to a list within the `package.json` file;
    either `dependencies` for production modules or `devDependencies` for development
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any time, once your module list exists within the `package.json` file, you
    can install all the modules by simply invoking the following in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If no `node_modules` folder exists in your project, this command will create
    it and proceed to download all the modules contained in both the `dependencies`
    and `devDependencies` lists.
  prefs: []
  type: TYPE_NORMAL
- en: The Yarn Package Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yarn is a more recent addition to the available JavaScript package managers
    but is increasing in popularity. It was conceived by Facebook, in collaboration
    with Google, Tilde Inc., and Exponent Inc., and works as a different frontend
    to the npm repository. It was created primarily to provide a safer alternative
    to npm since the npm command-line tool can allow modules to run code upon installation,
    which can be a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you should use Yarn is simply a preference. The issues that are exposed
    by the Yarn project are likely to be patched by npm over time and may already
    be irrelevant. Since Yarn doesn't replace much in the npm ecosystem, there isn't
    a big requirement to use it over the **npm CLI**.
  prefs: []
  type: TYPE_NORMAL
- en: The Babel Transpiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Babel is a set of tools and libraries that transpiles JavaScript into JavaScript.
    Its benefit is that you can use cutting-edge JavaScript features today and still
    ensure that they run on a wide range of browsers and browser versions, all while
    ensuring minimally produced code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When working on exceptionally small projects, it is still possible to create
    much shorter scripts than what's run on most browsers. Using Babel is mostly beneficial
    for medium-to-large projects, which many modern JavaScript applications tend to
    be. Therefore, if all you are doing is reading some values from a field or two
    and validating them using a handful of lines of JavaScript, then you may be better
    off skipping modules and transpilers altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple Babel installation provides three development-time tools and a polyfill
    library to be compiled into your application. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Babel engine core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Babel command-line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Babel environment preset engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Babel/polyfill library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the Babel tools can be installed using the npm CLI and use package names
    that are prefixed with `@babel/`. This is known as the package scope or namespace
    and ensures that other packages in the npm repository do not conflict should they
    have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: '@babel/core'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@babel/core` tool provides the engine of the Babel transpiler. It contains
    functions that invoke the transformation of JavaScript code from one form to another,
    though the logic for various transformations may not be in the `@babel/core` package
    itself. All Babel installations must include the `@babel/core` package in order
    to function.
  prefs: []
  type: TYPE_NORMAL
- en: '@babel/cli'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`@babel/cli` provides command-line functionality for Babel projects. This can
    be used to invoke the transpilation of your source code, as well as to incorporate
    additional plugins and configuration. However, you will not typically use this
    CLI directly. Instead, you will create a new `scripts` entry and provide the configuration
    in a separate file.'
  prefs: []
  type: TYPE_NORMAL
- en: '@babel/preset-env'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@babel/preset-env` tool provides intelligent directives for transpiling
    your code for specific environments, such as browser types and versions. Typically,
    the wider the range of environments you wish to support, the larger your resulting
    deployable transpiled code will be. The configuration for this tool will exist
    in a configuration file so that you only need to specify it once.
  prefs: []
  type: TYPE_NORMAL
- en: '@babel/polyfill'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`@babel/polyfill` is a library that is at least partly compiled into your deployable
    code. Through using `@babel/preset-env`, Babel selects elements from `@babel/polyfill`
    to include in the transpiled code.'
  prefs: []
  type: TYPE_NORMAL
- en: .babelrc Configuration File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `.babelrc` file (note the period character at the start of the filename)
    is a JSON configuration file that sits in the root of your project directory.
    This file can store information about the presets, plugins, and various other
    bits of information that are useful for Babel's installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common configuration you will apply to this file will be the environments
    you wish to support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example requests that Babel transpiles code to support browsers
    that are used globally by more than 0.25% of the population. Otherwise, those
    browsers are not considered dead, which means browsers that are still actively
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: A full explanation of the environment queries that are supported by the `.babelrc`
    configuration file can be found at [https://packt.live/2NVxWwP](https://packt.live/2NVxWwP).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.01: A Basic Babel Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a usable install of the Babel transpiler
    using npm. This will be a simple setup that will result in a working environment
    that''s able to transpile a source modularized JavaScript application into a deployable
    repository of files. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a new directory called `babel_app` in your operating system''s
    `Documents` folder using the Terminal. Then, navigate into that directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, initialize the folder as an npm project. You can use all of the default
    settings for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see something similar to the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.4: npm initialization'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_12_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.4: npm initialization'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that npm is set up, you can install the Babel development libraries. These
    will need to be saved in the `devDependencies` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see some information pertaining to downloading the modules to the
    `node_modules` directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.5: Development modules installed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_12_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.5: Development modules installed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These files will not be compiled into your resulting transpiled application
    since they are used to perform the transpiling itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you will need to install the Babel polyfill library. This library will
    be transpiled into your resulting application, as required by the transpiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, this module will be saved in the `node_modules` directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.6: Polyfill module installation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_12_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.6: Polyfill module installation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the modules installed, you will now need to configure Babel. This requires
    a new file called `.babelrc`, which will contain the appropriate JSON. There are
    many possible configurable features of Babel, but for this exercise, you will
    simply need to specify the environment presets. Create a new file called `.babelrc`
    in the root of the project directory and populate it with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With everything in place, you will now need to create your project work files
    and directories. You can layout your project however you like, but for this example,
    you''ll utilize two directories: an `src` directory for source files and a `dist`
    directory for transpiled files. Go ahead and create these in the root of the project
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you''ll need a project file to transpile. In the `src` directory, add
    a file called `index.js` and add the following JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This JavaScript uses a little of the ES2015 specification, in the form of the
    fat arrow function. This means, when transpiled, you should see a difference between
    what is in the source file and what is in the transpiled file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, in order to get everything working, you''ll need to modify the `package.json`
    file to include a script that executes the Babel transpiler. Go ahead and open
    that file up, and then add the following line to the `scripts` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line means that when you run it, it will call the Babel CLI tool using
    the npm package runner and will pass it the `src` directory for input and the
    `dist` directory for output. Don''t forget to add a comma at the end of the previous
    line or your JSON will be invalid. Your `package.json` file should now look as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the version numbers next to each of the module entries. If your version
    numbers are different, don't panic. The steps that were used to install these
    modules ensured that the latest versions were downloaded. Any differences in your
    own file compared to the preceding code simply mean those modules have been updated
    since this chapter was written. However, everything should still work fine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, it''s time to run the transpiler. To do this, simply call the script
    through the npm CLI tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once executed, take a look at the `dist` directory. It should now also contain
    an `index.js` file. However, the contents of this file will differ slightly to
    the code you entered in the `index.js` file in the `src` directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the Babel transpiler stripped out the fat arrow function syntax
    and replaced it with a standard function definition. This is so that the transpiled
    code will work in the environments you specified in the `.babelrc` configuration
    file. Babel allows you to utilize any of the cutting-edge features you want to
    use while being comforted by the knowledge that your resulting transpiled application
    should work exactly where you need it to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The basic setup we've described here provides a powerful starting point for
    even the largest of applications. Many professional JavaScript development companies
    use Babel to ensure code correctness, portability, and a flexible working environment
    that can be managed by teams of developers without having each developer stepping
    on the toes of another.
  prefs: []
  type: TYPE_NORMAL
- en: While what you have accomplished is a great starting point for a robust, team-driven
    application, there is more that can be accomplished to improve this even further.
    We will look at some of these additional steps throughout the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Babel Applications with Parcel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'npm works very well as a package manager, but its project management capabilities
    are limited. In the previous exercise, you set up a script in the npm `package.json`
    file that executed the Babel transpiler. The transpiler can translate JavaScript
    files one at a time and place the resulting translated files in the `dist` directory,
    but that''s about the extent of it. Often, your projects will have other requirements,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring your files are combined into fewer resulting JavaScript files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining hot modules (breaking the compiled output into smaller chunks with
    dynamic loading)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing CSS files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring files aren't cached between builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to write your own scripts to manage your projects and execute
    them from npm from a parent script, but this is a lot of repetitive work that
    has already been solved by others. **Parcel** is a solution to this.
  prefs: []
  type: TYPE_NORMAL
- en: What is Parcel?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parcel is considered a web application bundler. It is, essentially, a packaging
    module that performs the tasks that were listed in the previous section. What
    makes Parcel unique is that it is a zero-configuration bundler. You simply call
    it from your project directory, and it figures out how your application should
    be readied for distribution. The only requirement, then, is to call the Parcel
    CLI command to launch it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parcel is typically installed in your project as a global module. This means
    it is not stored in the `node_modules` directory in your project folder, but in
    a `node_modules` directory that exists on your operating system''s environment
    path. To do this, instead of supplying a `--save` or `--save-dev` flag, you supply
    a `-g` flag, for global:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since Parcel is globally installed, the installation will not modify the `package.json`
    file as it will not need to be added to the `dependencies` or `devDependencies`
    lists.
  prefs: []
  type: TYPE_NORMAL
- en: Using Parcel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make use of Parcel, you will need to add new scripts to the `package.json
    scripts` object. There are several ways Parcel can be called. The first is simply
    to pass the main JavaScript file as the only parameter to the `parcel` CLI tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will request that Parcel processes the JavaScript file and for it to output
    a development build of it. Parcel traverses this file and determines whether any
    other files also need processing. During the processing phase, Parcel will also
    analyze any configuration files present within the project directory. The `.babelrc`
    configuration file is one such file Parcel understands. Therefore, by its very
    presence, Parcel will ensure that any JavaScript files are transpiled by Babel.
    The same will be true if common configuration files are present for other tools,
    but also with files of a given type within the source tree, such as HTML and CSS
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Parcel development build'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.7: Parcel development build'
  prefs: []
  type: TYPE_NORMAL
- en: When processing as a development build, Parcel includes additional code within
    the transpiled JavaScript. Additionally, a call to Parcel to process your files
    in development mode will not return. As you can see in the preceding screenshot,
    running Parcel in development mode launches a special development server, which
    you can navigate to by going to [http://localhost:1234](http://localhost:1234)
    in your web browser. This simply presents your transpiled application as though
    it were running on a remote webserver.
  prefs: []
  type: TYPE_NORMAL
- en: The running service also utilizes a filesystem listener so that, when you update
    a file within your project, that file is then automatically reprocessed, and the
    resulting changes are made available immediately. If you then view your application
    within the browser at the time a file is changed, the browser will automatically
    be refreshed to include those changes. This feature greatly speeds up development
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to invoke the parcel CLI tool is to provide the `build` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `build` flag tells Parcel to process the source files so that they''re
    ready for a production release. This version will not have the additional browser
    update code and there will be no development server running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: Parcel production build'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.8: Parcel production build'
  prefs: []
  type: TYPE_NORMAL
- en: When deploying your finished application to a production server, the development
    features are not necessary and simply add bloat to your code, so being able to
    compile your application without them is a necessary step.
  prefs: []
  type: TYPE_NORMAL
- en: Modular Applications in Parcel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Utilizing Parcel provides a lot of features for free. In *Chapter 9, Working
    with Node.js*, you saw how modules are acquired in a Node.js application. Transpiling
    with Babel and Parcel also provides module acquisition when using the `import`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building your applications, it is preferable to break the application
    source into smaller files so that managing your code is simpler. The `import`
    keyword follows the ES2015 specification, whereby each module in your source directory
    `exports` one or more functions, which can then be imported into other modules
    as required using the `import` keyword. If a module `exports` only one function,
    then it can be exported simply as a `default` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In another module, this function can then be imported with a named reference,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `.js` extension was not required when naming the importing module,
    much like how Node.js imports modules. The transpiler automatically understands
    how to reference the external file using this format. When processing the `index.js`
    file, Parcel automatically traverses all imported files, transpiling those as
    well. Each module is followed, including their linked modules and so on. The resulting
    code is stored in a single JavaScript file in the `dist` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a module contains multiple functions, then it can export them using an object
    format. This foregoes the `default` keyword as, now, functions must be cherry-picked
    using their specific names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the calling module, each required function must be named explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using this method, only those functions you intend to use need to be imported.
    The transpiler will ensure that any dead functions (functions that are never called)
    are not transpiled needlessly into the resulting `dist` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.02: A Basic Parcel Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will update the application you created in *Exercise
    12.01: A Basic Babel Project* to incorporate a Parcel build system. You will also
    include an additional module so that you can experience how simple modular application
    development can be. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need to install the Parcel tools. If you have not already done
    so, install them globally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are on a Mac or Linux device and you receive an error stating that you
    have insufficient privileges, you will need to prepend the previous line with
    the `sudo` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new file in the `src` directory and call it `index.html`. Then,
    add the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Parcel works by processing a file tree. By passing an HTML file as the master
    file, not only will JavaScript files be processed, but so will the HTML, CSS,
    and other such assets linked in your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, update the `package.json` file to include the new `build` command scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `"build"` entry should replace the one we used previously, which called
    the Babel CLI directly. Your `package.json` file should now look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a new module in `src` called `module.js`. This file will demonstrate
    the module loading in Parcel. In this file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, import that module into the `index.js` file by replacing its content with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now run your application in development mode by simply calling the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should then see the expected development server launch in the Terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.9: Running the development server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_12_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.9: Running the development server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you launch your browser with the console open, you will see the expected
    content:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.10: Console output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_12_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.10: Console output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, update `module.js` by adding additional value in the array. When you
    save the file, the browser should instantly refresh to show the latest changes:![Figure
    12.11: Updated console output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_12_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.11: Updated console output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you view the source of the HTML page, you will see that the HTML doesn''t
    reference `index.js` as it does in the `src` directory. Instead, the JavaScript
    file will have a random name in order to prevent the browser from caching the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The setup we've created in this exercise is now a perfect starting point for
    many JavaScript projects. This simple build provides numerous development features
    that empower your coding and ensure optimal reliability in the production files.
  prefs: []
  type: TYPE_NORMAL
- en: Babel Applications with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is an application bundler for JavaScript applications that provides
    a much more configurable experience. In version 4, the webpack team introduced
    zero-configuration support in order to compete with Parcel specifically. While
    webpack is an excellent tool for bundling your JavaScript and other assets, it
    does take quite a lot of configuring and requires just as much patience.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a webpack, you simply install it, just like any JavaScript module. Webpack
    comes in two main parts: the webpack engine and the webpack CLI. Both can be installed
    simultaneously, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you install it using your Terminal, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: Webpack installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.12: Webpack installation'
  prefs: []
  type: TYPE_NORMAL
- en: 'With those downloaded, you can then add a script in the `package.json` file
    in order to execute them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by running the script in the Terminal, it should compile your JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: Executing Webpack zero configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.13: Executing Webpack zero configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in the preceding screenshot, both the `index.js` and `module.js`
    files were compiled into a file called `main.js`. Webpack defaults its entry point
    path to `src/index.js` and its output path to `dist/main.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s supply a source file and output file explicitly so as to try and mimic
    the Parcel build. Update your `wp` script to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set the input source as the `index.html` file and request the output
    to be placed in the `dist` directory, but with the same filename. If you run this,
    you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: Webpack HTML parse error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.14: Webpack HTML parse error'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the webpack wasn't too happy about finding an HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, a caveat with a webpack is that it does not try to be intelligent. The
    compiled output of the previous execution would not have transpiled your code
    using Babel, so the fat arrow functions from the source files will have made it
    to the output folder. Also, webpack in zero-configuration mode will only compile
    your JavaScript, meaning any other assets included in your application require
    some configuration in order for them to be processed and sent to the `dist` directory,
    including any HTML files.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Webpack provides a linear processing pipeline for your applications. Using
    a source input file, it will build a dependency tree, known as a dependency graph,
    and will process each file where configuration exists for that file type. The
    pipeline utilizes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Source input file or entry point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loader modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugin modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webpack requires a specific configuration for each of the asset types in your
    application so that it knows how to process them.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack Loaders and Plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both **loaders** and **plugins** are modules of code that you include in a webpack
    pipeline. They can be considered the bolt-on functionality since webpack is a
    pipeline, they are like its "fixtures and fittings." Loaders and plugins both
    have an effect on how your application is processed by webpack, but they are also
    quite different from one another.
  prefs: []
  type: TYPE_NORMAL
- en: A loader is a module that works at the beginning of the webpack pipeline; sometimes
    even before it starts. These modules process assets individually. For instance,
    if you wanted to use Babel in a webpack configuration, you would need to include
    the babel-webpack loader, which transpiles each file individually as they are
    processed.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins, on the other hand, tend to work at the end of the webpack pipeline.
    These modules affect the entire output bundle and allow you to have much greater
    control over your application output. Plugins are quite a bit more complex than
    loaders, and their configuration often reflects this.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The configuration of a webpack pipeline is added to a file called `webpack.config.js`,
    which exists in the root of your project directory. As a JavaScript file, it is
    executed by the Node.js runtime and can, therefore, include Node.js-compatible
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The webpack configuration is exported from the `webpack.config.js` file, much
    like any JavaScript module. The exported data can include information about the
    entry point path, destination path, loaders, and plugins, as is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, a simple `webpack.config.js` file, which specifies the entry
    point and output paths, may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you create a `webpack.config.js` file, be sure to reset your `package.json`
    script so that it is like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Failing to do so may cause confusing results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.03: A Basic WebPack Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will set up your webpack installation so that it implements
    Babel transpiling and so that it includes and processes your `index.html` source
    file. As we stated previously, there are many configuration features you can apply
    to a webpack installation, but by completing this exercise, you will have a better
    understanding of how to implement any loaders you require. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although your application includes the Babel transpiler in the `package.json`
    file, it is not enough for a webpack to be able to understand how and when to
    use it. To utilize Babel with webpack, you need to include and configure the `Babel
    loader module`. Run the following in your Terminal to download and install the
    Babel loader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open up the `webpack.config.js` file, if you have it, and add a new `module`
    section to the `exports` object. If you don''t have the `webpack.config.js` file
    yet, create it now and add the code from the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This new block provides the rule we can use to process files with Babel. Essentially,
    it''s saying "test: for filenames that end with `.js`, exclude: any files in the
    `node_modules` folder, use: `babel-loader` on those files you find."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With Babel transpilation supported, you now need to include support for HTML
    files. HTML processing is both a pre- and post-JavaScript processing task and,
    therefore, is carried out using both a loader and a plugin. To install both of
    these, run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If all went well, you should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.15: Webpack HTML loader and plugin installation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_12_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.15: Webpack HTML loader and plugin installation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With these modules installed, they now need to be configured in the `webpack.config.js`
    file. Like the Babel loader, the HTML loader should be entered into the `modules`
    array of the `exports` object. Add it after the `babel-loader` configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implementing the HTML plugin requires a couple of steps. First, you will need
    to require it at the top of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the module required, you can now configure it by adding it to the `plugins`
    section of the `exports` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the directory of the output file is not required. The HTML plugin
    will place it in the `dist` folder, regardless.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your `webpack.config.js` file should now look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, execute your webpack script. You should now find that the JavaScript
    output has been correctly transpiled by Babel and that the `index.html` file will
    also be present within the `dist` directory. Your Terminal window should look
    as follows:![Figure 12.16: Successful webpack transpilation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_12_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.16: Successful webpack transpilation'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring webpack installations can be quite a lengthy process of trial and
    error. Even with this exercise, you may notice that the `index.html` file still
    does not implement a non-caching process whereby the JavaScript output is renamed
    randomly to avoid browser caching. While webpack is a must for medium-to-large
    projects that require that extra mile in configuration freedom, it is recommended
    that Parcel is used for those small projects that need a simple setup, without
    configuration headaches.
  prefs: []
  type: TYPE_NORMAL
- en: Other Popular Bundlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many bundler tools available for your JavaScript project, each with
    their own benefits and caveats. Obviously, choosing a bundler may result from
    personal choice or it may be a requirement from the project manager, development
    team, or the organization that tendered the project. However, of those bundlers,
    two of the most popular tools that haven't been covered in this chapter yet are
    Gulp and Grunt.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gulp** and **Grunt** are a little different from the examples you''ve seen
    up until now as they don''t use configuration files. Instead, they use JavaScript
    code that you write to accomplish tasks similar to what webpack and Parcel can
    accomplish.'
  prefs: []
  type: TYPE_NORMAL
- en: Gulp and Grunt are known as task runners. This means that, instead of defining
    a coding environment for your project, they act as an application you write to
    manage the application you're writing; a kind of application wrapper, if you will.
    The toolsets for both these bundlers provide a framework to facilitate this, which
    runs on the Node.js runtime. You simply code what you would like to achieve and
    execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gulp` bundler which runs on the Node.js runtime is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grunt` bundler which runs on the Node.js runtime is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Other Language Transpiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The JavaScript platform is an extremely popular one. After all, it is the de
    facto script runtime for the majority of browsers. However, the JavaScript language
    isn''t necessarily loved by everyone. Some developers prefer a static typing system,
    while others prefer better interoperability with their favorite server-side language.
    Whatever the reason, this love/hate relationship, mixed with JavaScript''s monopoly
    of the browser itself, has created a long list of alternative languages that each
    transpile to JavaScript. Some of the more popular of these languages include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoffeeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ClojureScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Haxe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PureScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the list is much longer than this, but the preceding list does highlight
    some of the more popular alternatives, each of which has its own set of benefits
    and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TypeScript** is an interesting and important alternative to the JavaScript
    language. A superset of the JavaScript language, TypeScript was developed by Microsoft
    and was released sometime in 2014\. It is very similar to JavaScript but has a
    feature that is very important to some: strict typing with type inference.'
  prefs: []
  type: TYPE_NORMAL
- en: Strict typing is where a variable has a fixed type. This may be a number, a
    string, or a Boolean. By being strictly typed, a variable is unable to contain
    a value of any other type. This prevents a number of bugs in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a JavaScript problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'A developer builds a function that accepts two numbers and adds them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the developer has thought to check the parameters, first, that both `a`
    and `b` are provided, and then that the two values can be added together. However,
    as you saw in *Chapter 5, Beyond the Fundamentals*, the addition operator is overloaded,
    so if a string is passed, it will be concatenated into a new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: While this is fine if the developer expected the outcome, it does raise potential
    hazards that could be missed by even seasoned developers. Such bugs are problematic
    because they do not resolve in an error at the source, but rather further in the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript''s static typing could easily solve this issue by ensuring the values
    that are passed to the function are of a specific type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'All types are checked at compile time. In the preceding example, checking the
    content of the type is not necessary as the compiler will ensure that the function
    is called with the correct number of arguments. If an argument were optional,
    then it could be marked as such with the `?` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Such optional parameters must always appear at the tail end of the arguments
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, specifying the types of your variables is not required—the compiler
    will infer them. This means that based on the first value the variable contains,
    the compiler will then expect it to always contain a value of that type. Function
    arguments can still contain any type if you wish them to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.04: A Basic TypeScript Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript is a major player in the professional JavaScript world, so understanding
    how to set up a TypeScript project is an important skill. In this exercise, you
    will create a minimal webpack project by utilizing the TypeScript transpiler.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory and initialize it with a webpack installation, as per
    *Exercise 12.03: A Basic Webpack Project*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, install the TypeScript libraries from npm. These libraries will be saved
    as `devDependencies`, since TypeScript is not required by your project after transpiling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ts-loader` is a webpack loader module since webpack doesn''t know about or
    understand `*.ts` files out of the box.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The TypeScript transpiler utilizes configuration from a unique document in
    the root of your project called `tsconfig.json`. The possible values for this
    document are extensive, but for a simple project, simply enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `webpack.config.js` file and add the following rule to the `rules`
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the entry filename from `index.js` to `index.ts`. Your entire `webpack.config.js`
    file should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, provide an `index.ts` file within the `src` directory and add the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now compile the application with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now see a successful compilation output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17: TypeScript with webpack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.17: TypeScript with webpack'
  prefs: []
  type: TYPE_NORMAL
- en: What you have just created is boilerplate for any kind of TypeScript application.
    Creating a webpack and TypeScript project may be something you do time and time
    again for many of your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Elm and ClojureScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `null` and `undefined` values completely.
  prefs: []
  type: TYPE_NORMAL
- en: The intention of these languages is to empower the developer by outputting better
    code, but also improving the developer's coding ability. By thinking declaratively
    and functionally, problems can be solved more quickly and with better results.
  prefs: []
  type: TYPE_NORMAL
- en: Haxe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Haxe approaches JavaScript from a different angle. It was created as a unified
    language that could compile on many platforms, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Flash ActionScript 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# (.NET)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neko (a small, native cross-platform virtual machine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashLink (an even faster, more portable cross-platform virtual machine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The platforms that are supported are continually increasing thanks to an enthusiastic
    community.
  prefs: []
  type: TYPE_NORMAL
- en: By compiling on many platforms, the source code of a Haxe application has the
    benefit of being potentially portable between those platforms. This means you
    could write a Haxe application for a JavaScript client, but also use much of the
    same code in a C# server application.
  prefs: []
  type: TYPE_NORMAL
- en: Code Support Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout its relatively long life, JavaScript has acquired a number of popular
    and useful libraries to aid engineers with their application development. Some
    of these libraries simply provide useful and reusable functions that reduce code
    complexity, while others offer extensive opinionated frameworks. Everything from
    user interfaces to database management is covered, with many overlapping libraries
    providing something a little different than competing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jQuery is one of the oldest running utility libraries available. Functioning
    as a general-purpose tool, jQuery empowered developers with a simple means to
    manipulate the browser's Document Object Model (DOM), perform animations, send
    Asynchronous JavaScript and XML (AJAX) requests, manage events, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Before jQuery was first released, finding and acquiring nodes within a web page
    was a laborious task, as was handling data and events from UI controls. The inception
    of jQuery alleviated a lot of the issues of earlier browsers, specifically with
    regard to cross-browser differences.
  prefs: []
  type: TYPE_NORMAL
- en: These days, much of the functionality provided by jQuery is now present in modern
    browsers, but the library itself is still a popular choice for many seeking a
    more uniform means to manage client-side application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'jQuery provides a singular global reference object that can be accessed in
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: jQuery's ubiquity means that you're likely to see the solitary `$` symbol used
    throughout the internet and, indeed, very few libraries adopt this simple sigil,
    which is a valid variable symbol, for that reason.
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery library has been covered somewhat in previous chapters, so no further
    information will be provided here.
  prefs: []
  type: TYPE_NORMAL
- en: Underscore, Lodash, and Ramda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming is becoming ever more important, with the benefits being
    realized in many different languages and platforms. While we can program in JavaScript
    functionally, it still does lack many features of more mature functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this shortcoming, the JavaScript community has provided numerous
    functional-oriented libraries, with the most popular being Underscore, Lodash,
    and Ramda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underscore and Lodash are named thus due to their use of the `_` symbol. Just
    like jQuery''s `$` symbol, the `_` symbol provides the single access point for
    either of these libraries. Both libraries provide a means to assign the primary
    object to a variable of a different name if there is a likelihood of a clash of
    library namespaces in an application, but since Underscore and Lodash provide
    much of the same functionality, it is not common to see both in use at the same
    time. The Ramda library uses the capital letter `R` as its library accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: While each of these libraries provides a number of overlapping features, there
    are some functionalities that are unique to a library among the three. For instance,
    the Ramda library provides lensing functionality, which is a means to operate
    on subsets of a collection of data that match the given criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Client Frameworks Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recent years have seen an explosion in powerful JavaScript application frameworks.
    Many of these provide interesting ways to greatly simplify single-page application
    (SPA) development, as well as modular, dynamically loaded applications. While
    frameworks have long been an important requirement for reducing development complexity,
    supporting engineering teams, and facilitating common use cases with minimal fuss,
    modern frameworks often take things to a whole new level.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to mobile internet browsing, JavaScript applications often require increased
    functionality within the browser and less on the server. This greatly increases
    complexity and, while many such large applications require many engineers to work
    on such a JavaScript project, building these from scratch simply isn't conducive
    to a productive project. As such, frameworks are now becoming more and more important
    to reduce time to market, increase standards and best practices, and to raise
    creativity.
  prefs: []
  type: TYPE_NORMAL
- en: Models, Views, and Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most application frameworks implement an architecture that separates application
    logic into common units of functionality. The primary abstraction of these units
    typically consists of Models, Views, and Controllers (MVC), whereby the Model
    represents an application''s data, the View represents how information is presented
    to the user, and the Controller is the functionality that facilitates processing
    between data and events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18: Model-View-Controller'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.18: Model-View-Controller'
  prefs: []
  type: TYPE_NORMAL
- en: The notion of an MVC was derived well before the inception of the JavaScript
    language and, indeed, frameworks often derive from an MVC to something a bit more
    appropriate to the browser, such as the Model-View-View-Model (MVVM) pattern.
    However, simply understanding that there is an abstraction, and knowing the roles
    of the actors therein, helps improve your adoption of any given framework.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOMs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another commonality of many newer frameworks is the inclusion of a virtual DOM.
    These are rendering engines that manage changes to nodes within the DOM. This
    means that, instead of manipulating the HTML within a web page directly, developers
    will instead utilize an API that sits between the application and the DOM. This
    way, when updates are needed, the virtual DOM will modify only those elements
    of the DOM that have changed by facilitating known low-latency, highly efficient
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: A great benefit of virtual DOMs arises when implementing two-way data binding
    between a Model and a View. If a user inputs a value in a text field, the associated
    Model could be instantly and automatically updated. Likewise, when the model updates,
    this may also trigger another view to display this new value.
  prefs: []
  type: TYPE_NORMAL
- en: This is known as two-way data binding, which is the ability for a model and
    its views to equally update each other when one location changes. Such manipulations
    of the browser are greatly enhanced through the use of a virtual DOM, which may
    previously have resulted in user experience degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another feature that's commonly found in modern frameworks is reactive functionality.
    When two-way data binding occurs using a virtual DOM, it is typically a reactive
    code that facilitates it. Reactive programming is a methodology of facilitating
    responsiveness, resilience, and scalability through data messaging. The idea is
    that, instead of polling and pulling data, messages are pushed as changes to data
    occur or when new data is made available. These updates may occur within an application
    or between applications, such as between the browser and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is such an important new paradigm that whole libraries
    and frameworks are named after it, such as RxJS (the Rx means Reactive) and ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: Popular Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the numerous frameworks available, there are three that are arguably the
    most popular among the JavaScript community. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AngularJS**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReactJS**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vue.js**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS was created by Google and released in October 2010 and was completely
    rewritten in 2014 as Angular2, changing many of its unique characteristics and
    adopting TypeScript as its preferred language; though it can be utilized with
    vanilla JavaScript with a bit of work. Since the rewrite, Angular2 is now incrementally
    updated with new releases regularly. Currently, Angular2 is on version 8 but is
    still called Angular2, which can get very confusing.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS (and its successor, Angular2) has a relatively high learning curve,
    flourishing many paradigms that are unique to the Angular community. However,
    it's an extremely opinionated library, helping to ensure that teams of developers
    utilize it in a common way, relieving any potential ambiguity of functionality.
    Additionally, AngularJS is a fully encompassing framework, providing almost all
    of the tools you may require when building complex browser-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ReactJS was conceived and developed by a single engineer at Facebook. In contrast
    to AngularJS, ReactJS does not try to do everything for you but purports to be
    merely the UI management layer, providing Virtual DOM functionality and other
    such goodies. The community that has formed around this framework has created
    additional libraries that can come together to form an ecosystem with similar
    capabilities to AngularJS. However, unlike AngularJS, ReactJS is not so opinionated,
    meaning applications can pick and choose what is implemented and, to some degree,
    how it is implemented. Developers also have greater freedom to decide from a range
    of libraries that compete to provide similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vue.js was developed by Evan You in 2013, a Google developer who had been using
    AngularJS while working for Google, but who decided he'd like to take only those
    elements of AngularJS that he liked and make his own lightweight framework. The
    result is a modular framework that provides almost all of the functionality of
    AngularJS, but in pieces that can be selected as needed, such as ReactJS, and
    with a total file size far smaller than either of the other two frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js has a very gentle learning curve and is steadily increasing in popularity
    as a framework that offers great application development structure, but without
    the rigid opinionated paradigms that work well in team environments. However,
    these often-hinder projects of a less vanilla nature.
  prefs: []
  type: TYPE_NORMAL
- en: Server-Side Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the browser, the server-side JavaScript ecosystem also has access
    to libraries and frameworks that aid an application's development. Since Node.js
    is JavaScript too, it is possible to utilize many libraries within both the browser
    and Node.js. For instance, Lodash, Underscore, and Ramda, having no browser-specific
    qualities, will function just as well in a Node.js application. This is one of
    the key reasons why the Node.js platform took off so quickly following its initial
    release; with so many libraries already usable on the platform that was created
    for browser applications, it was possible for developers to continue working in
    a style they were familiar with for server-side application development.
  prefs: []
  type: TYPE_NORMAL
- en: As well as all the possible browser-centric libraries, Node.js also has some
    key libraries of its own that provide functionality that is not possible in the
    browser, such as REST server functionality or database object relational mapping
    (ORM).
  prefs: []
  type: TYPE_NORMAL
- en: Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Possibly the single most popular library for Node.js is called Express. This
    library makes it extremely easy to build webservers since it provides functions
    that are able to establish routes and serve content when requests are sent to
    those routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Express can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can write a simple server application, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Once built, the webserver can be launched just like any other Node.js application;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The Express object supports all possible HTTP call types, including `GET`, `PUT`,
    `POST`, and `DELETE`, thus empowering complete REST-capable servers, but is also
    capable of serving static HTML, JavaScript, CSS, and other such asset files, using
    a special `static` function.
  prefs: []
  type: TYPE_NORMAL
- en: The Express library is very complete, so reading the documentation and guides
    on its website is recommended so that you get a true feeling of its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Express functions as a webserver, the Request library functions as a web
    client. Often, when creating web applications, it can become necessary to proxy
    content, data, or functionality from another remote webserver. The Request library
    enables communication with such servers for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Request can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can use Request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Socket.IO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with HTTP can be slow. The client creates a request packet and sends
    it to the recipient server. This server then creates a response packet and sends
    it back to the caller. Each request/response transaction is atomic, meaning it
    occurs independently of any other request/response transactions, often requiring
    a unique connection setup and teardown.
  prefs: []
  type: TYPE_NORMAL
- en: Modern applications prefer to utilize web sockets more and more. These are "always
    connected" sockets that use a faster, more agile connection protocol for sending
    data and are wonderful for building applications such as online chat rooms, multiplayer
    games, and also for fast data storage and retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: While web sockets utilize a protocol of their own, that protocol merely handles
    the security and reliability of the data transaction, and not with the specific
    requirements of an application's logic.
  prefs: []
  type: TYPE_NORMAL
- en: To address this, Socket.IO provides an additional layer to make working with
    web sockets much easier, thus providing functionality that's common to many applications
    that can utilize it how they see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Socket.IO can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple Socket.IO server application looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 12.01: Creating a Project to Recognize and Compile TypeScript Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter provided a lot of information regarding the investigation of the
    greater JavaScript world. Obviously, there is a lot you can learn beyond the basics
    of a language or platform but knowing where to look and how to integrate a new
    library or framework into your application provides the necessary foundation from
    which you can experiment and improve your coding skills.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you have been tasked with setting up TypeScript for a new
    project. You are now aware of what TypeScript is. For the project at hand, both
    your project manager and your developer colleagues want to utilize TypeScript's
    static typing capabilities, among other things, in what will be a large project.
  prefs: []
  type: TYPE_NORMAL
- en: Your task for this activity is to create the initial project setup, ensuring
    that TypeScript files are recognized and compiled correctly to the output folder.
    It is not important to provide any code, merely to ensure everything compiles
    successfully. The project manager is happy for Parcel to be used in this project
    in order to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project that has `npm` initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Parcel as a global library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the TypeScript library in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the necessary TypeScript configuration but keep it simple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a temporary `.ts` file in the `src` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the necessary script to the `package.json` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the transpiler and ensure that output is generated. You should see no errors.
    The TypeScript transpiler should show a `Built in <x>ms` response message if all
    went well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for this activity is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19: Parcel TypeScript Output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.19: Parcel TypeScript Output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to the activity can be found on page 752.
  prefs: []
  type: TYPE_NORMAL
- en: Simply knowing how to utilize a package manager opens up vast amounts of power
    so that you can create functional applications quickly. When working in a professional
    environment, using the necessary tools in the correct fashion is paramount and
    will ensure that your application starts off on the right footing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at the various tools that are available on the
    market for advanced development in JavaScript. We learned how to use the latest
    JavaScript syntax in older browsers and identified the different options that
    are available for the development of JavaScript applications in other languages.
    We also explored the various package managers, such as npm and Yarn, that are
    compatible with JavaScript, along with several different frameworks, such as AngularJS,
    ReactJS, and Vue.js. Finally, we looked at some server-side libraries such as
    Express, Request, and Socket.IO.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some other areas of advanced JavaScript.
  prefs: []
  type: TYPE_NORMAL
