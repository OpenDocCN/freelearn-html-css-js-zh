- en: 12\. Using Next-Generation JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 使用下一代 JavaScript
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to identify and select from the
    tools available for advanced JavaScript development; use the latest JavaScript
    syntax in older browsers; select from useful frameworks for client-side and server-side
    application development; use `npm` and `Yarn` within a project; apply config-free
    asset management using `Parcel`; and implement configurable asset management using
    webpack.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够识别和选择可用于高级 JavaScript 开发的工具；在旧浏览器中使用最新的 JavaScript 语法；从客户端和服务器端应用程序开发的实用框架中选择；在项目中使用
    `npm` 和 `Yarn`；使用 `Parcel` 进行无配置的资产管理；以及使用 webpack 实现可配置的资产管理。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you looked at creating clean, maintainable code by
    utilizing coding best practices, ensuring pure function implementation, and keeping
    your code simple. Now, while your code may be concise and correct, there are numerous
    factors that can cause problems when it's time to deploy your application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了通过利用编码最佳实践、确保纯函数实现以及保持代码简洁来创建干净、可维护的代码。现在，尽管你的代码可能简洁且正确，但在部署应用程序时，仍有许多因素可能导致问题。
- en: Writing JavaScript applications is not natively a simple "**write and deploy**"
    practice. There are many caveats that need to be overcome; for instance, managing
    incorporated third-party modules, ensuring the proper directory structure of your
    project, and ensuring your code runs without error in all the necessary environments.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 JavaScript 应用程序并非原生的“**编写和部署**”实践。有许多需要注意的事项需要克服；例如，管理集成第三方模块、确保项目的正确目录结构以及确保你的代码在所有必要的环境中运行无误。
- en: It is important to remember that JavaScript is a constantly evolving platform.
    Since its creation, JavaScript has always had differences between the available
    runtimes and, most notably, between browser types and versions. In the early years
    of its existence, JavaScript was quite unruly, with obvious differences between
    browsers. During those times, developers needed to repeatedly test their applications
    in each browser frequently to ensure it ran successfully and without bugs. Even
    now, each available modern browser has a different list of supported features
    and, awkwardly, very small variations in how similar features are implemented,
    which can trip up an unsuspecting developer. Attempting to write code that works
    in all modern browsers can be time-consuming and may require some patience.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，JavaScript 是一个不断发展的平台。自从其创建以来，JavaScript 总是在可用的运行时之间以及，最值得注意的是，在浏览器类型和版本之间存在差异。在其存在的早期，JavaScript
    非常难以驾驭，浏览器之间存在明显的差异。在那个时期，开发者需要频繁地在每个浏览器中重复测试他们的应用程序，以确保其成功运行且无错误。即使现在，每个可用的现代浏览器都有不同的支持功能列表，并且尴尬的是，相似功能实现的微小差异可能会让一个没有防备的开发者陷入困境。试图编写适用于所有现代浏览器的代码可能会耗费时间，并且可能需要一些耐心。
- en: 'Thankfully, there are ways to overcome these differences through tooling and
    libraries. These include the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有方法可以通过工具和库来克服这些差异。以下是一些方法：
- en: '**Polyfill** libraries, which add missing features to runtimes, ensuring a
    better match between environments'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Polyfill** 库，它们向运行时添加缺失的功能，确保环境之间的更好匹配'
- en: Libraries that support coding methodologies, ensuring a practical cross-runtime
    development experience
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持编码方法的库，确保实用的跨运行时开发体验
- en: '**Transpilers**, which convert a singular language implementation into code
    supported in multiple different runtime environments'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transpilers**，它们将单一语言实现转换为支持多个不同运行时环境的代码'
- en: By including these tools in your project workspaces, you can not only save hours
    of frustration and needless headaches when deploying your code but also ensure
    a pleasant development experience from its inception. The idea is to support your
    creativity rather than to fight with the tools.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些工具包含在你的项目工作区中，你不仅可以节省部署代码时的数小时挫败感和不必要的头痛，还可以确保从开始就有一个愉快的开发体验。这个想法是支持你的创造力，而不是与工具作斗争。
- en: This chapter will highlight those libraries and tools that make light work of
    coding with JavaScript, as well as to inform you of where to look so that you
    can customize your development experience.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将突出那些使使用 JavaScript 编码变得轻松的库和工具，并告知你如何查找信息，以便你可以定制你的开发体验。
- en: Browser Differences
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器差异
- en: When a user views a website or web application, it is important that it works
    as expected and, preferably, works similarly within all browsers. However, ensuring
    this occurs is a difficult task for many developers. Not only do browsers provide
    slightly varying implementations of JavaScript, but also of HTML5 features, **Cascading
    Style Sheet** (**CSS**) support, and more. Overcoming such differences have been
    an important task in every JavaScript developers working life, with experience
    playing a key part in ensuring applications work similarly in all environments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户查看网站或网络应用程序时，它按预期工作并且最好在所有浏览器中工作方式相似是很重要的。然而，对于许多开发者来说，确保这一点是一项艰巨的任务。不仅浏览器提供了略有不同的
    JavaScript 实现，还有 HTML5 功能、**层叠样式表** (**CSS**) 支持，以及更多。克服这些差异一直是每个 JavaScript 开发者职业生涯中的重要任务，经验在确保应用程序在所有环境中工作方式相似中起着关键作用。
- en: 'To see what works on different browser types and versions, you can use the
    *Can I Use* website, which lists every browser''s features and their compatibility:
    [https://caniuse.com/](https://caniuse.com/).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看不同浏览器类型和版本上哪些功能可用，你可以使用 *Can I Use* 网站，该网站列出了每个浏览器的功能和它们的兼容性：[https://caniuse.com/](https://caniuse.com/).
- en: In recent years, Microsoft has worked to eradicate these differences. For instance,
    on iOS devices, Microsoft's Edge browser uses **WebKit**, which is the same technology
    that's used by Google's Chrome and Apple's Safari browsers. As such, the future
    of web application development is looking much brighter, with fewer caveats between
    browsers. The problem will be, though, that not all users are up to date with
    the latest versions of their internet browser, meaning backward compatibility
    is still a necessity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，微软致力于消除这些差异。例如，在 iOS 设备上，微软的 Edge 浏览器使用 **WebKit**，这是谷歌的 Chrome 和苹果的 Safari
    浏览器所使用的相同技术。因此，网络应用程序开发的未来看起来更加光明，浏览器之间的限制更少。然而，问题在于，并非所有用户都更新了他们互联网浏览器的最新版本，这意味着向后兼容性仍然是必要的。
- en: polyfills
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: polyfills
- en: A solution to browser incompatibilities is to use polyfills. These are libraries
    that are created by third parties to bridge the gaps between browsers, ensuring
    the functionality they provide is matched. There are many polyfill libraries,
    each asserting a given list of features across a range of browsers and browser
    versions. The most popular of these polyfills is **Polyfill.io** ([https://polyfill.io/v3](https://polyfill.io/v3)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 解决浏览器兼容性问题的一个方法是使用 polyfills。这些是由第三方创建的库，用于弥合浏览器之间的差距，确保它们提供的功能与预期匹配。有许多 polyfill
    库，每个库都声称在一系列浏览器和浏览器版本中提供特定的功能列表。其中最受欢迎的 polyfills 是 **Polyfill.io** ([https://polyfill.io/v3](https://polyfill.io/v3)).
- en: Polyfill.io was created by the *Financial Times* to cover a broad range of discrepancies
    among browsers. It is an open-source library that can be configured to include
    just the features you require, or you can simply import everything. By including
    it in your project, you can smooth over the cracks in browser differences.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Polyfill.io 是由 *Financial Times* 创建的，用于覆盖浏览器之间广泛的不一致。它是一个开源库，可以配置为仅包含你需要的功能，或者你可以简单地导入所有内容。通过将其包含在你的项目中，你可以平滑处理浏览器差异。
- en: 'Including Polyfill.io in your application is as simple as adding it with a
    `script` tag:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中包含 Polyfill.io 与通过 `script` 标签添加它一样简单：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, to make full use of Polyfill.io, it is best to appropriately configure
    it to your needs using the `Create a Polyfill Bundle` page on the Polyfill.io
    website.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了充分利用 Polyfill.io，最好通过 Polyfill.io 网站的“创建 Polyfill 包”页面适当地配置它以满足你的需求。
- en: Transpilers
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转译器
- en: Transpilers are tools that convert one language into another. They are similar
    to compilers, except compilers typically convert a language into machine code
    or into intermediate byte code. There are many transpilers that convert a different
    language into JavaScript, but one of the most popular in web development is the
    **Babel transpiler**, which converts JavaScript into JavaScript. This may sound
    strange but imagine being able to utilize all of the latest features of JavaScript,
    then transpile it to work on all major browsers from the last 5 years, without
    having to utilize a polyfill library. This is essentially what Babel does.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 转译器是转换一种语言到另一种语言的工具。它们与编译器类似，但编译器通常将一种语言转换为机器代码或中间字节码。有许多转译器可以将不同的语言转换为 JavaScript，但其中在网页开发中最受欢迎的是
    **Babel 转译器**，它将 JavaScript 转换为 JavaScript。这听起来可能有些奇怪，但想象一下能够利用 JavaScript 的所有最新功能，然后将其转译为在过去
    5 年的所有主要浏览器上工作，而无需使用 polyfill 库。这正是 Babel 所做的。
- en: The Babel transpiler, as well as several other transpilers, will be discussed
    later in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 转译器以及本章后面将要讨论的几个其他转译器。
- en: Development Methodology Libraries
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发方法库
- en: 'An alternative to covering the cracks in browser differences is to utilize
    libraries that offer a uniform development methodology that is supported in older
    browsers. There are many libraries that provide an arsenal of functionality, thereby
    making it easier to code in a predefined, opinionated manner. Some of these include
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为覆盖浏览器差异裂缝的替代方案，可以利用提供统一开发方法且在旧浏览器中受支持的库。有许多库提供了一系列功能，从而使得以预定义、有见地的编程方式更容易。以下是一些这样的库：
- en: The **Underscore**, **Lodash**, **RxJS**, and **Ramda** functional programming
    libraries
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Underscore**、**Lodash**、**RxJS** 和 **Ramda** 函数式编程库'
- en: The **React**, **Polymer**, and **Riot** component-based UI libraries
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React**、**Polymer** 和 **Riot** 组件化 UI 库'
- en: The **Backbone** and **Knockout MVC** frameworks
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Backbone** 和 **Knockout MVC** 框架'
- en: The **jQuery** and **MooTools DOM** manipulation libraries
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jQuery** 和 **MooTools DOM** 操作库'
- en: Each of the preceding libraries may be used in tandem with each other and with
    a transpiler, so choosing your libraries can be an important step to getting the
    results you require. We will be looking at some useful libraries later in this
    chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前述每个库都可以与其他库和转译器一起使用，因此选择你的库可能是获得所需结果的重要步骤。我们将在本章后面查看一些有用的库。
- en: Package Managers
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理器
- en: Package managers are tools that provide managed support for your included libraries.
    These package managers may provide functionality that can be used in your production
    code, provide functionality externally to your application that helps test your
    code, or even provide tools you can use to make development easier but that is
    discarded from the eventual production code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器是提供对包含库的管理的支持的工具。这些包管理器可能提供可以在生产代码中使用的功能，提供对应用程序外部帮助测试代码的功能，或者甚至提供可以用来使开发更容易但最终从生产代码中丢弃的工具。
- en: When implementing a package manager, a manifest is kept that keeps track of
    each of the libraries that have been imported into your project, as well as their
    version numbers. This way, if you were to remove all of the libraries from your
    project, you could easily reinstall the libraries that were used instantly. This
    is very useful when storing your application source code in a source repository
    such as GitHub, as you only need to store your own code. Any libraries you have
    used in the past can be easily installed by other developers in your team using
    the package manifest, ensuring your source repository is streamlined.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现包管理器时，会保留一个清单，以跟踪项目中导入的每个库及其版本号。这样，如果你要从项目中移除所有库，你可以轻松地重新安装曾经使用的库。这在将应用程序源代码存储在源代码库（如
    GitHub）中非常有用，因为你只需要存储自己的代码。其他开发者可以通过包清单轻松安装你过去使用的任何库，从而确保源代码库的简洁。
- en: For many years, the most popular package manager that's been used by JavaScript
    developers has been Node Package Manager (npm). However, additional managers are
    available, with some gaining popularity, including Yarn.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 许多年来，JavaScript 开发者最常用的包管理器是节点包管理器（npm）。然而，还有其他管理器可用，其中一些正在获得人气，包括 Yarn。
- en: The Node Package Manager
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点包管理器
- en: 'The node package manager (npm) is automatically installed when you install
    Node.js. Therefore, if you followed along in *Chapter 9, Working with Node.js*,
    then you should already have it. To test for it, simply run the following in your
    Terminal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Node.js 时，节点包管理器（npm）会自动安装。因此，如果你跟随了第 9 章“使用 Node.js”的内容，那么你应该已经安装了它。要测试是否已安装，只需在你的终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will output version information if you do indeed have it installed on
    your system:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实在你的系统上安装了它，这将输出版本信息：
- en: '![Figure 12.1: npm version'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1：npm 版本](img/C14377_12_01.jpg)'
- en: '](img/C14377_12_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1：npm 版本](img/C14377_12_01.jpg)'
- en: 'Figure 12.1: npm version'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：npm 版本
- en: When using npm with a project, it creates a manifest file called `package.json`,
    which maintains a list of production and development libraries to be used with
    your project. Any installed packages are stored in a directory called `node_modules`,
    which npm also creates, and which lives in the root of your project. It is advisable
    to ensure that the `node_modules` directory is never stored in your project's
    source code repository, for streamlining purposes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用npm与项目一起使用时，它会创建一个名为`package.json`的清单文件，该文件维护了一个用于与项目一起使用的生产环境和开发库的列表。任何已安装的包都存储在一个名为`node_modules`的目录中，npm也会创建这个目录，并且它位于项目的根目录。出于简化目的，建议确保`node_modules`目录永远不会存储在你的项目源代码仓库中。
- en: 'To begin using npm, you simply navigate to your project directory using your
    Terminal and execute the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用npm，你只需使用终端导航到你的项目目录，并执行以下命令：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will prompt you to answer a number of questions. It''s okay if you don''t
    know what to put for these, and you can simply press the Enter key to skip them
    and use the provided default values if you wish:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示你回答一系列问题。如果你不知道要填什么，可以简单地按Enter键跳过它们，并使用提供的默认值。如果你愿意的话：
- en: '![Figure 12.2: npm initialization'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.2: npm initialization'
- en: '](img/C14377_12_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_12_02.jpg](img/C14377_12_02.jpg)'
- en: 'Figure 12.2: npm initialization'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：npm初始化
- en: Once completed, it will create a barebones `package.json` file containing the
    JSON code detailed in the preceding screenshot. Now, at this time, this JSON will
    not contain any modules, but that's fine. What it does and can contain is metadata
    about your project, such as its version, the initial index or starting script,
    and other such important information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，它将创建一个包含前述截图详细JSON代码的裸骨`package.json`文件。现在，在这个时候，这个JSON将不包含任何模块，但这没关系。它所做和可以包含的是关于你的项目的元数据，例如其版本、初始索引或启动脚本，以及其他此类重要信息。
- en: 'One of the predefined metadata properties is the `scripts` object. This is
    an important entry and one you will soon become familiar with. Each entry within
    this object is an executable command shortcut that you can invoke using the npm
    Terminal command. The one that''s provided initially doesn''t really do anything
    except output an error, but you can run it anyway if you wish so that you can
    see it in action. Do this by executing the following in the Terminal:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的元数据属性之一是`scripts`对象。这是一个重要的条目，你很快就会熟悉。该对象中的每个条目都是一个可执行的命令快捷方式，你可以使用npm终端命令调用它。最初提供的那个实际上并没有做什么，除了输出一个错误，但如果你愿意，你可以运行它以查看其效果。通过在终端中执行以下命令来实现：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the current JSON, this will simply output the following error:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前的JSON，这将简单地输出以下错误：
- en: '![Figure 12.3: Initial package.json output'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.3: Initial package.json output'
- en: '](img/C14377_12_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_12_03.jpg](img/C14377_12_03.jpg)'
- en: 'Figure 12.3: Initial package.json output'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：初始package.json输出
- en: The `scripts` section of the `package.json` file is extremely useful for implementing
    your own shortcut commands so that you can run common tasks. You will be utilizing
    this a lot later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件的`scripts`部分对于实现自己的快捷命令非常有用，这样你就可以运行常见任务。你将在本章的后面大量使用它。'
- en: Installing Modules
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装模块
- en: 'The key task of a package manager is to install modules. As we stated previously,
    there are two primary ways to install a module into your project. The first is
    to install it as a production-level module. This means it may be incorporated
    into your deployment scripts during a build phase:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器的关键任务是安装模块。正如我们之前所述，将模块安装到项目中有两种主要方式。第一种是将它作为生产级模块安装。这意味着它可以在构建阶段被整合到你的部署脚本中：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, to install it as a development module, you would simply execute
    the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要将其作为开发模块安装，你只需执行以下代码：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each installed module will be added to a list within the `package.json` file;
    either `dependencies` for production modules or `devDependencies` for development
    modules.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个已安装的模块都将添加到`package.json`文件中的一个列表中；对于生产模块是`dependencies`，对于开发模块是`devDependencies`。
- en: 'At any time, once your module list exists within the `package.json` file, you
    can install all the modules by simply invoking the following in the Terminal:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时间，一旦你的模块列表存在于`package.json`文件中，你只需在终端中调用以下命令即可安装所有模块：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If no `node_modules` folder exists in your project, this command will create
    it and proceed to download all the modules contained in both the `dependencies`
    and `devDependencies` lists.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目中不存在`node_modules`文件夹，这个命令将会创建它，并继续下载`dependencies`和`devDependencies`列表中包含的所有模块。
- en: The Yarn Package Manager
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Yarn 包管理器
- en: Yarn is a more recent addition to the available JavaScript package managers
    but is increasing in popularity. It was conceived by Facebook, in collaboration
    with Google, Tilde Inc., and Exponent Inc., and works as a different frontend
    to the npm repository. It was created primarily to provide a safer alternative
    to npm since the npm command-line tool can allow modules to run code upon installation,
    which can be a security risk.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn 是 JavaScript 包管理器中较新的补充，但正在变得越来越受欢迎。它由 Facebook 联合 Google、Tilde Inc. 和
    Exponent Inc. 共同构思，作为 npm 存储库的不同前端。它主要是为了提供一个比 npm 命令行工具更安全的替代品，因为 npm 命令行工具可以在安装模块时运行代码，这可能是一个安全风险。
- en: Whether you should use Yarn is simply a preference. The issues that are exposed
    by the Yarn project are likely to be patched by npm over time and may already
    be irrelevant. Since Yarn doesn't replace much in the npm ecosystem, there isn't
    a big requirement to use it over the **npm CLI**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否应该使用 Yarn 只是一个偏好问题。Yarn 项目暴露的问题可能会随着时间的推移由 npm 修复，并且可能已经不再相关。由于 Yarn 并没有在
    npm 生态系统中取代太多东西，因此没有很大必要在 **npm CLI** 之上使用它。
- en: The Babel Transpiler
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Babel 转译器
- en: Babel is a set of tools and libraries that transpiles JavaScript into JavaScript.
    Its benefit is that you can use cutting-edge JavaScript features today and still
    ensure that they run on a wide range of browsers and browser versions, all while
    ensuring minimally produced code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 是一套将 JavaScript 转译为 JavaScript 的工具和库。它的好处是您今天可以使用最前沿的 JavaScript 特性，同时确保它们在广泛的浏览器和浏览器版本上运行，同时确保生成的代码量最小。
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: When working on exceptionally small projects, it is still possible to create
    much shorter scripts than what's run on most browsers. Using Babel is mostly beneficial
    for medium-to-large projects, which many modern JavaScript applications tend to
    be. Therefore, if all you are doing is reading some values from a field or two
    and validating them using a handful of lines of JavaScript, then you may be better
    off skipping modules and transpilers altogether.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理特别小的项目时，仍然可以创建比大多数浏览器上运行的脚本更短的脚本。使用 Babel 主要对中等至大型项目有益，许多现代 JavaScript 应用程序往往属于这一类。因此，如果您只是从字段或两个字段中读取一些值，并使用几行
    JavaScript 验证它们，那么您可能最好完全跳过模块和转译器。
- en: 'A simple Babel installation provides three development-time tools and a polyfill
    library to be compiled into your application. These are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 Babel 安装提供了三个开发时工具和一个需要编译到您的应用程序中的 polyfill 库。具体如下：
- en: The Babel engine core
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel 引擎核心
- en: The Babel command-line interface
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel 命令行界面
- en: The Babel environment preset engine
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel 环境预设引擎
- en: The Babel/polyfill library
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel/polyfill 库
- en: Each of the Babel tools can be installed using the npm CLI and use package names
    that are prefixed with `@babel/`. This is known as the package scope or namespace
    and ensures that other packages in the npm repository do not conflict should they
    have the same name.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Babel 工具都可以使用 npm CLI 安装，并使用以 `@babel/` 前缀的包名。这被称为包作用域或命名空间，确保 npm 存储库中的其他包在名称相同的情况下不会发生冲突。
- en: '@babel/core'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@babel/core'
- en: The `@babel/core` tool provides the engine of the Babel transpiler. It contains
    functions that invoke the transformation of JavaScript code from one form to another,
    though the logic for various transformations may not be in the `@babel/core` package
    itself. All Babel installations must include the `@babel/core` package in order
    to function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`@babel/core` 工具提供了 Babel 转译器的引擎。它包含将 JavaScript 代码从一种形式转换为另一种形式的函数，尽管各种转换的逻辑可能不在
    `@babel/core` 包本身中。所有 Babel 安装都必须包含 `@babel/core` 包才能正常工作。'
- en: '@babel/cli'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@babel/cli'
- en: '`@babel/cli` provides command-line functionality for Babel projects. This can
    be used to invoke the transpilation of your source code, as well as to incorporate
    additional plugins and configuration. However, you will not typically use this
    CLI directly. Instead, you will create a new `scripts` entry and provide the configuration
    in a separate file.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`@babel/cli` 为 Babel 项目提供了命令行功能。这可以用来调用源代码的转译，以及包含额外的插件和配置。然而，您通常不会直接使用此 CLI。相反，您将创建一个新的
    `scripts` 条目，并在单独的文件中提供配置。'
- en: '@babel/preset-env'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@babel/preset-env'
- en: The `@babel/preset-env` tool provides intelligent directives for transpiling
    your code for specific environments, such as browser types and versions. Typically,
    the wider the range of environments you wish to support, the larger your resulting
    deployable transpiled code will be. The configuration for this tool will exist
    in a configuration file so that you only need to specify it once.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`@babel/preset-env`工具为针对特定环境（如浏览器类型和版本）转换您的代码提供了智能指令。通常，您希望支持的环境范围越广，您生成的可部署转换代码就越大。此工具的配置将存在于配置文件中，这样您就只需指定一次。'
- en: '@babel/polyfill'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@babel/polyfill'
- en: '`@babel/polyfill` is a library that is at least partly compiled into your deployable
    code. Through using `@babel/preset-env`, Babel selects elements from `@babel/polyfill`
    to include in the transpiled code.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`@babel/polyfill`是一个至少部分编译到您的可部署代码中的库。通过使用`@babel/preset-env`，Babel从`@babel/polyfill`中选择元素包含在转换代码中。'
- en: .babelrc Configuration File
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .babelrc配置文件
- en: The `.babelrc` file (note the period character at the start of the filename)
    is a JSON configuration file that sits in the root of your project directory.
    This file can store information about the presets, plugins, and various other
    bits of information that are useful for Babel's installation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`.babelrc`文件（注意文件名开头的点字符）是一个JSON配置文件，位于项目目录的根目录。此文件可以存储有关预设、插件以及各种其他对Babel安装有用的信息。'
- en: 'The most common configuration you will apply to this file will be the environments
    you wish to support:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您将应用到此文件的最常见的配置是您希望支持的环境：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example requests that Babel transpiles code to support browsers
    that are used globally by more than 0.25% of the population. Otherwise, those
    browsers are not considered dead, which means browsers that are still actively
    supported.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子要求Babel将代码转换为支持全球使用率超过0.25%的浏览器。否则，这些浏览器不被认为是已死亡的，这意味着仍然得到积极支持的浏览器。
- en: A full explanation of the environment queries that are supported by the `.babelrc`
    configuration file can be found at [https://packt.live/2NVxWwP](https://packt.live/2NVxWwP).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://packt.live/2NVxWwP](https://packt.live/2NVxWwP)找到`.babelrc`配置文件支持的完整环境查询说明。
- en: 'Exercise 12.01: A Basic Babel Project'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：一个基本的Babel项目
- en: 'In this exercise, you will create a usable install of the Babel transpiler
    using npm. This will be a simple setup that will result in a working environment
    that''s able to transpile a source modularized JavaScript application into a deployable
    repository of files. Let''s get started:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用npm创建一个可用的Babel转换器安装。这将是一个简单的设置，将产生一个能够将源模块化JavaScript应用转换为可部署文件库的工作环境。让我们开始吧：
- en: 'Begin by creating a new directory called `babel_app` in your operating system''s
    `Documents` folder using the Terminal. Then, navigate into that directory:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在操作系统的`Documents`文件夹中使用终端创建一个名为`babel_app`的新目录。然后，导航到该目录：
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, initialize the folder as an npm project. You can use all of the default
    settings for this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将文件夹初始化为npm项目。您可以为此使用所有默认设置：
- en: '[PRE9]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see something similar to the following output:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到以下类似的输出：
- en: '![Figure 12.4: npm initialization'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.4：npm初始化'
- en: '](img/C14377_12_04.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_12_04.jpg)'
- en: 'Figure 12.4: npm initialization'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.4：npm初始化
- en: 'Now that npm is set up, you can install the Babel development libraries. These
    will need to be saved in the `devDependencies` list:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在npm已经设置好了，您可以安装Babel的开发库。这些库需要保存在`devDependencies`列表中：
- en: '[PRE10]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will see some information pertaining to downloading the modules to the
    `node_modules` directory:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到一些与将模块下载到`node_modules`目录有关的信息：
- en: '![Figure 12.5: Development modules installed'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.5：已安装的开发模块'
- en: '](img/C14377_12_05.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_12_05.jpg)'
- en: 'Figure 12.5: Development modules installed'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.5：已安装的开发模块
- en: These files will not be compiled into your resulting transpiled application
    since they are used to perform the transpiling itself.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些文件不会被编译到您的结果转换应用中，因为它们用于执行转换本身。
- en: 'Now, you will need to install the Babel polyfill library. This library will
    be transpiled into your resulting application, as required by the transpiler:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要安装Babel polyfill库。此库将根据转换器的需求转换为您的结果应用：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Again, this module will be saved in the `node_modules` directory:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，这个模块将被保存在`node_modules`目录中：
- en: '![Figure 12.6: Polyfill module installation'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.6：Polyfill模块安装'
- en: '](img/C14377_12_06.jpg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_12_06.jpg)'
- en: 'Figure 12.6: Polyfill module installation'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.6：Polyfill模块安装
- en: 'With the modules installed, you will now need to configure Babel. This requires
    a new file called `.babelrc`, which will contain the appropriate JSON. There are
    many possible configurable features of Babel, but for this exercise, you will
    simply need to specify the environment presets. Create a new file called `.babelrc`
    in the root of the project directory and populate it with the following content:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了模块后，你现在需要配置Babel。这需要一个名为`.babelrc`的新文件，它将包含适当的JSON。Babel有许多可能的可配置功能，但在这个练习中，你只需要指定环境预设。在项目目录的根目录中创建一个名为`.babelrc`的新文件，并填充以下内容：
- en: '[PRE12]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With everything in place, you will now need to create your project work files
    and directories. You can layout your project however you like, but for this example,
    you''ll utilize two directories: an `src` directory for source files and a `dist`
    directory for transpiled files. Go ahead and create these in the root of the project
    directory:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备就绪后，你现在需要创建你的项目工作文件和目录。你可以按照你喜欢的任何方式布局你的项目，但在这个例子中，你将使用两个目录：一个`src`目录用于源文件，一个`dist`目录用于转换后的文件。请继续在项目目录的根目录中创建这些目录：
- en: '[PRE13]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, you''ll need a project file to transpile. In the `src` directory, add
    a file called `index.js` and add the following JavaScript:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要一个项目文件来进行转换。在`src`目录中，添加一个名为`index.js`的文件，并添加以下JavaScript代码：
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This JavaScript uses a little of the ES2015 specification, in the form of the
    fat arrow function. This means, when transpiled, you should see a difference between
    what is in the source file and what is in the transpiled file.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个JavaScript使用了一点点ES2015规范，以胖箭头函数的形式。这意味着在转换时，你应该在源文件和转换后的文件中看到差异。
- en: 'Now, in order to get everything working, you''ll need to modify the `package.json`
    file to include a script that executes the Babel transpiler. Go ahead and open
    that file up, and then add the following line to the `scripts` array:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了使一切正常工作，你需要修改`package.json`文件以包含一个执行Babel转换器的脚本。请打开该文件，然后在`scripts`数组中添加以下行：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This line means that when you run it, it will call the Babel CLI tool using
    the npm package runner and will pass it the `src` directory for input and the
    `dist` directory for output. Don''t forget to add a comma at the end of the previous
    line or your JSON will be invalid. Your `package.json` file should now look as
    follows:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码的意思是，当你运行它时，它将使用npm包运行器调用Babel CLI工具，并将`src`目录作为输入，将`dist`目录作为输出。别忘了在上一个行末添加逗号，否则你的JSON将是无效的。你的`package.json`文件现在应该看起来如下所示：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the version numbers next to each of the module entries. If your version
    numbers are different, don't panic. The steps that were used to install these
    modules ensured that the latest versions were downloaded. Any differences in your
    own file compared to the preceding code simply mean those modules have been updated
    since this chapter was written. However, everything should still work fine.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意每个模块条目旁边的版本号。如果你的版本号不同，不要慌张。安装这些模块所使用的步骤确保了下载了最新版本。你自己的文件与前面代码之间的任何差异仅仅意味着这些模块自从本章编写以来已经更新了。然而，一切应该仍然运行良好。
- en: 'Finally, it''s time to run the transpiler. To do this, simply call the script
    through the npm CLI tool:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候运行转换器了。为此，只需通过npm CLI工具调用脚本即可：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once executed, take a look at the `dist` directory. It should now also contain
    an `index.js` file. However, the contents of this file will differ slightly to
    the code you entered in the `index.js` file in the `src` directory:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行后，查看`dist`目录。它现在也应该包含一个`index.js`文件。然而，这个文件的內容将与你在`src`目录中的`index.js`文件中输入的代码略有不同：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the Babel transpiler stripped out the fat arrow function syntax
    and replaced it with a standard function definition. This is so that the transpiled
    code will work in the environments you specified in the `.babelrc` configuration
    file. Babel allows you to utilize any of the cutting-edge features you want to
    use while being comforted by the knowledge that your resulting transpiled application
    should work exactly where you need it to.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到Babel转换器移除了胖箭头函数语法，并用标准的函数定义替换了它。这样做是为了确保转换后的代码能在你在`.babelrc`配置文件中指定的环境中运行。Babel允许你使用任何你想要使用的尖端特性，同时安心地知道你的转换后的应用程序应该正好在你需要的地方运行。
- en: The basic setup we've described here provides a powerful starting point for
    even the largest of applications. Many professional JavaScript development companies
    use Babel to ensure code correctness, portability, and a flexible working environment
    that can be managed by teams of developers without having each developer stepping
    on the toes of another.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的基本设置为即使是最大的应用程序也提供了一个强大的起点。许多专业的 JavaScript 开发公司使用 Babel 来确保代码的正确性、可移植性和灵活的工作环境，这样开发团队可以管理，而不需要每个开发者互相干扰。
- en: While what you have accomplished is a great starting point for a robust, team-driven
    application, there is more that can be accomplished to improve this even further.
    We will look at some of these additional steps throughout the rest of this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你所取得的成果是一个健壮、团队驱动的应用的绝佳起点，但还有更多可以做到的来进一步提升这一点。我们将在本章的剩余部分探讨这些额外的步骤。
- en: Babel Applications with Parcel
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Parcel 的 Babel 应用程序
- en: 'npm works very well as a package manager, but its project management capabilities
    are limited. In the previous exercise, you set up a script in the npm `package.json`
    file that executed the Babel transpiler. The transpiler can translate JavaScript
    files one at a time and place the resulting translated files in the `dist` directory,
    but that''s about the extent of it. Often, your projects will have other requirements,
    such as the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: npm 作为包管理器工作得非常好，但其项目管理功能有限。在之前的练习中，你在 npm 的 `package.json` 文件中设置了一个脚本，该脚本执行了
    Babel 编译器。编译器可以一次翻译一个 JavaScript 文件，并将生成的翻译文件放置在 `dist` 目录中，但这只是其中的一部分。通常，你的项目会有其他要求，例如以下内容：
- en: Ensuring your files are combined into fewer resulting JavaScript files
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的文件合并成更少的JavaScript结果文件
- en: Defining hot modules (breaking the compiled output into smaller chunks with
    dynamic loading)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义热模块（将编译输出拆分成更小的块，以动态加载）
- en: Processing CSS files
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 CSS 文件
- en: Compressing images
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩图片
- en: Ensuring files aren't cached between builds
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保文件在构建之间不被缓存
- en: It is possible to write your own scripts to manage your projects and execute
    them from npm from a parent script, but this is a lot of repetitive work that
    has already been solved by others. **Parcel** is a solution to this.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写自己的脚本来管理你的项目，并从父脚本中通过 npm 执行它们，但这是一项大量重复性的工作，已经被其他人解决了。**Parcel** 是一个解决方案。
- en: What is Parcel?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Parcel？
- en: Parcel is considered a web application bundler. It is, essentially, a packaging
    module that performs the tasks that were listed in the previous section. What
    makes Parcel unique is that it is a zero-configuration bundler. You simply call
    it from your project directory, and it figures out how your application should
    be readied for distribution. The only requirement, then, is to call the Parcel
    CLI command to launch it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Parcel 被视为一个网络应用程序打包器。本质上，它是一个执行上一节中列出的任务的打包模块。使 Parcel 独特的是，它是一个零配置打包器。你只需从你的项目目录中调用它，它就会确定你的应用程序应该如何为分发做好准备。那么，唯一的要求就是调用
    Parcel CLI 命令来启动它。
- en: 'Parcel is typically installed in your project as a global module. This means
    it is not stored in the `node_modules` directory in your project folder, but in
    a `node_modules` directory that exists on your operating system''s environment
    path. To do this, instead of supplying a `--save` or `--save-dev` flag, you supply
    a `-g` flag, for global:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Parcel 通常作为全局模块安装在你的项目中。这意味着它不会存储在你的项目文件夹中的 `node_modules` 目录中，而是在你的操作系统环境路径上存在的
    `node_modules` 目录中。为此，你不需要提供 `--save` 或 `--save-dev` 标志，而是提供一个 `-g` 标志，用于全局：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since Parcel is globally installed, the installation will not modify the `package.json`
    file as it will not need to be added to the `dependencies` or `devDependencies`
    lists.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Parcel 是全局安装的，安装不会修改 `package.json` 文件，因为它不需要被添加到 `dependencies` 或 `devDependencies`
    列表中。
- en: Using Parcel
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Parcel
- en: 'To make use of Parcel, you will need to add new scripts to the `package.json
    scripts` object. There are several ways Parcel can be called. The first is simply
    to pass the main JavaScript file as the only parameter to the `parcel` CLI tool:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Parcel，你需要向 `package.json scripts` 对象中添加新的脚本。有多种方式可以调用 Parcel。第一种是简单地将主
    JavaScript 文件作为唯一参数传递给 `parcel` CLI 工具：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will request that Parcel processes the JavaScript file and for it to output
    a development build of it. Parcel traverses this file and determines whether any
    other files also need processing. During the processing phase, Parcel will also
    analyze any configuration files present within the project directory. The `.babelrc`
    configuration file is one such file Parcel understands. Therefore, by its very
    presence, Parcel will ensure that any JavaScript files are transpiled by Babel.
    The same will be true if common configuration files are present for other tools,
    but also with files of a given type within the source tree, such as HTML and CSS
    files:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将请求Parcel处理JavaScript文件，并输出其开发构建版本。Parcel遍历此文件，并确定是否有其他文件也需要处理。在处理阶段，Parcel还会分析项目目录中存在的任何配置文件。`.babelrc`配置文件就是Parcel理解的一种文件。因此，通过其存在，Parcel将确保任何JavaScript文件都通过Babel进行转换。如果存在其他工具的通用配置文件，或者源树中给定类型的文件（如HTML和CSS文件）也是如此，情况将相同：
- en: '![Figure 12.7: Parcel development build'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7：Parcel开发构建'
- en: '](img/C14377_12_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_12_07.jpg)'
- en: 'Figure 12.7: Parcel development build'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：Parcel开发构建
- en: When processing as a development build, Parcel includes additional code within
    the transpiled JavaScript. Additionally, a call to Parcel to process your files
    in development mode will not return. As you can see in the preceding screenshot,
    running Parcel in development mode launches a special development server, which
    you can navigate to by going to [http://localhost:1234](http://localhost:1234)
    in your web browser. This simply presents your transpiled application as though
    it were running on a remote webserver.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为开发构建处理时，Parcel会在转换后的JavaScript中包含额外的代码。此外，调用Parcel以开发模式处理你的文件将不会返回。正如你可以在前面的屏幕截图中所见，以开发模式运行Parcel会启动一个特殊的发展服务器，你可以通过在浏览器中访问[http://localhost:1234](http://localhost:1234)来导航到该服务器。这仅仅是将你的转换后的应用程序展示得好像它正在远程服务器上运行。
- en: The running service also utilizes a filesystem listener so that, when you update
    a file within your project, that file is then automatically reprocessed, and the
    resulting changes are made available immediately. If you then view your application
    within the browser at the time a file is changed, the browser will automatically
    be refreshed to include those changes. This feature greatly speeds up development
    time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的服务还利用文件系统监听器，以便当你更新项目中的文件时，该文件会自动重新处理，并且产生的更改会立即可用。如果你在文件更改时在浏览器中查看你的应用程序，浏览器会自动刷新以包含这些更改。这个特性大大加快了开发时间。
- en: 'Another way to invoke the parcel CLI tool is to provide the `build` flag:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调用parcel CLI工具的方法是提供`build`标志：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `build` flag tells Parcel to process the source files so that they''re
    ready for a production release. This version will not have the additional browser
    update code and there will be no development server running:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`标志告诉Parcel处理源文件，以便它们为生产发布做好准备。这个版本将不会包含额外的浏览器更新代码，并且不会有开发服务器在运行：'
- en: '![Figure 12.8: Parcel production build'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：Parcel生产构建'
- en: '](img/C14377_12_08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_12_08.jpg)'
- en: 'Figure 12.8: Parcel production build'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：Parcel生产构建
- en: When deploying your finished application to a production server, the development
    features are not necessary and simply add bloat to your code, so being able to
    compile your application without them is a necessary step.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当将你的完成的应用程序部署到生产服务器时，开发功能是不必要的，并且只是增加了代码的冗余，因此能够不使用它们编译应用程序是一个必要的步骤。
- en: Modular Applications in Parcel
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Parcel中的模块化应用程序
- en: Utilizing Parcel provides a lot of features for free. In *Chapter 9, Working
    with Node.js*, you saw how modules are acquired in a Node.js application. Transpiling
    with Babel and Parcel also provides module acquisition when using the `import`
    keyword.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Parcel提供了许多免费功能。在*第9章，使用Node.js*中，你看到了如何在Node.js应用程序中获取模块。使用Babel和Parcel进行转换时，使用`import`关键字也能获取模块。
- en: 'When building your applications, it is preferable to break the application
    source into smaller files so that managing your code is simpler. The `import`
    keyword follows the ES2015 specification, whereby each module in your source directory
    `exports` one or more functions, which can then be imported into other modules
    as required using the `import` keyword. If a module `exports` only one function,
    then it can be exported simply as a `default` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，最好将应用程序源代码拆分成更小的文件，这样管理代码会更简单。`import`关键字遵循ES2015规范，其中每个源目录中的模块`exports`一个或多个函数，然后可以使用`import`关键字将它们导入到其他模块中。如果一个模块`exports`只有一个函数，那么它可以简单地作为`default`函数导出：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In another module, this function can then be imported with a named reference,
    like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个模块中，此函数可以像这样通过命名引用导入：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how the `.js` extension was not required when naming the importing module,
    much like how Node.js imports modules. The transpiler automatically understands
    how to reference the external file using this format. When processing the `index.js`
    file, Parcel automatically traverses all imported files, transpiling those as
    well. Each module is followed, including their linked modules and so on. The resulting
    code is stored in a single JavaScript file in the `dist` directory.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在命名导入模块时不需要`.js`扩展名，这与Node.js导入模块的方式非常相似。转换器会自动理解如何使用此格式引用外部文件。当处理`index.js`文件时，Parcel会自动遍历所有导入的文件，并将它们一起转换。每个模块都会被跟踪，包括它们的链接模块等。生成的代码存储在`dist`目录下的单个JavaScript文件中。
- en: 'If a module contains multiple functions, then it can export them using an object
    format. This foregoes the `default` keyword as, now, functions must be cherry-picked
    using their specific names:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块包含多个函数，那么它可以使用对象格式导出它们。这省略了`default`关键字，因为现在必须使用特定的名称来挑选函数：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in the calling module, each required function must be named explicitly:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在调用模块中，每个必需的函数都必须明确命名：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using this method, only those functions you intend to use need to be imported.
    The transpiler will ensure that any dead functions (functions that are never called)
    are not transpiled needlessly into the resulting `dist` code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，只需要导入您打算使用的函数。转换器将确保任何未调用的函数（从未被调用的函数）不会无谓地转换到生成的`dist`代码中。
- en: 'Exercise 12.02: A Basic Parcel Project'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：一个基本的Parcel项目
- en: 'In this exercise, you will update the application you created in *Exercise
    12.01: A Basic Babel Project* to incorporate a Parcel build system. You will also
    include an additional module so that you can experience how simple modular application
    development can be. Let''s get started:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将更新在*练习12.01：一个基本的Babel项目*中创建的应用程序，以包含一个Parcel构建系统。您还将包含一个额外的模块，以便您可以体验模块化应用程序开发是多么简单。让我们开始吧：
- en: 'First, you will need to install the Parcel tools. If you have not already done
    so, install them globally:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要安装Parcel工具。如果您还没有这样做，请全局安装它们：
- en: '[PRE26]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you are on a Mac or Linux device and you receive an error stating that you
    have insufficient privileges, you will need to prepend the previous line with
    the `sudo` command:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在Mac或Linux设备上收到一个错误，表明您权限不足，您需要在上一行之前添加`sudo`命令：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, create a new file in the `src` directory and call it `index.html`. Then,
    add the following markup:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`src`目录中创建一个新文件，并将其命名为`index.html`。然后，添加以下标记：
- en: '[PRE28]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Parcel works by processing a file tree. By passing an HTML file as the master
    file, not only will JavaScript files be processed, but so will the HTML, CSS,
    and other such assets linked in your application.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Parcel通过处理文件树来工作。通过传递一个HTML文件作为主文件，不仅会处理JavaScript文件，还会处理应用程序中链接的HTML、CSS和其他此类资产。
- en: 'Now, update the `package.json` file to include the new `build` command scripts:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`package.json`文件以包含新的`build`命令脚本：
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `"build"` entry should replace the one we used previously, which called
    the Babel CLI directly. Your `package.json` file should now look as follows:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"build"`条目应替换我们之前使用的，它直接调用Babel CLI。您的`package.json`文件现在应如下所示：'
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, add a new module in `src` called `module.js`. This file will demonstrate
    the module loading in Parcel. In this file, add the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`src`目录中添加一个名为`module.js`的新模块。此文件将演示Parcel中的模块加载。在此文件中，添加以下代码：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, import that module into the `index.js` file by replacing its content with
    the following:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此模块导入到`index.js`文件中，方法是替换其内容为以下内容：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can now run your application in development mode by simply calling the
    following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以通过简单地调用以下命令来以开发模式运行您的应用程序：
- en: '[PRE33]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should then see the expected development server launch in the Terminal:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该然后在终端中看到预期的开发服务器启动：
- en: '![Figure 12.9: Running the development server'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.9：运行开发服务器'
- en: '](img/C14377_12_09.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_12_09.jpg)'
- en: 'Figure 12.9: Running the development server'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.9：运行开发服务器
- en: 'If you launch your browser with the console open, you will see the expected
    content:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在打开控制台的情况下启动浏览器，您将看到预期的内容：
- en: '![Figure 12.10: Console output'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.10：控制台输出'
- en: '](img/C14377_12_10.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_12_10.jpg)'
- en: 'Figure 12.10: Console output'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.10：控制台输出
- en: 'Finally, update `module.js` by adding additional value in the array. When you
    save the file, the browser should instantly refresh to show the latest changes:![Figure
    12.11: Updated console output'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在数组中添加额外的值来更新 `module.js`。当您保存文件时，浏览器应该立即刷新以显示最新的更改：![图 12.11：更新后的控制台输出
- en: '](img/C14377_12_11.jpg)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_12_11.jpg)'
- en: 'Figure 12.11: Updated console output'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.11：更新后的控制台输出
- en: 'If you view the source of the HTML page, you will see that the HTML doesn''t
    reference `index.js` as it does in the `src` directory. Instead, the JavaScript
    file will have a random name in order to prevent the browser from caching the
    file:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您查看 HTML 页面的源代码，您会发现 HTML 并没有像在 `src` 目录中那样引用 `index.js`。相反，JavaScript 文件将有一个随机名称，以防止浏览器缓存该文件：
- en: '[PRE34]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The setup we've created in this exercise is now a perfect starting point for
    many JavaScript projects. This simple build provides numerous development features
    that empower your coding and ensure optimal reliability in the production files.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中我们创建的设置现在是一个许多 JavaScript 项目的完美起点。这个简单的构建提供了许多开发功能，这些功能能够增强您的编码并确保生产文件的最佳可靠性。
- en: Babel Applications with Webpack
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Webpack 的 Babel 应用程序
- en: Webpack is an application bundler for JavaScript applications that provides
    a much more configurable experience. In version 4, the webpack team introduced
    zero-configuration support in order to compete with Parcel specifically. While
    webpack is an excellent tool for bundling your JavaScript and other assets, it
    does take quite a lot of configuring and requires just as much patience.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是一个用于 JavaScript 应用程序的应用程序打包器，它提供了一个更加可配置的体验。在版本 4 中，Webpack 团队引入了零配置支持，以特别与
    Parcel 竞争。虽然 Webpack 是一个打包您的 JavaScript 和其他资源的优秀工具，但它确实需要相当多的配置，并且需要同样的耐心。
- en: 'To use a webpack, you simply install it, just like any JavaScript module. Webpack
    comes in two main parts: the webpack engine and the webpack CLI. Both can be installed
    simultaneously, like so:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Webpack，您只需像安装任何 JavaScript 模块一样安装它。Webpack 主要由两部分组成：Webpack 引擎和 Webpack
    CLI。这两个可以同时安装，如下所示：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you install it using your Terminal, you should see the following output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用终端安装它，您应该看到以下输出：
- en: '![Figure 12.12: Webpack installation'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.12：Webpack 安装'
- en: '](img/C14377_12_12.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_12_12.jpg)'
- en: 'Figure 12.12: Webpack installation'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12：Webpack 安装
- en: 'With those downloaded, you can then add a script in the `package.json` file
    in order to execute them, like so:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下载这些文件后，您可以在 `package.json` 文件中添加一个脚本来执行它们，如下所示：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, by running the script in the Terminal, it should compile your JavaScript:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在终端中运行脚本，它应该编译您的 JavaScript：
- en: '![Figure 12.13: Executing Webpack zero configuration'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13：执行 Webpack 零配置'
- en: '](img/C14377_12_13.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_12_13.jpg)'
- en: 'Figure 12.13: Executing Webpack zero configuration'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13：执行 Webpack 零配置
- en: As you can see, in the preceding screenshot, both the `index.js` and `module.js`
    files were compiled into a file called `main.js`. Webpack defaults its entry point
    path to `src/index.js` and its output path to `dist/main.js`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在前面的屏幕截图中，`index.js` 和 `module.js` 文件都被编译成了一个名为 `main.js` 的文件。Webpack 默认将其入口点路径设置为
    `src/index.js`，输出路径设置为 `dist/main.js`。
- en: 'Let''s supply a source file and output file explicitly so as to try and mimic
    the Parcel build. Update your `wp` script to the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确指定源文件和输出文件，以尝试模拟 Parcel 构建。将您的 `wp` 脚本更新如下：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will set the input source as the `index.html` file and request the output
    to be placed in the `dist` directory, but with the same filename. If you run this,
    you should see something like the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置输入源为 `index.html` 文件，并请求输出放置在 `dist` 目录中，但使用相同的文件名。如果您运行此命令，您应该看到以下内容：
- en: '![Figure 12.14: Webpack HTML parse error'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.14：Webpack HTML 解析错误'
- en: '](img/C14377_12_14.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_12_14.jpg)'
- en: 'Figure 12.14: Webpack HTML parse error'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14：Webpack HTML 解析错误
- en: As you can see, the webpack wasn't too happy about finding an HTML file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Webpack 对找到 HTML 文件并不太高兴。
- en: Now, a caveat with a webpack is that it does not try to be intelligent. The
    compiled output of the previous execution would not have transpiled your code
    using Babel, so the fat arrow functions from the source files will have made it
    to the output folder. Also, webpack in zero-configuration mode will only compile
    your JavaScript, meaning any other assets included in your application require
    some configuration in order for them to be processed and sent to the `dist` directory,
    including any HTML files.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于 webpack 的一个注意事项是它并不试图变得智能。前一次执行的编译输出不会使用 Babel 对您的代码进行转换，因此源文件中的箭头函数将进入输出文件夹。此外，零配置模式的
    webpack 只会编译您的 JavaScript，这意味着任何包含在您的应用程序中的其他资产都需要一些配置才能被处理并发送到 `dist` 目录，包括任何
    HTML 文件。
- en: Webpack Architecture
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack 架构
- en: 'Webpack provides a linear processing pipeline for your applications. Using
    a source input file, it will build a dependency tree, known as a dependency graph,
    and will process each file where configuration exists for that file type. The
    pipeline utilizes the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 为您的应用程序提供了一个线性处理管道。使用源输入文件，它将构建一个依赖树，称为依赖图，并将处理配置了该文件类型的每个文件。该管道利用以下内容：
- en: Source input file or entry point
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源输入文件或入口点
- en: Output file
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出文件
- en: Loader modules
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载器模块
- en: Plugin modules
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件模块
- en: Webpack requires a specific configuration for each of the asset types in your
    application so that it knows how to process them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 需要对您的应用程序中的每种资产类型进行特定的配置，以便它知道如何处理它们。
- en: Webpack Loaders and Plugins
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack 加载器和插件
- en: Both **loaders** and **plugins** are modules of code that you include in a webpack
    pipeline. They can be considered the bolt-on functionality since webpack is a
    pipeline, they are like its "fixtures and fittings." Loaders and plugins both
    have an effect on how your application is processed by webpack, but they are also
    quite different from one another.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载器**和**插件**都是您在 webpack 管道中包含的代码模块。它们可以被认为是附加功能，因为 webpack 是一个管道，它们就像是它的“配件和附件。”加载器和插件都会影响
    webpack 如何处理您的应用程序，但它们之间也相当不同。'
- en: A loader is a module that works at the beginning of the webpack pipeline; sometimes
    even before it starts. These modules process assets individually. For instance,
    if you wanted to use Babel in a webpack configuration, you would need to include
    the babel-webpack loader, which transpiles each file individually as they are
    processed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器是一个在 webpack 管道开始时工作的模块；有时甚至在它开始之前。这些模块单独处理资产。例如，如果您想在 webpack 配置中使用 Babel，您需要包含
    babel-webpack 加载器，该加载器会逐个转换正在处理的每个文件。
- en: Plugins, on the other hand, tend to work at the end of the webpack pipeline.
    These modules affect the entire output bundle and allow you to have much greater
    control over your application output. Plugins are quite a bit more complex than
    loaders, and their configuration often reflects this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，插件通常在 webpack 管道的末端工作。这些模块影响整个输出包，并允许您对应用程序输出有更大的控制权。插件比加载器复杂得多，它们的配置通常反映了这一点。
- en: Webpack Configuration
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack 配置
- en: The configuration of a webpack pipeline is added to a file called `webpack.config.js`,
    which exists in the root of your project directory. As a JavaScript file, it is
    executed by the Node.js runtime and can, therefore, include Node.js-compatible
    JavaScript.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 管道的配置被添加到一个名为 `webpack.config.js` 的文件中，该文件位于您的项目目录的根目录中。作为一个 JavaScript
    文件，它由 Node.js 运行时执行，因此可以包含兼容 Node.js 的 JavaScript。
- en: The webpack configuration is exported from the `webpack.config.js` file, much
    like any JavaScript module. The exported data can include information about the
    entry point path, destination path, loaders, and plugins, as is required.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 配置是从 `webpack.config.js` 文件导出的，就像任何 JavaScript 模块一样。导出的数据可以包括有关入口点路径、目标路径、加载器和插件的信息，如所需。
- en: 'As an example, a simple `webpack.config.js` file, which specifies the entry
    point and output paths, may look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个简单的 `webpack.config.js` 文件，它指定了入口点和输出路径，可能看起来像这样：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you create a `webpack.config.js` file, be sure to reset your `package.json`
    script so that it is like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了一个 `webpack.config.js` 文件，请确保重置您的 `package.json` 脚本，使其如下所示：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Failing to do so may cause confusing results.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，可能会导致结果混乱。
- en: 'Exercise 12.03: A Basic WebPack Project'
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.03：一个基本的 WebPack 项目
- en: 'In this exercise, you will set up your webpack installation so that it implements
    Babel transpiling and so that it includes and processes your `index.html` source
    file. As we stated previously, there are many configuration features you can apply
    to a webpack installation, but by completing this exercise, you will have a better
    understanding of how to implement any loaders you require. Let''s get started:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将设置你的webpack安装，使其实现Babel转译，并且包含并处理你的`index.html`源文件。正如我们之前所述，你可以为webpack安装应用许多配置功能，但通过完成这个练习，你将更好地理解如何实现所需的任何加载器。让我们开始吧：
- en: 'Although your application includes the Babel transpiler in the `package.json`
    file, it is not enough for a webpack to be able to understand how and when to
    use it. To utilize Babel with webpack, you need to include and configure the `Babel
    loader module`. Run the following in your Terminal to download and install the
    Babel loader:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然你的应用程序在`package.json`文件中包含了Babel转译器，但这对于webpack理解如何以及何时使用它来说是不够的。要利用webpack与Babel，你需要包含并配置`Babel
    loader module`。在你的终端中运行以下命令以下载和安装Babel加载器：
- en: '[PRE40]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, open up the `webpack.config.js` file, if you have it, and add a new `module`
    section to the `exports` object. If you don''t have the `webpack.config.js` file
    yet, create it now and add the code from the previous section:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果你有`webpack.config.js`文件，请打开它，并在`exports`对象中添加一个新的`module`部分。如果你还没有`webpack.config.js`文件，现在创建它并添加上一节中的代码：
- en: '[PRE41]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This new block provides the rule we can use to process files with Babel. Essentially,
    it''s saying "test: for filenames that end with `.js`, exclude: any files in the
    `node_modules` folder, use: `babel-loader` on those files you find."'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新块提供了我们可以用来处理文件的Babel规则。本质上，它是在说“test：对于以`.js`结尾的文件名，exclude：排除`node_modules`文件夹中的任何文件，use：对找到的这些文件使用`babel-loader`。”
- en: 'With Babel transpilation supported, you now need to include support for HTML
    files. HTML processing is both a pre- and post-JavaScript processing task and,
    therefore, is carried out using both a loader and a plugin. To install both of
    these, run the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在支持Babel转译后，你现在需要包含对HTML文件的支持。HTML处理既是JavaScript处理的前置任务也是后置任务，因此它使用加载器和插件来完成。要安装这两个，运行以下代码：
- en: '[PRE42]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If all went well, you should see the following output:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到以下输出：
- en: '![Figure 12.15: Webpack HTML loader and plugin installation'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.15：Webpack HTML加载器和插件安装'
- en: '](img/C14377_12_15.jpg)'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14377_12_15.jpg](img/C14377_12_15.jpg)'
- en: 'Figure 12.15: Webpack HTML loader and plugin installation'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.15：Webpack HTML加载器和插件安装
- en: 'With these modules installed, they now need to be configured in the `webpack.config.js`
    file. Like the Babel loader, the HTML loader should be entered into the `modules`
    array of the `exports` object. Add it after the `babel-loader` configuration:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了这些模块后，现在需要在`webpack.config.js`文件中进行配置。与Babel加载器一样，HTML加载器应该被添加到`exports`对象的`modules`数组中。在`babel-loader`配置之后添加它：
- en: '[PRE43]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implementing the HTML plugin requires a couple of steps. First, you will need
    to require it at the top of the page:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现HTML插件需要几个步骤。首先，你需要在页面顶部引入它：
- en: '[PRE44]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With the module required, you can now configure it by adding it to the `plugins`
    section of the `exports` object:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要模块后，你可以通过将其添加到`exports`对象的`plugins`部分来配置它：
- en: '[PRE45]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that the directory of the output file is not required. The HTML plugin
    will place it in the `dist` folder, regardless.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，输出文件的目录不是必需的。HTML插件将把它放在`dist`文件夹中，不管怎样。
- en: 'Your `webpack.config.js` file should now look as follows:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的`webpack.config.js`文件现在应该如下所示：
- en: '[PRE46]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, execute your webpack script. You should now find that the JavaScript
    output has been correctly transpiled by Babel and that the `index.html` file will
    also be present within the `dist` directory. Your Terminal window should look
    as follows:![Figure 12.16: Successful webpack transpilation'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行你的webpack脚本。你现在应该会发现JavaScript输出已经被Babel正确转译，并且`index.html`文件也将出现在`dist`目录中。你的终端窗口应该如下所示：![图12.16：成功的webpack转译
- en: '](img/C14377_12_16.jpg)'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14377_12_16.jpg](img/C14377_12_16.jpg)'
- en: 'Figure 12.16: Successful webpack transpilation'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：成功的webpack转译
- en: Configuring webpack installations can be quite a lengthy process of trial and
    error. Even with this exercise, you may notice that the `index.html` file still
    does not implement a non-caching process whereby the JavaScript output is renamed
    randomly to avoid browser caching. While webpack is a must for medium-to-large
    projects that require that extra mile in configuration freedom, it is recommended
    that Parcel is used for those small projects that need a simple setup, without
    configuration headaches.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 webpack 安装可能是一个相当长的试错过程。即使进行这个练习，你也可能注意到 `index.html` 文件仍然没有实现一个非缓存过程，即 JavaScript
    输出被随机重命名以避免浏览器缓存。虽然 webpack 对于需要额外配置自由度的中到大项目是必需的，但对于那些需要简单设置且没有配置头痛的小项目，建议使用
    Parcel。
- en: Other Popular Bundlers
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他流行打包器
- en: There are many bundler tools available for your JavaScript project, each with
    their own benefits and caveats. Obviously, choosing a bundler may result from
    personal choice or it may be a requirement from the project manager, development
    team, or the organization that tendered the project. However, of those bundlers,
    two of the most popular tools that haven't been covered in this chapter yet are
    Gulp and Grunt.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的 JavaScript 项目，有许多打包器工具可供选择，每个都有自己的优点和缺点。显然，选择打包器可能源于个人选择，也可能是项目经理、开发团队或投标项目的组织的要求。然而，在这些打包器中，尚未在本章中介绍的两个最受欢迎的工具是
    Gulp 和 Grunt。
- en: '**Gulp** and **Grunt** are a little different from the examples you''ve seen
    up until now as they don''t use configuration files. Instead, they use JavaScript
    code that you write to accomplish tasks similar to what webpack and Parcel can
    accomplish.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gulp** 和 **Grunt** 与你之前看到的示例略有不同，因为它们不使用配置文件。相反，它们使用你编写的 JavaScript 代码来完成类似于
    webpack 和 Parcel 可以完成的任务。'
- en: Gulp and Grunt are known as task runners. This means that, instead of defining
    a coding environment for your project, they act as an application you write to
    manage the application you're writing; a kind of application wrapper, if you will.
    The toolsets for both these bundlers provide a framework to facilitate this, which
    runs on the Node.js runtime. You simply code what you would like to achieve and
    execute it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 和 Grunt 被称为任务运行器。这意味着，你不需要为你的项目定义一个编码环境，它们充当一个你编写的应用程序来管理你正在编写的应用程序；如果你愿意，可以将其视为一种应用程序包装器。这两个打包器的工具集提供了一个框架来简化这个过程，它运行在
    Node.js 运行时上。你只需编写你想要实现的功能并执行它。
- en: 'The `gulp` bundler which runs on the Node.js runtime is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 运行时运行的 `gulp` 打包器如下：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `grunt` bundler which runs on the Node.js runtime is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 运行时运行的 `grunt` 打包器如下：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Other Language Transpiling
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他语言转译
- en: 'The JavaScript platform is an extremely popular one. After all, it is the de
    facto script runtime for the majority of browsers. However, the JavaScript language
    isn''t necessarily loved by everyone. Some developers prefer a static typing system,
    while others prefer better interoperability with their favorite server-side language.
    Whatever the reason, this love/hate relationship, mixed with JavaScript''s monopoly
    of the browser itself, has created a long list of alternative languages that each
    transpile to JavaScript. Some of the more popular of these languages include the
    following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 平台是一个非常流行的平台。毕竟，它是大多数浏览器的事实上的脚本运行时。然而，JavaScript 语言并不一定受到每个人的喜爱。一些开发者更喜欢静态类型系统，而另一些则更喜欢与他们的首选服务器端语言有更好的互操作性。无论原因如何，这种爱恨交加的关系，加上
    JavaScript 对浏览器本身的垄断，创造了一长串将转换为 JavaScript 的替代语言。其中一些更流行的语言包括以下内容：
- en: TypeScript
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript
- en: Dart
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dart
- en: CoffeeScript
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoffeeScript
- en: Elm
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm
- en: ClojureScript
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ClojureScript
- en: Haxe
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haxe
- en: Nim
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nim
- en: PureScript
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PureScript
- en: Of course, the list is much longer than this, but the preceding list does highlight
    some of the more popular alternatives, each of which has its own set of benefits
    and drawbacks.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个列表比这要长得多，但前面的列表确实突出了其中一些更受欢迎的替代品，每个都有其自身的优点和缺点。
- en: The TypeScript Language
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 语言
- en: '**TypeScript** is an interesting and important alternative to the JavaScript
    language. A superset of the JavaScript language, TypeScript was developed by Microsoft
    and was released sometime in 2014\. It is very similar to JavaScript but has a
    feature that is very important to some: strict typing with type inference.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript** 是 JavaScript 语言的有趣且重要的替代品。作为 JavaScript 语言的超集，TypeScript 由微软开发，并于
    2014 年左右发布。它与 JavaScript 非常相似，但有一个对某些人来说非常重要的特性：严格的类型推断。'
- en: Strict typing is where a variable has a fixed type. This may be a number, a
    string, or a Boolean. By being strictly typed, a variable is unable to contain
    a value of any other type. This prevents a number of bugs in your system.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 严格类型是变量具有固定类型的情况。这可能是一个数字、一个字符串或一个布尔值。通过严格类型，变量无法包含任何其他类型的值。这可以防止系统中出现许多错误。
- en: Let's look at a JavaScript problem.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 JavaScript 问题。
- en: 'A developer builds a function that accepts two numbers and adds them together:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者构建了一个接受两个数字并将它们相加的函数：
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, the developer has thought to check the parameters, first, that both `a`
    and `b` are provided, and then that the two values can be added together. However,
    as you saw in *Chapter 5, Beyond the Fundamentals*, the addition operator is overloaded,
    so if a string is passed, it will be concatenated into a new string:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开发者已经想到了检查参数，首先检查 `a` 和 `b` 是否都提供了，然后检查这两个值是否可以相加。然而，正如你在 *第五章，超越基础* 中看到的，加法操作符是重载的，所以如果传递了一个字符串，它将被连接成一个新的字符串：
- en: '[PRE50]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While this is fine if the developer expected the outcome, it does raise potential
    hazards that could be missed by even seasoned developers. Such bugs are problematic
    because they do not resolve in an error at the source, but rather further in the
    application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果开发者预期这样的结果，这是可以的，但它确实提出了可能被甚至经验丰富的开发者忽视的潜在风险。这样的错误是有问题的，因为它们不会在源代码中产生错误，而是在应用程序的更深处。
- en: 'TypeScript''s static typing could easily solve this issue by ensuring the values
    that are passed to the function are of a specific type:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的静态类型可以通过确保传递给函数的值是特定类型来轻松解决这个问题：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'All types are checked at compile time. In the preceding example, checking the
    content of the type is not necessary as the compiler will ensure that the function
    is called with the correct number of arguments. If an argument were optional,
    then it could be marked as such with the `?` operator:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型都在编译时进行检查。在上面的例子中，检查类型内容不是必要的，因为编译器将确保函数以正确的参数数量被调用。如果某个参数是可选的，则可以使用 `?`
    操作符将其标记为可选：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Such optional parameters must always appear at the tail end of the arguments
    list.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的可选参数必须始终出现在参数列表的末尾。
- en: Of course, specifying the types of your variables is not required—the compiler
    will infer them. This means that based on the first value the variable contains,
    the compiler will then expect it to always contain a value of that type. Function
    arguments can still contain any type if you wish them to.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，指定变量的类型不是必需的——编译器会推断它们。这意味着根据变量包含的第一个值，编译器会期望它始终包含该类型的值。如果你希望函数参数包含任何类型，它们仍然可以包含任何类型。
- en: 'Exercise 12.04: A Basic TypeScript Project'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.04：一个基本的 TypeScript 项目
- en: 'TypeScript is a major player in the professional JavaScript world, so understanding
    how to set up a TypeScript project is an important skill. In this exercise, you
    will create a minimal webpack project by utilizing the TypeScript transpiler.
    Let''s get started:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是专业 JavaScript 世界中的主要参与者，因此了解如何设置 TypeScript 项目是一个重要的技能。在这个练习中，你将通过使用
    TypeScript 编译器创建一个最小的 webpack 项目。让我们开始吧：
- en: 'Create a new directory and initialize it with a webpack installation, as per
    *Exercise 12.03: A Basic Webpack Project*.'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录，并按照 *练习 12.03：一个基本的 Webpack 项目* 的说明初始化它。
- en: 'Next, install the TypeScript libraries from npm. These libraries will be saved
    as `devDependencies`, since TypeScript is not required by your project after transpiling:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从 npm 安装 TypeScript 库。这些库将被保存为 `devDependencies`，因为 TypeScript 在编译后不是你的项目所必需的：
- en: '[PRE53]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`ts-loader` is a webpack loader module since webpack doesn''t know about or
    understand `*.ts` files out of the box.'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ts-loader` 是一个 webpack 加载模块，因为 webpack 默认不知道或理解 `*.ts` 文件。'
- en: 'The TypeScript transpiler utilizes configuration from a unique document in
    the root of your project called `tsconfig.json`. The possible values for this
    document are extensive, but for a simple project, simply enter the following:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeScript 编译器利用项目根目录中一个名为 `tsconfig.json` 的独特文档中的配置。这个文档的可能值非常广泛，但对于一个简单的项目，只需输入以下内容：
- en: '[PRE54]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open the `webpack.config.js` file and add the following rule to the `rules`
    list:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `webpack.config.js` 文件，并在 `rules` 列表中添加以下规则：
- en: '[PRE55]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Update the entry filename from `index.js` to `index.ts`. Your entire `webpack.config.js`
    file should now look as follows:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将入口文件名从 `index.js` 更改为 `index.ts`。现在，你的整个 `webpack.config.js` 文件应该如下所示：
- en: '[PRE56]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, provide an `index.ts` file within the `src` directory and add the following
    content:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `src` 目录中提供一个 `index.ts` 文件，并添加以下内容：
- en: '[PRE57]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can now compile the application with the following code:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以使用以下代码编译应用程序：
- en: '[PRE58]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should now see a successful compilation output, as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到一个成功的编译输出，如下所示：
- en: '![Figure 12.17: TypeScript with webpack'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17：使用webpack的TypeScript]'
- en: '](img/C14377_12_17.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片链接](img/C14377_12_17.jpg)'
- en: 'Figure 12.17: TypeScript with webpack'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：使用webpack的TypeScript
- en: What you have just created is boilerplate for any kind of TypeScript application.
    Creating a webpack and TypeScript project may be something you do time and time
    again for many of your future projects.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建的是任何类型TypeScript应用程序的样板代码。创建webpack和TypeScript项目可能是您在许多未来的项目中反复进行的事情。
- en: Elm and ClojureScript
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Elm和ClojureScript
- en: Both `null` and `undefined` values completely.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`和`undefined`值完全支持。'
- en: The intention of these languages is to empower the developer by outputting better
    code, but also improving the developer's coding ability. By thinking declaratively
    and functionally, problems can be solved more quickly and with better results.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言的目的在于通过输出更好的代码，同时提高开发者的编码能力。通过声明性和函数性思考，可以更快地解决问题并获得更好的结果。
- en: Haxe
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Haxe
- en: 'Haxe approaches JavaScript from a different angle. It was created as a unified
    language that could compile on many platforms, including the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Haxe从不同的角度接近JavaScript。它被创建为一个可以在许多平台（包括以下）上编译的统一语言：
- en: Flash ActionScript 3
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flash ActionScript 3
- en: C++
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C# (.NET)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# (.NET)
- en: Java
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Neko (a small, native cross-platform virtual machine)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neko（一个小型、本地的跨平台虚拟机）
- en: HashLink (an even faster, more portable cross-platform virtual machine)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashLink（一个更快、更便携的跨平台虚拟机）
- en: PHP
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Python
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Lua
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lua
- en: The platforms that are supported are continually increasing thanks to an enthusiastic
    community.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于热情的社区，支持的平台不断增多。
- en: By compiling on many platforms, the source code of a Haxe application has the
    benefit of being potentially portable between those platforms. This means you
    could write a Haxe application for a JavaScript client, but also use much of the
    same code in a C# server application.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在许多平台上编译，Haxe应用程序的源代码具有在这些平台之间可能可移植的好处。这意味着您可以为JavaScript客户端编写Haxe应用程序，同时也可以在C#服务器应用程序中使用大量相同的代码。
- en: Code Support Libraries
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码支持库
- en: Throughout its relatively long life, JavaScript has acquired a number of popular
    and useful libraries to aid engineers with their application development. Some
    of these libraries simply provide useful and reusable functions that reduce code
    complexity, while others offer extensive opinionated frameworks. Everything from
    user interfaces to database management is covered, with many overlapping libraries
    providing something a little different than competing libraries.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在其相对较长的生命周期中，JavaScript获得了一些流行的和有用的库，以帮助工程师进行应用程序开发。其中一些库仅提供有用的和可重用的函数，以减少代码复杂性，而其他则提供广泛的具有意见的框架。从用户界面到数据库管理，涵盖了所有内容，许多重叠的库提供了与竞争库略有不同的东西。
- en: jQuery
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery
- en: jQuery is one of the oldest running utility libraries available. Functioning
    as a general-purpose tool, jQuery empowered developers with a simple means to
    manipulate the browser's Document Object Model (DOM), perform animations, send
    Asynchronous JavaScript and XML (AJAX) requests, manage events, and more.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是可用的最古老的运行实用库之一。作为一个通用工具，jQuery通过提供一种简单的方式来操纵浏览器的文档对象模型（DOM）、执行动画、发送异步JavaScript和XML（AJAX）请求、管理事件等，赋予了开发者权力。
- en: Before jQuery was first released, finding and acquiring nodes within a web page
    was a laborious task, as was handling data and events from UI controls. The inception
    of jQuery alleviated a lot of the issues of earlier browsers, specifically with
    regard to cross-browser differences.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在jQuery首次发布之前，在网页中查找和获取节点是一项费力的任务，同样处理来自UI控件的数据和事件也是如此。jQuery的诞生缓解了早期浏览器中的许多问题，特别是在跨浏览器差异方面。
- en: These days, much of the functionality provided by jQuery is now present in modern
    browsers, but the library itself is still a popular choice for many seeking a
    more uniform means to manage client-side application development.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，jQuery提供的许多功能现在在现代浏览器中都有，但该库本身仍然是许多寻求更统一方式来管理客户端应用程序开发的流行选择。
- en: 'jQuery provides a singular global reference object that can be accessed in
    two ways:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了一个单一的全球引用对象，可以通过两种方式访问：
- en: '[PRE59]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: jQuery's ubiquity means that you're likely to see the solitary `$` symbol used
    throughout the internet and, indeed, very few libraries adopt this simple sigil,
    which is a valid variable symbol, for that reason.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的普及意味着你很可能会在互联网上看到单独的`$`符号被使用，实际上，很少有库采用这个简单的符号，因为它是一个有效的变量符号。
- en: The jQuery library has been covered somewhat in previous chapters, so no further
    information will be provided here.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery库在前面的章节中已有一定程度的介绍，因此这里不再提供更多信息。
- en: Underscore, Lodash, and Ramda
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Underscore、Lodash和Ramda
- en: Functional programming is becoming ever more important, with the benefits being
    realized in many different languages and platforms. While we can program in JavaScript
    functionally, it still does lack many features of more mature functional languages.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程正变得越来越重要，其好处在许多不同的语言和平台上得到体现。虽然我们可以在JavaScript中以函数式编程，但它仍然缺乏更成熟函数式语言的一些特性。
- en: To overcome this shortcoming, the JavaScript community has provided numerous
    functional-oriented libraries, with the most popular being Underscore, Lodash,
    and Ramda.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一缺点，JavaScript社区提供了许多以函数式为导向的库，其中最受欢迎的是Underscore、Lodash和Ramda。
- en: 'Underscore and Lodash are named thus due to their use of the `_` symbol. Just
    like jQuery''s `$` symbol, the `_` symbol provides the single access point for
    either of these libraries. Both libraries provide a means to assign the primary
    object to a variable of a different name if there is a likelihood of a clash of
    library namespaces in an application, but since Underscore and Lodash provide
    much of the same functionality, it is not common to see both in use at the same
    time. The Ramda library uses the capital letter `R` as its library accessor:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore和Lodash之所以被命名为这样，是因为它们使用了`_`符号。就像jQuery的`$`符号一样，`_`符号为这两个库提供了一个单一的访问点。这两个库都提供了一种方法，如果应用程序中存在库命名空间冲突的可能性，可以将主要对象分配给不同名称的变量，但由于Underscore和Lodash提供了许多相同的功能，因此同时使用这两个库并不常见。Ramda库使用大写字母`R`作为其库访问器：
- en: '[PRE60]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: While each of these libraries provides a number of overlapping features, there
    are some functionalities that are unique to a library among the three. For instance,
    the Ramda library provides lensing functionality, which is a means to operate
    on subsets of a collection of data that match the given criteria.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三个库都提供了一些重叠的功能，但其中一些功能是这三个库中独有的。例如，Ramda库提供了lensing功能，这是一种在满足给定标准的数据集合子集上操作的手段。
- en: Client Frameworks Overview
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端框架概述
- en: Recent years have seen an explosion in powerful JavaScript application frameworks.
    Many of these provide interesting ways to greatly simplify single-page application
    (SPA) development, as well as modular, dynamically loaded applications. While
    frameworks have long been an important requirement for reducing development complexity,
    supporting engineering teams, and facilitating common use cases with minimal fuss,
    modern frameworks often take things to a whole new level.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，强大的JavaScript应用程序框架数量激增。许多框架提供了简化单页应用程序（SPA）开发以及模块化、动态加载应用程序的有趣方法。虽然框架长期以来一直是降低开发复杂性、支持工程团队和简化常见用例的重要要求，但现代框架通常将事情提升到了全新的水平。
- en: Thanks to mobile internet browsing, JavaScript applications often require increased
    functionality within the browser and less on the server. This greatly increases
    complexity and, while many such large applications require many engineers to work
    on such a JavaScript project, building these from scratch simply isn't conducive
    to a productive project. As such, frameworks are now becoming more and more important
    to reduce time to market, increase standards and best practices, and to raise
    creativity.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了移动互联网浏览，JavaScript应用程序通常需要在浏览器中提供更多功能，而在服务器上则较少。这大大增加了复杂性，尽管许多大型应用程序需要许多工程师共同参与这样的JavaScript项目，但从头开始构建这些项目并不利于高效的项目。因此，框架现在变得越来越重要，以减少上市时间、提高标准和最佳实践，以及提升创造力。
- en: Models, Views, and Controllers
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型、视图和控制
- en: 'Most application frameworks implement an architecture that separates application
    logic into common units of functionality. The primary abstraction of these units
    typically consists of Models, Views, and Controllers (MVC), whereby the Model
    represents an application''s data, the View represents how information is presented
    to the user, and the Controller is the functionality that facilitates processing
    between data and events:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18: Model-View-Controller'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_12_18.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.18: Model-View-Controller'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The notion of an MVC was derived well before the inception of the JavaScript
    language and, indeed, frameworks often derive from an MVC to something a bit more
    appropriate to the browser, such as the Model-View-View-Model (MVVM) pattern.
    However, simply understanding that there is an abstraction, and knowing the roles
    of the actors therein, helps improve your adoption of any given framework.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOMs
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another commonality of many newer frameworks is the inclusion of a virtual DOM.
    These are rendering engines that manage changes to nodes within the DOM. This
    means that, instead of manipulating the HTML within a web page directly, developers
    will instead utilize an API that sits between the application and the DOM. This
    way, when updates are needed, the virtual DOM will modify only those elements
    of the DOM that have changed by facilitating known low-latency, highly efficient
    methods.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: A great benefit of virtual DOMs arises when implementing two-way data binding
    between a Model and a View. If a user inputs a value in a text field, the associated
    Model could be instantly and automatically updated. Likewise, when the model updates,
    this may also trigger another view to display this new value.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: This is known as two-way data binding, which is the ability for a model and
    its views to equally update each other when one location changes. Such manipulations
    of the browser are greatly enhanced through the use of a virtual DOM, which may
    previously have resulted in user experience degradation.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another feature that's commonly found in modern frameworks is reactive functionality.
    When two-way data binding occurs using a virtual DOM, it is typically a reactive
    code that facilitates it. Reactive programming is a methodology of facilitating
    responsiveness, resilience, and scalability through data messaging. The idea is
    that, instead of polling and pulling data, messages are pushed as changes to data
    occur or when new data is made available. These updates may occur within an application
    or between applications, such as between the browser and the server.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is such an important new paradigm that whole libraries
    and frameworks are named after it, such as RxJS (the Rx means Reactive) and ReactJS.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Popular Frameworks
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the numerous frameworks available, there are three that are arguably the
    most popular among the JavaScript community. They are as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '**AngularJS**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReactJS**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vue.js**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS was created by Google and released in October 2010 and was completely
    rewritten in 2014 as Angular2, changing many of its unique characteristics and
    adopting TypeScript as its preferred language; though it can be utilized with
    vanilla JavaScript with a bit of work. Since the rewrite, Angular2 is now incrementally
    updated with new releases regularly. Currently, Angular2 is on version 8 but is
    still called Angular2, which can get very confusing.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS是由Google创建的，于2010年10月发布，并在2014年完全重写为Angular2，改变了其许多独特的特性，并采用TypeScript作为其首选语言；尽管通过一些工作也可以使用vanilla
    JavaScript。重写之后，Angular2现在定期通过新版本进行增量更新。目前，Angular2处于第8版，但仍被称为Angular2，这可能会非常令人困惑。
- en: AngularJS (and its successor, Angular2) has a relatively high learning curve,
    flourishing many paradigms that are unique to the Angular community. However,
    it's an extremely opinionated library, helping to ensure that teams of developers
    utilize it in a common way, relieving any potential ambiguity of functionality.
    Additionally, AngularJS is a fully encompassing framework, providing almost all
    of the tools you may require when building complex browser-based applications.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS（及其继任者Angular2）的学习曲线相对较高，繁荣了许多仅属于Angular社区的独特范例。然而，它是一个非常有意见的库，有助于确保开发团队以相同的方式使用它，从而消除任何潜在的功能模糊性。此外，AngularJS是一个完全包容的框架，在构建复杂的基于浏览器的应用程序时，几乎提供了你可能需要的所有工具。
- en: ReactJS
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReactJS
- en: ReactJS was conceived and developed by a single engineer at Facebook. In contrast
    to AngularJS, ReactJS does not try to do everything for you but purports to be
    merely the UI management layer, providing Virtual DOM functionality and other
    such goodies. The community that has formed around this framework has created
    additional libraries that can come together to form an ecosystem with similar
    capabilities to AngularJS. However, unlike AngularJS, ReactJS is not so opinionated,
    meaning applications can pick and choose what is implemented and, to some degree,
    how it is implemented. Developers also have greater freedom to decide from a range
    of libraries that compete to provide similar functionality.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS是由Facebook的一位工程师构思和开发的。与AngularJS相比，ReactJS并不试图为你做所有事情，而是声称仅仅是UI管理层，提供虚拟DOM功能和其他类似的好东西。围绕这个框架形成的社区已经创建了额外的库，这些库可以结合起来形成一个具有与AngularJS相似功能的生态系统。然而，与AngularJS不同，ReactJS并不那么有意见，这意味着应用程序可以选择实现什么，以及在某种程度上如何实现。开发者也有更大的自由度，可以从竞争提供类似功能的众多库中选择。
- en: Vue.js
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue.js
- en: Vue.js was developed by Evan You in 2013, a Google developer who had been using
    AngularJS while working for Google, but who decided he'd like to take only those
    elements of AngularJS that he liked and make his own lightweight framework. The
    result is a modular framework that provides almost all of the functionality of
    AngularJS, but in pieces that can be selected as needed, such as ReactJS, and
    with a total file size far smaller than either of the other two frameworks.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js是由Evan You在2013年开发的，他是一位在Google工作的开发者，当时一直在使用AngularJS，但他决定他只想保留他喜欢的AngularJS元素，并创建自己的轻量级框架。结果是，一个模块化框架，它提供了几乎与AngularJS相同的功能，但以可以按需选择的片段形式提供，例如ReactJS，并且总文件大小远小于其他两个框架。
- en: Vue.js has a very gentle learning curve and is steadily increasing in popularity
    as a framework that offers great application development structure, but without
    the rigid opinionated paradigms that work well in team environments. However,
    these often-hinder projects of a less vanilla nature.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js的学习曲线非常平缓，作为一个提供优秀应用开发结构但又不拘泥于团队环境中工作得很好的严格意见化范例的框架，它的受欢迎程度正在稳步上升。然而，这些往往阻碍了那些不那么常规项目的进展。
- en: Server-Side Libraries
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端库
- en: Just like the browser, the server-side JavaScript ecosystem also has access
    to libraries and frameworks that aid an application's development. Since Node.js
    is JavaScript too, it is possible to utilize many libraries within both the browser
    and Node.js. For instance, Lodash, Underscore, and Ramda, having no browser-specific
    qualities, will function just as well in a Node.js application. This is one of
    the key reasons why the Node.js platform took off so quickly following its initial
    release; with so many libraries already usable on the platform that was created
    for browser applications, it was possible for developers to continue working in
    a style they were familiar with for server-side application development.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 就像浏览器一样，服务器端 JavaScript 生态系统也有访问库和框架的权限，这些库和框架有助于应用程序的开发。由于 Node.js 也是 JavaScript，因此可以在浏览器和
    Node.js 中利用许多库。例如，Lodash、Underscore 和 Ramda 没有浏览器特定的特性，在 Node.js 应用程序中也能正常工作。这是
    Node.js 平台在最初发布后迅速起飞的关键原因之一；由于平台上有许多库已经可用，这些库是为浏览器应用程序创建的，因此开发人员可以在他们熟悉的方式下继续进行服务器端应用程序开发。
- en: As well as all the possible browser-centric libraries, Node.js also has some
    key libraries of its own that provide functionality that is not possible in the
    browser, such as REST server functionality or database object relational mapping
    (ORM).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有可能的以浏览器为中心的库之外，Node.js 还有一些自己的关键库，这些库提供了在浏览器中无法实现的功能，例如 REST 服务器功能或数据库对象关系映射（ORM）。
- en: Express
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Express
- en: Possibly the single most popular library for Node.js is called Express. This
    library makes it extremely easy to build webservers since it provides functions
    that are able to establish routes and serve content when requests are sent to
    those routes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是 Node.js 最受欢迎的库之一，名为 Express。这个库使得构建 web 服务器变得极其简单，因为它提供了在请求发送到这些路由时建立路由和提供内容的功能。
- en: 'Express can be installed with the following command:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Express 可以通过以下命令安装：
- en: '[PRE61]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once installed, you can write a simple server application, such as the following:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以编写一个简单的服务器应用程序，例如以下内容：
- en: '[PRE62]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once built, the webserver can be launched just like any other Node.js application;
    for example:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，web 服务器就可以像任何其他 Node.js 应用程序一样启动；例如：
- en: '[PRE63]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The Express object supports all possible HTTP call types, including `GET`, `PUT`,
    `POST`, and `DELETE`, thus empowering complete REST-capable servers, but is also
    capable of serving static HTML, JavaScript, CSS, and other such asset files, using
    a special `static` function.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Express 对象支持所有可能的 HTTP 调用类型，包括 `GET`、`PUT`、`POST` 和 `DELETE`，从而使得完全具备 REST 功能的服务器成为可能，但它也具备使用特殊
    `static` 函数提供静态 HTML、JavaScript、CSS 和其他此类资产文件的能力。
- en: The Express library is very complete, so reading the documentation and guides
    on its website is recommended so that you get a true feeling of its capabilities.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Express 库非常完整，因此建议阅读其网站上的文档和指南，以便你能够真正感受到其功能。
- en: Request
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求
- en: While Express functions as a webserver, the Request library functions as a web
    client. Often, when creating web applications, it can become necessary to proxy
    content, data, or functionality from another remote webserver. The Request library
    enables communication with such servers for this purpose.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Express 充当 web 服务器，但 Request 库充当 web 客户端。在创建网络应用程序时，有时可能需要从另一个远程 web 服务器代理内容、数据或功能。Request
    库允许为此目的与这些服务器进行通信。
- en: 'Request can be installed with the following command:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可以通过以下命令安装：
- en: '[PRE64]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once installed, you can use Request as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，你可以按以下方式使用 Request：
- en: '[PRE65]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Socket.IO
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.IO
- en: Working with HTTP can be slow. The client creates a request packet and sends
    it to the recipient server. This server then creates a response packet and sends
    it back to the caller. Each request/response transaction is atomic, meaning it
    occurs independently of any other request/response transactions, often requiring
    a unique connection setup and teardown.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTP 进行工作可能会很慢。客户端创建一个请求包并将其发送到接收服务器。然后，该服务器创建一个响应包并将其发送回调用者。每个请求/响应事务都是原子的，这意味着它独立于任何其他请求/响应事务发生，通常需要设置和断开一个独特的连接。
- en: Modern applications prefer to utilize web sockets more and more. These are "always
    connected" sockets that use a faster, more agile connection protocol for sending
    data and are wonderful for building applications such as online chat rooms, multiplayer
    games, and also for fast data storage and retrieval.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序越来越倾向于利用 WebSocket。这些是“始终连接”的套接字，它们使用更快速、更敏捷的连接协议来发送数据，非常适合构建在线聊天室、多人游戏等应用程序，也适用于快速数据存储和检索。
- en: While web sockets utilize a protocol of their own, that protocol merely handles
    the security and reliability of the data transaction, and not with the specific
    requirements of an application's logic.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WebSocket使用自己的协议，但该协议仅处理数据传输的安全性和可靠性，而不是应用程序逻辑的具体要求。
- en: To address this, Socket.IO provides an additional layer to make working with
    web sockets much easier, thus providing functionality that's common to many applications
    that can utilize it how they see fit.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Socket.IO 提供了一个额外的层，使得使用 WebSocket 变得更加容易，从而为许多可以利用它的应用程序提供了通用的功能。
- en: 'Socket.IO can be installed with the following command:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装 Socket.IO：
- en: '[PRE66]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A simple Socket.IO server application looks as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 Socket.IO 服务器应用程序看起来如下所示：
- en: '[PRE67]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Activity 12.01: Creating a Project to Recognize and Compile TypeScript Files'
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.01：创建一个识别和编译 TypeScript 文件的项目
- en: This chapter provided a lot of information regarding the investigation of the
    greater JavaScript world. Obviously, there is a lot you can learn beyond the basics
    of a language or platform but knowing where to look and how to integrate a new
    library or framework into your application provides the necessary foundation from
    which you can experiment and improve your coding skills.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了大量关于调查更大 JavaScript 世界的信息。显然，你可以在语言或平台的基础知识之外学到很多东西，但知道在哪里寻找以及如何将新的库或框架集成到你的应用程序中，为你提供了必要的基石，从那里你可以进行实验并提高你的编码技能。
- en: In this activity, you have been tasked with setting up TypeScript for a new
    project. You are now aware of what TypeScript is. For the project at hand, both
    your project manager and your developer colleagues want to utilize TypeScript's
    static typing capabilities, among other things, in what will be a large project.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你被要求为一个新的项目设置 TypeScript。你现在已经知道 TypeScript 是什么了。对于当前的项目，你的项目经理和开发同事都希望利用
    TypeScript 的静态类型能力，以及其他功能，这将是一个大型项目。
- en: Your task for this activity is to create the initial project setup, ensuring
    that TypeScript files are recognized and compiled correctly to the output folder.
    It is not important to provide any code, merely to ensure everything compiles
    successfully. The project manager is happy for Parcel to be used in this project
    in order to keep things simple.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的任务是创建初始项目设置，确保 TypeScript 文件被正确识别并编译到输出文件夹。不需要提供任何代码，只需确保一切编译成功。项目经理很高兴在这个项目中使用
    Parcel 以保持事情简单。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的概要步骤如下：
- en: Create a new project that has `npm` initialized.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并初始化 `npm`。
- en: Install Parcel as a global library.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Parcel 作为全局库安装。
- en: Install the TypeScript library in the application.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中安装 TypeScript 库。
- en: Create the necessary TypeScript configuration but keep it simple.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的 TypeScript 配置，但要保持简单。
- en: Create a temporary `.ts` file in the `src` directory.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 目录中创建一个临时的 `.ts` 文件。
- en: Add the necessary script to the `package.json` file.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将必要的脚本添加到 `package.json` 文件中。
- en: Run the transpiler and ensure that output is generated. You should see no errors.
    The TypeScript transpiler should show a `Built in <x>ms` response message if all
    went well.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行编译器并确保生成输出。你不应该看到任何错误。如果一切顺利，TypeScript 编译器应该显示 `Built in <x>ms` 的响应消息。
- en: 'The expected output for this activity is as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的预期输出如下：
- en: '![Figure 12.19: Parcel TypeScript Output'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.19：Parcel TypeScript 输出](img/C14377_12_19.jpg)'
- en: '](img/C14377_12_19.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_12_19.jpg](img/C14377_12_19.jpg)'
- en: 'Figure 12.19: Parcel TypeScript Output'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19：Parcel TypeScript 输出
- en: Note
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to the activity can be found on page 752.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 752 页找到。
- en: Simply knowing how to utilize a package manager opens up vast amounts of power
    so that you can create functional applications quickly. When working in a professional
    environment, using the necessary tools in the correct fashion is paramount and
    will ensure that your application starts off on the right footing.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 仅了解如何使用包管理器就能打开大量的能力，让你可以快速创建功能性的应用程序。在专业环境中工作，正确使用必要的工具至关重要，这将确保你的应用程序有一个良好的开端。
- en: Summary
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a look at the various tools that are available on the
    market for advanced development in JavaScript. We learned how to use the latest
    JavaScript syntax in older browsers and identified the different options that
    are available for the development of JavaScript applications in other languages.
    We also explored the various package managers, such as npm and Yarn, that are
    compatible with JavaScript, along with several different frameworks, such as AngularJS,
    ReactJS, and Vue.js. Finally, we looked at some server-side libraries such as
    Express, Request, and Socket.IO.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了市场上用于 JavaScript 高级开发的多种工具。我们学习了如何在旧浏览器中使用最新的 JavaScript 语法，并确定了可用于在其他语言中开发
    JavaScript 应用程序的不同选项。我们还探讨了与 JavaScript 兼容的各种包管理器，例如 npm 和 Yarn，以及几个不同的框架，如 AngularJS、ReactJS
    和 Vue.js。最后，我们查看了一些服务器端库，例如 Express、Request 和 Socket.IO。
- en: In the next chapter, we will look at some other areas of advanced JavaScript.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些其他高级 JavaScript 领域。
