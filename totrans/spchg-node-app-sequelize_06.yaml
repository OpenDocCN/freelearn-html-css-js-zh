- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Implementing Transactions with Sequelize
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sequelize实现事务
- en: Throughout the previous chapters, we went over how to ensure that data integrity
    is maintained from within our Node.js application using life cycle events, validations,
    and constraints. However, these methods do not guarantee that the data is internally
    consistent in the database itself. Databases offer a way to atomicize integrity
    using **transactions**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了如何使用生命周期事件、验证和约束来确保从我们的Node.js应用程序内部维护数据完整性。然而，这些方法并不能保证数据库内部数据的一致性。数据库提供了一种使用**事务**来原子化完整性的方法。
- en: Transactions are used for ensuring a process has been completed without interruptions
    such as a connection failure or the power abruptly failing. They are also used
    for isolating, or locking, applications from manipulating data concurrently, which
    alleviates **race****condition** issues. Transactions promise data validity by
    following the **ACID** principle, which stands for **atomic** (“all-or-nothing”
    behavior), **consistent** (adheres to constraints), **isolated** (transactions
    happen sequentially and unbeknownst toward each other), and **durable** (persistent
    storage).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 事务用于确保一个过程在没有中断（如连接失败或电源突然断电）的情况下完成。它们还用于隔离或锁定应用程序，防止并发地操作数据，从而减轻**竞争条件**问题。事务通过遵循**ACID**原则来保证数据的有效性，其中**ACID**代表**原子性**（“全有或全无”行为）、**一致性**（遵守约束）、**隔离性**（事务按顺序发生，彼此之间不知情）和**持久性**（持久存储）。
- en: A generic use case for transactions would be transferring funds from one user
    account to another. If *User A* had 30 coins in their account and was charged
    20 coins by *User B* just before *User A* decided to make a purchase from another
    user for 15 coins, then the database should prevent *User A* from being able to
    purchase the item that costs 15 coins due to a low balance. The database would
    see that *User A* was charged 20 coins prior to charging 15 coins and then would
    issue a **rollback** for the second transaction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的一个通用用例是从一个用户账户向另一个用户账户转账。如果*用户A*账户中有30个硬币，并且在*用户A*决定从另一个用户那里购买价值15个硬币的商品之前，*用户B*向*用户A*收取了20个硬币，那么数据库应该防止*用户A*因为余额不足而无法购买价值15个硬币的商品。数据库会看到*用户A*在收取15个硬币之前已经被收取了20个硬币，然后会对第二个事务发出**回滚**。
- en: Note
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Transactions also offer a feature called **savepoints** that would act as “snapshots
    of time for the database” with changes made from the transaction itself, which
    is useful for multi-step transactions. For instance, in a bank scenario, we only
    transact the currency itself, but in a vendor’s shop, we would have to ensure
    the item and currencies are in their appropriate places.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 事务还提供了一种称为**保存点**的功能，它作为“数据库时间快照”，记录事务本身所做的更改，这对于多步事务非常有用。例如，在银行场景中，我们只交易货币本身，但在供应商的商店中，我们必须确保商品和货币处于适当的位置。
- en: By default, Sequelize does not execute queries under a transaction, but it does
    offer two methods for interacting with transactions that are referred to as managed
    and unmanaged transactions. Managed transactions will either commit the changes
    or roll back their changes automatically/implicitly depending on whether there
    is an error. Unmanaged transactions rely on the developer to invoke the appropriate
    methods for committing or rolling back changes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Sequelize不会在事务下执行查询，但它确实提供了两种与事务交互的方法，分别称为管理事务和非管理事务。管理事务将自动/隐式地提交更改或回滚更改，具体取决于是否存在错误。非管理事务依赖于开发者调用适当的提交或回滚更改的方法。
- en: 'In this chapter, we will cover the following areas:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A more in-depth look at – and examples of—managed and unmanaged transactions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨并举例说明管理事务和非管理事务
- en: Using **Continuation-Local Storage** (**CLS**) for partial transactions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**延续本地存储**（**CLS**）进行部分事务
- en: Managing and configuring advanced transaction options including isolation levels
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和配置高级事务选项，包括隔离级别
- en: Using life cycle events and locks with transactions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生命周期事件和锁与事务一起使用
- en: 'Specifically, we will look at the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将探讨以下主题：
- en: Managed and unmanaged transactions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理事务和非管理事务
- en: Running transactions concurrently
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发运行事务
- en: Isolation levels and advanced configuration
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离级别和高级配置
- en: Putting it all together
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can always reference Sequelize’s code base to maintain an up-to-date list
    of available transaction methods here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以始终参考Sequelize的代码库，以维护这里可用的交易方法列表的最新状态：
- en: '[https://github.com/sequelize/sequelize/blob/v6/src/transaction.js](https://github.com/sequelize/sequelize/blob/v6/src/transaction.js)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/sequelize/sequelize/blob/v6/src/transaction.js](https://github.com/sequelize/sequelize/blob/v6/src/transaction.js)'
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files of this chapter at [https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch6](https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch6).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch6](https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch6)找到本章的代码文件。
- en: Managed and unmanaged transactions
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理事务和非管理事务
- en: Managed transactions are typically easier for developers with previous **object-relational
    mapping** (**ORM**) experience, and unmanaged transactions may be more familiar
    to developers who write **Structured Query Language** (**SQL**) directly. Unmanaged
    transactions are explicit by design, but managed transactions have some implicit
    behaviors for state management such as automatically creating a transaction instance
    and calling your callback method with that transaction.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有先前**对象关系映射**（**ORM**）经验的开发者来说，管理事务通常更容易，而对于直接编写**结构化查询语言**（**SQL**）的开发者来说，非管理事务可能更为熟悉。非管理事务的设计是显式的，但管理事务在状态管理方面有一些隐式行为，例如自动创建事务实例并使用该事务调用您的回调方法。
- en: 'Let’s look at the steps for creating unmanaged transactions, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建非管理事务的步骤，如下所示：
- en: 'We would start by creating a transaction instance, like so:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个事务实例，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will want to wrap our queries in a `try` block. For this example,
    we will increment and decrement two account balances by `100` using the same transaction
    instance, like so:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `try` 块中包装我们的查询。在这个例子中，我们将使用相同的事务实例增加和减少两个账户余额各 `100`，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following line of code will commit our transaction if our previous two
    queries are executed successfully:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将在前两个查询成功执行后提交我们的事务：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can close the `try` block and add a `catch` block for handling any
    errors thrown from our transaction, as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以关闭 `try` 块并添加一个 `catch` 块来处理事务中抛出的任何错误，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `tx.rollback()` command will tell the database to revert any changes made
    within this transaction. You may roll back a transaction at any time regardless
    of whether there is a conditional statement or for error handling.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx.rollback()` 命令会告诉数据库撤销此事务内所做的任何更改。无论是否有条件语句或错误处理，您都可以在任何时候回滚事务。'
- en: 'Sequelize can automate a lot of this work for you by using *managed transactions*.
    Let us presume that our `Account` model has a constraint where the balance had
    to be greater than zero, and the sender account only had five coins in its balance.
    We can rewrite our previous unmanaged transaction example into a managed transaction,
    like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 *管理事务*，Sequelize 可以为您自动化很多这项工作。假设我们的 `Account` 模型有一个约束，即余额必须大于零，并且发送账户的余额中只有五枚硬币。我们可以将先前的非管理事务示例重写为管理事务，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Managed transactions will automatically commit or roll back depending on whether
    an exception was thrown from an applicable query. You can still roll back manually
    within a managed transaction by throwing an error within the transaction block,
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 管理事务将根据是否有从适用查询抛出异常自动提交或回滚。您仍然可以在管理事务中通过在事务块内抛出错误来手动回滚，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Sometimes, our application will require different transactions to run concurrently.
    We can chain multiple transactions recursively or we could use a module called
    CLS. In the next section, we will cover how to use concurrent transactions with
    both methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的应用程序可能需要运行不同的并发事务。我们可以递归地链式多个事务，或者使用名为 CLS 的模块。在下一节中，我们将介绍如何使用这两种方法使用并发事务。
- en: Running transactions concurrently
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行运行事务
- en: 'Depending on whether your application requires isolation between reads and
    writes, within the database, you may need to explicitly run multiple transactions
    at the same time. Sequelize offers two methods for running transactions concurrently:
    recursively chaining transactions (Sequelize’s native method) or integrating your
    application with a third-party module called CLS.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的应用程序是否需要在数据库中读取和写入之间进行隔离，您可能需要显式地同时运行多个事务。Sequelize 提供了两种并行运行事务的方法：递归链式事务（Sequelize
    的原生方法）或通过第三方模块 CLS 集成您的应用程序。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: SQLite does not support running multiple transactions concurrently.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite不支持同时运行多个事务。
- en: Running transactions concurrently with Sequelize
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sequelize同时运行事务
- en: 'We can run transactions concurrently with Sequelize concurrently by chaining
    two transaction methods together, which would look similar to this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过链式调用两个事务方法来使用Sequelize同时运行事务，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can run multiple queries simultaneously while using different transactions,
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在使用不同事务的同时同时运行多个查询，如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By default, Sequelize will not use a transaction instance variable. If we were
    to omit the `{ transaction: tx2 }` option for the last `Account.create` command,
    then Sequelize would not use a transaction instance variable and would act like
    the first `Account.create` command with `{ transaction: null }`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，Sequelize不会使用事务实例变量。如果我们省略了最后一个`Account.create`命令的`{ transaction: tx2
    }`选项，那么Sequelize将不会使用事务实例变量，其行为将类似于第一个`Account.create`命令，即`{ transaction: null
    }`。'
- en: Running transactions with CLS
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CLS运行事务
- en: Using CLS with Sequelize will help you automatically pass transactions to all
    queries, as well as provide something similar to thread-local storage. The advantage
    of CLS’ automatic transaction execution is that some database pool drivers require
    us to commit transactions across the wire, which would be cumbersome to manage
    manually. The thread-local storage gives us the ability to share context across
    transactions created in separate parts within our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CLS与Sequelize结合可以帮助您自动将事务传递给所有查询，并提供类似线程局部存储的功能。CLS自动执行事务的优势在于，某些数据库连接池驱动程序要求我们在网络上提交事务，这手动管理起来会非常繁琐。线程局部存储使我们能够在应用程序的不同部分创建的事务之间共享上下文。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about CLS, refer to the project’s Git repository at [https://github.com/othiym23/node-continuation-local-storage](https://github.com/othiym23/node-continuation-local-storage).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于CLS的信息，请参考项目的Git仓库：[https://github.com/othiym23/node-continuation-local-storage](https://github.com/othiym23/node-continuation-local-storage)。
- en: 'This book does not integrate CLS with Sequelize, but for completeness, we will
    cover how to enable CLS with Sequelize for your project. We will need to install
    the necessary package, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本书没有将CLS与Sequelize集成，但为了完整性，我们将介绍如何为您的项目启用CLS。我们需要安装必要的包，如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we can initialize a CLS namespace, like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以初始化一个CLS命名空间，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then pass the `namespace` variable to the Sequelize constructor’s `useCLS`
    method, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`namespace`变量传递给Sequelize构造函数的`useCLS`方法，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we are using Sequelize’s constructor, all of Sequelize’s instances will
    share the same namespace. Individual CLS instances are not supported by Sequelize
    at this time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Sequelize构造函数，所有Sequelize的实例都将共享相同的命名空间。目前Sequelize不支持单独的CLS实例。
- en: 'Borrowing from the previous section’s example, we omit to classify the transaction
    parameter within our queries, as highlighted in the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的示例中借鉴，我们在查询中省略了事务参数的分类，如下例所示：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With CLS, Sequelize will pass the innermost scoped transaction instance variable,
    which would be `tx2` from the previous example. If we were to omit the `{ transaction:
    null }` option for the first `Account.create` command, then Sequelize will presumptuously
    use `tx2` for its transaction, as in the last `Account.create` command. The second—or
    middle—`Account.create` command would still explicitly use the `tx1` transaction
    instance.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '使用CLS，Sequelize将传递最内层作用域的事务实例变量，在先前的例子中将是`tx2`。如果我们省略第一个`Account.create`命令的`{
    transaction: null }`选项，那么Sequelize将默认使用`tx2`作为其事务，就像在最后的`Account.create`命令中一样。第二个——中间的——`Account.create`命令仍然会显式使用`tx1`事务实例。'
- en: 'Since Sequelize automatically passes a transaction to queries, the following
    two examples would execute with the same `tx` instance variable:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Sequelize自动将事务传递给查询，以下两个示例将使用相同的`tx`实例变量执行：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, enabling CLS with Sequelize can offer some advantages and organize
    the project’s code base a bit better.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，启用CLS与Sequelize结合使用可以提供一些优势，并更好地组织项目的代码库。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For even more functionality with CLS, refer to a project called CLS-Hooked:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得CLS的更多功能，请参考名为CLS-Hooked的项目：
- en: '[https://github.com/jeff-lewis/cls-hooked](https://github.com/jeff-lewis/cls-hooked)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jeff-lewis/cls-hooked](https://github.com/jeff-lewis/cls-hooked)'
- en: Isolation levels and advanced configuration
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离级别和高级配置
- en: 'In this section, we will be covering the different isolation levels and configuration
    options available from Sequelize for every type of transaction. For managed transactions,
    the method signature looks like this: `sequelize.transaction(options, callback)`.
    The unmanaged transaction signature is `sequelize.transaction(options)`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 Sequelize 为每种类型的事务提供的不同隔离级别和配置选项。对于管理事务，方法签名如下：`sequelize.transaction(options,
    callback)`。非管理事务的签名是 `sequelize.transaction(options)`。
- en: 'Here is a list of configurable options for both transaction types:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两种事务类型可配置选项的列表：
- en: '`type`—A SQLite option to set the transaction type. Possible values are `DEFERRED`
    (the default), `IMMEDIATE`, and `EXCLUSIVE`. Refer to [https://www.sqlite.org/lang_transaction.xhtml](https://www.sqlite.org/lang_transaction.xhtml).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`—SQLite 中的一个选项，用于设置事务类型。可能的值有 `DEFERRED`（默认值）、`IMMEDIATE` 和 `EXCLUSIVE`。有关更多信息，请参阅
    [https://www.sqlite.org/lang_transaction.xhtml](https://www.sqlite.org/lang_transaction.xhtml)。'
- en: '`isolationLevel`—Sets the transaction’s isolation level. The following explanations
    are under the context of MySQL but should be applicable to other `READ_UNCOMMITTED`—Reads
    data using non-locking mechanisms. This could cause concurrency issues using stale,
    or invalid, data from other transactions that have been rolled back.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isolationLevel`—设置事务的隔离级别。以下说明是在 MySQL 的上下文中，但应适用于其他数据库。`READ_UNCOMMITTED`—使用非锁定机制读取数据。这可能导致并发问题，使用已回滚的其他事务中的过时或无效数据。'
- en: '`READ_COMMITTED`—Performs consistent reads even from within the same transaction.
    In other words, reading data will be consistent with updates performed from prior
    queries within the same transaction.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ_COMMITTED`—即使在同一事务内部也执行一致的读取。换句话说，读取数据将与同一事务内部先前查询执行的更新保持一致。'
- en: '`REPEATABLE_READ`—Similar to `READ_COMMITTED` when it comes to reading the
    information, but there are some stipulations when it comes to MySQL’s InnoDB database
    engines explicitly. Refer to [https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.xhtml#isolevel_repeatable-read](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.xhtml#isolevel_repeatable-read)
    for more information on how to consistently lock records for when you need to.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPEATABLE_READ`—在读取信息方面类似于 `READ_COMMITTED`，但在 MySQL 的 InnoDB 数据库引擎方面有一些具体规定。有关如何一致性地锁定记录的更多信息，请参阅
    [https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.xhtml#isolevel_repeatable-read](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.xhtml#isolevel_repeatable-read)。'
- en: '`SERIALIZABLE`—A stricter ruleset than `REPEATABLE_READ`. This isolation level
    is generally used for figuring out concurrency and deadlock-related issues for
    the database.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERIALIZABLE`—比 `REPEATABLE_READ` 更严格的规则集。此隔离级别通常用于解决数据库的并发和死锁相关的问题。'
- en: '`deferrable`—Applicable to PostgreSQL only, this setting determines whether
    constraints can be deferred or checked immediately.*   `logging`—A function that
    Sequelize will pass a query and its parameters as arguments.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deferrable`—仅适用于 PostgreSQL，此设置确定约束是否可以延迟或立即检查。*   `logging`—一个函数，Sequelize
    将传递查询及其参数作为参数。'
- en: 'Sequelize offers constant variables for convenience when setting isolation
    levels, like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 提供了用于设置隔离级别的常量变量，以便于使用，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also set the transaction’s isolation level on an instance level by setting
    the `isolationLevel` option when initializing Sequelize, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在初始化 Sequelize 时设置 `isolationLevel` 选项，在实例级别上设置事务的隔离级别，如下所示：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, any subsequent transactions will use the `READ_COMMITTED` level by default.
    These isolation levels pertain to reading data. In the next section, we will go
    over locking mechanisms for writing data to the database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何后续的事务都将默认使用 `READ_COMMITTED` 级别。这些隔离级别与读取数据相关。在下一节中，我们将介绍写入数据库的锁定机制。
- en: Locking rows with Sequelize
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Sequelize 锁定行
- en: 'Sometimes, our application requires us to temporarily lock information while
    performing a transaction and prevent other transactions from committing to the
    same table or row. Database practitioners may know this mechanism as a `SELECT
    FOR UPDATE` query. You can see an example of such a query in the following code
    snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的应用程序需要我们在执行事务时暂时锁定信息，并防止其他事务提交到同一表或行。数据库从业者可能知道这种机制称为 `SELECT FOR UPDATE`
    查询。您可以在以下代码片段中看到一个此类查询的示例：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Presuming that each `row` and `seat` instance is unique per `venue` instance,
    the previous example will lock that particular seat’s record until the transaction
    has been committed or rolled back.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个`row`和`seat`实例在每个`venue`实例中都是唯一的，前面的示例将锁定该特定座位的记录，直到事务提交或回滚。
- en: 'Suppose we wanted to retrieve a list of seats that were not in a pending transaction.
    If our DBMS supports the `SKIP LOCKED` command, then we can use a `skipLocked:
    true` configuration option when querying data. To demonstrate the `SKIP LOCKED`
    feature, we can begin by adding a locked record for a particular seat, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们想要检索一个不在挂起交易中的座位列表。如果我们的数据库管理系统支持`SKIP LOCKED`命令，那么在查询数据时可以使用`skipLocked:
    true`配置选项。为了演示`SKIP LOCKED`功能，我们可以首先为特定座位添加一个锁定记录，如下所示：'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, the following query will use the `SKIP LOCKED` rule and return any applicable
    row that is not locked by another pending transaction (in this particular case,
    row 5, seat 13):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下查询将使用`SKIP LOCKED`规则并返回任何由其他挂起交易（在本例中为行5，座位13）未锁定的适用行：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: MySQL added support for `SKIP LOCKED` from version 8.0.1\. This book’s code
    base will not require `skipLocked`, but if you are using an older version and
    try to use `skipLocked`, then Sequelize will silently omit the `SKIP LOCKED` command
    from the query and may yield unexpected behaviors or results.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL从8.0.1版本开始支持`SKIP LOCKED`。本书的代码库不需要`skipLocked`，但如果您使用的是较旧版本并尝试使用`skipLocked`，那么Sequelize将默默地从查询中省略`SKIP
    LOCKED`命令，可能会导致意外的行为或结果。
- en: Using life cycle events for transactions
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用生命周期事件进行事务
- en: Sequelize only offers one life cycle—even for transactions—explicitly at the
    moment. This life cycle event, named `afterCommit`, can be used for both managed
    and unmanaged transactions. This event will not be triggered if the transaction
    gets rolled back, nor can the event modify its transaction object (unlike traditional
    life cycle events).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize目前只为事务提供一种生命周期——即使是事务——明确地。这个名为`afterCommit`的生命周期事件可以用于管理和非管理事务。如果事务回滚，则不会触发此事件，并且该事件不能修改其事务对象（与传统生命周期事件不同）。
- en: 'To invoke the `afterCommit` hook, we can add the event to the transaction’s
    instance, like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`afterCommit`钩子，我们可以将事件添加到事务实例中，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can append `afterCommit` events to an entire model via the `afterSave` event.
    A good use case for using `afterCommit` is sending serialized data to some other
    service, application, blockchain database, and so on. Here is an example of how
    to use `afterCommit`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`afterSave`事件将`afterCommit`事件附加到整个模型上。使用`afterCommit`的一个好例子是将序列化数据发送到其他服务、应用程序、区块链数据库等。以下是如何使用`afterCommit`的示例：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So far, we have gone over the different kinds of transactions that Sequelize
    offers, namespace environments for transactions, isolation levels, locking, and
    life cycle events. Using a combination of these skillsets, we can finally start
    implementing some of this knowledge into our application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了Sequelize提供的不同类型的事务，事务的命名空间环境，隔离级别，锁定和生命周期事件。通过这些技能的组合，我们最终可以开始将一些知识应用到我们的应用程序中。
- en: Putting it all together
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Now that we have gone over the core tenets of using transactions with Sequelize,
    we can begin adding to our *Avalon Airlines* project. Our business partner just
    informed us that the investors want a small demonstration for booking a flight
    without processing a payment. For this task, we will need to add a couple of new
    files, update the `BoardingTicket` and `FlightSchedule` models, add new routes
    to our express application, and install a new Node.js package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用Sequelize进行事务的核心原则，我们可以开始向我们的*Avalon Airlines*项目添加内容。我们的业务伙伴刚刚通知我们，投资者想要一个预订航班而不处理支付的简单演示。为此任务，我们需要添加几个新文件，更新`BoardingTicket`和`FlightSchedule`模型，向我们的Express应用程序添加新路由，并安装一个新的Node.js包。
- en: 'First, let us begin by adding the new Node.js package that the project will
    require. This package is known as Luxon ([https://moment.github.io/luxon/](https://moment.github.io/luxon/)),
    which is a date-and-time JavaScript library. Use the following command to add
    the package:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开始添加项目所需的新Node.js包。这个包被称为Luxon ([https://moment.github.io/luxon/](https://moment.github.io/luxon/))，它是一个日期和时间JavaScript库。使用以下命令添加包：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we will want to modify a life cycle event that exists within the `BoardingTicket`
    model located in `models/boardingticket.js` by adding/changing the following highlighted
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将想要修改位于`models/boardingticket.js`中的`BoardingTicket`模型中的一个生命周期事件，通过添加/更改以下突出显示的代码：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The other model that we will need to add a few updates to is the `FlightSchedule`
    model located in `models/flightschedule.js`. Add the following line of code to
    the top of the file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新另一个模型，即位于`models/flightschedule.js`中的`FlightSchedule`模型。在文件顶部添加以下代码行：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that, add another validation within the `validate` object just below
    the `validDestination` method, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`validDestination`方法下方添加另一个验证到`validate`对象中，如下所示：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can add a new folder and file located at `routes/flights.js` from the
    project’s main directory and add the following lines of code to load the appropriate
    modules and files:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在项目主目录中添加一个新文件夹和文件`routes/flights.js`，并添加以下代码行以加载适当的模块和文件：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For our first flight-related route, we will need to find a way to create our
    airplanes first. Looking at the attributes from `models/airplane.js`, we can determine
    that we will need a model name and the number of seats for each airplane. The
    code is illustrated in the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们第一个与航班相关的航线，我们需要找到一种方法来首先创建我们的飞机。查看`models/airplane.js`中的属性，我们可以确定我们需要一个型号名称和每架飞机的座位数。代码如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within the `POST` data, we will expect `name` and `seats` values to be sent
    to our Express application. Now, we can add the airplane creation logic, along
    with closing and exporting the function, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`POST`数据中，我们期望发送`name`和`seats`值到我们的Express应用程序。现在，我们可以添加飞机创建逻辑，以及关闭和导出函数，如下所示：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our next function will be for creating flight schedules. We will require `airplaneId`,
    `origin`, `destination`, and `departure` `POST` values for creating flight schedules,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数将是用于创建航班时刻表。我们需要`airplaneId`、`origin`、`destination`和`departure` `POST`值来创建航班时刻表，如下所示：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, let us validate and parse the departure time into a native `DateTime`
    object, like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们验证并解析出发时间到一个本地的`DateTime`对象，如下所示：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we will want to check whether the airplane actually exists, so we’ll
    execute the following code to find out:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将想要检查飞机是否实际存在，因此我们将执行以下代码来找出答案：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the airplane does exist, we will want to create a flight schedule for it.
    We will wrap the creation in a transaction to ensure that creating the schedule,
    and associating the schedule with a particular airplane, would yield no errors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果飞机确实存在，我们将想要为它创建一个航班时刻表。我们将创建过程封装在一个事务中，以确保创建时刻表以及将时刻表与特定的飞机关联不会产生错误。
- en: 'For this particular demonstration, a transaction is not necessary, but in a
    real-world application, we would want to make sure that an airplane is not overbooked
    based on routing and departing times. The transaction block would look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的演示，事务不是必需的，但在实际应用中，我们想要确保根据航线和出发时间，飞机不会被过度预订。事务块看起来如下所示：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We follow this by setting the associated airplane, returning the schedule record,
    finishing the transaction, and rendering a response with **JavaScript Object Notation**
    (**JSON**) data, like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置相关的飞机，返回时刻表记录，完成事务，并使用**JavaScript对象表示法**（**JSON**）数据渲染响应，如下所示：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The last part of this file is capturing any errors from the previous `try`
    block and exporting the `createSchedule` function, like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的最后部分是捕获之前`try`块中的任何错误，并导出`createSchedule`函数，如下所示：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can create a new file located at `routes/tickets.js` that will serve
    as the route for booking our actual flight. For demonstration purposes, we will
    omit complex functionalities such as determining prices and customer sessions
    and fill in those details with constant values. After creating the file, we would
    load our models at the top of the file, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`routes/tickets.js`中创建一个新的文件，该文件将作为预订实际航班的路由。出于演示目的，我们将省略确定价格和客户会话等复杂功能，并用常量值填充这些细节。创建文件后，我们将在文件顶部加载我们的模型，如下所示：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For our `bookTicket` method, we will need a `scheduleId` and `seat` `POST`
    parameter, in addition to opening a transaction for creating a ticket. Here’s
    how we can add these:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`bookTicket`方法，我们需要一个`scheduleId`和`seat` `POST`参数，以及为创建登机牌打开一个事务。以下是我们可以添加这些内容的示例：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Check to see whether the `FlightSchedule` model exists by executing the following
    code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下代码检查`FlightSchedule`模型是否存在：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s create our new boarding ticket, like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的登机牌，如下所示：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We’ll now set our boarding ticket’s associations and then return the ticket
    while completing the transaction, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置登机牌的关联，并在完成事务的同时返回登机牌，如下所示：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Capture any errors and export the function, like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获任何错误并导出函数，如下所示：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we will want to add a module called `body-parser` that helps transform
    different `req.body` in Express). For more information, visit [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser).
    We can install and add the package to our `package.json` file with the following
    command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望添加一个名为 `body-parser` 的模块，该模块有助于转换 Express 中的不同 `req.body`。更多信息，请访问 [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser)。我们可以使用以下命令安装并将包添加到我们的
    `package.json` 文件中：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our last file to edit would be the `index.js` file within the project’s main
    directory. We will want to add the following module after requiring the express
    module on the first line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要编辑的文件将是项目主目录中的 `index.js` 文件。我们希望在第一行引入 express 模块之后添加以下模块：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Just below the `const models = require("./models");` line, we will want to
    add our new exported functions. Here’s how we do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `const models = require("./models");` 行之下，我们希望添加我们的新导出函数。这是我们的做法：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Just above the first route, `app.get(''/'', …)`, add the following line of
    code for JSON `POST` support:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个路由 `app.get('/', …)` 之上，添加以下代码行以支持 JSON `POST`：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we will want to add the following line of code above the `app.get(''/airplanes/:id'',
    ...)` line for our `createAirplane` route:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望在 `app.get('/airplanes/:id', ...)` 行之上添加以下代码行以创建 `createAirplane` 路由：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we can add our remaining new routes just above the `app.listen(3000,
    ...)` line, like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `app.listen(3000, ...)` 行之上添加我们剩余的新路由，如下所示：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since all of our changes have been committed, we can now run our application
    by executing the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所有的更改都已提交，我们现在可以通过执行以下命令来运行我们的应用程序：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In order to test our application, we can use cURL or any HTTP REST utility
    such as Postman ([https://www.postman.com/](https://www.postman.com/)) or HTTPie
    ([https://httpie.io/](https://httpie.io/)). Let us create a new airplane before
    a flight schedule, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的应用程序，我们可以使用 cURL 或任何 HTTP REST 工具，如 Postman ([https://www.postman.com/](https://www.postman.com/))
    或 HTTPie ([https://httpie.io/](https://httpie.io/))。在创建飞行日程安排之前，让我们创建一架新的飞机，如下所示：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We should see a response similar to this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会看到类似以下响应：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This particular A320 model has up to 150 seats available at a time for customers.
    When we adjust our total number of seats available, our new command would look
    like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的 A320 型号一次最多有 150 个座位可供客户使用。当我们调整可用的总座位数时，我们的新命令将如下所示：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding command should return a response similar to this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令应该返回类似以下内容的响应：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will want to keep the `id` value in mind for the next command when creating
    a schedule:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建日程安排的下一个命令时，我们将想要记住 `id` 值：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The preceding request should result in an error that looks similar to this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的请求应该导致类似以下内容的错误：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We currently do not fly to Chicago’s O’Hare International Airport! The new
    destination will now be Miami using the `MIA` code, as illustrated here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前不飞往芝加哥的奥黑尔国际机场！新的目的地现在将是使用 `MIA` 代码的迈阿密，如下所示：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The response should look similar to this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该类似于以下内容：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the booking request, we will need the previous response’s `id` value and
    a seating assignment, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预订请求，我们需要之前响应的 `id` 值和座位分配，如下所示：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The response would look similar to this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将类似于以下内容：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we were to repeat the previous command, an error message would be shown
    to us indicating that the seat has already been taken, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复执行之前的命令，会显示一个错误消息，提示我们座位已被占用，如下所示：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That wraps up our changes to the *Avalon Airlines* project. We implemented a
    way to create airplanes and new flight schedules and assign boarding tickets with
    transactions. This should complete the requirements for our next investor meeting.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对 *Avalon Airlines* 项目的更改。我们实现了一种创建飞机和新的飞行日程以及使用事务分配登机牌的方法。这应该完成我们下一次投资者会议的要求。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the differences between managed and unmanaged
    transactions, using CLS for global scoping transactions, the supported isolation
    levels, applicable life cycle events, and locking transactions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用 CLS 进行全局作用域事务、支持的隔离级别、适用的生命周期事件和锁定事务，介绍了托管事务和无托管事务之间的区别。
- en: In the next chapter, we will be covering how to handle customized, JSON, and
    **binary large object** (**BLOB**) data directly from Sequelize to the DBMS. The
    following chapter will also contain further instructions on completing the *Avalon
    Airlines* project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何直接从 Sequelize 处理自定义的 JSON 和 **二进制大对象** (**BLOB**) 数据到数据库管理系统（DBMS）。下一章还将包含完成
    *Avalon Airlines* 项目的高级指导。
