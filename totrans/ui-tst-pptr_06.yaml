- en: '*Chapter 6*: Executing and Injecting JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past few chapters, we learned about most of the basic Puppeteer features,
    from creating a browser and a page correctly, to finding elements and interacting
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to get into more powerful tools. In this chapter, we will see
    how Puppeteer gives us the ability to execute JavaScript code in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: It might sound like a hack or a last resort tool. Sometimes it is. But it is
    also a tool that will help us perform actions that are not provided by the Puppeteer
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The communication between the code being executed on the Node side and the code
    being executed in the browser can sometimes be tricky. We will learn how to communicate
    with both sides efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the previous chapter, we will add another tool to our toolbox.
    We are going to run our code on *Checkly*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating handles with JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing local functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our checks with Checkly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to get more out of the page you
    are automating by executing JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will find all the code of this chapter in the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter6` directory. Remember to run `npm install` on that directory
    and then go to the `Chapter6/vuejs-firebase-shopping-cart` directory and run `npm
    install` again.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to implement the code while following this chapter, you can start
    from the code you left in the `Chapter5` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Executing JavaScript code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first question you might ask is: "Why would I need to run JavaScript code?
    Shouldn''t Puppeteer give me all the APIs I need?" Well, yes and no.'
  prefs: []
  type: TYPE_NORMAL
- en: Before getting into the different possible use cases, let's see how this feature
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Variable scopes in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One thing that makes JavaScript so flexible is that functions are first-class
    citizens. You can declare functions, assign them to variables, and pass them as
    an argument. You could even return functions from other functions, like in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That code is pretty fun. `getFunc` returns another function. When we do `getFunc()()`,
    we are calling the function returned by `getFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: This piece of code will print `'Hello world'` in the console. The interesting
    part is that the function returned by `getFunc` is able to keep the variable `word`
    in its scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could even do more complex things, for instance, passing an argument to
    `getFunc`, and then using that argument inside the function that `getFunc` will
    return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That piece of code will print '`Hello world`' and '`Hello mars`'. This is called
    a `getFunc`, the returned function will be bundled together with the string `'world'`
    in the first case, or `'mars'` in the second case.
  prefs: []
  type: TYPE_NORMAL
- en: We won't get into the internals of this feature. But you need to know that **this
    is not how functions work in Puppeteer**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use closures in Puppeteer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have a function that we are passing to the `evaluate` function,
    and that function is using the variable `name`, which is in the scope of the function
    we just created. But this is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable scopes in Puppeteer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Variable scopes in Puppeteer
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the name didn't get to the alert. For us as developers, the
    big issue is that the code looks good. If you look at the code, the code is perfect.
    It's not very different from our previous examples. But something works differently
    there. Once you understand this, you will be able to answer lots of questions
    on Stack Overflow.
  prefs: []
  type: TYPE_NORMAL
- en: First, the signature of `page.evaluate` is `page.evaluate(pageFunction[, ...args])`,
    where `pageFunction` can be a string or a function. The second argument is an
    optional list of values to pass to `pageFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass `evaluate` function. An expression is a statement like the ones
    you can write inside the DevTools console. For instance, a simple string returning
    the `URL` property of the `document` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`page.evaluate` will send the expression `document.URL` to the browser and
    the browser will evaluate it. Once the browser evaluates the expression, it will
    send that back to Puppeteer, and `page.evaluate` will return the result. In this
    case, `about:blank`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expressions are perfect when you want to evaluate simple expressions. But you
    could accomplish the same result using a JavaScript function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, passing an expression is more straightforward, but you will
    be able to write more complex code using functions, and, no less important, you
    will get the autocomplete features of your code editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key concept here is that `page.evaluate` `toString()` to function inside
    a variable. Let''s try that out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the function as a string value in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If Puppeteer takes that function, converts it to a string using `toString`,
    and sends it to the browser, the value of the `name` variable will be lost in
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you send a function to be evaluated inside the browser context, you need
    to make sure that all the values the function uses are already in the browser
    or are being passed as an argument. This is how we can fix our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are passing the `name` variable as part of the `args` argument
    of `evaluate`. Now Puppeteer knows that it has to serialize that function and
    also send `args`. The browser will now be able to execute that function, passing
    those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I renamed the variable name to `n`. It's not required, but this
    practice will help you avoid these kinds of scope mistakes. Now you, and your
    IDE, know that the `n` variable being used in the `alert` function is an argument
    being passed to that function.
  prefs: []
  type: TYPE_NORMAL
- en: This `evaluate` function is available not only in the `page` and `frame` classes
    but also in the `JSHandle` and `ElementHandle` classes. Let's explore how we can
    execute JavaScript code once we've got an `ElementHandle` or a `JSHandle` in Puppeteer.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating handles with JavaScript code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about `ElementHandle` in [*Chapter 4*](B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072),
    *Interacting with a Page*. Let's recap this concept. `ElementHandle` is a variable
    in our code pointing to a `DOM` element inside the page we are automating. Now
    it's time to know that an `ElementHandle` is, in fact, a **JSHandle**.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that `ElementHandle` is a variable pointing to an element in
    the browser, `document.URL`, and a DOM element, like `document.activeElement`,
    is that a DOM element has a visual representation, that's all. So, we can say
    that an `ElementHandle` (a DOM element) is also a `JSHandle` (a JavaScript variable).
    Inheritance 101.
  prefs: []
  type: TYPE_NORMAL
- en: We were using functions like `$` or `$x` to get `ElementHandles`. Now we can
    also use `evaluateHandle`, which works like `evaluate`, but as Puppeteer knows
    that we want a pointer to a variable in the browser, a handle, it will return
    an object that will represent that variable in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our login test. The way we were getting the password input
    was straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But, let''s imagine that the developers want to create a super-secure login
    creating elements dynamically. But, they tell us that they are storing the password
    input in the `window.passwordInput` variable. We could get that input using an
    `evaluateHandle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There, `evaluateHandle` will return a `JSHandle`, which we can convert to an
    `ElementHandle` using the `asElement` function. If you have to find an element
    that you cannot find using a CSS selector or an XPath selector, you now have a
    third tool: you can use a JavaScript function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `evaluateHandle` function is not limited to DOM elements or simple variables.
    You can also return, and even create, objects for later access. You will find
    this code in the `Chapter6/demos.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this, you will see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Evaluate result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate result
  prefs: []
  type: TYPE_NORMAL
- en: In the first `evaluateHandle`, we create an object with a property `count`,
    assign it to a property `counter` in the `window` object, and then return that
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `window` object, we make it clear that we are using a global variable.
    If we declare a variable inside that function, we will lose it after executing
    the function. Although it is not considered a good practice, we could declare
    `counter` as a global variable by changing `window.counter` with just `counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second step, we are learning how to use the `evaluate` function, but
    in the context of a `JSHandle`. The function works in the same way as the `evaluate`
    function in the `page` class. But here, it will pass the `JSHandle` as the first
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see there, the function expects two arguments: `c` and `inc`. But
    we are only passing `3`, which is the second argument, `inc`, because the first
    argument, `c`, is our `JSHandle`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also have a function with no extra arguments. For instance, we could
    hardcode that `3` inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass `JSHandle` objects as arguments to the `evaluate` function
    of the `page` class. So, this would be the equivalent of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This opens the door to many new things we can do with Puppeteer. Let's see some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information from the elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Checking how the page reacts to an action is quite essential. For instance,
    if you add an item to the cart, you would like to check whether the number of
    items count was increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at our `HomePageModel` class, this is how we solved the `getStock`
    function, which helped us check the stock prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We used that code to learn the XPath expression. In the first two lines, we
    were getting the product `div`, and from there, the `stock` element. After that,
    we used the `evaluate` function to get the text of that element.
  prefs: []
  type: TYPE_NORMAL
- en: 'I believe these kinds of functionalities should be part of the Puppeteer API.
    But in the meantime, you can start building your utility functions. We can start
    with a generic function to return the `innerText` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will expect an element as an argument and return the `innerText`
    property. The `innerText` property returns the text content of a `DOM` element,
    including all its descendants. But you could also create new utility functions
    for other common properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`innerHtml` returns the HTML content inside an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outerHTML` returns the HTML content, including the HTML of the element itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to get the `value` of an input element, you will need to use `value``innerText`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check the MDN site for a complete list of element properties ([https://www.hardkoded.com/ui-testing-with-puppeteer/element](https://www.hardkoded.com/ui-testing-with-puppeteer/element)).
    You will also find that some elements have specific properties. For instance,
    an input box has properties such as `disabled` or `checked` when the type is a
    checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to mess with `ElementHandles`, you can also use `page.$eval`.
    The signature of this function is `page.$eval(selector, pageFunction[, ...args])`.
    The page will get the `ElementHandle` using the selector, and then execute `evaluate`,
    passing the `pageFunction` and the `args`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we can replace this line we can find in the `logState` function
    inside the `LoginPageModel.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With this simpler line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This line of code is easier to read because you have the selector on one side
    and the function to execute on the other side. Notice that the `pageFunction`
    must always have the element as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: But using the `evaluate` function is not only about getting information. We
    can change the page behavior, acting on elements.
  prefs: []
  type: TYPE_NORMAL
- en: Acting on elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `evaluate` function to get values from elements and act on those
    elements so that you can **force** specific scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: This might sound hacky, but sometimes all the steps required to get to a particular
    scenario aren't worth the effort. It's like those cooking TV shows, where they
    are baking a cake, and suddenly, they come up with an already baked cake, and
    they show you how to add the cream.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of shortcuts not only save you time, but reduce potential flakiness
    that could come up during a long process, where you need to wait for many things
    to happen before you can act.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first action we will learn about is forcing a `click` action. Wait, don''t
    we have a `click` function in Puppeteer? We do have a `click` function. The good
    thing about the `click` function is that it emulates a user click. But to be a
    real emulation, the element being clicked needs to be visible and actionable (clickable).
    Sometimes we don''t want to run the risk of getting a fail because the element
    was hidden. We can take a shortcut and force a click using the `click` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of calling `el.click()`, we call the `click` function inside the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way as with properties, this method is not only for the `click`
    function. You can use it to force the `blur` event or select a text in an input
    with the `setSelectionRange` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can act on elements not only through functions. You can also set properties.
    For instance, you could disable the email input on the login page programmatically.
    Let''s see that in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get the element, and then we set the disabled property. With this recipe,
    you could also set the `innerText` of an element. For instance, you could change
    a product description with a very long text to see how the page reacts to long
    product titles.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, being "hacky" is what we want to test. Is our site ready for clever
    users?
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing server rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the rise of rich web applications, a new type of bad practice emerged:
    **writing business rules only on the client side**.'
  prefs: []
  type: TYPE_NORMAL
- en: We need important business rules on the server first, and then on the client.
    Let's say that in our cart application, we need to validate that the user has
    been authorized to make purchases. We wrote that business rule, but the only thing
    we did was add an "`is-disabled`" CSS class in the checkout button. If I'm a clever
    user, I could open the developer tools, remove that class, and then click on the
    button. If we don't have the same rule on the server, the user might have easily
    bypassed our business rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write our own "should validate on the server" test. Let''s grab the
    checkbox, remove the CSS class, and try to click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are getting the checkout button, and then we remove the `is-disabled`
    CSS class programmatically. That would enable the button, so then we can click
    it. After that, we should do some validation to check that the business rule was
    enforced on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The `evaluate` function can also help us when we can't find elements using CSS
    selectors or XPath expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Finding elements using JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can find `DOM` elements using CSS selectors in over 90% of cases, even more
    if we use attribute selectors. XPath expressions help us cover another 9% of the
    cases. But there is that 1% where we need something more elaborated. For instance,
    there are properties that are not exposed in a way for a CSS selector to work.
    Let's take the case of input text.
  prefs: []
  type: TYPE_NORMAL
- en: '![An input box in Amazon'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.03_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: An input box in Amazon
  prefs: []
  type: TYPE_NORMAL
- en: If the input box is rendered with the word puppeteer (by rendered, I mean that
    it has the value in the HTML content), the attribute selector `[value=puppeteer]`
    will work. But if the value changes to, for example, *node*, the `[value=node]`
    selector won't work, and the first selector, `[value=puppeteer]`, would still
    return a `DOM` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some properties are not exposed as HTML attributes, so we won''t be able to
    use them on CSS selectors or XPath expressions. For instance, the `IMG` element
    has a property called `naturalWidth`. This property will return the original size
    of the image. With this property, we could write a test to check that all the
    images on our home page are being loaded. If the `naturalWidth` of an image is
    0, it means that the image was not loaded. You can find this code in the test
    called `''Should load all images''` inside the `Chapter6/test/homepage.tests.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we are getting all the IMG elements with `document.querySelectorAll(''IMG'')`.
    Then we need to wrap it inside an `Array.from`, so we can filter those elements.
    And then, we call the `filter` function, asking for elements with a `naturalWidth`
    value: `!e.naturalWidth`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is something important for you to notice. The function we are executing
    using `evaluateHandle` returns a list of elements. But `evaluateHandle` will return
    one element handle. It will return a pointer to that array in the browser. So,
    if we need to get the `length` of that array, we need to call `evaluate` and request
    the `length` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Situations like these are when you need to find a balance. Sometimes it''s
    simpler to have a big `evaluate` function but evaluate everything in one trip.
    In this case, this could have been solved in only one async call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now we are doing everything in one hit. We query the images, we filter them,
    and check for the length.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned how to execute JavaScript code and how to manipulate elements,
    but there is more. We can also use JavaScript code as wait functions.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about many wait functions in [*Chapter 5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087),
    *Waiting for elements and network calls*. We learned to wait for network events,
    for `DOM` elements to be visible or hidden. We also covered many page events we
    can wait for. But in the same way that a CSS selector won't cover 100% of cases,
    and an XPath expression cannot cover all other scenarios, the same happens with
    wait functions.
  prefs: []
  type: TYPE_NORMAL
- en: There are some scenarios where we need something more. Now we have the `waitForFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the signature of the `waitForFunction` function: `page.waitForFunction(pageFunction,
    options, ...args)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the `pageFunction`. It works in the same way as in the
    `evaluate` function. It can be a JavaScript function; it could also be a string;
    it can expect arguments, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument, `args`, is the arguments that can be sent to the function.
    This is an optional list of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'I didn''t forget about the second argument. The second argument is the `options`
    argument. The `options` object has two settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first property is, you guessed it, `timeout`. It has the same defaults
    as we saw in the different wait functions in [*Chapter 5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087),
    *Waiting for elements and network calls*: defaults to 30 seconds, and then you
    change or overwrite the value with `page.setDefaultTimeout(timeout)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second property is the interesting one: the `polling` option. This option
    determines the frequency at which Puppeteer will execute our function. We have
    three possible options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) The default option is `raf`. `requestAnimationFrame`. According to Mozilla,
    the *requestAnimationFrame method tells the browser that you wish to perform an
    animation and requests that the browser calls a specified function to update an
    animation before the next repaint. The method takes a callback as an argument
    to be invoked before the repaint* ([https://www.hardkoded.com/ui-testing-with-puppeteer/raf](https://www.hardkoded.com/ui-testing-with-puppeteer/raf)).
    It is the most frequent polling you can use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) The second option available is `mutation`. This option will use a `MutationObserver`.
    According to Mozilla, *The MutationObserver interface provides the ability to
    watch for changes being made to the DOM tree* ([https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver](https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) The last option is a `number`. This number will be an interval in milliseconds
    at which the function will be executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we talked about finding elements using JavaScript, we mentioned that there
    are many scenarios where CSS selectors or XPath expressions won't be enough. But
    I also think that sometimes an `evaluateHandle` or a `waitForFunction` call will
    be easier to read than a complex XPath expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, for instance, the Packt cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packt cart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Packt cart
  prefs: []
  type: TYPE_NORMAL
- en: When we add a new book to the cart, the cart number is not updated immediately.
    If we look at the **Network** tab, there is a network call to an "**add**" endpoint,
    and after that, the cart is updated.
  prefs: []
  type: TYPE_NORMAL
- en: We can wait for that item number to be updated in many ways. We could wait for
    the items list to be updated using a CSS selector. We could also wait for a network
    response with the URL "**add**". But we could also do something as simple as wait
    for the number to change.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more challenge there. When we add an item to the cart, we need
    to dismiss it. But the popup is moving. The good news is that `waitForFunction`
    **to wait for animations to finish**.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: I thought this would be a simple example, and it turned out to be quite complicated.
    But I think it's great. You will find these kinds of issues in real life, and
    you need to resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to explain the test piece by piece. You will be able to see the entire
    test in the `packpub.tests.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to solve, and it''s something that we, unfortunately,
    see a lot these days, is the cookies notification. Let''s see how we can wait
    for a notification banner using Puppeteer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is go to the page we want to test. Then we might, or might
    not, get the cookies banner. The problem is that the cookies banner might take
    a little while to be shown. So, we wait for the `'.accept_all'` selector, which
    is the `.catch(e => e)`. If we finally get that cookie button, we click on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the cookies banner is dismissed, we need to wait for the page to be ready
    to act. We don''t care which client library the page is using, but it seems that
    it takes a little bit to be ready to act. One of the things I found is that it
    will set the class `empty` to the cart button when the cart is ready. Another
    thing we know is that the `add-to-cart` class. We can add a `Promise.all` and
    wait for those two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This step was easy. We need to wait for the selectors, `.counter.qty.empty`,
    which is the empty cart button, and `.add-to-cart,` which is the **Add to cart**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we need to set up our wait promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This looks complex, but it's not that complex. We are setting up two promises.
    The first promise will resolve when the text (using the `innerText` property)
    of the cart counter, which has the selector `.counter.qty .counter-number`, is
    equal to 1\. We hope it will be resolved at one point in time after we click on
    the first product. There, I added a `trim` function, so we remove any extra spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The second promise is the same as the first one. But it will resolve when the
    cart number is equal to 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our wait promises, it''s time to click on the first product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are grabbing all the **Add to cart** buttons and clicking on the first
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we get to the fun part. We need to wait for the checkout popup to show
    up and finish its fancy animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Pretty scary, right? Let's analyze this function because it's a handy method.
  prefs: []
  type: TYPE_NORMAL
- en: Our `wait for` function needs to be resolved when the checkout popup is visible
    and has stopped moving. How do we know that it stopped moving? Well, we could
    check the element height every 20 milliseconds, and if the height is the same
    after 10 checks, we can assume it stopped moving.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is get the element, grabbing the initial height using
    `getBoundingClientRect`, and set a counter to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have that, we will `await` a `promise`, but it will be resolved inside
    the browser. Inside that `promise`, we will create a function called `stoppedMoving`,
    and we will call it.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will check inside that function is whether the element is
    visible. If it's not, we will call the function again after 20 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Then we check the current height. If the height has changed, we reset the counter,
    and we start over. If it didn't change for the past 10 times, we resolve the promise
    by calling `resolve()`.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do there is to call the same function after 20 milliseconds.
    Eventually, that function will be resolved, or it will fail due to the `waitForFunction`
    timeout.
  prefs: []
  type: TYPE_NORMAL
- en: '**The numbers here are relative. You don''t need to wait 20 milliseconds or
    wait 10 times. You can pick the numbers that will suit you in your example.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know that the popup is opened and is not moving, we can close it using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As simple as calling `click`, we are passing the close button selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can wait for the cart number to be updated to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are awaiting the promise we built before. The promise might have already
    been resolved by the time we get here; we don't care. If the promise is resolved,
    the `await` will resolve immediately. If not, we will wait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we click on a second product and await the second promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we grabbed the second product on the list, clicked on it, and waited for
    the cart number to change to 2\. Again, we don't care if that promise was already
    resolved or not.
  prefs: []
  type: TYPE_NORMAL
- en: If all promises were resolved, there is nothing to assert. We know that everything
    worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: I bet you will need a break after this section. Once you are ready, we will
    see one more thing we can do with functions. We are going to make the browser
    call functions on the Node side.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing local functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Puppeteer, you can not only execute code inside the browser but also make
    calls from the browser back to your Node app. The `exposeFunction` function allows
    us to register Node functions inside the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `exposeFunction` signature: `page.exposeFunction(name, puppeteerFunction)`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is `name`. This will be the function name inside the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`puppeteerFunction` is a function that follows the same style and functionality
    as all the functions we have learned about in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This feature is perfect when it is called from a `MutationObserver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, instead of executing a function over and over, waiting for the
    checkout counter to change, we could create a `MutationObserver` to let us know
    when the value has changed in the HTML Node. Let''s see how the code would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we are declaring an observer, which expects a `callback`
    function. The first argument of that `callback` function will be a list of mutations.
    That mutation has the `target` object, and we can get the `nodeValue` from there.
    You can go to the Mozilla documentation ([https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord](https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord))
    if you want to know the full list of properties of the mutation records.
  prefs: []
  type: TYPE_NORMAL
- en: That observer won't do much. We need to tell it to observe changes in a particular
    element, in our case, an element with the selector `.counter.qty .counter-number`.
    So, we call `observe`, passing the `counter` element, and, as a second argument,
    we will tell the `observe` function what changes we want to listen to. In this
    case, we only care about `characterData` changes, and we also want to listen to
    changes in the `subtree` (child elements). That means text changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, we could make a copy of our previous test and replace `cartIsOnePromise`
    and `cartIsTwoPromise` with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We create a promise, `reachedToTwo`. Inside the promise constructor, we will
    expose a function named `'notifyCartChange'`. The function we will expose there
    will expect one argument, and we will resolve the promise if the argument is equal
    to `'2'`.
  prefs: []
  type: TYPE_NORMAL
- en: That `exposeFunction` function will allow us to call a `notifiyCartChange` inside
    the `MutationObserver` we declared using an `evaluate` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the last step, we replace our old awaits with the new promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes as expected, `notifyCartChange` will be called twice, once
    with the value `'1'` and then with the value `'2'`, and the second call will resolve
    the `reachedToTwo` promise we added at the end of the test.
  prefs: []
  type: TYPE_NORMAL
- en: This might sound like silly, overcomplicated code, but picture all you could
    do with `exposeFunction` and `MutationObserver`. You could test chat apps by listening
    to incoming changes and many other complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Before wrapping up this chapter, it is time to add another tool to our toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Running our checks with Checkly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an extra tool that I want to show you, and you shouldn''t miss the
    chance of trying it out. *Checkly* ([https://www.checklyhq.com/](https://www.checklyhq.com/))
    is a platform that will help you monitor your website. The following screenshot
    shows the *Checkly* website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checkly website'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Checkly website
  prefs: []
  type: TYPE_NORMAL
- en: Once you create an account in *Checkly*, you will be able to upload your tests
    (or checks), and *Checkly* will run those checks every certain number of minutes,
    reporting back. Firstly, it will report whether the check is passing, and secondly,
    it will report the time it took to run.
  prefs: []
  type: TYPE_NORMAL
- en: You will also be able to test your website's API without running a browser.
    This is huge. It's like having your own, personal quality guard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to [https://www.checklyhq.com/](https://www.checklyhq.com/) and start
    our trial. Follow these steps to start using *Checkly*:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you enter your email, phone number, and account name, you will get the
    first dashboard with a few examples, as shown here:![Checkly dashboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.07_B16113.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Checkly dashboard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now delete those two examples and create your own cart test. We can
    create a browser test:![New test dialog
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.08_B16113.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New test dialog
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, name your check `Cart number check`. You can copy the code from the `Chapter6/checkly.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![First check'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.09_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: First check
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have left the browser and the page creation there. Once we have
    copied the code, we can click on the **Run Script** button to check that the code
    is correct. Finally, we will need to pick our data center locations, hit **Save
    Check**, and we will have a platform checking our website's health automatically.
  prefs: []
  type: TYPE_NORMAL
- en: If your team can afford it, *Checkly* will take you to the next level. Now it's
    time to wrap up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered one of the most powerful features of Puppeteer in this chapter. Most
    web automation tools let you run JavaScript code somehow, but Puppeteer makes
    it super easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: We started this chapter by talking about some basic JavaScript concepts. We
    learned about variable scopes and closures. That helped us understand how variables
    and closures work (or don't work) in Puppeteer. If you learned those differences,
    you will be able to answer 20% of the Puppeteer questions on Stack Overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned about `JSHandles` and `ElementHandles`. You don't see these
    classes being used a lot by the community, but they are very helpful if you know
    how to use them, and now you know.
  prefs: []
  type: TYPE_NORMAL
- en: The `waitForFunction` completed our "wait" toolbox. You will use that wait function
    a lot. We also learned how to expose functions and listen to HTML changes using
    `MutationObserver`. Exposing functions and listening to HTML changes is not used
    much in UI testing, but it is an excellent tool for web scraping, a great topic
    we will cover in [*Chapter 9*](B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156),
    *Scraping tools*.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we have completed the basics of Puppeteer. You now have most
    of the tools you need to start doing end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you are as excited with *Checkly* as I was when I saw this platform for
    the very first time. *Checkly* is a dashboard that will help not only the QA team
    but also the development team. It will help your team find issues and even find
    new opportunities to improve your site's performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see some features you wouldn't expect from an automation
    tool. We are going to see how to generate content using Puppeteer.
  prefs: []
  type: TYPE_NORMAL
