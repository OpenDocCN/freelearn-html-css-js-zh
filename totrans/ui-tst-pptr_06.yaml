- en: '*Chapter 6*: Executing and Injecting JavaScript'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：执行和注入JavaScript'
- en: In the past few chapters, we learned about most of the basic Puppeteer features,
    from creating a browser and a page correctly, to finding elements and interacting
    with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们学习了大多数基本Puppeteer功能，从正确创建浏览器和页面，到查找元素并与它们交互。
- en: Now it's time to get into more powerful tools. In this chapter, we will see
    how Puppeteer gives us the ability to execute JavaScript code in the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入了解更强大的工具了。在本章中，我们将了解Puppeteer如何让我们能够在浏览器中执行JavaScript代码。
- en: It might sound like a hack or a last resort tool. Sometimes it is. But it is
    also a tool that will help us perform actions that are not provided by the Puppeteer
    API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能像是一种黑客手段或最后的手段工具。有时确实是。但这也是一个可以帮助我们执行Puppeteer API未提供的操作的工具。
- en: The communication between the code being executed on the Node side and the code
    being executed in the browser can sometimes be tricky. We will learn how to communicate
    with both sides efficiently.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node端执行和浏览器中执行的代码之间的通信有时可能很棘手。我们将学习如何高效地与双方进行通信。
- en: As we did in the previous chapter, we will add another tool to our toolbox.
    We are going to run our code on *Checkly*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中所做的那样，我们将向我们的工具箱中添加另一个工具。我们将在*Checkly*上运行我们的代码。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Executing JavaScript code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行JavaScript代码
- en: Manipulating handles with JavaScript code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript代码操作句柄
- en: Waiting for functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待函数
- en: Exposing local functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示本地函数
- en: Running our checks with Checkly
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Checkly运行我们的检查
- en: By the end of this chapter, you will be able to get more out of the page you
    are automating by executing JavaScript code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够通过执行JavaScript代码从你正在自动化的页面中获得更多。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code of this chapter in the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter6` directory. Remember to run `npm install` on that directory
    and then go to the `Chapter6/vuejs-firebase-shopping-cart` directory and run `npm
    install` again.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库（[https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer)）的`Chapter6`目录下找到本章的所有代码。请记住，在那个目录上运行`npm
    install`，然后进入`Chapter6/vuejs-firebase-shopping-cart`目录并再次运行`npm install`。
- en: If you want to implement the code while following this chapter, you can start
    from the code you left in the `Chapter5` directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在遵循本章内容的同时实现代码，你可以从`Chapter5`目录中留下的代码开始。
- en: Let's get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Executing JavaScript code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行JavaScript代码
- en: 'The first question you might ask is: "Why would I need to run JavaScript code?
    Shouldn''t Puppeteer give me all the APIs I need?" Well, yes and no.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问的第一个问题是：“我为什么要运行JavaScript代码？Puppeteer不应该给我所有我需要的API吗？”嗯，是的，也不完全是。
- en: Before getting into the different possible use cases, let's see how this feature
    works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨不同的可能用例之前，让我们看看这个功能是如何工作的。
- en: Variable scopes in JavaScript
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的变量作用域
- en: 'One thing that makes JavaScript so flexible is that functions are first-class
    citizens. You can declare functions, assign them to variables, and pass them as
    an argument. You could even return functions from other functions, like in this
    example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使JavaScript如此灵活的一点是函数是一等公民。你可以声明函数，将它们分配给变量，并将它们作为参数传递。你甚至可以从其他函数中返回函数，就像这个例子一样：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That code is pretty fun. `getFunc` returns another function. When we do `getFunc()()`,
    we are calling the function returned by `getFunc`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码很有趣。`getFunc`返回另一个函数。当我们执行`getFunc()()`时，我们正在调用`getFunc`返回的函数。
- en: This piece of code will print `'Hello world'` in the console. The interesting
    part is that the function returned by `getFunc` is able to keep the variable `word`
    in its scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在控制台打印出`'Hello world'`。有趣的部分在于，`getFunc`返回的函数能够在其作用域内保持变量`word`。
- en: 'You could even do more complex things, for instance, passing an argument to
    `getFunc`, and then using that argument inside the function that `getFunc` will
    return:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以做一些更复杂的事情，例如，将一个参数传递给`getFunc`，然后在`getFunc`将返回的函数内部使用该参数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That piece of code will print '`Hello world`' and '`Hello mars`'. This is called
    a `getFunc`, the returned function will be bundled together with the string `'world'`
    in the first case, or `'mars'` in the second case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印出`'Hello world'`和`'Hello mars'`。这被称为`getFunc`，在第一种情况下，返回的函数将与字符串`'world'`捆绑在一起，在第二种情况下，与`'mars'`捆绑在一起。
- en: We won't get into the internals of this feature. But you need to know that **this
    is not how functions work in Puppeteer**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这个功能的内部。但你需要知道，**这并不是Puppeteer中函数的工作方式**。
- en: 'Let''s try to use closures in Puppeteer:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在Puppeteer中使用闭包：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, we have a function that we are passing to the `evaluate` function,
    and that function is using the variable `name`, which is in the scope of the function
    we just created. But this is what we get:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个传递给`evaluate`函数的函数，该函数正在使用变量`name`，该变量在我们刚刚创建的函数的作用域内。但这就是我们得到的结果：
- en: '![Variable scopes in Puppeteer'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![Puppeteer中的变量作用域'
- en: '](img/Figure_6.01_B16113.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B16113.jpg)'
- en: Variable scopes in Puppeteer
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer中的变量作用域
- en: As you can see, the name didn't get to the alert. For us as developers, the
    big issue is that the code looks good. If you look at the code, the code is perfect.
    It's not very different from our previous examples. But something works differently
    there. Once you understand this, you will be able to answer lots of questions
    on Stack Overflow.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，名称没有传递到alert中。对我们这些开发者来说，一个重大问题是代码看起来很好。如果你看代码，代码是完美的。它与我们的先前的例子没有太大不同。但那里有些不同的地方。一旦你理解了这一点，你将能够回答Stack
    Overflow上的许多问题。
- en: First, the signature of `page.evaluate` is `page.evaluate(pageFunction[, ...args])`,
    where `pageFunction` can be a string or a function. The second argument is an
    optional list of values to pass to `pageFunction`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`page.evaluate`的签名是`page.evaluate(pageFunction[, ...args])`，其中`pageFunction`可以是字符串或函数。第二个参数是传递给`pageFunction`的可选值列表。
- en: 'You can pass `evaluate` function. An expression is a statement like the ones
    you can write inside the DevTools console. For instance, a simple string returning
    the `URL` property of the `document` object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以传递`evaluate`函数。表达式是像你可以在DevTools控制台中编写的语句一样的东西。例如，一个简单的字符串，返回`document`对象的`URL`属性：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`page.evaluate` will send the expression `document.URL` to the browser and
    the browser will evaluate it. Once the browser evaluates the expression, it will
    send that back to Puppeteer, and `page.evaluate` will return the result. In this
    case, `about:blank`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`page.evaluate`会将表达式`document.URL`发送到浏览器，浏览器将评估它。一旦浏览器评估了表达式，它将把它发送回Puppeteer，`page.evaluate`将返回结果。在这种情况下，`about:blank`。'
- en: 'Expressions are perfect when you want to evaluate simple expressions. But you
    could accomplish the same result using a JavaScript function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想评估简单的表达式时，表达式是完美的。但你可以使用JavaScript函数达到相同的结果：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, passing an expression is more straightforward, but you will
    be able to write more complex code using functions, and, no less important, you
    will get the autocomplete features of your code editor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，传递表达式更为直接，但你可以使用函数编写更复杂的代码，而且，同样重要的是，你将获得代码编辑器的自动完成功能。
- en: 'The key concept here is that `page.evaluate` `toString()` to function inside
    a variable. Let''s try that out:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键概念是使用`page.evaluate` `toString()`将函数放入变量中。让我们试试看：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will print the function as a string value in the console:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台中打印出函数的字符串值：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If Puppeteer takes that function, converts it to a string using `toString`,
    and sends it to the browser, the value of the `name` variable will be lost in
    the process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Puppeteer接收这个函数，使用`toString`将其转换为字符串，并发送到浏览器，那么`name`变量的值在这个过程中就会丢失。
- en: 'When you send a function to be evaluated inside the browser context, you need
    to make sure that all the values the function uses are already in the browser
    or are being passed as an argument. This is how we can fix our code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将函数发送到浏览器上下文中进行评估时，你需要确保函数使用的所有值已经在浏览器中或作为参数传递。这就是我们可以修复我们代码的方法：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, we are passing the `name` variable as part of the `args` argument
    of `evaluate`. Now Puppeteer knows that it has to serialize that function and
    also send `args`. The browser will now be able to execute that function, passing
    those arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们将`name`变量作为`evaluate`函数的`args`参数的一部分传递。现在Puppeteer知道它必须序列化该函数并也发送`args`。现在浏览器将能够执行该函数，并传递这些参数。
- en: Tip
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that I renamed the variable name to `n`. It's not required, but this
    practice will help you avoid these kinds of scope mistakes. Now you, and your
    IDE, know that the `n` variable being used in the `alert` function is an argument
    being passed to that function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我将变量名重命名为`n`。这不是必需的，但这个做法将帮助你避免这类作用域错误。现在你，以及你的IDE，都知道在`alert`函数中使用的`n`变量是该函数传递的参数。
- en: This `evaluate` function is available not only in the `page` and `frame` classes
    but also in the `JSHandle` and `ElementHandle` classes. Let's explore how we can
    execute JavaScript code once we've got an `ElementHandle` or a `JSHandle` in Puppeteer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`evaluate`函数不仅可在`page`和`frame`类中使用，也可在`JSHandle`和`ElementHandle`类中使用。让我们探索一下，一旦我们在Puppeteer中获得了`ElementHandle`或`JSHandle`，我们如何执行JavaScript代码。
- en: Manipulating handles with JavaScript code
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript代码操作控件
- en: We talked about `ElementHandle` in [*Chapter 4*](B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072),
    *Interacting with a Page*. Let's recap this concept. `ElementHandle` is a variable
    in our code pointing to a `DOM` element inside the page we are automating. Now
    it's time to know that an `ElementHandle` is, in fact, a **JSHandle**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072)中讨论了`ElementHandle`，*与页面交互*。让我们回顾一下这个概念。`ElementHandle`是我们代码中的一个变量，指向我们正在自动化的页面内的`DOM`元素。现在，我们需要知道`ElementHandle`实际上是一个**JSHandle**。
- en: In the same way that `ElementHandle` is a variable pointing to an element in
    the browser, `document.URL`, and a DOM element, like `document.activeElement`,
    is that a DOM element has a visual representation, that's all. So, we can say
    that an `ElementHandle` (a DOM element) is also a `JSHandle` (a JavaScript variable).
    Inheritance 101.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ElementHandle`是一个指向浏览器中元素的变量，`document.URL`和DOM元素，如`document.activeElement`是一个DOM元素有视觉表示，那只是全部。因此，我们可以说`ElementHandle`（一个DOM元素）也是一个`JSHandle`（一个JavaScript变量）。继承101。
- en: We were using functions like `$` or `$x` to get `ElementHandles`. Now we can
    also use `evaluateHandle`, which works like `evaluate`, but as Puppeteer knows
    that we want a pointer to a variable in the browser, a handle, it will return
    an object that will represent that variable in the browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用像`$`或`$x`这样的函数来获取`ElementHandles`。现在我们也可以使用`evaluateHandle`，它的工作方式与`evaluate`相同，但Puppeteer知道我们想要一个指向浏览器中变量的指针，一个句柄，因此它将返回一个对象，该对象将代表浏览器中的那个变量。
- en: 'Let''s go back to our login test. The way we were getting the password input
    was straightforward:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的登录测试。我们获取密码输入的方式很简单：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But, let''s imagine that the developers want to create a super-secure login
    creating elements dynamically. But, they tell us that they are storing the password
    input in the `window.passwordInput` variable. We could get that input using an
    `evaluateHandle`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，让我们想象一下，开发者想要创建一个超级安全的动态创建元素的登录。但是，他们告诉我们他们正在将密码输入存储在`window.passwordInput`变量中。我们可以使用`evaluateHandle`获取该输入：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There, `evaluateHandle` will return a `JSHandle`, which we can convert to an
    `ElementHandle` using the `asElement` function. If you have to find an element
    that you cannot find using a CSS selector or an XPath selector, you now have a
    third tool: you can use a JavaScript function.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，`evaluateHandle`将返回一个`JSHandle`，我们可以使用`asElement`函数将其转换为`ElementHandle`。如果你必须找到无法使用CSS选择器或XPath选择器找到的元素，你现在有了第三个工具：你可以使用一个JavaScript函数。
- en: 'The `evaluateHandle` function is not limited to DOM elements or simple variables.
    You can also return, and even create, objects for later access. You will find
    this code in the `Chapter6/demos.js` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluateHandle`函数不仅限于DOM元素或简单变量。你还可以返回，甚至创建对象以供以后访问。你将在`Chapter6/demos.js`文件中找到此代码：'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you run this, you will see this result:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你会看到这个结果：
- en: '![Evaluate result'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![评估结果'
- en: '](img/Figure_6.02_B16113.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.02_B16113.jpg)'
- en: Evaluate result
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 评估结果
- en: In the first `evaluateHandle`, we create an object with a property `count`,
    assign it to a property `counter` in the `window` object, and then return that
    object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`evaluateHandle`中，我们创建一个具有`count`属性的对象，将其分配给`window`对象中的`counter`属性，然后返回该对象。
- en: 'By using the `window` object, we make it clear that we are using a global variable.
    If we declare a variable inside that function, we will lose it after executing
    the function. Although it is not considered a good practice, we could declare
    `counter` as a global variable by changing `window.counter` with just `counter`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`window`对象，我们清楚地表明我们正在使用一个全局变量。如果我们在这个函数内部声明一个变量，我们将在执行函数后丢失它。尽管这不是一个好的做法，但我们可以通过将`window.counter`改为`counter`来将`counter`声明为全局变量：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the second step, we are learning how to use the `evaluate` function, but
    in the context of a `JSHandle`. The function works in the same way as the `evaluate`
    function in the `page` class. But here, it will pass the `JSHandle` as the first
    argument:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们学习如何使用`evaluate`函数，但在这个`JSHandle`的上下文中。该函数的工作方式与`page`类中的`evaluate`函数相同。但在这里，它将`JSHandle`作为第一个参数传递：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see there, the function expects two arguments: `c` and `inc`. But
    we are only passing `3`, which is the second argument, `inc`, because the first
    argument, `c`, is our `JSHandle`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该函数期望两个参数：`c`和`inc`。但我们只传递了`3`，这是第二个参数`inc`，因为第一个参数`c`是我们的`JSHandle`。
- en: 'We could also have a function with no extra arguments. For instance, we could
    hardcode that `3` inside the function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以有一个没有额外参数的函数。例如，我们可以在函数中硬编码`3`：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also pass `JSHandle` objects as arguments to the `evaluate` function
    of the `page` class. So, this would be the equivalent of the previous example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`JSHandle`对象作为参数传递给`page`类的`evaluate`函数。所以，这将等同于前面的例子：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This opens the door to many new things we can do with Puppeteer. Let's see some
    examples.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们打开了使用Puppeteer可以做很多事情的大门。让我们看看一些例子。
- en: Getting information from the elements
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从元素获取信息
- en: Checking how the page reacts to an action is quite essential. For instance,
    if you add an item to the cart, you would like to check whether the number of
    items count was increased.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 检查页面对动作的反应是非常关键的。例如，如果你向购物车添加一个项目，你希望检查项目数量是否增加。
- en: 'If we take a look at our `HomePageModel` class, this is how we solved the `getStock`
    function, which helped us check the stock prices:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看我们的`HomePageModel`类，这就是我们解决`getStock`函数的方法，它帮助我们检查股票价格：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We used that code to learn the XPath expression. In the first two lines, we
    were getting the product `div`, and from there, the `stock` element. After that,
    we used the `evaluate` function to get the text of that element.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这段代码来学习XPath表达式。在前两行中，我们正在获取产品`div`，然后从那里获取`stock`元素。之后，我们使用`evaluate`函数来获取该元素的文本。
- en: 'I believe these kinds of functionalities should be part of the Puppeteer API.
    But in the meantime, you can start building your utility functions. We can start
    with a generic function to return the `innerText` value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这些功能应该成为Puppeteer API的一部分。但与此同时，你可以开始构建你的实用函数。我们可以从一个返回`innerText`值的通用函数开始：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This function will expect an element as an argument and return the `innerText`
    property. The `innerText` property returns the text content of a `DOM` element,
    including all its descendants. But you could also create new utility functions
    for other common properties:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将期望一个元素作为参数，并返回`innerText`属性。`innerText`属性返回`DOM`元素的文本内容，包括所有后代元素。但你也可以为其他常见属性创建新的实用函数：
- en: '`innerHtml` returns the HTML content inside an element.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innerHtml`返回元素内的HTML内容。'
- en: '`outerHTML` returns the HTML content, including the HTML of the element itself.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outerHTML`返回包括元素本身的HTML内容。'
- en: If you want to get the `value` of an input element, you will need to use `value``innerText`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要获取输入元素的`value`，你需要使用`value`和`innerText`。
- en: You can check the MDN site for a complete list of element properties ([https://www.hardkoded.com/ui-testing-with-puppeteer/element](https://www.hardkoded.com/ui-testing-with-puppeteer/element)).
    You will also find that some elements have specific properties. For instance,
    an input box has properties such as `disabled` or `checked` when the type is a
    checkbox.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在MDN网站上查看元素属性的完整列表（[https://www.hardkoded.com/ui-testing-with-puppeteer/element](https://www.hardkoded.com/ui-testing-with-puppeteer/element)）。你还会发现一些元素具有特定的属性。例如，当类型是复选框时，输入框有`disabled`或`checked`属性。
- en: If you don't want to mess with `ElementHandles`, you can also use `page.$eval`.
    The signature of this function is `page.$eval(selector, pageFunction[, ...args])`.
    The page will get the `ElementHandle` using the selector, and then execute `evaluate`,
    passing the `pageFunction` and the `args`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想与`ElementHandles`打交道，你也可以使用`page.$eval`。这个函数的签名是`page.$eval(selector, pageFunction[,
    ...args])`。页面将使用选择器获取`ElementHandle`，然后执行`evaluate`，传递`pageFunction`和`args`。
- en: 'With this in mind, we can replace this line we can find in the `logState` function
    inside the `LoginPageModel.js` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，我们可以替换在`LoginPageModel.js`文件中的`logState`函数内的这一行：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this simpler line of code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用更简单的代码行：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This line of code is easier to read because you have the selector on one side
    and the function to execute on the other side. Notice that the `pageFunction`
    must always have the element as the first argument.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码更容易阅读，因为你在一边有选择器，另一边有要执行的函数。注意，`pageFunction`必须始终将元素作为第一个参数。
- en: But using the `evaluate` function is not only about getting information. We
    can change the page behavior, acting on elements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用`evaluate`函数不仅是为了获取信息。我们还可以改变页面行为，对元素进行操作。
- en: Acting on elements
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对元素进行操作
- en: You can use the `evaluate` function to get values from elements and act on those
    elements so that you can **force** specific scenarios.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`evaluate`函数从元素中获取值并对这些元素进行操作，以便您可以**强制**特定的场景。
- en: This might sound hacky, but sometimes all the steps required to get to a particular
    scenario aren't worth the effort. It's like those cooking TV shows, where they
    are baking a cake, and suddenly, they come up with an already baked cake, and
    they show you how to add the cream.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像黑客式的方法，但有时到达特定场景所需的步骤不值得付出努力。这就像那些烹饪电视节目，他们在烘焙蛋糕，突然他们拿出一个已经烤好的蛋糕，然后向你展示如何添加奶油。
- en: These kinds of shortcuts not only save you time, but reduce potential flakiness
    that could come up during a long process, where you need to wait for many things
    to happen before you can act.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的快捷方式不仅节省了您的时间，还减少了在需要等待许多事情发生才能采取行动的长时间过程中可能出现的潜在问题。
- en: 'The first action we will learn about is forcing a `click` action. Wait, don''t
    we have a `click` function in Puppeteer? We do have a `click` function. The good
    thing about the `click` function is that it emulates a user click. But to be a
    real emulation, the element being clicked needs to be visible and actionable (clickable).
    Sometimes we don''t want to run the risk of getting a fail because the element
    was hidden. We can take a shortcut and force a click using the `click` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习的第一项操作是强制执行`click`操作。等等，Puppeteer中不是有`click`函数吗？我们确实有`click`函数。`click`函数的好处是它模拟了用户点击。但为了实现真正的模拟，被点击的元素需要是可见的并且可操作的（可点击的）。有时我们不想冒元素隐藏导致测试失败的风险。我们可以采取捷径，使用`click`函数强制点击：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, instead of calling `el.click()`, we call the `click` function inside the
    browser.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是调用`el.click()`，而是在浏览器内部调用`click`函数。
- en: In the same way as with properties, this method is not only for the `click`
    function. You can use it to force the `blur` event or select a text in an input
    with the `setSelectionRange` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与属性一样，这种方法不仅适用于`click`函数。您可以使用它强制`blur`事件或使用`setSelectionRange`函数在输入框中选择文本。
- en: 'You can act on elements not only through functions. You can also set properties.
    For instance, you could disable the email input on the login page programmatically.
    Let''s see that in action:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅可以通过函数对元素进行操作。您还可以设置属性。例如，您可以通过编程方式禁用登录页面上的电子邮件输入。让我们看看这是如何实现的：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we get the element, and then we set the disabled property. With this recipe,
    you could also set the `innerText` of an element. For instance, you could change
    a product description with a very long text to see how the page reacts to long
    product titles.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取元素，然后设置禁用属性。使用这个方法，您也可以设置元素的`innerText`。例如，您可以将一个非常长的产品描述更改为查看页面如何对长产品标题做出反应。
- en: Sometimes, being "hacky" is what we want to test. Is our site ready for clever
    users?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要测试的是“黑客式”的方法。我们的网站是否准备好应对聪明的用户？
- en: Enforcing server rules
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行服务器规则
- en: 'With the rise of rich web applications, a new type of bad practice emerged:
    **writing business rules only on the client side**.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随着丰富网络应用程序的兴起，出现了一种新的不良做法：**仅在客户端编写业务规则**。
- en: We need important business rules on the server first, and then on the client.
    Let's say that in our cart application, we need to validate that the user has
    been authorized to make purchases. We wrote that business rule, but the only thing
    we did was add an "`is-disabled`" CSS class in the checkout button. If I'm a clever
    user, I could open the developer tools, remove that class, and then click on the
    button. If we don't have the same rule on the server, the user might have easily
    bypassed our business rule.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要在服务器上编写重要的业务规则，然后是客户端。假设在我们的购物车应用程序中，我们需要验证用户是否有权进行购买。我们编写了那个业务规则，但我们所做的只是添加了一个"`is-disabled`"
    CSS类到结算按钮上。如果我是聪明的用户，我就可以打开开发者工具，移除那个类，然后点击按钮。如果我们服务器上没有相同的规则，用户可能会轻易绕过我们的业务规则。
- en: 'We can write our own "should validate on the server" test. Let''s grab the
    checkbox, remove the CSS class, and try to click on it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写自己的“应在服务器上验证”测试。让我们获取复选框，移除CSS类，然后尝试点击它：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are getting the checkout button, and then we remove the `is-disabled`
    CSS class programmatically. That would enable the button, so then we can click
    it. After that, we should do some validation to check that the business rule was
    enforced on the server side.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取结算按钮，然后以编程方式移除`is-disabled` CSS类。这将启用按钮，然后我们可以点击它。之后，我们应该进行一些验证，以检查业务规则是否在服务器端得到执行。
- en: The `evaluate` function can also help us when we can't find elements using CSS
    selectors or XPath expressions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们无法使用CSS选择器或XPath表达式找到元素时，`evaluate` 函数也可以帮助我们。
- en: Finding elements using JavaScript
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript查找元素
- en: We can find `DOM` elements using CSS selectors in over 90% of cases, even more
    if we use attribute selectors. XPath expressions help us cover another 9% of the
    cases. But there is that 1% where we need something more elaborated. For instance,
    there are properties that are not exposed in a way for a CSS selector to work.
    Let's take the case of input text.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用CSS选择器在90%以上的情况下找到 `DOM` 元素，如果使用属性选择器，则更多。XPath表达式帮助我们覆盖另外9%的情况。但是，还有1%的情况我们需要更详细的方法。例如，有些属性没有以CSS选择器可以工作的方式暴露出来。让我们以输入文本的情况为例。
- en: '![An input box in Amazon'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![亚马逊中的输入框'
- en: '](img/Figure_6.03_B16113.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.03_B16113.jpg)'
- en: An input box in Amazon
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊中的输入框
- en: If the input box is rendered with the word puppeteer (by rendered, I mean that
    it has the value in the HTML content), the attribute selector `[value=puppeteer]`
    will work. But if the value changes to, for example, *node*, the `[value=node]`
    selector won't work, and the first selector, `[value=puppeteer]`, would still
    return a `DOM` element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入框被渲染为单词puppeteer（这里的渲染指的是它在HTML内容中有值），属性选择器 `[value=puppeteer]` 将会起作用。但如果值变为，例如，*node*，则
    `[value=node]` 选择器将不会工作，而第一个选择器 `[value=puppeteer]` 仍然会返回一个 `DOM` 元素。
- en: 'Some properties are not exposed as HTML attributes, so we won''t be able to
    use them on CSS selectors or XPath expressions. For instance, the `IMG` element
    has a property called `naturalWidth`. This property will return the original size
    of the image. With this property, we could write a test to check that all the
    images on our home page are being loaded. If the `naturalWidth` of an image is
    0, it means that the image was not loaded. You can find this code in the test
    called `''Should load all images''` inside the `Chapter6/test/homepage.tests.js`
    file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性没有作为HTML属性暴露，因此我们无法在CSS选择器或XPath表达式中使用它们。例如，`IMG` 元素有一个名为 `naturalWidth`
    的属性。这个属性将返回图像的原始大小。使用这个属性，我们可以编写一个测试来检查我们主页上的所有图像是否正在加载。如果一个图像的 `naturalWidth`
    为0，这意味着该图像没有加载。你可以在 `Chapter6/test/homepage.tests.js` 文件中的测试 `'Should load all
    images'` 中找到此代码：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this test, we are getting all the IMG elements with `document.querySelectorAll(''IMG'')`.
    Then we need to wrap it inside an `Array.from`, so we can filter those elements.
    And then, we call the `filter` function, asking for elements with a `naturalWidth`
    value: `!e.naturalWidth`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用 `document.querySelectorAll('IMG')` 获取所有的IMG元素。然后我们需要将其包裹在 `Array.from`
    中，这样我们就可以过滤这些元素。然后我们调用 `filter` 函数，要求具有 `naturalWidth` 值的元素：`!e.naturalWidth`。
- en: Here is something important for you to notice. The function we are executing
    using `evaluateHandle` returns a list of elements. But `evaluateHandle` will return
    one element handle. It will return a pointer to that array in the browser. So,
    if we need to get the `length` of that array, we need to call `evaluate` and request
    the `length` property.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的事情需要你注意。我们使用 `evaluateHandle` 执行的函数返回一个元素列表。但 `evaluateHandle` 将返回一个元素句柄。它将返回指向浏览器中该数组的指针。因此，如果我们需要获取该数组的
    `length`，我们需要调用 `evaluate` 并请求 `length` 属性。
- en: 'Situations like these are when you need to find a balance. Sometimes it''s
    simpler to have a big `evaluate` function but evaluate everything in one trip.
    In this case, this could have been solved in only one async call:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下，你需要找到一个平衡点。有时拥有一个大的 `evaluate` 函数但一次性完成所有操作会更简单。在这种情况下，这可以通过一个异步调用来解决：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we are doing everything in one hit. We query the images, we filter them,
    and check for the length.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在一次性完成所有操作。我们查询图像，过滤它们，并检查长度。
- en: We've learned how to execute JavaScript code and how to manipulate elements,
    but there is more. We can also use JavaScript code as wait functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何执行JavaScript代码以及如何操作元素，但还有更多。我们还可以将JavaScript代码用作等待函数。
- en: Waiting for functions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待函数
- en: We learned about many wait functions in [*Chapter 5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087),
    *Waiting for elements and network calls*. We learned to wait for network events,
    for `DOM` elements to be visible or hidden. We also covered many page events we
    can wait for. But in the same way that a CSS selector won't cover 100% of cases,
    and an XPath expression cannot cover all other scenarios, the same happens with
    wait functions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第五章*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087)，“等待元素和网络调用”中学习了关于许多等待函数的内容。我们学习了等待网络事件、等待`DOM`元素可见或隐藏。我们还涵盖了我们可以等待的许多页面事件。但就像CSS选择器不能涵盖所有情况，XPath表达式也不能涵盖所有其他场景一样，等待函数也是如此。
- en: There are some scenarios where we need something more. Now we have the `waitForFunction`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景我们需要更多。现在我们有`waitForFunction`。
- en: 'This is the signature of the `waitForFunction` function: `page.waitForFunction(pageFunction,
    options, ...args)`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`waitForFunction`函数的签名：`page.waitForFunction(pageFunction, options, ...args)`。
- en: The first argument is the `pageFunction`. It works in the same way as in the
    `evaluate` function. It can be a JavaScript function; it could also be a string;
    it can expect arguments, and so on.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`pageFunction`。它的工作方式与`evaluate`函数相同。它可以是JavaScript函数；它也可以是字符串；它可以期望参数，等等。
- en: The third argument, `args`, is the arguments that can be sent to the function.
    This is an optional list of values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数`args`是可以发送给函数的参数。这是一个可选的值列表。
- en: 'I didn''t forget about the second argument. The second argument is the `options`
    argument. The `options` object has two settings:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有忘记第二个参数。第二个参数是`options`参数。`options`对象有两个设置：
- en: 'The first property is, you guessed it, `timeout`. It has the same defaults
    as we saw in the different wait functions in [*Chapter 5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087),
    *Waiting for elements and network calls*: defaults to 30 seconds, and then you
    change or overwrite the value with `page.setDefaultTimeout(timeout)`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个属性是，正如你所猜到的，是`timeout`。它与我们看到的[*第五章*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087)中不同等待函数的默认值相同：默认为30秒，然后你可以使用`page.setDefaultTimeout(timeout)`更改或覆盖该值。
- en: 'The second property is the interesting one: the `polling` option. This option
    determines the frequency at which Puppeteer will execute our function. We have
    three possible options:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个属性是很有趣的一个：`polling`选项。这个选项决定了Puppeteer将执行我们的函数的频率。我们有三种可能的选择：
- en: a) The default option is `raf`. `requestAnimationFrame`. According to Mozilla,
    the *requestAnimationFrame method tells the browser that you wish to perform an
    animation and requests that the browser calls a specified function to update an
    animation before the next repaint. The method takes a callback as an argument
    to be invoked before the repaint* ([https://www.hardkoded.com/ui-testing-with-puppeteer/raf](https://www.hardkoded.com/ui-testing-with-puppeteer/raf)).
    It is the most frequent polling you can use.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 默认选项是`raf`。`requestAnimationFrame`。根据Mozilla，*`requestAnimationFrame`方法告诉浏览器你希望执行动画，并请求浏览器在下次重绘之前调用指定的函数来更新动画。该方法接受一个回调作为参数，在重绘之前调用*
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/raf](https://www.hardkoded.com/ui-testing-with-puppeteer/raf))。这是你可以使用的最频繁的轮询。
- en: b) The second option available is `mutation`. This option will use a `MutationObserver`.
    According to Mozilla, *The MutationObserver interface provides the ability to
    watch for changes being made to the DOM tree* ([https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver](https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver)).
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 可用的第二个选项是`mutation`。这个选项将使用`MutationObserver`。根据Mozilla，*`MutationObserver`接口提供了监视DOM树变化的能力*
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver](https://www.hardkoded.com/ui-testing-with-puppeteer/MutationObserver))。
- en: c) The last option is a `number`. This number will be an interval in milliseconds
    at which the function will be executed.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 最后一个选项是一个`number`。这个数字将是一个函数执行的毫秒间隔。
- en: When we talked about finding elements using JavaScript, we mentioned that there
    are many scenarios where CSS selectors or XPath expressions won't be enough. But
    I also think that sometimes an `evaluateHandle` or a `waitForFunction` call will
    be easier to read than a complex XPath expression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论使用JavaScript查找元素时，我们提到有许多场景CSS选择器或XPath表达式不足以满足需求。但我认为，有时`evaluateHandle`或`waitForFunction`调用比复杂的XPath表达式更容易阅读。
- en: 'Let''s take, for instance, the Packt cart:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Packt购物车为例：
- en: '![Packt cart'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![Packt购物车'
- en: '](img/Figure_6.04_B16113.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.04_B16113.jpg)'
- en: Packt cart
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Packt购物车
- en: When we add a new book to the cart, the cart number is not updated immediately.
    If we look at the **Network** tab, there is a network call to an "**add**" endpoint,
    and after that, the cart is updated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向购物车添加新书时，购物车数量不会立即更新。如果我们查看**网络**标签，会看到一个网络调用到“**添加**”端点，然后购物车才会更新。
- en: We can wait for that item number to be updated in many ways. We could wait for
    the items list to be updated using a CSS selector. We could also wait for a network
    response with the URL "**add**". But we could also do something as simple as wait
    for the number to change.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式等待项目数量更新。我们可以等待项目列表通过CSS选择器更新。我们也可以等待带有URL“**添加**”的网络响应。但我们也可以简单地等待数字变化。
- en: There is one more challenge there. When we add an item to the cart, we need
    to dismiss it. But the popup is moving. The good news is that `waitForFunction`
    **to wait for animations to finish**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个挑战。当我们向购物车添加一个项目时，我们需要将其关闭。但是弹出窗口正在移动。好消息是`waitForFunction`可以等待动画完成。
- en: Important note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I thought this would be a simple example, and it turned out to be quite complicated.
    But I think it's great. You will find these kinds of issues in real life, and
    you need to resolve them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我以为这会是一个简单的例子，结果却相当复杂。但我认为这很好。你将在现实生活中遇到这类问题，你需要解决它们。
- en: I'm going to explain the test piece by piece. You will be able to see the entire
    test in the `packpub.tests.js` file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我将逐个解释测试部分。你将能够在`packpub.tests.js`文件中看到整个测试。
- en: 'The first thing we need to solve, and it''s something that we, unfortunately,
    see a lot these days, is the cookies notification. Let''s see how we can wait
    for a notification banner using Puppeteer:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的第一件事，而且不幸的是，这是我们今天经常看到的事情，是Cookies通知。让我们看看我们如何使用Puppeteer等待通知横幅：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first thing we do is go to the page we want to test. Then we might, or might
    not, get the cookies banner. The problem is that the cookies banner might take
    a little while to be shown. So, we wait for the `'.accept_all'` selector, which
    is the `.catch(e => e)`. If we finally get that cookie button, we click on it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是访问我们想要测试的页面。然后我们可能会，也可能不会，看到Cookies横幅。问题是Cookies横幅可能需要一点时间才能显示。因此，我们等待`'.accept_all'`选择器，即`.catch(e
    => e)`。如果我们最终得到了那个Cookies按钮，我们就点击它。
- en: 'Once the cookies banner is dismissed, we need to wait for the page to be ready
    to act. We don''t care which client library the page is using, but it seems that
    it takes a little bit to be ready to act. One of the things I found is that it
    will set the class `empty` to the cart button when the cart is ready. Another
    thing we know is that the `add-to-cart` class. We can add a `Promise.all` and
    wait for those two conditions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦关闭了Cookies横幅，我们需要等待页面准备好进行操作。我们不在乎页面使用哪个客户端库，但似乎需要一点时间才能准备好操作。我发现的一件事是，当购物车准备好时，它将设置购物车按钮的类为`empty`。另一件事是我们知道的是`add-to-cart`类。我们可以添加一个`Promise.all`并等待这两个条件：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This step was easy. We need to wait for the selectors, `.counter.qty.empty`,
    which is the empty cart button, and `.add-to-cart,` which is the **Add to cart**
    button.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤很简单。我们需要等待选择器`.counter.qty.empty`，这是空购物车按钮，以及`.add-to-cart`，这是**添加到购物车**按钮。
- en: 'Next up, we need to set up our wait promises:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的等待承诺：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This looks complex, but it's not that complex. We are setting up two promises.
    The first promise will resolve when the text (using the `innerText` property)
    of the cart counter, which has the selector `.counter.qty .counter-number`, is
    equal to 1\. We hope it will be resolved at one point in time after we click on
    the first product. There, I added a `trim` function, so we remove any extra spaces.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很复杂，但实际上并不复杂。我们设置了两个承诺。第一个承诺将在购物车计数器的文本（使用`innerText`属性）等于1时解决。我们希望在我们点击第一个产品后，在某个时间点解决。在那里，我添加了一个`trim`函数，这样我们就移除了任何额外的空格。
- en: The second promise is the same as the first one. But it will resolve when the
    cart number is equal to 2.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个承诺与第一个相同。但它将在购物车数量等于2时解决。
- en: 'Now that we have our wait promises, it''s time to click on the first product:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的等待承诺，是时候点击第一个产品了：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we are grabbing all the **Add to cart** buttons and clicking on the first
    one.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在获取所有的**添加到购物车**按钮并点击第一个。
- en: 'Now we get to the fun part. We need to wait for the checkout popup to show
    up and finish its fancy animation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了有趣的部分。我们需要等待结账弹出窗口出现并完成其华丽的动画：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Pretty scary, right? Let's analyze this function because it's a handy method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很吓人，对吧？让我们分析这个函数，因为它是一个实用的方法。
- en: Our `wait for` function needs to be resolved when the checkout popup is visible
    and has stopped moving. How do we know that it stopped moving? Well, we could
    check the element height every 20 milliseconds, and if the height is the same
    after 10 checks, we can assume it stopped moving.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `wait for` 函数需要在结账弹出窗口可见且停止移动时解决。我们如何知道它已经停止移动了呢？嗯，我们可以每20毫秒检查一次元素的高度，如果在10次检查后高度保持不变，我们可以假设它已经停止移动。
- en: The first thing we do is get the element, grabbing the initial height using
    `getBoundingClientRect`, and set a counter to `0`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是获取元素，使用 `getBoundingClientRect` 获取初始高度，并将计数器设置为 `0`。
- en: Once we have that, we will `await` a `promise`, but it will be resolved inside
    the browser. Inside that `promise`, we will create a function called `stoppedMoving`,
    and we will call it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们将 `await` 一个承诺，但这个承诺将在浏览器内部解决。在这个承诺内部，我们将创建一个名为 `stoppedMoving` 的函数，并调用它。
- en: The first thing we will check inside that function is whether the element is
    visible. If it's not, we will call the function again after 20 milliseconds.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数内部，我们首先会检查元素是否可见。如果不是，我们将在20毫秒后再次调用该函数。
- en: Then we check the current height. If the height has changed, we reset the counter,
    and we start over. If it didn't change for the past 10 times, we resolve the promise
    by calling `resolve()`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查当前高度。如果高度已改变，我们重置计数器，并重新开始。如果过去10次没有改变，我们将通过调用 `resolve()` 解决承诺。
- en: The last thing we do there is to call the same function after 20 milliseconds.
    Eventually, that function will be resolved, or it will fail due to the `waitForFunction`
    timeout.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在那里做的最后一件事是在20毫秒后调用相同的函数。最终，该函数将被解决，或者由于 `waitForFunction` 超时而失败。
- en: '**The numbers here are relative. You don''t need to wait 20 milliseconds or
    wait 10 times. You can pick the numbers that will suit you in your example.**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**这里的数字是相对的。你不需要等待20毫秒或等待10次。你可以选择适合你示例的数字。**'
- en: 'Once we know that the popup is opened and is not moving, we can close it using
    the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道弹出窗口已打开且没有移动，我们可以使用以下代码关闭它：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As simple as calling `click`, we are passing the close button selector.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就像调用 `click` 一样简单，我们传递了关闭按钮的选择器。
- en: 'Now we can wait for the cart number to be updated to 1:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以等待购物车数量更新为1：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we are awaiting the promise we built before. The promise might have already
    been resolved by the time we get here; we don't care. If the promise is resolved,
    the `await` will resolve immediately. If not, we will wait.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在等待我们之前构建的承诺。当我们到达这里时，承诺可能已经解决；我们不在乎。如果承诺已经解决，`await` 将立即解决。如果没有，我们将等待。
- en: 'Lastly, we click on a second product and await the second promise:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们点击第二个产品并等待第二个承诺：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we grabbed the second product on the list, clicked on it, and waited for
    the cart number to change to 2\. Again, we don't care if that promise was already
    resolved or not.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们抓取了列表中的第二个产品，点击了它，并等待购物车数量变为2。同样，我们不在乎那个承诺是否已经解决。
- en: If all promises were resolved, there is nothing to assert. We know that everything
    worked as expected.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有承诺都已解决，就没有什么可以断言的了。我们知道一切按预期工作。
- en: I bet you will need a break after this section. Once you are ready, we will
    see one more thing we can do with functions. We are going to make the browser
    call functions on the Node side.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我打赌你在这一节之后需要休息一下。一旦你准备好了，我们将看到我们可以用函数做的一件事。我们将让浏览器在Node端调用函数。
- en: Exposing local functions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露本地函数
- en: With Puppeteer, you can not only execute code inside the browser but also make
    calls from the browser back to your Node app. The `exposeFunction` function allows
    us to register Node functions inside the browser.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppeteer，你不仅可以执行浏览器内的代码，还可以从浏览器调用回你的Node应用。`exposeFunction` 函数允许我们在浏览器中注册Node函数。
- en: 'This is the `exposeFunction` signature: `page.exposeFunction(name, puppeteerFunction)`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `exposeFunction` 的签名：`page.exposeFunction(name, puppeteerFunction)`：
- en: The first argument is `name`. This will be the function name inside the browser.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是 `name`。这将是浏览器内的函数名。
- en: '`puppeteerFunction` is a function that follows the same style and functionality
    as all the functions we have learned about in this chapter.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`puppeteerFunction` 是一个函数，其风格和功能与我们在这章中学到的所有函数相同。'
- en: This feature is perfect when it is called from a `MutationObserver`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `MutationObserver` 调用时，这个特性非常完美。
- en: 'For instance, instead of executing a function over and over, waiting for the
    checkout counter to change, we could create a `MutationObserver` to let us know
    when the value has changed in the HTML Node. Let''s see how the code would look:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不必反复执行函数，等待结账柜台的变化，我们可以创建一个`MutationObserver`来通知我们当HTML节点中的值发生变化时。让我们看看代码会是什么样子：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this piece of code, we are declaring an observer, which expects a `callback`
    function. The first argument of that `callback` function will be a list of mutations.
    That mutation has the `target` object, and we can get the `nodeValue` from there.
    You can go to the Mozilla documentation ([https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord](https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord))
    if you want to know the full list of properties of the mutation records.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们声明了一个观察者，它期望一个`callback`函数。那个`callback`函数的第一个参数将是一个突变列表。那个突变有一个`target`对象，我们可以从那里获取`nodeValue`。如果你想了解突变记录的完整属性列表，可以访问Mozilla文档([https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord](https://www.hardkoded.com/ui-testing-with-puppeteer/MutationRecord))。
- en: That observer won't do much. We need to tell it to observe changes in a particular
    element, in our case, an element with the selector `.counter.qty .counter-number`.
    So, we call `observe`, passing the `counter` element, and, as a second argument,
    we will tell the `observe` function what changes we want to listen to. In this
    case, we only care about `characterData` changes, and we also want to listen to
    changes in the `subtree` (child elements). That means text changes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 那个观察者不会做太多。我们需要告诉它观察特定元素的变化，在我们的例子中，是一个具有选择器`.counter.qty .counter-number`的元素。因此，我们调用`observe`，传递`counter`元素，作为第二个参数，我们将告诉`observe`函数我们想要监听哪些变化。在这种情况下，我们只关心`characterData`变化，并且我们还想监听`subtree`（子元素）的变化。这意味着文本变化。
- en: 'So now, we could make a copy of our previous test and replace `cartIsOnePromise`
    and `cartIsTwoPromise` with something like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们可以复制我们之前的测试，并将`cartIsOnePromise`和`cartIsTwoPromise`替换为类似以下内容：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We create a promise, `reachedToTwo`. Inside the promise constructor, we will
    expose a function named `'notifyCartChange'`. The function we will expose there
    will expect one argument, and we will resolve the promise if the argument is equal
    to `'2'`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个承诺，`reachedToTwo`。在承诺构造函数中，我们将公开一个名为`'notifyCartChange'`的函数。我们将公开的函数期望一个参数，如果参数等于`'2'`，我们将解决承诺。
- en: That `exposeFunction` function will allow us to call a `notifiyCartChange` inside
    the `MutationObserver` we declared using an `evaluate` call.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`exposeFunction`函数将允许我们使用`evaluate`调用在声明的`MutationObserver`内部调用`notifiyCartChange`。
- en: 'For the last step, we replace our old awaits with the new promise:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一步，我们将旧的`await`替换为新的承诺：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If everything goes as expected, `notifyCartChange` will be called twice, once
    with the value `'1'` and then with the value `'2'`, and the second call will resolve
    the `reachedToTwo` promise we added at the end of the test.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如预期进行，`notifyCartChange`将被调用两次，一次是值`'1'`，然后是值`'2'`，第二次调用将解决我们在测试末尾添加的`reachedToTwo`承诺。
- en: This might sound like silly, overcomplicated code, but picture all you could
    do with `exposeFunction` and `MutationObserver`. You could test chat apps by listening
    to incoming changes and many other complex scenarios.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像是愚蠢的、过于复杂的代码，但想象一下你可以用`exposeFunction`和`MutationObserver`做什么。你可以通过监听传入的变化来测试聊天应用，以及许多其他复杂的场景。
- en: Before wrapping up this chapter, it is time to add another tool to our toolbox.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一章之前，是时候在我们的工具箱中添加另一个工具了。
- en: Running our checks with Checkly
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Checkly运行我们的检查
- en: 'This is an extra tool that I want to show you, and you shouldn''t miss the
    chance of trying it out. *Checkly* ([https://www.checklyhq.com/](https://www.checklyhq.com/))
    is a platform that will help you monitor your website. The following screenshot
    shows the *Checkly* website:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我想展示给你的额外工具，你不应该错过尝试它的机会。*Checkly* ([https://www.checklyhq.com/](https://www.checklyhq.com/))是一个可以帮助你监控网站的平台。以下截图显示了*Checkly*网站：
- en: '![Checkly website'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Checkly网站'
- en: '](img/Figure_6.06_B16113.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.06_B16113.jpg)'
- en: Checkly website
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Checkly网站
- en: Once you create an account in *Checkly*, you will be able to upload your tests
    (or checks), and *Checkly* will run those checks every certain number of minutes,
    reporting back. Firstly, it will report whether the check is passing, and secondly,
    it will report the time it took to run.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在*Checkly*中创建了一个账户，你将能够上传你的测试（或检查），*Checkly*将每隔一定时间运行这些检查，并返回报告。首先，它会报告检查是否通过，其次，它会报告运行所需的时间。
- en: You will also be able to test your website's API without running a browser.
    This is huge. It's like having your own, personal quality guard.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将能够测试你的网站 API，而无需运行浏览器。这是巨大的。这就像拥有你自己的、个人的质量守卫。
- en: 'Let''s go to [https://www.checklyhq.com/](https://www.checklyhq.com/) and start
    our trial. Follow these steps to start using *Checkly*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去 [https://www.checklyhq.com/](https://www.checklyhq.com/) 开始我们的试用。按照以下步骤开始使用
    *Checkly*：
- en: Once you enter your email, phone number, and account name, you will get the
    first dashboard with a few examples, as shown here:![Checkly dashboard
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你输入你的电子邮件、电话号码和账户名称，你将获得一个包含一些示例的第一个仪表板，如下所示：![Checkly 仪表板
- en: '](img/Figure_6.07_B16113.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_6.07_B16113.jpg)'
- en: Checkly dashboard
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Checkly 仪表板
- en: You can now delete those two examples and create your own cart test. We can
    create a browser test:![New test dialog
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以删除这两个示例，创建你自己的购物车测试。我们可以创建一个浏览器测试：![新的测试对话框
- en: '](img/Figure_6.08_B16113.jpg)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_6.08_B16113.jpg)'
- en: New test dialog
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的测试对话框
- en: 'Now, name your check `Cart number check`. You can copy the code from the `Chapter6/checkly.js`
    file:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，给你的检查命名为 "购物车号检查"。你可以从 `Chapter6/checkly.js` 文件中复制代码：
- en: '![First check'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![第一次检查'
- en: '](img/Figure_6.09_B16113.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.09_B16113.jpg)'
- en: First check
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次检查
- en: Notice that we have left the browser and the page creation there. Once we have
    copied the code, we can click on the **Run Script** button to check that the code
    is correct. Finally, we will need to pick our data center locations, hit **Save
    Check**, and we will have a platform checking our website's health automatically.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里留下了浏览器和页面创建。一旦我们复制了代码，我们就可以点击 **运行脚本** 按钮来检查代码是否正确。最后，我们需要选择我们的数据中心位置，点击
    **保存检查**，我们就会有一个平台自动检查我们网站的运行状况。
- en: If your team can afford it, *Checkly* will take you to the next level. Now it's
    time to wrap up.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的团队能够承担得起，*Checkly* 将带你进入下一个层次。现在，是时候总结一下了。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered one of the most powerful features of Puppeteer in this chapter. Most
    web automation tools let you run JavaScript code somehow, but Puppeteer makes
    it super easy to implement.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中介绍了 Puppeteer 最强大的功能之一。大多数网络自动化工具都允许你以某种方式运行 JavaScript 代码，但 Puppeteer
    使其变得超级容易实现。
- en: We started this chapter by talking about some basic JavaScript concepts. We
    learned about variable scopes and closures. That helped us understand how variables
    and closures work (or don't work) in Puppeteer. If you learned those differences,
    you will be able to answer 20% of the Puppeteer questions on Stack Overflow.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时讨论了一些基本的 JavaScript 概念。我们学习了变量作用域和闭包。这有助于我们理解变量和闭包在 Puppeteer 中的工作方式（或工作不正常的方式）。如果你了解了这些差异，你将能够回答
    Stack Overflow 上 20% 的 Puppeteer 问题。
- en: Then, we learned about `JSHandles` and `ElementHandles`. You don't see these
    classes being used a lot by the community, but they are very helpful if you know
    how to use them, and now you know.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了 `JSHandles` 和 `ElementHandles`。你不会看到社区中大量使用这些类，但如果你知道如何使用它们，它们将非常有帮助，现在你知道了。
- en: The `waitForFunction` completed our "wait" toolbox. You will use that wait function
    a lot. We also learned how to expose functions and listen to HTML changes using
    `MutationObserver`. Exposing functions and listening to HTML changes is not used
    much in UI testing, but it is an excellent tool for web scraping, a great topic
    we will cover in [*Chapter 9*](B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156),
    *Scraping tools*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForFunction` 完成了我们的 "等待" 工具箱。你将大量使用那个等待函数。我们还学习了如何使用 `MutationObserver`
    暴露函数和监听 HTML 变化。在 UI 测试中，暴露函数和监听 HTML 变化并不常用，但它是网络爬取的一个优秀工具，这是我们将在 [*第 9 章*](B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156)
    "爬取工具" 中讨论的一个大主题。'
- en: With this chapter, we have completed the basics of Puppeteer. You now have most
    of the tools you need to start doing end-to-end testing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们已经完成了 Puppeteer 的基础知识。你现在拥有了开始进行端到端测试所需的大部分工具。
- en: I hope you are as excited with *Checkly* as I was when I saw this platform for
    the very first time. *Checkly* is a dashboard that will help not only the QA team
    but also the development team. It will help your team find issues and even find
    new opportunities to improve your site's performance.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你对 *Checkly* 的兴奋程度和我第一次看到这个平台时的感觉一样。*Checkly* 是一个仪表板，它不仅可以帮助 QA 团队，还可以帮助开发团队。它将帮助你的团队发现问题和甚至发现改进网站性能的新机会。
- en: In the next chapter, we will see some features you wouldn't expect from an automation
    tool. We are going to see how to generate content using Puppeteer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到一些自动化工具中你不会期望的功能。我们将看到如何使用 Puppeteer 生成内容。
