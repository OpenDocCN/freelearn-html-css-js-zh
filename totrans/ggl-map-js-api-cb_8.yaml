- en: Chapter 8. Mastering the Google Maps JavaScript API through Advanced Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding WMS layers to maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Fusion Tables layers to maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding CartoDB layers to maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing ArcGIS Server with the Google Maps JavaScript API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing GeoServer with the Google Maps JavaScript API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Google Maps JavaScript API may seem like a simple library that only shows
    basic geo-related features, but there are a lot of capabilities that could be
    explored. The Google Maps JavaScript API gives developers many foundation classes
    to build complex solutions for different cases, especially for **Geographical
    Information Systems** (**GIS**).
  prefs: []
  type: TYPE_NORMAL
- en: The Google Maps JavaScript API has a lot of potential with GIS services and
    tools. Most of the GIS solutions need base maps and services to support the tool
    itself and the Google Maps JavaScript API is the best solution with its base maps
    and services.
  prefs: []
  type: TYPE_NORMAL
- en: There are different GIS solutions from proprietary software and services to
    open source ones, such as Google Fusion Tables, CartoDB, ArcGIS Server, or GeoServer.
    In this chapter, we will integrate these servers or services with the Google Maps
    JavaScript API. Some of the GIS service creation processes are skipped due to
    space constraints. If you need more information, please check other books by *Packt
    Publishing* to dive into details.
  prefs: []
  type: TYPE_NORMAL
- en: Adding WMS layers to maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web Map Service** (**WMS**) is an **Open Geospatial Consortium** (**OGC**)
    standard for publishing georeferenced map images over the Internet that are generated
    by a map server using data from various geospatial sources such as shapefiles
    or geospatial databases. There are various versions used in WMS services but the
    most used ones are 1.1.1 or 1.3.0\. WMS has two required request types: `GetCapabilities`
    and `GetMap`.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to add a WMS layer to the Google Maps JavaScript API by
    extending the `google.maps.OverlayView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should already know how to create a map, so only additional code
    lines are explained in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code at `Chapter 8/ch08_wms_map.html`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding WMS layers to the map is quite easy if you perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `wms.js` file to include in the HTML later. This JavaScript
    file has a `WMSUntiled` class that is written as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, extend our base class by inheriting the `google.maps.OverlayView` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to implement three methods of the `OverlayView` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following methods to finish the `WMSUntiled` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now this JavaScript class file must be added to the HTML after adding the Google
    Maps JavaScript API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After initializing the map, we create our WMS options as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end, we initialize the WMS layer with the WMS options created in steps
    1 to 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and see the result. The following topological map coming from WMS is shown on
    the satellite base map of Google Maps:![How to do it…](img/8825OT_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, we added a WMS layer to our map.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WMS is a standard for serving georeferenced images. The main idea behind WMS
    is serving the image according to the width/height and bounding box of the map
    with additional parameters such as projection type, layer names, and return format.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the WMS classes for the Google Maps JavaScript API around the Web are
    based on a tiled structure, which is the base for most mapping APIs. This tiled
    structure gets the bounding box of each tile and sends it to the server. This
    can be a good usage for user interactivity wherein users only get missing tiles
    when dragging the map, but there is a problem with map servers. Getting lots of
    tiles instead of a single image causes a big load on map servers if there isn't
    a caching mechanism with a high volume of usage.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used the untiled structure to get WMS images from the server.
    This approach is getting one image from the server on each user interaction that
    can be useful in some cases. There isn't much information about this approach,
    so we encourage you to read and implement both approaches for your geo-web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript class named `WMSUntiled` is created in a different file in order
    to make the HTML file readable. This class is created with functional style and
    methods are added to the prototype of the constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Google Maps JavaScript API has a base class to extend in these cases named
    as `google.maps.OverlayView`. The `WMSUntiled` class extends this class to create
    a WMS overlay on top of the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OverlayView` class has three methods to implement in order to show the
    overlays as `draw()`, `onAdd()`, and `onRemove()`. The `onAdd()` and `onRemove()`
    methods are called during initialization and removal respectively. The `div` element
    is created and added to the map with the help of the `appendChild` function in
    the `onAdd()` method. Also, the `drag` event of the map is started to listen and
    draw the WMS layer on each user drag in this method. The `onRemove()` method removes
    the `div` element created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part of the class is the `draw()` method. This method creates
    an `img` element and attaches this element to the created `div` element in the
    `onAdd()` method. If there is an `img` element created before, it is removed from
    the `div` element. The `img` source is obtained from another method of the class
    named `prepareWMSUrl()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need pixel coordinates to place the `div` element. We get a projection of
    the layers in order to locate the `div` and `img` elements in the right place
    on the map. The `fromLatLngToDivPixel()` method converts the `LatLng` coordinates
    to screen pixels, which are used for placing the `div` element in the correct
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: WMS has a bounding box parameter (`BBOX`) that defines the boundaries of a georeferenced
    image. The `BBOX` parameter must be in the same unit defined in the CRS parameter.
    Google Maps is based on the Web Mercator projection, which is defined as `EPSG:900913`
    or `EPSG:3857`. The Google Maps JavaScript API used Web Mercator as a base projection,
    but gives us the `LatLng` objects in geographic projection defined as `EPSG:4326`.
    In order to get the right WMS image on Google Maps, there is a need for transformation
    of coordinates from `EPSG:4326` to `EPSG:3857`. This transformation can be done
    via the `toMercator()` method of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `prepareWMSUrl()` method gets most of the parameters from the `wmsoptions`
    object and creates a WMS URL to get the georeferenced image. The `BBOX` and `width`/`height`
    parameters are gathered from the map functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WMSUntiled` class handles almost everything. In order to add WMS layers
    to the Google Maps JavaScript API, you need to define the parameters of WMS layers
    and create an object from the `WMSUntiled` class. Since we give `map` as a parameter,
    there is no need to add the WMS layer to the `map` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of parameters to get WMS from the server, but that is out of
    the scope of this book. The sample WMS server used in this example cannot be available
    when you want to use it, so please use your own WMS servers in order to be sure
    of the availability of the services.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated at the beginning of the recipe, we create an overlay class to add
    WMS layers to the Google Maps JavaScript API without using the tiled structure.
    This is just a use case for developers. You should check for both tiled and untiled
    structures for your cases. There is an example use of the tiled structure in the
    *Accessing GeoServer with the Google Maps JavaScript API* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Accessing GeoServer with the Google Maps JavaScript API* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Fusion Tables layers to maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fusion Tables ([http://tables.googlelabs.com/](http://tables.googlelabs.com/))
    is an experimental tool provided by Google to store different types of tabular
    data. Fusion Tables is important for geo developers because it supports feature
    types such as points, polylines, and polygons. There is also support for geocoding
    of the address, place names, or countries that make Fusion Tables a powerful database
    for your features. Fusion Tables also has an API so that developers can connect
    it to different applications. There are some limitations in Fusion Tables but
    these limitations are enough for most developers.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenStreetMap POI database can be downloaded via different sources. We downloaded
    the restaurant POI database of Switzerland in the KML format and imported it into
    Fusion Tables. There are 7967 points in this table. In this recipe, we will use
    this table as a sample to help us visualize.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map view of the Switzerland POI database of restaurants can be seen using
    Fusion Tables as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Fusion Tables layers to maps](img/8825OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is how we achieve adding a Fusion Tables layer to the map that shows thousands
    of points without a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We assume that you already know how to create a simple map. We will only cover
    the code that is needed for adding a Fusion Tables layer.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code at `Chapter 8/ch08_fusion_tables.html`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to add Fusion Tables layers to the map, you should perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following line for jQuery to simplify our work after the Google
    Maps JavaScript API is added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following HTML code before the map''s DIV element for interactivity
    with the Fusion Tables layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create the Fusion Tables layers and add it to the map after the initialization
    of the `map` object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to listen to the `click` event of the checkbox to switch between
    the normal view and the heat map view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines to listen to the `click` event of the **Search** button
    to filter the Fusion Tables layer according to the value entered in the textbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to your local URL where your HTML is stored in your favorite browser and
    click on the map to see the result. If you click on the heat map checkbox, the
    Fusion Tables layer will change into a heat map. You can also search for the names
    of restaurants with the **Search** button:![How to do it…](img/8825OT_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding screenshot is also showing a filtered Fusion Tables layers added
    to a map.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, Fusion Tables is an experimental tool to use and classes
    related to Fusion Tables that are under the Google Maps JavaScript API are also
    experimental according to the documentation. As far as we have used them, both
    Fusion Tables and classes under Google Maps JavaScript API are stable and can
    be ready for production environments, but it is at your own risk to use them in
    your geo-web application.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, please make sure that your tables do not pass 100,000 rows in order
    to use them properly, because there is a limitation written in the API.
  prefs: []
  type: TYPE_NORMAL
- en: Fusion Tables supports the importing of various data types such as CSV, TSV,
    TXT, or KML with coordinates of geometries. Fusion Tables geometry columns can
    be in different formats, such as a geometry column in the KML format, address
    column, or latitude/longitude coordinates in single column or two separate columns.
    If you have addresses or city names, these columns can also be geocoded in order
    to be used in your applications. We uploaded a KML file to Fusion Tables gathered
    from OpenStreetMap that is full of restaurant points with names.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a REST API for Fusion Tables to access and manipulate the data
    within tables with/without OAuth regardless of the Google Maps JavaScript API.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `google.maps.FusionTablesLayer` class in the Google Maps JavaScript
    API to access and visualize the data from Fusion Tables. We need the table ID
    and name of the geometry column to access the Fusion Tables layer in the Google
    Maps JavaScript API. Remember that your table must be shared as public or unlisted
    in order to be accessible from the Google Maps JavaScript API. Developers can
    get the table ID by navigating to **File** | **About** in the Fusion Tables web
    interface. The following code block is needed to add Fusion Tables to the Google
    Maps JavaScript API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to enable the heat map option at the beginning of the API, you
    should set the enabled option to `true` under the `heatmap` parameter. We will
    switch these parameters with the `checkbox` options in our recipe as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Using heat maps is a good way to summarize the data you have and show where
    most of the points are gathered. Heat maps are mostly used in various fields in
    order to show the important places such as most dense crime spots in crime mapping.
    If users enable the heat map, you will see the following results in the application.
    The following map shows in red where the restaurant population is crowded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8825OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fusion Tables also supports filtering rows with SQL-like queries. SQL queries
    can be added to the `query` parameter with the `where` field. This can be a starting
    value or added later to filter the visualized data. In this recipe, we filter
    our data according to the value entered in the textbox. The following code listens
    to the **Search** button and when a click occurs, it gets the value of the textbox
    and set the options of the Fusion Tables layer according to the textbox value.
    The filtered data is immediately shown on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `google.maps.FusionTablesLayer` class also has the ability to change the
    style of the map according to filters. You can change the marker type of points,
    line color of polylines, or fill color of polygons consistent with the values
    of columns.
  prefs: []
  type: TYPE_NORMAL
- en: Fusion Tables can be a good candidate to store, analyze, and visualize your
    data if developers know the limitations. Also, developers do not forget that Fusion
    Tables are still in the experimental stage, so Google can change something in
    Fusion Tables in the future that can cause your application to stop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**More about data**'
  prefs: []
  type: TYPE_NORMAL
- en: The data used in this application can be downloaded from [http://poi-osm.tucristal.es/](http://poi-osm.tucristal.es/),
    which uses OpenStreetMap as a source. The data used in this recipe is available
    with the code. The data is also available from Fusion Tables as a public share.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a heat map* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding CartoDB layers to maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CartoDB is a geospatial database on the cloud that allows for the storage and
    visualization of data on the Web. Using CartoDB will allow you to quickly create
    map-based visualizations. According to the CartoDB website ([www.cartodb.com](http://www.cartodb.com)),
    you can use CartoDB in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Upload, visualize, and manage your data using the CartoDB dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quickly create and customize maps that you can embed or share via public URL
    using the map-embedding tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze and integrate data you store on CartoDB into your applications using
    the SQL API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more advanced integrations of CartoDB maps on your website or application,
    use `CartoDB.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CartoDB is an open source project for which you can fork the code from GitHub
    and start your own CartoDB instance on your own hardware, but the power of CartoDB
    is the cloud backend. CartoDB is based on PostgreSQL, PostGIS, and Mapnik, which
    are the most popular and powerful open source geo tools nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: There is a free tier for developers to explore the power of CartoDB, which has
    a limit of up to 5 MB storage and five tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, the simplified version of world borders is imported from the
    CartoDB dashboard to play with. The following screenshots show both the tabular
    and map view of the world borders. This data will be published on the Google Maps
    JavaScript API with the help of the `CartoDB.js` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding CartoDB layers to maps](img/8825OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And now the map view of the world border is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding CartoDB layers to maps](img/8825OT_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we assume you already know how to create a simple map. So, we
    will only show the extra code lines to add CartoDB layers on top of the Google
    Maps base maps.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code at `Chapter 8/ch08_cartodb_layer.html`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you perform the following steps, you can add CartoDB layers to the map:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, CartoDB-related files are added to the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, the jQuery file is added after CartoDB files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to add a global variable to access from everywhere after the
    `map` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After initialization of the map, the following lines are added to define the
    cartography of the layers. This can be single line string, but it is separated
    into multiple lines in order to improve readability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The important part of the code is the initialization of the CartoDB layer as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following part to listen to the `click` event of the **Search**
    button in order to update the map contents according to the textbox value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do not forget to add the following lines before and after the map''s `div`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to your local URL where your HTML is stored in your favorite browser and
    take a look at the CartoDB layer on top of the Google Maps base map. When you
    move on the map, the bottom line of the map changes according to where your mouse
    is placed. When you click on the map, you will also see an info window about that
    country as shown in the following screenshot:![How to do it…](img/8825OT_08_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result of this recipe, we can add CartoDB layers to the map, which gets
    live data from your data source.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, CartoDB is based on PostGIS and Mapnik technologies,
    so you can use CartoCSS as a styling language of the layer. CartoCSS is much like
    CSS with some additional tags to define the cartography. In this recipe, we will
    define a choropleth cartography according to population values. Using population
    values seems to be simple for cartography but this is the most easiest way to
    understand CartoCSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `#world_borders` layer is the name of the layer defined in the CartoDB dashboard.
    The first brackets include all the features in the layer with a polygon-fill and
    a polygon-opacity. The second brackets target the features with a population of
    more than 10 million with a different color. The third brackets and fourth brackets
    target the features with a population of more than 40 and 70 million respectively
    with different colors. So, we have four different categories defined in this CartoCSS
    tag according to the population of countries. Each CartoCSS rule overwrites the
    one written before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the cartography of the layer, it is time to create the layer
    and add it to the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have used chaining methods to create the layer and add it to the map. The
    following part is explained later. There is a `user_name` field to define your
    CartoDB account. The important part to define the layer is the `sublayers` field.
    You can define more than one layer but we will add only one layer at this time.
    The JavaScript object within the `sublayers` field is very important. The `sql`
    field defines, which features to be shown on the map. You can even write very
    complex SQL queries here like your own PostGIS database. The `cartocss` field
    is the part where you define the cartography of your layer. This is defined before,
    so just pass that variable to this field.
  prefs: []
  type: TYPE_NORMAL
- en: The next field is the `interactivity` field. This is important due to the technology
    behind it called **UTFGrid**. UTFGrid is a specification for rasterized interaction
    data. According to MapBox, who introduced this standard, UTFGrid's solution to
    this problem is to rasterize polygons and points in JSON as a grid of text characters.
    Each feature is referenced by a distinct character and associated to JSON data
    by its character code. The result is a cheap, fast lookup that even Internet Explorer
    7 can do instantly.
  prefs: []
  type: TYPE_NORMAL
- en: With UTFGrid, you can load some attribute data to the client with the loading
    of layer tile images and you can show this attribute data while your mouse is
    moving without sending any requests to the server. This is the quickest way to
    interact with users and remove the load from servers. You can still get detailed
    information from the server when it is really needed. Most of the time, users
    are very happy with this fast data interaction and there is no need to get more
    information from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**More about UTFGrid**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in more technical details of UTFGrid, the following web
    addresses are suggested for further reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/mapbox/utfgrid-spec](https://github.com/mapbox/utfgrid-spec)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.mapbox.com/developers/utfgrid/](https://www.mapbox.com/developers/utfgrid/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have previously covered, there is a field named `interactivity`. This
    should be filled with the column names that will be used for interactivity; it
    is important to make sure that interactivity is quick for users. So, adding complex
    text columns to show on interactivity is not advised in order to increase the
    loading of UTFGrids. Then we add this layer to the map with the chaining method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We added the CartoDB layer to the map but there are still missing pieces to
    activate the interactivity. We add another chaining method to add the necessary
    functionality as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This `done()` method is called when the layer is created and added to the map.
    First, we assign the local variable `layer` to the global variable `cartoLayer`
    to manipulate the SQL query of the `layer` variable later. Then, we activate the
    info window with the `cartodb.vis.Vis.addInfoWindow()` method. But there are still
    required code parts for activating UTFGrid, which are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first line activated the UTFGrid interaction, but we still need to know
    where and when to show the data. With the `featureOver` event of the layer, we
    catch each mouse move, get the related data from UTFGrid, and show it on the `div`
    element defined. We only show the `name` and `pop2005` fields of the layer on
    each mouse move.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of the recipe is to search for the countries by typing their
    names. This part is like writing the SQL query. On each `click` event of the **Search**
    button, we get the value of the textbox and assign it to a local variable named
    `txtValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have the `txtValue` variable, we set the query of the CartoDB layer
    by using the `setQuery()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `txtValue` variable is empty, we recover the defined cartography; otherwise,
    we change the cartography of the layers to a black color to see which countries
    are selected by using the `setCartoCSS()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is taken after searching countries whose names include
    `Turk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8825OT_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we have seen in this recipe, CartoDB is a complete solution for everyone,
    from basic map visualization to complex GIS analysis. You can use the complete
    power of PostGIS behind your geo-web applications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing ArcGIS Server with the Google Maps JavaScript API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ArcGIS Server is the mapping and spatial server developed by ESRI. It is a proprietary
    software, but the capabilities and integration with desktop software make ArcGIS
    Server better than other spatial server products. ArcGIS Server is a complete
    spatial server solution for enterprise corporations or institutions. ArcGIS Server
    is used for creating and managing GIS web services, applications, and data. ArcGIS
    Server is typically deployed on-premises within the organization's **Service-oriented
    Architecture** (**SOA**) or off-premises in a cloud computing environment.
  prefs: []
  type: TYPE_NORMAL
- en: ESRI releases APIs for the ArcGIS Server to use in multiple platforms, but ESRI
    does not support the Google Maps JavaScript API v3\. There was an extension for
    the Google Maps JavaScript API v2, but it does not work with the new API. There
    is an open source library to extend the Google Maps JavaScript API v3 to work
    with ArcGIS Server.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the open source library to work with ArcGIS Server.
    We will add both a tiled and dynamic layer to the Google Maps JavaScript API.
    We also identify the dynamic layer with mouse clicks and show the underlying information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**More about the open source ArcGIS Server library**'
  prefs: []
  type: TYPE_NORMAL
- en: ArcGIS Server link for the Google Maps JavaScript API v3 is an open source library
    and can be found the following web address. It is advised to download and check
    the library at [https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html](https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is still using the same map creation process defined in [Chapter
    1](ch01.html "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript
    API Basics*, but there are some additional code blocks to add ArcGIS tiled/dynamic
    layers and listen for mouse clicks to identify the dynamic layer.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code at `Chapter 8/ch08_arcgis_layer.html`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps we need to access ArcGIS Server with the Google
    Maps JavaScript API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download the ArcGIS Server link for the Google Maps JavaScript API v3
    from the following address: [https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html](https://google-maps-utility-library-v3.googlecode.com/svn/trunk/arcgislink/docs/reference.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to add the downloaded library to your HTML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The jQuery library is also needed in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need some global variables as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a tiled map layer named `tiledMap` with an opacity of `0.6`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a dynamic map layer named `dynamicMap` with an opacity of `0.8`.
    Also, a copyright control is added to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need a map service for identifying with the same URL used in the dynamic
    map layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start listening to the `map` object for each mouse click event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create the function that is called on each mouse click event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterward, we will show the results in an info window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add the function used for showing polygons. This function is used
    in the previous recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following function for removing all the polygons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code block listens to the checkboxes and switches the visibility
    of both tiled and dynamic layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to add the necessary HTML tags for checkboxes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to your local URL where the HTML is stored in your favorite browser and enable
    **Add Topo Map Overlay** by clicking on the checkbox nearby. The following topological
    map is shown on the satellite base map:![How to do it…](img/8825OT_08_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, we have successfully created a map that accesses the ArcGIS Server layers
    with the Google Maps JavaScript API.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ArcGIS Server has different capabilities to use with the Google Maps JavaScript
    API. The library used to access ArcGIS Server in this recipe has almost every
    method for the REST API of the ArcGIS Server. The library is created on the Google
    Maps JavaScript API base classes, so using it is not as difficult as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The service URLs used in this recipe are serving by ESRI, so you can use them
    for developing purposes without any problems. If you want to use them in a production
    environment, please contact ESRI to get valid licenses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we will add a tiled map showing the topology of the world
    on the satellite base map. With the help of the `gmaps.ags.MapType` class, you
    can easily create a tiled map with a URL to the map service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding and removing the tiled map is done in the the same way as we did in
    [Chapter 2](ch02.html "Chapter 2. Adding Raster Layers"), *Adding Raster Layers*.
    Please get the index of the layer. This index is used when removing the layer
    from map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a dynamic layer is also very easy thanks to the library. The library
    handles all the code for drawing the dynamic layer. The sample dynamic layer used
    in this recipe is the CENSUS data layer, which has the demographic information
    about states, counties, or census blocks of the U.S.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the screenshot of the CENSUS layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8825OT_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding and removing the dynamic layer are the same as overlays because the
    `gmaps.ags.MapOverlay` class is extended from the `google.maps.OverlayView` base
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Identifying a map layer is a very important task for most geo-web applications.
    This gives information to users about the layer at known points. To achieve this,
    we need to define a map service as follows. The `gmaps.ags.MapService` class only
    gets the URL parameters, which are defined for the dynamic layer before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When a map `click` event occurs, we need to handle it with a function named
    `identify`. This function gets the `latLng` object and trigger the `identify`
    method of the `gmaps.ags.MapService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `identify` method gets some parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`geometry`: This gets `LatLng`, `Polyline`, or `Polygon` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tolerance`: This is the distance in screen pixels where the mouse is clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layerIds`: This array contains layer IDs. The value `5` in this recipe defines
    the state''s layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layerOption`: These options can be `top`, `visible`, or `all`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bounds`: This gets an object created from the `LatLngBounds` class. This defines
    the current bounds of the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: This is the width of the map `div` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This is the height of the map `div` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The return of the function contains an array of features that contains both
    the attribute and geometry data. The result function can iterate over this array
    and show the attribute data in an info window. The geometry of each feature can
    also be shown on the map. The result of the `identify` operation is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8825OT_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ArcGIS Server is a powerful tool to use with the Google Maps JavaScript API
    if you have the license. There are also other GIS functionalities such as geoprocessing,
    geocoding, or geometry service, which are not included in this recipe due to the
    scope, but their usage is no different from the `identify` operation.
  prefs: []
  type: TYPE_NORMAL
- en: The Google Maps JavaScript API is a perfect mapping tool and is powerful with
    this kind of service and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we focused on the ArcGIS Server, but ESRI also has an alternative
    cloud solution named ArcGIS Online ([www.arcgis.com](http://www.arcgis.com)).
    It is the cloud version of the ArcGIS Server and the usage of its services are
    almost the same as ArcGIS Server's services.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding popups to markers or maps* recipe in [Chapter 3](ch03.html "Chapter 3. Adding
    Vector Layers"), *Adding Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding polygons to maps* recipe in [Chapter 3](ch03.html "Chapter 3. Adding
    Vector Layers"), *Adding Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Getting coordinates of a mouse click* recipe in [Chapter 5](ch05.html "Chapter 5. Understanding
    Google Maps JavaScript API Events"), *Understanding Google Maps JavaScript API
    Events*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing GeoServer with the Google Maps JavaScript API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GeoServer is an open source map server written in Java that allows users to
    share and edit geospatial data. It is one of the popular open source map servers
    that can publish OGC compliant services such as WMS and WFS. **Web Map Service**
    (**WMS**) is used for publishing georeferenced images and simple querying. On
    the other side, **Web Feature Service** (**WFS**) is used for publishing vector
    data to any kind of GIS clients. WFS is mostly used for data sharing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use one of GeoServer's standard published service named
    `topp:states` in WMS format. As stated in the *Adding WMS layers to maps* recipe
    of this chapter, WMS has different request types such as `GetMap` or `GetCapabilities`.
    We will also use a `GetFeatureInfo` addition to the `GetMap` request. This new
    request gets the information of the point on the map. Also, we used a tiled structure
    in this recipe to get WMS images in order to make a comparison between the untiled
    structure in the *Adding WMS layers to maps* recipe and the tiled structure in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the first recipe defined in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    as a template in order to skip the map creation.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code at `Chapter 8/ch08_geoserver.html`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can easily access GeoServer with the Google Maps JavaScript API after performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `wms-tiled.js` file to include in the HTML later. This JavaScript
    file has the `WMSTiled` and `WMSFeatureInfo` classes. Let''s add the `WMSTiled`
    class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the `WMSFeatureInfo` class and its `getUrl` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step in the `wms-tiled.js` file is to add the `toMercator()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have our JavaScript class file; add the following line after adding
    the Google Maps JavaScript API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to add a jQuery library to the HTML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a tiled WMS from the class written in the `wms-tiled.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create an object from the `WMSFeatureInfo` class to be
    used later in the event listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to listen to the `click` event of the map to get information
    from the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to your local URL where the HTML is stored in your favorite browser and try
    to click on the map where you want to get info.![How to do it…](img/8825OT_08_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The previous screenshot is the result of the recipe that shows WMS layers created
    by GeoServer on the Google Maps JavaScript API.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing GeoServer is not much different from accessing a WMS server because
    they share the same standards. With GeoServer, you can publish your data on your
    own servers with your security standards.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we installed a fresh GeoServer to our Mac OS X and its sample
    data is ready for serving WMS and WFS. We used the sample states data of the U.S.
    on WMS to show the interaction.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are serving HTML files from `localhost` on port 80, but GeoServer
    is working from `localhost` on port 8080\. This is a problem for our case, because
    we cannot access GeoServer when getting information due to the cross-site scripting
    security limitation of HTML. The solution is using a JSONP format to pass over
    the limitation. GeoServer can give the JSONP format, but you should activate it
    from the options.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Adding WMS layers to maps* recipe of this chapter, we used the untiled
    structure to get WMS images, but this time, we are using the tiled structure to
    get WMS images. The difference can be seen in the screenshot of untiled and tiled
    usage of WMS that the abbreviation of states' names occurring more than once on
    tiled WMS because the geometry of the same state can be seen in different images
    of tiled WMS. As said, the choice is yours whether it is tiled or untiled according
    to your geo-web application's needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a tiled structure in WMS is done in exactly the same way as we did
    in the *Adding tile overlays to maps* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*. The important part here is to create
    the URL for each tile. The `BBOX` parameter for each tile is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There is a need for projection transformation to get tiles that will fit exactly
    on the Google Maps' base map. Google Maps has a Web Mercator projection so the
    overlays need to be in this projection.
  prefs: []
  type: TYPE_NORMAL
- en: One of the other parameters needed for URL is the WMS standard parameter, but
    be sure about the difference of parameters according to the WMS versions.
  prefs: []
  type: TYPE_NORMAL
- en: The `SRS` parameter used in this recipe is `EPSG:3857`, which is the equivalent
    of `EPSG:900913`, `ESRI:102113`, or `ESRI:102100`. All `SRS` parameters mentioned
    here define the Web Mercator projection systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WMSFeatureInfo` class is written for creating WMS get info requests. The
    parameters of the URL are important, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x`: This is the x coordinate of the mouse in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: This is the y coordinate of the mouse in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: This is the width of the map `div` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This is the height of the map `div` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info_format`: This is a string that describes the return format of information.
    In this case, `Text`/`JavaScript` is used for getting info in the format of JSONP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query_layers`: This is the comma-separated list of layers to be queried.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layers`: This is the comma- separated list of layers to be shown (coming from
    the `GetMap` request).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bbox`: This is the bounding box of the map shown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format_options`: This is required for JSONP to define the name of the `callback`
    function. The `callback` function''s name must be the same as in the jQuery AJAX
    request to get information without any errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `getUrl` method gets the `LatLng` object as an input, but there is a need
    for screen coordinates in the `GetFeatureInfo` request. We came up with a trick
    in order to convert `LatLng` to screen coordinates in the `getUrl` method. In
    the constructor, we create an overlay with the `google.maps.OverlayView` class
    and use its functions to convert `LatLng` to screen coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `google.maps.Projection` class has a method named `fromLatLngToPoint()`
    to convert the `LatLng` object to screen coordinates but this does not work as
    it is expected to. This converts the `LatLng` coordinates to screen coordinates
    in world scale, but we need to get the screen coordinates in the map's `div` reference.
    To achieve this, we use the `google.maps.MapCanvasProjection` class method named
    `fromLatLngToContainerPixel()`.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't go into detail with listening to the map `click` event and showing
    popups. Also, we used the `ajax` method of jQuery to get a JSONP request, which
    is also out of the scope of this book. If you want to get details of these topics,
    please refer to previous recipes of related chapters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding popups to markers or maps* recipe in [Chapter 3](ch03.html "Chapter 3. Adding
    Vector Layers"), *Adding Vector Layers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Getting coordinates of a mouse click* recipe in [Chapter 5](ch05.html "Chapter 5. Understanding
    Google Maps JavaScript API Events"), *Understanding Google Maps JavaScript API
    Events*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding WMS layers to maps* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
