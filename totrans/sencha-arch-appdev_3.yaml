- en: Chapter 3. Creating a Sencha Touch App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。创建 Sencha Touch 应用程序
- en: 'In this chapter, we will take our first step building a Sencha Touch application
    with Sencha Architect. We will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Sencha Architect 来构建我们的第一个 Sencha Touch 应用程序。我们将涵盖以下内容：
- en: Creating a Sencha Touch project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Sencha Touch 项目
- en: Creating models, stores, views, and controllers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模型、存储、视图和控制器
- en: Executing the project for the first time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次执行项目
- en: Integrating Sencha Touch with PhoneGap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Sencha Touch 与 PhoneGap 集成
- en: Implementing the Sencha Touch app
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Sencha Touch 应用程序
- en: 'Before we implement our Sencha Touch application, let''s take a look at what
    we will build by the end of this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现我们的 Sencha Touch 应用程序之前，让我们看看本章结束时我们将要构建的内容：
- en: '![Implementing the Sencha Touch app](img/9819OS_03_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![实现 Sencha Touch 应用程序](img/9819OS_03_01.jpg)'
- en: It is a simple list that lists all the contacts available on the phone. All
    the UI design will be done with Sencha Touch, and to retrieve the native contacts
    from the device we will use PhoneGap. The previous screenshot was taken from an
    iPhone with the app running. We will learn how to build and prepare the application
    to be executed on a real device later in this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的列表，列出了手机上可用的所有联系人。所有的 UI 设计都将使用 Sencha Touch 完成，并且为了从设备中检索原生联系人，我们将使用
    PhoneGap。前面的截图是在 iPhone 上运行应用程序时拍摄的。我们将在本书的后面部分学习如何构建和准备在真实设备上执行的应用程序。
- en: Creating the project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'First, create a new Sencha Touch project; we can do this by selecting the **New
    Project** option from the welcome screen or from the toolbar:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 Sencha Touch 项目；我们可以通过从欢迎屏幕或从工具栏中选择**新建项目**选项来完成此操作：
- en: '![Creating the project](img/9819OS_03_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/9819OS_03_02.jpg)'
- en: Right after the project is created, we will see the landing screen, with the
    toolbar, canvas, project inspector, config panel, and toolbox. We will save our
    project immediately. To do so, click on **Save** in the toolbox or press *Ctrl*
    + *S* (*cmd* + *S* on Mac OS). The **Save Project** screen will be displayed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建后，我们将看到登录屏幕，其中包括工具栏、画布、项目检查器、配置面板和工具箱。我们将立即保存我们的项目。为此，请点击工具箱中的**保存**或按*Ctrl*
    + *S*（在 Mac OS 上为*cmd* + *S*）。将显示**保存项目**屏幕。
- en: 'We will save the project as `SenchaContacts` inside the `sencha-architect`
    directory, the same directory we saved our Ext JS project to. The following screenshot
    shows the **Save Project** screen:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把项目保存在`sencha-architect`目录下的`SenchaContacts`中，这个目录和我们的 Ext JS 项目保存的目录相同。以下截图显示了**保存项目**屏幕：
- en: '![Creating the project](img/9819OS_03_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/9819OS_03_03.jpg)'
- en: 'Now that the project is saved, we can start implementing it. We will use the
    following development workflow: first we will implement the **Model**, then the
    **Store**, then the **View**, lastly the **Controller**, and repeat it until our
    project is finished.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已保存，我们可以开始实现它。我们将使用以下开发工作流程：首先实现**模型**，然后是**存储**，然后是**视图**，最后是**控制器**，直到我们的项目完成。
- en: Configuring the app
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: 'The first step is to set up the application we are going to develop throughout
    this chapter. Before we start, in the project inspector, select **Application**
    (*Step 1*), and then go to the config panel, locate the property **name**, and
    set its value to `Packt` (*Step 2*). This is the namespace of our application,
    meaning all the classes will be named `Packt + package + className`. If we open
    the code editor, the code that we will see is shown in the following screenshot
    (*Step 3*):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置本章我们将要开发的应用程序。在我们开始之前，在项目检查器中，选择**应用程序**（*步骤 1*），然后转到配置面板，找到属性**名称**，并将其值设置为`Packt`（*步骤
    2*）。这是我们的应用程序命名空间，意味着所有类都将命名为`Packt + package + className`。如果我们打开代码编辑器，我们将看到的代码如下截图所示（*步骤
    3*）：
- en: '![Configuring the app](img/9819OS_03_04.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![配置应用程序](img/9819OS_03_04.jpg)'
- en: All these configurations will be applied on the `app.js` file, since the application
    represents the `app.js` file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些配置都将应用于`app.js`文件，因为应用程序代表`app.js`文件。
- en: You will notice that many of the steps that we will perform throughout this
    chapter are very similar to the ones we did in the previous chapter. This is because
    Ext JS and Sencha Touch share part of the API and also because once you are used
    to Ext JS or Sencha Touch, learning the second framework is easier.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在本章中我们将执行的大多数步骤与上一章中执行的操作非常相似。这是因为 Ext JS 和 Sencha Touch 共享部分 API，而且一旦你习惯了
    Ext JS 或 Sencha Touch，学习第二个框架就会更容易。
- en: Creating the model
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Following our development workflow, we will start with the model. On the top
    of the project inspector, click on the **+** icon and select **Model** (*Step
    1*):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的开发工作流程，我们将从模型开始。在项目检查器的顶部，点击**+**图标并选择**Model**（*步骤 1*）：
- en: '![Creating the model](img/9819OS_03_05.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建模型](img/9819OS_03_05.jpg)'
- en: 'Once the **Model** is created, select it, go to the config panel, and set the
    class name (`userClassName`) to `Contact` (*Step 2*). Then, still on the config
    panel, locate the **fields** property, click on its **+** icon and add the first
    field, which is named `id`. Continue until we have the following fields created:
    `id`, `displayName`, `phoneNumber`, `familyName`, and `givenName` (*Step 3*).
    These fields represent some of the fields that are available on the device.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了**模型**，选择它，转到配置面板，并将类名（`userClassName`）设置为`Contact`（*步骤 2*）。然后，仍然在配置面板中，找到**字段**属性，点击其**+**图标并添加第一个字段，该字段命名为`id`。继续添加，直到我们创建了以下字段：`id`、`displayName`、`phoneNumber`、`familyName`和`givenName`（*步骤
    3*）。这些字段代表设备上可用的某些字段。
- en: '![Creating the model](img/9819OS_03_06.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![创建模型](img/9819OS_03_06.jpg)'
- en: As we have `givenName` and `familyName`, let's say we want to create a field
    that returns the `givenName` and `familyName` fields concatenated. For this reason
    we created the `displayName` field. So to do what we want, we need to create a
    `convert()` function for the `displayName` field. To do so, we need to select
    the `displayName` field in the project inspector (*Step 4*), locate the **convert**
    property and click on the **+** icon (*Step 5*), then, a green diamond icon will
    appear near to the left of the **convert** property. This means a function was
    created on the code editor, and it is available for editing. To go to the code
    editor, we can click on the arrow icon (*Step 6*). Then we can add the code that
    will concatenate the `givenName` and `familyName` fields (*Step 7*).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有`givenName`和`familyName`，假设我们想要创建一个返回连接`givenName`和`familyName`字段的字段。因此，我们创建了`displayName`字段。所以为了完成我们想要的操作，我们需要为`displayName`字段创建一个`convert()`函数。为此，我们需要在项目检查器中选择`displayName`字段（*步骤
    4*），找到**convert**属性并点击**+**图标（*步骤 5*），然后，一个绿色菱形图标将出现在**convert**属性左侧。这意味着在代码编辑器中创建了一个函数，并且它可供编辑。要转到代码编辑器，我们可以点击箭头图标（*步骤
    6*）。然后我们可以添加将连接`givenName`和`familyName`字段的代码（*步骤 7*）。
- en: If we go back to the project inspector, the contact model should look as shown
    in the following screenshot (*Step 8*). If we look at the canvas, nothing will
    be displayed in the **Design** mode, but if we take a look at the **Code** editor,
    the `Packt.model.Contact` class will be defined. If we try to edit its code, we
    will notice that the only code available for editing is the `convert()` function
    we created for the `displayName` field (the edit icon will appear when we hover
    the mouse over the `convert()` function content). Any other change must be done
    using the config panel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到项目检查器，联系模型应该如图所示（*步骤 8*）。如果我们查看画布，在**设计**模式下将不会显示任何内容，但如果我们查看**代码**编辑器，`Packt.model.Contact`类将被定义。如果我们尝试编辑其代码，我们会注意到唯一可编辑的代码是我们为`displayName`字段创建的`convert()`函数（当我们将鼠标悬停在`convert()`函数内容上时，将出现编辑图标）。任何其他更改都必须使用配置面板进行。
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `Contact.js` inside
    the `app/model` directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目并查看Sencha Architect迄今为止创建的文件，我们会看到它在`app/model`目录中创建了一个名为`Contact.js`的文件。
- en: Creating the store
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建商店
- en: 'The next step is to create a store. Our data is going to come from the device,
    and we will use a special proxy with PhoneGap code to load it. This means that
    we can create a store that will use an Ajax Proxy, as on the project inspector
    **+** menu we do not have the option to create an empty store (neither by creating
    the store from the toolbox). So we need to go back to the project inspector, click
    on the **+** icon again, select **Store** and then select **Json Store** as shown
    in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个商店。我们的数据将来自设备，我们将使用特殊的代理和PhoneGap代码来加载它。这意味着我们可以创建一个使用Ajax代理的商店，因为在项目检查器的**+**菜单中，我们没有创建空商店的选项（无论是通过工具箱创建商店）。因此，我们需要回到项目检查器，再次点击**+**图标，选择**Store**，然后选择**Json
    Store**，如图所示：
- en: '![Creating the store](img/9819OS_03_07.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![创建商店](img/9819OS_03_07.jpg)'
- en: Right after we create the store, we need to give a name to it. So select the
    store on the project inspector, go to the config panel, locate the **userClassName**,
    and set its value as **Contacts** (this will be the name of the store—*Step 1*).
    Then, we also need to assign a **storeId** to it that will also have its value
    set to **Contacts** (*Step 2*). After we create the store, we will also see a
    red exclamation mark icon (*Step 3*). If we click on it (*Step 3*), we will see
    an error message saying that we need to associate a model to this store or create
    at least one field on the store (*Step 4*). As we already have a model, click
    on the **Store** in the project inspector, go to the config panel, search for
    **model** and then you can choose from the list of models we already created (*Step
    5*).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建商店后，我们需要给它起一个名字。因此，在项目检查器中选择商店，转到配置面板，找到**userClassName**，并将其值设置为**Contacts**（这将成为商店的名称—*步骤1*）。然后，我们还需要为其分配一个**storeId**，其值也将设置为**Contacts**（*步骤2*）。创建商店后，我们还将看到一个红色的感叹号图标（*步骤3*）。如果我们点击它（*步骤3*），我们将看到一个错误消息，表示我们需要将一个模型与此商店关联或至少在商店上创建一个字段（*步骤4*）。由于我们已经有了一个模型，我们可以点击项目检查器中的**Store**，转到配置面板，搜索**model**，然后可以从我们已创建的模型列表中选择（*步骤5*）。
- en: 'In this case, we have only created the **Contact** model. And at last, as we
    will use our own proxy (not the ones available on Sencha Touch API) we can delete
    the proxy by selecting it and right-clicking on it, then selecting the **Delete**
    option (*Step 6*):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只创建了**Contact**模型。最后，由于我们将使用自己的代理（而不是Sencha Touch API上可用的代理），我们可以通过选择它并右键单击它来删除代理，然后选择**Delete**选项（*步骤6*）：
- en: '![Creating the store](img/9819OS_03_08.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![创建商店](img/9819OS_03_08.jpg)'
- en: 'We can also create a store with no proxy by clicking directly on the **Store**
    option (as highlighted in the next screenshot), without the need to click on one
    of the following options; **Array Store**, **Direct Store**, and so on:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过直接点击**Store**选项（如下一张截图所示）来创建没有代理的商店，无需点击以下选项之一；**Array Store**、**Direct
    Store**等：
- en: '![Creating the store](img/9819OS_03_23.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![创建商店](img/9819OS_03_23.jpg)'
- en: 'As we saw earlier in this chapter, in the screenshot taken from an iPhone,
    a letter groups the contacts (this letter represents the first letter of the `givenName`—or
    the `familyName` if the contact does not have a `givenName`). We will add this
    configuration on the list later, but the class that will do the work of grouping
    the contacts is the store. So to do it, we need to select the **Contacts** in
    the **Stores** from the project inspector (*Step 7*), go to the toolbox, select
    the data, and then, under **Data Utilities**, we will find the **Grouper**. Double-click
    on it and a grouper will be added to the **Contacts** store. Then, select **MyGrouper**
    under the **Contacts** store, locate the **groupFn** on the config panel, and
    click on the **+** icon (*Step 8*). A green diamond icon will appear next to the
    **groupFn** function. Click on the arrow icon (*Step 9*) and the code editor will
    be opened, so we can add the grouper code (*Step 10*):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所见，在从iPhone拍摄的截图中，一个字母将联系人分组（这个字母代表`givenName`的第一个字母—如果没有`givenName`，则为`familyName`）。我们将在稍后添加此配置，但将执行分组工作的类是商店。因此，为了做到这一点，我们需要从项目检查器中选择**Contacts**在**Stores**中，转到工具箱，选择数据，然后在**Data
    Utilities**下找到**Grouper**。双击它，将在**Contacts**商店中添加一个分组器。然后，在**Contacts**商店下选择**MyGrouper**，在配置面板上找到**groupFn**，并点击**+**图标（*步骤8*）。在**groupFn**函数旁边将出现一个绿色菱形图标。点击箭头图标（*步骤9*），代码编辑器将打开，这样我们就可以添加分组器代码（*步骤10*）：
- en: '![Creating the store](img/9819OS_03_09.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![创建商店](img/9819OS_03_09.jpg)'
- en: If the contact has a `givenName`, the store will use its first letter to group;
    if not, it will use the `familyName` first letter. In case the contact does not
    have a name (it can happen), we will return `"-"`. It is very important to cover
    all the cases, because if not, the contacts will not appear in the list when we
    run this example on a real device.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果联系人有`givenName`，商店将使用其第一个字母进行分组；如果没有，则将使用`familyName`的第一个字母。如果联系人没有名字（这种情况可能发生），我们将返回`"-"`。覆盖所有情况非常重要，因为如果不这样做，当我们在真实设备上运行此示例时，联系人将不会出现在列表中。
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `Contacts.js` inside
    the `app/store` directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目并查看Sencha Architect迄今为止创建的文件后，我们将看到它已在`app/store`目录中创建了一个名为`Contacts.js`的文件。
- en: Creating the contacts proxy – PhoneGap
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建联系人代理 – PhoneGap
- en: 'As our idea is to load the contacts from the device, we will use PhoneGap to
    do the native access for us. To do so, we need to create our own proxy with the
    PhoneGap code. So go to the application directory (`sencha-architect/SenchaContacts`)
    and inside the `app` folder create a new folder named `proxy`, and create a file
    named `ContactsProxy.js` as demonstrated in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是从设备中加载联系人，因此我们将使用PhoneGap为我们进行原生访问。为此，我们需要使用PhoneGap代码创建自己的代理。所以请转到应用程序目录（`sencha-architect/SenchaContacts`），然后在`app`文件夹内创建一个名为`proxy`的新文件夹，并创建一个名为`ContactsProxy.js`的文件，如下面的截图所示：
- en: '![Creating the contacts proxy – PhoneGap](img/9819OS_03_10.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![创建联系人代理 – PhoneGap](img/9819OS_03_10.jpg)'
- en: 'Inside the `ContactsProxy.js` file we will add the following code (using a
    code editor of your choice—Notepad, Sublime Text, Eclipse, and so on)—unfortunately,
    this is something that we cannot do from Sencha Architect, as it is limited to
    the model, store, view and controller packages:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContactsProxy.js`文件中，我们将添加以下代码（使用您选择的代码编辑器——记事本、Sublime Text、Eclipse等）——遗憾的是，这是我们不能从Sencha
    Architect中完成的事情，因为它仅限于模型、存储、视图和控制器包：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the skeleton of our proxy. Creating custom proxies is an advanced topic
    and requires some knowledge of the API source code. So let's go step-by-step.
    First we have the definition of the class (`#1`) that follows the Sencha naming
    convention.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的代理的骨架。创建自定义代理是一个高级话题，需要一些对API源代码的了解。所以让我们一步一步来。首先，我们有类的定义（`#1`），它遵循Sencha命名约定。
- en: 'Notice that `Packt` is the namespace we chose for our app, `proxy` is the name
    of the package, and `ContactsProxy` is the name of the `.js` file we created.
    Then we are extending the proxy class from Sencha Touch API (`#2`). Next we are
    creating an alias so we can use the `contactsstorage` type later when we define
    the proxy inside the contacts store (`#3`). Following the code we have the default
    `constructor` (`#4`) and then, we have the signature of functions that our proxy
    needs to have: `create()` (`#5`), `update()` (`#6`), and `destroy()` (`#7`). We
    will not implement these functions. The one we will implement is `read()`, that
    we will add to our `ContactsProxy` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Packt`是我们为应用程序选择的命名空间，`proxy`是包名，`ContactsProxy`是我们创建的`.js`文件的名称。然后我们扩展了Sencha
    Touch API中的代理类（`#2`）。接下来，我们创建了一个别名，这样我们就可以在定义联系人存储中的代理时使用`contactsstorage`类型（`#3`）。在代码之后，我们有默认的构造函数（`#4`），然后是我们代理需要的函数签名：`create()`（`#5`）、`update()`（`#6`）和`destroy()`（`#7`）。我们不会实现这些函数。我们将实现的是`read()`，我们将将其添加到`ContactsProxy`类中：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the method `read()`, we have a mix of Sencha and PhoneGap code. To read
    the contacts, we will use a PhoneGap function (navigate to [http://docs.phonegap.com/en/2.6.0/cordova_contacts_contacts.md.html#Contacts](http://docs.phonegap.com/en/2.6.0/cordova_contacts_contacts.md.html#Contacts)
    for more information). The `navigator.contacts.find()` function needs the `contactFields`
    to be searched (`#8`), the success function in case PhoneGap was able to read
    the contacts successfully (`#9`), an error callback (`#16`), and some options
    (`#17`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`read()`方法中，我们有Sencha和PhoneGap代码的混合。为了读取联系人，我们将使用一个PhoneGap函数（有关更多信息，请参阅[http://docs.phonegap.com/en/2.6.0/cordova_contacts_contacts.md.html#Contacts](http://docs.phonegap.com/en/2.6.0/cordova_contacts_contacts.md.html#Contacts)）。`navigator.contacts.find()`函数需要搜索的`contactFields`（`#8`），在PhoneGap能够成功读取联系人时的成功函数（`#9`），一个错误回调（`#16`），以及一些选项（`#17`）。
- en: Our biggest interest is inside the `success()` function (`#9`). First, we are
    going to iterate each contact returned by the device to PhoneGap (`#10`). We will
    extract a phone number (`#11`—the contact can have more than one phone, in this
    case we will retrieve only the first one). Then we need to create a contact model
    instance with the information we extracted from the device (`#12`). We will push
    this contact model instance into an array. Finally, we need to set the information
    (contact model instances and their totals) into the `ResultSet` so the Ext JS
    contacts store can understand the information (`#14`) and set the `operation`
    as a success and complete (`#14`). And at last, we need to inform the Ext JS callback
    function (`#15`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最大的兴趣在于`success()`函数（`#9`）。首先，我们将遍历设备返回给PhoneGap的每个联系人（`#10`）。我们将提取一个电话号码（`#11`——联系人可以有多个电话，在这种情况下，我们将只检索第一个）。然后我们需要使用从设备提取的信息创建一个联系人模型实例（`#12`）。我们将把这个联系人模型实例推入一个数组。最后，我们需要将信息（联系人模型实例及其总数）设置到`ResultSet`中，以便Ext
    JS联系人存储可以理解这些信息（`#14`）并将`operation`设置为成功和完成（`#14`）。最后，我们需要通知Ext JS回调函数（`#15`）。
- en: Then, the contacts store will understand the information we retrieved from the
    device. The `read()` function will be called when we call the `load()` method
    from the store. We will see how to apply this proxy in the store on the controller
    section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，联系人存储将理解我们从设备检索到的信息。当我们从存储中调用`load()`方法时，将调用`read()`函数。我们将在控制器部分看到如何在存储中应用此代理。
- en: Creating the list view
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建列表视图
- en: 'In the next step we will create our view, which is the contacts list. There
    are two ways of creating a view. You can choose the one you like the most. The
    first one requires selecting the **Views** package on the project inspector (*Step
    1*); go to the **Toolbox** and locate the **Grid Panel** component and then double-click
    on it (*Step 2*). A new list view called `MyList` will be created under the **Views**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将创建我们的视图，即联系人列表。有两种创建视图的方法。你可以选择你最喜欢的一种。第一种方法需要选择项目检查器上的**Views**包（*步骤1*）；转到**Toolbox**并找到**Grid
    Panel**组件，然后双击它（*步骤2*）。在**Views**下将创建一个新的列表视图`MyList`：
- en: '![Creating the list view](img/9819OS_03_11.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![创建列表视图](img/9819OS_03_11.jpg)'
- en: Then, after the list is created, we need to select it from the project inspector,
    locate the **userAlias**, and set its value to **contactsList** and also set the
    **userClassName** to **contactsList** (*Step 3*). Still on the config panel, we
    also need to set a **store** to the list (*Step 4*).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在列表创建后，我们需要从项目检查器中选择它，找到**userAlias**，并将其值设置为**contactsList**，并将**userClassName**也设置为**contactsList**（*步骤3*）。仍然在配置面板上，我们还需要为列表设置一个**store**（*步骤4*）。
- en: 'The second way of creating the view is to select the component from the **Toolbox**,
    and drag-and-drop it inside the **Views** package (or it can be the **Views**,
    **Stores**, **Models**, or **Controllers** packages as well):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图的第二种方法是选择组件从**Toolbox**，并将其拖放到**Views**包内部（或者它也可以是**Views**、**Stores**、**Models**或**Controllers**包）：
- en: '![Creating the list view](img/9819OS_03_12.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![创建列表视图](img/9819OS_03_12.jpg)'
- en: 'The next step is to change the **itemTpl**. The **itemTpl** is the template
    of what information from the **Model** we will display as an item of the **ContactsList**.
    In this case, we want to display the `givenName` in bold and the `familyName`
    in a regular font as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是更改**itemTpl**。**itemTpl**是我们将显示为**ContactsList**项目的信息的模板。在这种情况下，我们希望以粗体显示`givenName`，并以常规字体显示`familyName`，如下面的屏幕截图所示：
- en: '![Creating the list view](img/9819OS_03_13.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![创建列表视图](img/9819OS_03_13.jpg)'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we double-click on **itemTpl** in the project inspector, the code editor
    will be displayed, and then we can edit the **itemTpl** as shown in the previous
    screenshot.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在项目检查器中双击**itemTpl**，代码编辑器将显示出来，然后我们可以像前一个屏幕截图所示那样编辑**itemTpl**。
- en: 'To make our list prettier, let''s add a toolbar to it. Select the **ContactsList**
    from the project inspector, then go to the toolbox and locate the **Toolbar**
    component; double-click on it (*Step 5*). Then, select the **Toolbar** from the
    project inspector, go to the config panel, locate the **title**, and set its value
    to `My Contacts` (*Step 6*). Another way of setting the toolbar''s title is using
    the design view and changing the title by double clicking on it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的列表看起来更美观，让我们给它添加一个工具栏。从项目检查器中选择**ContactsList**，然后转到工具箱并找到**Toolbar**组件；双击它（*步骤5*）。然后，从项目检查器中选择**Toolbar**，转到配置面板，找到**title**，并将其值设置为`My
    Contacts`（*步骤6*）。设置工具栏标题的另一种方法是使用设计视图，通过双击来更改标题：
- en: '![Creating the list view](img/9819OS_03_14.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![创建列表视图](img/9819OS_03_14.jpg)'
- en: 'Our last step is to add the index bar and group the list. So first, to add
    the index bar, select the **ContactsList** from the project inspector, go to **Toolbox**
    | **Views**, and locate the **List Index Bar** component (*Step 8*), which is
    the only thing we need to do. If we go to the code editor, we will see that Sencha
    Architect added the property `indexBar: true`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的最后一步是添加索引栏并对列表进行分组。所以首先，为了添加索引栏，从项目检查器中选择**ContactsList**，转到**Toolbox**
    | **Views**，并找到**List Index Bar**组件（*步骤8*），这是我们唯一需要做的事情。如果我们转到代码编辑器，我们会看到Sencha
    Architect添加了属性`indexBar: true`。'
- en: '![Creating the list view](img/9819OS_03_15.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![创建列表视图](img/9819OS_03_15.jpg)'
- en: 'And finally, select the **ContactsList** from the project inspector again,
    go to the config panel, locate the **grouped** property checkbox, and check it.
    This will add the property `grouped: true` in the code editor.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，再次从项目检查器中选择**ContactsList**，转到配置面板，找到**grouped**属性复选框，并勾选它。这将向代码编辑器中添加属性`grouped:
    true`。'
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `ContactsList.js`
    inside the `app/view` directory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目并查看Sencha Architect迄今为止创建的文件，我们会看到它已经在`app/view`目录中创建了一个名为`ContactsList.js`的文件。
- en: Creating the controller
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'So to create the controller, let''s go back to the top of the project inspector
    and click on the **+** icon once again and select the **Controller** option (*Step
    1*). Then, with the **Controller** selected, go to the config panel, and change
    its **userClassName** to **Contacts** (*Step 2*):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建控制器，让我们回到项目检查器的顶部并再次点击**+**图标，然后选择**Controller**选项（*步骤1*）。然后，选择**Controller**，转到配置面板，并将它的**userClassName**更改为**Contacts**（*步骤2*）：
- en: '![Creating the controller](img/9819OS_03_16.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/9819OS_03_16.jpg)'
- en: 'Still on the config panel, locate the **models**, **stores**, and **views**
    properties (*Step 3*). With these properties, we will declare the models, stores
    and views that this controller will care about. Once you select **Model**, **Store**,
    or **View**, Sencha Architect will display a window with a question as shown in
    the following screenshot. Click on **Remove**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在配置面板中，定位到**models**、**stores**和**views**属性（*步骤3*）。使用这些属性，我们将声明这个控制器将关注的模型、存储和视图。一旦选择**Model**、**Store**或**View**，Sencha
    Architect将显示一个带有问题的窗口，如下截图所示。点击**移除**：
- en: '![Creating the controller](img/9819OS_03_17.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/9819OS_03_17.jpg)'
- en: This is because on the application (`app.js`), as we create models, stores,
    and views, they will be declared on the **models**, **views**, and **stores**
    properties of the application. With this step, we are transferring the responsibility
    to the controller, and there is no need to keep their declaration on the `app.js`
    application and also on the controller (which is what will happen if we click
    on the **Keep** button).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在应用程序（`app.js`）中，当我们创建模型、存储和视图时，它们将被声明在应用程序的**models**、**views**和**stores**属性中。通过这一步，我们将责任转移到控制器，并且不需要在`app.js`应用程序和控制器（如果我们点击**保留**按钮会发生的情况）上保留它们的声明。
- en: The next step is to add a new **Controller Action** to the contacts controller.
    To do so, select the contacts controller on the project inspector, go to the toolbox,
    locate the **Controller** **Action**, and double-click on it (or drag-and-drop)
    as demonstrated by *Step 4*. Once the **Controller** **Action** is listed under
    the contacts controller, select it, go to the config panel, and choose **ContactsList**
    as **targetType** (*Step 5*); then, on the **EventBinding**, select the **name**
    of the event we want to listen to, which is **show**. If you would like, you can
    change the **controlQuery** to be more specific, as well as the name of the **BasicFunction**
    by changing **fn**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为联系人控制器添加一个新的**Controller Action**。要做到这一点，在项目检查器中选择联系人控制器，转到工具箱，找到**Controller**
    **Action**，并双击它（或拖放），如*步骤4*所示。一旦**Controller** **Action**在联系人控制器下列出，选择它，转到配置面板，并将**targetType**选择为**ContactsList**（*步骤5*）；然后，在**EventBinding**中，选择我们想要监听的事件的**name**，即**show**。如果您愿意，可以将**controlQuery**改为更具体，以及通过更改**fn**来更改**BasicFunction**的名称。
- en: '![Creating the controller](img/9819OS_03_18.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/9819OS_03_18.jpg)'
- en: Then on the code editor, we will add the logic we want to take place, when the
    **ContactsList** is displayed, which is to load its **Store**, so PhoneGap can
    load the contacts from the device. But what happens is that the contacts store
    does not have a proxy set, so we can set `contactsstorage`, which is the proxy
    we created using the `setProxy()` method. This is the easiest way we can do it.
    The other way would be creating an override of the contacts store, but this is
    an advanced topic that we will learn in the next chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在代码编辑器中，我们将添加我们希望在**ContactsList**显示时发生的逻辑，即加载其**Store**，这样PhoneGap就可以从设备中加载联系人。但实际情况是联系人存储没有设置代理，因此我们可以设置`contactsstorage`，这是我们使用`setProxy()`方法创建的代理。这是我们可以做到的最简单的方法。另一种方法是在联系人存储上创建一个覆盖，但这是一个高级主题，我们将在下一章中学习。
- en: Next on line `26` of the `onListShow()` method we have the `document.addEventListener('deviceready')`
    declaration. This is a PhoneGap code that will be fired when the device is ready
    to be used. Then, as a function we load the **ContactsList** store. As the proxy
    we created uses PhoneGap code, we need to make sure we will call it only when
    the device is ready to be used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onListShow()` 方法的第 `26` 行，我们有 `document.addEventListener('deviceready')`
    声明。这是一段 PhoneGap 代码，当设备准备好使用时将会触发。然后，作为一个函数，我们加载 **ContactsList** 存储。由于我们创建的代理使用了
    PhoneGap 代码，我们需要确保只有在设备准备好使用时才调用它。
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `Contacts.js` inside
    the `app/controller` directory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目并查看 Sencha Architect 到目前为止创建的文件后，我们会看到它在 `app/controller` 目录中创建了一个名为 `Contacts.js`
    的文件。
- en: 'We can click on the preview icon again in the toolbar, and now we will see
    the final version of our project, but first we need to set the **URL Prefix:**
    as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次在工具栏中点击预览图标，现在我们将看到我们项目的最终版本，但首先我们需要设置 **URL 前缀**，如下截图所示：
- en: '![Creating the controller](img/9819OS_03_19.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/9819OS_03_19.jpg)'
- en: And then, by clicking on the **Preview** button, the browser will be opened,
    but it will not display anything, as the browser is not a device. To display any
    contacts, we need to use an emulator or test the app on a real device; we will
    learn about this later in this book.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过点击工具栏中的 **预览** 按钮，浏览器将被打开，但它不会显示任何内容，因为浏览器不是一个设备。要显示任何联系人，我们需要使用模拟器或在真实设备上测试应用程序；我们将在本书的后面部分学习这一点。
- en: '![Creating the controller](img/9819OS_03_20.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/9819OS_03_20.jpg)'
- en: Adding PhoneGap
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 PhoneGap
- en: As we already coded everything we need to do, the only thing left to do is to
    add the `PhoneGap js` file into our Sencha Architect project. To do so, select
    **Resources** on the project inspector, go to the toolbox, select **Resources**,
    and then double-click on **JS** **Resource**. Then, on the config panel, give
    an **id** to it (**phonegap**) and set the **URL** as the **phonegap** file (in
    this case we are using the **cordova-2.5.0.js** that we can get from [http://phonegap.com](http://phonegap.com)).
    And then we are done!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经编写了所有需要做的代码，剩下要做的就是将 `PhoneGap js` 文件添加到我们的 Sencha Architect 项目中。要做到这一点，在项目检查器中选择
    **资源**，转到工具箱，选择 **资源**，然后双击 **JS 资源**。然后，在配置面板中，给它一个 **id**（**phonegap**）并将 **URL**
    设置为 **phonegap** 文件（在这种情况下我们使用的是可以从 [http://phonegap.com](http://phonegap.com)
    获取的 **cordova-2.5.0.js**）。然后我们就完成了！
- en: '![Adding PhoneGap](img/9819OS_03_21.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![添加 PhoneGap](img/9819OS_03_21.jpg)'
- en: The final project structure
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终项目结构
- en: 'As we have finished implementing our first Sencha Touch project with Sencha
    Architect, let''s take a look at the code generated for us as shown in the following
    screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Sencha Architect 完成我们的第一个 Sencha Touch 项目实现后，让我们看看为我们生成的代码，如下截图所示：
- en: '![The final project structure](img/9819OS_03_22.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![最终项目结构](img/9819OS_03_22.jpg)'
- en: Notice that Sencha Architect created all the files for us (with the exception
    of proxy).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Sencha Architect 为我们创建了所有文件（除了代理）。
- en: Similar to an Ext JS project, it is very important to bring to our attention
    that we cannot modify the files on a code editor. In case we do modify any files
    and try to open in Sencha Architect again, all changes will be lost because Sencha
    Architect will override them. So in case you decide you want to change any file
    on a code editor, it is important to know that you will not be able to use Sencha
    Architect again (and if you do, you will lose the modifications).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ext JS 项目类似，我们必须注意，我们不能在代码编辑器中修改文件。如果我们修改了任何文件并尝试再次在 Sencha Architect 中打开，所有更改都将丢失，因为
    Sencha Architect 将会覆盖它们。所以，如果你决定在代码编辑器中更改任何文件，重要的是要知道你将无法再次使用 Sencha Architect（如果你这样做，你将丢失这些更改）。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned how to implement our first Sencha Touch project using
    Sencha Architect. We learned how to create a new Sencha Touch project, and how
    to set up the `app.js` file using the application. We learned how to create the
    model, store, view, and controller, and we also covered how to integrate our Sencha
    Touch project with PhoneGap, which is an advanced topic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Sencha Architect 实现我们的第一个 Sencha Touch 项目。我们学习了如何创建一个新的 Sencha
    Touch 项目，以及如何使用应用程序设置 `app.js` 文件。我们学习了如何创建模型、存储、视图和控制器，我们还介绍了如何将我们的 Sencha Touch
    项目与 PhoneGap 集成，这是一个高级主题。
- en: In the next chapter, we will learn some tips and tricks, such as multilingual
    apps, create overrides, exporting and importing a project, and much more.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些技巧和窍门，例如多语言应用、创建覆盖、导出和导入项目，以及更多内容。
