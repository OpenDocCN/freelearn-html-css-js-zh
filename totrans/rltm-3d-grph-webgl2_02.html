<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Rendering</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we covered the history of WebGL, along with its evolution. We discussed the fundamental elements in a 3D application and how to set up a WebGL context. In this chapter, we will investigate how geometric entities are defined in WebGL. </p>
<p>WebGL renders objects following a "divide and conquer" approach. Complex polygons are decomposed into triangles, lines, and point primitives. Then, each geometric primitive is processed in parallel by the GPU in order to create the final scene.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Understand how WebGL defines and processes geometric information</li>
<li>Discuss the relevant API methods that relate to geometry manipulation</li>
<li>Examine why and how to use <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) to define, store, and load complex geometries</li>
<li>Continue our analysis of WebGL as a state machine to describe the attributes that are relevant to geometry manipulation that can be set and retrieved</li>
<li>Experiment with creating and loading different geometry models</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebGL Rendering Pipeline</h1>
                </header>
            
            <article>
                
<p>Although WebGL is often thought of as a comprehensive 3D API, it is, in reality, just a rasterization engine. It draws points, lines, and triangles based on the code you supply. Getting WebGL to do anything else requires you to provide code to use points, lines, and triangles to accomplish your task.</p>
<p>WebGL runs on the GPU on your computer. As such, you need to provide code that runs on that GPU. The code should be provided in the form of pairs of functions. Those two functions are known as the <strong>vertex shader</strong> and <strong>fragment shader</strong>, and they are each written in a very strictly-typed C/C++-like language called GLSL (GL Shader Language). Together, they are called a <strong>program</strong>.</p>
<div class="packt_infobox"><span class="packt_screen">GLSL</span><strong><br/>
<br/></strong> GLSL is an acronym for the official OpenGL Shading Language. GLSL is a C/C++-like, high-level programming language for several parts of the graphic card. With GLSL, you can code short programs, called shaders, which are executed on the GPU. For more information, please check out <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">https://en.wikipedia.org/wiki/OpenGL_Shading_Language</a>.</div>
<p>A vertex shader's job is to compute vertex attributes. Based on various positions, the function outputs values that can be used to rasterize various kinds of primitives, including points, lines, and triangles. When rasterizing these primitives, it calls a second user-supplied function known as a fragment shader. A fragment shader's job is to compute a color for each pixel of the primitive currently being drawn.</p>
<p>Nearly all of the WebGL API is about setting up state for these pairs of functions to execute. For each thing you want to draw, you need to set up state to run these functions by invoking <kbd>gl.drawArrays</kbd> or <kbd>gl.drawElements</kbd>, which executes your shaders on the GPU.</p>
<p>Before going any further, let's examine what WebGL's rendering pipeline looks like. <span>In subsequent chapters, we will discuss the pipeline in more detail. </span>The following is a diagram of a simplified version of WebGL's rendering pipeline:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0131f45f-813f-4251-898d-2b894c1fb4ec.png"/></p>
<p>Let's take a moment to describe each element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vertex Buffer Objects (VBOs)</h1>
                </header>
            
            <article>
                
<p><strong>VBOs</strong> contain the data that is used to describe the geometry to be rendered. Vertex coordinates, which are points that define the vertices of 3D objects, are usually stored and processed in WebGL as VBOs. Additionally, there are several data elements, such as vertex normals, colors, and texture coordinates, that can be modeled as VBOs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Index Buffer Objects (IBOs)</h1>
                </header>
            
            <article>
                
<p>While VBOs contain vertices describing a geometry, <strong>IBOs</strong> contain information about the relationship of the vertices as the rendering pipeline constructs the drawing type primitives. It uses the index of each vertex in the vertex buffer as a value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vertex Shader</h1>
                </header>
            
            <article>
                
<p>The <strong>vertex shader</strong> is called on each vertex. The shader manipulates <em>per-vertex</em> data, such as vertex coordinates, normals, colors, and texture coordinates. This data is represented by attributes inside the vertex shader. Each attribute points to a VBO from where it reads vertex data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fragment Shader</h1>
                </header>
            
            <article>
                
<p>Every set of three vertices defines a triangle. Each element on the surface of that triangle needs to be assigned a color. Without this, our surfaces wouldn't have a color. Each surface element is called a <strong>fragment</strong>. Since we are dealing with surfaces that will be displayed on your screen, these elements are more commonly known as <strong>pixels</strong>.</p>
<p>The main goal of the <strong>fragment shader</strong> is to calculate the color of <em>individual pixels</em>. The following diagram illustrates this idea:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/461fa06e-78e2-492d-8f53-937e72435b86.png" style="width:44.58em;height:19.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Framebuffer</h1>
                </header>
            
            <article>
                
<p>A two-dimensional buffer contains the fragments that have been processed by the fragment shader. Once all of the fragments have been processed, a 2D image is formed and displayed on screen. The <strong>framebuffer</strong> is the final destination of the rendering pipeline.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attributes</h1>
                </header>
            
            <article>
                
<p><strong>Attributes</strong> are input variables that are used in the vertex shader. Attributes are used to specify how to pull data out of buffers and provide them to the vertex shader. For example, you may put positions in a buffer as three 32-bit floats per position. You would tell a particular attribute which buffer to pull the positions out of, what type of data it should pull out (3-component, 32-bit floating point numbers), what offset in the buffer the positions start at, and how many bytes to get from one position to the next. Since the vertex shader is called on each vertex, the attributes will be different every time the vertex shader is invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uniforms</h1>
                </header>
            
            <article>
                
<p><strong>Uniforms</strong> are input variables that are available to both the vertex shader and the fragment shader. Unlike attributes, uniforms are constant during a rendering cycle. For example, the position of a light is often modeled as a uniform. Uniforms are effectively global variables that you set before executing your shader program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Textures</h1>
                </header>
            
            <article>
                
<p><strong>Textures</strong> are arrays of data that can be accessed in your shader program. Image data is the most common thing to put in a texture, but textures are simply data and can just as easily contain something other than an array of colors describing an image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Varyings</h1>
                </header>
            
            <article>
                
<p><strong>Varyings</strong> are used to <em>pass data</em> from the vertex shader to the fragment shader. Depending on what is being rendered <span>–</span> points, lines, or triangles <span>–</span> the values set on a varying by a vertex shader will be interpolated while executing the fragment shader.</p>
<p>Now, let's cover the principles of creating a simple geometric object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering in WebGL</h1>
                </header>
            
            <article>
                
<p>WebGL handles geometry in a standard way, independent of the complexity and number of points that surfaces can have. There are two data types that are fundamental to represent the geometry of any 3D object: <em>vertices</em> and <em>indices</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vertices</h1>
                </header>
            
            <article>
                
<p><strong>Vertices</strong> are the points that define the corners of 3D objects. Each vertex is represented by three floating-point numbers that correspond to the <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> coordinates of the vertex. Unlike its cousin, OpenGL, WebGL does not provide API methods to pass independent vertices to the rendering pipeline; therefore, all of our vertices need to be written in a <strong>JavaScript array</strong>, which can then be used to construct a WebGL vertex buffer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Indices</h1>
                </header>
            
            <article>
                
<p><strong>Indices</strong> are numeric labels for the vertices in a given 3D scene. Indices allow us to tell WebGL how to connect vertices in order to produce a surface. As with vertices, indices are stored in a JavaScript array and are then passed along to WebGL's rendering pipeline using a WebGL index buffer.</p>
<div class="packt_infobox"><span class="packt_screen">VBOs Versus IBOs</span><br/>
<br/>
There are two kinds of WebGL buffers used to describe and process geometry. Buffers that contain vertex data are known as <strong><span>V</span>BOs</strong>,<span> and buffers that contain index data are known as </span><strong>IBOs</strong><span>.</span></div>
<p>In this section, we will use the following steps to render an object in WebGL:</p>
<ol>
<li>Define a geometry using JavaScript arrays</li>
<li>Create the respective WebGL buffers</li>
<li>Point a vertex shader attribute to a VBO from the previous step to store vertex coordinates</li>
<li>Use the IBO to render the geometry</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a Geometry Using JavaScript Arrays</h1>
                </header>
            
            <article>
                
<p>To practice using the preceding steps, let's use a trapezoid to see how we can define its vertices and indices. We need two JavaScript arrays <span>–</span> one for the vertices and one for the indices:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1ccc3e64-684e-4098-b910-505346c4b396.png" style="width:38.67em;height:23.33em;"/></p>
<p>As you can see from the preceding illustration, we have placed the coordinates sequentially in the vertex array and then indicated how these coordinates are used to draw the trapezoid in the index array. So, the first triangle is formed with the vertices having the indices <kbd>0</kbd>, <kbd>2</kbd>, and <kbd>1</kbd>; the second, with the vertices having the indices <kbd>1</kbd>, <kbd>2</kbd>, and <kbd>3</kbd>; and finally, the third, with the vertices having the indices <kbd>2</kbd>, <kbd>4</kbd>, and <kbd>3</kbd>. We will follow the same procedure for all possible geometries.</p>
<div class="packt_tip"><span class="packt_screen">Index Array Order</span><br/>
<br/>
Triangles in the index array are usually, but not necessarily, defined in counter-clockwise order. It's important to pick one approach and keep it consistent to help you determine the front and back sides of geometry primitives. Consistency is important, because programs may use the clockwise/counter-clockwise order to determine whether a face is facing forward or backward for <strong>culling</strong> and rendering purposes.</div>
<div class="packt_infobox"><span class="packt_screen">Culling<br/></span> <strong><br/></strong> <span>In computer </span>graphics<span>, back-face </span>culling<span> determines whether a polygon of a graphical object is visible. It is a step in the graphical pipeline that tests whether the points in the polygon appear in clockwise or counter-clockwise order when projected onto the screen. For more information, visit <a href="https://en.wikipedia.org/wiki/Back-face_culling">https://en.wikipedia.org/wiki/Back-face_culling</a><a href="https://en.wikipedia.org/wiki/Back-face_culling">.</a></span><strong><br/></strong></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating WebGL Buffers</h1>
                </header>
            
            <article>
                
<p>Now that we understand how to define a geometry using vertices and indices, let's render a square. Once we have created the JavaScript arrays that define the vertices and indices for our geometry, the next step is to create the respective buffers. In this case, we have a simple square on the <kbd>x</kbd>-<kbd>y</kbd> plane with the z values set as <kbd>0</kbd>:</p>
<div>
<pre><span>const </span>vertices = [<br/>  -<span>0.5</span><span>,  </span><span>0.5</span><span>, 0,<br/></span><span>  </span>-<span>0.5</span><span>, </span>-<span>0.5</span><span>, 0,<br/></span><span>   </span><span>0.5</span><span>, </span>-<span>0.5</span><span>, 0,<br/></span><span>   </span><span>0.5</span><span>,  </span><span>0.5, 0<br/></span>]<span>;<br/></span><span><br/></span><span>const </span>positionBuffer = gl.<span>createBuffer</span>()<span>;</span></pre></div>
<div class="packt_infobox"><span class="packt_screen">Clipspace Coordinates</span><br/>
<br/>
These vertices are defined in clipspace coordinates, because WebGL only deals with clipspace coordinates. Clipspace coordinates always go from <kbd>-1</kbd> to <kbd>+1</kbd>, regardless of the size of the <kbd>canvas</kbd>. In later chapters, we will cover coordinates in more detail and learn how to convert between different coordinate systems.</div>
<p>In <a href="48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml"/><a href="48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml">Chapter 1</a>, <em>Getting Started</em>, you may remember learning that WebGL operates as a state machine. Now, when <kbd>positionBuffer</kbd> is made the currently-bound WebGL buffer, any subsequent buffer operation will be executed on this buffer until it is unbound, or another buffer is made the current one with a bound call. We can bind a buffer with the following instruction:</p>
<div>
<pre>gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);</pre></div>
<p>The first parameter is the type of buffer we are creating. We have two options for this parameter:</p>
<ul>
<li><kbd>gl.ARRAY_BUFFER</kbd>: Vertex data</li>
<li><kbd>gl.ELEMENT_ARRAY_BUFFER</kbd>: Index data</li>
</ul>
<p>In the previous example, we created the buffer for vertex coordinates; therefore, we use <kbd>ARRAY_BUFFER</kbd>. For indices, the <kbd>ELEMENT_ARRAY_BUFFER</kbd> type is used.</p>
<div class="packt_tip"><span class="packt_screen"><strong>Bound Buffer Operations</strong></span><br/>
<br/>
WebGL will always access the currently-bound buffer looking for the data. This means that we need to ensure that we always have bound a buffer before calling any other operation for geometry processing. If there is no buffer bound, you will obtain the <kbd>INVALID_OPERATION</kbd> error.</div>
<p>Remember that <kbd>drawArrays</kbd> uses VBOs<em>.</em> Once we have bound a buffer, we need to pass along its contents. We do this with the <kbd>bufferData</kbd> function:</p>
<div>
<pre>gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);</pre></div>
<p>In this example, the vertices variable is a normal JavaScript array that contains the vertex coordinates. WebGL does not accept JavaScript arrays as a parameter for the <kbd>bufferData</kbd> method. Instead, WebGL requires JavaScript typed array so that the buffer data can be processed in its native binary form with the objective of speeding up geometry-processing performance.</p>
<p><span>The typed arrays used by WebGL include <kbd>Int8Array</kbd>, <kbd>Uint8Array</kbd>, <kbd>Int16Array</kbd>, <kbd>Uint16Array</kbd>, <kbd>Int32Array</kbd>, <kbd>Uint32Array</kbd>, <kbd>Float32Array</kbd>, and <kbd>Float64Array</kbd>.</span></p>
<p>It's important to note that vertex coordinates can be float, but indices are <em>always</em> integers. Therefore, we will use <kbd>Float32Array</kbd> for VBOs and <kbd>Uint16Array</kbd> for IBOs in this book. These two types represent the largest typed arrays that you can use in WebGL <em>per rendering call</em>. Other types may or may not be present in your browser, as this specification is not yet final at the time of this book's publication.</p>
<p>Since the indices support in WebGL is restricted to 16-bit integers, an index array can only be <kbd>65,535</kbd> elements in length. If you have a geometry that requires more indices, you will need to use several rendering calls. More about rendering calls will be presented <span>later in this chapter</span>.</p>
<div class="packt_infobox"><span class="packt_screen">JavaScript Typed Arrays</span><br/>
<br/>
<span>Specifications for typed arrays can be found at </span><a href="http://www.khronos.org/registry/typedarray/specs/latest/">http://www.khronos.org/registry/typedarray/specs/latest/</a>.<a href="http://www.khronos.org/registry/typedarray/specs/latest/"/></div>
<p>Finally, it is a good practice to unbind the buffer. We can achieve this by calling the following instruction:</p>
<div>
<pre>gl.bindBuffer(gl.ARRAY_BUFFER, null);</pre></div>
<p>We will repeat the same calls described here for every WebGL buffer (VBO or IBO) that we will use.</p>
<p>Let's review what we have just learned with an example. We are going to look at an example from <kbd>ch02_01_square.html</kbd> to see the definition of VBOs and IBOs for a square:</p>
<div>
<pre><span>// Set up the buffers for the square<br/></span><span>function </span><span>initBuffers</span>() {<br/>  <span>/*<br/></span><span>    V0                    V3<br/></span><span>    (-0.5, 0.5, 0)        (0.5, 0.5, 0)<br/></span><span>    X---------------------X<br/></span><span>    |                     |<br/></span><span>    |                     |<br/></span><span>    |       (0, 0)        |<br/></span><span>    |                     |<br/></span><span>    |                     |<br/></span><span>    X---------------------X<br/></span><span>    V1                    V2<br/></span><span>    (-0.5, -0.5, 0)       (0.5, -0.5, 0)<br/></span><span>  */<br/></span><span>  </span><span>const </span>vertices = [<br/>    -<span>0.5</span><span>, </span><span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>0.5</span><span>, </span>-<span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.5</span><span>, </span>-<span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.5</span><span>, </span><span>0.5</span><span>, </span><span>0<br/></span><span>  </span>]<span>;<br/></span><span><br/></span><span>  </span><span>// Indices defined in counter-clockwise order<br/></span><span>  </span>indices = [<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>0</span><span>, </span><span>2</span><span>, </span><span>3</span>]<span>;<br/></span><span><br/></span><span>  </span><span>// Setting up the VBO<br/></span><span>  </span>squareVertexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span>squareVertexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>new </span>Float32Array(vertices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Setting up the IBO<br/></span><span>  </span>squareIndexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>squareIndexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new </span>Uint16Array(indices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Clean<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span>}</pre></div>
<p>If you want to see this scene in action, launch the <kbd>ch02_01_square.html</kbd> file in your browser.</p>
<p>To summarize, for every buffer, we want to do the following:</p>
<ul>
<li>Create a new buffer</li>
<li>Bind it to make it the current buffer</li>
<li>Pass the buffer data using one of the typed arrays</li>
<li>Unbind the buffer</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operations to Manipulate WebGL Buffers</h1>
                </header>
            
            <article>
                
<p>The operations to manipulate WebGL buffers are summarized in the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%;border-color: #000000">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign"><strong>Method</strong></td>
<td class="CDPAlignLeft CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd><span>createBuffer()</span></kbd></td>
<td class="CDPAlignLeft CDPAlign"><span>Creates a new buffer.</span></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd><span>deleteBuffer(buffer)</span></kbd></td>
<td class="CDPAlignLeft CDPAlign"><span>Deletes the supplied buffer.</span></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd><span>bindBuffer(target, buffer)</span></kbd></td>
<td class="CDPAlignLeft CDPAlign">
<p>Binds a buffer object. The accepted values for target are as follows:</p>
<ul>
<li><kbd>ARRAY_BUFFER</kbd> (for vertices)</li>
<li><kbd>ELEMENT_ARRAY_BUFFER</kbd> (for indices)</li>
</ul>
</td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd><span>bufferData(target, data, type)</span></kbd></td>
<td class="CDPAlignLeft CDPAlign">
<p>Provides the buffer data. The accepted values for target are as follows:</p>
<ul>
<li><kbd>ARRAY_BUFFER</kbd> (for vertices)</li>
<li><kbd>ELEMENT_ARRAY_BUFFER</kbd> (for indices)</li>
</ul>
<p>As mentioned earlier, WebGL only accepts JavaScript typed arrays for the data.</p>
<p>The parameter type is a performance hint for WebGL. The accepted values for type are as follows:</p>
<ul>
<li><kbd>STATIC_DRAW</kbd>: Data in the buffer will not be changed (specified once and used many times)</li>
<li><kbd>DYNAMIC_DRAW</kbd>: Data will be changed frequently (specified many times and used many times)</li>
<li><kbd>STREAM_DRAW</kbd>: Data will change on every rendering cycle (specified once and used once)</li>
</ul>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Associating Attributes to VBOs</h1>
                </header>
            
            <article>
                
<p>Once we have created the VBOs, we need to associate these buffers to vertex shader attributes. Each vertex shader attribute will refer to <em>one</em> an<em>d</em> <em>only one </em>buffer, depending on the correspondence that is established, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ef13dc42-3a59-4167-97e1-a8d76ec9ea02.png" style="width:41.58em;height:25.75em;"/></p>
<p>We can achieve this by following these steps:</p>
<ol>
<li>Bind a VBO</li>
<li>Point an attribute to the currently-bound VBO</li>
<li>Enable the attribute</li>
<li>Unbind</li>
</ol>
<p>Let's take a look at the first step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding a VBO</h1>
                </header>
            
            <article>
                
<p>We already know how to do this:</p>
<div>
<pre><span>gl.bindBuffer(gl.ARRAY_BUFFER, myBuffer);</span></pre></div>
<p>Where <kbd>myBuffer</kbd> is the buffer we want to map.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pointing an Attribute to the Currently-Bound VBO</h1>
                </header>
            
            <article>
                
<p>The majority of the WebGL API is about setting up state to supply data to our GLSL programs. In this case, the only input to our GLSL program is <kbd>aVertexPosition</kbd>, which is an attribute. In <a href="0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml">Chapter 3</a>, <em>Lights</em>, we will learn how to define and reference vertex and fragment shader attributes. For now, let's assume that we have the <kbd>aVertexPosition</kbd> attribute, which describes the vertex coordinates in the shader.</p>
<p>The WebGL function that allows pointing attributes to the currently-bound VBOs is <kbd>vertexAttribPointer</kbd>. The following is its signature:</p>
<div>
<pre>gl.vertexAttribPointer(index, size, type, normalize, stride, offset);</pre></div>
<p>Let’s describe each parameter individually:</p>
<ul>
<li><strong>Index</strong>: An attribute's index that we are going to map the currently-bound buffer to.</li>
<li><strong>Size</strong>: Indicates the number of values per vertex that are stored in the currently-bound buffer.</li>
<li><strong>Type</strong>: Specifies the data type of the values stored in the current buffer. It is one of the following constants: <kbd>FIXED</kbd>, <kbd>BYTE</kbd>, <kbd>UNSIGNED_BYTE</kbd>, <kbd>FLOAT</kbd>, <kbd>SHORT</kbd>, or <kbd>UNSIGNED_SHORT</kbd>.</li>
<li><strong>Normalize</strong>: This parameter can be set to <kbd>true</kbd> or <kbd>false</kbd>. It handles numeric conversions that are beyond the scope of this introductory guide. For our purposes, we will set this parameter to <kbd>false</kbd>.</li>
<li><strong>Stride</strong>: If stride is <kbd>0</kbd>, then we are indicating that elements are stored sequentially in the buffer.</li>
<li><strong>Offset</strong>: The position in the buffer from which we will start reading values for the corresponding attribute. It is usually set to <kbd>0</kbd> to indicate that we will start reading values from the first element of the buffer.</li>
</ul>
<div class="packt_tip"><strong><span class="packt_screen">Buffer Pointer</span></strong><br/>
<br/>
<kbd>vertexAttribPointer</kbd> defines a pointer for reading information <em>fro</em><em>m the currently-bound buffer</em>. Remember that an error will be generated if there is no VBO currently bound.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling the Attribute</h1>
                </header>
            
            <article>
                
<p>Finally, we need to activate the vertex shader attribute. <span>Following our example</span>, we just need to add <span><kbd><span>gl.enableVertexAttribArray(positionAttributeLocation);</span></kbd></span>.</p>
<p>The following diagram summarizes the mapping procedure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9e019111-cf3c-4756-97c3-2abce4db9f69.png" style="width:43.75em;height:27.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unbinding a VBO</h1>
                </header>
            
            <article>
                
<p>As a rule of thumb, we should unbind our buffers after we're done using them. We can do so with:</p>
<div>
<p><kbd>gl.bindBuffer(gl.ARRAY_BUFFER, null);</kbd>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering</h1>
                </header>
            
            <article>
                
<p>Once we have defined our VBOs and we have mapped them to the corresponding vertex shader attributes, we are ready to render! To do this, we can use one of the two API functions: <kbd>drawArrays</kbd> or <kbd>drawElements</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing Functions</h1>
                </header>
            
            <article>
                
<div>
<p><span>The <kbd>drawArrays</kbd> and <kbd>drawElements</kbd> functions are used for writing to the framebuffer. <kbd>drawArrays</kbd> uses vertex data in the order in which it is defined in the buffer to create the geometry. In contrast, <kbd>drawElements</kbd> uses indices to access the vertex data buffers and create the geometry. Both <kbd>drawArrays</kbd> and <kbd>drawElements</kbd> will only use </span><strong>enabled arrays</strong><span>. These are the vertex buffer objects that are</span> mapped<span> </span>to active vertex shader attributes<span>.</span></p>
</div>
<p>In our example, the buffer that contains the vertex coordinates is the only enabled array. However, in a more general scenario, there may be several enabled arrays at our disposal.</p>
<p>For instance, we can have arrays with information about vertex colors, vertex normals, texture coordinates, and any other per-vertex data required by the application. In this case, each one of them would be mapped to an active vertex shader attribute.</p>
<div class="packt_tip"><span class="packt_screen">Using Multiple VBOs</span><strong><br/></strong><br/>
In <a href="0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml">Chapter 3</a>, <em>Lights</em>, we will learn how to use a vertex normal buffer and vertex coordinates to create a lighting model for our geometry. In that scenario, we will have two active arrays: vertex coordinates and vertex normals.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using drawArrays</h1>
                </header>
            
            <article>
                
<p>We will call <kbd>drawArrays</kbd> when information about indices is not available. In most cases, <kbd>drawArrays</kbd> is used when the geometry is simple enough that defining indices is overkill <span>–</span> for instance, when we want to render a triangle or a rectangle. In that case, WebGL will create the geometry in the order in which the vertex coordinates are defined in the VBO. If you have contiguous triangles (as we did in the trapezoid example), you will have to <em>repeat</em> these coordinates in the VBO.</p>
<p>If you need to repeat many vertices to create the geometry, <kbd>drawArrays</kbd> is not the optimal method, because the more vertex data you duplicate, the more calls you will have on the vertex shader. This can reduce the overall performance, since the same vertices must go through the pipeline several times, one for each time that they are repeated in the respective VBO:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f878e9ed-961a-454c-9751-4ecb3b96cbe6.png" style="width:42.50em;height:25.08em;"/></p>
<p>The signature for <kbd>drawArrays</kbd> is as follows:</p>
<div>
<pre>gl.drawArrays(mode, first, count)</pre></div>
<p>Where:</p>
<ul>
<li><kbd>mode</kbd>: Represents the type of primitive that we are going to render. The possible values for mode are <kbd>gl.POINTS</kbd>, <kbd>gl.LINE_STRIP</kbd>, <kbd>gl.LINE_LOOP</kbd>, <kbd>gl.LINES</kbd>, <kbd>gl.TRIANGLE_STRIP</kbd>, <kbd>gl.TRIANGLE_FAN</kbd>, and <kbd>gl.TRIANGLES</kbd>.</li>
<li><kbd>first</kbd>: Specifies the starting element in the enabled arrays.</li>
<li><kbd>count</kbd>: The number of elements to be rendered.</li>
</ul>
<div class="packt_infobox"><span class="packt_screen">WebGL drawArrays Specification</span><br/>
<br/>
When <kbd>drawArrays</kbd> is called, it uses count sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with the element <em>first</em>. Mode specifies what kinds of primitives are constructed and how the array elements construct those primitives.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using drawElements</h1>
                </header>
            
            <article>
                
<p>Unlike the previous case where no IBO was defined, <kbd>drawElements</kbd> allows us to use the IBO to tell WebGL how to render the geometry. Remember that <kbd>drawArrays</kbd> uses VBOs, which means that the vertex shader will process the repeated vertices as many times as they appear in the VBO. On the other hand, <kbd>drawElements</kbd> uses indices. Therefore, vertices are only processed once, and can be used as many times as they are defined in the IBO. This feature reduces both the memory and processing required on the GPU.</p>
<p>Let's revisit the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93121f63-2b22-47f1-bccc-337ba09ec6a8.png" style="width:40.67em;height:24.42em;"/></p>
<p>When we use <kbd>drawElements</kbd>, we need at least two buffers: a VBO and an IBO. As the vertex shader gets executed on each vertex, the rendering pipeline assembles the geometry into triangles using the IBO.</p>
<div class="packt_tip"><span class="packt_screen">Binding the IBO with</span> <kbd><span class="packt_screen">drawElements</span></kbd><br/>
<br/>
When using <kbd>drawElements</kbd>, you need to make sure that the corresponding IBO is currently bound.</div>
<p>The signature for <kbd>drawElements</kbd> is as follows:</p>
<div>
<pre>gl.drawElements(mode, count, type, offset)</pre></div>
<p>Where:</p>
<ul>
<li><kbd>mode</kbd>: Represents the type of primitive we are going to render. The possible values for mode are <kbd>POINTS</kbd>, <kbd>LINE_STRIP</kbd>, <kbd>LINE_LOOP</kbd>, <kbd>LINES</kbd>, <kbd>TRIANGLE_STRIP</kbd>, <kbd>TRIANGLE_FAN</kbd>, and <kbd>TRIANGLES</kbd>.</li>
<li><kbd>count</kbd>: Specifies the number of elements to be rendered.</li>
<li><kbd>type</kbd>: Specifies the type of the values in indices. Must be <kbd>UNSIGNED_BYTE</kbd> or <kbd>UNSIGNED_SHORT</kbd>, as we are handling indices (integer numbers).</li>
<li><kbd>offset</kbd>: Indicates which element in the buffer will be the starting point for rendering. It is usually the first element (zero value).</li>
</ul>
<div class="packt_infobox"><span class="packt_screen">WebGL</span> <span class="packt_screen">drawElements</span><span class="packt_screen"> Specification</span><br/>
<br/>
When <kbd>drawElements</kbd> is called, <span>it uses count sequential elements </span>from an enabled array, starting at the offset to construct a sequence of geometric primitives. Mode specifies what kinds of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting Everything Together</h1>
                </header>
            
            <article>
                
<p>Since you've probably been waiting to see how everything works together, let's go over a simple WebGL program that renders a square.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time for Action: Rendering a Square</h1>
                </header>
            
            <article>
                
<p>Follow the given steps:</p>
<ol>
<li>Open the <kbd>ch02_01_square.html</kbd> file in a code editor (ideally one that supports syntax highlighting).</li>
</ol>
<ol start="2">
<li>Examine the structure of this file with the help of the following diagram:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f6ba7319-03f3-49fb-ad75-89d741e24628.png" style="width:40.42em;height:26.83em;"/></p>
<ol start="3">
<li>The web page contains the following:</li>
</ol>
<ul>
<li>The <kbd>&lt;script id="vertex-shader" type="x-shader/x-vertex"&gt;</kbd> script contains the vertex shader code.</li>
<li>The <kbd>&lt;script id="fragment-shader" type="x-shader/x-fragment"&gt;</kbd> script contains the fragment shader code. <span>We won't pay attention to these two scripts as they will be the main point of study in the next chapter. For now, simply notice that we have a fragment shader and a vertex shader.</span></li>
<li>The next script on our web page, <kbd>&lt;script type="text/javascript"&gt;</kbd>, contains all the JavaScript WebGL code that we will need. This script is divided into the following functions:</li>
</ul>
<pre style="padding-left: 60px"><span>// Global variables that are set and used<br/></span><span>// across the application<br/></span><span>let </span>gl<span>,<br/></span><span>  </span>program<span>,<br/></span><span>  </span>squareVertexBuffer<span>,<br/></span><span>  </span>squareIndexBuffer<span>,<br/></span><span>  </span>indices<span>;</span></pre>
<ul>
<li>We list a few global variables that we use throughout our application:</li>
</ul>
<pre style="padding-left: 60px"><span>// Given an id, extract the content's of a shader script<br/></span><span>// from the DOM and return the compiled shader<br/></span><span>function </span><span>getShader</span>(id) {<br/>  <span>const </span>script = document.<span>getElementById</span>(id)<span>;<br/></span><span>  </span><span>const </span>shaderString = script.<span>text</span>.<span>trim</span>()<span>;<br/></span><span><br/></span><span>  </span><span>// Assign shader depending on the type of shader<br/></span><span>  </span><span>let </span>shader<span>;<br/></span><span>  </span><span>if </span>(script.<span>type </span>=== <span>'x-shader/x-vertex'</span>) {<br/>    shader = gl.<span>createShader</span>(gl.<span>VERTEX_SHADER</span>)<span>;<br/></span><span>  </span>}<br/>  <span>else if </span>(script.<span>type </span>=== <span>'x-shader/x-fragment'</span>) {<br/>    shader = gl.<span>createShader</span>(gl.<span>FRAGMENT_SHADER</span>)<span>;<br/></span><span>  </span>}<br/>  <span>else </span>{<br/>    <span>return null</span><span>;<br/></span><span>  </span>}<br/><br/>  <span>// Compile the shader using the supplied shader code<br/></span><span>  </span>gl.<span>shaderSource</span>(shader<span>, </span>shaderString)<span>;<br/></span><span>  </span>gl.<span>compileShader</span>(shader)<span>;<br/></span><span><br/></span><span>  </span><span>// Ensure the shader is valid<br/></span><span>  </span><span>if </span>(!gl.<span>getShaderParameter</span>(shader<span>, </span>gl.<span>COMPILE_STATUS</span>)) {<br/>    console.<span>error</span>(gl.<span>getShaderInfoLog</span>(shader))<span>;<br/></span><span>    </span><span>return null</span><span>;<br/></span><span>  </span>}<br/><br/>  <span>return </span>shader<span>;<br/></span>}</pre>
<ul>
<li><kbd>getShader</kbd> extracts the contents of a shader present in the HTML web page given its <kbd>id</kbd>:</li>
</ul>
<pre style="padding-left: 60px"><span>// Create a program with the appropriate vertex and fragment shaders<br/></span><span>function </span><span>initProgram</span>() {<br/>  <span>const </span>vertexShader = <span>getShader</span>(<span>'vertex-shader'</span>)<span>;<br/></span><span>  </span><span>const </span>fragmentShader = <span>getShader</span>(<span>'fragment-shader'</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Create a program<br/></span><span>  </span>program = gl.<span>createProgram</span>()<span>;<br/></span><span>  </span><span>// Attach the shaders to this program<br/></span><span>  </span>gl.<span>attachShader</span>(program<span>, </span>vertexShader)<span>;<br/></span><span>  </span>gl.<span>attachShader</span>(program<span>, </span>fragmentShader)<span>;<br/></span><span>  </span>gl.<span>linkProgram</span>(program)<span>;<br/></span><span><br/></span><span>  </span><span>if </span>(!gl.<span>getProgramParameter</span>(program<span>, </span>gl.<span>LINK_STATUS</span>)) {<br/>    console.<span>error</span>(<span>'Could not initialize shaders'</span>)<span>;<br/></span><span>  </span>}<br/><br/>  <span>// Use this program instance<br/></span><span>  </span>gl.<span>useProgram</span>(program)<span>;<br/></span><span>  </span><span>// We attach the location of these shader values to the program <br/>  // instance </span><span>for easy access later in the code<br/></span><span>  </span>program.<span>aVertexPosition </span>= gl.<span>getAttribLocation</span>(program<span>, </span><span>'aVertexPosition'</span>)<span>;<br/></span>}</pre>
<ul>
<li><kbd>initProgram</kbd> obtains a reference for the vertex shader and the fragment shader present in the web page (that is, the first two scripts that we discussed) and passes them along to the GPU to be compiled. Lastly, we attach the location of the <kbd>aVertexPosition</kbd> attribute to the <kbd>program</kbd> object so that it can be easily referenced later. <span>Looking up <kbd>attribute</kbd> and <kbd>uniform</kbd> locations is expensive; therefore, such operations should happen once during initialization. </span>We will cover these techniques <span>in later chapters</span>:</li>
</ul>
<pre style="padding-left: 60px"><span>// Set up the buffers for the square<br/></span><span>function </span><span>initBuffers</span>() {<br/>  <span>/*<br/></span><span>    V0                    V3<br/></span><span>    (-0.5, 0.5, 0)        (0.5, 0.5, 0)<br/></span><span>    X---------------------X<br/></span><span>    |                     |<br/></span><span>    |                     |<br/></span><span>    |       (0, 0)        |<br/></span><span>    |                     |<br/></span><span>    |                     |<br/></span><span>    X---------------------X<br/></span><span>    V1                    V2<br/></span><span>    (-0.5, -0.5, 0)       (0.5, -0.5, 0)<br/></span><span>  */<br/></span><span>  </span><span>const </span>vertices = [<br/>    -<span>0.5</span><span>, </span><span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>0.5</span><span>, </span>-<span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.5</span><span>, </span>-<span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.5</span><span>, </span><span>0.5</span><span>, </span><span>0<br/></span><span>  </span>]<span>;<br/></span><span><br/></span><span>  </span><span>// Indices defined in counter-clockwise order<br/></span><span>  </span>indices = [<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>0</span><span>, </span><span>2</span><span>, </span><span>3</span>]<span>;<br/></span><span><br/></span><span>  </span><span>// Setting up the VBO<br/></span><span>  </span>squareVertexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span>squareVertexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>new </span>Float32Array(vertices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Setting up the IBO<br/></span><span>  </span>squareIndexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>squareIndexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new </span>Uint16Array(indices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Clean<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span>}</pre>
<ul>
<li><kbd>initBuffers</kbd> contains the API calls to create and initialize buffers, as we discussed <span>earlier in this chapter</span>. In this example, we create a VBO to store coordinates for the square and an IBO to store the indices of the square:</li>
</ul>
<pre style="padding-left: 60px"><span>// We call draw to render to our canvas<br/></span><span>function </span><span>draw</span>() {<br/>  <span>// Clear the scene<br/></span><span>  </span>gl.<span>clear</span>(gl.<span>COLOR_BUFFER_BIT </span>| gl.<span>DEPTH_BUFFER_BIT</span>)<span>;<br/></span><span>  </span>gl.<span>viewport</span>(<span>0</span><span>, </span><span>0</span><span>, </span>gl.<span>canvas</span>.<span>width</span><span>, </span>gl.<span>canvas</span>.<span>height</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Use the buffers we've constructed<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span>squareVertexBuffer)<span>;<br/></span><span>  </span>gl.<span>vertexAttribPointer</span>(program.<span>aVertexPosition</span><span>, </span><span>3</span><span>, </span>gl.<span>FLOAT</span><span>, <br/></span><span>   false</span><span>, </span><span>0</span><span>, </span><span>0</span>)<span>;<br/></span><span>  </span>gl.<span>enableVertexAttribArray</span>(program.<span>aVertexPosition</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Bind IBO<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>squareIndexBuffer)<span>;<br/></span><span><br/></span><span>  </span><span>// Draw to the scene using triangle primitives<br/></span><span>  </span>gl.<span>drawElements</span>(gl.<span>TRIANGLES</span><span>, </span>indices.<span>length</span><span>, </span>gl.<span>UNSIGNED_SHORT</span><span>, <br/></span><span>   0</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Clean<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span>}</pre>
<ul>
<li><kbd>draw</kbd> maps the VBO to the respective vertex buffer attribute, <kbd>program.aVertexPosition</kbd>, and enables it by calling <kbd>enableVertexAttribArray</kbd>. It then binds the IBO and calls the <kbd>drawElements</kbd> function. We will cover this in more detail in later chapters:</li>
</ul>
<pre style="padding-left: 60px"><span>// Entry point to our application<br/></span><span>function </span><span>init</span>() {<br/>  <span>// Retrieve the canvas<br/></span><span>  </span><span>const </span>canvas = utils.<span>getCanvas</span>(<span>'webgl-canvas'</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Set the canvas to the size of the screen<br/></span><span>  </span>canvas.<span>width </span>= window.<span>innerWidth</span><span>;<br/></span><span>  </span>canvas.<span>height </span>= window.<span>innerHeight</span><span>;<br/></span><span><br/></span><span>  </span><span>// Retrieve a WebGL context<br/></span><span>  </span>gl = utils.<span>getGLContext</span>(canvas)<span>;<br/></span><span>  </span><span>// Set the clear color to be black<br/></span><span>  </span>gl.<span>clearColor</span>(<span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>1</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Call the functions in an appropriate order<br/></span><span>  </span><span>initProgram</span>()<span>;<br/></span><span>  </span><span>initBuffers</span>()<span>;<br/></span><span>  </span><span>draw</span>()<span>;<br/></span>}</pre>
<ul>
<li><kbd>init</kbd> is the entry point for the entire application. When the page has loaded, <kbd>init</kbd> is invoked via <kbd>window.onload = init</kbd>. It's important to note that the order of functions invoked inside of <kbd>init</kbd> are important to set up and render the geometry. W<span>e also set the canvas dimension to take the size of the entire window (fullscreen). </span>As mentioned previously, in the <kbd>draw</kbd> function, we are using <kbd>canvas.width</kbd> and <kbd>canvas.height</kbd> as the source of truth for our drawing dimensions.</li>
</ul>
<ol start="4">
<li>Open the <kbd>ch02_01_square.html</kbd> file in the HTML5 browser of your preference (Firefox, Safari, Chrome, or Opera), and you should see the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/230dfe04-f3bd-4609-b9f3-90cba1c1efce.png" style="width:22.08em;height:14.42em;"/></p>
<ol start="5">
<li>Open up the code for <kbd>ch02_01_square.html</kbd> and scroll down to the <kbd>initBuffers</kbd> function. Please pay attention to the diagram that appears as a comment inside of the function. This diagram describes how the vertices and indices are organized. You should see something like the following:</li>
</ol>
<div>
<pre style="padding-left: 60px"><span>/*<br/></span><span>  V0                    V3<br/></span><span>  (-0.5, 0.5, 0)        (0.5, 0.5, 0)<br/></span><span>  X---------------------X<br/></span><span>  |                     |<br/></span><span>  |                     |<br/></span><span>  |       (0, 0)        |<br/></span><span>  |                     |<br/></span><span>  |                     |<br/></span><span>  X---------------------X<br/></span><span>  V1                    V2<br/></span><span>  (-0.5, -0.5, 0)       (0.5, -0.5, 0)<br/></span><span>*/</span></pre></div>
<ol start="6">
<li>Try to modify the existing buffers to turn the square into a pentagon. How would you do this?</li>
</ol>
<div class="packt_tip"><span class="packt_screen">Updating the Geometry</span> <span class="packt_screen">Definition</span><br/>
<br/>
Modify the vertex buffer array and index array so that the resulting figure is a pentagon instead of a square. To do this, you need to add one vertex to the vertex array and define one more triangle in the index array.</div>
<ol start="7">
<li>Save the file with a different name and open it in the HTML5 browser of your preference to test it.</li>
</ol>
<p><em><strong>What just happened?</strong></em></p>
<p>You have learned about the different code elements that conform to a WebGL app. The <kbd>initBuffers</kbd> function has been examined closely and modified to render a different geometry.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Have a Go: Changing the Square Color</h1>
                </header>
            
            <article>
                
<p>Go to the fragment shader and change the color of your geometry.</p>
<div class="packt_tip"><span class="packt_screen">Four-Component Color Vector</span><br/>
<br/>
The format is (red, green, blue, alpha). Alpha is always <kbd>1.0</kbd> (for now), and the first three arguments are float numbers in the range of <kbd>0.0</kbd> to <kbd>1.0</kbd>.</div>
<p>Remember to save the file after making the changes in your text editor before opening it in your browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Have a Go: Rendering Using drawArrays</h1>
                </header>
            
            <article>
                
<p class="mce-root">Our square was defined using <kbd>drawElements</kbd> via vertices and indices. Go ahead and render the same square using <kbd>drawArrays</kbd>.</p>
<div class="packt_tip"><span class="packt_screen">Hint</span><br/>
<br/>
Given that you don't use indices with <kbd>drawArrays</kbd>, you won't need an <kbd>IBO</kbd>. So, you will need to duplicate vertices to construct this geometry.</div>
<div class="packt_tip"><span class="packt_screen">Hint</span><strong><br/>
<br/></strong> For reference, you can find the source code for this exercise in <kbd>ch02_02_square-arrays.html</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vertex Array Objects</h1>
                </header>
            
            <article>
                
<p><span><strong>Vertex array objects (VAOs)</strong> allow you to store all of the vertex/index binding information for a set of buffers in a single, easy to manage object. That is, the state of attributes, which buffers to use for each attribute, and how to pull data out from those buffers, is collected into a VAO. Although we can implement VAOs in WebGL 1 by using extensions, they are available by default in WebGL 2.</span></p>
<p>This is an important feature that should <em>always </em>be used, since it significantly reduces rendering times. When not using VAOs, all attributes data is in global WebGL state, which means that calling functions such as <kbd>gl.vertexAttribPointer</kbd>, <kbd>gl.enableVertexAttribArray</kbd>, and <kbd>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)</kbd> manipulates the global state. This leads to performance loss, because before any draw call, we would need to set up all vertex attributes and set the <kbd>ELEMENT_ARRAY_BUFFER</kbd> where indexed data is being used. On the other hand, with VAOs, we would set up all attributes during our application's initialization and simply bind the data at render, yielding much better performance.</p>
<p class="mce-root">Let's see how we can start using VAOs from here on out!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time for Action: Rendering a Square Using a VAO</h1>
                </header>
            
            <article>
                
<p><span>Let's refactor a previous example</span><span> using VAOs:</span></p>
<ol>
<li>Open up <span><kbd>ch02_01_square.html</kbd> in your editor.</span></li>
<li>First, we update our global variables:</li>
</ol>
<pre style="padding-left: 60px"><span>// Global variables that are set and used<br/></span><span>// across the application<br/></span><span>let </span>gl<span>,<br/></span><span>  </span>program<span>,<br/></span><span>  </span><strong>squareVAO</strong><span><strong>,</strong><br/></span><span>  </span>squareIndexBuffer<span>,<br/></span><span>  </span>indices<span>;</span></pre>
<ol start="3">
<li>We've replaced <kbd>squareVertexBuffer</kbd> with <kbd>squareVAO</kbd>, as we no longer need to reference the vertex buffer directly.</li>
</ol>
<ol start="4">
<li>Next, we update the <kbd>initBuffers</kbd> functions as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>// Set up the buffers for the square<br/></span><span>function </span><span>initBuffers</span>() {<br/>  <span>/*<br/></span><span>    V0                    V3<br/></span><span>    (-0.5, 0.5, 0)        (0.5, 0.5, 0)<br/></span><span>    X---------------------X<br/></span><span>    |                     |<br/></span><span>    |                     |<br/></span><span>    |       (0, 0)        |<br/></span><span>    |                     |<br/></span><span>    |                     |<br/></span><span>    X---------------------X<br/></span><span>    V1                    V2<br/></span><span>    (-0.5, -0.5, 0)       (0.5, -0.5, 0)<br/></span><span>  */<br/></span><span>  </span><span>const </span>vertices = [<br/>    -<span>0.5</span><span>, </span><span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>0.5</span><span>, </span>-<span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.5</span><span>, </span>-<span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.5</span><span>, </span><span>0.5</span><span>, </span><span>0<br/></span><span>  </span>]<span>;<br/></span><span><br/></span><span>  </span><span>// Indices defined in counter-clockwise order<br/></span><span>  </span>indices = [<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>0</span><span>, </span><span>2</span><span>, </span><span>3</span>]<span>;<br/></span><span><br/></span><strong><span>  </span><span>// Create VAO instance<br/></span><span>  </span>squareVAO = gl.createVertexArray()<span>;<br/></span><span><br/></span><span>  </span><span>// Bind it so we can work on it<br/></span><span>  </span>gl.bindVertexArray(squareVAO)</strong><span><strong>;</strong><br/></span><span><br/></span><span>  </span><span>const </span>squareVertexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span>squareVertexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>new </span>Float32Array(vertices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><strong><span>// Provide instructions for VAO to use data later in draw<br/></span><span>  </span>gl.<span>enableVertexAttribArray</span>(program.<span>aVertexPosition</span>)<span>;<br/></span><span>  </span>gl.<span>vertexAttribPointer</span>(program.<span>aVertexPosition</span><span>, </span><span>3</span><span>, </span>gl.<span>FLOAT</span><span>, <br/></span><span>   false</span><span>, </span><span>0</span><span>, </span><span>0</span>)<span>;<br/></span></strong><span><br/></span><span>  </span><span>// Setting up the IBO<br/></span><span>  </span>squareIndexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>squareIndexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new </span>Uint16Array(indices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Clean<br/></span><strong><span>  </span>gl.bindVertexArray(<span>null</span>)</strong><span><strong>;</strong><br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span>}</pre>
<ol start="5">
<li>We create a new VAO instance using <kbd>gl.createVertexArray();</kbd> and assign it to <kbd>squareVAO</kbd>.</li>
<li>Then, we bind <kbd>squareVAO</kbd> with <kbd>gl.bindVertexArray(squareVAO);</kbd> <span>so that all of our attribute settings will apply to that set of attribute state.</span></li>
<li>After the <kbd>squareVertexBuffer</kbd> has been configured, we instruct the currently bound VAO (i.e. <kbd>squareVAO</kbd>) on how to extract data given the instructions for <kbd>aVertexPosition</kbd>. These instructions are the same ones that previously sat inside of the <kbd>draw</kbd> function; but now, they happen <em>once </em>during initialization.</li>
<li>Lastly, we need to use this VAO in our <kbd>draw</kbd> function:</li>
</ol>
<pre style="padding-left: 60px"><span>// We call draw to render to our canvas<br/></span><span>function </span><span>draw</span>() {<br/>  <span>// Clear the scene<br/></span><span>  </span>gl.<span>clear</span>(gl.<span>COLOR_BUFFER_BIT </span>| gl.<span>DEPTH_BUFFER_BIT</span>)<span>;<br/></span><span>  </span>gl.<span>viewport</span>(<span>0</span><span>, </span><span>0</span><span>, </span>gl.<span>canvas</span>.<span>width</span><span>, </span>gl.<span>canvas</span>.<span>height</span>)<span>;<br/></span><span><br/></span><strong><span>  </span><span>// Bind the VAO<br/></span><span>  </span>gl.bindVertexArray(squareVAO)</strong><span><strong>;</strong><br/></span><span><br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>squareIndexBuffer)<span>;<br/></span><span><br/></span><span>  </span><span>// Draw to the scene using triangle primitives<br/></span><span>  </span>gl.<span>drawElements</span>(gl.<span>TRIANGLES</span><span>, </span>indices.<span>length</span><span>, </span>gl.<span>UNSIGNED_SHORT</span><span>, <br/></span><span>   0</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Clean<br/></span><strong><span>  </span>gl.bindVertexArray(<span>null</span>)<span>;<br/></span></strong><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span>}</pre>
<ol start="9">
<li>The updated <kbd>draw</kbd> function is far simpler! We simply bind the VAO (i.e. <kbd>squareVAO</kbd>) and allow for it to handle the instructions we provided it inside of <kbd>initBuffers</kbd>.</li>
</ol>
<ol start="10">
<li>Lastly, it's good practice to unbind buffers and VAOs after usage by providing <kbd>null</kbd> values.</li>
<li>Save the file and open it in your browser. You should see the same square being rendered using a VAO:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/29fb58a7-d500-4205-90eb-6c336690bc22.png" style="width:21.92em;height:14.42em;"/></p>
<ol start="12">
<li>The source code for this exercise can be found in <span><kbd>ch02_03_square-vao.html</kbd>.</span></li>
</ol>
<p>Given that we're currently rendering a single geometry, using a VAO may seem unnecessarily complex. That is a reasonable assessment! However, as the complexity of our application grows, using VAOs becomes a foundational feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time for Action: Rendering Modes</h1>
                </header>
            
            <article>
                
<p>Let's revisit the signature of the <kbd>drawElements</kbd> function:</p>
<div>
<pre>gl.drawElements(mode, count, type, offset)</pre></div>
<p>The first parameter determines the type of primitives that we are rendering. In the following section, we will see the different rendering modes with examples.</p>
<p>Follow the given steps:</p>
<ol>
<li>Open the <kbd>ch02_04_rendering-modes.html</kbd> file in your browser. This example follows the same structure as in the previous section.</li>
<li>Open <kbd>ch02_04_rendering-modes.html</kbd> in your editor and scroll down to the <kbd>initBuffers</kbd> function:</li>
</ol>
<pre style="padding-left: 60px"><span>function </span><span>initBuffers</span>() {<br/>  <span>const </span>vertices = [<br/>    -<span>0.5</span><span>, </span>-<span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>0.25</span><span>, </span><span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.0</span><span>, </span>-<span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.25</span><span>, </span><span>0.5</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>0.5</span><span>, </span>-<span>0.5</span><span>, </span><span>0<br/></span><span>  </span>]<span>;<br/></span><span><br/></span><span>  </span>indices = [<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>0</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>]<span>;<br/></span><span><br/></span><span>  </span><span>// Create VAO<br/></span><span>  </span>trapezoidVAO = gl.createVertexArray()<span>;<br/></span><span><br/></span><span>  </span><span>// Bind VAO<br/></span><span>  </span>gl.bindVertexArray(trapezoidVAO)<span>;<br/></span><span><br/></span><span>  </span><span>const </span>trapezoidVertexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span>trapezoidVertexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>new </span>Float32Array(vertices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span>  </span><span>// Provide instructions to VAO<br/></span><span>  </span>gl.<span>vertexAttribPointer</span>(program.<span>aVertexPosition</span><span>, </span><span>3</span><span>, </span>gl.<span>FLOAT</span><span>, <br/></span><span>   false</span><span>, </span><span>0</span><span>, </span><span>0</span>)<span>;<br/></span><span>  </span>gl.<span>enableVertexAttribArray</span>(program.<span>aVertexPosition</span>)<span>;<br/></span><span><br/></span><span>  </span>trapezoidIndexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>trapezoidIndexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new </span>Uint16Array(indices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Clean<br/></span><span>  </span>gl.bindVertexArray(<span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span>}</pre>
<ol start="3">
<li>Here, you will see that we are drawing a trapezoid. However, on screen, you will see two triangles! Later, we'll see how this happened.</li>
<li>At the top of the page, there is a settings controller that allows you to select the different rendering modes that WebGL provides:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/142fa15e-666d-4653-bb3e-353f5aa521f0.png" style="width:39.83em;height:25.25em;"/></p>
<pre style="padding-left: 60px"><span>let </span>gl<span>,<br/></span><span>  </span>canvas<span>,<br/></span><span>  </span>program<span>,<br/></span><span>  </span>indices<span>,<br/></span><span>  </span>trapezoidVAO<span>,<br/></span><span>  </span>trapezoidIndexBuffer<span>,<br/></span><span>  </span><span>// Global variable that captures the current rendering mode type<br/></span><strong><span>  </span>renderingMode = <span>'TRIANGLES'</span><span>;</span></strong></pre>
<ol start="5">
<li>When you select any option from the settings, you are changing the value of the <kbd>renderingMode</kbd> variable defined at the top of the code (scroll up if you want to see where it is defined). The code that sets up the settings controller is inside the <kbd>initControls</kbd> function. We will cover this functionality later.</li>
<li>To see how each option modifies the rendering, scroll to the <kbd>draw</kbd> function:</li>
</ol>
<pre style="padding-left: 60px"><span>function </span><span>draw</span>() {<br/>  gl.<span>clear</span>(gl.<span>COLOR_BUFFER_BIT </span>| gl.<span>DEPTH_BUFFER_BIT</span>)<span>;<br/></span><span>  </span>gl.<span>viewport</span>(<span>0</span><span>, </span><span>0</span><span>, </span>gl.<span>canvas</span>.<span>width</span><span>, </span>gl.<span>canvas</span>.<span>height</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Bind VAO<br/></span><span>  </span>gl.bindVertexArray(trapezoidVAO)<span>;<br/></span><span><br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>trapezoidIndexBuffer)<span>;<br/></span><span><br/></span><span>  </span><span>// Depending on the rendering mode type, we will draw differently<br/></span><span>  </span><span>switch </span>(renderingMode) {<br/>    <span>case </span><span>'TRIANGLES'</span>: {<br/>      indices = [<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>]<span>;<br/></span><span>      </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new <br/></span>       Uint16Array(indices)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span>      </span>gl.<span>drawElements</span>(gl.<span>TRIANGLES</span><span>, </span>indices.<span>length</span><span>, <br/></span>       gl.<span>UNSIGNED_SHORT</span><span>, <br/></span><span>       0</span>)<span>;<br/></span><span>      </span><span>break</span><span>;<br/></span><span>    </span>}<br/>    <span>case </span><span>'LINES'</span>: {<br/>      indices = [<span>1</span><span>, </span><span>3</span><span>, </span><span>0</span><span>, </span><span>4</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>2</span><span>, </span><span>3</span>]<span>;<br/></span><span>      </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new <br/></span>       Uint16Array(indices)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span>      </span>gl.<span>drawElements</span>(gl.<span>LINES</span><span>, </span>indices.<span>length</span><span>, </span>gl.<span>UNSIGNED_SHORT</span><span>, <br/></span><span>       0</span>)<span>;<br/></span><span>      </span><span>break</span><span>;<br/></span><span>    </span>}<br/>    <span>case </span><span>'POINTS'</span>: {<br/>      indices = [<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span>]<span>;<br/></span><span>      </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new <br/></span>       Uint16Array(indices)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span>      </span>gl.<span>drawElements</span>(gl.<span>POINTS</span><span>, </span>indices.<span>length</span><span>, </span>gl.<span>UNSIGNED_SHORT</span><span>, <br/></span><span>       0</span>)<span>;<br/></span><span>      </span><span>break</span><span>;<br/></span><span>    </span>}<br/>    <span>case </span><span>'LINE_LOOP'</span>: {<br/>      indices = [<span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>1</span><span>, </span><span>0</span>]<span>;<br/></span><span>      </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new <br/></span>       Uint16Array(indices)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span>      </span>gl.<span>drawElements</span>(gl.<span>LINE_LOOP</span><span>, </span>indices.<span>length</span><span>, <br/></span>       gl.<span>UNSIGNED_SHORT</span><span>, </span><span>0</span>)<span>;<br/></span><span>      </span><span>break</span><span>;<br/></span><span>    </span>}<br/>    <span>case </span><span>'LINE_STRIP'</span>: {<br/>      indices = [<span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>1</span><span>, </span><span>0</span>]<span>;<br/></span><span>      </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new <br/></span>       Uint16Array(indices)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span>      </span>gl.<span>drawElements</span>(gl.<span>LINE_STRIP</span><span>, </span>indices.<span>length</span><span>, <br/></span>       gl.<span>UNSIGNED_SHORT</span><span>, </span><span>0</span>)<span>;<br/></span><span>      </span><span>break</span><span>;<br/></span><span>    </span>}<br/>    <span>case </span><span>'TRIANGLE_STRIP'</span>: {<br/>      indices = [<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>]<span>;<br/></span><span>      </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new <br/></span>       Uint16Array(indices)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span>      </span>gl.<span>drawElements</span>(gl.<span>TRIANGLE_STRIP</span><span>, </span>indices.<span>length</span><span>, <br/></span>       gl.<span>UNSIGNED_SHORT</span><span>, </span><span>0</span>)<span>;<br/></span><span>      </span><span>break</span><span>;<br/></span><span>    </span>}<br/>    <span>case </span><span>'TRIANGLE_FAN'</span>: {<br/>      indices = [<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>]<span>;<br/></span><span>      </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new <br/></span>       Uint16Array(indices)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span>      </span>gl.<span>drawElements</span>(gl.<span>TRIANGLE_FAN</span><span>, </span>indices.<span>length</span><span>, <br/></span>       gl.<span>UNSIGNED_SHORT</span><span>, </span><span>0</span>)<span>;<br/></span><span>      </span><span>break</span><span>;<br/></span><span>    </span>}<br/>  }<br/><br/>  <span>// Clean<br/></span><span>  </span>gl.bindVertexArray(<span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span>}</pre>
<ol start="7">
<li>You will see that after binding the IBO <kbd>trapezoidIndexBuffer</kbd> with the following instruction:</li>
</ol>
<div>
<pre style="padding-left: 60px">gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>trapezoidIndexBuffer)<span>;</span></pre></div>
<ol start="8">
<li><span>You also have a switch statement where there is some code that executes, depending on the value of the </span><kbd>renderingMode</kbd><span> variable.</span></li>
<li>For each mode, we define the contents of the JavaScript array indices. Then, we pass this array to the currently-bound buffer, <kbd>trapezoidIndexBuffer</kbd>, by using the <kbd>bufferData</kbd> function. Finally, we call the <kbd>drawElements</kbd> function.</li>
<li>Let's see what each mode does:</li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%;border-color: #000000">
<tbody>
<tr>
<td><strong>Mode</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd><span>TRIANGLES</span></kbd></td>
<td>
<p>When you use the <kbd>TRIANGLES</kbd> mode, WebGL will use the first three indices defined in your IBO to construct the first triangle, the next three to construct the second triangle, and so on.</p>
<p>In this example, we are drawing two triangles, which can be verified by examining the JavaScript indices array that populates the IBO:<span> </span><kbd>indices = [0, 1, 2, 2, 3, 4];</kbd>.</p>
</td>
</tr>
<tr>
<td><kbd><span>LINES</span></kbd></td>
<td>
<p>The <kbd>LINES</kbd> mode will instruct WebGL to take each consecutive pair of indices defined in the IBO and draw lines by taking the coordinates of the corresponding vertices.</p>
<p>For instance,<span> </span><kbd>indices = [1, 3, 0, 4, 1, 2, 2, 3];</kbd> will draw four lines: from vertex number <kbd>1</kbd> to vertex number <kbd>3</kbd>, from vertex number <kbd>0</kbd> to vertex number <kbd>4</kbd>, from vertex number <kbd>1</kbd> to vertex number <kbd>2</kbd>, and from vertex number <kbd>2</kbd> to vertex number <kbd>3</kbd>.</p>
</td>
</tr>
<tr>
<td><kbd><span>POINTS</span></kbd></td>
<td>
<p>When we use the <kbd>POINTS</kbd> mode, WebGL will not generate surfaces. Instead, it will render the vertices that we had defined using the index array.</p>
<p>In this example, we will only render vertices number <kbd>1</kbd>, <kbd>2</kbd>, and <kbd>3</kbd> with <kbd>indices = [1, 2, 3];</kbd>.</p>
</td>
</tr>
<tr>
<td><kbd><span>LINE_LOOP</span></kbd></td>
<td>
<p class="mce-root"><span><kbd>LINE_LOOP</kbd> draws a closed loop connecting the vertices defined in the IBO to the next one.</span></p>
<p class="mce-root"><span>In our case, it will be <kbd>indices = [2, 3, 4, 1, 0];</kbd>.</span></p>
</td>
</tr>
<tr>
<td><kbd><span>LINE_STRIP</span></kbd></td>
<td>
<p><kbd>LINE_STRIP</kbd> is similar to <kbd>LINE_LOOP</kbd>. The difference is that WebGL does not connect the last vertex to the first one (not a closed loop).</p>
<p>The indices JavaScript array will be<span> </span><kbd>indices = [2, 3, 4, 1, 0];</kbd>.</p>
</td>
</tr>
<tr>
<td><kbd><span>TRIANGLE_STRIP</span></kbd></td>
<td>
<p><kbd>TRIANGLE_STRIP</kbd> draws connected triangles. Every vertex is specified after the first three.</p>
<p>In our example, vertices number <kbd>0</kbd>, number <kbd>1</kbd>, and number <kbd>2</kbd> create a new triangle. If we have<span> </span><kbd>indices = [0, 1, 2, 3, 4];</kbd>, then we will generate the triangles <em>(0, 1, 2)</em>, <em>(1, 2, 3)</em>, and <em>(2, 3, 4)</em>.</p>
</td>
</tr>
<tr>
<td><kbd><span>TRIANGLE_FAN</span></kbd></td>
<td>
<p><kbd>TRIANGLE_FAN</kbd> creates triangles in a similar way to <kbd>TRIANGLE_STRIP</kbd>. However, the first vertex defined in the IBO is taken as the origin of the fan (the only shared vertex among consecutive triangles).</p>
<p>In our example,<span> </span><kbd>indices = [0, 1, 2, 3, 4];</kbd><span> </span>will create the triangles <em>(0, 1, 2)</em> and <em>(0, 3, 4)</em>.</p>
</td>
</tr>
</tbody>
</table>
<ol start="11">
<li><span>The following diagram can be useful in visualizing these various rendering modes. That being said, it's easiest to see these modes in action by changing the setting's drop-down values and seeing the various results:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/22264ffd-5283-4738-a52a-7ff3b1271121.png" style="width:39.25em;height:31.50em;"/></p>
<ol start="12">
<li>Let's make some changes by e<span>diting <kbd>ch02_04_rendering-modes.html</kbd> so that when you select the </span><span><kbd>TRIANGLES</kbd> option, you render the trapezoid instead of two triangles.</span></li>
</ol>
<div class="packt_tip"><span class="packt_screen"><strong><span class="packt_screen">Hint</span></strong></span><br/>
<br/>
You need one extra triangle in the indices array.</div>
<ol start="13">
<li>Save the file and test it in your browser.</li>
<li>Edit the web page so that you draw the letter <strong>M</strong> using the <kbd>LINES</kbd> option.</li>
</ol>
<div class="packt_tip"><span class="packt_screen">Hint</span><br/>
<br/>
You need to define four lines in the indices array.</div>
<ol start="15">
<li>Just like before, save your changes and test them in your browser.</li>
<li>Using the <kbd>LINE_LOOP</kbd> mode, draw only the boundary of the trapezoid.</li>
</ol>
<p><em><strong>What just happened?</strong></em></p>
<p>This simple exercise helped us see the different rendering modes supported by WebGL. These different modes determine how to interpret vertex and index data to render an object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebGL as a State Machine: Buffer Manipulation</h1>
                </header>
            
            <article>
                
<p><span>When dealing with buffers for the <kbd>getParameter</kbd>, <kbd>getBufferParameter</kbd>, and <kbd>isBuffer</kbd> functions, new information about the state of the rendering pipeline becomes available to us.</span></p>
<p>Similar to <a href="48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml">Chapter 1</a>, <em>Getting Started</em>, we will use <kbd>getParameter(parameter)</kbd>, where parameter can have the following values:</p>
<ul>
<li><kbd>ARRAY_BUFFER_BINDING</kbd>: Retrieves a reference to the currently-bound VBO</li>
<li><kbd>ELEMENT_ARRAY_BUFFER_BINDING</kbd>: Retrieves a reference to the currently-bound IBO</li>
</ul>
<p>We can also query the size and the usage of the currently-bound VBO and IBO using <kbd>getBufferParameter(type, parameter)</kbd>, where type can have the following values:</p>
<ul>
<li><kbd>ARRAY_BUFFER</kbd>: To refer to the currently-bound VBO</li>
<li><kbd>ELEMENT_ARRAY_BUFFER</kbd>: To refer to the currently-bound IBO</li>
</ul>
<p>And parameter can have the following values:</p>
<ul>
<li><kbd>BUFFER_SIZE</kbd>: Returns the size of the requested buffer</li>
<li><kbd>BUFFER_USAGE</kbd>: Returns the usage of the requested buffer</li>
</ul>
<div class="packt_tip"><strong><span class="packt_screen">Binding Buffers</span></strong><br/>
<br/>
Your VBO and/or IBO needs to be bound when you inspect the state of the currently-bound VBO and/or IBO with <kbd>getParameter</kbd> and <kbd>getBufferParameter</kbd>.</div>
<div class="page">
<div class="section">
<div class="layoutArea">
<p class="column"><span>Finally, </span><kbd>isBuffer(object)</kbd><span> will return </span><kbd>true</kbd><span> if the object is a WebGL buffer, or </span><kbd>false</kbd><span> with an error when the buffer is invalid. Unlike </span><kbd>getParameter</kbd><span> and </span><kbd>getBufferParameter</kbd><span>, </span><kbd>isBuffer</kbd><span> does not require any VBO or IBO to be bound.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time for Action: Querying the State of Buffers</h1>
                </header>
            
            <article>
                
<p>Follow the given steps:</p>
<ol>
<li>Open the <kbd>ch02_05_state-machine.html</kbd> file in your browser. You should see the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/429910d1-7f7c-4a50-a5d9-abdc8e529cc3.png" style="width:66.42em;height:37.17em;"/></p>
<ol start="2">
<li>Open <kbd>ch02_05_state-machine.html</kbd> in your editor and scroll down to the <kbd>initBuffers</kbd> method:</li>
</ol>
<pre style="padding-left: 60px"><span>function </span><span>initBuffers</span>() {<br/>  <span>const </span>vertices = [<br/>    <span>1.5</span><span>, </span><span>0</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>1</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>0.809017</span><span>, </span><span>0.587785</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>0.309017</span><span>, </span><span>0.951057</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>0.309017</span><span>, </span><span>0.951057</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>0.809017</span><span>, </span><span>0.587785</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>1</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>0.809017</span><span>, </span>-<span>0.587785</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>0.309017</span><span>, </span>-<span>0.951057</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>0.309017</span><span>, </span>-<span>0.951057</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>0.809017</span><span>, </span>-<span>0.587785<br/></span><span>  </span>]<span>;<br/></span><span><br/></span><span>  </span>indices = [<br/>    <span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>2</span><span>, </span><span>3</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>3</span><span>, </span><span>4</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>4</span><span>, </span><span>5</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>5</span><span>, </span><span>6</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>6</span><span>, </span><span>7</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>7</span><span>, </span><span>8</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>8</span><span>, </span><span>9</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>9</span><span>, </span><span>10</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>10</span><span>, </span><span>1<br/></span><span>  </span>]<span>;<br/></span><span><br/></span><span>  </span><span>// Create VAO<br/></span><span>  </span>coneVAO = gl.createVertexArray()<span>;<br/></span><span><br/></span><span>  </span><span>// Bind VAO<br/></span><span>  </span>gl.bindVertexArray(coneVAO)<span>;<br/></span><span><br/></span><span>  </span><span>const </span>coneVertexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span>coneVertexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>new </span>Float32Array(vertices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Configure instructions<br/></span><span>  </span>gl.<span>vertexAttribPointer</span>(program.<span>aVertexPosition</span><span>, </span><span>3</span><span>, </span>gl.<span>FLOAT</span><span>, <br/></span><span>   false</span><span>, </span><span>0</span><span>, </span><span>0</span>)<span>;<br/></span><span>  </span>gl.<span>enableVertexAttribArray</span>(program.<span>aVertexPosition</span>)<span>;<br/></span><span><br/></span><span>  </span>coneIndexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>coneIndexBuffer)<span>;<br/></span><span>  </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new </span>Uint16Array(indices)<span>, <br/></span>   gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>  </span><span>// Set the global variables based on the parameter type<br/></span><span>  </span><span>if </span>(coneVertexBuffer === <br/>    gl.<span>getParameter</span>(gl.<span>ARRAY_BUFFER_BINDING</span>)) {<br/>    vboName = <span>'coneVertexBuffer'</span><span>;<br/></span><span>  </span>}<br/>  <span>if </span>(coneIndexBuffer === <br/>    gl.<span>getParameter</span>(gl.<span>ELEMENT_ARRAY_BUFFER_BINDING</span>)) {<br/>    iboName = <span>'coneIndexBuffer'</span><span>;<br/></span><span>  </span>}<br/><br/>  vboSize = gl.<span>getBufferParameter</span>(gl.<span>ARRAY_BUFFER</span><span>, </span>gl.<span>BUFFER_SIZE</span>)<span>;<br/></span><span>  </span>vboUsage = gl.<span>getBufferParameter</span>(gl.<span>ARRAY_BUFFER</span><span>, <br/></span>   gl.<span>BUFFER_USAGE</span>)<span>;<br/></span><span><br/></span><span>  </span>iboSize = gl.<span>getBufferParameter</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, <br/></span>   gl.<span>BUFFER_SIZE</span>)<span>;<br/></span><span>  </span>iboUsage = gl.<span>getBufferParameter</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, <br/></span>   gl.<span>BUFFER_USAGE</span>)<span>;<br/></span><span><br/></span><span>  </span><span>try </span>{<br/>    isVerticesVbo = gl.<span>isBuffer</span>(vertices)<span>;<br/></span><span>  </span>}<br/>  <span>catch </span>(e) {<br/>    isVerticesVbo = <span>false</span><span>;<br/></span><span>  </span>}<br/><br/>  isConeVertexBufferVbo = gl.<span>isBuffer</span>(coneVertexBuffer)<span>;<br/></span><span><br/></span><span>  </span><span>// Clean<br/></span><span>  </span>gl.bindVertexArray(<span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span>}</pre>
<ol start="3">
<li>Pay attention to how we use the methods discussed in this section to retrieve and display information about the current state of the buffers.</li>
<li>The information queried by the <kbd>initBuffers</kbd> function is shown in the settings section of the web page when we use <kbd>updateInfo</kbd>.</li>
</ol>
<ol start="5">
<li>In the settings section of the web page, you will see the following result:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/43adbdf7-8f9d-48c9-826f-4c328423a54b.png" style="width:41.75em;height:24.33em;"/></p>
<ol start="6">
<li>Copy the following line, <kbd>gl.bindBuffer(gl.ARRAY_BUFFER, null);</kbd>, and paste it right before the following line inside of the <kbd>initBuffers</kbd> <span>function: <kbd>coneIndexBuffer = gl.createBuffer();</kbd>.</span></li>
<li>What happens when you launch the page in your browser again?</li>
<li>Why do you think this behavior occurs?</li>
</ol>
<p><em><strong>What just happened?</strong></em></p>
<p>You have learned that the currently-bound buffer is a state variable in WebGL. The buffer is bound until you unbind it by calling <kbd>bindBuffer</kbd> again with the corresponding type (<kbd>ARRAY_BUFFER</kbd> or <kbd>ELEMENT_ARRAY_BUFFER</kbd>) as the first parameter and with <kbd>null</kbd> as the second argument (that is, no buffer to bind). You have also learned that you can only query the state of the currently-bound buffer. Therefore, if you want to query a different buffer, you need to bind it first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Have a Go: Add One Validation</h1>
                </header>
            
            <article>
                
<p>Modify the file so that you can validate and show on screen whether the indices array and the <kbd>coneIndexBuffer</kbd> are WebGL buffers.</p>
<div class="packt_tip"><strong><span class="packt_screen">Hint</span></strong><br/>
<br/>
In order to display the values, you will have to modify the table in the HTML body and modify the <kbd>updateInfo</kbd> function accordingly.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced Geometry-Loading Techniques</h1>
                </header>
            
            <article>
                
<p>So far, we’ve rendered very simple objects. Now, let's investigate how to load a geometry (vertices and indices) from a file instead of declaring the vertices and indices every time we call <kbd>initBuffers</kbd>. To do this, we will make asynchronous calls to the web server using AJAX. We will retrieve the file with our geometry from the web server and then use the built-in JSON parser to convert the context of our files into JavaScript objects. In our case, these objects will be the vertices and indices arrays.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to JavaScript Object Notation (JSON)</h1>
                </header>
            
            <article>
                
<p><strong>JSON</strong> stands for <strong>JavaScript Object Notation</strong>. It is a lightweight, text-based, open format used for data interchange. JSON is commonly used as an alternative to XML.</p>
<p>The power of JSON is that it's language-agnostic. This means that there are parsers in many languages to read and interpret JSON objects. Also, JSON is a subset of the object literal notation of JavaScript. Therefore, we can define JavaScript objects using JSON.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining JSON-Based 3D Models</h1>
                </header>
            
            <article>
                
<p>Let's assume, for example, that we have a model object with two arrays: vertices and indices. Say that these arrays contain the information described in the cone example (<kbd>ch02_06_cone.html</kbd>), as follows:</p>
<div>
<pre><span>function </span><span>initBuffers</span>() {<br/>  <span>const </span>vertices = [<br/>    <span>1.5</span><span>, </span><span>0</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>1</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>0.809017</span><span>, </span><span>0.587785</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>0.309017</span><span>, </span><span>0.951057</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>0.309017</span><span>, </span><span>0.951057</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>0.809017</span><span>, </span><span>0.587785</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>1</span><span>, </span><span>0</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>0.809017</span><span>, </span>-<span>0.587785</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span>-<span>0.309017</span><span>, </span>-<span>0.951057</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>0.309017</span><span>, </span>-<span>0.951057</span><span>,<br/></span><span>    </span>-<span>1.5</span><span>, </span><span>0.809017</span><span>, </span>-<span>0.587785<br/></span><span>  </span>]<span>;<br/></span><span><br/></span><span>  </span>indices = [<br/>    <span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>2</span><span>, </span><span>3</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>3</span><span>, </span><span>4</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>4</span><span>, </span><span>5</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>5</span><span>, </span><span>6</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>6</span><span>, </span><span>7</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>7</span><span>, </span><span>8</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>8</span><span>, </span><span>9</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>9</span><span>, </span><span>10</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>10</span><span>, </span><span>1<br/></span><span>  </span>]<span>;<br/></span><span><br/></span><span>  // ...</span><span><br/></span>}</pre></div>
<p>Following the JSON notation, we would represent these two arrays as an object, as follows:</p>
<div>
<pre>{<br/>  <span>"vertices"</span><span>: </span>[<br/>    <span>1.5</span><span>, </span><span>0</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>1</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>0.809017</span><span>, </span><span>0.587785</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>0.309017</span><span>, </span><span>0.951057</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>-0.309017</span><span>, </span><span>0.951057</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>-0.809017</span><span>, </span><span>0.587785</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>-1</span><span>, </span><span>0</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>-0.809017</span><span>, </span><span>-0.587785</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>-0.309017</span><span>, </span><span>-0.951057</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>0.309017</span><span>, </span><span>-0.951057</span><span>,<br/></span><span>    </span><span>-1.5</span><span>, </span><span>0.809017</span><span>, </span><span>-0.587785<br/></span><span>  </span>]<span>,<br/></span><span>  </span><span>"indices"</span><span>: </span>[<br/>    <span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>2</span><span>, </span><span>3</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>3</span><span>, </span><span>4</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>4</span><span>, </span><span>5</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>5</span><span>, </span><span>6</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>6</span><span>, </span><span>7</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>7</span><span>, </span><span>8</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>8</span><span>, </span><span>9</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>9</span><span>, </span><span>10</span><span>,<br/></span><span>    </span><span>0</span><span>, </span><span>10</span><span>, </span><span>1<br/></span><span>  </span>]<br/>}</pre></div>
<p>Based on this example, we can infer the following syntax rules:</p>
<ul>
<li>The extent of a JSON object is defined by curly brackets (<kbd>{}</kbd>).</li>
<li>Attributes in a JSON object are separated by commas (<kbd>,</kbd>).</li>
<li>There is no comma after the last attribute.</li>
<li>Each attribute of a JSON object has two parts: a <strong>key </strong>and a <strong>value.</strong></li>
<li>The name of an attribute is enclosed by quotation marks (<kbd>""</kbd>).</li>
<li>Each attribute key is separated from its corresponding value with a colon (<kbd>:</kbd>).</li>
<li>Attributes of the array are defined in the same way you would define them in JavaScript.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time for Action: Encoding and Decoding JSON</h1>
                </header>
            
            <article>
                
<p>Most modern web browsers support native JSON encoding and decoding. Let's examine the methods available inside this object:</p>
<table border="1" style="border-collapse: collapse;width: 100%;border-color: #000000">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign"><strong>Method</strong></td>
<td class="CDPAlignLeft CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd><span>JSON.stringify(object)</span></kbd></td>
<td class="CDPAlignLeft CDPAlign"><span>We use <kbd>JSON.stringify</kbd> to convert JavaScript objects to JSON-formatted text.</span></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd><span>JSON.parse(string)</span></kbd></td>
<td class="CDPAlignLeft CDPAlign"><span>We use <kbd>JSON.parse</kbd> to convert text into JavaScript objects.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p><span>Let's learn how to encode and decode with the JSON notation </span>by creating a simple model—a 3D line. Here, we will be focusing on how we do JSON encoding and decoding. Follow the given steps:</p>
<ol>
<li>In your browser, open the interactive JavaScript console. Use the following table for assistance:</li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%;border-color: #000000">
<tbody>
<tr>
<td><strong>Browser</strong></td>
<td><strong>Shortcut keys (PC/Mac)</strong></td>
</tr>
<tr>
<td><span>Firefox</span></td>
<td><em>Ctrl </em>+ <em>Shift </em>+<em> K</em><span>/</span><em>Command </em>+<em> Alt </em>+<em> K</em></td>
</tr>
<tr>
<td><span>Safari</span></td>
<td><em>Ctrl </em>+<em> Shift </em>+<em> C</em><span>/</span><em>Command </em>+<em> Alt </em>+<em> C</em></td>
</tr>
<tr>
<td><span>Chrome</span></td>
<td><em>Ctrl </em>+<em> Shift </em>+<em> J</em><span>/</span><em>Command </em>+<em> Alt</em> +<em> J</em></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>Create a JSON object by typing the following:</li>
</ol>
<pre style="padding-left: 60px">const model = { vertices: [0, 0, 0, 1, 1, 1], indices: [0, 1] };</pre>
<ol start="3"/>
<ol start="3"/>
<ol start="3">
<li>Verify that the model is an object by writing the following:</li>
</ol>
<div>
<pre style="padding-left: 60px">typeof(model); // outputs "object"</pre></div>
<div class="packt_tip"><span class="packt_screen">JavaScript Type-Checking</span><br/>
<br/>
Since many things in JavaScript are <em>objects</em>, it is recommended that you are more rigorous with type-checking. We will just use <kbd>typeof</kbd><strong> </strong>for demonstration purposes. Additionally, there are many utility libraries, such as Lodash (<a href="https://lodash.com/">https://lodash.com</a>), that extend JavaScript features to provide these operations and more.</div>
<ol start="4">
<li>Let's print the model attributes. Write this in the console (press <em>Enter</em> at the end of each line):</li>
</ol>
<div>
<pre style="padding-left: 60px">model.vertices // outputs the vertices<br/>model.indices // outputs the indices</pre></div>
<ol start="5">
<li>Let's create a JSON text:</li>
</ol>
<div>
<pre style="padding-left: 60px">const text = JSON.stringify(model);<br/>alert(text);</pre></div>
<ol start="6">
<li>What happens when you type <kbd>text.vertices</kbd>?</li>
<li>As you can see, you get a message saying that <kbd>text.vertices</kbd> is <kbd>undefined</kbd>. This happens because text is not a JavaScript object, but a <kbd>string</kbd> with the peculiarity of being written according to JSON notation to describe an <kbd>object</kbd>. Everything in it is text, and so it does not have any fields.</li>
<li>Let's convert the JSON text back into an object. Type the following:</li>
</ol>
<div>
<pre style="padding-left: 60px">const model2 = JSON.parse(text);<br/>typeof(model2); // outputs "object"<br/>model2.vertices; // outputs vertices</pre></div>
<p><em><strong>What just happened?</strong></em></p>
<p>We have learned to encode and decode JSON objects. These exercises are relevant because we will use the same process to define our geometry to be loaded from external files. In the next section, we will see how to download geometric models specified with JSON from a web server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous Loading with AJAX</h1>
                </header>
            
            <article>
                
<p>The following diagram summarizes the asynchronous loading of files by the web browser using AJAX:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8c7a9d35-44e1-4c8e-a678-278d6ceb0978.png" style="width:36.00em;height:21.42em;"/></p>
<p>Let's analyze this more closely:</p>
<ul>
<li><strong>Request File</strong>: Indicates the path to the file you want to load. Remember that this file contains the geometry that we will be loading from the web server instead of coding the JavaScript arrays (vertices and indices) directly into the web page.</li>
<li><strong>AJAX Request</strong>: We need to write a function that will perform the AJAX request. Let's call this function <kbd>load</kbd>. The code looks like this:</li>
</ul>
<div>
<pre style="padding-left: 60px"><span>// Given a path to a file, load the assets asynchronously<br/></span><span>function </span><span>load</span>(filePath) {<br/>  <span>// We return the promise so that, if needed, you can know when <br/>  // `load` has resolved<br/></span><span>  </span><span>return </span><span>fetch</span>(filePath)<br/>  <span>// Convert to a valid json<br/></span><span>  </span>.<span>then</span>(res =&gt; res.<span>json</span>())<br/>  <span>// Handle the parsed JSON data<br/></span><span>  </span>.<span>then</span>(data =&gt; {<br/>    <span>// Handle data<br/></span><span>  </span>})<br/>  .<span>catch</span>(error =&gt; {<br/>    <span>// Handle error<br/></span><span>  </span>})<span>;<br/></span>}</pre></div>
<div class="packt_infobox"><span class="packt_screen">AJAX Reques</span><span class="packt_screen"><span class="packt_screen">ts w</span>ith Fetch</span><strong><br/>
<br/></strong> We are leveraging <kbd>fetch</kbd>, an AJAX API provided in modern browsers, for fetching resources. It is very convenient with a <strong>Promise</strong>-based implementation. To learn more about <kbd>fetch</kbd>, visit <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a>.</div>
<p>For now, let's say that this function will perform the AJAX request.</p>
<ul>
<li><strong>Retrieving the file</strong>: The web server will receive and treat our request as a regular HTTP request. In fact, the server does not know that this request is <em>asynchronous </em>(it is asynchronous for the web browser since it does not wait for the answer). The server will look for our file and generate a response, regardless of whether it finds the request.</li>
<li><strong>Asynchronous response</strong>: Once a response is sent to the web browser, the <kbd>fetch</kbd> promise is resolved and the provided callback is invoked. This callback corresponds to the <kbd>then</kbd> request method. If the request is successful, we invoke the <kbd>then</kbd> callback; if it fails, we invoke the <kbd>catch</kbd> callback.</li>
<li><strong>Handling the loaded model</strong>: After our data is received and parsed, we attach a new callback to process the file retrieved from the server. Please notice that in the previous segment of code, we used the promise-based JSON parser to create a JavaScript object from the file before passing it to the next function. The code for the <kbd>load</kbd> function looks like this:</li>
</ul>
<div>
<pre style="padding-left: 60px"><span>// Given a path to a file, load the assets asynchronously<br/></span><span>function </span><span>load</span>(filePath) {<br/>  <span>// We return the promise so that, if needed, you can know when<br/>  // `load` has resolved<br/></span><span>  </span><span>return </span><span>fetch</span>(filePath)<br/>  <span>// Convert to a valid json<br/></span><span>  </span>.<span>then</span>(res =&gt; res.<span>json</span>())<br/>  <span>// Handle the parsed JSON data<br/></span><span>  </span>.<span>then</span>(data =&gt; {<br/>    model = data<span>;<br/></span><span><br/></span><span>    </span><span>// Create VAO<br/></span><span>    </span>vao = gl.createVertexArray()<span>;<br/></span><span><br/></span><span>    </span><span>// Bind VAO<br/></span><span>    </span>gl.bindVertexArray(coneVAO)<span>;</span><span><br/></span><span><br/></span><span>    </span><span>const </span>modelVertexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>    </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span>modelVertexBuffer)<span>;<br/></span><span>    </span>gl.<span>bufferData</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>new <br/></span>     Float32Array(model.<span>vertices</span>)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>    </span><span>// Configure instructions<br/></span><span>    </span>gl.<span>enableVertexAttribArray</span>(program.<span>aVertexPosition</span>)<span>;<br/></span><span>    </span>gl.<span>vertexAttribPointer</span>(program.<span>aVertexPosition</span><span>, </span><span>3</span><span>, </span>gl.<span>FLOAT</span><span>, <br/></span><span>     false</span><span>, </span><span>0</span><span>, </span><span>0</span>)<span>;<br/></span><span><br/></span><span>    </span>modelIndexBuffer = gl.<span>createBuffer</span>()<span>;<br/></span><span>    </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span>modelIndexBuffer)<span>;<br/></span><span>    </span>gl.<span>bufferData</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>new <br/></span>     Uint16Array(model.<span>indices</span>)<span>, </span>gl.<span>STATIC_DRAW</span>)<span>;<br/></span><span><br/></span><span>    </span><span>// Clean<br/></span><span>    </span>gl.bindVertexArray(<span>null</span>)<span>;<br/></span><span>    </span>gl.<span>bindBuffer</span>(gl.<span>ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>    </span>gl.<span>bindBuffer</span>(gl.<span>ELEMENT_ARRAY_BUFFER</span><span>, </span><span>null</span>)<span>;<br/></span><span>  </span>})<br/>  <span>// Display into the console if there are any errors<br/></span><span>  </span>.<span>catch</span>(console.<span>error</span>)<span>;<br/></span>}</pre></div>
<p>If you look closely, you’ll realize that this function is very similar to one of the functions we saw previously: the <kbd>initBuffers</kbd> function. This is reasonable, given that we cannot initialize the buffers until we retrieve the geometry data from the server. Just like <kbd>initBuffers</kbd>, we configure our VAO, VBO, and IBO and pass them the information contained in the JavaScript arrays of our model object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a Web Server</h1>
                </header>
            
            <article>
                
<p>Now that we're fetching assets from a server, we need to serve our application by using a server. If you do <em>not</em> have a web server, we recommend that you install a lightweight web server from the following options:</p>
<ul>
<li><strong>Serve: </strong><a href="https://github.com/zeit/serve">https://github.com/zeit/serve</a></li>
<li><strong>Lighttpd: </strong><a href="http://www.lighttpd.net/">http://www.lighttpd.net</a></li>
<li><strong>Python Server: </strong><a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server">https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server</a></li>
</ul>
<div class="packt_tip"><span class="packt_screen">Hosting Examples</span><strong><br/>
<br/></strong> Although any web server will be able to serve these examples, <kbd>serve</kbd> provides simplicity and great functionality. That being said, be sure to run your server from the root of the examples directory, since the <kbd>common</kbd> directory is a shared dependency across chapters.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working Around the Web Server Requirement</h1>
                </header>
            
            <article>
                
<p>If you have Firefox and do not want to install a web server, you can change <kbd>strict_origin_policy</kbd> to false in <kbd>about:config</kbd>.</p>
<p>If you are using Chrome and do not want to install a web server, make sure that you run it from the command line with the following modifier:</p>
<div>
<pre><strong>--allow-file-access-from-files</strong> </pre></div>
<p>Let's use AJAX and JSON to load a cone from our web server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time for Action: Loading a Cone with AJAX</h1>
                </header>
            
            <article>
                
<p>Follow the given steps:</p>
<ol>
<li>Make sure that your web server is running and access the <kbd>ch02_07_ajax-cone.html</kbd> file using your web server.</li>
</ol>
<div class="packt_tip"><span class="packt_screen">Web Server Address</span><br/>
<br/>
You know that you are using the web server if the URL in the address bar starts with <kbd>localhost/</kbd> or <kbd>127.0.0.1/</kbd> instead of <kbd>file://</kbd>.</div>
<ol start="2">
<li>The folder containing the code for this chapter should look like this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0eb95e36-93cf-4cc9-be0c-19c312fe1a7f.png" style="width:40.25em;height:10.58em;"/></p>
<ol start="3">
<li>Click on <kbd>ch02_07_ajax-cone.html</kbd>.</li>
<li>The example will load in your browser and you will see something similar to this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2f7e96fe-8a28-431d-936a-4f8c32cf6620.png" style="width:20.83em;height:13.92em;"/></p>
<ol start="5">
<li>Please review the <kbd>load</kbd> functions to better understand the use of AJAX and JSON in the application.</li>
<li>How is the global <kbd>model</kbd> variable used? <em>(Check the source code.)</em></li>
<li>Check what happens when you change the color in the <kbd>common/models/geometries/cone.json</kbd> file and reload the page.</li>
<li>Modify the coordinates of the cone in the <kbd>common/models/geometries/cone.json</kbd> file and reload the page. Here, you can verify that WebGL reads and renders the coordinates from the file. If you modify them in the file, the geometry will be updated on the screen.</li>
</ol>
<p><em><strong>What just happened?</strong></em></p>
<p>You learned how to use AJAX and JSON to load geometries from a remote location (web server) instead of specifying these geometries (using JavaScript arrays) inside the web page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Have a Go: Loading a Nissan GTR</h1>
                </header>
            
            <article>
                
<p>Follow the given steps:</p>
<ol>
<li>Open the <kbd>ch02_08_ajax-car.html</kbd> file using your web server.</li>
<li>You should see something like this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ce4fd31d-c4eb-4701-abcd-416ccd53f68e.png" style="width:40.00em;height:30.00em;"/></p>
<ol start="3">
<li>The reason we selected the <kbd>LINES</kbd> model instead of the <kbd>TRIANGLES</kbd> model is to easily visualize the structure of the car.</li>
<li>Find the line where the rendering mode is being selected and make sure that you understand what the code does.</li>
<li>Go to the <kbd>draw</kbd> function.</li>
<li>In the <kbd>drawElements</kbd> instruction, change the mode from <kbd>gl.LINES</kbd> to <kbd>gl.TRIANGLES</kbd>.</li>
<li>Refresh the page in the web browser.</li>
<li>What do you see? Can you guess why the visuals are different? What is your rationale?</li>
</ol>
<div class="packt_tip"><span class="packt_screen">Lights</span><br/>
<br/>
Illumination helps us visualize complex geometries more clearly. Without lights, all of our volumes will look opaque, and it will be difficult to distinguish their parts when changing from <kbd>LINES</kbd> to <kbd>TRIANGLES</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Architecture Updates</h1>
                </header>
            
            <article>
                
<p>Let's cover some useful functions that we can refactor for use in later chapters:</p>
<ol>
<li>Open <kbd>common/js/utils.js</kbd><span> </span>in your editor to see the following changes.</li>
<li>We have added two additional methods, <kbd>autoResizeCanvas</kbd> <span>and</span> <kbd>getShader</kbd><span>, to <kbd>utils.js</kbd> that look very similar to the code we implemented earlier in this chapter:</span></li>
</ol>
<pre style="padding-left: 60px"><span>'use strict'</span><span>;<br/></span><span><br/></span><span>// A set of utility functions for /common operations across our <br/>// application<br/></span><span>const </span>utils = {<br/><br/>  <span>// Find and return a DOM element given an ID<br/></span><span>  </span><span>getCanvas</span>(id) {<br/>    // ...<span><br/></span><span>  </span>}<span>,<br/></span><span><br/></span><span>  </span><span>// Given a canvas element, return the WebGL2 context<br/></span><span>  </span><span>getGLContext</span>(canvas) {<br/>    // ...<span><br/></span><span>  </span>}<span>,<br/></span><span><br/></span><span>  </span><span>// Given a canvas element, expand it to the size of the window<br/></span><span>  // and ensure that it automatically resizes as the window changes<br/></span><span>  </span><span>autoResizeCanvas</span>(canvas) {<br/>    <span>const </span><span>expandFullScreen </span>= () =&gt; {<br/>      canvas.<span>width </span>= window.<span>innerWidth</span><span>;<br/></span><span>      </span>canvas.<span>height </span>= window.<span>innerHeight</span><span>;<br/></span><span>    </span>}<span>;<br/></span><span>    </span><span>expandFullScreen</span>()<span>;<br/></span><span>    </span>window.<span>addEventListener</span>(<span>'resize'</span><span>, </span><span>expandFullScreen</span>)<span>;<br/></span><span>  </span>}<span>,<br/></span><span><br/></span><span>  </span><span>// Given a WebGL context and an id for a shader script,<br/></span><span>  // return a compiled shader<br/></span><span>  </span><span>getShader</span>(gl<span>, </span>id) {<br/>    <span>const </span>script = document.<span>getElementById</span>(id)<span>;<br/></span><span>    </span><span>if </span>(!script) {<br/>      <span>return null</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>const </span>shaderString = script.<span>text</span>.<span>trim</span>()<span>;<br/></span><span><br/></span><span>    </span><span>let </span>shader<span>;<br/></span><span>    </span><span>if </span>(script.<span>type </span>=== <span>'x-shader/x-vertex'</span>) {<br/>      shader = gl.<span>createShader</span>(gl.<span>VERTEX_SHADER</span>)<span>;<br/></span><span>    </span>}<br/>    <span>else if </span>(script.<span>type </span>=== <span>'x-shader/x-fragment'</span>) {<br/>      shader = gl.<span>createShader</span>(gl.<span>FRAGMENT_SHADER</span>)<span>;<br/></span><span>    </span>}<br/>    <span>else </span>{<br/>      <span>return null</span><span>;<br/></span><span>    </span>}<br/><br/>    gl.<span>shaderSource</span>(shader<span>, </span>shaderString)<span>;<br/></span><span>    </span>gl.<span>compileShader</span>(shader)<span>;<br/></span><span><br/></span><span>    </span><span>if </span>(!gl.<span>getShaderParameter</span>(shader<span>, </span>gl.<span>COMPILE_STATUS</span>)) {<br/>      console.<span>error</span>(gl.<span>getShaderInfoLog</span>(shader))<span>;<br/></span><span>      </span><span>return null</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>return </span>shader<span>;<br/></span><span>  </span>}<br/><br/>};</pre>
<ol start="3">
<li>The <kbd>autoResizeCanvas</kbd> method takes a <kbd>canvas</kbd> element and dynamically resizes it to be fullscreen by watching browser-resizing events.</li>
<li>The <kbd>getShader</kbd> function takes a <kbd>gl</kbd> instance and an <kbd>id</kbd> script to compile and return the shader source. Internally, <kbd>getShader</kbd> reads the source code of the script and stores it in a local variable. Then, it creates a new shader by using the WebGL <kbd>createShader</kbd> function. After that, it will add the source code to it using the <kbd>shaderSource</kbd> function. Finally, it will try to compile the shader using the <kbd>compileShader</kbd> function.</li>
<li>Open <kbd>ch02_09_ajax-car-final.html</kbd><span> </span><span>in your editor to see the following changes.</span></li>
</ol>
<ol start="6">
<li>Scroll to the<span> </span><kbd>init</kbd><span> </span><span>function</span> <span>where the necessary changes were made to use the <kbd>utils.autoResizeCanvas</kbd> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span>function </span><span>init</span>() {<br/>  <span>const </span>canvas = utils.<span>getCanvas</span>(<span>'webgl-canvas'</span>)<span>;<br/></span><strong><span> </span><span>// Handle automatic resizing<br/></span><span> </span>utils.<span>autoResizeCanvas</span>(canvas)</strong><span><strong>;</strong></span><span><br/></span><span><br/></span><span>  </span><span>// Retrieve a valid WebGL2 context<br/></span><span>  </span>gl = utils.<span>getGLContext</span>(canvas)<span>;<br/></span><span>  </span>gl.<span>clearColor</span>(<span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>, </span><span>1</span>)<span>;<br/></span><span>  </span>gl.<span>enable</span>(gl.<span>DEPTH_TEST</span>)<span>;<br/></span><span><br/></span><span>  </span><span>initProgram</span>()<span>;<br/></span><span>  </span><span>// We are no longer blocking the render until `load` has <br/></span><span>  // resolved, as we're not returning a Promise.<br/></span><span>  </span><span>load</span>()<span>;<br/></span><span>  </span><span>render</span>()<span>;<br/></span>}</pre>
<ol start="7">
<li>Scroll to the <kbd><span>initProgram</span></kbd><span> </span>function inside of <kbd><span>ch02_09_ajax-car-final.html</span></kbd><span>, where the necessary changes were made to use the <kbd>utils.getShader</kbd> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span>function </span><span>initProgram</span>() {<br/><strong>  <span>// Retrieve shaders based on the shader script IDs<br/></span><span>  </span><span>const </span>vertexShader = utils.<span>getShader</span>(gl<span>, </span><span>'vertex-shader'</span>)<span>;<br/></span><span>  </span><span>const </span>fragmentShader = utils.<span>getShader</span>(gl<span>, </span><span>'fragment-shader'</span>)</strong><span><strong>;</strong><br/></span><span><br/></span><span>  </span>program = gl.<span>createProgram</span>()<span>;<br/></span><span>  </span>gl.<span>attachShader</span>(program<span>, </span>vertexShader)<span>;<br/></span><span>  </span>gl.<span>attachShader</span>(program<span>, </span>fragmentShader)<span>;<br/></span><span>  </span>gl.<span>linkProgram</span>(program)<span>;<br/></span><span><br/></span><span>  </span><span>if </span>(!gl.<span>getProgramParameter</span>(program<span>, </span>gl.<span>LINK_STATUS</span>)) {<br/>    console.<span>error</span>(<span>'Could not initialize shaders'</span>)<span>;<br/></span><span>  </span>}<br/><br/>  gl.<span>useProgram</span>(program)<span>;<br/></span><span><br/></span><span>  </span>program.<span>aVertexPosition </span>= gl.<span>getAttribLocation</span>(program<span>, <br/></span><span>   'aVertexPosition'</span>)<span>;<br/></span><span>  </span>program.<span>uProjectionMatrix </span>= gl.<span>getUniformLocation</span>(program<span>, <br/></span><span>   'uProjectionMatrix'</span>)<span>;<br/></span><span>  </span>program.<span>uModelViewMatrix </span>= gl.<span>getUniformLocation</span>(program<span>, <br/></span><span>   'uModelViewMatrix'</span>)<span>;<br/></span>}</pre>
<ol start="8">
<li>Open <kbd><span>ch02_09_ajax-car-final.html</span></kbd><span> </span>in a browser to see these changes in action.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Let’s summarize what we’ve learned in this chapter:</p>
<ul>
<li><span>The WebGL API itself is just a rasterizer and, conceptually, is fairly simple.</span></li>
<li>WebGL's rendering pipeline describes how the WebGL buffers are used and passed in the form of attributes to be processed by the vertex shader. The vertex shader parallelizes vertex processing in the GPU. Vertices define the surface of the geometry that is going to be rendered. Every element on this surface is known as a fragment. These fragments are processed by the fragment shader.</li>
<li>Fragment processing also occurs in parallel in the GPU. When all fragments have been processed, the framebuffer, a two-dimensional array, contains the image that is then displayed on your screen.</li>
<li>WebGL is actually a pretty simple API. Its job is to execute two user-supplied functions, a vertex shader and fragment shader, and draw triangles, lines, or points. While it can get more complicated to do 3D, that complication is added by you, the programmer, in the form of more complex shaders.</li>
<li>The fine details of how WebGL renders geometry. Remember that there are two kinds of WebGL buffers that deal with geometry rendering: VBOs and IBOs<em>.</em></li>
<li>WebGL works as a state machine. As such, properties referring to buffers are available and their values depend on the currently-bound buffer.</li>
<li>JSON and AJAX are two JavaScript technologies that integrate well with WebGL by enabling us to load large and complex assets.</li>
</ul>
<p>In the next chapter, <span>we will learn more about shaders and use them to implement light sources in our WebGL scene by passing information back and forth between the WebGL JavaScript API and the attributes, uniforms, and varyings.</span></p>


            </article>

            
        </section>
    </body></html>