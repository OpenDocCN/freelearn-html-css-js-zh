- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Bundles and Content Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern web development requires three key components: the backend server, the
    client-side application, and the browser. Earlier chapters have demonstrated how
    the Node.js API – and its add-on packages – can be used to receive and process
    HTTP requests. Now it is time to explore how the server-side part of the application
    has to work together with the other components.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers two topics that shape the way the parts of an application
    fit together. The first topic is using a **bundler**. The client-side part of
    an application usually consists of a large number of files, and these are gathered
    together and compressed into a small number of files for efficiency. This is done
    by a bundler and most of the widely used client-side frameworks, such as Angular
    and React, provide developer tools that use a bundler named webpack. In the first
    part of the chapter, I explain how webpack works and describe the different ways
    that it can be integrated with the backend server. *Table 7.1* puts bundlers in
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7.1: Putting Bundlers in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What are they? | Bundlers combine and compress the files required by the
    client-side part of the application. |'
  prefs: []
  type: TYPE_TB
- en: '| Why are they useful? | Bundlers reduce the number of HTTP requests the browser
    has to make to get the client-side files and reduce the total amount of data that
    has to be transferred. |'
  prefs: []
  type: TYPE_TB
- en: '| How are they used? | Bundlers can be used stand-alone or integrated into
    the server-side build tools. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | Bundlers are often integrated into
    more complex client-side development tools and cannot always be configured directly,
    which can limit the options for integration with the backend server. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | Bundlers are not required, but adoption is
    usually driven by the choice of build tools for the client-side framework. |'
  prefs: []
  type: TYPE_TB
- en: The second topic in this chapter is the use of a **content security policy**
    (**CSP**). Browsers are active participants in web applications, and CSPs allow
    the browser to stop client-side JavaScript code from performing unexpected actions.
    Content security policies are an important defense against **cross-site scripting**
    (**XSS**) attacks, in which an attacker subverts the application to execute JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I deliberately create an XSS vulnerability in the example application,
    demonstrate how it can be exploited, and then use a content security browser to
    provide the browser with the information it needs to stop the application from
    being abused. *Table 7.2* puts content security policies in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7.2: Putting Content security policies in context'
  prefs: []
  type: TYPE_NORMAL
- en: '| Question | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| What are they? | Content security policies describe the expected behavior
    of the client-side code to the browser. |'
  prefs: []
  type: TYPE_TB
- en: '| Why are they useful? | Browsers stop JavaScript code from performing actions
    that deviate from those defined by the content security policy. |'
  prefs: []
  type: TYPE_TB
- en: '| How are they used? | The backend server includes a `Content-Security-Policy`
    header in HTTP responses. The header specifies directives that describe the expected
    behavior of the client-side code. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | It can require careful testing to
    define a content security policy that allows the client-side code to function
    without creating opportunities for XSS attacks. For this reason, content security
    policies must be used alongside other measures, such as input sanitization, as
    described in *Part 2* of this book. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | Content security policies are optional but
    provide an important defense against subversion of the client-side part of the
    application and should be used whenever possible. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 7.3* summarizes the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7.3: Chapter Summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Combine client-side files to minimize HTTP requests | Use a JavaScript bundler
    such as webpack. | *6-10* |'
  prefs: []
  type: TYPE_TB
- en: '| Reload the browser automatically when a new bundle is created | Use the webpack
    development HTTP server. | *11-14* |'
  prefs: []
  type: TYPE_TB
- en: '| Receive backend server requests from bundled client-side code | Use a separate
    URL and enable CORS on the backend server, or proxy requests between the two servers.
    | *15-22* |'
  prefs: []
  type: TYPE_TB
- en: '| Defend against cross-site scripting attacks | Define and apply a content
    security policy. | *23-33* |'
  prefs: []
  type: TYPE_TB
- en: '| Simplify the process of defining a content security policy | Use a JavaScript
    package such as Helmet. | *34-36* |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I continue using the `webapp` project from *Chapter 6*. To
    prepare for this chapter, replace the contents of the `readHandler.ts` file with
    the code shown in *Listing 7.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.1: The contents of the readHandler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This handler replies to all messages with a response that contains a JSON-formatted
    object. Replace the contents of the `server.ts` file in the `src` folder with
    the code shown in *Listing 7.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.2: The contents of the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code removes some of the handlers used in the previous examples and uses
    Express to serve static content and match POST requests to the `/read` path to
    the handler defined in *Listing 7.1*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, replace the contents of the `index.html` file in the `static` folder with
    the elements shown in *Listing 7.3*, which removes the image used in the previous
    chapter and applies styles provided by the Bootstrap CSS package to a table that
    displays the responses from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.3: The contents of the index.html file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the command shown in *Listing 7.4* in the `webapp` folder to start the watcher
    that compiles TypeScript files and executes the JavaScript that is produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.4: Starting the project'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Open a web browser and request `http://localhost:5000`. Click the **Send Request**
    button and you will see the result shown in *Figure 7.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Running the example project'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging client files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client side of web applications is usually executed by a browser, and the
    application is delivered as an HTML file that, in turn, tells the browser to request
    JavaScript files, CSS stylesheets, and any other resources that are required.
  prefs: []
  type: TYPE_NORMAL
- en: There can be many JavaScript and CSS files, which means the browser has to make
    HTTP requests for many files. Those files tend to be verbose because they are
    formatted to be read and maintained by the development team, with whitespace and
    comments that are not required to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Many projects use a bundler, which processes client-side assets to make them
    smaller and combine them into fewer files. The most popular bundler is webpack
    ([https://webpack.js.org](https://webpack.js.org)), which can be used on its own
    or as part of the standard developer tools for frameworks such as React and Angular.
    There are other bundlers available, just as with most areas of JavaScript functionality,
    but webpack is a good place to start because of its popularity and longevity.
  prefs: []
  type: TYPE_NORMAL
- en: Bundlers can help the server side of the project by concentrating the requests
    clients make for resources into fewer requests and smaller files. However, bundlers
    often need work to integrate them with the project so that client-side and server-side
    development can be easily combined.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, I describe the different ways bundles can be used
    and explain the impact each of them has on server-side development. Run the command
    shown in *Listing 7.5* in the `webapp` folder to install the `webpack` packages.
    This command also installs the `npm-run-all` package, which allows multiple NPM
    scripts to be run concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.5: Installing the bundler packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating stand-alone bundles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to use a bundler is as a stand-alone tool. To configure `webpack`,
    add a file named `webpack.config.mjs` to the `webapp` folder with the content
    shown in *Listing 7.6*. webpack uses a JavaScript – rather than JSON – configuration
    file and the `mjs` file extension specifies a JavaScript module, which allows
    the use of the same `import` syntax used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.6: The contents of the webpack.config.mjs file in the webapp folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This basic configuration file tells `webpack` to process the `client.js` file
    in the `static` folder and write the bundle it creates to a file named `bundle.js`
    in the `dist/client` folder. There isn’t enough client-side JavaScript in the
    example project to give webpack much to do, but in a real project, webpack will
    follow all the imports made in the starting JavaScript file and incorporate all
    of the code the application requires into the bundle. *Listing 7.7* updates the
    `index.html` file so that it uses the `bundle.js` file that webpack will create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.7: Using the bundle file in the index.html file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To allow the client to request the `bundle.js` file, *Listing 7.8* uses the
    Express static files middleware to add a new location for file requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.8: Adding a file location in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The final step is to update the `scripts` section of the `package.json` file
    so that webpack is run in watch mode alongside the existing build process for
    the server-side JavaScript file, as shown in *Listing 7.9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.9: Updating scripts in the package.json file in the webapp folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The new `start` command uses the `npm-run-all` package to start `client` and
    `server` commands that run the webpack client-side bundler and the server-side
    TypeScript compiler side by side. Putting webpack into watch mode means the bundle
    will be updated automatically when the client-side JavaScript file is altered.
  prefs: []
  type: TYPE_NORMAL
- en: Stop the existing Node.js server and run the `npm` `start` command in the `webapp`
    folder. *Listing 7.10* makes a small change to the client-side code that will
    demonstrate webpack change detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.10: Making a small change in the client.js file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `client.js` file is saved, the change will be detected by webpack,
    which will create a new bundle file, producing console messages like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Reload the browser – or open a new browser and request `http://localhost:5000`
    – and click the Send Request button and you will see the effect of the change
    when the response is displayed, as shown in *Figure 7.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Using a client-side bundler'
  prefs: []
  type: TYPE_NORMAL
- en: Using the webpack development server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: webpack provides an HTTP server that streamlines the client-side development
    process, and this is widely used as the basis for popular development packages
    for Angular, React, and other popular frameworks. If the client-side part of your
    project relies on one of these frameworks, then you are likely to find yourself
    working with the webpack development server.
  prefs: []
  type: TYPE_NORMAL
- en: The webpack development server can be used for client-side development alongside
    the conventional server-side functionality, albeit with some integration. Run
    the command shown in *Listing 7.11* in the `webapp` folder to install the webpack
    development HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.11: Adding the development server package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The webpack development web server has a lot of configuration options, which
    are described in detail at [https://webpack.js.org/configuration/dev-server](https://webpack.js.org/configuration/dev-server),
    but the default settings are well-chosen and suit most projects. *Listing 7.12*
    adds a section to the webpack configuration file for the development server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.12: Adding a section in the webpack.config.mjs file in the webapp
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `devServer` configuration section contains the settings for the HTTP server.
    The webpack server listens for HTTP requests on the port specified by the `port`
    setting and responds using the files in the directories specified by the `static`
    setting. The key difference is that the bundle of JavaScript sent to the browser
    contains additional code that opens a persistent HTTP connection back to the development
    server and waits for a signal. When webpack detects that one of the files it is
    watching has changed, it builds a new bundle and sends the browser the signal
    that it has been waiting for, which loads the changed content dynamically. This
    is known as *live reloading*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: There is a more sophisticated option available, known as *hot module replacement*,
    that will attempt to update individual JavaScript modules without affecting the
    rest of the code or forcing the browser to reload. See [https://webpack.js.org/guides/hot-module-replacement](https://webpack.js.org/guides/hot-module-replacement)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7.13* changes the script used to use the webpack development HTTP
    server instead of watch mode. (The addition of the `noClear` argument to the `tsc-watch`
    command stops the output from the webpack development server from being lost when
    the server-side code is compiled).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.13: Updating the webpack script in the package.json file in the webapp
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Stop the node processes from the previous section and run `npm` `start` in the
    `webapp` folder so that the new configuration takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the effect of the webpack development server by using the browser
    to request `http://localhost:5100` (note the new port number) and using your code
    editor to make a change to the `index.html` file, as shown in *Listing 7.14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.14: Changing an element in the index.html file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This file isn’t part of the bundle, but webpack watches files in the `static`
    locations in its configuration file and will trigger an update if they change.
    When you save the file, the browser will automatically reload and the new text
    on the button will be displayed, as shown in *Figure 7.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: An automatic update from the webpack development server'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a server just to serve the client-side code causes problems because
    the webpack server has no means to respond to HTTP requests made by the client-side
    JavaScript code it bundles. You can see the problem by clicking on the **Send
    Message** button. The request will fail, and the detail of the response generated
    by the webpack server is displayed, as shown in *Figure 7.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Sending an HTTP request'
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, I describe three different ways this problem can
    be solved. Not all approaches work in every project because client-side frameworks
    don’t always allow the underlying webpack configuration to be changed or they
    introduce specific requirements for how requests are processed. But all frameworks
    can be used with at least one of these approaches and it is worth experimenting
    to find one that works and that suits your development style.
  prefs: []
  type: TYPE_NORMAL
- en: Using a different request URL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest approach is to change the URL to which the client-side JavaScript
    code sends requests, as shown in *Listing 7.15*. This is a useful approach when
    you cannot make changes to the webpack configuration file, typically because it
    is hidden deep inside a framework-specific build tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.15: Changing URL in the client.js file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This approach is simple and effective, but it does require changes to the server-side
    part of the application. Browsers allow JavaScript code to make HTTP requests
    only within the same *origin*, which means URLs that have the same scheme, host,
    and port as the URL used to load the JavaScript code. The change in *Listing 7.15*
    means that the HTTP request is to a URL that is outside of the allowed origin
    and so the browser blocks the request. The solution to this problem is to use
    **Cross-Origin Resource Sharing** (**CORS**), in which the browser sends an additional
    request to the target HTTP server to determine whether it is willing to accept
    HTTP requests from the origin of the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Save the changes in *Listing 7.15*, open the browser’s F12 developer tools,
    and click the **Send Message** button in the browser window. Ignore the message
    displayed in the main browser window and use the **Network** tab of the F12 tools
    to see the requests the browser has made. You will see a request that uses the
    HTTP `OPTIONS` method, which is known as the *pre-flight request*, as shown in
    *Figure 7.5*, and which allows the backend server to indicate whether it will
    accept the request.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The preflight request'
  prefs: []
  type: TYPE_NORMAL
- en: The response from the backend server did not include the `Access-Control-Allow-Origin`
    header, which would have indicated that cross-origin requests are allowed, and
    so the browser blocks the POST request.
  prefs: []
  type: TYPE_NORMAL
- en: CORS is described in detail at [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS),
    and you can use the Node.js API described in *Chapter 5* to set the headers required
    to allow client requests. A simpler approach is to use one of the many JavaScript
    packages available to manage CORS. Run the command shown in *Listing 7.16* in
    the `webapp` folder to install a CORS package for Express and a package that describes
    the API it provides for the TypeScript compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.16: Installing the CORS package and type descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7.17* configures Express to use the new package to allow cross-origin
    requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.17\. Allowing cross-origin requests in the server.Ts file in the src
    folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The CORS package contains an Express middleware package that is applied with
    the `use` method. The full set of CORS configuration options can be found at [https://github.com/expressjs/cors](https://github.com/expressjs/cors)
    and *Listing 7.17* uses the `origin` configuration setting to specify that requests
    are allowed from `http://localhost:5100`, which will allow requests from JavaScript
    code loaded from the webpack development server.
  prefs: []
  type: TYPE_NORMAL
- en: Dismiss the error message displayed in the browser window (you can click the
    cross icon or reload the browser) and click the `Send Message` button again. This
    time, the backend server will respond to the OPTIONS request with the headers
    the browser is expecting, and the HTTP POST request will be allowed. The *F12*
    tools will display details of the successful request, as shown in *Figure 7.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Using CORS to allow cross-origin requests'
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding requests from webpack to the backend server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more sophisticated solution is to configure the webpack development server
    so that it forwards requests to the backend server. The request forwarding isn’t
    apparent to the browser, which means that all requests are sent to the same origin
    and CORS isn’t required. *Listing 7.18* updates the webpack configuration file
    to add support for forwarding requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.18: Adding a setting in the webpack.config.mjs file in the webapp
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `proxy` setting is used to specify one or more paths and the URLs to which
    they should be forwarded. *Listing 7.19* updates the client-side JavaScript code
    so that requests are sent relative to the JavaScript file’s origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.19: Using relative URLs in the client.js file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: webpack doesn’t pick up changes to its configuration file automatically. Use
    *Control+C* to stop the existing process and then run the `npm start` command
    in the `webapp` folder to start `webpack` and the backend server again. Use a
    browser to request `http://localhost:5100` (the URL for the webpack server) and
    then click the **Send Message** button. The webpack server will receive the request
    and act as a proxy to get a response from the backend server, producing the response
    shown in *Figure 7.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Using webpack as a proxy for the backend server'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, the webpack HTTP server uses Express and the core development
    server functionality is available in the `webpack-dev-middleware` package, which
    can be used as middleware in any project that also uses Express. I have not demonstrated
    this feature because it requires additional packages and extensive configuration
    changes to recreate features like live reloading, which are already set up when
    using the standard webpack development server package.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://webpack.js.org/guides/development/#using-webpack-dev-middleware](https://webpack.js.org/guides/development/#using-webpack-dev-middleware)
    for details of using webpack as Express middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding requests from the backend server to webpack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third approach is to switch the servers around so that the backend server
    forwards requests to the webpack server. This has the advantage of making the
    development environment more consistent with production and ensures that headers
    set by the backend server are applied. Run the commands shown in *Listing 7.20*
    in the `webapp` folder to install a proxy package for Express and a description
    of the API it provides for the TypeScript compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.20: Installing a proxy package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7.21* changes the Express configuration so that requests are forwarded
    to the webpack server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.21: Forwarding requests in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The changes enable the proxy, including support for dealing with web socket
    requests, which are used for the live reload feature, and which must also be forwarded
    to the webpack development server. A corresponding update is required in the webpack
    configuration file to specify the URL that the client-side live reloading code
    will connect to, as shown in *Listing 7.22*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.22: Changing the client-side URL in the webpack.config.mjs file'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Use *Control+C* to stop the existing build process and run `npm start` in the
    `webapp` folder so that the changes take effect. Use a browser to request `http://localhost:5000`,
    as shown in *Figure 7.8*, to have the backend server receive the request and still
    benefit from the features of the webpack development server.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Using the backend server as a proxy for webpack'
  prefs: []
  type: TYPE_NORMAL
- en: Using a content security policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CORS is an example of a set of request headers that were introduced to address
    malicious behavior by providing the browser with information about how the application
    is expected to work.
  prefs: []
  type: TYPE_NORMAL
- en: There are additional headers that the backend server can set to provide the
    browser with insight into how the application works and what behaviors are expected.
    The most important header is `Content-Security-Policy`, which the backend server
    uses to describe the application’s **Content Security Policy** (**CSP**). The
    CSP tells the browser what behaviors to expect from the client-side application
    so that the browser can block suspicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: The use of content security policies is intended to prevent **cross-site scripting**
    (**XSS**) attacks. There are many variations of XSS attacks, but they all involve
    injecting malicious content or code into the content displayed by the browser
    to perform a task not intended by the application developers – typically something
    that deceives the user or steals sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: One common cause of XSS attacks arises when an application accepts input from
    one user that is subsequently incorporated into the content presented to other
    users. If an application accepts user reviews that are displayed alongside products,
    for example, an attacker could craft a review that browsers will interpret as
    HTML or JavaScript content when the product page is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The best place to start is with a demonstration of the problem, which requires
    some changes to the example application. The first change is to add an `input`
    element to the HTML document displayed by the browser, which will allow the user
    to enter data that will later be displayed by the browser, as shown in *Listing
    7.23*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.23: Adding an input element in the index.html file in the static
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7.24* updates the client-side JavaScript code so that it sends the
    contents of the `input` element added in *Listing 7.23* to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.24: Updating the client-side code in the client.js file in the static
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7.25* updates the handler that receives data from the browser so that
    it pipes the data from the request to the response. This means that whatever is
    entered into the `input` element will be sent to the server and then piped back
    to the browser, where it will be displayed to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.25: Piping data in the readHandler.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The handler also sets a cookie in the response. One of the uses of XSS attacks
    is to steal session credentials so that the attacker can impersonate a legitimate
    user. The cookie set by the code in *Listing 7.25* is a placeholder for data that
    will be stolen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: See Part 2 of this book for details on how to create and use real sessions.
  prefs: []
  type: TYPE_NORMAL
- en: The changes from *Listing 7.23* to *Listing 7.25* deliberately create a situation
    where input provided by the user is used without any form of validation. This
    sort of problem is easy to spot in a simple example but can be much more difficult
    to identify in a real project, especially one where features are added over time.
    This is such a common problem that XSS is one of the top 10 application security
    risks identified by the **Open Worldwide Application Security Project** (**OWASP**)
    and has been for some years (see [https://owasp.org/www-project-top-ten](https://owasp.org/www-project-top-ten)
    for the complete list).
  prefs: []
  type: TYPE_NORMAL
- en: Injecting malicious content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete the preparations, add a file named `badServer.mjs` to the `webapp`
    folder with the content shown in *Listing 7.26*. This is a “bad” server, which
    will serve content and receive requests on behalf of malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.26: Creating a server in the badServer.mjs file in the webapp folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of simplicity, this file contains JavaScript code so that it can
    be executed without needing the TypeScript compiler. The code is expressed for
    brevity, rather than readability, and uses the Express features for serving static
    content and the router to receive POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command prompt, navigate to the `webapp` folder, and run the command
    shown in *Listing 7.27* to start the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.27: Starting the bad web server'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Having prepared the example application and the bad server, the process of subverting
    the application requires entering carefully crafted strings, intended to get the
    browser to load content or execute JavaScript that isn’t part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: This section shows simple – and related – exploits that take advantage of a
    defect that I have knowingly created, which helps me describe useful features
    but doesn’t cover the full spectrum of XSS issues. You can find an excellent set
    of XSS tests to apply at [https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html).
  prefs: []
  type: TYPE_NORMAL
- en: Enter the text shown in *Listing 7.28* into the `input` element and click the
    **Send Message** button. Pay close attention to the quote characters when entering
    the text into the `input` element. It is important to use double and single quotes
    as they are shown, otherwise, the browser won’t be able to parse the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.28: Requesting an image'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The client-side JavaScript code adds the response from the server to the HTML
    document displayed to the user, which causes the browser to request an image file
    from the bad server. Clicking on the image causes the browser to navigate away
    from the application, as shown in *Figure 7.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Loading an image with a click redirection'
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t just images that can be added to the document. Enter the text shown
    in *Listing 7.29* into the `input` element and click the **Send Message** button,
    which will add a button to the document displayed by the user. Once again, pay
    close attention to the quote characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.29: Creating a button'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The button that is created takes advantage of the CSS stylesheets that are used
    by the application, giving the new element an appearance that is consistent with
    the other button displayed by the browser, as shown in *Figure 7.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Adding an element'
  prefs: []
  type: TYPE_NORMAL
- en: Injected code can also be used to steal sensitive data. Enter the text shown
    in *Listing 7.30* into the `input` element and click the **Send Message** button,
    once again paying close attention to the quote characters and entering the text
    as a single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.30: Stealing data'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This `img` element specifies a file that doesn’t exist. The browser will emit
    the `error` event when it fails to load the file, which executes the fragment
    of JavaScript code assigned to the `onerror` attribute in *Listing 7.30*. The
    code uses the browser’s Fetch API to send an HTTP POST request to the bad server,
    including the sensitive cookie data as the request body. If you examine the output
    from the command prompt running the bad server, you will see the following message,
    showing the data that the bad server received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: No user action was needed to trigger this behavior and the data is sent as soon
    as the browser tries – and fails – to load the image. For the final example, add
    a file named `bad.js` to the `static` folder with the content shown in *Listing
    7.31*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.31: The contents of the bad.js file in the static folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code locates the `button` element in the HTML document and replaces it
    with one that sends the sensitive data to the bad server. To get the browser to
    load this file, enter the text shown in *Listing 7.32* in the `input` element
    and click the **Send Message** button. This is the most complex example in this
    section and particular care must be taken to enter it correctly and as a single
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.32: Loading a JavaScript file'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript code uses the browser’s Fetch API to request the `bad.js` file
    from the bad HTTP server and then uses the JavaScript `eval` function to execute
    its contents. The `eval` function will treat any string as JavaScript code and,
    as a consequence, can present a risk whenever it is used. When the browser executes
    the JavaScript code, the existing button is replaced with one that sends the sensitive
    cookie data to the bad server, as shown in *Figure 7.12*. (The button text is
    also changed just to emphasize the change.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Replacing a button'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the button, the bad HTTP server will display a console message
    that shows the cookie value and whatever you entered into the `input` element
    before clicking the button, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Why Not Just inject a script element?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS attacks have been such a problem for so long that some protections against
    them are codified into the HTML specification. For example, the client-side code
    in the example application uses the `innerHTML` property to display the response
    it receives from the backend server, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The HTML specification instructs browsers not to execute `script` elements assigned
    to the `innerHTML` property, which means that using JavaScript code directly won’t
    work, but using event handlers will. This limitation arises because of the way
    the example app has evolved from chapter to chapter, and you must not assume that
    all applications will be similarly restricted.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a content security policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A content security policy tells the browser how the client-side application
    is expected to behave and is set using the `Content-Security-Policy` header, as
    shown in *Listing 7.33*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.33: Setting a content security policy in the server.ts file in the
    src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The CSP header should be applied to every response, and so the listing uses
    the Express `use` method to set up a middleware component, which is like a regular
    request handler but receives an additional argument that is used to pass the request
    along for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header value is the policy for the application and consists of one or more
    *policy directives* and values. The header in *Listing 7.33* contains one policy
    directive, which is `img-src` and whose value is `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The CSP specification defines a range of policies that specify the locations
    from which different content can be loaded. *Table 7.4* describes the most useful
    policy directives, and a full list can be found at `https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7.4: Useful CSP directives'
  prefs: []
  type: TYPE_NORMAL
- en: '| Policy Directive | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '| This directive sets the default policy for all directives. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '| This directive specifies the URLs that can be requested using JavaScript
    code. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '| This directive specifies the sources from which images can be loaded. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '| This directive specifies the sources from which JavaScript files can be loaded.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '| This directive specifies the valid sources for inline event handlers. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '| This directive specifies the URLs to which form data can be sent. |'
  prefs: []
  type: TYPE_TB
- en: The values for a policy can be specified using URLs with wildcards (such as
    `http://*.acme.com`) or a scheme (such as `http:` to allow all HTTP requests or
    `https:` for all HTTPS requests). There are also special values such as `'none'`,
    which blocks all URLs, and `'self'`, which limits requests to the origin from
    which the document was loaded. (The single quotes must be specified for these
    special values, which is why the policy defined in *Listing 7.33* looks oddly
    quoted.)
  prefs: []
  type: TYPE_NORMAL
- en: The policy defined in *Listing 7.33* tells the browser that images can only
    be requested from the same origin as the HTML document. To see the effect, reload
    the browser, enter the text from *Listing 7.28*, and click the **Send Message**
    button. (You must reload to ensure that the header defined in *Listing 7.33* is
    sent to the browser.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The policy restricts images so they can only come from the same origin as the
    HTML document. If you examine the browser’s *F12* developer tools, you will see
    an error message in the console similar to this one, which is from Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The attempt to load an image from the bad server was prevented, but if you click
    the broken image placeholder displayed by the browser, you will still be able
    to navigate away from the application. Policies generally require multiple directives
    to be effective.
  prefs: []
  type: TYPE_NORMAL
- en: Using a package to set the policy header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to set the CSP header directly, as the previous section demonstrated,
    but using a package to define a CSP policy is easier and less prone to errors.
    One excellent package is *Helmet* ([https://helmetjs.github.io](https://helmetjs.github.io)),
    which sets several security-related headers, including the CSP header. Run the
    command shown in *Listing 7.34* in the `webapp` folder to install the Helmet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.34: Adding a package to the project'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7.35* replaces the custom middleware from the previous section with
    the equivalent functionality provided by Helmet and defines the complete policy
    for the example application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.35: Defining a CSP policy in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Helmet is applied as middleware and is configured with an object whose properties
    determine the headers that are set and the values that should be used. The `contentSecurityPolicy.directives`
    property is used to set CSP directives, expressed as camel case because the hyphenated
    CSP directive names are not allowed in JavaScript (so `img-src` becomes `imgSrc`,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: The configuration in *Listing 7.35* specifies a content security policy that
    will allow images to be loaded from the HTML document’s domain, block all JavaScript
    in element attributes, restrict JavaScript files to the document’s domain, and
    limit the URLs to which connections can be made by JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: This last directive specifies `self`, allowing HTTP connections to be sent to
    the backend server, but also includes the `ws://localhost:5000` URL, which allows
    the connection required by the webpack live reload feature (the `ws` scheme denotes
    a web sockets connection and is the same connection that required additional configuration
    when setting up the proxy in *Listing 7.21*).
  prefs: []
  type: TYPE_NORMAL
- en: If you reload the browser at this point, you will see a CSP error displayed
    in the browser’s JavaScript console. That’s because the CSP has disabled the use
    of the `eval` function, which is sensible because it is so dangerous, but problematic
    because webpack unpacks the contents of its bundles using `eval`. (This is only
    the case when webpack is producing development bundles and is not the case when
    the final bundles are produced before an application is deployed.)
  prefs: []
  type: TYPE_NORMAL
- en: The best approach is to change the webpack configuration so that it uses a different
    technique to process bundles, as shown in *Listing 7.36*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.36: Changing the webpack configuration in the webpack.config.mjs
    file in the webapp folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Use *Control+C* to stop the build tools and run the `npm start` command in the
    `webapp` folder to start them again with the new configuration. Reload the browser
    and the JavaScript bundle will be processed without using the `eval` function.
    Run through the examples in *Listing 7.28* to *Listing 7.32* again and you will
    see that each attack is defeated by one of the content security settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Content-Security-Policy-Report-Only` header instructs the browser to report
    on actions that would break the content security policy without blocking those
    actions, which can be a good way to assess an existing application. If you are
    using the Helmet package, you can enable this header by setting the `contentSecurityPolicy.reportOnly`
    configuration setting to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: There are limits to CSP and it is important to avoid including unfiltered user
    input in the HTML displayed to the user. I demonstrate how user input can be processed
    in Part 2 of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are unable to alter the webpack configuration, then you can allow the
    `eval` function in the content security policy. Use `"'self' 'unsafe-eval'"` as
    the value for the `scriptSrc` setting. The special `'unsafe-eval'` value allows
    the eval function to be used, but the `'self'` value restricts the locations from
    which JavaScript files can be downloaded to just the backend server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I described two important ways in which the backend Node.js
    server works with the other components in a modern web application. The first
    topic I described was the use of a bundler:'
  prefs: []
  type: TYPE_NORMAL
- en: Bundlers combine and compress multiple files to reduce the number of HTTP requests
    made by the browser and reduce the amount of data to be transferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundlers are integrated into the developer tools for all of the popular client-side
    frameworks, including Angular and React.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundlers can work independently of the backend server, but the best workflows
    are achieved by using them together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second topic I described was the application of a content security policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content security policies are used to defend against **cross-site scripting**
    (**XSS**) attacks, in which the goal is to trick the browser into executing malicious
    JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To apply a content security policy, the backend server provides the browser
    with a description of how the client-side application code behaves in terms of
    how it obtains and uses resources such as images and JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser blocks JavaScript operations that are outside of the limits imposed
    by the content security policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I will demonstrate the features that Node.js provides for
    unit testing and debugging JavaScript code.
  prefs: []
  type: TYPE_NORMAL
