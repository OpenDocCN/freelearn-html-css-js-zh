- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Using Bundles and Content Security
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用打包和内容安全
- en: 'Modern web development requires three key components: the backend server, the
    client-side application, and the browser. Earlier chapters have demonstrated how
    the Node.js API – and its add-on packages – can be used to receive and process
    HTTP requests. Now it is time to explore how the server-side part of the application
    has to work together with the other components.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络开发需要三个关键组件：后端服务器、客户端应用程序和浏览器。前面的章节已经展示了如何使用Node.js API及其附加包来接收和处理HTTP请求。现在，我们需要探讨应用程序的服务器端部分如何与其他组件协同工作。
- en: This chapter covers two topics that shape the way the parts of an application
    fit together. The first topic is using a **bundler**. The client-side part of
    an application usually consists of a large number of files, and these are gathered
    together and compressed into a small number of files for efficiency. This is done
    by a bundler and most of the widely used client-side frameworks, such as Angular
    and React, provide developer tools that use a bundler named webpack. In the first
    part of the chapter, I explain how webpack works and describe the different ways
    that it can be integrated with the backend server. *Table 7.1* puts bundlers in
    context.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了两个塑造应用程序各部分如何组合在一起的话题。第一个话题是使用**打包器**。应用程序的客户端部分通常由大量文件组成，这些文件被收集在一起并压缩成少量文件以提高效率。这是通过打包器完成的，并且大多数广泛使用的客户端框架，如Angular和React，都提供了使用名为webpack的打包器的开发者工具。在本章的第一部分，我解释了webpack的工作原理，并描述了它如何与后端服务器集成。*表7.1*将打包器置于上下文中。
- en: 'Table 7.1: Putting Bundlers in context'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1：将打包器置于上下文中
- en: '| Question | Answer |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What are they? | Bundlers combine and compress the files required by the
    client-side part of the application. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 它们是什么？ | 打包器将应用程序客户端部分所需的文件组合并压缩成少量文件。|'
- en: '| Why are they useful? | Bundlers reduce the number of HTTP requests the browser
    has to make to get the client-side files and reduce the total amount of data that
    has to be transferred. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它们有用？ | 打包器减少了浏览器需要发出的HTTP请求次数以获取客户端文件，并减少了需要传输的总数据量。|'
- en: '| How are they used? | Bundlers can be used stand-alone or integrated into
    the server-side build tools. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 如何使用它们？ | 打包器可以独立使用或集成到服务器端构建工具中。|'
- en: '| Are there any pitfalls or limitations? | Bundlers are often integrated into
    more complex client-side development tools and cannot always be configured directly,
    which can limit the options for integration with the backend server. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 有没有陷阱或限制？ | 打包器通常集成到更复杂的客户端开发工具中，并且不能总是直接配置，这可能会限制与后端服务器集成的选项。|'
- en: '| Are there any alternatives? | Bundlers are not required, but adoption is
    usually driven by the choice of build tools for the client-side framework. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 打包器不是必需的，但通常是由客户端框架的构建工具选择驱动的采用。'
- en: The second topic in this chapter is the use of a **content security policy**
    (**CSP**). Browsers are active participants in web applications, and CSPs allow
    the browser to stop client-side JavaScript code from performing unexpected actions.
    Content security policies are an important defense against **cross-site scripting**
    (**XSS**) attacks, in which an attacker subverts the application to execute JavaScript
    code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二个话题是使用**内容安全策略**（**CSP**）。浏览器是网络应用程序的积极参与者，CSP允许浏览器阻止客户端JavaScript代码执行意外的操作。内容安全策略是防止**跨站脚本攻击**（**XSS**）的重要防御手段，在这种攻击中，攻击者会篡改应用程序以执行JavaScript代码。
- en: In this chapter, I deliberately create an XSS vulnerability in the example application,
    demonstrate how it can be exploited, and then use a content security browser to
    provide the browser with the information it needs to stop the application from
    being abused. *Table 7.2* puts content security policies in context.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我故意在示例应用程序中创建了一个XSS漏洞，演示了如何利用它，然后使用内容安全浏览器为浏览器提供所需信息，以阻止应用程序被滥用。*表7.2*将内容安全策略置于上下文中。
- en: 'Table 7.2: Putting Content security policies in context'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2：将内容安全策略置于上下文中
- en: '| Question | Answer |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What are they? | Content security policies describe the expected behavior
    of the client-side code to the browser. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 它们是什么？ | 内容安全策略描述了客户端代码对浏览器的预期行为。|'
- en: '| Why are they useful? | Browsers stop JavaScript code from performing actions
    that deviate from those defined by the content security policy. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它们有用？ | 浏览器阻止JavaScript代码执行与内容安全策略定义不符的操作。|'
- en: '| How are they used? | The backend server includes a `Content-Security-Policy`
    header in HTTP responses. The header specifies directives that describe the expected
    behavior of the client-side code. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 它们是如何使用的？ | 后端服务器在 HTTP 响应中包含一个 `Content-Security-Policy` 头部。该头部指定了描述客户端代码预期行为的指令。
    |'
- en: '| Are there any pitfalls or limitations? | It can require careful testing to
    define a content security policy that allows the client-side code to function
    without creating opportunities for XSS attacks. For this reason, content security
    policies must be used alongside other measures, such as input sanitization, as
    described in *Part 2* of this book. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 有没有陷阱或限制？ | 它可能需要仔细测试才能定义一个允许客户端代码正常工作而不创建 XSS 攻击机会的内容安全策略。因此，内容安全策略必须与其他措施一起使用，例如输入清理，如本书
    *第 2 部分* 中所述。 |'
- en: '| Are there any alternatives? | Content security policies are optional but
    provide an important defense against subversion of the client-side part of the
    application and should be used whenever possible. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 内容安全策略是可选的，但提供了防止应用程序客户端部分被篡改的重要防御措施，应在可能的情况下使用。 |'
- en: '*Table 7.3* summarizes the chapter.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 7.3* 总结了本章内容。'
- en: 'Table 7.3: Chapter Summary'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.3：本章摘要
- en: '| Problem | Solution | Listing |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Combine client-side files to minimize HTTP requests | Use a JavaScript bundler
    such as webpack. | *6-10* |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 将客户端文件合并以最小化 HTTP 请求 | 使用如 webpack 这样的 JavaScript 捆绑器。 | *6-10* |'
- en: '| Reload the browser automatically when a new bundle is created | Use the webpack
    development HTTP server. | *11-14* |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 当创建新捆绑时自动重新加载浏览器 | 使用 webpack 开发 HTTP 服务器。 | *11-14* |'
- en: '| Receive backend server requests from bundled client-side code | Use a separate
    URL and enable CORS on the backend server, or proxy requests between the two servers.
    | *15-22* |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 从捆绑的客户端代码接收后端服务器请求 | 在后端服务器上使用单独的 URL 并启用 CORS，或者在两个服务器之间代理请求。 | *15-22*
    |'
- en: '| Defend against cross-site scripting attacks | Define and apply a content
    security policy. | *23-33* |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 防御跨站脚本攻击 | 定义并应用内容安全策略。 | *23-33* |'
- en: '| Simplify the process of defining a content security policy | Use a JavaScript
    package such as Helmet. | *34-36* |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 简化定义内容安全策略的过程 | 使用如 Helmet 这样的 JavaScript 包。 | *34-36* |'
- en: Preparing for this chapter
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章
- en: In this chapter, I continue using the `webapp` project from *Chapter 6*. To
    prepare for this chapter, replace the contents of the `readHandler.ts` file with
    the code shown in *Listing 7.1*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将继续使用 *第 6 章* 中的 `webapp` 项目。为了准备本章，将 `readHandler.ts` 文件的内容替换为 *列表 7.1*
    中显示的代码。
- en: '**Tip**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)
    下载本章的示例项目——以及本书中所有其他章节的示例项目。有关运行示例时遇到问题的帮助，请参阅 *第 1 章*。
- en: 'Listing 7.1: The contents of the readHandler.ts file in the src folder'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1：src 文件夹中 readHandler.ts 文件的内容
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This handler replies to all messages with a response that contains a JSON-formatted
    object. Replace the contents of the `server.ts` file in the `src` folder with
    the code shown in *Listing 7.2*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理器对所有消息的响应都包含一个包含 JSON 格式对象的响应。将 `src` 文件夹中 `server.ts` 文件的内容替换为 *列表 7.2*
    中显示的代码。
- en: 'Listing 7.2: The contents of the server.ts file in the src folder'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2：src 文件夹中 server.ts 文件的内容
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code removes some of the handlers used in the previous examples and uses
    Express to serve static content and match POST requests to the `/read` path to
    the handler defined in *Listing 7.1*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码移除了之前示例中使用的某些处理器，并使用 Express 来提供静态内容，并将 `/read` 路径的 POST 请求匹配到 *列表 7.1* 中定义的处理程序。
- en: Next, replace the contents of the `index.html` file in the `static` folder with
    the elements shown in *Listing 7.3*, which removes the image used in the previous
    chapter and applies styles provided by the Bootstrap CSS package to a table that
    displays the responses from the server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `static` 文件夹中 `index.html` 文件的内容替换为 *列表 7.3* 中显示的元素，这将移除上一章中使用的图像，并将 Bootstrap
    CSS 包提供的样式应用到显示服务器响应的表格上。
- en: 'Listing 7.3: The contents of the index.html file in the static folder'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3：静态文件夹中 index.html 文件的内容
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the command shown in *Listing 7.4* in the `webapp` folder to start the watcher
    that compiles TypeScript files and executes the JavaScript that is produced.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webapp` 文件夹中运行 *列表 7.4* 中显示的命令以启动编译 TypeScript 文件并执行生成的 JavaScript 的监视器。
- en: 'Listing 7.4: Starting the project'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4：启动项目
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open a web browser and request `http://localhost:5000`. Click the **Send Request**
    button and you will see the result shown in *Figure 7.1*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网络浏览器并请求 `http://localhost:5000`。点击 **发送请求** 按钮，你将看到 *图 7.1* 中显示的结果。
- en: '![](img/B21959_07_01.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_01.png)'
- en: 'Figure 7.1: Running the example project'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：运行示例项目
- en: Packaging client files
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包客户端文件
- en: The client side of web applications is usually executed by a browser, and the
    application is delivered as an HTML file that, in turn, tells the browser to request
    JavaScript files, CSS stylesheets, and any other resources that are required.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用的客户端通常由浏览器执行，应用程序以 HTML 文件的形式交付，该文件反过来告诉浏览器请求 JavaScript 文件、CSS 样式表以及任何其他所需资源。
- en: There can be many JavaScript and CSS files, which means the browser has to make
    HTTP requests for many files. Those files tend to be verbose because they are
    formatted to be read and maintained by the development team, with whitespace and
    comments that are not required to run the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有许多 JavaScript 和 CSS 文件，这意味着浏览器需要为许多文件发出 HTTP 请求。这些文件往往很冗长，因为它们被格式化为供开发团队阅读和维护，其中包含空格和注释，这些注释对于运行应用程序不是必需的。
- en: Many projects use a bundler, which processes client-side assets to make them
    smaller and combine them into fewer files. The most popular bundler is webpack
    ([https://webpack.js.org](https://webpack.js.org)), which can be used on its own
    or as part of the standard developer tools for frameworks such as React and Angular.
    There are other bundlers available, just as with most areas of JavaScript functionality,
    but webpack is a good place to start because of its popularity and longevity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目使用打包器，它处理客户端资源以减小它们的大小并将它们合并成更少的文件。最受欢迎的打包器是 webpack ([https://webpack.js.org](https://webpack.js.org))，它可以单独使用，也可以作为
    React 和 Angular 等框架的标准开发者工具的一部分。与其他 JavaScript 功能领域一样，还有其他打包器可用，但鉴于其流行度和持久性，webpack
    是一个很好的起点。
- en: Bundlers can help the server side of the project by concentrating the requests
    clients make for resources into fewer requests and smaller files. However, bundlers
    often need work to integrate them with the project so that client-side and server-side
    development can be easily combined.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器可以通过将客户端对资源的请求集中到更少的请求和更小的文件中，帮助项目的服务器端。然而，打包器通常需要与项目集成，以便客户端和服务器端开发可以轻松结合。
- en: In the sections that follow, I describe the different ways bundles can be used
    and explain the impact each of them has on server-side development. Run the command
    shown in *Listing 7.5* in the `webapp` folder to install the `webpack` packages.
    This command also installs the `npm-run-all` package, which allows multiple NPM
    scripts to be run concurrently.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将描述不同的使用打包器的方式，并解释它们对服务器端开发的影响。在 `webapp` 文件夹中运行 *列表 7.5* 中显示的命令来安装
    `webpack` 包。此命令还安装了 `npm-run-all` 包，它允许同时运行多个 NPM 脚本。
- en: 'Listing 7.5: Installing the bundler packages'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5：安装打包器包
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating stand-alone bundles
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建独立包
- en: The simplest way to use a bundler is as a stand-alone tool. To configure `webpack`,
    add a file named `webpack.config.mjs` to the `webapp` folder with the content
    shown in *Listing 7.6*. webpack uses a JavaScript – rather than JSON – configuration
    file and the `mjs` file extension specifies a JavaScript module, which allows
    the use of the same `import` syntax used throughout this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包器的最简单方法是将它作为一个独立的工具。要配置 `webpack`，将一个名为 `webpack.config.mjs` 的文件添加到 `webapp`
    文件夹中，其内容如 *列表 7.6* 所示。webpack 使用 JavaScript 而不是 JSON 配置文件，`mjs` 文件扩展名指定了一个 JavaScript
    模块，这允许使用本书中使用的相同 `import` 语法。
- en: 'Listing 7.6: The contents of the webpack.config.mjs file in the webapp folder'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6：webapp 文件夹中 webpack.config.mjs 文件的内容
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This basic configuration file tells `webpack` to process the `client.js` file
    in the `static` folder and write the bundle it creates to a file named `bundle.js`
    in the `dist/client` folder. There isn’t enough client-side JavaScript in the
    example project to give webpack much to do, but in a real project, webpack will
    follow all the imports made in the starting JavaScript file and incorporate all
    of the code the application requires into the bundle. *Listing 7.7* updates the
    `index.html` file so that it uses the `bundle.js` file that webpack will create.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此基本配置文件告诉`webpack`处理`static`文件夹中的`client.js`文件，并将创建的打包写入`dist/client`文件夹中名为`bundle.js`的文件。示例项目中客户端JavaScript代码不足以让webpack有太多工作可做，但在实际项目中，webpack将遵循起始JavaScript文件中做出的所有导入，并将应用程序所需的所有代码合并到打包中。*列表7.7*更新了`index.html`文件，使其使用webpack将创建的`bundle.js`文件。
- en: 'Listing 7.7: Using the bundle file in the index.html file in the static folder'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7：在静态文件夹中的index.html文件中使用bundle文件
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To allow the client to request the `bundle.js` file, *Listing 7.8* uses the
    Express static files middleware to add a new location for file requests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许客户端请求`bundle.js`文件，*列表7.8*使用Express静态文件中间件为文件请求添加了一个新位置。
- en: 'Listing 7.8: Adding a file location in the server.ts file in the src folder'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8：在src文件夹中的server.ts文件中添加文件位置
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The final step is to update the `scripts` section of the `package.json` file
    so that webpack is run in watch mode alongside the existing build process for
    the server-side JavaScript file, as shown in *Listing 7.9*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新`package.json`文件中的`scripts`部分，以便webpack在服务器端JavaScript文件现有的构建过程旁边以监视模式运行，如*列表7.9*所示。
- en: 'Listing 7.9: Updating scripts in the package.json file in the webapp folder'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9：更新webapp文件夹中的package.json文件中的脚本
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The new `start` command uses the `npm-run-all` package to start `client` and
    `server` commands that run the webpack client-side bundler and the server-side
    TypeScript compiler side by side. Putting webpack into watch mode means the bundle
    will be updated automatically when the client-side JavaScript file is altered.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`start`命令使用`npm-run-all`包来启动`client`和`server`命令，这些命令并行运行webpack客户端打包器和服务器端TypeScript编译器。将webpack置于监视模式意味着当客户端JavaScript文件被修改时，打包将自动更新。
- en: Stop the existing Node.js server and run the `npm` `start` command in the `webapp`
    folder. *Listing 7.10* makes a small change to the client-side code that will
    demonstrate webpack change detection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 停止现有的Node.js服务器，并在`webapp`文件夹中运行`npm start`命令。*列表7.10*对客户端代码进行小修改，以演示webpack更改检测。
- en: 'Listing 7.10: Making a small change in the client.js file in the static folder'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.10：在静态文件夹中的client.js文件中进行小修改
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the `client.js` file is saved, the change will be detected by webpack,
    which will create a new bundle file, producing console messages like these:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当`client.js`文件被保存时，webpack将检测到更改，将创建一个新的打包文件，产生如下控制台消息：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Reload the browser – or open a new browser and request `http://localhost:5000`
    – and click the Send Request button and you will see the effect of the change
    when the response is displayed, as shown in *Figure 7.2*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载浏览器 - 或者打开一个新的浏览器并请求`http://localhost:5000` - 然后点击发送请求按钮，你将在响应显示时看到更改的效果，如*图7.2*所示。
- en: '![](img/B21959_07_02.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_02.png)'
- en: 'Figure 7.2: Using a client-side bundler'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：使用客户端打包器
- en: Using the webpack development server
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用webpack开发服务器
- en: webpack provides an HTTP server that streamlines the client-side development
    process, and this is widely used as the basis for popular development packages
    for Angular, React, and other popular frameworks. If the client-side part of your
    project relies on one of these frameworks, then you are likely to find yourself
    working with the webpack development server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: webpack提供了一个HTTP服务器，它简化了客户端开发过程，这被广泛用作Angular、React和其他流行框架的流行开发包的基础。如果你的项目客户端部分依赖于这些框架之一，那么你很可能会发现自己在使用webpack开发服务器。
- en: The webpack development server can be used for client-side development alongside
    the conventional server-side functionality, albeit with some integration. Run
    the command shown in *Listing 7.11* in the `webapp` folder to install the webpack
    development HTTP server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: webpack开发服务器可以与传统的服务器端功能一起用于客户端开发，尽管需要一些集成。在`webapp`文件夹中运行*列表7.11*中显示的命令来安装webpack开发HTTP服务器。
- en: 'Listing 7.11: Adding the development server package'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11：添加开发服务器包
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The webpack development web server has a lot of configuration options, which
    are described in detail at [https://webpack.js.org/configuration/dev-server](https://webpack.js.org/configuration/dev-server),
    but the default settings are well-chosen and suit most projects. *Listing 7.12*
    adds a section to the webpack configuration file for the development server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 开发 web 服务器有许多配置选项，这些选项在 [https://webpack.js.org/configuration/dev-server](https://webpack.js.org/configuration/dev-server)
    上有详细描述，但默认设置选择得很好，适用于大多数项目。*列表 7.12* 为开发服务器添加了 webpack 配置文件中的一个部分。
- en: 'Listing 7.12: Adding a section in the webpack.config.mjs file in the webapp
    folder'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12：在 webapp 文件夹中的 webpack.config.mjs 文件中添加一个部分
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `devServer` configuration section contains the settings for the HTTP server.
    The webpack server listens for HTTP requests on the port specified by the `port`
    setting and responds using the files in the directories specified by the `static`
    setting. The key difference is that the bundle of JavaScript sent to the browser
    contains additional code that opens a persistent HTTP connection back to the development
    server and waits for a signal. When webpack detects that one of the files it is
    watching has changed, it builds a new bundle and sends the browser the signal
    that it has been waiting for, which loads the changed content dynamically. This
    is known as *live reloading*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`devServer` 配置部分包含 HTTP 服务器的设置。webpack 服务器监听由 `port` 设置指定的端口上的 HTTP 请求，并使用由
    `static` 设置指定的目录中的文件进行响应。关键区别在于发送到浏览器的 JavaScript 包包含额外的代码，该代码打开一个持久性的 HTTP 连接到开发服务器并等待信号。当
    webpack 检测到它正在监视的文件之一已更改时，它会构建一个新的包并将它等待的信号发送给浏览器，该信号动态加载更改的内容。这被称为 *实时重新加载*。'
- en: '**Tip**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: There is a more sophisticated option available, known as *hot module replacement*,
    that will attempt to update individual JavaScript modules without affecting the
    rest of the code or forcing the browser to reload. See [https://webpack.js.org/guides/hot-module-replacement](https://webpack.js.org/guides/hot-module-replacement)
    for details.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更高级的选项可用，称为 *热模块替换*，它将尝试更新单个 JavaScript 模块，而不会影响其他代码或强制浏览器重新加载。有关详细信息，请参阅
    [https://webpack.js.org/guides/hot-module-replacement](https://webpack.js.org/guides/hot-module-replacement)。
- en: '*Listing 7.13* changes the script used to use the webpack development HTTP
    server instead of watch mode. (The addition of the `noClear` argument to the `tsc-watch`
    command stops the output from the webpack development server from being lost when
    the server-side code is compiled).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.13* 将脚本更改为使用 webpack 开发 HTTP 服务器而不是监视模式。（向 `tsc-watch` 命令添加 `noClear`
    参数可以防止在服务器端代码编译时丢失 webpack 开发服务器的输出）。'
- en: 'Listing 7.13: Updating the webpack script in the package.json file in the webapp
    folder'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13：更新 webapp 文件夹中 package.json 文件中的 webpack 脚本
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Stop the node processes from the previous section and run `npm` `start` in the
    `webapp` folder so that the new configuration takes effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 停止上一节中的 node 进程，并在 `webapp` 文件夹中运行 `npm start`，以便新配置生效。
- en: You can see the effect of the webpack development server by using the browser
    to request `http://localhost:5100` (note the new port number) and using your code
    editor to make a change to the `index.html` file, as shown in *Listing 7.14*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用浏览器请求 `http://localhost:5100`（注意新的端口号）并使用你的代码编辑器更改 `index.html` 文件，如图
    *列表 7.14* 所示，来查看 webpack 开发服务器的影响。
- en: 'Listing 7.14: Changing an element in the index.html file in the static folder'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14：更改 static 文件夹中 index.html 文件中的一个元素
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This file isn’t part of the bundle, but webpack watches files in the `static`
    locations in its configuration file and will trigger an update if they change.
    When you save the file, the browser will automatically reload and the new text
    on the button will be displayed, as shown in *Figure 7.3*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件不是包的一部分，但 webpack 会监视其配置文件中 `static` 位置的文件，并在它们更改时触发更新。当你保存文件时，浏览器将自动重新加载，按钮上的新文本将显示出来，如图
    *图 7.3* 所示。
- en: '![](img/B21959_07_03.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_03.png)'
- en: 'Figure 7.3: An automatic update from the webpack development server'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：webpack 开发服务器的自动更新
- en: Introducing a server just to serve the client-side code causes problems because
    the webpack server has no means to respond to HTTP requests made by the client-side
    JavaScript code it bundles. You can see the problem by clicking on the **Send
    Message** button. The request will fail, and the detail of the response generated
    by the webpack server is displayed, as shown in *Figure 7.4*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了服务客户端代码而引入服务器会导致问题，因为webpack服务器没有方法来响应它捆绑的客户端JavaScript代码发出的HTTP请求。您可以通过点击**发送消息**按钮来看到这个问题。请求将失败，webpack服务器生成的响应详情将显示，如*图7.4*所示。
- en: '![](img/B21959_07_04.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_04.png)'
- en: 'Figure 7.4: Sending an HTTP request'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：发送HTTP请求
- en: In the sections that follow, I describe three different ways this problem can
    be solved. Not all approaches work in every project because client-side frameworks
    don’t always allow the underlying webpack configuration to be changed or they
    introduce specific requirements for how requests are processed. But all frameworks
    can be used with at least one of these approaches and it is worth experimenting
    to find one that works and that suits your development style.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我描述了三种不同的解决这个问题的方法。并非所有方法都适用于每个项目，因为客户端框架并不总是允许更改底层webpack配置，或者它们为请求处理引入了特定的要求。但所有框架都可以至少使用这些方法中的一种，并且值得尝试找到一种既有效又适合您开发风格的方法。
- en: Using a different request URL
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用不同的请求URL
- en: The simplest approach is to change the URL to which the client-side JavaScript
    code sends requests, as shown in *Listing 7.15*. This is a useful approach when
    you cannot make changes to the webpack configuration file, typically because it
    is hidden deep inside a framework-specific build tool.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是更改客户端JavaScript代码发送请求的URL，如*列表7.15*所示。当你无法修改webpack配置文件时，这是一个有用的方法，通常是因为它隐藏在框架特定的构建工具深处。
- en: 'Listing 7.15: Changing URL in the client.js file in the static folder'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.15：在静态文件夹中的client.js文件中更改URL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This approach is simple and effective, but it does require changes to the server-side
    part of the application. Browsers allow JavaScript code to make HTTP requests
    only within the same *origin*, which means URLs that have the same scheme, host,
    and port as the URL used to load the JavaScript code. The change in *Listing 7.15*
    means that the HTTP request is to a URL that is outside of the allowed origin
    and so the browser blocks the request. The solution to this problem is to use
    **Cross-Origin Resource Sharing** (**CORS**), in which the browser sends an additional
    request to the target HTTP server to determine whether it is willing to accept
    HTTP requests from the origin of the JavaScript code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简单有效，但确实需要修改应用程序的服务器端部分。浏览器允许JavaScript代码仅在相同的*源*内进行HTTP请求，这意味着与加载JavaScript代码的URL具有相同方案、主机和端口的URL。*列表7.15*中的更改意味着HTTP请求是到允许源之外的URL，因此浏览器阻止了请求。解决这个问题的方法是使用**跨源资源共享**（**CORS**），在这种情况下，浏览器向目标HTTP服务器发送一个额外的请求，以确定它是否愿意接受来自JavaScript代码源的HTTP请求。
- en: Save the changes in *Listing 7.15*, open the browser’s F12 developer tools,
    and click the **Send Message** button in the browser window. Ignore the message
    displayed in the main browser window and use the **Network** tab of the F12 tools
    to see the requests the browser has made. You will see a request that uses the
    HTTP `OPTIONS` method, which is known as the *pre-flight request*, as shown in
    *Figure 7.5*, and which allows the backend server to indicate whether it will
    accept the request.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 保存*列表7.15*中的更改，打开浏览器F12开发者工具，并在浏览器窗口中点击**发送消息**按钮。忽略主浏览器窗口中显示的消息，并使用F12工具的**网络**选项卡查看浏览器已发出的请求。您将看到一个使用HTTP
    `OPTIONS`方法的请求，这被称为*预检请求*，如*图7.5*所示，它允许后端服务器表明它是否将接受请求。
- en: '![](img/B21959_07_05.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_05.png)'
- en: 'Figure 7.5: The preflight request'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：预检请求
- en: The response from the backend server did not include the `Access-Control-Allow-Origin`
    header, which would have indicated that cross-origin requests are allowed, and
    so the browser blocks the POST request.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务器的响应没有包含`Access-Control-Allow-Origin`头，这将表明允许跨源请求，因此浏览器阻止了POST请求。
- en: CORS is described in detail at [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS),
    and you can use the Node.js API described in *Chapter 5* to set the headers required
    to allow client requests. A simpler approach is to use one of the many JavaScript
    packages available to manage CORS. Run the command shown in *Listing 7.16* in
    the `webapp` folder to install a CORS package for Express and a package that describes
    the API it provides for the TypeScript compiler.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 的详细信息请参阅 [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)，您可以使用
    *第五章* 中描述的 Node.js API 来设置允许客户端请求所需的头部信息。一种更简单的方法是使用许多可用的 JavaScript 包来管理 CORS。在
    `webapp` 文件夹中运行 *列表 7.16* 中显示的命令来安装用于 Express 的 CORS 包以及描述 TypeScript 编译器提供的 API
    的包。
- en: 'Listing 7.16: Installing the CORS package and type descriptions'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.16*：安装 CORS 包和类型描述'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 7.17* configures Express to use the new package to allow cross-origin
    requests.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.17* 配置 Express 使用新包来允许跨源请求。'
- en: Listing 7.17\. Allowing cross-origin requests in the server.Ts file in the src
    folder
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.17*：在 src 文件夹中的 server.Ts 文件中允许跨源请求'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The CORS package contains an Express middleware package that is applied with
    the `use` method. The full set of CORS configuration options can be found at [https://github.com/expressjs/cors](https://github.com/expressjs/cors)
    and *Listing 7.17* uses the `origin` configuration setting to specify that requests
    are allowed from `http://localhost:5100`, which will allow requests from JavaScript
    code loaded from the webpack development server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 包包含一个用于 Express 的中间件包，该包通过 `use` 方法应用。完整的 CORS 配置选项可以在 [https://github.com/expressjs/cors](https://github.com/expressjs/cors)
    找到，*列表 7.17* 使用 `origin` 配置设置指定允许从 `http://localhost:5100` 发送请求，这将允许从 webpack
    开发服务器加载的 JavaScript 代码发送请求。
- en: Dismiss the error message displayed in the browser window (you can click the
    cross icon or reload the browser) and click the `Send Message` button again. This
    time, the backend server will respond to the OPTIONS request with the headers
    the browser is expecting, and the HTTP POST request will be allowed. The *F12*
    tools will display details of the successful request, as shown in *Figure 7.6*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭浏览器窗口中显示的错误消息（您可以点击交叉图标或重新加载浏览器），然后再次点击“发送消息”按钮。这次，后端服务器将使用浏览器期望的头部信息响应 OPTIONS
    请求，并允许 HTTP POST 请求。*F12* 工具将显示成功请求的详细信息，如图 *图 7.6* 所示。
- en: '![](img/B21959_07_06.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_06.png)'
- en: 'Figure 7.6: Using CORS to allow cross-origin requests'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：使用 CORS 允许跨源请求
- en: Forwarding requests from webpack to the backend server
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 webpack 转发请求到后端服务器
- en: A more sophisticated solution is to configure the webpack development server
    so that it forwards requests to the backend server. The request forwarding isn’t
    apparent to the browser, which means that all requests are sent to the same origin
    and CORS isn’t required. *Listing 7.18* updates the webpack configuration file
    to add support for forwarding requests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的解决方案是配置 webpack 开发服务器，使其将请求转发到后端服务器。请求转发对浏览器来说是不明显的，这意味着所有请求都发送到相同的源，因此不需要
    CORS。*列表 7.18* 更新了 webpack 配置文件以添加对请求转发的支持。
- en: 'Listing 7.18: Adding a setting in the webpack.config.mjs file in the webapp
    folder'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.18*：在 webapp 文件夹中的 webpack.config.mjs 文件中添加设置'
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `proxy` setting is used to specify one or more paths and the URLs to which
    they should be forwarded. *Listing 7.19* updates the client-side JavaScript code
    so that requests are sent relative to the JavaScript file’s origin.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `proxy` 设置来指定一个或多个路径以及它们应转发到的 URL。*列表 7.19* 更新客户端 JavaScript 代码，以便请求相对于 JavaScript
    文件的源发送。
- en: 'Listing 7.19: Using relative URLs in the client.js file in the static folder'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.19*：在 static 文件夹中的 client.js 文件中使用相对 URL'
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: webpack doesn’t pick up changes to its configuration file automatically. Use
    *Control+C* to stop the existing process and then run the `npm start` command
    in the `webapp` folder to start `webpack` and the backend server again. Use a
    browser to request `http://localhost:5100` (the URL for the webpack server) and
    then click the **Send Message** button. The webpack server will receive the request
    and act as a proxy to get a response from the backend server, producing the response
    shown in *Figure 7.7*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 不会自动检测其配置文件的更改。使用 *Control+C* 停止现有进程，然后在 `webapp` 文件夹中运行 `npm start`
    命令再次启动 `webpack` 和后端服务器。使用浏览器请求 `http://localhost:5100`（webpack 服务器的 URL），然后点击
    **发送消息** 按钮。webpack 服务器将接收请求并作为代理从后端服务器获取响应，生成如图 *图 7.7* 所示的响应。
- en: '![](img/B21959_07_07.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_07.png)'
- en: 'Figure 7.7: Using webpack as a proxy for the backend server'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：使用 webpack 作为后端服务器的代理
- en: '**Tip**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Behind the scenes, the webpack HTTP server uses Express and the core development
    server functionality is available in the `webpack-dev-middleware` package, which
    can be used as middleware in any project that also uses Express. I have not demonstrated
    this feature because it requires additional packages and extensive configuration
    changes to recreate features like live reloading, which are already set up when
    using the standard webpack development server package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，webpack HTTP 服务器使用 Express，核心开发服务器功能包含在 `webpack-dev-middleware` 包中，该包可以用作任何也使用
    Express 的项目的中间件。我没有演示此功能，因为它需要额外的包和广泛的配置更改来重新创建像实时重新加载这样的功能，而这些功能在使用标准的 webpack
    开发服务器包时已经设置好了。
- en: See [https://webpack.js.org/guides/development/#using-webpack-dev-middleware](https://webpack.js.org/guides/development/#using-webpack-dev-middleware)
    for details of using webpack as Express middleware.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将 webpack 作为 Express 中间件使用的详细信息，请参阅 [https://webpack.js.org/guides/development/#using-webpack-dev-middleware](https://webpack.js.org/guides/development/#using-webpack-dev-middleware)。
- en: Forwarding requests from the backend server to webpack
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将请求从后端服务器转发到 webpack
- en: The third approach is to switch the servers around so that the backend server
    forwards requests to the webpack server. This has the advantage of making the
    development environment more consistent with production and ensures that headers
    set by the backend server are applied. Run the commands shown in *Listing 7.20*
    in the `webapp` folder to install a proxy package for Express and a description
    of the API it provides for the TypeScript compiler.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是调整服务器，使后端服务器将请求转发到 webpack 服务器。这种方法的优势在于使开发环境与生产环境更加一致，并确保后端服务器设置的头部得到应用。在
    `webapp` 文件夹中运行 *列表 7.20* 中显示的命令以安装 Express 的代理包及其为 TypeScript 编译器提供的 API 描述。
- en: 'Listing 7.20: Installing a proxy package'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.20：安装代理包
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 7.21* changes the Express configuration so that requests are forwarded
    to the webpack server.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.21* 修改了 Express 配置，以便将请求转发到 webpack 服务器。'
- en: 'Listing 7.21: Forwarding requests in the server.ts file in the src folder'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.21：在 src 文件夹中的 server.ts 文件中转发请求
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The changes enable the proxy, including support for dealing with web socket
    requests, which are used for the live reload feature, and which must also be forwarded
    to the webpack development server. A corresponding update is required in the webpack
    configuration file to specify the URL that the client-side live reloading code
    will connect to, as shown in *Listing 7.22*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改启用了代理，包括处理用于实时重新加载功能的 WebSocket 请求的支持，这些请求也必须转发到 webpack 开发服务器。需要在 webpack
    配置文件中进行相应的更新，以指定客户端实时重新加载代码将连接到的 URL，如图 *7.22* 所示。
- en: 'Listing 7.22: Changing the client-side URL in the webpack.config.mjs file'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.22：在 webpack.config.mjs 文件中更改客户端 URL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Use *Control+C* to stop the existing build process and run `npm start` in the
    `webapp` folder so that the changes take effect. Use a browser to request `http://localhost:5000`,
    as shown in *Figure 7.8*, to have the backend server receive the request and still
    benefit from the features of the webpack development server.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Control+C* 停止现有的构建过程，并在 `webapp` 文件夹中运行 `npm start` 以使更改生效。使用浏览器请求 `http://localhost:5000`，如图
    *7.8* 所示，以便后端服务器接收请求并仍然受益于 webpack 开发服务器的功能。
- en: '![](img/B21959_07_08.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_08.png)'
- en: 'Figure 7.8: Using the backend server as a proxy for webpack'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：使用后端服务器作为 webpack 的代理
- en: Using a content security policy
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内容安全策略
- en: CORS is an example of a set of request headers that were introduced to address
    malicious behavior by providing the browser with information about how the application
    is expected to work.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 是一组请求头部的示例，它通过向浏览器提供有关应用程序预期如何工作的信息来应对恶意行为。
- en: There are additional headers that the backend server can set to provide the
    browser with insight into how the application works and what behaviors are expected.
    The most important header is `Content-Security-Policy`, which the backend server
    uses to describe the application’s **Content Security Policy** (**CSP**). The
    CSP tells the browser what behaviors to expect from the client-side application
    so that the browser can block suspicious activity.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务器可以设置额外的头信息，以便向浏览器提供有关应用程序如何工作以及预期行为的信息。最重要的头信息是 `Content-Security-Policy`，后端服务器使用它来描述应用程序的
    **内容安全策略**（**CSP**）。CSP 告诉浏览器从客户端应用程序期望的行为，以便浏览器可以阻止可疑活动。
- en: The use of content security policies is intended to prevent **cross-site scripting**
    (**XSS**) attacks. There are many variations of XSS attacks, but they all involve
    injecting malicious content or code into the content displayed by the browser
    to perform a task not intended by the application developers – typically something
    that deceives the user or steals sensitive data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 内容安全策略的使用旨在防止 **跨站脚本**（**XSS**）攻击。XSS 攻击有很多变体，但它们都涉及将恶意内容或代码注入到浏览器显示的内容中，以执行应用程序开发者未打算执行的任务——通常是欺骗用户或窃取敏感数据。
- en: One common cause of XSS attacks arises when an application accepts input from
    one user that is subsequently incorporated into the content presented to other
    users. If an application accepts user reviews that are displayed alongside products,
    for example, an attacker could craft a review that browsers will interpret as
    HTML or JavaScript content when the product page is displayed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 攻击的一个常见原因是当应用程序接受来自一个用户的输入，随后将其整合到展示给其他用户的内 容中。例如，如果一个应用程序接受显示在产品旁边的用户评论，攻击者可以构建一个评论，当产品页面显示时，浏览器将其解释为
    HTML 或 JavaScript 内容。
- en: The best place to start is with a demonstration of the problem, which requires
    some changes to the example application. The first change is to add an `input`
    element to the HTML document displayed by the browser, which will allow the user
    to enter data that will later be displayed by the browser, as shown in *Listing
    7.23*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的起点是演示问题，这需要对示例应用程序进行一些更改。第一个更改是在浏览器显示的 HTML 文档中添加一个 `input` 元素，这将允许用户输入数据，该数据稍后将被浏览器显示，如
    *列表 7.23* 所示。
- en: 'Listing 7.23: Adding an input element in the index.html file in the static
    folder'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.23：在静态文件夹中的 index.html 文件中添加一个输入元素
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7.24* updates the client-side JavaScript code so that it sends the
    contents of the `input` element added in *Listing 7.23* to the server.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.24* 更新客户端 JavaScript 代码，以便将 *列表 7.23* 中添加的 `input` 元素的 内容发送到服务器。'
- en: 'Listing 7.24: Updating the client-side code in the client.js file in the static
    folder'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.24：在静态文件夹中的 client.js 文件中更新客户端代码
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 7.25* updates the handler that receives data from the browser so that
    it pipes the data from the request to the response. This means that whatever is
    entered into the `input` element will be sent to the server and then piped back
    to the browser, where it will be displayed to the user.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.25* 更新了接收浏览器数据的处理器，以便将数据从请求管道到响应。这意味着输入到 `input` 元素中的任何内容都将发送到服务器，然后管道回浏览器，在那里它将被显示给用户。'
- en: 'Listing 7.25: Piping data in the readHandler.ts file in the src folder'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.25：在 src 文件夹中的 readHandler.ts 文件中管道数据
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The handler also sets a cookie in the response. One of the uses of XSS attacks
    is to steal session credentials so that the attacker can impersonate a legitimate
    user. The cookie set by the code in *Listing 7.25* is a placeholder for data that
    will be stolen.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器还在响应中设置了一个 cookie。XSS 攻击的一种用途是窃取会话凭证，以便攻击者可以冒充合法用户。*列表 7.25* 中的代码设置的 cookie
    是将要窃取的数据的占位符。
- en: '**Tip**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: See Part 2 of this book for details on how to create and use real sessions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何创建和使用真实会话的详细信息，请参阅本书的第二部分。
- en: The changes from *Listing 7.23* to *Listing 7.25* deliberately create a situation
    where input provided by the user is used without any form of validation. This
    sort of problem is easy to spot in a simple example but can be much more difficult
    to identify in a real project, especially one where features are added over time.
    This is such a common problem that XSS is one of the top 10 application security
    risks identified by the **Open Worldwide Application Security Project** (**OWASP**)
    and has been for some years (see [https://owasp.org/www-project-top-ten](https://owasp.org/www-project-top-ten)
    for the complete list).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从*列表7.23*到*列表7.25*所做的更改故意创建了一种情况，即用户提供的输入在没有任何形式验证的情况下被使用。这种问题在简单示例中很容易发现，但在实际项目中可能要困难得多，尤其是在随着时间的推移添加功能的项目中。这是一个如此普遍的问题，以至于跨站脚本攻击（XSS）是**开放式全球应用程序安全项目**（**OWASP**）确定的十大应用安全风险之一，并且已经持续了多年（有关完整列表，请参阅[https://owasp.org/www-project-top-ten](https://owasp.org/www-project-top-ten)）。
- en: Injecting malicious content
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入恶意内容
- en: To complete the preparations, add a file named `badServer.mjs` to the `webapp`
    folder with the content shown in *Listing 7.26*. This is a “bad” server, which
    will serve content and receive requests on behalf of malicious code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成准备工作，将名为`badServer.mjs`的文件添加到`webapp`文件夹中，其内容如*列表7.26*所示。这是一个“不良”服务器，它将代表恶意代码提供内容和接收请求。
- en: 'Listing 7.26: Creating a server in the badServer.mjs file in the webapp folder'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.26：在webapp文件夹中的badServer.mjs文件中创建服务器
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For the sake of simplicity, this file contains JavaScript code so that it can
    be executed without needing the TypeScript compiler. The code is expressed for
    brevity, rather than readability, and uses the Express features for serving static
    content and the router to receive POST requests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，此文件包含JavaScript代码，以便无需TypeScript编译器即可执行。代码以简洁性表达，而不是可读性，并使用Express功能提供静态内容，以及路由器接收POST请求。
- en: Open a new command prompt, navigate to the `webapp` folder, and run the command
    shown in *Listing 7.27* to start the server.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的命令提示符，导航到`webapp`文件夹，并运行*列表7.27*中显示的命令以启动服务器。
- en: 'Listing 7.27: Starting the bad web server'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.27：启动不良服务器
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Having prepared the example application and the bad server, the process of subverting
    the application requires entering carefully crafted strings, intended to get the
    browser to load content or execute JavaScript that isn’t part of the application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好示例应用程序和不良服务器后，颠覆应用程序的过程需要输入精心设计的字符串，目的是让浏览器加载内容或执行不属于应用程序的JavaScript。
- en: '**Note**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: This section shows simple – and related – exploits that take advantage of a
    defect that I have knowingly created, which helps me describe useful features
    but doesn’t cover the full spectrum of XSS issues. You can find an excellent set
    of XSS tests to apply at [https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了简单且相关的利用，这些利用利用了我有意创建的缺陷，这有助于我描述有用的功能，但并不涵盖XSS问题的全部范围。您可以在[https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)找到一组出色的XSS测试。
- en: Enter the text shown in *Listing 7.28* into the `input` element and click the
    **Send Message** button. Pay close attention to the quote characters when entering
    the text into the `input` element. It is important to use double and single quotes
    as they are shown, otherwise, the browser won’t be able to parse the string.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将*列表7.28*中显示的文本输入到`input`元素中，并点击**发送消息**按钮。在将文本输入到`input`元素时，请注意引号字符。使用双引号和单引号非常重要，正如所示，否则浏览器将无法解析字符串。
- en: 'Listing 7.28: Requesting an image'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.28：请求图像
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The client-side JavaScript code adds the response from the server to the HTML
    document displayed to the user, which causes the browser to request an image file
    from the bad server. Clicking on the image causes the browser to navigate away
    from the application, as shown in *Figure 7.9*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端JavaScript代码将服务器的响应添加到显示给用户的HTML文档中，这导致浏览器从不良服务器请求图像文件。点击图像会导致浏览器从应用程序导航离开，如图*图7.9*所示。
- en: '![](img/B21959_07_09.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21959_07_09.png]'
- en: 'Figure 7.9: Loading an image with a click redirection'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：通过点击重定向加载图像
- en: It isn’t just images that can be added to the document. Enter the text shown
    in *Listing 7.29* into the `input` element and click the **Send Message** button,
    which will add a button to the document displayed by the user. Once again, pay
    close attention to the quote characters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加到文档中的不仅仅是图像。将 *Listing 7.29* 中显示的文本输入到 `input` 元素中，然后点击 **发送消息** 按钮，这将向用户显示的文档中添加一个按钮。再次密切注意引号字符。
- en: 'Listing 7.29: Creating a button'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.29：创建按钮
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The button that is created takes advantage of the CSS stylesheets that are used
    by the application, giving the new element an appearance that is consistent with
    the other button displayed by the browser, as shown in *Figure 7.11*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的按钮利用了应用程序使用的 CSS 样式表，使新元素的外观与浏览器显示的其他按钮保持一致，如图 *7.11* 所示。
- en: '![](img/B21959_07_10.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_10.png)'
- en: 'Figure 7.11: Adding an element'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：添加元素
- en: Injected code can also be used to steal sensitive data. Enter the text shown
    in *Listing 7.30* into the `input` element and click the **Send Message** button,
    once again paying close attention to the quote characters and entering the text
    as a single line.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的代码也可以用来窃取敏感数据。将 *Listing 7.30* 中显示的文本输入到 `input` 元素中，然后再次点击 **发送消息** 按钮，同时密切注意引号字符，并将文本作为单行输入。
- en: 'Listing 7.30: Stealing data'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.30：窃取数据
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This `img` element specifies a file that doesn’t exist. The browser will emit
    the `error` event when it fails to load the file, which executes the fragment
    of JavaScript code assigned to the `onerror` attribute in *Listing 7.30*. The
    code uses the browser’s Fetch API to send an HTTP POST request to the bad server,
    including the sensitive cookie data as the request body. If you examine the output
    from the command prompt running the bad server, you will see the following message,
    showing the data that the bad server received:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `img` 元素指定了一个不存在的文件。当浏览器无法加载文件时，将触发 `error` 事件，执行 *Listing 7.30* 中分配给 `onerror`
    属性的 JavaScript 代码片段。该代码使用浏览器的 Fetch API 向恶意服务器发送 HTTP POST 请求，包括作为请求体的敏感 cookie
    数据。如果你检查运行恶意服务器的命令提示符的输出，你会看到以下消息，显示恶意服务器接收到的数据：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: No user action was needed to trigger this behavior and the data is sent as soon
    as the browser tries – and fails – to load the image. For the final example, add
    a file named `bad.js` to the `static` folder with the content shown in *Listing
    7.31*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要用户操作即可触发此行为，并且数据在浏览器尝试（并失败）加载图像时立即发送。对于最后一个示例，将名为 `bad.js` 的文件添加到 `static`
    文件夹中，其内容如 *Listing 7.31* 所示。
- en: 'Listing 7.31: The contents of the bad.js file in the static folder'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.31：静态文件夹中 bad.js 文件的内容
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code locates the `button` element in the HTML document and replaces it
    with one that sends the sensitive data to the bad server. To get the browser to
    load this file, enter the text shown in *Listing 7.32* in the `input` element
    and click the **Send Message** button. This is the most complex example in this
    section and particular care must be taken to enter it correctly and as a single
    line.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定位 HTML 文档中的 `button` 元素，并将其替换为将敏感数据发送到恶意服务器的元素。要使浏览器加载此文件，请在 `input` 元素中输入
    *Listing 7.32* 中显示的文本，然后点击 **发送消息** 按钮。这是本节中最复杂的示例，必须特别小心地正确输入，并且作为单行输入。
- en: 'Listing 7.32: Loading a JavaScript file'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.32：加载 JavaScript 文件
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The JavaScript code uses the browser’s Fetch API to request the `bad.js` file
    from the bad HTTP server and then uses the JavaScript `eval` function to execute
    its contents. The `eval` function will treat any string as JavaScript code and,
    as a consequence, can present a risk whenever it is used. When the browser executes
    the JavaScript code, the existing button is replaced with one that sends the sensitive
    cookie data to the bad server, as shown in *Figure 7.12*. (The button text is
    also changed just to emphasize the change.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码使用浏览器的 Fetch API 从恶意 HTTP 服务器请求 `bad.js` 文件，然后使用 JavaScript `eval`
    函数执行其内容。`eval` 函数将任何字符串视为 JavaScript 代码，因此，每次使用时都可能存在风险。当浏览器执行 JavaScript 代码时，现有的按钮将被替换为将敏感
    cookie 数据发送到恶意服务器的按钮，如图 *7.12* 所示。（按钮文本也进行了更改，以强调变化。）
- en: '![](img/B21959_07_11.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_07_11.png)'
- en: 'Figure 7.12: Replacing a button'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：替换按钮
- en: 'When you click the button, the bad HTTP server will display a console message
    that shows the cookie value and whatever you entered into the `input` element
    before clicking the button, like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击按钮时，恶意 HTTP 服务器将显示一个控制台消息，显示 cookie 值以及你在点击按钮之前输入到 `input` 元素中的任何内容，如下所示：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Why Not Just inject a script element?**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么不直接注入一个脚本元素？**'
- en: 'XSS attacks have been such a problem for so long that some protections against
    them are codified into the HTML specification. For example, the client-side code
    in the example application uses the `innerHTML` property to display the response
    it receives from the backend server, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: XSS攻击已经是一个长期存在的问题，以至于一些针对它们的保护措施被编码到HTML规范中。例如，示例应用中的客户端代码使用`innerHTML`属性来显示它从后端服务器接收到的响应，如下所示：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The HTML specification instructs browsers not to execute `script` elements assigned
    to the `innerHTML` property, which means that using JavaScript code directly won’t
    work, but using event handlers will. This limitation arises because of the way
    the example app has evolved from chapter to chapter, and you must not assume that
    all applications will be similarly restricted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: HTML规范指示浏览器不要执行分配给`innerHTML`属性的`script`元素，这意味着直接使用JavaScript代码将不会工作，但使用事件处理器将会。这种限制是由于示例应用从一章到另一章的演变方式造成的，并且你不应该假设所有应用都会受到类似的限制。
- en: Defining a content security policy
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义内容安全策略
- en: A content security policy tells the browser how the client-side application
    is expected to behave and is set using the `Content-Security-Policy` header, as
    shown in *Listing 7.33*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 内容安全策略告诉浏览器客户端应用预期如何行为，并使用`Content-Security-Policy`标头设置，如*列表7.33*所示。
- en: 'Listing 7.33: Setting a content security policy in the server.ts file in the
    src folder'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.33：在src文件夹中的server.ts文件中设置内容安全策略
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The CSP header should be applied to every response, and so the listing uses
    the Express `use` method to set up a middleware component, which is like a regular
    request handler but receives an additional argument that is used to pass the request
    along for further processing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 应将CSP标头应用于每个响应，因此列表使用Express的`use`方法设置一个中间件组件，它类似于常规请求处理器，但接收一个额外的参数，用于将请求传递给进一步处理。
- en: 'The header value is the policy for the application and consists of one or more
    *policy directives* and values. The header in *Listing 7.33* contains one policy
    directive, which is `img-src` and whose value is `self`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 标头值是应用的策略，由一个或多个*策略指令*和值组成。*列表7.33*中的标头包含一个策略指令，即`img-src`，其值为`self`：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The CSP specification defines a range of policies that specify the locations
    from which different content can be loaded. *Table 7.4* describes the most useful
    policy directives, and a full list can be found at `https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: CSP规范定义了一系列策略，指定了可以从不同位置加载的不同内容。*表7.4*描述了最有用的策略指令，完整的列表可以在`https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy`找到。
- en: 'Table 7.4: Useful CSP directives'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.4：有用的CSP指令
- en: '| Policy Directive | Description |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 策略指令 | 描述 |'
- en: '|'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| This directive sets the default policy for all directives. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 此指令设置所有指令的默认策略。 |'
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| This directive specifies the URLs that can be requested using JavaScript
    code. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 此指令指定了可以使用JavaScript代码请求的URL。 |'
- en: '|'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '| This directive specifies the sources from which images can be loaded. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 此指令指定了可以从其中加载图片的来源。 |'
- en: '|'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '| This directive specifies the sources from which JavaScript files can be loaded.
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 此指令指定了可以从其中加载JavaScript文件的来源。 |'
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| This directive specifies the valid sources for inline event handlers. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 此指令指定了内联事件处理器的有效来源。 |'
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| This directive specifies the URLs to which form data can be sent. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 此指令指定了可以发送表单数据的URL。 |'
- en: The values for a policy can be specified using URLs with wildcards (such as
    `http://*.acme.com`) or a scheme (such as `http:` to allow all HTTP requests or
    `https:` for all HTTPS requests). There are also special values such as `'none'`,
    which blocks all URLs, and `'self'`, which limits requests to the origin from
    which the document was loaded. (The single quotes must be specified for these
    special values, which is why the policy defined in *Listing 7.33* looks oddly
    quoted.)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 策略的值可以使用带有通配符的URL（例如`http://*.acme.com`）或方案（例如`http:`以允许所有HTTP请求或`https:`以允许所有HTTPS请求）来指定。还有特殊值，如`'none'`，它阻止所有URL，以及`'self'`，它限制请求到加载文档的来源。（这些特殊值必须指定单引号，这就是为什么*列表7.33*中定义的策略看起来奇怪地加了引号。）
- en: The policy defined in *Listing 7.33* tells the browser that images can only
    be requested from the same origin as the HTML document. To see the effect, reload
    the browser, enter the text from *Listing 7.28*, and click the **Send Message**
    button. (You must reload to ensure that the header defined in *Listing 7.33* is
    sent to the browser.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *列表 7.33* 中定义的策略告诉浏览器，只能从与 HTML 文档相同的源请求图像。为了看到效果，请重新加载浏览器，输入 *列表 7.28* 中的文本，然后点击
    **发送消息** 按钮。（您必须重新加载以确保 *列表 7.33* 中定义的头部信息被发送到浏览器。）
- en: 'The policy restricts images so they can only come from the same origin as the
    HTML document. If you examine the browser’s *F12* developer tools, you will see
    an error message in the console similar to this one, which is from Chrome:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略限制了图像，使其只能来自与 HTML 文档相同的源。如果您检查浏览器的 *F12* 开发者工具，您将在控制台看到类似以下错误消息，这是来自 Chrome
    的：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The attempt to load an image from the bad server was prevented, but if you click
    the broken image placeholder displayed by the browser, you will still be able
    to navigate away from the application. Policies generally require multiple directives
    to be effective.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止从不良服务器加载图像的尝试，但如果您点击浏览器显示的损坏图像占位符，您仍然可以离开应用程序。策略通常需要多个指令才能有效。
- en: Using a package to set the policy header
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包设置策略头部
- en: It is possible to set the CSP header directly, as the previous section demonstrated,
    but using a package to define a CSP policy is easier and less prone to errors.
    One excellent package is *Helmet* ([https://helmetjs.github.io](https://helmetjs.github.io)),
    which sets several security-related headers, including the CSP header. Run the
    command shown in *Listing 7.34* in the `webapp` folder to install the Helmet package.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接设置 CSP 头部，如前节所示，但使用包来定义 CSP 策略更容易且更不容易出错。一个优秀的包是 *Helmet* ([https://helmetjs.github.io](https://helmetjs.github.io))，它设置了一些与安全相关的头部，包括
    CSP 头部。在 `webapp` 文件夹中运行 *列表 7.34* 中显示的命令以安装 Helmet 包。
- en: 'Listing 7.34: Adding a package to the project'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.34：将包添加到项目中
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 7.35* replaces the custom middleware from the previous section with
    the equivalent functionality provided by Helmet and defines the complete policy
    for the example application.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.35* 替换了上一节中的自定义中间件，并定义了示例应用的完整策略。'
- en: 'Listing 7.35: Defining a CSP policy in the server.ts file in the src folder'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.35：在 src 文件夹中的 server.ts 文件中定义 CSP 策略
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Helmet is applied as middleware and is configured with an object whose properties
    determine the headers that are set and the values that should be used. The `contentSecurityPolicy.directives`
    property is used to set CSP directives, expressed as camel case because the hyphenated
    CSP directive names are not allowed in JavaScript (so `img-src` becomes `imgSrc`,
    for example).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Helmet 作为中间件应用，并配置了一个对象，其属性决定了设置的头部和应使用的值。`contentSecurityPolicy.directives`
    属性用于设置 CSP 指令，因为 JavaScript 中不允许使用连字符的 CSP 指令名称，所以以驼峰式表达（例如，`img-src` 变为 `imgSrc`）。
- en: The configuration in *Listing 7.35* specifies a content security policy that
    will allow images to be loaded from the HTML document’s domain, block all JavaScript
    in element attributes, restrict JavaScript files to the document’s domain, and
    limit the URLs to which connections can be made by JavaScript code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7.35* 中的配置指定了一个内容安全策略，允许从 HTML 文档的域加载图像，阻止元素属性中的所有 JavaScript，限制 JavaScript
    文件只能来自文档的域，并限制 JavaScript 代码可以建立连接的 URL。'
- en: This last directive specifies `self`, allowing HTTP connections to be sent to
    the backend server, but also includes the `ws://localhost:5000` URL, which allows
    the connection required by the webpack live reload feature (the `ws` scheme denotes
    a web sockets connection and is the same connection that required additional configuration
    when setting up the proxy in *Listing 7.21*).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个指令指定了 `self`，允许发送 HTTP 连接到后端服务器，但也包括了 `ws://localhost:5000` URL，这允许 webpack
    实时重新加载功能所需的连接（`ws` 方案表示一个 WebSocket 连接，这是在 *列表 7.21* 中设置代理时需要额外配置的相同连接）。
- en: If you reload the browser at this point, you will see a CSP error displayed
    in the browser’s JavaScript console. That’s because the CSP has disabled the use
    of the `eval` function, which is sensible because it is so dangerous, but problematic
    because webpack unpacks the contents of its bundles using `eval`. (This is only
    the case when webpack is producing development bundles and is not the case when
    the final bundles are produced before an application is deployed.)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时重新加载浏览器，你将在浏览器的JavaScript控制台中看到CSP错误。这是因为CSP已禁用 `eval` 函数的使用，这是合理的，因为它非常危险，但问题在于webpack使用
    `eval` 解包其打包内容。（这仅在webpack生成开发打包时适用，在应用部署前生成的最终打包中不适用。）
- en: The best approach is to change the webpack configuration so that it uses a different
    technique to process bundles, as shown in *Listing 7.36*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳做法是更改webpack配置，使其使用不同的技术来处理打包，如 *Listing 7.36* 所示。
- en: 'Listing 7.36: Changing the webpack configuration in the webpack.config.mjs
    file in the webapp folder'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.36：在 `webapp` 文件夹中的 `webpack.config.mjs` 文件中更改webpack配置
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Use *Control+C* to stop the build tools and run the `npm start` command in the
    `webapp` folder to start them again with the new configuration. Reload the browser
    and the JavaScript bundle will be processed without using the `eval` function.
    Run through the examples in *Listing 7.28* to *Listing 7.32* again and you will
    see that each attack is defeated by one of the content security settings.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Control+C* 停止构建工具，并在 `webapp` 文件夹中运行 `npm start` 命令以使用新的配置重新启动它们。重新加载浏览器，JavaScript
    打包器将不使用 `eval` 函数进行处理。再次运行从 *Listing 7.28* 到 *Listing 7.32* 的示例，你会看到每个攻击都被内容安全策略中的一个设置所击败。
- en: '**Note**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `Content-Security-Policy-Report-Only` header instructs the browser to report
    on actions that would break the content security policy without blocking those
    actions, which can be a good way to assess an existing application. If you are
    using the Helmet package, you can enable this header by setting the `contentSecurityPolicy.reportOnly`
    configuration setting to `true`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Security-Policy-Report-Only` 标头指示浏览器报告那些会破坏内容安全策略但不会阻止这些操作的行为，这可以是一种评估现有应用的好方法。如果你正在使用Helmet包，可以通过将
    `contentSecurityPolicy.reportOnly` 配置设置设为 `true` 来启用此标头。'
- en: There are limits to CSP and it is important to avoid including unfiltered user
    input in the HTML displayed to the user. I demonstrate how user input can be processed
    in Part 2 of this book.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: CSP（内容安全策略）有其限制，避免在向用户显示的HTML中包含未经过滤的用户输入是很重要的。我在本书的第二部分演示了如何处理用户输入。
- en: '**Note**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you are unable to alter the webpack configuration, then you can allow the
    `eval` function in the content security policy. Use `"'self' 'unsafe-eval'"` as
    the value for the `scriptSrc` setting. The special `'unsafe-eval'` value allows
    the eval function to be used, but the `'self'` value restricts the locations from
    which JavaScript files can be downloaded to just the backend server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法更改webpack配置，则可以在内容安全策略中允许使用 `eval` 函数。将 `scriptSrc` 设置的值设为 `"'self' 'unsafe-eval'"`。特殊的
    `'unsafe-eval'` 值允许使用 `eval` 函数，但 `'self'` 值限制了可以下载JavaScript文件的来源，仅限于后端服务器。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, I described two important ways in which the backend Node.js
    server works with the other components in a modern web application. The first
    topic I described was the use of a bundler:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了两种重要的方式，即后端Node.js服务器如何与现代Web应用中的其他组件协同工作。我描述的第一个主题是使用打包器：
- en: Bundlers combine and compress multiple files to reduce the number of HTTP requests
    made by the browser and reduce the amount of data to be transferred.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包器将多个文件合并并压缩，以减少浏览器发出的HTTP请求次数，并减少需要传输的数据量。
- en: Bundlers are integrated into the developer tools for all of the popular client-side
    frameworks, including Angular and React.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包器已集成到所有流行的客户端框架的开发工具中，包括Angular和React。
- en: Bundlers can work independently of the backend server, but the best workflows
    are achieved by using them together.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包器可以独立于后端服务器工作，但最佳工作流程是通过一起使用它们来实现的。
- en: The second topic I described was the application of a content security policy.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我描述的第二个主题是内容安全策略的应用。
- en: Content security policies are used to defend against **cross-site scripting**
    (**XSS**) attacks, in which the goal is to trick the browser into executing malicious
    JavaScript code.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容安全策略用于防御 **跨站脚本攻击**（XSS），其目标是欺骗浏览器执行恶意JavaScript代码。
- en: To apply a content security policy, the backend server provides the browser
    with a description of how the client-side application code behaves in terms of
    how it obtains and uses resources such as images and JavaScript code.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了应用内容安全策略，后端服务器向浏览器提供客户端应用程序代码如何行为的描述，包括它如何获取和使用资源，如图片和 JavaScript 代码。
- en: The browser blocks JavaScript operations that are outside of the limits imposed
    by the content security policy.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器会阻止超出内容安全策略限制的 JavaScript 操作。
- en: In the next chapter, I will demonstrate the features that Node.js provides for
    unit testing and debugging JavaScript code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将演示 Node.js 为单元测试和调试 JavaScript 代码提供的功能。
