- en: Chapter 3. Nesting Rules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。嵌套规则
- en: If you have spent any time developing with preprocessors, then you will likely
    have come across nested properties—instead of writing multiple style rules with
    repeated references to the same elements, we can use nesting to create concise
    style rules that compile to valid CSS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花过时间使用预处理程序进行开发，那么你可能会遇到嵌套属性——我们不需要写多个带有对相同元素重复引用的样式规则，我们可以使用嵌套来创建简洁的样式规则，这些规则编译成有效的CSS。
- en: 'In this chapter, we''ll delve into using the power of nesting, show you how
    you can transition from using preprocessors such as SASS or Less, and explore
    some of the tricks we can use that are not available with preprocessors such as
    SASS:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨使用嵌套的强大功能，向您展示如何从使用预处理程序（如SASS或Less）过渡，并探索一些我们可以在没有预处理程序（如SASS）的情况下使用的技巧：
- en: Exploring the use of BEM (Block, Element, Modifier) or standard nesting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用BEM（块、元素、修饰符）或标准嵌套
- en: Creating nested rules and BEM equivalents using existing preprocessors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有预处理程序创建嵌套规则和BEM等效规则
- en: Transitioning to using PostCSS plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向使用PostCSS插件
- en: Understanding the pitfalls of nesting and how we can improve our code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解嵌套的陷阱以及我们如何改进代码
- en: Let's make a start…!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧…！
- en: Introducing nesting
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍嵌套
- en: The concept of nesting is nothing new when using processors such as Less CSS
    or SASS; it's a useful technique to help reduce the amount of code we need to
    write, and to organize code in a more human-readable format.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Less CSS或SASS等处理器时，嵌套的概念并不新鲜；这是一种有用的技术，可以帮助我们减少需要编写的代码量，并以更易于人类阅读的格式组织代码。
- en: The flipside of the coin is that it is frequently abused—when using processors
    for the first time, many developers fall into the trap of thinking that everything
    should be nested. One can get away with it if the code is very simple; it is more
    likely to result in fragile code that is difficult to read and easily broken with
    simple changes to one or more styles in the code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它经常被滥用——当第一次使用处理器时，许多开发者会陷入认为所有内容都应该嵌套的陷阱。如果代码非常简单，可能还能侥幸过关；更有可能的结果是产生脆弱的代码，难以阅读，并且简单更改代码中的一个或多个样式就容易被破坏。
- en: 'If nesting is done correctly, then it can be very effective; it helps avoid
    the need to repeat parent selectors, and allows us to group together rules that
    apply to the same selector, together. To see what is meant by this, take a look
    at this simple example for SASS:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果嵌套做得正确，那么它可以非常有效；它有助于避免重复父选择器的需要，并允许我们将应用于相同选择器的规则组合在一起。为了了解这意味着什么，请看这个简单的SASS示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If this is compiled using a GUI application or via the command line, it results
    in these styles:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用GUI应用程序或通过命令行编译，它会产生以下样式：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The great thing about this code is that we've not tried to cram in every single
    rule that applies to the same parent selector, or a descendant; this is something
    we should consider when working with nesting.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的伟大之处在于，我们没有试图将适用于相同父选择器或后代的所有规则都塞进来；这是我们在处理嵌套时应该考虑的事情。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how, in our SASS example, the nesting was at the end of the code? It's
    considered good practice to include nested statements at the end, before the closing
    bracket.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的SASS示例中，嵌套是在代码的末尾？将嵌套语句放在末尾，在闭合括号之前，被认为是良好的实践。
- en: Some developers counsel against using nesting though, as it causes real issues
    for elements that have been styled in specific contexts; it becomes harder to
    change the code if we need to change the style. We will explore more of the reasons
    why nesting is fraught with risks later in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者建议不要使用嵌套，因为它会给在特定上下文中样式化的元素带来真正的问题；如果我们需要更改样式，代码就变得更难更改。我们将在本章后面进一步探讨嵌套充满风险的原因。
- en: 'Leaving aside the risks of nesting for the moment, we can use the same basic
    principle of nesting when using PostCSS—for this, we need to use the `postcss-nesting`
    plugin by Jonathan Neal, which is available from [https://github.com/jonathantneal/postcss-nesting](https://github.com/jonathantneal/postcss-nesting).
    To give you a flavor of what nesting looks like in PostCSS, take a look at this
    screenshot—this is an online playground provided by the author for trialing nested
    statements, where we can see the results automatically on the right:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时抛开嵌套的风险，我们可以在使用PostCSS时使用相同的基本嵌套原则——为此，我们需要使用Jonathan Neal的`postcss-nesting`插件，该插件可在[https://github.com/jonathantneal/postcss-nesting](https://github.com/jonathantneal/postcss-nesting)获取。为了给您一个PostCSS中嵌套外观的印象，请看这张截图——这是作者提供的在线游乐场，用于试验嵌套语句，我们可以在右侧自动看到结果：
- en: '![Introducing nesting](img/BO5194_03_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![介绍嵌套](img/BO5194_03_01.jpg)'
- en: 'The key line is on the left, fifth from the bottom: the `postcss-nesting` plugin
    uses `@nest &` as the placeholder for nesting code.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关键行在左侧，从下往上数第五行：`postcss-nesting`插件使用`@nest &`作为嵌套代码的占位符。
- en: To help illustrate how the `postcss-nesting` plugin works, we will use it to
    create a somewhat unique navigation system. Our navigation will use a mix of jQuery
    and CSS to style and flip some demo pages, with the animation effects provided
    by CSS3 styling. Intrigued? Let's dive in and take a look.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助说明`postcss-nesting`插件的工作原理，我们将使用它创建一个相对独特的导航系统。我们的导航将结合使用jQuery和CSS来样式化和翻转一些演示页面，动画效果由CSS3样式提供。感兴趣吗？让我们深入探讨并看看。
- en: Navigating through pages
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在页面间导航
- en: I've always had a desire to do something a little different; doing the same
    thing as everyone else becomes so passé! With this in mind, when researching for
    this book, I came across an intriguing demo by Nikolay Talanov, where pages are
    flipped over from one to the next, using either CSS3 animation if supported, or
    falling back to standard jQuery.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直渴望做一些与众不同的事情；和别人做同样的事情变得如此过时！本着这个想法，在为这本书进行研究时，我遇到了Nikolay Talanov的一个有趣的演示，其中页面从一个翻到下一个，如果支持，则使用CSS3动画，否则回退到标准的jQuery。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can see the original pen demo at [http://codepen.io/suez/pen/LCHlA](http://codepen.io/suez/pen/LCHlA).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://codepen.io/suez/pen/LCHlA](http://codepen.io/suez/pen/LCHlA)看到原始的pen演示。
- en: This has provided a perfect base for this chapter. For the purpose of the demos,
    I've stripped back the vendor prefixes (as these will be covered by `Autoprefixer`),
    tweaked the design of the first page, and switched to just using nesting throughout.
    The jQuery fall-back code has also been removed, as most modern browsers will
    support the animations with little difficulty.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这为本章提供了一个完美的基础。为了演示的目的，我移除了供应商前缀（因为这些将由`Autoprefixer`处理），调整了第一页的设计，并切换到整个使用嵌套。jQuery回退代码也已移除，因为大多数现代浏览器都能轻松支持这些动画。
- en: Preparing our demo
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备我们的演示
- en: 'For our demo, we will have four pages—the navigation will flip between each
    page, using standard CSS3 animation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将有四个页面——导航将在每个页面之间翻转，使用标准的CSS3动画：
- en: '![Preparing our demo](img/BO5194_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![准备我们的演示](img/BO5194_03_02.jpg)'
- en: The design may be a little unique, but to help illustrate how it could be used,
    I've added a simple wireframe sketch to the front page, which could easily be
    expanded to the remaining pages and developed into something more substantial.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设计可能有点独特，但为了帮助说明其可能的用途，我在首页添加了一个简单的线框草图，这个草图可以轻松扩展到剩余的页面，并发展成为更实质性的内容。
- en: To see it in action, extract a copy of the `Tutorial5` folder from the code
    download that accompanies this book, then run `index.html` in a browser, and click
    on the dots or arrow icons to the right—you will see it flip up or down, depending
    on which direction you click.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它的实际效果，请从本书附带的代码下载中提取`Tutorial5`文件夹的副本，然后在浏览器中运行`index.html`，点击右侧的圆点或箭头图标——您将看到它向上或向下翻转，具体取决于您点击的方向。
- en: Converting from existing processors
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从现有处理器转换
- en: At present, our demo is using plain CSS, and nothing is wrong with this, but
    I suspect some of you will likely be using an existing processor, such as SASS
    or less CSS. The real benefit of using PostCSS is its ability to mimic existing
    tools, without the dependencies.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的演示正在使用纯CSS，这并没有什么问题，但我怀疑你们中的一些人可能会使用现有的处理器，比如SASS或less CSS。使用PostCSS的真正好处是它能够模仿现有工具，而不需要依赖。
- en: With this in mind, there are copies of the demo, available in the code download,
    which use Less CSS and SASS. If you prefer using SASS, then go ahead and extract
    `Tutorial6A` from the code download folder; for Less, use `Tutorial6B`. The code
    can easily be compiled using the `gulpfile.js` file from `Tutorial1A` in [Chapter
    2](ch02.html "Chapter 2. Creating Variables and Mixins"), *Creating Variables
    and Mixins* (for SASS), or `Tutorial 1B` (for Less CSS, in the same chapter folder).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，代码下载中提供了使用 Less CSS 和 SASS 的演示副本。如果您更喜欢使用 SASS，请从代码下载文件夹中提取 `Tutorial6A`；对于
    Less，请使用 `Tutorial6B`。代码可以很容易地使用来自 [第 2 章](ch02.html "第 2 章。创建变量和混入") 的 `Tutorial1A`
    中的 `gulpfile.js` 文件编译（对于 SASS），或 `Tutorial 1B`（对于 Less CSS，在同一章文件夹中）。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to install the plugins listed—most of these will already be present
    from previous demos, but `gulp-sass` and `gulp-less` will need to be installed
    using NPM, in the same manner.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装列出的插件——其中大部分已经在前面的演示中存在，但 `gulp-sass` 和 `gulp-less` 需要使用 NPM 安装，方式相同。
- en: Both will produce identical results to the vanilla CSS version, once compiled,
    and the contents of the `dest` folder have been copied to the `css` sub-folder
    in the tutorial folder. With the base demo in place, we are now ready to make
    the conversion—let's make a start by installing the `postcss-nesting` plugin.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在编译后都会产生与纯 CSS 版本相同的结果，并且将 `dest` 文件夹的内容复制到教程文件夹中的 `css` 子文件夹中。在基础演示设置完成后，我们现在可以开始转换了——让我们从安装
    `postcss-nesting` 插件开始。
- en: Transitioning to using PostCSS plugins
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过渡到使用 PostCSS 插件
- en: We've seen that adapting code to use nesting is a simple principle, but the
    real art is getting the balance right, many developers fall into the trap of nesting
    everything in their code when using the technique for the first time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，将代码调整为使用嵌套是一个简单的原则，但真正的艺术在于找到平衡，许多开发者在使用该技术第一次时，会陷入将代码中所有内容都嵌套的陷阱。
- en: 'With this in mind, let''s explore how we can convert our code to using PostCSS.
    We''ll start by installing the `postcss-nesting` plugin, which will perform most
    of the work for us:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，让我们探讨如何将我们的代码转换为使用 PostCSS。我们将从安装 `postcss-nesting` 插件开始，这将为我们完成大部分工作：
- en: Fire up a Node.js command prompt, then change the working directory to our project
    area.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Node.js 命令提示符，然后更改工作目录到我们的项目区域。
- en: 'At the command prompt, enter the following command, then press *Enter*:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中，输入以下命令，然后按 *Enter*：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Node.js will go away and install the plugin—it is ready for use when we see
    something akin to this screenshot:![Transitioning to using PostCSS plugins](img/BO5194_03_03.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 将会移除并安装插件——当我们看到类似以下截图时，它就准备好使用了：![过渡到使用 PostCSS 插件](img/BO5194_03_03.jpg)
- en: With the plugin installed, we need to configure PostCSS to use it—open up a
    copy of `gulpfile.js` from the project area, ready for editing.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件安装后，我们需要配置 PostCSS 以使用它——打开项目区域中的一个 `gulpfile.js` 复制，准备编辑。
- en: 'We need to make a few changes—the first is to assign a variable that references
    the plugin. Add the highlighted line in immediately below the last variable statement:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做一些修改——首先是分配一个引用插件的变量。在最后一个变量语句下方立即添加高亮显示的行：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `autoprefixer` task needs to be altered—this time around, we will start
    with compiling our nested code and adding the appropriate vendor prefixes. Alter
    the first line of this task, as indicated:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要修改 `autoprefixer` 任务——这次，我们将从编译嵌套代码并添加适当的供应商前缀开始。按照指示修改此任务的第 1 行：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, add in the nesting configuration call:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加嵌套配置调用：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'SASS normally compresses any code on compilation by default—as we''re no longer
    using it, we need to provide an alternative. For this, we will reuse the `cssnano`
    plugin from [Chapter 2](ch02.html "Chapter 2. Creating Variables and Mixins"),
    *Creating Variables and Mixins*. Go ahead and add this at line 20:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SASS 默认情况下在编译时会压缩任何代码——由于我们不再使用它，我们需要提供一个替代方案。为此，我们将重用来自 [第 2 章](ch02.html "第
    2 章。创建变量和混入") 的 `cssnano` 插件，*创建变量和混入*。请继续在 20 行处添加以下内容：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The lint-styles task should then run once the vendor prefixes have been added;
    to make this happen, add the constraint as shown:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加供应商前缀后，lint-styles 任务应该会运行；为了实现这一点，添加如下约束：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We no longer have any need for the `sass` task, so go ahead and remove it in
    its entirety, and from the default task entry—we should be left with this:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要 `sass` 任务，所以请将其完全删除，并且从默认任务条目中，我们应该剩下以下内容：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Last, but by no means least, go ahead and switch the order of the rename task.
    Instead of running it immediately after the `autoprefixer` task, we''ll run it
    once the lint-styles task has been completed:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this stage, our gulp task file is now ready for use. We can begin to convert
    our style sheet to use PostCSS nesting as a replacement for SASS. Let's make a
    start on converting it, as part of the next exercise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get stuck, there is a completed version of `gulpfile.js` in the code
    download that accompanies this book—simply extract a copy and place it in the
    root of our project area to use it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Converting our demo to PostCSS
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Altering our code to use PostCSS is very simple. Even if it requires a few
    changes, the format does not change significantly when compared to processors
    such as SASS; let''s take a look at what is involved:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by opening a copy of `style.scss` from the `Tutorial6A` folder in
    the code download that accompanies this book—save it to the `src` folder of our
    project area. Rename it to `style.css`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On line 19, add `@nest` immediately before `&:`, as indicated—this is required
    to allow the `postcss-nesting` plugin to correctly compile each nesting statement:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On line 53, add `@nest &` immediately before `h2`, as shown:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On line 61, add `@nest` immediately before `&.`, as shown:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Repeat step 4 for lines 65, 69 and 73.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On line 119, add `@nest` immediately before `&.`, as shown:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On line 123, add `@nest` immediately before `ul`, as shown:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On line 125, add `@nest` immediately before `& li`, as shown:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On line 136, add `@nest` immediately before `&.`, as shown:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Repeat the same process for lines 150 and 155.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On lines 179, add `@nest` immediately before `&.`, as shown:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Repeat the same process for lines 183 and 187, then save the file.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our style sheet is now converted; to prove it works, we need to run it through
    PostCSS, so let's do that now as part of the next exercise.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Compiling our code
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the changes made to our code, we need to compile it—let''s go ahead and
    do that now, using the same process we saw back in [Chapter 2](ch02.html "Chapter 2. Creating
    Variables and Mixins"), *Creating Variables and Mixins*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt session, or use the one from earlier if you
    still have it open, and change the working folder to the project area.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command, then press *Enter*:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If all is well, we should see something akin to this screenshot:![Compiling
    our code](img/BO5194_03_04.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A quick peek in the `dest` folder of our project area should reveal the relevant
    compiled CSS and source map files, produced by PostCSS.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we need to extract a copy of the `Tutorial7` folder from the
    code download that accompanies this book—save this to our project area.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `dest` folder from our project area to the `css` folder
    under `Tutorial7`—if all is well, our demo should continue to work, but without
    the dependency of SASS.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note, make sure you expand the demo to the full width of the screen to view
    it properly!
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try previewing the results in a browser—if all is well, we should see the same
    results appear as before, but this time using PostCSS, and without the dependency
    on SASS. We can now apply the same techniques to any project, safe in the knowledge
    that using the postcss-nesting plugin will allow us to compile to valid CSS code—or
    will it?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the pitfalls of nesting
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It has to be said that although nesting is a simple technique to understand,
    it can be difficult to get right, as shown in our SASS version of the demo:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the pitfalls of nesting](img/BO5194_03_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'The issues we have here are twofold—the multiple levels of nesting result in
    a high level of code specificity; if we wanted to change the styling for `.nav-panel
    ul li` (the compiled version of line **125**), it would likely break the appearance
    of our front end code. To see what I mean, let''s take an example HTML page that
    any developer might create:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, before you all scream, *Yuk, I would never do that!* at me, and claim
    (quite rightly) that we should use semantic elements such as `<header>`, `<section>`,
    `<article>`, and / or `<footer>` to provide context and meaning, instead of all
    of these `<div>` statements, then stop! There is a point in producing that ugly
    mix of code. Let me explain:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The example HTML we have just seen is likely to result in this nested CSS:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Some developers might think this is perfectly acceptable—after all, they know
    no different, so why should it be an issue, right? Wrong—this code, while it may
    *technically* fit the styles in our HTML document, has several issues with it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**It is awkward to read** at best, and enough to give anyone a headache when
    trying to decipher it.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try compiling it; it will result in a lot of **duplicated parent selectors**,
    with code stretching to around 20 lines.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering performance** is likely to be poor—if for example, a tool such
    as Google''s Page Speed is installed, then it is likely to trigger the **Prioritize
    Visible Content** rule, where additional round trips are needed to render content
    on-screen above the fold.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size** is likely to be an issue—even though we live in an age of broadband
    connections, it is bad manners to take a cavalier attitude to content, and not
    create something in as small a footprint as possible.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability** will become a problem—our example code has bound styles
    too tightly, which defeats the purpose of cascading style sheets, where we should
    be able to place common styles in a parent selector and allow these to cascade
    down to children, or be overridden as required.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we get around it? The simplest answer is to be sensible about the number
    of levels we use when nesting code—some developers argue no more than four; I
    would argue from experience that two should be sufficient (which in this case
    would be `body div.content`, had we compiled our monster CSS style sheet).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing to stop us from using four levels if we absolutely have no
    other way of achieving our desired result; if we're doing this regularly, then
    we clearly need to revisit our code!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绝对没有其他方法来实现我们想要的结果，我们不妨使用四层；如果我们经常这样做，那么显然我们需要重新审视我们的代码！
- en: Taking a better approach
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用更好的方法
- en: 'If, when working on code, we are forced to regularly use nested styles that
    are more than two or three levels deep, then there are some tricks we can use
    to reduce both the CSS specificity over time, and the need to use nesting more
    than two to three levels deep. Let''s take a look at a few:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编写代码时，我们被迫经常使用两层以上（超过两层）嵌套样式，那么我们可以使用一些技巧来减少CSS特定性，并减少超过两层嵌套样式的需求。让我们看看几个例子：
- en: 'Can you give yourself the class you need? Specificity can creep in if we''re
    overriding an existing selector:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能给自己提供所需的类吗？如果我们在覆盖现有的选择器，特定性可能会渗透进来：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To avoid specificity, can a class be emitted through the use of server-side
    code or functions, which we can use to style the element instead?
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了避免特定性，能否通过使用服务器端代码或函数来发出一个类，我们可以用它来样式化元素？
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Which could output one class, or both, as desired:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能输出一个类，或者根据需要输出两个类：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The order of your style sheets can play an important role here, even though
    you might use a single class to override styles:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的样式表的顺序在这里可以发挥重要作用，即使你可能使用单个类来覆盖样式：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Your existing class may be overriding your override; both selectors have the
    same specificity, so the last rule(s) to be applied will take precedence. The
    fix for this is simply to rework the order in which your style rules are applied,
    so that overriding classes can be applied later.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现有的类可能覆盖了你的覆盖；这两个选择器具有相同的特定性，所以最后应用的规定将具有优先权。解决这个问题只是简单地重新排列你的样式规则应用的顺序，以便覆盖类可以稍后应用。
- en: Consider reducing the specificity of the element you're trying to style; can
    the element be replaced, or removed in its entirety? If, however, it's being used
    within JavaScript (or jQuery) code, then it is preferable to leave it as-is, and
    add a second class (or use an existing class already applied, if one exists).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑降低你试图样式的元素的特定性；这个元素可以被替换，或者完全移除吗？然而，如果它被用于JavaScript（或jQuery）代码中，那么最好是保持原样，并添加第二个类（或者如果存在，使用已应用的现有类）。
- en: 'Where possible, aim to use as flat a structure as possible for your code; it
    is too easy to style an element such as this:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，尽量使用尽可能扁平的结构来编写你的代码；样式化这样一个元素太容易了：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we''re styling all `h2` elements that are direct children
    of the parent `.module` class. However, this will work until we need to assign
    a different style for the `h2` element. If the markup looks similar to this example:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在为父类`.module`的直接子元素的所有`h2`元素应用样式。然而，这将在我们需要为`h2`元素分配不同样式时停止工作。如果标记看起来类似于这个例子：
- en: '[PRE26]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '…it will be difficult to apply styles easily, due to CSS specificity creeping
    in:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于CSS特定性（specificity）的渗透，将难以轻松应用样式：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To avoid this, using as flat a structure as possible is recommended—it will
    be worth the extra effort required to set it up:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免这种情况，建议尽可能使用扁平的结构——这将值得额外设置所需的努力：
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Consider using an established pattern library, or atomic design (such as the
    one at [http://patternlab.io/](http://patternlab.io/)), to help guide you through
    how a site should be built—they are likely to be built using minimal CSS specificity,
    and with hopefully little need to override existing code.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用一个已建立的样式库，或者原子设计（例如[http://patternlab.io/](http://patternlab.io/)上的），以帮助指导你如何构建网站——它们很可能是使用最小CSS特定性构建的，并且可能几乎不需要覆盖现有代码。
- en: Be careful if you decide to use cascading when applying CSS styles—if we apply
    a base style to an element (or class) that is reused multiple times, this will
    cause issues. To avoid this, try to avoid using cascading if it isn't really needed;
    consider limiting it to 2-3 levels only, to reduce risk of odd or unexpected styles
    being applied.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用CSS样式时，如果你决定使用级联（cascading），要小心——如果我们对一个被多次重用的元素（或类）应用基本样式，这将会引起问题。为了避免这种情况，尽量在不必要的情况下避免使用级联；考虑将其限制在2-3级，以减少出现奇怪或意外样式的风险。
- en: Sometimes code is outside of your control—in instances such as this, we have
    to work with it; we can either try using low specificity selectors where possible,
    or use the `!important` keyword to override the code. For now, we may have to
    leave comments in the code to explain why the selectors are set as such; in an
    ideal world, we would try to contact the authors to see if they can update or
    alter the code to remove these issues.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候代码超出了你的控制——在类似这样的情况下，我们必须与之合作；我们可以尝试在可能的情况下使用低特定性选择器，或者使用`!important`关键字来覆盖代码。目前，我们可能需要在代码中留下注释来解释为什么选择器被设置为这样的；在一个理想的世界里，我们会尝试联系作者，看看他们是否可以更新或修改代码以消除这些问题。
- en: As a last resort, if you must get into the realms of CSS specificity, then try
    to only apply a light touch, and not take the sledgehammer approach, such as using
    a selector ID or `!important`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后的手段，如果你必须进入CSS特定性的领域，那么尽量只采取轻柔的处理方式，而不是采取使用选择器ID或`!important`这样的锤子方法。
- en: 'We can try applying a single class to an existing tag, but this may not feel
    right for some; an alternative is to use two classes:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以尝试将一个类应用到现有的标签上，但这可能对某些人来说感觉不太对；一个替代方案是使用两个类：
- en: '[PRE29]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The key here, though, is to not use more than one additional class!
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，关键是要避免使用超过一个额外的类！
- en: 'Nesting styles can lead to writing overly specific selectors in our code—some
    developers discourage its use for this reason, even though nesting can help make
    our code visually easier to read and digest. Instead of using compound selectors,
    we can emulate a form of name-spacing by using the ampersand symbol:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套样式可能导致我们在代码中编写过于特定的选择器——一些开发者因为这一点而劝阻其使用，尽管嵌套可以帮助使我们的代码在视觉上更容易阅读和理解。而不是使用复合选择器，我们可以通过使用&符号来模拟一种命名空间的形式：
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '…which will compile to this:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …这将编译成以下内容：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If your style is overriding a style that is already an override—stop: Why are
    you doing this? Overriding a class or selector element can be an efficient way
    of styling, but applying a second override will only cause confusion.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的样式正在覆盖已经覆盖的样式——停止：你为什么要这样做？覆盖类或选择器元素可能是高效样式的途径，但应用第二个覆盖只会造成混淆。
- en: We've seen a number of ways of avoiding, or reducing CSS specificity issues
    that are inherent with nesting; the key message, though, is that we are not forced
    to have to nest our code, and that, to paraphrase the front-end architect Roy
    Tomeij—nested code doesn't create bad code; bad coders do!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多避免或减少嵌套中固有的CSS特定性问题的方式；然而，关键信息是，我们并非被迫必须嵌套我们的代码，而且，用前端架构师罗伊·托梅伊的话来说——嵌套的代码并不会产生糟糕的代码；糟糕的程序员才会产生糟糕的代码！
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can see the original article by Roy Tomeij at [http://www.thesassway.com/editorial/sass-doesnt-create-bad-code-bad-coders-do](http://www.thesassway.com/editorial/sass-doesnt-create-bad-code-bad-coders-do)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在罗伊·托梅伊的原始文章中看到更多内容：[http://www.thesassway.com/editorial/sass-doesnt-create-bad-code-bad-coders-do](http://www.thesassway.com/editorial/sass-doesnt-create-bad-code-bad-coders-do)
- en: 'There is one method, though, that we''ve not touched on, and for good reason:
    it''s a route many developers new to using processing will likely take for the
    first time. Intrigued? It has something to do with using conversion tools, and
    more specifically, how we use them to convert from plain CSS to code suitable
    for compiling using PostCSS.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有很好的理由，但我们还没有触及一种方法：这是许多刚开始使用处理器的开发者可能会第一次尝试的路线。好奇吗？这与使用转换工具有关，更具体地说，是我们如何使用它们将纯CSS转换为适合使用PostCSS编译的代码。
- en: Reconsidering our code
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新考虑我们的代码
- en: 'Imagine this scenario, if you will:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个场景，如果你愿意的话：
- en: You've taken over a website, and are keen to make use of PostCSS to help with
    maintaining your code. The code uses plain vanilla CSS, so as a step to converting
    it, you happen to know of a number of sites that will convert plain CSS to SASS.
    After all, there are some similarities between PostCSS and SASS code, so why not?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你接管了一个网站，并热衷于使用PostCSS来帮助维护你的代码。代码使用纯CSS，所以作为转换的一步，你碰巧知道一些网站可以将纯CSS转换为SASS。毕竟，PostCSS和SASS代码之间有一些相似之处，所以为什么不呢？
- en: You extract the results into a text file, save it, and put it through a SASS
    compilation process. Out comes some newly compiled CSS, which you drop into the
    relevant location on your server, and voilà! You have a working site that now
    uses SASS. A working site, and a perfect basis for converting to PostCSS…or is
    it?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你将结果提取到一个文本文件中，保存它，然后通过SASS编译过程。结果会生成一些新编译的CSS，你将其放入服务器上的相关位置，然后 voilà！你现在有一个使用SASS的运行网站。一个运行网站，以及转换为PostCSS的完美基础……或者不是吗？
- en: 'The short answer should be no, but the longer one is that it will depend on
    your code. Let me explain why:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答应该是没有，但更长的回答是，这取决于你的代码。让我解释一下原因：
- en: Simply pushing code through a conversion process isn't enough—granted, it will
    give you code that works, but unless it is very simple, it is likely **not to
    give code that is concise and efficient**. To see what I mean, take a close look
    at the CSS style sheet from `Tutorial5`—and specifically, the style rules for
    `.nav-panel`, from around line 132.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将代码通过转换过程是不够的——当然，它将给你一段能工作的代码，但除非它非常简单，否则它很可能**不会生成简洁高效的代码**。为了理解我的意思，请仔细查看`Tutorial5`中的CSS样式表——特别是从第132行开始的`.nav-panel`的样式规则。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For reasons of space, the style sheet is too long to print in full—I would recommend
    taking a look at the file from the code download in a text editor!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间原因，样式表太长，无法全部打印出来——我建议你用文本编辑器查看代码下载中的文件！
- en: A conversion process will have no problem processing it to produce valid SASS,
    but it won't look pretty—as an example, try copying lines 114 to 197 into the
    converter hosted at [http://css2sass.herokuapp.com/](http://css2sass.herokuapp.com/).
    Doesn't look great, does it? There is definitely room for improvement—I've already
    made some changes to the code, but we can do more; let's take a look at what can
    be done to improve the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 转换过程将没有问题处理它以生成有效的SASS，但它看起来不会很美观——作为一个例子，试着将第114行到第197行的代码复制到[http://css2sass.herokuapp.com/](http://css2sass.herokuapp.com/)提供的转换器中。看起来不错，不是吗？肯定有改进的空间——我已经对代码做了一些修改，但我们还可以做得更多；让我们看看我们可以做些什么来改进代码。
- en: Updating our code
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新我们的代码
- en: When using a CSS to SASS convertor, the one key point that should always be
    at the back of our minds is that the converted code should **not** be considered
    the final article.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CSS到SASS转换器时，我们心中始终要牢记的一个关键点是，转换后的代码**不应**被视为最终文章。
- en: 'It doesn''t matter how simple or complex your code is—it should be the first
    step in our conversion process. It''s just a matter of how little or how much
    we have to do, once the code has been through the converter! As an example, take
    a look at this block of code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你的代码多么简单或复杂——它应该是我们转换过程的第一步。这只是一个问题，即一旦代码通过转换器，我们有多少工作要做！作为一个例子，看看这段代码：
- en: '![Updating our code](img/BO5194_03_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![更新我们的代码](img/BO5194_03_06.jpg)'
- en: 'It''s a direct copy of lines 234 to 239 of the compiled version of the pen
    by Nikolay, which we used as a basis for our earlier demos. Now take a quick look
    at the equivalent code that I tweaked from the original and used in my version:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Nikolay编译版本的第234行到第239行的直接复制，我们将其作为我们早期演示的基础。现在快速看一下我从原始版本中调整并用于我版本中的等效代码：
- en: '![Updating our code](img/BO5194_03_07.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![更新我们的代码](img/BO5194_03_07.jpg)'
- en: Notice any differences? The vendor prefix version of the `transform` attribute
    has been stripped out—most modern browsers (certainly within the last year to
    eighteen months), should handle this code without the need for vendor prefixes.
    The original version also suffered from a high degree of CSS specificity—this
    will become even more apparent if the code is nested!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到任何差异了吗？`transform`属性的供应商前缀版本已经被移除——大多数现代浏览器（当然是在过去一年到十八个月之内），应该能够处理这段代码而不需要供应商前缀。原始版本也遭受了高度CSS特定性的困扰——如果代码嵌套，这一点将变得更加明显！
- en: To improve it, I've switched in `.nav-panel ul li` as a direct replacement for
    `.nav-panel ul .nav-btn`—the code is relatively simple in that it does not need
    a second class to identify elements for styling purposes. The next logical step
    is to break up the large nesting block within the source file; it is tempting
    to include a single large block, but this will be at the expense of readability,
    maintenance, and performance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进它，我已将`.nav-panel ul li`作为`.nav-panel ul .nav-btn`的直接替代——代码相对简单，因为它不需要第二个类来识别元素进行样式化。下一步合乎逻辑的步骤是将源文件中的大嵌套块拆分；包含一个单独的大块很有吸引力，但这将牺牲可读性、维护性和性能。
- en: We could potentially go even further, and consider removing the leading `.nav-panel`;
    not only will it make the code infinitely easier to read, but it will also reduce
    the issues around CSS specificity. Of course, this kind of change will depend
    on what is in your code; the point here is to examine your code thoroughly, and
    look to reduce any CSS specificity as much as possible, so that your nesting won't
    look so bad!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative means we can use though, which removes issues around
    CSS specificity—using **Block Element Modifier** notation (or **BEM** for short).
    It's a great way to systematically style elements using CSS, and it is worth taking
    time to get accustomed to how it works. Let's dive in and take a look.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Making the switch to BEM
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what is BEM, and why can it help with reducing or removing CSS specificity
    issues?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**BEM**, or **Block Element Modifier**, helps us style elements using a systematic
    naming convention, which is structured thus:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '`.block`: top-level containing the element we''re going to change'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.block__modifier`: the style assigned when the state of an element is changed'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.block__element`: an element inside a top-level container'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.block__element__modifier`: alternate representation of an element, when its
    state has been changed'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea behind this style of coding is to make it portable and easier to maintain.
    The basis for this is that, while standard, non-BEM CSS is more concise, it is
    harder to infer what each rule does. We frequently have to assign multiple classes
    to an element, which introduces a degree of CSS specificity, and reduces the reusability
    of CSS rules. Using BEM allows us to combine the constituent names into one style
    class name, and remove any concern around CSS specificity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use this concept, we can use it to write style rules such as this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will compile to the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code uses plain BEM format, but from within a processor environment
    such as SASS to construct BEM rules in PostCSS, we can use the `postcss-bem` plugin
    (available from [https://github.com/ileri/postcss-bem](https://github.com/ileri/postcss-bem))
    to produce our BEM CSS using `@-rules`. For example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this instance, `@component` signifies our Block, `@descendant` our element,
    and `@modifier` is our modifier. When compiled, our CSS would look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The beauty of using BEM is that it helps to reduce or even avoid CSS specificity
    issues—although names are longer, we can combine both element and modifier names
    into one class, instead of having to apply three or more separate classes. Granted,
    there may be instances where we might have to apply a second class, but with careful
    planning we should be able to reduce this to a minimum.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Right, onwards we go: let''s get stuck in to coding! Over the next few pages,
    we will take a look at implementing BEM styling in a simple demo, and see how
    we can use PostCSS to compile our code.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple message boxes
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our BEM demo, we're going to work through the CSS rules required to show
    some simple message boxes on screen, such as for displaying confirmation that
    a task has completed, or a warning when something isn't right.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的BEM演示，我们将通过CSS规则来展示一些简单的消息框，例如用于显示任务已完成或当某事不正确时的警告。
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The original version of this demo, by Rene Spronk, is available from [http://www.cssportal.com/blog/css-notification-boxes/](http://www.cssportal.com/blog/css-notification-boxes/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示的原版是由Rene Spronk制作的，可以从[http://www.cssportal.com/blog/css-notification-boxes/](http://www.cssportal.com/blog/css-notification-boxes/)获取。
- en: It's a simple demo, but shows off the principles behind BEM CSS perfectly—go
    ahead and extract a copy of the `Tutorial8` folder, then run `index.html` to get
    a feel for what we will be producing. This version uses standard CSS; we will
    use this as a basis for converting to using BEM.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的演示，但它完美地展示了BEM CSS背后的原理——继续提取`Tutorial8`文件夹的副本，然后运行`index.html`来感受我们将要制作的内容。这个版本使用标准CSS；我们将以此为基础将其转换为使用BEM。
- en: 'Let''s make a start:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: We'll begin by extracting a copy of the `Tutorial9` folder from the code download
    that accompanies this book—drop this into our project area.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从本书附带的代码下载中提取`Tutorial9`文件夹的副本——将其放入我们的项目区域。
- en: Next, in a new file, add the following CSS statements starting at line 1, and
    leaving a one-line gap between each—they should be fairly self-explanatory, but
    we will go through each block in turn.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在一个新文件中，从第1行开始添加以下CSS语句，并在每个语句之间留一个空行——它们应该是相当自解释的，但我们将依次通过每个块。
- en: 'We kick off with the core styles for each dialog—this is a basis style for
    each dialog box:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从每个对话框的核心样式开始——这是每个对话框的基础样式：
- en: '[PRE36]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next up comes a simple style for each `<span>` element—this turns the lead-in
    caption for each dialog to uppercase and sets it in bold text:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是每个`<span>`元素的简单样式——这会将每个对话框的引导标题转换为大写并设置为粗体文本：
- en: '[PRE37]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We now need to add our block element—it''s the opening line that forms the
    basis for our styling:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要添加我们的块元素——这是构成我们样式的起始行：
- en: '[PRE38]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next up comes the Element part of our style rule. These rules need to be added
    as nested (that is, indented) rules immediately underneath—using the PostCSS plugin,
    we add it in as a `@descendent` of our `@component`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是样式规则中的Element部分。这些规则需要作为嵌套（即缩进）规则立即添加到下面——使用PostCSS插件，我们将它添加为`@component`的`@descendent`：
- en: '[PRE39]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Up next comes the first of our status messages—we kick off with styling the
    Error message first; the main rule adds an error icon and styles the border. The
    `:hover` pseudo-element reduces the opacity when we hover over the box:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的第一个状态消息——我们首先开始为错误消息添加样式；主要规则添加了一个错误图标并设置了边框样式。`:hover`伪元素在鼠标悬停在框上时减少不透明度：
- en: '[PRE40]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is swiftly followed by styling for the Success message:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这迅速被成功消息的样式所跟随：
- en: '[PRE41]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can''t forget the obligatory Warning message, so here''s the style rule
    for that status:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能忘记必选的警告消息，所以这里是该状态样式的规则：
- en: '[PRE42]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Last but by no means least, here''s the final one, which is Notice; it includes
    the closing bracket for the BEM nesting:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，这是最后一个，即通知；它包含了BEM嵌套的闭合括号：
- en: '[PRE43]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save the file as `style.scss` into the `src` folder of our top-level project
    area (and not into the `Tutorial8` folder!).
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为`style.scss`到我们顶级项目区域的`src`文件夹中（而不是`Tutorial8`文件夹中！）。
- en: Our simple demo isn't going to set the world alight in terms of styling. If
    we were to preview it now, the results will of course not look great; let's fix
    that by setting up the compilation and linting tasks within PostCSS.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个简单的演示在样式方面不会让世界变得光明；如果我们现在预览它，结果当然不会很好看；让我们通过在PostCSS中设置编译和linting任务来修复它。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are a SASS user, then you can see a version of this code suitable for
    that processor on GitHub—the code is available at: [https://gist.github.com/alibby251/45eab822a6a619467279](https://gist.github.com/alibby251/45eab822a6a619467279).
    Note how similar the results are when you compare the compiled version with the
    version we''ll get in the next exercise!'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用SASS，那么你可以在GitHub上看到适合该处理器的代码版本——代码可在：[https://gist.github.com/alibby251/45eab822a6a619467279](https://gist.github.com/alibby251/45eab822a6a619467279)找到。注意当你比较编译版本和我们在下一个练习中将得到的版本时，结果是多么相似！
- en: Compiling and linting our code
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和linting我们的代码
- en: Our code is in place, but the boxes won't look particularly appetizing—most
    of the styles are still written using PostCSS `@-rules`. We can fix that by compiling
    the code, so let's dive in and take a look at installing support for BEM.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码已经就位，但盒子看起来并不特别吸引人——大多数样式仍然使用PostCSS `@-rules`编写。我们可以通过编译代码来修复这个问题，所以让我们深入了解一下如何安装BEM支持。
- en: Installing BEM support
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装BEM支持
- en: Setting up BEM support in PostCSS is a cinch—we can make use of two plugins
    to compile and lint our code. The plugins we need for this task are `postcss-bem`
    (available from [https://github.com/ileri/postcss-bem](https://github.com/ileri/postcss-bem)),
    and `postcss-bem-linter` (available from [https://github.com/postcss/postcss-bem-linter](https://github.com/postcss/postcss-bem-linter)).
    Both can be installed using the same process through Node.js.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostCSS中设置BEM支持非常简单——我们可以使用两个插件来编译和检查我们的代码。我们需要为此任务的两个插件是`postcss-bem`（可在[https://github.com/ileri/postcss-bem](https://github.com/ileri/postcss-bem)获取），以及`postcss-bem-linter`（可在[https://github.com/postcss/postcss-bem-linter](https://github.com/postcss/postcss-bem-linter)获取）。这两个插件都可以通过Node.js使用相同的过程安装。
- en: 'Hopefully the process will be familiar by now, so without further ado, let''s
    make a start:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在为止，这个过程已经变得熟悉了，所以我们不再拖延，现在就开始吧：
- en: We'll begin by firing up a Node.js command prompt, and navigating to our working
    folder.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先启动一个Node.js命令提示符，并导航到我们的工作文件夹。
- en: 'At the command prompt, enter this command then press *Enter*:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符下，输入以下命令然后按*Enter*：
- en: '[PRE44]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Node.js will install each of the elements required; if all is well, we should
    see this result, to indicate a successful installation:![Installing BEM support](img/BO5194_03_08.jpg)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js将安装所需的每个元素；如果一切顺利，我们应该看到这个结果，以表明安装成功：![安装BEM支持](img/BO5194_03_08.jpg)
- en: 'Repeat the same process for `postcss-bem-linter`, using this command:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`postcss-bem-linter`重复相同的步骤，使用以下命令：
- en: '[PRE45]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![Installing BEM support](img/BO5194_03_09.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![安装BEM支持](img/BO5194_03_09.jpg)'
- en: Keep the command prompt session open, but minimized. We're going to make use
    of it again in a moment!
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持命令提示符会话开启，但最小化。我们很快就会再次使用它！
- en: 'Now that the plugin is installed, we can go ahead and add support to our gulp
    task file, and begin to parse our code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已经安装好了，我们可以继续添加对gulp任务文件的支持，并开始解析我们的代码：
- en: First, go ahead and remove the existing `gulpfile.js` file at the root of our
    project area.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请先删除我们项目区域根目录下的现有`gulpfile.js`文件。
- en: 'In a new file, add the following lines and save it as `gulpfile.js`, at the
    root of our project area. We start with setting a number of variables that call
    each of the plugins:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下行并将其保存为`gulpfile.js`，位于我们项目区域的根目录。我们首先设置一些变量，这些变量调用每个插件：
- en: '[PRE46]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The first task in the file checks the code for consistency with BEM standards,
    and displays any errors on-screen:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件中的第一个任务检查代码与BEM标准的兼容性，并在屏幕上显示任何错误：
- en: '[PRE47]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second task in the file compiles the BEM code to valid CSS:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件中的第二个任务将BEM代码编译为有效的CSS：
- en: '[PRE48]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This task is the default that is called when we run gulp from the command line;
    it calls each of the tasks in turn:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个任务是在我们从命令行运行gulp时默认调用的任务；它依次调用每个任务：
- en: '[PRE49]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We finish the `gulpfile.js` with a watch facility, to kick in and compile our
    code when any changes are made to it:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`gulpfile.js`中添加一个监视功能，以便在代码有任何更改时启动并编译我们的代码：
- en: '[PRE50]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''re going to replace the `package.json` file too—add these lines to a new
    file, and save it to the root of the project area. These simply tell gulp which
    versions of our plugins to use when compiling the code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将替换`package.json`文件——将这些行添加到新文件中，并将其保存到项目区域的根目录。这些行简单地告诉gulp在编译代码时使用我们插件的哪个版本：
- en: '[PRE51]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: From the code download that accompanies this book, go ahead and extract a copy
    of `style.css` from the `css – completed version` folder under `Tutorial9`—save
    this to the `src` folder under our project area.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码下载中，请从`Tutorial9`下的`css – completed version`文件夹中提取`style.css`的副本——将其保存到我们项目区域的`src`文件夹下。
- en: 'Revert back to the Node.js command prompt session we had before, then at the
    prompt, enter this command and press *Enter*:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们之前的Node.js命令提示符会话，然后在提示符下，输入以下命令并按*Enter*：
- en: '[PRE52]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If all is well, the code will be checked, and the results displayed on screen.
    You may see errors appear, such as those shown in this screenshot. If they do,
    they can be ignored for now (we will explore this in more detail later):![Installing
    BEM support](img/BO5194_03_10.jpg)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，代码将被检查，结果将在屏幕上显示。你可能会看到错误出现，例如这个屏幕截图所示。如果出现，现在可以忽略它们（我们将在稍后更详细地探讨这个问题）：![安装BEM支持](img/BO5194_03_10.jpg)
- en: Go ahead and copy the contents of the `dest` folder into the `css` folder underneath
    `Tutorial9`—if all is well, we should see something akin to this screenshot when
    previewing the results in a browser:![Installing BEM support](img/BO5194_03_11.jpg)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，把`dest`文件夹的内容复制到`Tutorial9`下的`css`文件夹里——如果一切顺利，我们在浏览器中预览结果时应该能看到类似这样的截图：![安装BEM支持](img/BO5194_03_11.jpg)
- en: Our simple demo shows some useful message boxes that we can use as a basis for
    something more complex; it illustrates perfectly how we can use BEM to style our
    code, while keeping issues around CSS specificity at bay. We've covered a few
    useful techniques throughout this exercise, so let's take a moment to explore
    them in more detail.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的演示展示了我们可以用作更复杂基础的一些有用的消息框；它完美地说明了我们如何使用BEM来样式化我们的代码，同时避免CSS特定性问题。我们在整个练习中介绍了一些有用的技术，所以让我们花点时间更详细地探索它们。
- en: Exploring our changes in more detail
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更详细地探索我们的更改
- en: It is worth taking time to really get familiar with BEM styling principles.
    This is one of those areas where not spending time can easily dissuade you from
    using this technique; the principles are easy to understand but can take time
    to implement! Let's take a look at our code in more detail.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间真正熟悉BEM样式原则是值得的。这是那些不花时间可能会轻易让你放弃使用这种技术的领域之一；原则容易理解，但实施起来可能需要时间！让我们更详细地看看我们的代码。
- en: The key principle around BEM, when using the PostCSS plugin, is that of nesting—in
    this instance, we create our core component content, which results in an empty
    style rule at the top of our style sheet. Indented to the next level is our `@descendant`—this
    indicates that our message boxes are being styled as alerts. We then use a number
    of `@modifiers` to style each type of alert, such as success, warning, error,
    or notice (that is, information). This includes a separate style rule to cover
    each instance of the hover pseudo-element used in our code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PostCSS插件时，BEM的关键原则是嵌套——在这个例子中，我们创建核心组件内容，这导致我们的样式表顶部出现一个空的样式规则。缩进到下一级的是我们的`@descendant`——这表示我们的消息框被样式化为警告。然后我们使用多个`@modifiers`来样式化每种类型的警告，如成功、警告、错误或通知（即信息）。这包括一个单独的样式规则来覆盖我们代码中使用的每个hover伪元素的实例。
- en: What does this mean for us? It means we have to not just consider each element
    (for instance, a message box) as a single entity to which we simply apply lots
    of classes; instead, we should consider the constituent parts of each element
    and apply a single class to each. Hold on, does that not mean we still have three
    classes in use (as we might have here)?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们意味着什么？这意味着我们不仅要将每个元素（例如，消息框）视为一个单一实体，并简单地应用很多类；相反，我们应该考虑每个元素的组成部分，并为每个部分应用一个单独的类。等等，这不意味着我们仍然在使用三个类（就像我们在这里可能做的那样）吗？
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To learn more about BEM naming conventions, take a look at the useful article
    posted at [https://en.bem.info/tools/bem/bem-naming/](https://en.bem.info/tools/bem/bem-naming/).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于BEM命名约定的信息，请查看在[https://en.bem.info/tools/bem/bem-naming/](https://en.bem.info/tools/bem/bem-naming/)发布的有用文章。
- en: 'Well, the answer is yes, and no: the trick here is that PostCSS will combine
    each nested style into valid CSS; for example, this extract (adapted from our
    demo):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，答案是是，也不是：这里的技巧是PostCSS会将每个嵌套样式组合成有效的CSS；例如，这个提取（改编自我们的演示）：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When compiled, this will appear as this CSS:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，这将显示为以下CSS：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The sharp-eyed among you will have spotted that we still have errors being
    generated when our code is compiled:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 眼尖的你们中的一些人可能已经注意到，当我们的代码编译时仍然会生成错误：
- en: '![Exploring our changes in more detail](img/BO5194_03_12.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![更详细地探索我们的更改](img/BO5194_03_12.jpg)'
- en: It's always disconcerting to see errors, but there are valid reasons for them.
    We can safely ignore the two deprecation warnings (these should be fixed in a
    future version), but the two errors are of more concern.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 看到错误总是让人不安，但它们有合理的理由。我们可以安全地忽略两个弃用警告（这些应该在未来的版本中修复），但这两个错误更令人关注。
- en: Fixing our errors
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复我们的错误
- en: 'The two errors are being caused by `postcss-bem-linter`, which is not recognizing
    the two styles as valid BEM notation. This raises a question: can we alter our
    code to remove the issues?'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个错误是由`postcss-bem-linter`引起的，它没有将这两种样式识别为有效的BEM符号。这引发了一个问题：我们能否修改我们的代码来消除这些问题？
- en: To answer this, we would need to weigh up how much code is affected against
    the time and effort required to alter it. In our demo, there is very little code
    affected; to resolve it, we would need to alter the `.dlgBox` and `span` styles
    to equivalent BEM naming.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们需要权衡受影响的代码量与修改它所需的时间和精力。在我们的演示中，受影响的代码非常少；要解决这个问题，我们需要修改`.dlgBox`和`span`样式为等效的BEM命名。
- en: 'Is this worth the effort? In a small demo such as ours, it is likely that the
    answer is no, for a larger demo, we would look to alter these two styles. Instead,
    we can add a simple directive at line 48, thus:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这值得付出努力吗？在我们的这个小演示中，答案很可能是“不”，对于更大的演示，我们可能会考虑改变这两种样式。相反，我们可以在第48行添加一个简单的指令，如下所示：
- en: '![Fixing our errors](img/BO5194_03_13.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![修复我们的错误](img/BO5194_03_13.jpg)'
- en: 'When the code is recompiled, the errors are removed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码重新编译时，错误会被移除：
- en: '![Fixing our errors](img/BO5194_03_14.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![修复我们的错误](img/BO5194_03_14.jpg)'
- en: Purists may say this is cheating. It's true, our code is still *technically*
    not all BEM. In defense though, it's up to each developer to make that decision;
    there may be elements that have to remain as standard CSS, which we can't convert.
    In this case, it may be sensible to import these styles using the PostCSS import
    plugin—we will explore using this more in [Chapter 10](ch10.html "Chapter 10. Building
    a Custom Processor"), *Building a Custom Preprocessor*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹主义者可能会说这是作弊。确实，我们的代码在技术上仍然不是全部的BEM。然而，尽管如此，决定权在每位开发者手中；可能有一些元素必须保持为标准CSS，我们无法转换。在这种情况下，使用PostCSS导入插件导入这些样式可能是明智的——我们将在第10章“构建自定义处理器”中进一步探讨使用这种方法，[第10章](ch10.html
    "第10章。构建自定义预处理器")。
- en: It's worth noting that the `postcss-bem-linter plugin` will not display the
    results of any errors by itself—for this, we need to use a plugin such as `postcss-reporter`
    (available at [https://github.com/postcss/postcss-reporter](https://github.com/postcss/postcss-reporter),
    for command line), or postcss-browser-reporter (from [https://github.com/postcss/postcss-browser-reporter](https://github.com/postcss/postcss-browser-reporter),
    displays content in the browser window). Both have a number of options that are
    worth investigating to help fine-tune what is displayed when the code is processed
    through PostCSS.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`postcss-bem-linter插件`本身不会显示任何错误的结果——为了做到这一点，我们需要使用像`postcss-reporter`（可在[https://github.com/postcss/postcss-reporter](https://github.com/postcss/postcss-reporter)找到，适用于命令行）或`postcss-browser-reporter`（来自[https://github.com/postcss/postcss-browser-reporter](https://github.com/postcss/postcss-browser-reporter)）这样的插件，后者在浏览器窗口中显示内容）。两者都有许多值得调查的选项，可以帮助我们微调通过PostCSS处理代码时显示的内容。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the years, developers have had to frequently write code that duplicates
    all or part of a selector—a perfect example is styling lists or navigation items.
    It's a real pain to have to write so much extra code; instead we can use nesting
    principles to help remove some of this code. We've covered a number of techniques
    around nesting in PostCSS throughout this chapter, so let's take a moment to review
    what we've learned.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，开发者不得不经常编写重复选择器全部或部分代码的代码——一个完美的例子是样式化列表或导航项。编写这么多额外代码真的很痛苦；相反，我们可以使用嵌套原则来帮助移除一些这些代码。我们在本章中已经介绍了PostCSS中关于嵌套的多种技术，所以让我们花点时间回顾一下我们学到了什么。
- en: We kicked off with an introduction to nesting, to help bring us up to speed,
    before launching into using the `postcss-nesting` plugin to create nested styles
    within PostCSS. We then moved on to creating our nesting demo. We began with preparing
    a plain vanilla CSS version, before taking a look at converting to existing processors
    such as SASS.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从嵌套的介绍开始，帮助我们跟上进度，然后转向使用`postcss-nesting`插件在PostCSS中创建嵌套样式。然后我们继续创建我们的嵌套演示。我们开始准备一个纯CSS版本，然后查看将其转换为现有的处理器，如SASS。
- en: Moving on, we then took a look at converting our code using the `postcss-nesting`
    plugin, before exploring some of the pitfalls that are associated with nesting,
    and some of the tips and tricks we can use to reduce CSS specificity, one of the
    key issues associated with nesting.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`postcss-nesting`插件转换我们的代码，然后探讨了与嵌套相关的一些陷阱，以及我们可以使用的技巧和窍门来减少CSS特定性，这是与嵌套相关的一个关键问题。
- en: We then rounded out the chapter with a look at BEM, and how it can be used in
    PostCSS. We covered some of the basic principles of this methodology, before applying
    it to a simple example. We also learned why it won't always work for every instance;
    for those where it is suitable, we took a brief look at how we can set PostCSS
    to automatically lint our BEM code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节的最后部分探讨了BEM（块、元素、修饰符）及其在PostCSS中的应用。我们介绍了这一方法的基本原则，并在一个简单示例中应用了它们。我们还了解到，这种方法并不总是适用于所有情况；对于适用的情况，我们简要地探讨了如何设置PostCSS来自动检查我们的BEM代码。
- en: 'Phew, a real whistle stop tour there! Hang on to your hats though, as it won''t
    stop: in our next chapter, we''re going to take a look at writing media queries,
    and how PostCSS can help with compiling them into valid CSS.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，这真是一场真正的快速浏览！不过，请系好你的帽子，因为旅程不会就此结束：在下一章中，我们将探讨编写媒体查询的方法，以及PostCSS如何帮助将这些查询编译成有效的CSS。
