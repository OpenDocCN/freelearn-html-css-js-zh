- en: Chapter 3. Nesting Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have spent any time developing with preprocessors, then you will likely
    have come across nested properties—instead of writing multiple style rules with
    repeated references to the same elements, we can use nesting to create concise
    style rules that compile to valid CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll delve into using the power of nesting, show you how
    you can transition from using preprocessors such as SASS or Less, and explore
    some of the tricks we can use that are not available with preprocessors such as
    SASS:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the use of BEM (Block, Element, Modifier) or standard nesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating nested rules and BEM equivalents using existing preprocessors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning to using PostCSS plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the pitfalls of nesting and how we can improve our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's make a start…!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing nesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of nesting is nothing new when using processors such as Less CSS
    or SASS; it's a useful technique to help reduce the amount of code we need to
    write, and to organize code in a more human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: The flipside of the coin is that it is frequently abused—when using processors
    for the first time, many developers fall into the trap of thinking that everything
    should be nested. One can get away with it if the code is very simple; it is more
    likely to result in fragile code that is difficult to read and easily broken with
    simple changes to one or more styles in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If nesting is done correctly, then it can be very effective; it helps avoid
    the need to repeat parent selectors, and allows us to group together rules that
    apply to the same selector, together. To see what is meant by this, take a look
    at this simple example for SASS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is compiled using a GUI application or via the command line, it results
    in these styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The great thing about this code is that we've not tried to cram in every single
    rule that applies to the same parent selector, or a descendant; this is something
    we should consider when working with nesting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how, in our SASS example, the nesting was at the end of the code? It's
    considered good practice to include nested statements at the end, before the closing
    bracket.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers counsel against using nesting though, as it causes real issues
    for elements that have been styled in specific contexts; it becomes harder to
    change the code if we need to change the style. We will explore more of the reasons
    why nesting is fraught with risks later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leaving aside the risks of nesting for the moment, we can use the same basic
    principle of nesting when using PostCSS—for this, we need to use the `postcss-nesting`
    plugin by Jonathan Neal, which is available from [https://github.com/jonathantneal/postcss-nesting](https://github.com/jonathantneal/postcss-nesting).
    To give you a flavor of what nesting looks like in PostCSS, take a look at this
    screenshot—this is an online playground provided by the author for trialing nested
    statements, where we can see the results automatically on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing nesting](img/BO5194_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The key line is on the left, fifth from the bottom: the `postcss-nesting` plugin
    uses `@nest &` as the placeholder for nesting code.'
  prefs: []
  type: TYPE_NORMAL
- en: To help illustrate how the `postcss-nesting` plugin works, we will use it to
    create a somewhat unique navigation system. Our navigation will use a mix of jQuery
    and CSS to style and flip some demo pages, with the animation effects provided
    by CSS3 styling. Intrigued? Let's dive in and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've always had a desire to do something a little different; doing the same
    thing as everyone else becomes so passé! With this in mind, when researching for
    this book, I came across an intriguing demo by Nikolay Talanov, where pages are
    flipped over from one to the next, using either CSS3 animation if supported, or
    falling back to standard jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see the original pen demo at [http://codepen.io/suez/pen/LCHlA](http://codepen.io/suez/pen/LCHlA).
  prefs: []
  type: TYPE_NORMAL
- en: This has provided a perfect base for this chapter. For the purpose of the demos,
    I've stripped back the vendor prefixes (as these will be covered by `Autoprefixer`),
    tweaked the design of the first page, and switched to just using nesting throughout.
    The jQuery fall-back code has also been removed, as most modern browsers will
    support the animations with little difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our demo, we will have four pages—the navigation will flip between each
    page, using standard CSS3 animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing our demo](img/BO5194_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The design may be a little unique, but to help illustrate how it could be used,
    I've added a simple wireframe sketch to the front page, which could easily be
    expanded to the remaining pages and developed into something more substantial.
  prefs: []
  type: TYPE_NORMAL
- en: To see it in action, extract a copy of the `Tutorial5` folder from the code
    download that accompanies this book, then run `index.html` in a browser, and click
    on the dots or arrow icons to the right—you will see it flip up or down, depending
    on which direction you click.
  prefs: []
  type: TYPE_NORMAL
- en: Converting from existing processors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At present, our demo is using plain CSS, and nothing is wrong with this, but
    I suspect some of you will likely be using an existing processor, such as SASS
    or less CSS. The real benefit of using PostCSS is its ability to mimic existing
    tools, without the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, there are copies of the demo, available in the code download,
    which use Less CSS and SASS. If you prefer using SASS, then go ahead and extract
    `Tutorial6A` from the code download folder; for Less, use `Tutorial6B`. The code
    can easily be compiled using the `gulpfile.js` file from `Tutorial1A` in [Chapter
    2](ch02.html "Chapter 2. Creating Variables and Mixins"), *Creating Variables
    and Mixins* (for SASS), or `Tutorial 1B` (for Less CSS, in the same chapter folder).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to install the plugins listed—most of these will already be present
    from previous demos, but `gulp-sass` and `gulp-less` will need to be installed
    using NPM, in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: Both will produce identical results to the vanilla CSS version, once compiled,
    and the contents of the `dest` folder have been copied to the `css` sub-folder
    in the tutorial folder. With the base demo in place, we are now ready to make
    the conversion—let's make a start by installing the `postcss-nesting` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to using PostCSS plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen that adapting code to use nesting is a simple principle, but the
    real art is getting the balance right, many developers fall into the trap of nesting
    everything in their code when using the technique for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let''s explore how we can convert our code to using PostCSS.
    We''ll start by installing the `postcss-nesting` plugin, which will perform most
    of the work for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt, then change the working directory to our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command prompt, enter the following command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Node.js will go away and install the plugin—it is ready for use when we see
    something akin to this screenshot:![Transitioning to using PostCSS plugins](img/BO5194_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the plugin installed, we need to configure PostCSS to use it—open up a
    copy of `gulpfile.js` from the project area, ready for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to make a few changes—the first is to assign a variable that references
    the plugin. Add the highlighted line in immediately below the last variable statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `autoprefixer` task needs to be altered—this time around, we will start
    with compiling our nested code and adding the appropriate vendor prefixes. Alter
    the first line of this task, as indicated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add in the nesting configuration call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SASS normally compresses any code on compilation by default—as we''re no longer
    using it, we need to provide an alternative. For this, we will reuse the `cssnano`
    plugin from [Chapter 2](ch02.html "Chapter 2. Creating Variables and Mixins"),
    *Creating Variables and Mixins*. Go ahead and add this at line 20:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The lint-styles task should then run once the vendor prefixes have been added;
    to make this happen, add the constraint as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We no longer have any need for the `sass` task, so go ahead and remove it in
    its entirety, and from the default task entry—we should be left with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last, but by no means least, go ahead and switch the order of the rename task.
    Instead of running it immediately after the `autoprefixer` task, we''ll run it
    once the lint-styles task has been completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this stage, our gulp task file is now ready for use. We can begin to convert
    our style sheet to use PostCSS nesting as a replacement for SASS. Let's make a
    start on converting it, as part of the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get stuck, there is a completed version of `gulpfile.js` in the code
    download that accompanies this book—simply extract a copy and place it in the
    root of our project area to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Converting our demo to PostCSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Altering our code to use PostCSS is very simple. Even if it requires a few
    changes, the format does not change significantly when compared to processors
    such as SASS; let''s take a look at what is involved:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by opening a copy of `style.scss` from the `Tutorial6A` folder in
    the code download that accompanies this book—save it to the `src` folder of our
    project area. Rename it to `style.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On line 19, add `@nest` immediately before `&:`, as indicated—this is required
    to allow the `postcss-nesting` plugin to correctly compile each nesting statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On line 53, add `@nest &` immediately before `h2`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On line 61, add `@nest` immediately before `&.`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat step 4 for lines 65, 69 and 73.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On line 119, add `@nest` immediately before `&.`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On line 123, add `@nest` immediately before `ul`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On line 125, add `@nest` immediately before `& li`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On line 136, add `@nest` immediately before `&.`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat the same process for lines 150 and 155.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On lines 179, add `@nest` immediately before `&.`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat the same process for lines 183 and 187, then save the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our style sheet is now converted; to prove it works, we need to run it through
    PostCSS, so let's do that now as part of the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the changes made to our code, we need to compile it—let''s go ahead and
    do that now, using the same process we saw back in [Chapter 2](ch02.html "Chapter 2. Creating
    Variables and Mixins"), *Creating Variables and Mixins*:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt session, or use the one from earlier if you
    still have it open, and change the working folder to the project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all is well, we should see something akin to this screenshot:![Compiling
    our code](img/BO5194_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A quick peek in the `dest` folder of our project area should reveal the relevant
    compiled CSS and source map files, produced by PostCSS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we need to extract a copy of the `Tutorial7` folder from the
    code download that accompanies this book—save this to our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `dest` folder from our project area to the `css` folder
    under `Tutorial7`—if all is well, our demo should continue to work, but without
    the dependency of SASS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note, make sure you expand the demo to the full width of the screen to view
    it properly!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try previewing the results in a browser—if all is well, we should see the same
    results appear as before, but this time using PostCSS, and without the dependency
    on SASS. We can now apply the same techniques to any project, safe in the knowledge
    that using the postcss-nesting plugin will allow us to compile to valid CSS code—or
    will it?
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the pitfalls of nesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It has to be said that although nesting is a simple technique to understand,
    it can be difficult to get right, as shown in our SASS version of the demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the pitfalls of nesting](img/BO5194_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The issues we have here are twofold—the multiple levels of nesting result in
    a high level of code specificity; if we wanted to change the styling for `.nav-panel
    ul li` (the compiled version of line **125**), it would likely break the appearance
    of our front end code. To see what I mean, let''s take an example HTML page that
    any developer might create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before you all scream, *Yuk, I would never do that!* at me, and claim
    (quite rightly) that we should use semantic elements such as `<header>`, `<section>`,
    `<article>`, and / or `<footer>` to provide context and meaning, instead of all
    of these `<div>` statements, then stop! There is a point in producing that ugly
    mix of code. Let me explain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example HTML we have just seen is likely to result in this nested CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Some developers might think this is perfectly acceptable—after all, they know
    no different, so why should it be an issue, right? Wrong—this code, while it may
    *technically* fit the styles in our HTML document, has several issues with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It is awkward to read** at best, and enough to give anyone a headache when
    trying to decipher it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try compiling it; it will result in a lot of **duplicated parent selectors**,
    with code stretching to around 20 lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering performance** is likely to be poor—if for example, a tool such
    as Google''s Page Speed is installed, then it is likely to trigger the **Prioritize
    Visible Content** rule, where additional round trips are needed to render content
    on-screen above the fold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size** is likely to be an issue—even though we live in an age of broadband
    connections, it is bad manners to take a cavalier attitude to content, and not
    create something in as small a footprint as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability** will become a problem—our example code has bound styles
    too tightly, which defeats the purpose of cascading style sheets, where we should
    be able to place common styles in a parent selector and allow these to cascade
    down to children, or be overridden as required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we get around it? The simplest answer is to be sensible about the number
    of levels we use when nesting code—some developers argue no more than four; I
    would argue from experience that two should be sufficient (which in this case
    would be `body div.content`, had we compiled our monster CSS style sheet).
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing to stop us from using four levels if we absolutely have no
    other way of achieving our desired result; if we're doing this regularly, then
    we clearly need to revisit our code!
  prefs: []
  type: TYPE_NORMAL
- en: Taking a better approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If, when working on code, we are forced to regularly use nested styles that
    are more than two or three levels deep, then there are some tricks we can use
    to reduce both the CSS specificity over time, and the need to use nesting more
    than two to three levels deep. Let''s take a look at a few:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you give yourself the class you need? Specificity can creep in if we''re
    overriding an existing selector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To avoid specificity, can a class be emitted through the use of server-side
    code or functions, which we can use to style the element instead?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Which could output one class, or both, as desired:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The order of your style sheets can play an important role here, even though
    you might use a single class to override styles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your existing class may be overriding your override; both selectors have the
    same specificity, so the last rule(s) to be applied will take precedence. The
    fix for this is simply to rework the order in which your style rules are applied,
    so that overriding classes can be applied later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consider reducing the specificity of the element you're trying to style; can
    the element be replaced, or removed in its entirety? If, however, it's being used
    within JavaScript (or jQuery) code, then it is preferable to leave it as-is, and
    add a second class (or use an existing class already applied, if one exists).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Where possible, aim to use as flat a structure as possible for your code; it
    is too easy to style an element such as this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, we''re styling all `h2` elements that are direct children
    of the parent `.module` class. However, this will work until we need to assign
    a different style for the `h2` element. If the markup looks similar to this example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '…it will be difficult to apply styles easily, due to CSS specificity creeping
    in:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To avoid this, using as flat a structure as possible is recommended—it will
    be worth the extra effort required to set it up:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Consider using an established pattern library, or atomic design (such as the
    one at [http://patternlab.io/](http://patternlab.io/)), to help guide you through
    how a site should be built—they are likely to be built using minimal CSS specificity,
    and with hopefully little need to override existing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful if you decide to use cascading when applying CSS styles—if we apply
    a base style to an element (or class) that is reused multiple times, this will
    cause issues. To avoid this, try to avoid using cascading if it isn't really needed;
    consider limiting it to 2-3 levels only, to reduce risk of odd or unexpected styles
    being applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes code is outside of your control—in instances such as this, we have
    to work with it; we can either try using low specificity selectors where possible,
    or use the `!important` keyword to override the code. For now, we may have to
    leave comments in the code to explain why the selectors are set as such; in an
    ideal world, we would try to contact the authors to see if they can update or
    alter the code to remove these issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a last resort, if you must get into the realms of CSS specificity, then try
    to only apply a light touch, and not take the sledgehammer approach, such as using
    a selector ID or `!important`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can try applying a single class to an existing tag, but this may not feel
    right for some; an alternative is to use two classes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The key here, though, is to not use more than one additional class!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Nesting styles can lead to writing overly specific selectors in our code—some
    developers discourage its use for this reason, even though nesting can help make
    our code visually easier to read and digest. Instead of using compound selectors,
    we can emulate a form of name-spacing by using the ampersand symbol:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '…which will compile to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your style is overriding a style that is already an override—stop: Why are
    you doing this? Overriding a class or selector element can be an efficient way
    of styling, but applying a second override will only cause confusion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've seen a number of ways of avoiding, or reducing CSS specificity issues
    that are inherent with nesting; the key message, though, is that we are not forced
    to have to nest our code, and that, to paraphrase the front-end architect Roy
    Tomeij—nested code doesn't create bad code; bad coders do!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see the original article by Roy Tomeij at [http://www.thesassway.com/editorial/sass-doesnt-create-bad-code-bad-coders-do](http://www.thesassway.com/editorial/sass-doesnt-create-bad-code-bad-coders-do)
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one method, though, that we''ve not touched on, and for good reason:
    it''s a route many developers new to using processing will likely take for the
    first time. Intrigued? It has something to do with using conversion tools, and
    more specifically, how we use them to convert from plain CSS to code suitable
    for compiling using PostCSS.'
  prefs: []
  type: TYPE_NORMAL
- en: Reconsidering our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine this scenario, if you will:'
  prefs: []
  type: TYPE_NORMAL
- en: You've taken over a website, and are keen to make use of PostCSS to help with
    maintaining your code. The code uses plain vanilla CSS, so as a step to converting
    it, you happen to know of a number of sites that will convert plain CSS to SASS.
    After all, there are some similarities between PostCSS and SASS code, so why not?
  prefs: []
  type: TYPE_NORMAL
- en: You extract the results into a text file, save it, and put it through a SASS
    compilation process. Out comes some newly compiled CSS, which you drop into the
    relevant location on your server, and voilà! You have a working site that now
    uses SASS. A working site, and a perfect basis for converting to PostCSS…or is
    it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer should be no, but the longer one is that it will depend on
    your code. Let me explain why:'
  prefs: []
  type: TYPE_NORMAL
- en: Simply pushing code through a conversion process isn't enough—granted, it will
    give you code that works, but unless it is very simple, it is likely **not to
    give code that is concise and efficient**. To see what I mean, take a close look
    at the CSS style sheet from `Tutorial5`—and specifically, the style rules for
    `.nav-panel`, from around line 132.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For reasons of space, the style sheet is too long to print in full—I would recommend
    taking a look at the file from the code download in a text editor!
  prefs: []
  type: TYPE_NORMAL
- en: A conversion process will have no problem processing it to produce valid SASS,
    but it won't look pretty—as an example, try copying lines 114 to 197 into the
    converter hosted at [http://css2sass.herokuapp.com/](http://css2sass.herokuapp.com/).
    Doesn't look great, does it? There is definitely room for improvement—I've already
    made some changes to the code, but we can do more; let's take a look at what can
    be done to improve the code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using a CSS to SASS convertor, the one key point that should always be
    at the back of our minds is that the converted code should **not** be considered
    the final article.
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t matter how simple or complex your code is—it should be the first
    step in our conversion process. It''s just a matter of how little or how much
    we have to do, once the code has been through the converter! As an example, take
    a look at this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating our code](img/BO5194_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s a direct copy of lines 234 to 239 of the compiled version of the pen
    by Nikolay, which we used as a basis for our earlier demos. Now take a quick look
    at the equivalent code that I tweaked from the original and used in my version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating our code](img/BO5194_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice any differences? The vendor prefix version of the `transform` attribute
    has been stripped out—most modern browsers (certainly within the last year to
    eighteen months), should handle this code without the need for vendor prefixes.
    The original version also suffered from a high degree of CSS specificity—this
    will become even more apparent if the code is nested!
  prefs: []
  type: TYPE_NORMAL
- en: To improve it, I've switched in `.nav-panel ul li` as a direct replacement for
    `.nav-panel ul .nav-btn`—the code is relatively simple in that it does not need
    a second class to identify elements for styling purposes. The next logical step
    is to break up the large nesting block within the source file; it is tempting
    to include a single large block, but this will be at the expense of readability,
    maintenance, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: We could potentially go even further, and consider removing the leading `.nav-panel`;
    not only will it make the code infinitely easier to read, but it will also reduce
    the issues around CSS specificity. Of course, this kind of change will depend
    on what is in your code; the point here is to examine your code thoroughly, and
    look to reduce any CSS specificity as much as possible, so that your nesting won't
    look so bad!
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative means we can use though, which removes issues around
    CSS specificity—using **Block Element Modifier** notation (or **BEM** for short).
    It's a great way to systematically style elements using CSS, and it is worth taking
    time to get accustomed to how it works. Let's dive in and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Making the switch to BEM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what is BEM, and why can it help with reducing or removing CSS specificity
    issues?
  prefs: []
  type: TYPE_NORMAL
- en: '**BEM**, or **Block Element Modifier**, helps us style elements using a systematic
    naming convention, which is structured thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.block`: top-level containing the element we''re going to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.block__modifier`: the style assigned when the state of an element is changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.block__element`: an element inside a top-level container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.block__element__modifier`: alternate representation of an element, when its
    state has been changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea behind this style of coding is to make it portable and easier to maintain.
    The basis for this is that, while standard, non-BEM CSS is more concise, it is
    harder to infer what each rule does. We frequently have to assign multiple classes
    to an element, which introduces a degree of CSS specificity, and reduces the reusability
    of CSS rules. Using BEM allows us to combine the constituent names into one style
    class name, and remove any concern around CSS specificity.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use this concept, we can use it to write style rules such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will compile to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses plain BEM format, but from within a processor environment
    such as SASS to construct BEM rules in PostCSS, we can use the `postcss-bem` plugin
    (available from [https://github.com/ileri/postcss-bem](https://github.com/ileri/postcss-bem))
    to produce our BEM CSS using `@-rules`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, `@component` signifies our Block, `@descendant` our element,
    and `@modifier` is our modifier. When compiled, our CSS would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of using BEM is that it helps to reduce or even avoid CSS specificity
    issues—although names are longer, we can combine both element and modifier names
    into one class, instead of having to apply three or more separate classes. Granted,
    there may be instances where we might have to apply a second class, but with careful
    planning we should be able to reduce this to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right, onwards we go: let''s get stuck in to coding! Over the next few pages,
    we will take a look at implementing BEM styling in a simple demo, and see how
    we can use PostCSS to compile our code.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple message boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our BEM demo, we're going to work through the CSS rules required to show
    some simple message boxes on screen, such as for displaying confirmation that
    a task has completed, or a warning when something isn't right.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original version of this demo, by Rene Spronk, is available from [http://www.cssportal.com/blog/css-notification-boxes/](http://www.cssportal.com/blog/css-notification-boxes/).
  prefs: []
  type: TYPE_NORMAL
- en: It's a simple demo, but shows off the principles behind BEM CSS perfectly—go
    ahead and extract a copy of the `Tutorial8` folder, then run `index.html` to get
    a feel for what we will be producing. This version uses standard CSS; we will
    use this as a basis for converting to using BEM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by extracting a copy of the `Tutorial9` folder from the code download
    that accompanies this book—drop this into our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in a new file, add the following CSS statements starting at line 1, and
    leaving a one-line gap between each—they should be fairly self-explanatory, but
    we will go through each block in turn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We kick off with the core styles for each dialog—this is a basis style for
    each dialog box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up comes a simple style for each `<span>` element—this turns the lead-in
    caption for each dialog to uppercase and sets it in bold text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to add our block element—it''s the opening line that forms the
    basis for our styling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up comes the Element part of our style rule. These rules need to be added
    as nested (that is, indented) rules immediately underneath—using the PostCSS plugin,
    we add it in as a `@descendent` of our `@component`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Up next comes the first of our status messages—we kick off with styling the
    Error message first; the main rule adds an error icon and styles the border. The
    `:hover` pseudo-element reduces the opacity when we hover over the box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is swiftly followed by styling for the Success message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can''t forget the obligatory Warning message, so here''s the style rule
    for that status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last but by no means least, here''s the final one, which is Notice; it includes
    the closing bracket for the BEM nesting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file as `style.scss` into the `src` folder of our top-level project
    area (and not into the `Tutorial8` folder!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our simple demo isn't going to set the world alight in terms of styling. If
    we were to preview it now, the results will of course not look great; let's fix
    that by setting up the compilation and linting tasks within PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are a SASS user, then you can see a version of this code suitable for
    that processor on GitHub—the code is available at: [https://gist.github.com/alibby251/45eab822a6a619467279](https://gist.github.com/alibby251/45eab822a6a619467279).
    Note how similar the results are when you compare the compiled version with the
    version we''ll get in the next exercise!'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and linting our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our code is in place, but the boxes won't look particularly appetizing—most
    of the styles are still written using PostCSS `@-rules`. We can fix that by compiling
    the code, so let's dive in and take a look at installing support for BEM.
  prefs: []
  type: TYPE_NORMAL
- en: Installing BEM support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up BEM support in PostCSS is a cinch—we can make use of two plugins
    to compile and lint our code. The plugins we need for this task are `postcss-bem`
    (available from [https://github.com/ileri/postcss-bem](https://github.com/ileri/postcss-bem)),
    and `postcss-bem-linter` (available from [https://github.com/postcss/postcss-bem-linter](https://github.com/postcss/postcss-bem-linter)).
    Both can be installed using the same process through Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopefully the process will be familiar by now, so without further ado, let''s
    make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by firing up a Node.js command prompt, and navigating to our working
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command prompt, enter this command then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Node.js will install each of the elements required; if all is well, we should
    see this result, to indicate a successful installation:![Installing BEM support](img/BO5194_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat the same process for `postcss-bem-linter`, using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Installing BEM support](img/BO5194_03_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Keep the command prompt session open, but minimized. We're going to make use
    of it again in a moment!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the plugin is installed, we can go ahead and add support to our gulp
    task file, and begin to parse our code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, go ahead and remove the existing `gulpfile.js` file at the root of our
    project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, add the following lines and save it as `gulpfile.js`, at the
    root of our project area. We start with setting a number of variables that call
    each of the plugins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first task in the file checks the code for consistency with BEM standards,
    and displays any errors on-screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second task in the file compiles the BEM code to valid CSS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This task is the default that is called when we run gulp from the command line;
    it calls each of the tasks in turn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We finish the `gulpfile.js` with a watch facility, to kick in and compile our
    code when any changes are made to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re going to replace the `package.json` file too—add these lines to a new
    file, and save it to the root of the project area. These simply tell gulp which
    versions of our plugins to use when compiling the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the code download that accompanies this book, go ahead and extract a copy
    of `style.css` from the `css – completed version` folder under `Tutorial9`—save
    this to the `src` folder under our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Revert back to the Node.js command prompt session we had before, then at the
    prompt, enter this command and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all is well, the code will be checked, and the results displayed on screen.
    You may see errors appear, such as those shown in this screenshot. If they do,
    they can be ignored for now (we will explore this in more detail later):![Installing
    BEM support](img/BO5194_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and copy the contents of the `dest` folder into the `css` folder underneath
    `Tutorial9`—if all is well, we should see something akin to this screenshot when
    previewing the results in a browser:![Installing BEM support](img/BO5194_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our simple demo shows some useful message boxes that we can use as a basis for
    something more complex; it illustrates perfectly how we can use BEM to style our
    code, while keeping issues around CSS specificity at bay. We've covered a few
    useful techniques throughout this exercise, so let's take a moment to explore
    them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring our changes in more detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is worth taking time to really get familiar with BEM styling principles.
    This is one of those areas where not spending time can easily dissuade you from
    using this technique; the principles are easy to understand but can take time
    to implement! Let's take a look at our code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The key principle around BEM, when using the PostCSS plugin, is that of nesting—in
    this instance, we create our core component content, which results in an empty
    style rule at the top of our style sheet. Indented to the next level is our `@descendant`—this
    indicates that our message boxes are being styled as alerts. We then use a number
    of `@modifiers` to style each type of alert, such as success, warning, error,
    or notice (that is, information). This includes a separate style rule to cover
    each instance of the hover pseudo-element used in our code.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for us? It means we have to not just consider each element
    (for instance, a message box) as a single entity to which we simply apply lots
    of classes; instead, we should consider the constituent parts of each element
    and apply a single class to each. Hold on, does that not mean we still have three
    classes in use (as we might have here)?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about BEM naming conventions, take a look at the useful article
    posted at [https://en.bem.info/tools/bem/bem-naming/](https://en.bem.info/tools/bem/bem-naming/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the answer is yes, and no: the trick here is that PostCSS will combine
    each nested style into valid CSS; for example, this extract (adapted from our
    demo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled, this will appear as this CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The sharp-eyed among you will have spotted that we still have errors being
    generated when our code is compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring our changes in more detail](img/BO5194_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's always disconcerting to see errors, but there are valid reasons for them.
    We can safely ignore the two deprecation warnings (these should be fixed in a
    future version), but the two errors are of more concern.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing our errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two errors are being caused by `postcss-bem-linter`, which is not recognizing
    the two styles as valid BEM notation. This raises a question: can we alter our
    code to remove the issues?'
  prefs: []
  type: TYPE_NORMAL
- en: To answer this, we would need to weigh up how much code is affected against
    the time and effort required to alter it. In our demo, there is very little code
    affected; to resolve it, we would need to alter the `.dlgBox` and `span` styles
    to equivalent BEM naming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is this worth the effort? In a small demo such as ours, it is likely that the
    answer is no, for a larger demo, we would look to alter these two styles. Instead,
    we can add a simple directive at line 48, thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing our errors](img/BO5194_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the code is recompiled, the errors are removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing our errors](img/BO5194_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Purists may say this is cheating. It's true, our code is still *technically*
    not all BEM. In defense though, it's up to each developer to make that decision;
    there may be elements that have to remain as standard CSS, which we can't convert.
    In this case, it may be sensible to import these styles using the PostCSS import
    plugin—we will explore using this more in [Chapter 10](ch10.html "Chapter 10. Building
    a Custom Processor"), *Building a Custom Preprocessor*.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that the `postcss-bem-linter plugin` will not display the
    results of any errors by itself—for this, we need to use a plugin such as `postcss-reporter`
    (available at [https://github.com/postcss/postcss-reporter](https://github.com/postcss/postcss-reporter),
    for command line), or postcss-browser-reporter (from [https://github.com/postcss/postcss-browser-reporter](https://github.com/postcss/postcss-browser-reporter),
    displays content in the browser window). Both have a number of options that are
    worth investigating to help fine-tune what is displayed when the code is processed
    through PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, developers have had to frequently write code that duplicates
    all or part of a selector—a perfect example is styling lists or navigation items.
    It's a real pain to have to write so much extra code; instead we can use nesting
    principles to help remove some of this code. We've covered a number of techniques
    around nesting in PostCSS throughout this chapter, so let's take a moment to review
    what we've learned.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off with an introduction to nesting, to help bring us up to speed,
    before launching into using the `postcss-nesting` plugin to create nested styles
    within PostCSS. We then moved on to creating our nesting demo. We began with preparing
    a plain vanilla CSS version, before taking a look at converting to existing processors
    such as SASS.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we then took a look at converting our code using the `postcss-nesting`
    plugin, before exploring some of the pitfalls that are associated with nesting,
    and some of the tips and tricks we can use to reduce CSS specificity, one of the
    key issues associated with nesting.
  prefs: []
  type: TYPE_NORMAL
- en: We then rounded out the chapter with a look at BEM, and how it can be used in
    PostCSS. We covered some of the basic principles of this methodology, before applying
    it to a simple example. We also learned why it won't always work for every instance;
    for those where it is suitable, we took a brief look at how we can set PostCSS
    to automatically lint our BEM code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Phew, a real whistle stop tour there! Hang on to your hats though, as it won''t
    stop: in our next chapter, we''re going to take a look at writing media queries,
    and how PostCSS can help with compiling them into valid CSS.'
  prefs: []
  type: TYPE_NORMAL
