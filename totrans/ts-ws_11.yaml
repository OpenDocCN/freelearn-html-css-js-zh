- en: 10\. Event Loop and Asynchronous Behavior
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 事件循环与异步行为
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you'll investigate how a web page actually works within the
    browser, with a special focus on how, when, and why the browser executes the JavaScript
    code we provide. You'll dive deep into the intricacies of the event loop and see
    how we can manage it. Lastly, you'll learn about the tools that TypeScript offers
    you. By the end of this chapter, you will be able to better manage the asynchronous
    nature of the execution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探究网页如何在浏览器中实际工作，特别关注浏览器如何、何时以及为什么执行我们提供的JavaScript代码。你将深入了解事件循环的复杂性，并了解我们如何管理它。最后，你将了解TypeScript为你提供的工具。到本章结束时，你将能够更好地管理执行的异步特性。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned the fundamentals of generics and conditional
    types. This chapter introduces you to event loops and asynchronous behavior. However,
    before you proceed with learning these topics, let's have a look at a hypothetical
    scenario to really understand how synchronous and asynchronous executions work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了泛型和条件类型的基础知识。本章将向你介绍事件循环和异步行为。然而，在继续学习这些主题之前，让我们先看看一个假设场景，以便真正理解同步和异步执行是如何工作的。
- en: Imagine a small bank that has a single teller. His name is Tom, and he's serving
    clients all day. Since it's a small bank and there are few clients, there's no
    queue. So, when a client comes in, they get Tom's undivided attention. The client
    provides all the necessary paperwork, and Tom processes it. If the process needs
    some kind of outside input, such as from a credit bureau or the bank's back-office
    department, Tom submits the request, and he and the client wait for the response
    together. They might chat a bit, and when the response comes, Tom resumes his
    work. If a document needs to be printed, Tom sends it to the printer that's right
    on his desk, and they wait and chat. When the printing is done, Tom resumes his
    work. Once the work is completed, the bank has another satisfied client, and Tom
    continues with his day. If somebody comes while Tom is serving a client (which
    happens seldom), they wait until Tom is completely done with the previous client,
    and only then do they begin their process. Even if Tom is waiting on an external
    response, the other client will have to wait their turn, while Tom idly chats
    with the current client.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一家小银行，它只有一位出纳员。他的名字叫汤姆，他全天都在为客户服务。由于银行规模小，客户不多，所以没有排队。因此，当客户进来时，他们会得到汤姆的全神贯注。客户提供了所有必要的文件，汤姆进行处理。如果这个过程需要某种外部输入，例如来自信用局或银行的后台部门，汤姆会提交请求，他和客户一起等待响应。他们可能会聊一会儿，当响应到来时，汤姆继续他的工作。如果需要打印文件，汤姆会将文件发送到他的办公桌上方的打印机，他们等待并聊天。当打印完成时，汤姆继续他的工作。一旦工作完成，银行又有一位满意的客户，汤姆继续他的工作日。如果有人来的时候汤姆正在为客户服务（这种情况很少发生），他们必须等待，直到汤姆完全完成前一个客户的服务，然后才开始他们的流程。即使汤姆正在等待外部响应，其他客户也必须等待他们的轮次，同时汤姆与当前客户闲聊。
- en: Tom effectively works synchronously and sequentially. There are lots of benefits
    of this approach to working, namely, Tom (and his bosses) can always tell whether
    he is serving a client or not, he always knows who his current client is, and
    he can completely forget all the data about the client as soon as the client leaves,
    knowing that they have been serviced completely. There are no issues with mixing
    up documents from different clients. Any problems are easy to diagnose and easy
    to fix. And since the queue never gets crowded, this setup works to everyone's
    satisfaction.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 汤姆有效地以同步和顺序的方式工作。这种工作方式有很多好处，即汤姆（和他的上司）总能知道他是否在为客户服务，他总是知道他的当前客户是谁，并且一旦客户离开，他可以完全忘记所有关于客户的数据，因为他知道他们已经得到了完全的服务。没有混淆来自不同客户的文件的问题。任何问题都容易诊断和修复。由于队列永远不会拥挤，这种设置让每个人都满意。
- en: So far, so good. But what happens when the bank suddenly gets more clients?
    As more and more clients arrive, we get a long queue, and everyone is waiting,
    while Tom chats with the current client, waiting on a response from the credit
    bureau. Tom's boss is, understandably, not happy with the situation. The current
    system does not scale – at all. So, he wants to change the system somehow, to
    be able to serve more clients. How can he do that? You will look at a couple of
    solutions in the following section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但是，当银行突然增加更多客户时会发生什么呢？随着越来越多的客户到来，我们排起了长队，每个人都等待着，而汤姆在与当前客户聊天，等待信用局的回复。可以理解，汤姆的老板对这种情况并不满意。当前系统根本无法扩展。因此，他想以某种方式改变系统，以便能够服务更多客户。他该如何做呢？你将在下一节中看到几个解决方案。
- en: The Multi-Threaded Approach
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程方法
- en: Basically, there are two different approaches. One is to have multiple Toms.
    So, every single teller will still work in the exact same simple and synchronous
    way as before – we just have lots of them. Of course, the boss will need to have
    some kind of organization to know which teller is available and which is working,
    whether there are separate queues for each teller, or a single large queue, along
    with some kind of distribution mechanism (that is, a system where a number is
    assigned to each customer). The boss might also get one of those big office printers,
    instead of having one printer per teller, and have some kind of rule in order
    to not mix up the print jobs. The organization will be complex, but the task of
    every single teller will be straightforward.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，有两种不同的方法。一种是有多个汤姆。所以，每个柜员仍然会以前完全相同简单同步的方式工作——我们只是有很多个。当然，老板需要某种组织来了解哪个柜员可用，哪个柜员在工作，是否有为每个柜员单独的队列，或者一个大型队列，以及某种分配机制（即，为每个客户分配一个号码的系统）。老板可能还会得到一台大型的办公打印机，而不是每个柜员一台打印机，并制定某种规则以避免打印作业混淆。组织将会复杂，但每个柜员的任务将会简单明了。
- en: By now, you know we're not really discussing banks. This is the usual approach
    for server-side processing. Grossly simplified, the server process will have multiple
    sub-processes (called threads) that will work in parallel, and the main process
    will orchestrate everything. Each thread will execute synchronously, with a well-defined
    beginning, middle, and end. Since servers are usually machines with lots of resources,
    with heavy loads, this approach makes sense. It can accommodate low or high loads
    nicely, and the code that processes each request can be relatively simple and
    easy to debug. It even makes sense to have the thread wait for some external resource
    (a file from the file system, or data from the network or database), since we
    can always spin up new threads if we have more requests. This is not the case
    with real live tellers. We cannot just clone a new one if more clients come. The
    kind of waiting done by the threads (or by Tom) is usually referred to as *busy
    waiting*. The thread is not doing anything, but it's not available for any work,
    since it's busy doing something – it's busy waiting. Just like Tom was actually
    busy chatting with the client while waiting for a response from the credit bureau.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你知道我们实际上并不是在讨论银行。这是服务器端处理通常采用的方法。粗略简化一下，服务器进程将会有多个子进程（称为线程）并行工作，而主进程将协调一切。每个线程将同步执行，有一个明确的开始、中间和结束。由于服务器通常是拥有大量资源的机器，在重负载下，这种方法是有意义的。它可以很好地适应低或高负载，处理每个请求的代码可以相对简单且易于调试。甚至有理由让线程等待某些外部资源（例如文件系统中的文件，或来自网络或数据库的数据），因为我们总是可以启动新的线程来处理更多的请求。然而，对于现实生活中的柜员来说并非如此。当客户增多时，我们无法简单地克隆一个新的柜员。线程（或汤姆）所进行的等待通常被称为*忙等待*。线程并没有做任何事情，但它无法进行任何工作，因为它正忙于做某事——它正忙于等待。就像汤姆实际上在等待信用局的回复时，正忙于与客户聊天一样。
- en: We have a system that can be massively parallel and concurrent, but still, each
    part of it is run synchronously. The benefit of this approach is that we can serve
    many, many clients at the same time. One obvious downside is the cost, both in
    hardware and in complexity. While we managed to keep the client processing simple,
    we'll need a huge infrastructure that takes care of everything else – adding tellers,
    removing tellers, queueing customers, managing access to the office printer, and
    similar tasks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个可以大规模并行和并发运行的系统，但每个部分仍然同步运行。这种方法的优点是我们可以同时服务成千上万的客户。一个明显的缺点是成本，无论是硬件还是复杂性。虽然我们设法保持了客户处理的简单性，但我们还需要一个巨大的基础设施来处理其他所有事情——添加柜员、移除柜员、排队等候的客户、管理办公室打印机的访问，以及类似的任务。
- en: This will use all the available resources of the bank (or the server), but that
    is fine, since that's the whole point – to serve clients, as many and as fast
    as possible, and nothing else.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用银行（或服务器）的所有可用资源，但这没关系，因为这就是整个目的——尽可能快地服务尽可能多的客户，没有其他。
- en: However, there is another approach – asynchronous execution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种方法——异步执行。
- en: The Asynchronous Execution Approach
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步执行方法
- en: The other approach, the one taken by the web and, by extension, JavaScript and
    TypeScript, is to use just a single thread – so Tom is still on his own. But,
    instead of Tom idly chatting with a waiting client, he could do something else.
    If a situation arises where he needs some verification from the back office, he
    just writes down what he was doing and how far he got on a piece of paper, gives
    that paper to the client, and sends them to the back of the queue. Tom is now
    ready to start serving the next client in line. If that client does not need external
    resources, they are processed completely and are free to leave. If they need something
    else that Tom needs to wait for, they too are sent to the back of the line. And
    so on, and so forth. This way, if Tom has any clients at all, he's processing
    their requests. He's never busy waiting, instead, he's busy working. If a client
    needs to wait for a response, they do so separately from Tom. The only time Tom
    is idle is when he has no clients at all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，即网络和扩展到JavaScript和TypeScript采用的方法，是只使用单个线程——所以汤姆仍然独自一人。但是，汤姆不会无所事事地与等待的客户聊天，他可以做其他事情。如果出现需要从后台办公室获取验证的情况，他只需在一张纸上写下他正在做什么以及他做到了哪一步，然后将那张纸交给客户，并让他们去队伍的后面。现在，汤姆可以开始服务下一个排队等候的客户。如果那个客户不需要外部资源，他们的请求将被完全处理，并可以自由离开。如果他们需要汤姆需要等待的其他东西，他们也会被送到队伍的后面。以此类推。这样，如果汤姆有任何客户，他正在处理他们的请求。他永远不会忙于等待，相反，他总是忙于工作。如果客户需要等待响应，他们会在汤姆之外单独等待。汤姆唯一空闲的时候是他没有任何客户的时候。
- en: The benefit of this approach is fairly obvious – before, Tom spent a lot of
    his time chatting, now he is working all the time (of course, this benefit is
    from Tom's boss' point of view – Tom liked the small talk). An additional benefit
    is that we know our resource consumption up front. If we only have one teller,
    we know the square footage that we will need for the office. However, there are
    some downsides as well. The most important downside is that our clients now have
    to know our process quite intimately. They will need to understand how to queue
    and requeue, how to continue working from where they left off, and so on. Tom's
    work also got a lot more complicated. He needs to know how to pause the processing
    of a client, how to continue, how to behave if an external response is not received,
    and so on. This model of working is usually called asynchronous and concurrent.
    Doing his job, Tom will jump between multiple clients at the same time. More than
    one client will have their process started but not finished. And there's no way
    for a client to estimate how long it will take to process their task once it is
    started – it depends on how many other clients Tom processes at the same time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点相当明显——以前，汤姆花了很多时间聊天，现在他一直在工作（当然，这个好处是从汤姆老板的角度来看的——汤姆喜欢闲聊）。另一个好处是我们事先就知道我们的资源消耗。如果我们只有一个出纳员，我们就知道我们需要多少办公面积。然而，也有一些缺点。最重要的缺点是，我们的客户现在必须非常了解我们的流程。他们需要了解如何排队和重新排队，如何从他们离开的地方继续工作，等等。汤姆的工作也变得更加复杂。他需要知道如何暂停客户的处理，如何继续，如果未收到外部响应应该如何处理等等。这种工作模式通常被称为异步和并发。在执行他的工作时，汤姆会同时跳转到多个客户。不止一个客户会开始处理但未完成。而且客户无法估计一旦开始处理他们的任务将需要多长时间——这取决于汤姆同时处理多少其他客户。
- en: From the early days, this model made much more sense for the web. For starters,
    web applications are processed on the device of the client. We should not make
    any technical assumptions about it – as we cannot be sure about the kind of device
    that the client might be using. In essence, a web page is a guest on the client's
    device – and it should behave properly. For example, using up all of a device's
    resources to show what amounts to a fancy animation is not proper behavior at
    all. Another important issue is security. If we think of web pages as applications
    that contain some code, we're basically executing someone's code on our machine
    whenever we enter a web address in the browser's address bar.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，这个模型对网络来说就更有意义。首先，网络应用程序是在客户端的设备上处理的。我们不应该对此有任何技术假设——因为我们无法确定客户端可能会使用哪种设备。本质上，一个网页是客户端设备上的访客——并且它应该表现得体。例如，使用所有设备资源来展示一些花哨的动画根本不是合适的行为。另一个重要问题是安全性。如果我们把网页看作是包含一些代码的应用程序，那么每次我们在浏览器的地址栏中输入网址时，我们基本上就是在我们的机器上执行某人的代码。
- en: The browser needs to make sure that the code on the page, even if it's malicious,
    is restricted in what it can do to our machine. The web would not have been as
    popular as it is today if visiting a website could make your computer explode.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器需要确保页面上即使是有害的代码，也不能对我们的机器造成太大的影响。如果访问一个网站能让你的电脑爆炸，那么网络今天就不会像现在这样受欢迎了。
- en: So, since the browser cannot know in advance which pages it will be used for,
    it was decided that each web page will only get access to a single thread. Also,
    for security reasons, each web page will get a separate thread, so a running web
    page cannot meddle in the execution of other pages that may execute at the same
    time (with features such as web workers and Chrome applications, these restrictions
    are somewhat loosened, but in principle, they still apply).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于浏览器无法事先知道它将用于哪些页面，所以决定每个网页只能访问一个线程。此外，出于安全考虑，每个网页将获得一个单独的线程，因此正在运行的网页不能干涉同时可能执行的其它页面的执行（通过如网络工作者和Chrome应用程序等特性，这些限制有所放宽，但原则上仍然适用）。
- en: There is simply no way for a web page to spawn enough threads to swarm the system,
    or for a web page to get the data from another web page. And, since a web page
    needs to do lots of things at once, using the synchronous and sequential approach
    was out of the question. That is why all the JavaScript execution environments
    completely embraced the asynchronous, concurrent approach. This was done to such
    an extent that some common synchronization techniques are, intentionally, just
    not available in JavaScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，网页无法生成足够的线程来系统性地蜂拥而至，或者网页无法从另一个网页获取数据。而且，由于网页需要同时做很多事情，使用同步和顺序的方法是不可能的。这就是为什么所有的JavaScript执行环境完全采用了异步、并发的方法。这样做到了这样的程度，以至于一些常见的同步技术，故意地，在JavaScript中不可用。
- en: 'For example, lots of other languages have a "wait some time" primitive, or
    a library function that does that. For example, in the C# programming language,
    we can have this code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多其他语言都有一个“等待一段时间”的原语，或者一个执行此操作的库函数。例如，在C#编程语言中，我们可以有如下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code will write some text to the console, and 10 seconds later, write
    some more text. During the 25 seconds of the wait, the thread this executes on
    will be completely non-responsive, but the code written is simple and linear –
    easily understood, easily changeable, and easily debuggable. JavaScript simply
    does not have such a synchronous primitive, but it has an asynchronous variant
    in the `setTimeout` function. The simplest equivalent code would be the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将向控制台写入一些文本，然后在10秒后写入更多文本。在等待的25秒内，执行此代码的线程将完全无响应，但代码简单且线性——易于理解、易于更改和易于调试。JavaScript没有这样的同步原语，但它有一个异步变体，即`setTimeout`函数。最简单的等效代码如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's obvious that this code is much more complex than the C# equivalent, but
    the advantage that we get is that this code is non-blocking. In the 25 total seconds
    that this code is executing, our web page can do everything it needs to do. It
    can respond to events, the images can load and display, we can resize the window,
    scroll the text – basically, the application will resume the normal and expected
    functionalities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这段代码比C#的等效代码复杂得多，但我们获得的优势是这段代码是非阻塞的。在这段代码执行的25秒总时间内，我们的网页可以完成它需要做的所有事情。它可以响应用户事件，图片可以加载并显示，我们可以调整窗口大小，滚动文本——基本上，应用程序将恢复正常和预期的功能。
- en: 'Note that while it''s possible to block the JavaScript execution with some
    special synchronous code, it''s not easy to do it. When it does actually happen,
    the browser can detect that it did happen and terminate the offending page:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然使用一些特殊的同步代码可以阻塞JavaScript执行，但这并不容易。当它实际上发生时，浏览器可以检测到这一行为并终止有问题的页面：
- en: '![Figure 10.1: Unresponsive page'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：无响应页面'
- en: '](img/B14508_10_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_10_01.jpg)'
- en: 'Figure 10.1: Unresponsive page'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：无响应页面
- en: Executing JavaScript
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行JavaScript
- en: 'When a JavaScript execution environment, such as a node or a browser loads
    a JavaScript file, it parses it and then runs it. All the functions that are defined
    in a JavaScript file are registered, and all the code that is not in a function
    is executed. The order of the execution is according to the code''s position in
    the file. So, consider a file having the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个JavaScript执行环境，如node或浏览器加载一个JavaScript文件时，它会解析它然后运行它。在JavaScript文件中定义的所有函数都会被注册，所有不在函数中的代码都会被执行。执行的顺序是根据代码在文件中的位置来确定的。所以，考虑一个包含以下代码的文件：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The console will always display this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台将始终显示以下内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The order of the output cannot be changed, without changing the code itself.
    This is because the line with `First` will be executed completely – always – and
    then, and only then, will the line with `Second` begin to execute. This approach
    is synchronous because the execution is synchronized by the environment. We are
    guaranteed that the second line will not start executing, until and unless the
    line above it is completely done. But what happens if the line calls some function?
    Let''s take a look at the following piece of code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的顺序不能改变，除非修改代码本身。这是因为带有`First`的行将完全执行——总是如此——然后，并且只有然后，带有`Second`的行才会开始执行。这种方法是同步的，因为执行是由环境同步的。我们保证，除非上面的行完全执行完毕，否则第二行不会开始执行。但如果这一行调用了某个函数呢？让我们看看以下这段代码：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the code is parsed, the environment will detect that we have four functions
    – `first`, `second`, `third`, and `sayHello`. It will also execute the line of
    code that is not inside a function (`first();`), and that will start the execution
    of the `first` function. But that function, while it's executing, calls the `second`
    function. The runtime will then suspend the running of the `first` function, remember
    where it was, and begin with the execution of the `second` function. This function,
    in turn, calls the `third` function. The same thing happens again – the runtime
    starts executing the `third` function, remembering that once that function is
    done, it should resume with the execution of the `second` function, and that once
    `second` is done, it should resume with the execution of the `first` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码被解析时，环境将检测到我们有四个函数——`first`、`second`、`third`和`sayHello`。它还会执行不在函数内部的代码行（`first();`），这将启动`first`函数的执行。但是，当这个函数正在执行时，它会调用`second`函数。然后，运行时会挂起`first`函数的执行，记住它的位置，并开始执行`second`函数。这个函数反过来又调用`third`函数。同样的事情再次发生——运行时开始执行`third`函数，记住一旦该函数完成，它应该继续执行`second`函数，一旦`second`函数完成，它应该继续执行`first`函数。
- en: The structure the runtime uses to remember which function is active, and which
    are waiting, is called a **stack**, specifically, *the call stack*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时用来记住哪个函数是活动的，哪些在等待的结构被称为**栈**，具体来说，是*调用栈*。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term "stack" is used in the sense of a stack of dishes, or a stack of pancakes.
    We can only add to the top, and we can only remove from the top.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: “栈”这个术语在这里是指盘子堆或煎饼堆。我们只能从顶部添加，也只能从顶部移除。
- en: 'The executing functions are put one on top of the other, and the topmost function
    is the one being actively executed, as shown in the following representation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正在执行的函数被一个接一个地堆叠起来，最顶部的函数是正在积极执行的函数，如下面的表示所示：
- en: '![Figure 10.2: Stack'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2：栈'
- en: '](img/B14508_10_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2：栈](img/B14508_10_02.jpg)'
- en: 'Figure 10.2: Stack'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：栈
- en: In the example, the `third` function will call the `sayHello` function, which
    will in turn call the `log` function of the `console` object. Once the `log` function
    finishes executing, the stack will start unwinding. That means that once a certain
    function finishes executing, it will be removed from the stack, and the function
    below it will be able to resume executing. So, once the `sayHello` function finishes
    executing, the `third` function will resume and finish in turn. This will trigger
    the continuation of the `second` function, and when that function is done as well,
    the `first` function will continue, and eventually finish. When the `first` function
    finishes executing, the stack will become empty – and the runtime will stop executing
    code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，`third`函数将调用`sayHello`函数，该函数反过来又调用`console`对象的`log`函数。一旦`log`函数执行完成，栈将开始回溯。这意味着一旦某个函数完成执行，它将从栈中移除，下面的函数将能够继续执行。因此，一旦`sayHello`函数执行完成，`third`函数将恢复并依次完成。这将触发`second`函数的继续执行，当该函数也完成时，`first`函数将继续，并最终完成。当`first`函数执行完成时，栈将变为空——运行时将停止执行代码。
- en: It's worth noting that all of this execution is done strictly synchronously
    and deterministically. We can deduce the exact order and number of function calls
    just from looking at the code. We can also use common debugging tools such as
    breakpoints and stack traces.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，所有这些执行都是严格同步和确定性的。我们可以仅从查看代码中推断出函数调用的确切顺序和数量。我们还可以使用常见的调试工具，如断点和堆栈跟踪。
- en: 'Exercise 10.01: Stacking Functions'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.01：堆叠函数
- en: 'In this exercise, we''ll define few simple functions that call each other.
    Each of the functions will log to the console when it starts executing and when
    it''s about to finish executing. We will analyze when and in what order the output
    is mapped to the console:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义几个简单的相互调用的函数。每个函数在开始执行和即将完成执行时都会向控制台记录日志。我们将分析输出何时以及以何种顺序映射到控制台：
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://packt.link/X7QZQ](https://packt.link/X7QZQ).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在[https://packt.link/X7QZQ](https://packt.link/X7QZQ)找到。
- en: Create a new file, `stack.ts`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`stack.ts`。
- en: 'In `stack.ts`, define three functions called `inner`, `middle`, and `outer`.
    None of them need to have parameters or return types:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stack.ts`中定义三个函数，分别命名为`inner`、`middle`和`outer`。它们都不需要参数或返回类型：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the body of the `inner` function, add a single `log` statement, indented
    by four spaces:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`inner`函数的主体中，添加一个缩进四个空格的`log`语句：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the body of the `middle` function, add a call to the `inner` function. Before
    and after the call, add a `log` statement, indented by two spaces:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`middle`函数的主体中，添加对`inner`函数的调用。在调用前后添加一个缩进两个空格的`log`语句：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the body of the `outer` function, add a call to the `middle` function. Before
    and after the call, add a `log` statement:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`outer`函数的主体中，添加对`middle`函数的调用。在调用前后添加一个`log`语句：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the function declaration, create a call only to the `outer` function:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数声明后，仅创建对`outer`函数的调用：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Save the file, and compile it with the following command:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并使用以下命令进行编译：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Verify that the compilation ended successfully and that there is a `stack.js`
    file generated in the same folder. Execute it in the `node` environment with this command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功完成，并且同一文件夹中生成了一个`stack.js`文件。在`node`环境中使用以下命令执行它：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will see the output looks like this:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到输出看起来像这样：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output shows which function started executing first (`outer`), as that is
    the first message displayed. It can also be noted that the `middle` function finished
    executing after the `inner` function was already finished, but before the `outer`
    function was finished.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了哪个函数首先开始执行（`outer`），因为这是首先显示的消息。还可以注意到，`middle`函数在`inner`函数完成后，但在`outer`函数完成之前已经执行完毕。
- en: Browsers and JavaScript
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器和JavaScript
- en: When a web page is requested by the user, the browser needs to do lots of things.
    We won't go into the details of each of them, but we'll take a look at how it
    handles our code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户请求网页时，浏览器需要做很多事情。我们不会深入到每个细节，但我们会看看它是如何处理我们的代码的。
- en: First of all, the browser sends the request to the server and receives an HTML
    file as a response. Within that HTML file, there are embedded links to resources
    that are needed for the page, such as images, stylesheets, and JavaScript code.
    The browser then downloads those as well and applies them to the downloaded HTML.
    Images are displayed, elements are styled, and JavaScript files are parsed and
    run.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，浏览器向服务器发送请求，并接收一个HTML文件作为响应。在该HTML文件中，嵌入了对页面所需资源的链接，例如图片、样式表和JavaScript代码。然后浏览器也下载这些资源，并将它们应用到下载的HTML文件上。图片被显示，元素被样式化，JavaScript文件被解析并执行。
- en: 'The order in which the code is executed is according to the file''s order in
    the HTML, then according to the code''s position in the file. But when are the
    functions called? Let''s say we have the following code in our file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行的顺序是按照HTML文件中的顺序，然后根据代码在文件中的位置。但是函数何时被调用呢？假设我们在文件中有以下代码：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, the `sayHello` function is registered, and then when it''s called later,
    the function actually executes and writes `Hello` to the console. Take a look
    at the following code now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注册`sayHello`函数，然后当它稍后被调用时，函数实际上执行并将`Hello`写入控制台。现在看看以下代码：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the file with the preceding code is processed, it will register that it
    has two functions, `sayHello` and `sayHi`. Then it will detect that it has three
    invocations, that is, there are three tasks that need to be processed. The environment
    has something that is called the **task queue**, where it will put all the functions
    that need to be executed, one by one. So, our code will be transformed into three
    tasks. Then, the environment will check if the stack is actually empty, and if
    it is, it will take the first task off the queue and start executing it. The stack
    will grow and shrink depending on the execution of the code of the first task,
    and eventually, when the first task is finished, it will be empty. So, after the
    first task is executed, the situation will be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理包含上述代码的文件时，它会注册两个函数，`sayHello`和`sayHi`。然后它会检测到有三个调用，也就是说，有三个任务需要处理。环境有一个称为**任务队列**的东西，它会将所有需要执行的函数依次放入其中。因此，我们的代码将被转换为三个任务。然后，环境会检查栈是否实际上为空，如果是，它将从队列中取出第一个任务并开始执行。栈的大小会根据第一个任务的代码执行而增长和缩小，最终，当第一个任务完成时，它将是空的。因此，在第一个任务执行后，情况将如下所示：
- en: The execution stack will be empty.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行栈将为空。
- en: The task queue will contain two tasks.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务队列将包含两个任务。
- en: The first task will be completely done.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个任务将完全完成。
- en: Once the stack is empty, the next task is dequeued and executed, and so on,
    until both the task queue and the stack are empty, and all the code is executed.
    Again, this whole process is done synchronously, in a specified order.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦栈为空，下一个任务将被出队并执行，依此类推，直到任务队列和栈都为空，所有代码都执行完毕。再次强调，整个过程是同步进行的，按照指定的顺序。
- en: Events in the Browser
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器中的事件
- en: 'Now, take a look at a different example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看另一个例子：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you have this code in a JavaScript file that is loaded by the browser, you
    can see that the `sayHello` function is registered but not executed. However,
    if you click anywhere on the page, you will see that the `Hello` string appears
    on the console, meaning the `sayHello` function got executed. If you click multiple
    times, you'll get multiple instances of `"Hello"` on the console. And this code
    did not invoke the `sayHello` function even once; you don't have the `sayHello()`
    invocation in the code at all.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个由浏览器加载的JavaScript文件中的此代码，你可以看到`sayHello`函数已被注册但尚未执行。然而，如果你在页面上任何地方点击，你会在控制台看到`Hello`字符串出现，这意味着`sayHello`函数已被执行。如果你多次点击，你将在控制台看到多个`"Hello"`实例。而且这段代码甚至没有调用一次`sayHello`函数；代码中根本就没有`sayHello()`的调用。
- en: What happened is, you *registered* our function as an event listener. Consider
    that you don't call our function at all, but the browser's environment will call
    it for us, whenever a certain event occurs – in this case, the `click` event on
    the whole `document`. And since those events are generated by the user, we cannot
    know if and when our code will execute. Event listeners are the principal way
    that our code can communicate with the page that it's on, and they are called
    asynchronously – you don't know when or if the function will be invoked, nor how
    many times it will be invoked.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是，你*注册*了我们的函数作为事件监听器。考虑一下你根本就没有调用我们的函数，但浏览器环境会在某些事件发生时为我们调用它——在这个例子中，是整个`document`上的`click`事件。由于这些事件是由用户生成的，我们无法知道我们的代码何时以及是否会被执行。事件监听器是我们代码与所在页面通信的主要方式，它们是以异步方式调用的——你不知道函数何时以及是否会被调用，也不知道它会被调用多少次。
- en: What the browser does, when an event occurs, is to look up its own internal
    table of registered event handlers. In our case, if a `click` event occurs anywhere
    on the `document` (that's the whole web page), the browser will see that you have
    registered the `sayHello` function to respond to it. That function will not be
    executed directly – instead, the browser will place an invocation of the function
    in the task queue. After that, the regular behavior explained previously takes
    effect. If the queue and stack are empty, the event handler will begin executing
    immediately. Otherwise, our handler will wait for its turn.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，浏览器会查找其内部注册的事件处理程序表。在我们的例子中，如果`document`（即整个网页）上的任何地方发生`click`事件，浏览器会看到你已经注册了`sayHello`函数来响应它。该函数不会直接执行——相反，浏览器会将函数的调用放入任务队列。之后，将采取之前解释的常规行为。如果队列和栈都为空，事件处理程序将立即开始执行。否则，我们的处理程序将等待它的轮次。
- en: This is another core effect of asynchronous behavior – we simply cannot guarantee
    that the event handler will execute immediately. It might be the case that it
    does, but there is no way to know if the queue and stack are empty at a specific
    moment. If they are, we'll get immediate execution, but if they're not, we'll
    have to wait our turn.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对异步行为的一个核心影响——我们根本无法保证事件处理程序会立即执行。可能它确实会立即执行，但没有办法知道在特定时刻队列和栈是否为空。如果它们是空的，我们将立即执行，但如果它们不是空的，我们就必须等待我们的轮次。
- en: Environment APIs
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境API
- en: Most of our interaction with the browser will be done in the same pattern –
    you will define a function, and pass that function as a parameter to some browser
    API. When and if that function will actually be scheduled for execution will depend
    on the particulars of that API. In the previous case, you used the event handler
    API, `addEventListener`, which takes two parameters, the name of an event, and
    the code that will be scheduled when that event happens.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与浏览器的交互大部分将遵循相同的模式——你将定义一个函数，并将该函数作为参数传递给某个浏览器API。该函数何时以及是否会被调度执行将取决于该API的具体情况。在前一个例子中，你使用了事件处理程序API，即`addEventListener`，它接受两个参数，一个是事件的名称，另一个是当该事件发生时将被调度的代码。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can get a list of different possible events at [https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)找到不同可能事件的列表。
- en: In the rest of this chapter, you will use two other APIs as well, the environment's
    method to defer some code for later execution (`setTimeout`) and the ability to
    call on external resources (popularly called AJAX). There are two different AJAX
    implementations that we will be working with, the original `XMLHttpRequest` implementation,
    and the more modern and flexible `fetch` implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你还将使用另外两个API，即环境方法来延迟一些代码的后续执行（称为`setTimeout`）以及调用外部资源的能力（通常称为AJAX）。我们将使用两种不同的AJAX实现，原始的`XMLHttpRequest`实现和更现代、更灵活的`fetch`实现。
- en: setTimeout
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`setTimeout`'
- en: 'As mentioned previously, the environment offers no possibility to pause the
    execution of JavaScript for a certain amount of time. However, the need to execute
    some code after some set amount of time has passed arises quite often. So, instead
    of pausing the execution, we get to do something different that has the same outcome.
    We get to schedule a piece of code to get executed after an amount of time has
    passed. To do that we use the `setTimeout` function. This function takes two parameters:
    A function that will need to be executed, and the time, in milliseconds, it should
    defer the execution of that function by:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，环境不提供暂停JavaScript执行一定时间的可能性。然而，在经过一定时间后执行某些代码的需求相当常见。因此，我们不是暂停执行，而是执行一些具有相同结果的不同操作。我们可以安排一段代码在经过一段时间后执行。为此，我们使用`setTimeout`函数。此函数接受两个参数：一个需要执行的函数，以及以毫秒为单位延迟执行该函数的时间：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here it means that the anonymous function that is passed as a parameter will
    be executed after 1,000 milliseconds, that is, one second.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着传递给参数的匿名函数将在1,000毫秒后执行，即一秒后。
- en: 'Exercise 10.02: Exploring setTimeout'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.02：探索setTimeout
- en: 'In this exercise, you''ll use the `setTimeout` environment API call to investigate
    how asynchronous execution behaves and what it does:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用`setTimeout`环境API调用来调查异步执行的行为以及它做了什么：
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://packt.link/W0mlS](https://packt.link/W0mlS).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在[https://packt.link/W0mlS](https://packt.link/W0mlS)找到。
- en: Create a new file, `delays-1.ts`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`delays-1.ts`。
- en: 'In `delays-1.ts`, log some text at the beginning of the file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`delays-1.ts`中，在文件开头记录一些文本：
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add two calls to the `setTimeout` function:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个对`setTimeout`函数的调用：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, instead of creating a function and giving it to the `setTimeout` function
    using its name, we have used an anonymous function that we have created in-place.
    We can also use arrow functions instead of functions defined with the `function`
    keyword.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们不是创建一个函数并将其通过其名称传递给`setTimeout`函数，而是使用我们就地创建的匿名函数。我们也可以使用箭头函数代替使用`function`关键字定义的函数。
- en: 'Save the file, and compile it with the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并使用以下命令编译它：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verify that the compilation ended successfully and that there is a `delays-1.js`
    file generated in the same folder. Execute it in the `node` environment with this command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功完成，并在同一文件夹中生成一个`delays-1.js`文件。使用以下命令在`node`环境中执行它：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will see the output looks like this:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到输出如下：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second and third lines of the output should not appear immediately, but
    after 1 and 2 seconds respectively.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出的第二行和第三行不应立即出现，而应在1秒和2秒后分别出现。
- en: 'In the `delays-1.ts` file, switch the two calls to the `setTimeout` function:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`delays-1.ts`文件中，交换对`setTimeout`函数的两个调用：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Compile and run the code again, and verify that the output behaves identically.
    Even if the former `setTimeout` was executed first, its `function` parameter is
    not scheduled to run until 2 seconds have passed.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出行为是否相同。即使先前的`setTimeout`先执行，其`function`参数也不计划在2秒后运行。
- en: 'In the `delays-1.ts` file, move the initial `console.log` to the bottom:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`delays-1.ts`文件中，将初始的`console.log`移动到文件底部：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compile and run the code again, and verify that the output behaves identically.
    This illustrates one of the most common problems with code that behaves asynchronously.
    Even though the line was at the bottom of our file, it was executed first. It's
    much harder to mentally trace code that does not follow the top-down paradigm
    we're used to.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出行为是否相同。这说明了代码行为异步时最常见的一个问题之一。即使该行位于我们文件的底部，它也是首先执行的。要心理追踪不遵循我们习惯的从上到下范式的代码要困难得多。
- en: Create a new file, `delays-2.ts`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`delays-2.ts`。
- en: 'In `delays-2.ts`, add a single call to the `setTimeout` function, and set its
    delay time to `0`. This will mean that our code needs to wait 0 milliseconds in
    order to execute:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`delays-2.ts`中，添加对`setTimeout`函数的单次调用，并将其延迟时间设置为`0`。这意味着我们的代码需要等待0毫秒才能执行：
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add a `console.log` statement after the call to `setTimeout`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`setTimeout`之后添加一个`console.log`语句：
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Save the file, and compile it with the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并使用以下命令编译它：
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Verify that the compilation ended successfully and that there is a `delays-2.js`
    file generated in the same folder. Execute it in the `node` environment with this command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认编译成功结束，并且在同一文件夹中生成了一个`delays-2.js`文件。在`node`环境中使用以下命令执行它：
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see the output looks like this:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到输出看起来像这样：
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Well, that looks unexpected. Both lines appear basically immediately, but the
    one that was in the `setTimeout` block, and was first in the code, came after
    the line at the bottom of the script. And we explicitly told `setTimeout` not
    to wait, that is, to wait 0 milliseconds before the code got executed.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嗯，这看起来有些意外。两行几乎立即就出现了，但位于`setTimeout`块中的那一行，在代码中排在第一位，却在脚本底部的行之后。我们明确地告诉`setTimeout`不要等待，也就是说，在代码执行前等待0毫秒。
- en: 'To understand what happened, we need to go back to the call queue. When the
    file was loaded, the environment detected that we had two tasks that needed to
    be done, the call to `setTimeout` and the bottom call to `console.log` (#2). So,
    those two tasks were put into the task queue. Since the stack was empty at that
    time, the `setTimeout` call started executing, and #2 was left in the task queue.
    The environment saw that it has a zero delay, so immediately took the function
    (#1), and put it *at the end* of the task queue, after #2\. So, after the `setTimeout`
    call was done, we were left with two `console.log` tasks in the queue, with #2
    being the first, and #1 being the second.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解发生了什么，我们需要回到调用队列。当文件加载时，环境检测到我们有两个任务需要完成，即对`setTimeout`的调用和脚本底部的对`console.log`的调用（#2）。因此，这两个任务被放入任务队列。由于当时栈是空的，`setTimeout`调用开始执行，而#2被留在任务队列中。环境看到它有一个零延迟，所以立即取出了函数（#1），并将其*放在*任务队列的末尾，在#2之后。因此，在`setTimeout`调用完成后，我们剩下两个`console.log`任务在队列中，#2是第一个，#1是第二个。
- en: 'They got executed sequentially, and on our console, we got #2 first, and #1
    second.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是顺序执行的，在我们的控制台中，我们首先得到#2，然后是#1。
- en: AJAX (Asynchronous JavaScript and XML)
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AJAX（异步JavaScript和XML）
- en: In the early days of the web, it was not possible to get data from a server
    once the page was loaded. That was a huge inconvenience for developing dynamic
    web pages, and it was solved by the introduction of an object called `XMLHttpRequest`.
    This object enabled developers to get data from a server after the initial page
    load – and since loading data from a server means using an external resource,
    it had to be done in an asynchronous manner (even if it has XML right in the name,
    currently, it will mostly be used for JSON data). To use this object, you'll need
    to instantiate it and use a few of its properties.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络发展的早期，一旦页面加载完成，就无法从服务器获取数据。这对开发动态网页来说是一个巨大的不便，而这个问题是通过引入一个名为`XMLHttpRequest`的对象来解决的。这个对象使开发者能够在初始页面加载后从服务器获取数据——由于从服务器加载数据意味着使用外部资源，因此它必须以异步方式进行（即使它的名字中包含XML，目前它将主要用于JSON数据）。要使用这个对象，你需要实例化它并使用它的一些属性。
- en: To illustrate its usage, we'll try to get data about William Shakespeare from
    the Open Library project. The URL that we'll use to retrieve that information
    is [https://openlibrary.org/authors/OL9388A.json](https://openlibrary.org/authors/OL9388A.json),
    and the access method that we will use is `GET`, as we will only be getting data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明其用法，我们将尝试从Open Library项目获取关于威廉·莎士比亚的数据。我们将使用以下URL来检索这些信息：[https://openlibrary.org/authors/OL9388A.json](https://openlibrary.org/authors/OL9388A.json)，我们将使用的方法是`GET`，因为我们只会获取数据。
- en: 'The data received is of a specific format, defined by Open Library, so you''ll
    start by creating an interface for the data that you will actually use. You''ll
    display only an image of the Bard (received as an array of photo IDs), and the
    name, so you can define the interface like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 收到的数据是Open Library定义的特定格式，因此你将首先为你要实际使用的数据创建一个接口。你将只显示莎士比亚的图像（作为照片ID的数组接收），以及姓名，因此你可以将接口定义如下：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, create the `XMLHttpRequest` object, and assign it to a variable called
    `xhr`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`XMLHttpRequest`对象，并将其分配给名为`xhr`的变量：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now you need to `open` a connection to our URL:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要`打开`一个连接到我们的URL：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This call doesn''t actually send anything, but it prepares the system for accessing
    the external resource. Lastly, you need to actually send the request, using the
    `send` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用实际上没有发送任何内容，但它为访问外部资源准备了系统。最后，您需要实际发送请求，使用`send`方法：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since the request is asynchronous, this call will execute and finish immediately.
    In order to actually process the data once this request is done, you need to add
    something to this object – a callback. That is a function that will not be executed
    by us, but by the `xhr` object, once some event happens. This object has several
    events, such as `onreadystatechange`, `onload`, `onerror`, `ontimeout`, and you
    can set different functions to react to different events, but in this case, you
    will just use the `onload` event. Create a function that will get the data from
    the response and show it on the web page where our script is running:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求是异步的，这个调用将立即执行并完成。为了在请求完成后实际处理数据，您需要向这个对象添加一些内容——一个回调。这是一个函数，它不会由我们执行，而是由`xhr`对象在某个事件发生时执行。这个对象有几个事件，如`onreadystatechange`、`onload`、`onerror`、`ontimeout`，您可以为不同的事件设置不同的函数来响应，但在这个情况下，您将只使用`onload`事件。创建一个函数，它将从响应中获取数据并在我们的脚本运行的网页上显示它：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this method, you will be using some properties of the `xhr` variable that
    was defined previously, such as `status`, which gives us the HTTP status code
    of the request, or `response`, which gives us the actual response. If we just
    call the `showData` method by ourselves, we''ll most likely get empty fields or
    an error, as the response will not have finished. So, we need to give this function
    to the `xhr` object, and it will use it to call the `showData` back:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，您将使用之前定义的`xhr`变量的某些属性，例如`status`，它给我们提供了请求的HTTP状态码，或者`response`，它给我们实际的响应。如果我们自己调用`showData`方法，我们很可能会得到空字段或错误，因为响应还没有完成。所以，我们需要将这个函数给`xhr`对象，它将使用它来调用`showData`回：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Save this code as `shakespeare.ts`, compile it, and add it to an HTML page
    using the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码保存为`shakespeare.ts`，编译它，并使用以下方式将其添加到HTML页面中：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will get a result similar to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下类似的结果：
- en: '![Figure 10.3: Retrieved image of William Shakespeare'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：威廉·莎士比亚的检索图像'
- en: '](img/B14508_10_03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_10_03.jpg)'
- en: 'Figure 10.3: Retrieved image of William Shakespeare'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：威廉·莎士比亚的检索图像
- en: 'Activity 10.01: Movie Browser Using XHR and Callbacks'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十.01：使用XHR和回调的影片浏览器
- en: As a TypeScript developer, you have been tasked with creating a simple page
    to view movie data. The web page will be simple, with a text input field and a
    button. When you enter the name of a movie in the search input field and press
    the button, general information about the movie will be displayed on the web page,
    along with some images relevant to the movie.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为TypeScript开发者，您被分配了一个创建一个简单的页面来查看电影数据的任务。网页将很简单，有一个文本输入字段和一个按钮。当您在搜索输入字段中输入电影名称并按下按钮时，电影的一般信息将显示在网页上，以及一些与电影相关的图像。
- en: You can use *The Movie Database* ([https://www.themoviedb.org/](https://www.themoviedb.org/))
    as a source of general data, specifically its API. You need to issue AJAX requests
    using `XmlHttpRequest`, and use the data the site provides to format your own
    object. When using an API the data will rarely, if ever, be in the format we actually
    need. This means that you will need to use several API requests to get our data,
    and piecemeal construct our object. A common TypeScript approach to this issue
    is to use two sets of interfaces – one that exactly matches the format of the
    API, and one that matches the data that you use in your application. In this activity,
    you need to use the `Api` suffix to denote those interfaces that match the API
    format.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*电影数据库*（[https://www.themoviedb.org/](https://www.themoviedb.org/））作为一般数据源，特别是它的API。您需要使用`XmlHttpRequest`发出AJAX请求，并使用网站提供的数据来格式化您自己的对象。当使用API时，数据很少，如果不是永远，会是我们需要的形式。这意味着您将需要使用多个API请求来获取我们的数据，并逐步构建我们的对象。TypeScript解决此问题的常见方法是用两组接口——一组与API格式完全匹配，另一组与您在应用程序中使用的数据匹配。在这个活动中，您需要使用`Api`后缀来表示与API格式匹配的接口。
- en: Another important thing to note is that this particular API does not allow completely
    open access. You'll need to register for an API key and then send it in each API
    request. In the setup code for this activity, three functions (`getSearchUrl`,
    `getMovieUrl`, `getPeopleUrl`) will be provided that will generate the correct
    URLs for the needed API requests, once the `apiKey` variable is set to the value
    you will receive from The Movie Database. Also provided will be the base HTML,
    styling, as well as the code used to actually display the data – all that is missing
    is the data itself.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要事项是，这个特定的API不允许完全开放访问。您需要注册API密钥，然后在每个API请求中发送它。在本活动的设置代码中，将提供三个函数（`getSearchUrl`、`getMovieUrl`、`getPeopleUrl`），这些函数将在将`apiKey`变量设置为从The
    Movie Database接收到的值后生成所需的API请求的正确URL。还将提供基本HTML、样式以及实际显示数据的代码——唯一缺少的是数据本身。
- en: 'Those resources are listed here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源在此列出：
- en: '`display.ts` – A TypeScript file that houses the `showResult` and `clearResults`
    methods, which you will call to display a movie and clear the screen, respectively.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display.ts` – 一个TypeScript文件，包含`showResult`和`clearResults`方法，您将调用这些方法来显示电影和清除屏幕。'
- en: '`interfaces.ts` – A TypeScript file that contains the interfaces that you will
    use. All interfaces that have an `Api` suffix are objects that you will receive
    from The Movie Database API, and the rest (`Movie` and `Character`) will be used
    to display the data.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interfaces.ts` – 一个TypeScript文件，包含您将使用的接口。所有带有`Api`后缀的接口都是您将从The Movie Database
    API接收到的对象，其余的（`Movie`和`Character`）将用于显示数据。'
- en: '`script.ts` – A TypeScript file that has some boilerplate code that will start
    the application. The `search` function is here, and that function will be the
    main focus of this activity.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script.ts` – 一个包含启动应用程序的样板代码的TypeScript文件。`search`函数在这里，这个函数将是本活动的重点。'
- en: '`index.html` – An HTML file that has the basic markup for our web page.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html` – 一个包含我们网页基本标记的HTML文件。'
- en: '`styles.css` – A style sheet file that is used to style the results.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styles.css` – 一个用于样式化结果的样式表文件。'
- en: 'The following steps should help you with the solution:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将有助于您解决问题：
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The code files for this activity can be found at [https://packt.link/Qo4dB](https://packt.link/Qo4dB).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的代码文件可以在[https://packt.link/Qo4dB](https://packt.link/Qo4dB)找到。
- en: In the `script.ts` file, locate the `search` function and verify that it takes
    a single string parameter and that its body is empty.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script.ts`文件中定位`search`函数，并验证它接受一个字符串参数，并且其主体为空。
- en: Construct a new `XMLHttpRequest` object.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个新的`XMLHttpRequest`对象。
- en: Construct a new string for the search result URL using the `getSearchUrl` method.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getSearchUrl`方法构造一个新的搜索结果URL字符串。
- en: Call the `open` and `send` methods of the `xhr` object.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`xhr`对象的`open`和`send`方法。
- en: Add an event handler for the `xhr` object's `onload` event. Take the response
    and parse it as a JSON object. Store the result in a variable of the `SearchResultApi`
    interface. This data will have the results of our search in a `results` field.
    If you get no results, this means that our search failed.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`xhr`对象的`onload`事件添加一个事件处理器。获取响应并将其解析为JSON对象。将结果存储在`SearchResultApi`接口的变量中。此数据将在`results`字段中包含我们的搜索结果。如果没有结果，这意味着我们的搜索失败。
- en: If the search returned no results, call the `clearResults` method.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索没有返回结果，调用`clearResults`方法。
- en: If the search returned some results, just take the first one and store it in
    a variable, ignoring the other ones.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索返回了一些结果，只需取第一个并将其存储在变量中，忽略其他结果。
- en: Inside the `onload` handler, in the successful search branch, create a new `XMLHttpRequest`
    object.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onload`处理器内部，在成功的搜索分支中，创建一个新的`XMLHttpRequest`对象。
- en: Construct a new string for the search result URL using the `getMovieUrl` method.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getMovieUrl`方法构造一个新的搜索结果URL字符串。
- en: Call the `open` and `send` method of the constructed `xhr` object.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用构造的`xhr`对象的`open`和`send`方法。
- en: Add an event handler for the `xhr` objects's `onload` event. Take the response,
    and parse it as a JSON object. Store the result in a variable of the `MovieResultApi`
    interface. This response will have the general data for our movie, specifically,
    everything except the people who were involved in the movie. You will need to
    have another call to the API to get the data about the people.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`xhr`对象的`onload`事件添加一个事件处理器。获取响应，并将其解析为JSON对象。将结果存储在`MovieResultApi`接口的变量中。此响应将包含我们电影的通用数据，具体来说，是除了参与电影的人员之外的所有内容。您将需要另一个API调用以获取有关人员的数据。
- en: Inside the `onload` handler, in the successful search branch, create a new `XMLHttpRequest`
    object.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onload`处理程序内部，在成功的搜索分支中，创建一个新的`XMLHttpRequest`对象。
- en: Construct a new string for the search result URL using the `getPeopleUrl` method.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getPeopleUrl`方法构造一个新的搜索结果URL字符串。
- en: Call the `open` and `send` method of the constructed `xhr` object.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用构造的`xhr`对象的`open`和`send`方法。
- en: Add an event handler for the `xhr` object's `onload` event. Take the response,
    and parse it as a JSON object. Store the result in a variable of the `PeopleResultApi`
    interface. This response will have data about the people who were involved in
    the movie.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`xhr`对象的`onload`事件添加事件处理程序。获取响应，并将其解析为JSON对象。将结果存储在`PeopleResultApi`接口的变量中。此响应将包含有关参与电影的人物数据。
- en: Now you actually have all the data you need, so you can create your own object
    inside the people `onload` handler, which is inside the movie `onload` handler,
    which is inside the search `onload` handler.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你实际上已经拥有了所有需要的数据，因此你可以在`people onload`处理程序内部创建自己的对象，该处理程序位于电影`onload`处理程序内部，而电影`onload`处理程序又位于搜索`onload`处理程序内部。
- en: The people data has `cast` and `crew` properties. You'll only take the first
    six cast members, so first sort the `cast` property according to the `order` property
    of the cast members. Then slice off the first six cast members into a new array.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人物数据具有`cast`和`crew`属性。你将只取前六个演员，所以首先根据演员的`order`属性对`cast`属性进行排序。然后从第一个六个演员中切出一个新的数组。
- en: Transform the cast data (which is `CastResultApi` objects) into our own `Character`
    objects. You need to map the `character` field of `CastResultApi` to the `name`
    field of `Character`, the `name` field to the `actor` name, and the `profile_path`
    field to the `image` property.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将演员数据（即`CastResultApi`对象）转换为我们的`Character`对象。你需要将`CastResultApi`的`character`字段映射到`Character`的`name`字段，将`name`字段映射到演员名字，将`profile_path`字段映射到`image`属性。
- en: From the `crew` property of the people data, you'll only need the director and
    the writer. Since there can be multiple directors and writers, you'll get the
    names of all directors and writers and concatenate them, respectively. For the
    directors, from the `crew` property, filter the people who have a `department`
    of `Directing` and a `job` of `Director`. For those objects, take the `name` property,
    and `join` it together with an `&` in between.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从人物数据的`crew`属性中，你只需要导演和编剧。由于可能有多个导演和编剧，你需要分别连接所有导演和编剧的名字。对于导演，从`crew`属性中筛选出具有`Directing`部门`Director`职位的导演。对于这些对象，取其`name`属性，并用`&`连接起来。
- en: For the writers, from the `crew` property, filter the people who have a `department`
    of `Writing` and a `job` of `Writer`. For those objects, take the `name` property,
    and `join` it together with an `&` in between.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从人物数据的`crew`属性中，你只需要导演和编剧。由于可能有多个导演和编剧，你将分别连接所有导演和编剧的名字。对于导演，从`crew`属性中筛选出具有`Directing`部门`Director`职位的导演。对于这些对象，取其`name`属性，并用`&`连接起来。
- en: Create a new `Movie` object (using object literal syntax). Fill in all the properties
    of the `Movie` object using the data from the movie and people responses you prepared
    so far.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Movie`对象（使用对象字面量语法）。使用你迄今为止准备的电影和人物响应中的数据填写`Movie`对象的全部属性。
- en: Call the `showResults` function with the movie you constructed.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你构造的电影调用`showResults`函数。
- en: In your parent directory (`Activity01` in this case), install dependencies with `npm
    i`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的父目录（在这种情况下为`Activity01`）中，使用`npm i`安装依赖项。
- en: Compile the program using `tsc ./script.ts ./interfaces.ts ./display.ts`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tsc ./script.ts ./interfaces.ts ./display.ts`编译程序。
- en: Verify that the compilation ended successfully.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功结束。
- en: Open `index.html` using the browser of your choice.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你选择的浏览器打开`index.html`。
- en: 'You should see the following in your browser:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在浏览器中看到以下内容：
- en: '![Figure 10.4: The final web page'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.4：最终的网页'
- en: '](img/B14508_10_04.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.4：最终的网页'
- en: 'Figure 10.4: The final web page'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：最终的网页
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor431).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor431)找到。
- en: We will improve this application further in *Activity 10.02, Movie Browser using
    fetch and Promises,* and *Activity 10.03, Movie Browser using fetch and async/await*.
    However, before we do that, you need to learn about Promises and `async`/`await`
    in TypeScript.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*活动10.02，使用fetch和Promises的电影浏览器*和*活动10.03，使用fetch和async/await的电影浏览器*中进一步改进此应用程序。然而，在我们这样做之前，你需要了解TypeScript中的Promises和`async`/`await`。
- en: Promises
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: Using callbacks for asynchronous development gets the job done – and that is
    great. However, in many applications, our code needs to use external or asynchronous
    resources all the time. So, very quickly, we'll get to a situation where inside
    our callback, there is another asynchronous call, which requires a callback inside
    the callback, which in turn needs a callback on its own….
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调函数进行异步开发可以完成任务——这真是太好了。然而，在许多应用中，我们的代码需要一直使用外部或异步资源。所以，很快我们就会遇到这样的情况：在我们的回调函数内部，还有一个异步调用，这需要回调函数嵌套在回调函数中，而这个回调函数又需要自己的回调……
- en: It was (and in some cases, it still is) not uncommon to be a dozen levels deep
    inside the callback hole.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，深入回调函数的层级多达十多层并不罕见。
- en: 'Exercise 10.03: Counting to Five'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.03：数到五
- en: 'In this exercise, we''ll create a function that, when executed, will output
    the English words one through five. Each word will appear on the screen 1 second
    after the last word was displayed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，当执行时，将输出从一至五的英文单词。每个单词将在上一个单词显示后 1 秒钟出现在屏幕上：
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://packt.link/zD7TT](https://packt.link/zD7TT).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在 [https://packt.link/zD7TT](https://packt.link/zD7TT) 找到。
- en: Create a new file, `counting-1.ts`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`counting-1.ts`。
- en: 'In `counting-1.ts`, add an array with the English number names up to and including
    five:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `counting-1.ts` 中添加一个包含从一至五（包括五）的英文数字名称的数组：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add a single call to the `setTimeout` function, and print out the first number
    after a second:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `setTimeout` 函数进行单个调用，并在一秒后打印出第一个数字：
- en: '[PRE37]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Save the file, and compile it with the following command:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并使用以下命令进行编译：
- en: '[PRE38]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Verify that the compilation ended successfully and that there is a `counting-1.js`
    file generated in the same folder. Execute it in the `node` environment with this
    command:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功结束，并在同一文件夹中生成了一个 `counting-1.js` 文件。在 `node` 环境中使用此命令执行它：
- en: '[PRE39]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will see the output looks like this:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到输出看起来像这样：
- en: '[PRE40]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The line should appear 1 second after the application was run.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行应该在应用程序运行后 1 秒出现。
- en: 'In the `counting-1.ts` file, inside the `setTimeout` function, below `console.log`,
    add another, nested, call to the `setTimeout` function:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `counting-1.ts` 文件中，在 `setTimeout` 函数内部，在 `console.log` 下方添加另一个嵌套的 `setTimeout`
    函数调用：
- en: '[PRE41]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Compile and run the code again, and verify that the output has an extra line,
    displayed 1 second after the first:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出是否多了一行，在第一个输出后 1 秒显示：
- en: '[PRE42]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `counting-1.ts` file, inside the nested `setTimeout` function, above
    `console.log`, add another nested call to the `setTimeout` function:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `counting-1.ts` 文件中，在嵌套的 `setTimeout` 函数内部，在 `console.log` 之上添加另一个嵌套的 `setTimeout`
    函数调用：
- en: '[PRE43]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the innermost `setTimeout` function, below `console.log`, add yet another
    nested call to `setTimeout`, and repeat the process for the fifth number as well.
    The code should look like this:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最内层的 `setTimeout` 函数中，在 `console.log` 下方添加另一个嵌套的 `setTimeout` 函数调用，并且对第五个数也要重复这个过程。代码应该看起来像这样：
- en: '[PRE44]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Compile and run the code again, and verify that the output appears in the correct
    order as shown:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出是否按正确顺序显示，如下所示：
- en: '[PRE45]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this simple example, we implemented a simple functionality – counting to
    five. But as you can already see, the code is becoming extremely messy. Just imagine
    if we needed to count to 20 instead of 5\. That would be a downright unmaintainable
    mess. While there are ways to make this specific code look a bit better and more
    maintainable, in general, that's not the case. The use of callbacks is intrinsically
    connected with messy and hard-to-read code. And messy and hard-to-read code is
    the best place for bugs to hide, so callbacks do have a reputation of being the
    cause of difficult-to-diagnose bugs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们实现了一个简单的功能——数到五。但正如你所能看到的，代码正变得越来越混乱。想象一下，如果我们需要数到 20 而不是 5 会怎样。那将是一个完全无法维护的混乱。虽然有一些方法可以使这段特定的代码看起来更好、更易于维护，但总的来说，情况并非如此。回调函数的使用本质上与混乱且难以阅读的代码相关。而混乱且难以阅读的代码是错误隐藏的最佳场所，因此回调函数确实有导致难以诊断的错误的声誉。
- en: An additional problem with callbacks is that there cannot be a unified API across
    different objects. For example, we needed to explicitly know that in order to
    receive data using the `xhr` object, we need to call the `send` method and add
    a callback for the `onload` event. And we needed to know that in order to check
    whether the request was successful or not, we have to check the `status` property
    of the `xhr` object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的另一个问题是，不同对象之间不能有一个统一的 API。例如，我们需要明确知道，为了使用 `xhr` 对象接收数据，我们需要调用 `send` 方法并为
    `onload` 事件添加回调。并且我们需要知道，为了检查请求是否成功，我们必须检查 `xhr` 对象的 `status` 属性。
- en: What are Promises?
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺是什么？
- en: 'Fortunately, we can promise you that there is a better way. That way was initially
    done by third-party libraries, but it has proven to be so useful and so widely
    adopted that it was included in the JavaScript language itself. The logic behind
    this solution is rather simple. Each asynchronous call is basically a promise
    that, sometime in the future, some task will be done and some result will be acquired.
    As with promises in real life, we can have three different states for a promise:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以向您保证有一种更好的方法。这种方法最初是由第三方库实现的，但它已被证明非常有用且被广泛采用，以至于它被包含在 JavaScript 语言本身中。这个解决方案背后的逻辑相当简单。每个异步调用基本上是一个承诺，在未来的某个时刻，某个任务将被完成，某个结果将被获得。就像现实生活中的承诺一样，我们可以为一个承诺有三种不同的状态：
- en: A promise might not be resolved yet. This means that we need to wait some more
    time before we get a result. In TypeScript, we call these promises "pending."
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个承诺可能尚未解决。这意味着我们需要等待更多的时间才能得到结果。在 TypeScript 中，我们称这些承诺为“挂起。”
- en: A promise might be resolved negatively – the one who promised broke the promise.
    In TypeScript, we call these promises "rejected" and usually we get some kind
    of an error as a result.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个承诺可能被负面地解决——许诺的人违背了承诺。在 TypeScript 中，我们称这些承诺为“拒绝”，通常我们会因此得到某种错误。
- en: A promise might be resolved positively – the one who promised fulfilled the
    promise. In TypeScript, we call these promises "resolved" and we get a value out
    of them – the actual result.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个承诺可能被正面解决——许诺的人履行了承诺。在 TypeScript 中，我们称这些承诺为“解决”，并且我们可以从它们中获得一个值——实际的结果。
- en: And since promises are objects themselves, this means that promises can be assigned
    to variables, returned from functions, passed as arguments into functions, and
    lots of other things we're able to do with regular objects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于承诺本身就是对象，这意味着承诺可以被分配给变量，从函数中返回，作为函数的参数传递，以及我们可以用常规对象做的许多其他事情。
- en: Another great feature of promises is that it is relatively easy to write a promisified
    wrapper around an existing callback-based function. Let's try to promisify the
    Shakespeare example. We'll start by taking a look at the `showData` function.
    This function needs to do a lot of things, and those things are sometimes not
    connected to one another. It needs to both process the `xhr` variable to extract
    the data, and it needs to know what to do with that data. So, if the API we're
    using changes, we'll need to change our function. If the structure of our web
    page changes, that is, if we need to display a `div` instead of an `h1` element,
    we'll need to change our function. If we need to use the author data for something
    else, we'll also need to change our function. Basically, if anything needs to
    happen to the response, it needs to happen then and there. We have no way to somehow
    defer that decision to another piece of code. This creates unnecessary coupling
    inside our code, which makes it harder to maintain.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的另一个伟大特性是，围绕现有的基于回调的函数编写一个承诺包装器相对容易。让我们尝试将莎士比亚的例子承诺化。我们将首先查看 `showData` 函数。这个函数需要做很多事情，而且这些事情有时并不相互关联。它需要处理
    `xhr` 变量以提取数据，并且它需要知道如何处理这些数据。因此，如果我们所使用的 API 发生变化，我们需要更改我们的函数。如果我们的网页结构发生变化，也就是说，如果我们需要显示一个
    `div` 而不是 `h1` 元素，我们也需要更改我们的函数。如果我们需要将作者数据用于其他目的，我们也需要更改我们的函数。基本上，如果响应需要发生任何事情，它必须在那时发生。我们无法将此决策推迟到另一段代码中。这在我们代码中创建了不必要的耦合，使得维护变得更加困难。
- en: 'Let''s change that. We can create a new function that will return a promise,
    which will provide the data about the author. It will have no idea what that data
    will be used for:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变一下。我们可以创建一个新的函数，该函数将返回一个承诺，该承诺将提供关于作者的数据。它将不知道这些数据将被用于什么：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function returns a `Promise` object, which was created using the `Promise`
    constructor. This constructor takes a single argument, which is a function. That
    function takes two arguments as well (also functions), which are by convention
    called `resolve` and `reject`. You can see that the function inside the constructor
    just creates an `xhr` object, calls its `open` and `send` methods, sets its `onload`
    property, and returns. So, basically, nothing gets done, except that the request
    is fired off.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个由 `Promise` 构造函数创建的 `Promise` 对象。这个构造函数接受一个单一参数，即一个函数。该函数也接受两个参数（也是函数），按照惯例称为
    `resolve` 和 `reject`。你可以看到构造函数内部的函数只是创建了一个 `xhr` 对象，调用其 `open` 和 `send` 方法，设置其
    `onload` 属性，然后返回。所以，基本上，没有做任何事情，除了发起请求。
- en: A promise thus created will be in the pending state. And the promise stays in
    this state until one of the `resolve` or `reject` functions is called inside the
    body. If the `reject` function is called, it will transition to a rejected state,
    and we'll be able to use the `catch` method of the `Promise` object to handle
    the error, and if the `resolve` function is called, it will transition to the
    resolved state, and we'll be able to use the `then` method of the `Promise` object.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这样创建的Promise将处于挂起状态。并且Promise将保持这种状态，直到在主体内部调用 `resolve` 或 `reject` 函数之一。如果调用
    `reject` 函数，它将过渡到拒绝状态，我们可以使用 `Promise` 对象的 `catch` 方法来处理错误；如果调用 `resolve` 函数，它将过渡到解决状态，我们可以使用
    `Promise` 对象的 `then` 方法。
- en: 'One thing that we should note is that this method does nothing that is UI-related.
    It does not print any errors on the console or change any DOM elements. It simply
    promises us that it will get us an `OpenLibraryAuthor` object. Now, we''re free
    to use this object however we want:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意的一件事是，这个方法不执行任何与UI相关的操作。它不会在控制台打印任何错误或更改任何DOM元素。它只是承诺给我们一个 `OpenLibraryAuthor`
    对象。现在，我们可以随意使用这个对象：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this piece of code, we call the `getShakespeareData` data function, and then
    on its result, we're calling two methods, `then` and `catch`. The `then` method
    only executes if the promise is in the resolved state and it takes in a function
    that will get the result. The `catch` method only executes if the promise is in
    the rejected state, and it will get the error as an argument to its function.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们调用 `getShakespeareData` 数据函数，然后在其结果上调用两个方法，`then` 和 `catch`。`then`
    方法仅在Promise处于已解决状态时执行，并接受一个将获取结果的函数。`catch` 方法仅在Promise处于拒绝状态时执行，并将错误作为其函数的参数。
- en: One important note for the `then` and `catch` methods – they also return promises.
    This means that `Promise` objects are chainable, so instead of going in depth,
    as we did with callbacks, we can go in length, so to say. To illustrate that point,
    let's count to five once again.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `then` 和 `catch` 方法的一个重要注意事项——它们也返回Promise。这意味着 `Promise` 对象是可链的，所以与其深入，就像我们处理回调那样，我们可以说得更长。为了说明这一点，让我们再次数到五。
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A more comprehensive discussion of Promises will be presented in *Chapter 12,
    Guide to Promises in TypeScript*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第12章，TypeScript中的Promise指南* 中将更全面地讨论Promise。
- en: 'Exercise 10.04: Counting to Five with Promises'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.04：使用Promise计数到五
- en: 'In this exercise, we''ll create a function that, when executed, will output
    the English words one through five. Each word will appear on the screen 1 second
    after the last one was displayed:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，当执行时，将输出从一至五的英语单词。每个单词将在上一个单词显示后1秒钟出现在屏幕上：
- en: Note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://packt.link/nlge8](https://packt.link/nlge8).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在[https://packt.link/nlge8](https://packt.link/nlge8)找到。
- en: Create a new file, `counting-2.ts`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`counting-2.ts`。
- en: 'In `counting-2.ts`, add an array with the English number names up to and including
    five:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `counting-2.ts` 中，添加一个包含从一到五（包括五）的英语数字名称的数组：
- en: '[PRE48]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add a promisified wrapper of the `setTimeout` function. This wrapper will only
    execute when the given timeout expires:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `setTimeout` 函数的包装器。这个包装器只有在指定的超时时间到期时才会执行：
- en: '[PRE49]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Since our promise will not return any meaningful result, instead just resolving
    after a given amount of milliseconds, we have provided `void` as its type.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的Promise不会返回任何有意义的值，而是在给定数量的毫秒后简单地解决，因此我们提供了 `void` 作为其类型。
- en: 'Call the `delay` method with a parameter of `1000`, and after its resolution,
    print out the first number:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数 `1000` 调用 `delay` 方法，并在其解决后打印出第一个数字：
- en: '[PRE50]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Save the file, and compile it with the following command:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并使用以下命令编译它：
- en: '[PRE51]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Verify that the compilation ended successfully and that there is a `counting-2.js`
    file generated in the same folder. Execute it in the `node` environment with this
    command:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功完成，并在同一文件夹中生成一个`counting-2.js`文件。使用以下命令在`node`环境中执行它：
- en: '[PRE52]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You will see the output looks like this:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到输出看起来像这样：
- en: '[PRE53]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The line should appear 1 second after the application was run.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该行应在应用程序运行后1秒出现。
- en: 'In the `counting-2.ts` file, after the `then` line, add another `then` line.
    Inside it, call the `delay` method again, with a timeout of 1 second:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`counting-2.ts`文件中，在`then`行之后，添加另一个`then`行。在其内部，再次调用`delay`方法，超时时间为1秒：
- en: '[PRE54]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can do this because the result of the `then` method is `Promise`, which has
    its own `then` method.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以这样做，因为`then`方法的结果是`Promise`，它有自己的`then`方法。
- en: 'After the last `then` line, add another `then` line, inside which you print
    out the second number:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一个`then`行之后，添加另一个`then`行，在其内部打印出第二个数字：
- en: '[PRE55]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Compile and run the code again, and verify that the output has an extra line,
    displayed 1 second after the first.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出是否多了一行，在第一个输出后1秒显示。
- en: 'In the `counting-2.ts` file, add two more `then` lines for the third, fourth,
    and fifth numbers as well. The code should look like this:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`counting-2.ts`文件中，为第三个、第四个和第五个数字添加两个额外的`then`行。代码应如下所示：
- en: '[PRE56]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Compile and run the code again, and verify that the output appears in the correct
    order.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出是否按正确顺序出现。
- en: Let's compare this code with the code of the previous exercise. It's not the
    cleanest code, but its function is relatively obvious. We can see how we could
    expand this code to count to 20\. And the major benefit here is that this code,
    while asynchronous, is still sequential. We can reason about it, and the lines
    that are at the top will execute before the lines at the bottom. Furthermore,
    since we have objects now, we can even refactor this code into an even simpler
    and more extensible format – we can use a `for` loop.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们比较一下这段代码与之前练习中的代码。这不是最干净的代码，但其功能相对明显。我们可以看到如何扩展此代码以计数到20。这里的主要好处是，尽管这段代码是异步的，但它仍然是顺序执行的。我们可以对其进行分析，并且位于顶部的行将在位于底部的行之前执行。此外，由于我们现在有了对象，我们甚至可以将此代码重构为更简单、更易于扩展的格式——我们可以使用`for`循环。
- en: 'In the `counting-2.ts` file, remove the lines starting with `delay(1000)` until
    the end of the file. Add a line that will define a resolved promise:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`counting-2.ts`文件中，删除从`delay(1000)`开始的直到文件末尾的行。添加一行来定义一个已解决的promise：
- en: '[PRE57]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add a `for` loop that, for each number of the `numbers` array, will add to
    the `promise` chain a delay of 1 second, and print the number:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`for`循环，对于`numbers`数组中的每个数字，将1秒的延迟添加到promise链中，并打印该数字：
- en: '[PRE58]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Compile and run the code again, and verify that the output appears in the correct
    order as shown:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出是否按正确顺序出现，如下所示：
- en: '[PRE59]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Activity 10.02: Movie Browser Using fetch and Promises'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十点零二：使用fetch和Promises实现电影浏览器
- en: In this activity, we will be repeating the previous activity. The major difference
    is that, instead of using `XMLHttpRequest` and its `onload` method, we'll be using
    the `fetch` web API. In contrast to the `XMLHttpRequest` class, the `fetch` web
    API returns a `Promise` object, so instead of nesting our callbacks to have multiple
    API calls, we can have a chain of promise resolutions that will be far easier
    to understand.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动将重复之前的活动。主要区别在于，我们不会使用`XMLHttpRequest`及其`onload`方法，而是使用`fetch`网络API。与`XMLHttpRequest`类相比，`fetch`网络API返回一个`Promise`对象，因此我们不需要嵌套回调以进行多个API调用，我们可以有一个更易于理解的promise解析链。
- en: The activity has the same files and resources as the previous activity.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动与之前的活动具有相同的文件和资源。
- en: 'The following steps should help you with the solution:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将有助于您解决问题：
- en: In the `script.ts` file, locate the `search` function and verify that it takes
    a single string parameter and that its body is empty.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script.ts`文件中，找到`search`函数并验证它是否接受一个字符串参数，并且其主体为空。
- en: Above the `search` function, create a helper function called `getJsonData`.
    This function will use the `fetch` API to get data from an endpoint and format
    it as JSON. It should take a single string called `url` as a parameter, and it
    should return a `Promise`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`search`函数上方，创建一个名为`getJsonData`的辅助函数。此函数将使用`fetch` API从端点获取数据并将其格式化为JSON。它应接受一个名为`url`的单个字符串参数，并且它应返回一个`Promise`。
- en: In the body of the `getJsonData` function, add code that calls the `fetch` function
    with the `url` parameter, and `then` call the `json` method on the returned response.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `getJsonData` 函数的主体中，添加调用带有 `url` 参数的 `fetch` 函数的代码，然后对返回的响应调用 `json` 方法。
- en: In the `search` method, construct a new string for the search result URL using
    the `getSearchUrl` method.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `search` 方法中，使用 `getSearchUrl` 方法构建一个新的搜索结果 URL 字符串。
- en: Call the `getJsonData` function with the `searchUrl` as a parameter.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `searchUrl` 作为参数调用 `getJsonData` 函数。
- en: Add a `then` handler to the promise returned from `getJsonData`. The handler
    takes a single parameter of the type `SearchResultApi`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `getJsonData` 返回的 promise 上添加一个 `then` 处理程序。处理程序接受一个类型为 `SearchResultApi`
    的单个参数。
- en: In the body of the handler, check whether we have any results and if we don't,
    throw an error. If we do have results, return the first item. Note that the handler
    returns an object with `id` and `title` properties, but the `then` method actually
    returns a `Promise` of that data. This means that after the handler, we can chain
    other `then` calls.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理程序的主体中，检查是否有任何结果，如果没有，则抛出错误。如果有结果，则返回第一个项目。注意，处理程序返回一个具有 `id` 和 `title` 属性的对象，但
    `then` 方法实际上返回的是该数据的 promise。这意味着在处理程序之后，我们可以链式调用其他 `then` 调用。
- en: Add another `then` call to the previous handler. This handler will take a `movieResult`
    parameter that contains the `id` and `title` of the movie. Use the `id` property
    to call the `getMovieUrl` and `getPeopleUrl` methods to, respectively, get the
    correct URLs for the movie details and for the cast and crew.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前的处理程序中添加另一个 `then` 调用。此处理程序将接受一个包含电影 `id` 和 `title` 的 `movieResult` 参数。使用
    `id` 属性调用 `getMovieUrl` 和 `getPeopleUrl` 方法，分别获取电影详情和演员阵容及制作团队的正确 URL。
- en: After getting the URLs, call the `getJsonData` function with both, and assign
    the resulting values to variables. Note that the `getJsonData(movieUrl)` call
    will return a `Promise` of `MovieResultApi`, and `getJsonData(peopleUrl)` will
    return a `Promise` of `PeopleResultApi`. Assign those result values to variables
    called `dataPromise` and `peoplePromise`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取到 URL 后，使用这两个 URL 调用 `getJsonData` 函数，并将结果值分配给变量。注意，`getJsonData(movieUrl)`
    调用将返回一个 `MovieResultApi` 的 promise，而 `getJsonData(peopleUrl)` 将返回一个 `PeopleResultApi`
    的 promise。将这些结果值分配给名为 `dataPromise` 和 `peoplePromise` 的变量。
- en: Call the static `Promise.all` method with `dataPromise` and `peoplePromise`
    as parameters. This will create another promise based on those two values, and
    this promise will be resolved successfully if and only if both (that is, all)
    promises that are contained within resolve successfully. Its return value will
    be a `Promise` of an array of results.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dataPromise` 和 `peoplePromise` 作为参数调用静态 `Promise.all` 方法。这将基于这两个值创建另一个 promise，并且只有当包含在内的所有
    promise 都成功解析时，这个 promise 才会成功解析。它的返回值将是一个包含结果的数组 promise。
- en: Return the promise generated by the `Promise.all` call from the handler.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从处理程序返回由 `Promise.all` 调用生成的 promise。
- en: Add another `then` handler to the chain. This handler will take the array returned
    from `Promise.all` as a single parameter.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链中添加另一个 `then` 处理程序。此处理程序将 `Promise.all` 返回的数组作为单个参数。
- en: Deconstruct the parameter into two variables. The first element of the array
    should be the `movieData` variable of type `MovieResultApi`, and the second element
    of the array should be the `peopleData` variable of type `PeopleResultApi`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数解构为两个变量。数组的第一元素应该是 `movieData` 变量，其类型为 `MovieResultApi`，数组的第二元素应该是 `peopleData`
    变量，其类型为 `PeopleResultApi`。
- en: The people data has `cast` and `crew` properties. We'll only take the first
    six cast members, so first sort the `cast` property according to the `order` property
    of the cast members. Then slice off the first six cast members into a new array.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人物数据有 `cast` 和 `crew` 属性。我们只取前六个演员，所以首先根据演员的 `order` 属性对 `cast` 属性进行排序。然后从新数组中截取前六个演员。
- en: Transform the cast data (which is `CastResultApi` objects) into your own `Character`
    objects. We need to map the `character` field of `CastResultApi` to the `name`
    field of `Character`, the `name` field to the `actor` name, and the `profile_path`
    field to the `image` property.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将演员数据（即 `CastResultApi` 对象）转换为你的 `Character` 对象。我们需要将 `CastResultApi` 的 `character`
    字段映射到 `Character` 的 `name` 字段，将 `name` 字段映射到演员名字，将 `profile_path` 字段映射到 `image`
    属性。
- en: From the `crew` property of the people data, we'll only need the director and
    the writer. Since there can be multiple directors and writers, we'll get the names
    of all directors and writers and concatenate them, respectively. For the directors,
    from the `crew` property, filter the people who have a `department` of `Directing`
    and a `job` of `Director`. For those objects, take the `name` property, and `join`
    it together with an `&` in between.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从人物数据的`crew`属性中，我们只需要导演和编剧。由于可能有多个导演和编剧，我们将分别连接所有导演和编剧的名字。对于导演，从`crew`属性中，筛选出那些有`Directing`部门且职位为`Director`的人。对于这些对象，取出`name`属性，并用`&`符号连接起来。
- en: For the writers, from the `crew` property, filter the people who have a `department`
    of `Writing` and a `job` of `Writer`. For those objects, take the `name` property,
    and `join` it together with an `&` in between.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于作家，从`crew`属性中筛选出那些有`Writing`部门且职位为`Writer`的人。对于这些对象，取出`name`属性，并用`&`符号连接起来。
- en: Create a new `Movie` object (using object literal syntax). Fill in all the properties
    of the `Movie` object using the data from the movie and people responses we've
    prepared so far.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Movie`对象（使用对象字面量语法）。使用我们迄今为止准备的电影和人物响应数据填写`Movie`对象的全部属性。
- en: Return the `Movie` object from the handler.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从处理器返回`Movie`对象。
- en: Note that we did not do any UI interactions in our code. We just received a
    string, did some promise calls, and returned a value. The UI work can now be done
    in UI-oriented code. In this case, that's in the `click` event handler of the
    `search` button. We should simply add a `then` handler to the `search` call that
    will call the `showResults` method, and a `catch` handler that will call the `clearResults`
    method.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们在代码中没有进行任何UI交互。我们只是接收了一个字符串，进行了一些promise调用，并返回了一个值。现在，UI工作可以在面向UI的代码中完成。在这种情况下，是在`search`按钮的`click`事件处理器中。我们应该简单地为`search`调用添加一个`then`处理器，该处理器将调用`showResults`方法，并添加一个`catch`处理器，该处理器将调用`clearResults`方法。
- en: Although we used `fetch` and promises in this activity, and our code is now
    much more efficient but complex, the basic function of the website will be the
    same and you should see an output similar to the previous activity.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这次活动中使用了`fetch`和promise，并且我们的代码现在更加高效但复杂，网站的基本功能将保持不变，你应该会看到一个与之前活动类似的输出。
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this activity can be found at [https://packt.link/IeDTF](https://packt.link/IeDTF).
    The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor433).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的代码文件可以在[https://packt.link/IeDTF](https://packt.link/IeDTF)找到。本活动的解决方案可以通过[这个链接](B14508_Solution_ePub.xhtml#_idTextAnchor433)找到。
- en: async/await
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: async/await
- en: Promises solved the problem of callbacks quite nicely. However, often, they
    carry with them lots of unneeded fluff. We need to write lots of `then` calls,
    and we need to be careful not to forget to close any parentheses.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Promises很好地解决了回调问题。然而，它们往往伴随着许多不必要的冗余。我们需要编写很多`then`调用，并且要小心不要忘记关闭任何括号。
- en: The next step is to add a piece of syntactic sugar to our TypeScript skills.
    Unlike the other things in this chapter, this feature originated in TypeScript,
    and was later adopted in JavaScript as well. I'm talking about the `async`/`await`
    keywords. These are two separate keywords, but they are always used together,
    so the whole feature became known as `async`/`await`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向我们的TypeScript技能中添加一点语法糖。与其他章节中的内容不同，这个特性最初源于TypeScript，后来也被JavaScript采纳。我指的是`async`/`await`关键字。这两个关键字是分开的，但它们总是一起使用，所以整个特性被称为`async`/`await`。
- en: 'What we do is we can add the `async` modifier to a certain function, and then,
    in that function, we can use the `await` modifier to execute promises easily.
    Let''s go once more to our Shakespearean example, and let''s wrap the code we
    used to call `getShakespeareData` inside another function, simply called `run`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给某个函数添加`async`修饰符，然后，在那个函数中，我们可以使用`await`修饰符轻松地执行promise。让我们再次回到我们的莎士比亚示例，并将我们用来调用`getShakespeareData`的代码包裹在一个名为`run`的函数中：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code is functionally equivalent to the code we had previously. But now,
    we have a function that we can mark as an `async` function, like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在功能上与之前的代码等效。但现在，我们有一个可以标记为`async`函数的函数，如下所示：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we''re allowed to just get the result of a promise and put it inside of
    a variable. So, the whole `then` invocation will become this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接获取promise的结果并将其放入变量中。所以整个`then`调用将变成这样：
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can see that we don''t have any wrapping function calls anymore. The `catch`
    invocation can be replaced with a simple `try`/`catch` construct, and the final
    version of the `run` function will look like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们不再有任何包装函数调用了。可以将`catch`调用替换为简单的`try`/`catch`结构，最终版本的`run`函数将如下所示：
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You will notice that the amount of code that is deeply nested is drastically
    reduced. Now we can look at the code, and have a good idea of what it does, just
    from a quick glance. This is still the same, deeply asynchronous code, the only
    difference is that it looks almost synchronous and definitely sequential.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到深度嵌套的代码量大大减少了。现在我们可以查看代码，并从快速浏览中了解它做什么，这仍然是相同的深度异步代码，唯一的区别是它看起来几乎是同步的，并且绝对是顺序的。
- en: 'Exercise 10.05: Counting to Five with async and await'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.05：使用async和await计数到五
- en: 'In this exercise, we''ll create a function that, when executed, will output
    the English words one through five. Each word will appear on the screen 1 second
    after the last one was displayed:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，当执行时，将输出英语单词一至五。每个单词将在上一个单词显示后1秒出现在屏幕上：
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://packt.link/TaH6b](https://packt.link/TaH6b).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该练习的代码文件可以在[https://packt.link/TaH6b](https://packt.link/TaH6b)找到。
- en: Create a new file, `counting-3.ts`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`counting-3.ts`。
- en: 'In `counting-3.ts`, add an array with the English number names up to and including
    five:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`counting-3.ts`中，添加一个包含从一至五（包括五）的英语数字名称的数组：
- en: '[PRE64]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add a promisified wrapper of the `setTimeout` function. This wrapper will only
    execute when the given timeout expires:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`setTimeout`函数的promisified包装器。此包装器仅在指定的超时时间到期时执行：
- en: '[PRE65]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Since our promise will not return any meaningful results, instead of just resolving
    after a given number of milliseconds, we have provided `void` as its type.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的承诺不会返回任何有意义的成果，因此我们不是在给定数量的毫秒后简单地解析，而是提供了`void`作为其类型。
- en: 'Create an empty `async` function called `countNumbers` and execute it on the
    last line of the file:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`countNumbers`的空`async`函数，并在文件的最后一行执行它：
- en: '[PRE66]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Inside the `countNumbers` function, await the `delay` method with a parameter
    of `1000`, and after its resolution, print out the first number:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`countNumbers`函数内部，使用参数`1000`等待`delay`方法，并在其解决后打印出第一个数字：
- en: '[PRE67]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Save the file, and compile it with the following command:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并使用以下命令编译它：
- en: '[PRE68]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Verify that the compilation ended successfully and that there is a `counting-3.js`
    file generated in the same folder. Execute it in the `node` environment with this
    command:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功完成，并在同一文件夹中生成一个`counting-3.js`文件。使用以下命令在`node`环境中执行它：
- en: '[PRE69]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You will see the output looks like this:'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到输出看起来像这样：
- en: '[PRE70]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The line should appear 1 second after the application was run.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该行应在应用程序运行后1秒出现。
- en: 'In the `counting-3.ts` file, after the `console.log` line, add two more lines
    for the rest of the numbers as well. The code should look like this:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`counting-3.ts`文件中，在`console.log`行之后，添加两行以显示剩余的数字。代码应如下所示：
- en: '[PRE71]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Compile and run the code again, and verify that the output appears in the correct
    order.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出是否按正确顺序出现。
- en: Since the code is completely identical for all the numbers, it's trivial to
    replace it with a `for` loop.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于所有数字的代码完全相同，因此用`for`循环替换它是微不足道的。
- en: 'In the `counting-3.ts` file, remove the body of the `countNumbers` function,
    and replace it with a `for` loop that, for each number of the `numbers` array,
    will `await` a delay of a second, and then print the number:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`counting-3.ts`文件中，删除`countNumbers`函数的主体，并用一个`for`循环替换它，该循环对`numbers`数组中的每个数字，将等待一秒钟的延迟，然后打印该数字：
- en: '[PRE72]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Compile and run the code again, and verify that the output appears in the correct
    order:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编译并运行代码，并验证输出是否按正确顺序出现：
- en: '[PRE73]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Activity 10.03: Movie Browser Using fetch and async/await'
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.03：使用fetch和async/await的影片浏览器
- en: In this activity, we will be improving on the previous activity. The major difference
    is that instead of using the `then` method of the `Promises` class, we'll use
    the `await` keyword to do that for us magically. Instead of a chain of `then`
    calls, we'll just have code that looks completely regular, with some `await` statements
    peppered throughout.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将改进上一个活动。主要区别在于，我们不会使用`Promises`类的`then`方法，而是使用`await`关键字来神奇地完成它。我们将没有`then`调用链，而只有看起来完全正常的代码，其中穿插着一些`await`语句。
- en: The activity has the same files and resources as the previous activity.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动与上一个活动具有相同的文件和资源。
- en: 'The following steps should help you with the solution:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤应有助于您解决问题：
- en: In the `script.ts` file, locate the `search` function and verify that it takes
    a single string parameter and that its body is empty. Note that this function
    is now marked with the `async` keywords, which allows us to use the `await` operator.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script.ts`文件中，找到`search`函数并验证它是否接受一个字符串参数，并且其主体为空。请注意，此函数现在已标记为`async`关键字，这允许我们使用`await`运算符。
- en: Above the `search` function, create a helper function called `getJsonData`.
    This function will use the `fetch` API to get data from an endpoint and format
    it as JSON. It should take a single string called `url` as a parameter, and it
    should return a promise.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`search`函数上方创建一个名为`getJsonData`的辅助函数。此函数将使用`fetch` API从端点获取数据并将其格式化为JSON。它应接受一个名为`url`的单个字符串参数，并且它应该返回一个promise。
- en: In the body of the `getJsonData` function, add code that calls the `fetch` function
    with the `url` parameter, and `then` call the `json` method on the returned response.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getJsonData`函数的主体中，添加调用带有`url`参数的`fetch`函数的代码，然后调用返回响应上的`json`方法。
- en: In the `search` method, construct a new string for the search result URL using
    the `getSearchUrl` method.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`search`方法中，使用`getSearchUrl`方法构造一个新的搜索结果URL。
- en: Call the `getJsonData` function with `searchUrl` as a parameter, and `await`
    the result. Place the result into the `SearchResultApi` variable.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`searchUrl`作为参数调用`getJsonData`函数，并`await`结果。将结果放入`SearchResultApi`变量中。
- en: Check whether we have any results and if we don't, throw an error. If we do
    have results, set the first item of the `result` property into a variable called
    `movieResult`. This object will contain the `id` and `title` properties of the movie.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否有任何结果，如果没有，则抛出错误。如果有结果，将`result`属性的第一个项目设置到一个名为`movieResult`的变量中。此对象将包含电影的`id`和`title`属性。
- en: Use the `id` property to call the `getMovieUrl` and `getPeopleUrl` methods to,
    respectively, get the correct URLs for the movie details and for the cast and crew.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`id`属性调用`getMovieUrl`和`getPeopleUrl`方法，分别获取电影详情和演员及制作组的正确URL。
- en: After getting the URLs, call the `getJsonData` function with both, and assign
    the resulting values to variables. Note that the `getJsonData(movieUrl)` call
    will return a promise of `MovieResultApi`, and `getJsonData(peopleUrl)` will return
    a promise of `PeopleResultApi`. Assign those result values to variables called
    `dataPromise` and `peoplePromise`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取URL后，使用两个URL调用`getJsonData`函数，并将结果值分配给变量。请注意，`getJsonData(movieUrl)`调用将返回一个`MovieResultApi`的promise，而`getJsonData(peopleUrl)`将返回一个`PeopleResultApi`的promise。将这些结果值分配给名为`dataPromise`和`peoplePromise`的变量。
- en: Call the static `Promise.all` method with `dataPromise` and `peoplePromise`
    as parameters. This will create another promise based on those two values, and
    this promise will be resolved successfully if and only if both (that is, all)
    promises that are contained within resolve successfully. Its return value will
    be a promise of an array of results. `await` this promise, and place its result
    into a variable of type `array`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dataPromise`和`peoplePromise`作为参数调用静态`Promise.all`方法。这将基于这两个值创建另一个promise，并且只有当包含在内的所有promise都成功解决时，这个promise才会成功解决。它的返回值将是一个包含结果的promise数组。`await`这个promise，并将其结果放入一个类型为`array`的变量中。
- en: Deconstruct that array into two variables. The first element of the array should
    be the `movieData` variable of type `MovieResultApi`, and the second element of
    the array should be the `peopleData` variable of type `PeopleResultApi`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该数组解构为两个变量。数组的第一个元素应该是`movieData`变量，其类型为`MovieResultApi`，数组的第二个元素应该是`peopleData`变量，其类型为`PeopleResultApi`。
- en: The people data has `cast` and `crew` properties. We'll only take the first
    six cast members, so first sort the `cast` property according to the `order` property
    of the cast members. Then slice off the first six cast members into a new array.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人员数据有`cast`和`crew`属性。我们只取前六个演员，所以首先根据演员的`order`属性对`cast`属性进行排序。然后从第一个六个演员中切出新的数组。
- en: Transform the cast data (which is `CastResultApi` objects) into our own `Character`
    objects. We need to map the `character` field of `CastResultApi` to the `name`
    field of `Character`, the `name` field to the `actor` name, and the `profile_path`
    field to the `image` property.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将演员数据（即`CastResultApi`对象）转换为我们的`Character`对象。我们需要将`CastResultApi`的`character`字段映射到`Character`的`name`字段，将`name`字段映射到演员名称，将`profile_path`字段映射到`image`属性。
- en: From the `crew` property of the people data, we'll only need the director and
    the writer. Since there can be multiple directors and writers, we'll get the names
    of all directors and writers and concatenate them, respectively. For the directors,
    from the `crew` property, filter the people who have a `department` of `Directing`
    and a `job` of `Director`. For those objects, take the `name` property, and `join`
    it together with an `&` in between.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从人物数据的 `crew` 属性中，我们只需要导演和编剧。由于可能有多个导演和编剧，我们将获取所有导演和编剧的名字并将它们分别连接起来。对于导演，从 `crew`
    属性中筛选出具有 `Directing` 部门和 `Director` 职位的个人。对于这些对象，取其 `name` 属性，并用 `&` 连接起来。
- en: For the writers, from the `crew` property, filter the people who have a `department`
    of `Writing` and a `job` of `Writer`. For those objects, take the `name` property,
    and `join` it together with an `&` in between.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于编剧，从 `crew` 属性中筛选出具有 `Writing` 部门和 `Writer` 职位的个人。对于这些对象，取其 `name` 属性，并用 `&`
    连接起来。
- en: Create a new `Movie` object (using object literal syntax). Fill in all the properties
    of the `Movie` object using the data from the movie and people responses we've
    prepared so far.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Movie` 对象（使用对象字面量语法）。使用我们迄今为止准备的电影和人物响应数据，填写 `Movie` 对象的所有属性。
- en: Return the `Movie` object from the function.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数中返回 `Movie` 对象。
- en: Note that we did not do any UI interactions in our code. We just received a
    string, did some promise calls, and returned a value. The UI work can now be done
    in UI-oriented code. In this case, that's in the `click` event handler of the
    `search` button. We should simply add a `then` handler to the `search` call that
    will call the `showResults` method, and a `catch` handler that will call the `clearResults`
    method.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在我们的代码中我们没有进行任何 UI 交互。我们只接收了一个字符串，进行了一些承诺调用，并返回了一个值。现在，UI 的工作可以在面向 UI 的代码中完成。在这种情况下，是在
    `search` 按钮的 `click` 事件处理器中。我们应该简单地给 `search` 调用添加一个 `then` 处理器，该处理器将调用 `showResults`
    方法，并添加一个 `catch` 处理器，该处理器将调用 `clearResults` 方法。
- en: Although we used `fetch` and `async`/`await` in this activity, and our code
    is now just as efficient but less complex compared with the previous activity,
    the basic function of the website will be the same and you should see an output
    similar to the previous activity.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管我们在这次活动中使用了 `fetch` 和 `async`/`await`，与之前的活动相比，我们的代码现在既高效又简单，但网站的基本功能将保持不变，你应该会看到与之前活动类似的结果。
- en: Note
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this activity can be found at [https://packt.link/fExtR](https://packt.link/fExtR).
    The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor435).
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的代码文件可以在 [https://packt.link/fExtR](https://packt.link/fExtR) 找到。本活动的解决方案可以通过
    [此链接](B14508_Solution_ePub.xhtml#_idTextAnchor435) 获取。
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the execution model that is used on the web, and
    how we can use it to actually execute code. We glanced at the surface of the intricacies
    of asynchronous development – and how we can use it to load data from external
    resources. We showed the problems that arise when we get too deep into the hole
    of callbacks and managed to exit it using promises. Finally, we were able to await
    our asynchronous code, and have the best of both words – code that looks like
    it's synchronous, but that executes asynchronously.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在网络上使用的执行模型，以及我们如何使用它来实际执行代码。我们简要地了解了异步开发的复杂性表面——以及我们如何使用它从外部资源加载数据。我们展示了当我们深入回调的陷阱时出现的问题，并设法使用承诺退出。最后，我们能够等待异步代码的执行，并兼得两者之长——代码看起来像是同步的，但实际上是异步执行的。
- en: We also tested the skills developed in the chapter by creating a movie data
    viewer browser, first using XHR and callbacks, and then improved it progressively
    using `fetch` and promises, and then using `fetch` and `async`/`await`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过创建一个电影数据查看器浏览器来测试本章中开发的技能，最初使用 XHR 和回调，然后逐步使用 `fetch` 和承诺进行改进，最后使用 `fetch`
    和 `async`/`await`。
- en: The next chapter will teach you about higher-order functions and callbacks.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将教你关于高阶函数和回调的知识。
