<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-71"><a id="_idTextAnchor070"/>5</h1>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Validating Form Data</h1>
<p>Now that our system is accepting new birthdays, we need to validate the data coming in. In this chapter, we’ll see how we can test-drive the SvelteKit <code>fail</code> function to return useful information to the user so that they can correct any errors.</p>
<p><em class="italic">Figure 5</em><em class="italic">.1</em> shows what is displayed to the user after the server has deemed their date of birth invalid. Notice how the invalid form data is maintained so that the user has a chance to correct it:</p>
<div><div><img alt="Figure 5.1 – A validation error is shown when entering an invalid date" height="828" src="img/Figure_5.1_B19611.jpg" width="1094"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – A validation error is shown when entering an invalid date</p>
<p>This chapter covers the following key topics:</p>
<ul>
<li>Adding a Playwright test for validating form errors</li>
<li>Displaying SvelteKit form errors</li>
<li>Validating data in the form action</li>
<li>Clearing the data store between tests</li>
</ul>
<p>By the end of the chapter, you’ll have a good understanding of how to implement form validation using a test-driven approach.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter05/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter05/Start</a>.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Adding a Playwright test for validating form errors</h1>
<p>In this section we’ll write <a id="_idIndexMarker136"/>another Playwright test and then do some <a id="_idIndexMarker137"/>up-front planning for the Vitest unit tests we’ll need.</p>
<p>Here’s the next end-to-end test, which you can now add to <code>tests/birthdays.test.js</code>. It fills in the birthday form, just as in the previous chapter, but this time, the <code>invalid</code>: it is, literally, the word <code>invalid</code>, which is not a valid date of birth:</p>
<pre class="source-code">
test('does not save a birthday if there are validation errors', async ({
  page
}) =&gt; {
  await page.goto('/birthdays');
  await page.getByLabel('Name').fill('Demeter');
  await page
    .getByLabel('Date of birth')
    .fill('invalid');
  await page.getByRole('button').click();
  await expect(
    page.getByText('Demeter')
  ).not.toBeVisible();
  await expect(
    page.getByText(
      'Please provide a date of birth in the YYYY-MM-DD
       format.'
    )
  ).toBeVisible();
});</pre>
<p>Let’s think about the error message for a second: <code>Please provide a date of birth in the YYYY-MM-DD format</code>. In the interest of brevity, we’re not going fully test-drive this; rather, we’ll just accept anything that can be parsed by the in-built <code>Date.parse</code> function. It turns <a id="_idIndexMarker138"/>out that a lot of strings can be parsed by this function.</p>
<p>Beyond that, what else will be <a id="_idIndexMarker139"/>needed to make this work? Our form action should use SvelteKit’s <code>fail</code> function to signal to SvelteKit that the form needs to be<a id="_idIndexMarker140"/> re-evaluated. We call it with an <code>422</code> – the <em class="italic">Unprocessable entity</em> error code – meaning the request data was invalid.</p>
<p>The <code>fail</code> function can also return an object that is passed back to the client. It is given to our page component as a <code>form</code> prop. The object is a plain JavaScript object that we control. We can return whatever we want in it: all we have to do is call SvelteKit’s <code>fail</code> function with the object, and it will return that to the client.</p>
<p class="callout-heading">Valid return objects</p>
<p class="callout">The return object is only valid if it can be serialized into a string and reconstructed in the browser. Functions can’t be serialized, so they can’t be passed back.</p>
<p>We can include an <code>error</code> property that returns an error message. We can also return the <code>name</code> and <code>dob</code> properties so that they can be presented to the user again.</p>
<p>An example object looks like this:</p>
<pre class="source-code">
{
  name: 'Demeter',
  dob: 'invalid',
  error: 'Please provide a date of birth in the YYYY-MM-DD
          format.'
}</pre>
<p>In the remaining sections, we’ll <a id="_idIndexMarker141"/>start by updating the <code>BirthdayForm</code> component <a id="_idIndexMarker142"/>to make use of this new <code>form</code> prop. Then, we’ll update the form action to return the validation errors for two different validation errors: an empty name and an invalid date of birth.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Displaying SvelteKit form errors</h1>
<p>In this section, we’ll add tests<a id="_idIndexMarker143"/> and functionality to support passing in a new <code>form</code> prop into the <code>BirthayForm</code> component.</p>
<p>Let’s start with a new test:</p>
<ol>
<li>In the <code>src/routes/birthdays/BirthdayForm.test.js</code> file, add a new nested <code>describe</code> block with a single test, as shown in the following code snippet. It checks that if the <code>error</code> property is set on the <code>form</code> prop, then that error must be displayed somewhere on the page:<pre class="source-code">
describe('validation errors', () =&gt; {
  it('displays a message', () =&gt; {
    render(BirthdayForm, {
      form: {
        error: 'An error'
      }
    });
    expect(
      screen.queryByText('An error')
    ).toBeVisible();
  });
});</pre></li>
<li>Make that pass in <code>src/routes/birthdays/BirthdayForm.svelte</code>, first by adding an <code>export</code> statement for the new <code>form</code> prop and then by adding a new <code>p</code> element with<a id="_idIndexMarker144"/> the error text. You can also add the <code>&lt;style&gt;</code> element at the bottom, although this isn’t necessary for the test to pass:<pre class="source-code">
&lt;script&gt;
  export let form;
&lt;/script&gt;
&lt;p class="error"&gt;{form.error}&lt;/p&gt;
&lt;form&gt;
  ...
&lt;/form&gt;
&lt;style&gt;
  .error {
    color: red;
  }
&lt;/style&gt;</pre></li>
<li>If you run tests now, you’ll see we’ve broken a bunch of other tests by requiring the <code>form</code> prop to have an object value. But for the <em class="italic">create</em> mode of this component, the <code>form</code> prop should remain undefined. Update the <code>BirthdayForm</code> component <a id="_idIndexMarker145"/>as shown in the following code block:<pre class="source-code">
&lt;script&gt;
  export let form<strong class="bold"> = undefined;</strong>
&lt;/script&gt;
<strong class="bold">{#if form?.error}</strong>
  &lt;p class="error"&gt;{form.error}&lt;/p&gt;
<strong class="bold">{/if}</strong>
...</pre></li>
<li>Let’s add the next test in the same <code>describe</code> block. This test checks that if an error occurs, we re-populate the <code>name</code> text field with the same value as was passed in:<pre class="source-code">
describe('validation errors', () =&gt; {
  ...
  it('keeps the previous name value when an error
  occurs', () =&gt; {
    render(BirthdayForm, {
      form: {
        name: 'Hercules',
        error: 'Some awful error message'
      }
    });
    expect(
      screen.queryByLabelText('Name')
    ).toHaveValue('Hercules');
  });
});</pre></li>
<li>To make that pass, simply add a <code>value</code> attribute value to the <code>input</code> field:<pre class="source-code">
&lt;input type="text" name="name" <strong class="bold">value={form?.name}</strong> /&gt;</pre></li>
<li>Now repeat that<a id="_idIndexMarker146"/> for the <code>dob</code> field:<pre class="source-code">
describe('validation errors', () =&gt; {
  ...
  it('keeps the previous dob value when an error
  occurs', () =&gt; {
    render(BirthdayForm, {
      form: {
        dob: '1994-01-01',
        error: 'Some awful error message'
      }
    });
    expect(
      screen.queryByLabelText('Date of birth')
    ).toHaveValue('1994-01-01');
  });
});</pre></li>
<li>Make that pass by adding the <code>value</code> attribute on the <code>dob</code> field:<pre class="source-code">
&lt;input type="text" name="dob" <strong class="bold">value={form?.dob}</strong> /&gt;</pre></li>
<li>If you run the app now, you’ll see that in <em class="italic">create</em> mode, the <code>undefined</code> string value now appears for the <code>form</code> is <code>undefined</code> in <em class="italic">create</em> mode, and therefore <code>value</code> is <code>undefined</code>. And the browser converts that to a string, giving <code>undefined</code> in the text box. To fix that, we need to specify an initial value for the fields. In the <code>BirthdayForm</code> test<a id="_idIndexMarker147"/> suite, find the <code>describe</code> block for the <code>name</code> field and add a second test into it, as shown in the following code block:<pre class="source-code">
describe('name field', () =&gt; {
  ...
  it('initially has a blank value', () =&gt; {
    render(BirthdayForm);
    expect(
      screen.getByLabelText('Name')
    ).toHaveValue('');
  });
});</pre></li>
<li>To make that pass, update the <code>value</code> attribute, like this:<pre class="source-code">
&lt;input
  type="text"
  name="name"
  <strong class="bold">value={form?.name || ''}</strong>
/&gt;</pre></li>
<li>Then, repeat that for <code>date of birth field</code>, starting with the test shown here:<pre class="source-code">
describe('date a birth field', () =&gt; {
  ...
  it('initially has a blank value', () =&gt; {
    render(BirthdayForm);
    expect(
      screen.getByLabelText('Name')
    ).toHaveValue('');
  });
});</pre></li>
<li>Finally, make that test <a id="_idIndexMarker148"/>pass by setting the <code>value</code> attribute on the <code>dob</code> field in the same way:<pre class="source-code">
&lt;input
  type="text"
  name="dob"
  <strong class="bold">value={form?.dob || ''}</strong>
/&gt;</pre></li>
</ol>
<p>That completes the <code>BirthdayForm</code> component changes. Next, we need to get the <code>form</code> prop into <code>BirthdayForm</code> from the page component.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Passing the form data through the page component</h2>
<p>The <code>BirthdayForm</code> component<a id="_idIndexMarker149"/> is not the <em class="italic">root</em> route component: it is<a id="_idIndexMarker150"/> instantiated as a child component from the component in <code>+page.svelte</code>.</p>
<p>Follow these steps to ensure that the <code>form</code> prop is received by the <code>page</code> component and passed into the <code>BirthdayForm</code> component:</p>
<ol>
<li>In <code>src/routes/birthdays/page.test.js</code>, add a new test at the bottom of the test suite, as<a id="_idIndexMarker151"/> shown in the following code snippet. It checks that if the <code>form</code> prop is sent with the <code>error</code> prop, the <code>error</code> text appears onscreen:<pre class="source-code">
it('passes any form information to the BirthdayForm', () =&gt; {
  render(Page, {
    data: { birthdays },
    form: { error: 'An error' }
  });
  expect(
    screen.queryByText('An error')
  ).toBeVisible();
});</pre></li>
<li>Because the page<a id="_idIndexMarker152"/> component is already<a id="_idIndexMarker153"/> rendering <code>BirthdayForm</code>, it turns out the simplest way to make this test pass is to pass the <code>form</code> prop into <code>BirthdayForm</code>. In <a href="B19611_12.xhtml#_idTextAnchor134"><em class="italic">Chapter 12</em></a><em class="italic">, Using Component Mocks </em><em class="italic">to</em><em class="italic"> Clarify Tests</em>, we’ll see how this test can be rewritten using component mocks. For now, though, in <code>src/routes/birthdays/+page.svelte</code>, update the component to declare the <code>form</code> prop, and then pass it directly into <code>BirthdayForm</code>:<pre class="source-code">
&lt;script&gt;
  ...
<strong class="bold">  export let form = undefined;</strong>
&lt;/script&gt;
...
&lt;BirthdayForm <strong class="bold">{form}</strong> /&gt;</pre></li>
</ol>
<p>You’ve now learned how to use automated tests to drive the display of form errors.</p>
<p>In the next section, we’ll write tests for the form action that occurs on the server side.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Validating data in the form action</h1>
<p>Now we’re all set up for errors on the<a id="_idIndexMarker154"/> client, but we need the server code to actually do the validation checks. We’ll add two checks: one to check that the name is not empty, and one to check that the date can be parsed into a valid <code>Date</code> object.</p>
<p>Each of these checks needs four unit tests: the first to ensure we break early without adding the birthday; the next to check the <code>422</code> error code; then one to check the error message text; and finally, one to check that the original data is passed back. (In <a href="B19611_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Matchers to Simplify Tests</em>, you’ll see how to build a matcher that will roll up three of these tests into one single test.)</p>
<p class="callout-heading">The beforeEach function</p>
<p class="callout">This section introduces the <code>beforeEach</code> function, which is used to run setup code before each of the tests within the <code>describe</code> block. It is a useful tool for reducing duplication within your test suites. You can consider it as<a id="_idIndexMarker155"/> part of the <strong class="bold">Arrange</strong> phase of your tests.</p>
<p class="callout">The <code>beforeAll</code>, <code>afterEach</code>, and <code>afterAll</code> functions do similar jobs but are used less frequently. We used the <code>afterEach</code> function for initialization in <a href="B19611_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>,<em class="italic"> </em><em class="italic">Setting up for Testing</em>, and we’ll use <code>beforeAll</code> in <a href="B19611_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Matchers to </em><em class="italic">Simplify Tests</em>.</p>
<p>Let’s get started:</p>
<ol>
<li>In <code>src/routes/birthdays/page.server.test.js</code>, add a new import for the <code>beforeEach</code> function. We’ll use this to perform the setup for an entire set of tests:<pre class="source-code">
import {
  describe,
  it,
  expect,
<strong class="bold">  beforeEach</strong>
} from 'vitest';</pre></li>
</ol>
<p>Then add a nested <code>'validation errors'</code> describe block, together with another nested describe<a id="_idIndexMarker156"/> block entitled <code>'when the name is not provided'</code>, as shown here. This includes the first test, too:</p>
<pre class="source-code">
describe('/birthdays - default action', () =&gt; {
  ...
  describe('validation errors', () =&gt; {
    describe('when the name is not provided', () =&gt; {
      let result;
      beforeEach(async () =&gt; {
        const request = createFormDataRequest({
          name: '',
          dob: '2009-02-02'
        });
        result = await actions.default({
          request
        });
      });
      it('does not save the birthday', () =&gt; {
        expect(load().birthdays).not.toContainEqual(
          expect.objectContaining({
            name: '',
            dob: '2009-02-02'
          })
        );
      });
    });
  });
});</pre>
<p class="callout-heading">The when… context</p>
<p class="callout">The <code>when</code> style of naming the <code>describe</code> contexts is common when a group of tests belongs to a specific starting scenario, such as the one shown in the preceding scenario. They often have a <code>beforeEach</code> block that contains a setup that is common to all the tests.</p>
<p class="callout">It can sometimes be tempting to have multiple levels of nesting, but for simplicity, it’s best to keep a single level of the <code>when...</code> context blocks. The preceding example shows an outer block named <code>'validation errors'</code>, but that is for organization only and contains none of its own setup.</p>
<ol>
<li value="2">Then, in the <code>src/routes/birthdays/+page.server.js</code> file, update <code>actions</code> with a<a id="_idIndexMarker157"/> new <code>name</code> field is empty:<pre class="source-code">
export const actions = {
   default: async ({ request }) =&gt; {
     const data = await request.formData();
<strong class="bold">    const name = data.get('name');</strong>
<strong class="bold">    if (empty(name)) {</strong>
<strong class="bold">      return;</strong>
<strong class="bold">    }</strong>
    ...
  }
};</pre></li>
<li>For that to work, you’ll <a id="_idIndexMarker159"/>need a definition of the <code>empty</code> function, which you can define as shown:<pre class="source-code">
const empty = (value) =&gt;
  value === undefined ||
  value === null ||
  value.trim() === '';</pre></li>
</ol>
<p class="callout-heading">Taking shortcuts</p>
<p class="callout">You might observe that we haven’t fully tested the <code>empty</code> function, such as what happens if a line of spaces is sent in. To avoid having to write even more tests within this chapter, I’ve not written out those tests. If this were a real application, I’d move <code>empty</code> to a file of its own and then provide a whole bunch of unit tests that run directly against it.</p>
<ol>
<li value="4">For the next test, we’ll write a test that ensures the form returns a <code>422</code> response. Add this test into the same nested <code>describe</code> block:<pre class="source-code">
it('returns a 422', () =&gt; {
  expect(result.status).toEqual(422);
});</pre></li>
<li>To make that pass, first add the following <code>import</code> statement in the <code>src/routes/birthdays/+page.server.js</code> file:<pre class="source-code">
import { fail } from '@sveltejs/kit';</pre></li>
<li>Then update the guard clause to return a value using <code>fail</code>:<pre class="source-code">
if (empty(name)) {
  return <strong class="bold">fail(422);</strong>
}</pre></li>
<li>Now, still in the same nested <code>describe</code> block, add a test for the error message:<pre class="source-code">
it('returns a useful message', () =&gt; {
  expect(result.data.error).toEqual(
    'Please provide a name.'
  );
});</pre></li>
<li>Make that pass by<a id="_idIndexMarker160"/> adding a <code>return</code> object as the second parameter to the <code>fail</code> call:<pre class="source-code">
if (empty(name)) {
<strong class="bold">  return fail(422, {</strong>
<strong class="bold">   error: 'Please provide a name.'</strong>
<strong class="bold">  });</strong>
}</pre></li>
<li>Then add the final test for this name check, which is that we continue to pass the <code>dob</code> field value back, too:<pre class="source-code">
it('returns the data back', () =&gt; {
  expect(result.data).toContain({
    dob: '2009-02-02'
  });
});</pre></li>
<li>Complete the guard <a id="_idIndexMarker161"/>clause, as shown in the following code snippet. For this, you’ll need to pull out the <code>dob</code> field in the same way you did with <code>name</code>:<pre class="source-code">
const name = data.get('name');
<strong class="bold">const dob = data.get('dob');</strong>
...
if (empty(name)) {
  return fail(422, {
<strong class="bold">    dob,</strong>
    error: 'Please provide a name.'
  });
}</pre></li>
<li>Now let’s start on the second check for a <code>date</code> value that can’t be parsed. This behaves exactly the same as the previous check, just with different values for the form data:<pre class="source-code">
describe('/birthdays - default action', () =&gt; {
  ...
  describe('validation errors', () =&gt; {
    ...
    describe('when the date of birth is in the wrong
    format', () =&gt; {
      let result;
      beforeEach(async () =&gt; {
        const request = createFormDataRequest({
          name: 'Hercules',
          dob: 'unknown'
        });
        result = await actions.default({
          request
        });
      });
      it('does not save the birthday', () =&gt; {
        expect(load().birthdays).not.toContainEqual(
          expect.objectContaining({
            name: '',
            dob: '2009-02-02'
          })
        );
      });
    });
  });
});</pre></li>
<li>To make that pass, first define an <code>invalidDob</code> helper next to the <code>empty</code> helper:<pre class="source-code">
const invalidDob = (dob) =&gt; isNaN(Date.parse(dob));</pre></li>
<li>Then, update the <a id="_idIndexMarker162"/>form action with a new guard clause:<pre class="source-code">
export const actions = {
   default: async ({ request }) =&gt; {
     ...
<strong class="bold">     if (invalidDob(dob)) {</strong>
<strong class="bold">       return;</strong>
<strong class="bold">     }</strong>
  }
};</pre></li>
<li>Then, repeating the motions from <em class="italic">step 4</em> onwards, add a test to ensure that a <code>422</code> response is returned:<pre class="source-code">
it('returns a 422', () =&gt; {
  expect(result.status).toEqual(422);
});</pre></li>
<li>To make that pass, update the <code>return</code> statement like this:<pre class="source-code">
if (invalidDob(dob)) {
  return <strong class="bold">fail(422);</strong>
}</pre></li>
<li>Next, add a test for a useful message to be returned:<pre class="source-code">
it('returns a useful message', () =&gt; {
  expect(result.data.error).toEqual(
    'Please provide a date of birth in the YYYY-MM-DD
     format.'
  );
});</pre></li>
<li>Update the guard clause to display that message:<pre class="source-code">
if (invalidDob(dob)) {
<strong class="bold">  return fail(422, {</strong>
<strong class="bold">    error:</strong>
<strong class="bold">      'Please provide a date of birth in the YYYY-MM-</strong>
<strong class="bold">       </strong><strong class="bold">DD format.'</strong>
<strong class="bold">  });</strong>
}</pre></li>
<li>For the final test, we <a id="_idIndexMarker163"/>check that <em class="italic">all</em> the data is returned, including the invalid date. This is so that the user has the opportunity to correct the data:<pre class="source-code">
it('returns all data back, including the incorrect value', () =&gt; {
  expect(result.data).toContain({
    name: 'Hercules',
    dob: 'unknown'
  });
});</pre></li>
<li>And make that pass by passing in the <code>name</code> and <code>dob</code> properties to the failure object. At this point, all your tests should be passing:<pre class="source-code">
if (invalidDob(dob)) {
  return fail(422, {
<strong class="bold">    name,</strong>
<strong class="bold">    dob,</strong>
    error:
        'Please provide a date of birth in the YYYY-
         MM-DD format.'
  });
}</pre></li>
<li>Now, as a final, tiny <em class="italic">refactor</em> step, you <a id="_idIndexMarker164"/>can update the call to <code>addNew</code> so that it uses the form data values that you’ve already pulled out from previous steps:<pre class="source-code">
addNew({
  name,
  dob
});</pre></li>
</ol>
<p>That completes test-driving the server-side validation. Your Vitest tests and the Playwright test will now pass. You can also try out the app by running the dev server (with the <code>npm run dev</code> command) and opening your browser.</p>
<p>In the final section of this chapter, we’ll fix a bug that’s crept into our test suites.</p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Clearing the data store between tests</h1>
<p>It turns out our tests are not independent: changes<a id="_idIndexMarker165"/> to the <code>db</code> object in one test affect the other tests, too. We have to clear down our test database between each run. We can solve that by creating a <code>clear</code> function that will clear the database object, and we’ll use a <code>beforeEach</code> block to call it before every test.</p>
<p>What we need is the <code>clear</code> function that we can call directly in our tests. However, if you try to add this function to the <code>+page.server.js</code> file, you’ll get a warning from SvelteKit when you run your Playwright tests:</p>
<pre class="source-code">
Error: Invalid export 'clear' in /birthdays (valid exports are load, prerender, csr, ssr, actions, trailingSlash, or anything with a '_' prefix)</pre>
<p>Why does this error <a id="_idIndexMarker166"/>appear only in the Playwright tests and not the Vitest tests? Your Vitest tests do not run through the SvelteKit server code, so the framework has no opportunity to check for invalid exports. It’s only when you run tests via Playwright that you’ll see runtime issues such as this.</p>
<p>SvelteKit only wants a <code>load</code> export and an <code>actions</code> export and absolutely nothing else. So, we need to move things out of the action and into their own file:</p>
<ol>
<li>Create a new file, <code>src/lib/server/birthdayRepository.js</code>, with the following content:<pre class="source-code">
let db = [];
export const addNew = (item) =&gt; db.push(item);
export const getAll = () =&gt; Array.from(db);
export const clear = () =&gt; (db = []);</pre></li>
<li>In <code>src/routes/birthdays/+page.server.js</code>, you can now import those, as shown in the following code block. Note the use of the <code>$</code> symbol in front of the file path, which is used to make a location that is relative to the <code>src</code> folder, which avoids us having to write <code>../../</code> before the filename:<pre class="source-code">
import {
  addNew,
  getAll
} from '$lib/server/birthdayRepository.js';</pre></li>
<li>Then delete the <code>db</code> and <code>addNew</code> functions and update the <code>load</code> function to read as follows. At this point, all your tests (except for the skipped one) should still be passing:<pre class="source-code">
export const load = () =&gt; ({
  birthdays: <strong class="bold">getAll()</strong>
});</pre></li>
<li>Now you can<a id="_idIndexMarker167"/> add this new <code>import</code> statement in <code>src/routes/birthdays/page.server.test.js</code>:<pre class="source-code">
import
  as birthdayRepository
from '$lib/server/birthdayRepository.js';</pre></li>
<li>Add in the <code>beforeEach</code> statement, as shown in the following code block:<pre class="source-code">
describe('/birthdays - default action', () =&gt; {
  <strong class="bold">beforeEach(birthdayRepository.clear);</strong>
  ...
});</pre></li>
<li>Finally, in the action <code>describe</code> block, you can now also replace the use of <code>load</code> with <code>birthdayRepository.getAll</code>, which makes the test a little clearer as to what’s actually being tested: that the form action causes a new birthday to be inserted into the <code>birthdayRepository</code> object:<pre class="source-code">
it('adds a new birthday into the list', async () =&gt; {
  ...
  expect(<strong class="bold">birthdayRepository.getAll()</strong>).toContainEqual(
    ...
  );
});</pre></li>
</ol>
<p>In the last step, take care not to replace <em class="italic">all</em> the occurrences of <code>load</code>. In the second <code>describe</code> block, it’s the <code>load</code> function that is the function under test. Therefore, we keep those tests exactly as they are.</p>
<p>That completes all the <a id="_idIndexMarker168"/>work involved in extracting the repository module. Doing so has enabled us to introduce a <code>clear</code> function that can be used to keep our tests independent of each other. The <code>beforeEach</code> block ensures that each test starts from a clean slate.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Summary</h1>
<p>This chapter has involved writing many more unit tests than previous chapters. Sometimes, unit tests need to be very detailed, particularly when it comes to testing very specific return values. In <a href="B19611_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Matchers to Simplify Tests</em>, we’ll look at ways of reducing the number of tests required.</p>
<p>You’ve also seen why it’s important for unit tests to run independently and how to ensure your SvelteKit route tests clear their data between each test using the <code>beforeEach</code> function.</p>
<p>In the next chapter, you’ll learn how to extend the current <code>BirthdayForm</code> component to handle editing existing birthdays in addition to adding new birthdays.</p>
</div>
</div></body></html>