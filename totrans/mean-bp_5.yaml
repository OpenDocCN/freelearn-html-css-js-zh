- en: Chapter 5. E-commerce Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on building an e-commerce like application. We are going
    to experiment with a different application architecture by building a core that
    will hold all the business logic and consume it with smaller apps. Also one more
    interesting thing to note is that the front store of our e-commerce application
    will be built using server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: This new architecture will enable us to build micro apps; for example, one app
    could be the admin application that is going to manage the product catalog. The
    benefit is that each micro app can be built using different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: As a demonstration, we are not going to build our front store in Angular. Sounds
    crazy I know, but for educational purposes, it's going to be great. Also, we want
    to highlight how easy it is to build hybrid applications.
  prefs: []
  type: TYPE_NORMAL
- en: The admin part of the application is going to be built using Angular 2\. Because
    of this, we are going to build a headless core backend service. This core application
    will be consumed by our micro apps.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the base application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we used our own boilerplate to bootstrap the application's
    development. This chapter is going to have a fresh folder structure, but don't
    worry; we are still going to use a lot of code from the existing boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: A new folder structure will give us more flexibility, as at the moment we have
    outgrown our initial architecture. One benefit, which we are not going to cover
    in this chapter, is that you can move each module to a separate package and install
    them as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before jumping into things, let''s see a high-level view of our architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation for the folder structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apps`: This folder will contain several micro apps, such as `frontstore`,
    which will serve as the client application for users visiting our e-commerce store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core`: This is going to be the heart of our application, containing all the
    necessary business logic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middlewares`: In this folder, we''ll store all our pieces of functions that
    will manipulate the request and response object. A good example would be authentication
    middleware.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models`: This folder will store all the backend models.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services`: This will group all common sets of application logic available
    for different clients and will coordinate the consumption of business logic.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: All application configuration files go here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environments`: This folder contains files loaded according to the current
    environment'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests`: This folder contains all the tests necessary to test the application
    backend logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a high-level view of our architecture, let's define our models
    and see how they interact. This will give you a high-level view of how you are
    going to store your data in the database. Also, it will reflect the connections
    between different entities and you can decide, in the case of MongoDB, what documents
    will be embedded and which ones will be referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Custom money data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the earlier Expense Tracker application, we concluded that there is a way
    to work with monetary data in JavaScript and MongoDB. It only needs extra application
    logic to handle the Exact Precision solution.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are working with Mongoose as our ODM for Mongo, we can define a custom
    model for monetary data. I know it sounds strange, but it will give us the upper
    hand by defining virtual properties and reusing the money data type in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `core/models/money.js` and add the following Mongoose
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For easier readability, I did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defined a default currency with a default scale factor. To achieve better customization,
    you can add these into a configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Added a virtual named `display`, which will be the display value of the money
    model, for example, 18.99.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, having that out of the way, let's see what is going on with the preceding
    code. We created a custom Money model, which will serve us as a Money data type.
    As you can see, we disabled the autogeneration of the `_id` property. This way,
    if we use the model as an embedded document, Mongoose will not generate an `_id`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When transforming the price to an object, the output will contain all of the
    necessary information and we don't need to do any calculations using floats. Remember
    that we are storing the scale factor and the currency within the price model because
    this needs to be consistent across the application with the currency.
  prefs: []
  type: TYPE_NORMAL
- en: The product model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating an e-commerce application, you have to think about storing many
    different product types in your catalog. The MongoDB data model will come in handy
    in this situation due to the fact that we can represent data in any structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structuring data in an RDBMS would be a little bit harder; for example, one
    approach would be to represent each product type in a separate table. Each would
    have a different table structure. An alternative and popular approach would be
    **EAV**, which stands for **Entity Attribute Values**. In this case, you maintain
    a table with at least three columns: `entity_id`, `attribute_id`, and `value`.
    The EAV solution is very flexible, but it comes with a downside. Complex queries
    require a large number of JOIN operations, which can degrade performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, as pointed out earlier, MongoDB has a dynamic schema solution,
    and we can store all of the product data in one collection. We could have generic
    information of a product and product-specific information for different product
    types. Let''s get down to business and define our product schema. Create a file
    called `core/models/product.js`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a few fields that all types of products are going to
    have, and we have a mixed property called `details` that will hold all the necessary
    details about a specific product. Also we used our custom data type for the `price`
    property. A product, by default, will be flagged as inactive in the product catalog
    so that it will be shown only when all the necessary information is added.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the book—more precisely in [Chapter 3](part0035_split_000.html#11C3M1-5c78d361d97340239270192b72d53e7b
    "Chapter 3. Job Board"), *Job Board*—we used the `slug` definition for URL-friendly
    titles for our job openings. This time, we are going to use it for our product
    titles. To simplify things, we are going to automatically generate them when a
    new entry is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepend the following code in your product model file, before the `module.exports`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To freshen up your memory, we used the same technique in [Chapter 3](part0035_split_000.html#11C3M1-5c78d361d97340239270192b72d53e7b
    "Chapter 3. Job Board"), *Job Board* to create a slug from a title. So, this basically
    generates a URL-friendly string from the product title before saving in the database.
  prefs: []
  type: TYPE_NORMAL
- en: This pretty much sums up our product schema and should give us a solid start
    for storing products in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: The order model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the fact that we are trying to build an e-commerce application, we somehow
    need to be able to store what users have purchased from our store. We are going
    to store all of this information in an `orders` collection in MongoDB. An `order`
    entry should contain information about what products were bought, shipping details,
    and who made the purchase.
  prefs: []
  type: TYPE_NORMAL
- en: When you analyze this, the first thing that you think about is that we would
    also need to have a cart before placing an order. But if we reduce everything
    to a simple use case, we can consider that a cart is a special kind of an order.
    What I mean is that a cart holds product items that will be purchased and an order
    will be created for that purchase.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in simple terms, only the perspective changes how we see an order. We could
    have a `type` property for an order to determine its state. So we have a few key
    points to define our order schema. Now we can create a new file called `core/models/order.js`,
    and add the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, an order will store all selected products in the `items` property,
    together with simple information, such as the `sku`, `quantity`, and `price` of
    the product. We store some non-trivial data in the items list as the product's
    `title` so that we don't have to retrieve it for non-trivial operations.
  prefs: []
  type: TYPE_NORMAL
- en: When we are dealing with a `cart` entry, we want it to eventually expire if
    it is not finalized as an order. This is because we want to release items from
    the cart to be available.
  prefs: []
  type: TYPE_NORMAL
- en: Probably, we are going to store extra details about the order and shipping details
    that could vary from order to order. That's why we marked them as mixed data types.
  prefs: []
  type: TYPE_NORMAL
- en: The inventory model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have defined the product schema and the order schema. Neither
    mentioned anything about the inventory status. In the `order` schema, we store
    for each product item, what quantity was placed in the order, but this won't reflect
    the initial stock or the current stock.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few approaches when working with inventory data, each with its own
    benefits and downsides. For example, we can store a single record for each physical
    product; so if we have 100 stock units of a product, we store 100 records in the
    inventory.
  prefs: []
  type: TYPE_NORMAL
- en: In a large product catalog, this would not be a good solution, as the `inventory`
    collection would grow very quickly. Storing separate entries for each unit can
    be beneficial when you have physical products and a low volume of stock units.
    An example is a wood shop that builds furniture and wants to track more details
    for each physical unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative would be to store a single entry for each product, with the
    quantity of the product in stock. Now that we have a good hint about what needs
    to be done, let''s create the inventory model, called `core/models/inventory.js`,
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We pushed things a little bit further and added a `carted` property. This will
    hold all the items that are active in a cart to help us track the progress of
    each reserved item in the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you can have a clean history of the level of the inventory. You can
    omit the `carted` property and only rely on information from the `orders` collection.
  prefs: []
  type: TYPE_NORMAL
- en: The core Service Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because our application will have different clients consuming business logic,
    we are going to add a Service Layer; it will coordinate operations for different
    use cases. So, we are going to move most of our business logic from controllers
    to services. Probably, it's too early to see the benefits of this, but as we progress
    with this chapter, it will make more sense.
  prefs: []
  type: TYPE_NORMAL
- en: One benefit would be that you can simply expose your Service Layer as a RESTful
    API, or add another client that will render on the server-side templates and display
    all the necessary information to the user. Regardless of the application's client
    implementation, you can test the business logic of your application.
  prefs: []
  type: TYPE_NORMAL
- en: The product catalog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The product catalog will contain all the products you want to be shown or simply
    exist in the system. Each item in the catalog will be stored in MongoDB, in the
    `products` collection. We are going to create a `ProductCatalog` service, which
    will hold all the business logic for managing the products in our e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow a few steps in order to create the product catalog service:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the service file, called `core/services/product-catalog.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adding a product to the catalog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll add each class method one by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit an existing product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List all products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get more details using the `sku` identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a product by `slug`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We managed to put down a base for our product catalog service. As you can see,
    it only masks certain functionalities from the end module, which should not know
    of the underlining layer or how data is stored. It can be a database, as MongoDB
    is in our case, or simply a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first benefit that we get is testability, as we can test our application''s
    business logic and run an integration test before even implementing a higher-level
    layer. For example, we can have the following piece of code, extracted from `tests/integration/product-catalog.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test case will simply check whether all the operations done by
    the service are correct. We did a lot of test-driven development in the earlier
    chapters, and in the later chapters, we focused more on functionality, but this
    does not mean that we skipped writing tests. The tests are available in the full
    source code for you to check out and follow while developing the application.
  prefs: []
  type: TYPE_NORMAL
- en: The inventory manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lots of e-commerce solutions out in the wild come with an inventory manager,
    which will help you keep track of a product's stock level, replenish your product's
    stock level, or adjust it as desired.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't want to embed inventory information in the product document, so we
    are going to store it separately for each product. There are many ways you can
    track your inventory; we have chosen a solution that fits most of the use cases,
    and it's easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin coding, I would like to go through the test cases to give you
    a hint about what we are going to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should be able to track the inventory for a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A desired quantity of a given product should be reserved from the inventory
    on demand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If there is not adequate inventory, the service should not satisfy the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Increase the available quantity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or you can decrease the available quantity to make adjustments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have taken a glance at what needs to be done, let''s follow a few
    steps to create our inventory manager service:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `core/services/inventory-manager.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a starting point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that we can inject a custom `InventoryModel` inside our service as
    long as it has at least the necessary properties and methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new inventory item method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the quantity private method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created a private method, prefixed with an underscore for semantics. This
    will serve as the main entry point when manipulating stock levels. If nothing
    has changed, we return an error. After a successful operation, we return the current
    state of the inventory entry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Increase and decrease the quantity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will reserve the available quantity of a product in the inventory.
    In some cases, the system cannot satisfy the requested quantity, so we check to
    make sure that we have the desired availability before decrementing the quantity.
    If we cannot fulfill the request, we return a specific error.
  prefs: []
  type: TYPE_NORMAL
- en: Also you might notice that we have progressively added our own custom `Error`
    object, which also contains a suggestion for the status code itself. At this time,
    errors returned from the service have no standard format, due to the fact that
    the underlining ODM could return different `Error` objects.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be able to satisfy all use cases in this book, so sometimes you have
    to put the pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: Shopping cart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By this time, we should have all the necessary services used by the shopping
    cart service. Now this service will be quite interesting, if you permit me to
    say so. Regularly, e-commerce solutions have a shopping cart in which customers
    can easily add or remove items, change quantities, and even abandon them.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note is that we have to make sure that a customer cannot
    add items that are unavailable. In other words, if a product stock doesn't match
    the requested quantity, the add action should not succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, our shopping cart service will handle all the business logic described
    previously. Also, when a customer adds an item to the cart, the inventory should
    be properly updated. Remember that our orders collection will hold the carts as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things are pretty clear about what needs to be done. If not, go and take a
    quick look at the test cases. Let''s create our shopping cart service, `core/services/shopping-cart.js`,
    and add the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Noting fancy here. We can move on by adding our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Before I forget, we are going to use the other two services we implemented
    earlier to manage the inventory and retrieve products from our catalog. Moreover,
    before adding a new item into the cart, we need to create it. So let''s add the
    `createCart()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding a new item into the shopping cart, we have to take care of a few
    things, and we must verify that the inventory meets the request''s requirements.
    Let''s sketch out the `addProduct()` method of the cart service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When adding a product into the cart, we want to store some additional information,
    so we first need to retrieve the product from the catalog using the SKU. The product
    needs to be added with the desired quantity to the cart's items. After successfully
    populating the cart with the new item, we need to decrease the number of units
    available in the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: If there are not enough items in the inventory, we must roll back the cart update
    and raise an error in the application. Finally, we get a fresh copy of the persisted
    cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beside the methods used from the other two services, we have a few left to
    implement for the `ShoppingCart` class, such as the `_pushItems()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The cart must be active in order to add items to it. Also, we have to update
    the expiration date. Remember that we are doing atomic operations on our documents,
    so only the raw responses of the operations are returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to roll back our cart, we need to pull out the added items; the
    `_pullItems()` method does exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By this time, we should be able to manage our cart easily with the implemented
    functionalities. The `ShoppingCart` service has used both the `InventoryManager`
    and `ProductCatalog` services, exposing the exact business logic we need to handle
    operations on a cart.
  prefs: []
  type: TYPE_NORMAL
- en: The Auth micro app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Auth` micro app will handle authentications in different scenarios. It's
    going to be our main entry point to authenticate users, using stateful and stateless
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Our core module already exposes middleware to check whether a user is authenticated
    or not, and authorization-related middleware. This functionality can be used in
    any module or micro app.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is going to be our first micro app, so let''s go through a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new micro app called `apps/auth/index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following base content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We defined a base URL for our micro app and mounted the router on the main Express
    application. We also created a new instance of the Controller used in the `Auth`
    micro app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Register all necessary routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to save development time, we borrowed code from previous chapters,
    so the preceding lines of code are probably already familiar to you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initialize your micro app in the main `server.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the main `server.js` file, we are going to initialize each app. You can take
    a look at the final version of the `server.js` file to see exactly where to put
    things.
  prefs: []
  type: TYPE_NORMAL
- en: The controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, I stated that we are reusing code from previous chapters. We also
    did this for the controller. We turned our controller into a class called `AuthController`
    and exposed the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign in users using a stateful authentication strategy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Authenticate using a stateless strategy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In some cases, we don't need to persist the user's session. Instead, we create
    a token that will be used at each request to see who tries to access our endpoints.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Register a user in our system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exposing an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our core business logic needs to be accessed in some way, and I think a RESTful
    API would serve us in a good way. In order to get a better understanding and move
    through the whole app, we are only going to showcase a few parts from our API.
  prefs: []
  type: TYPE_NORMAL
- en: We are more interested in the whole app from an architectural point of view,
    instead of having detailed and fully integrated functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The Api class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this micro app, we are going to group our files by type context. First,
    we are going to create our micro app class, `apps/api/index.js`, and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This portion of the app mounts the routes exposed by `ProductRoutes` on the
    main Express app. The preceding `ProductRoutes` class takes a `ProductController`
    as a required parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are not going to discuss each controller and route in particular, and
    are only going to focus on the product part. We are going to use the `ProductCatalog`
    core service and call the required business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Product controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This controller is going to handle the requests to manage products. We are
    going to follow these steps to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `apps/api/controller/product.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach the `getAll` products method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Product router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining the routes is similar to what we did earlier in the `Auth` micro app,
    but we moved our routes into a separate file, called `apps/api/routes/products.js`.
    The content of the file is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the bearer authentication middleware was used from the core
    module to check whether a user has a valid token or not. This function has the
    following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: I think we have the big picture of how our `Api` micro app works and what needs
    to be done. You can follow the rest of the code in the project's repository.
  prefs: []
  type: TYPE_NORMAL
- en: Shared resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of our micro apps will use the same static assets in order not to replicate
    these resources across apps. We can create a micro app that will serve all the
    shared resources.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having a main `public` folder, each micro app that wants to serve
    static files can have a separate `public` folder. This means that we can move
    all of our shared static resources, and move them to the inner `public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index.js` file will have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We define a class and serve all the static resources from the `public` folder.
    The `resolve` method was used from the `path` module to resolve the path to the
    `public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it's fairly simple to make changes to our previous architecture
    from earlier chapters. Also, the preceding technique will be used in our `admin`
    micro app.
  prefs: []
  type: TYPE_NORMAL
- en: The admin section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, e-commerce solutions come with an admin section, where you can manage
    your products and inventory. The admin section for our application is going to
    be built with Angular 2\. Nothing fancy; we have already built a few apps with
    Angular, right?
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to go through all the details but only the most important parts
    of the application. Don't worry! Full source code is available for the project.
  prefs: []
  type: TYPE_NORMAL
- en: The admin micro app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We made a few architectural changes right from the beginning. Each of our micro
    apps will serve a specific purpose. The `admin` micro app will host the administration
    application built using Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding chapters, we used server-static to expose our `public` folder's
    content. This app will have its own `public` folder and will contain only the
    files related to our admin Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This micro app is going to be fairly simple. Create a file called `apps/admin/index.js`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `Admin` class will define our micro app and use the `serverStaticFiles()`
    method to expose the public folder's content for external use. The file serving
    for the admin app is mounted on the `/admin` URL path.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to take a look at the main `server.js` file to initialize your
    `admin` micro app correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the auth module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `admin` app uses a token to grant access to the API's endpoints. So we need
    to make a few changes to our `AuthHttp` service, from `apps/admin/public/src/auth/auth-http.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes affect the `request` method, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For each request, we add the `Authorization` header with the necessary token.
    Also, we need to retrieve the token from `localStorage` using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The token will be persisted to the `localStorage` on a successful sign-in.
    In `AuthService`, we are going to store the current user and its token and persist
    to `localStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When the user successfully signs in, we store the current user in a subject
    and notify all subscribers of that change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we can expose all the members from a context simply by using
    a single `index.ts` file, located in the root of the bounded context. For the
    `auth` module, we can have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, our `AuthHttp` service can be exported with `index.ts` using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can import it into another component using this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Products administration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the backend part, we created a service and exposed an API to manage products.
    Now on the client side, we need to create a module that will consume the API and
    let us do different operations.
  prefs: []
  type: TYPE_NORMAL
- en: The product service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to talk about only a few methods from our product service, because
    basically we are going to do only simple CRUD operations in the admin section.
    Let''s create a file called `apps/admin/public/src/services/product.service.ts`,
    with the following base content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, we''ll add the `getAll` products method. We are going to use
    this when we want to show a list of products. Append the following code to the
    `ProductService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the methods are in the full source code of the project.
  prefs: []
  type: TYPE_NORMAL
- en: List products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the main product administration section, we are going to list all the available
    products from the catalog. For this, we create another component found under `apps/admin/public/product/components/product-list.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will just list all the products retrieved from the service
    and have a route link to edit a specific product. You can easily list extra details
    of a product; you just need to modify the template.
  prefs: []
  type: TYPE_NORMAL
- en: The main product component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To manage our routes, we have to create a main entry point and create a component
    for this. To have a final picture, I''m going to show you the final version of
    `ProductComponent`, found under `apps/admin/public/src/product/product.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We are using this component to configure our routes for the products listing,
    for creating a new product, and for editing an existing product by a specific
    SKU. This way, we can easily mount it on a higher level component.
  prefs: []
  type: TYPE_NORMAL
- en: Add and edit a product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Basically, what we did is used the same template to edit and add a product.
    In this application, when viewing the product details, you are actually editing
    the product. In this way, we don't have to implement or mask the edit functionality
    separately from the detailed view.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that the application is in an early stage and there is no difference
    between creating a new product and updating an existing one, we can reduce the
    workload and implement both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The edit product source code can be found in `apps/admin/public/src/product/components/product-edit.component.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Order handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The system should handle orders, which means that someone needs to handle the
    status of the orders. Usually, orders can have a few states. I will try to explain
    some of these in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Status | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Pending | pending | The order is received (usually unpaid). |'
  prefs: []
  type: TYPE_TB
- en: '| Failed | failed | Something went wrong; that is, the payment failed or was
    declined. |'
  prefs: []
  type: TYPE_TB
- en: '| Processing | processing | The order is awaiting fulfillment. |'
  prefs: []
  type: TYPE_TB
- en: '| Completed | completed | The order is fulfilled and completed. Usually, no
    further action is required. |'
  prefs: []
  type: TYPE_TB
- en: '| On-hold | on_hold | The stock is reduced but waiting further confirmation,
    that is, payment. |'
  prefs: []
  type: TYPE_TB
- en: '| Cancelled | cancelled | The order was cancelled by the customer or admin.
    |'
  prefs: []
  type: TYPE_TB
- en: 'We are not going to handle all the scenarios we just described. The full version
    of the application supports only a few of them: pending, processing, cancelled,
    and completed. As we won''t implement a payment method, there is no need to handle
    all the scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: After so much code, I think we can take a break and only discuss this part.
    You can check out the working version from the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving orders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To manage all the incoming orders, we need to list all of them to the admin.
    We are not going to get into the details of the code because it is very similar
    to what we have done so far.
  prefs: []
  type: TYPE_NORMAL
- en: The service found at `public/src/order/order.service.ts` will handle all operations
    on the order entity. A nice touch that can be added in this application is getting
    a stream of orders from the backend. This is something similar to what we did
    in [Chapter 4](part0046_split_000.html#1BRPS1-5c78d361d97340239270192b72d53e7b
    "Chapter 4. Chat Application"), *Chat Application*, when we worked with WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we can notify all clients of the new orders available as soon
    as they are added into the system. This will give a boost when you have a high
    volume of incoming orders and would like to be notified as soon as possible so
    as to handle them as quickly as you can.
  prefs: []
  type: TYPE_NORMAL
- en: View and update orders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, before handling an order, you would like to see more information about
    it, such as the shipping address, or any other information the client provided
    to you. But at the same time, the actions required to handle an order should be
    kept at a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping all this in mind, we went with a solution in which one can view and
    edit the order in the same context. So, `OrderDetailsComponent` does exactly that;
    it can be found under the following location: `public/src/order/components/order-details.ts`.'
  prefs: []
  type: TYPE_NORMAL
- en: The full source can be found in the repository, but I'll try to explain what
    we did there.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Storefront
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed at the beginning of the chapter, we are going to try something
    different. Instead of building a single-page app for our Storefront, we are going
    to implement server-side-rendered pages.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, we are going to build a classical web page. The pages are going
    to be dynamic, rendered using a view engine to render our templates.
  prefs: []
  type: TYPE_NORMAL
- en: We want to truly leverage the benefits of our headless core application and
    see how we can integrate it with different client applications, so we are going
    to experiment a little bit with server-side-rendered pages using a third-party
    package.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily build this using Angular, but I wanted to add a twist, to see
    more complex solutions in action.
  prefs: []
  type: TYPE_NORMAL
- en: Storefront micro app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen before in the admin section of our application, we decoupled
    it from the main application into a micro app. So technically, we can just pull
    out the necessary code for the storefront from this application at any time, add
    it to a whole new Express app, and make all the calls across the network.
  prefs: []
  type: TYPE_NORMAL
- en: At first, this might seem a little strange, but as soon as your application
    starts growing and you need to scale your application, this will give you the
    upper hand to differentiate what part needs to be scaled or moved to a separate
    application for better scalability.
  prefs: []
  type: TYPE_NORMAL
- en: It is always a good thing to think ahead, but also, I'm not a big fan of early
    optimization. You cannot be certain from the beginning how your application will
    grow in time, but it is wise to plan ahead.
  prefs: []
  type: TYPE_NORMAL
- en: The Storefront application is going to showcase how we can integrate different
    techniques in the same application. The focus is purely educational, and this
    was added to the book to show different approaches to building Express apps.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about the technologies used to build our Storefront. We are going
    to use `nunjucks`, which is a nice templating engine for JavaScript. It can be
    used both on the server side and the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the templates part, we need to make some preparations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new apps folder under `apps/storefront`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new file, `apps/storefront/index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the micro app''s class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the view engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For this micro app, we started using a view engine to render our templates on
    the server side. The `configureViews()` method will initialize the `nunjucks`
    environment and load the template files from the filesystem. Also we are checking
    whether we should activate the cache and watch functionality from `nunjucks`.
    You can read more about this in the project's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we register the application's routes as for each of our previous Express
    applications we built together. For easier reading, I've only added the home location
    and only instantiated `ProductController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you are wondering what the `ProductController` is, we just use a class
    approach for our controller files so that we can instantiate it, and pass the
    core of the application. Let''s take a look at a section of the code from `apps/storefront/controllers/product.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: So basically, we are exporting a controller class, and in the `home()` method,
    we are retrieving products from the persistent storage—in our case, MongoDB—using
    our `ProductCatalog` service. After successfully getting all the products, we
    use the `render()` method from the response object to render an HTML response
    from our templates.
  prefs: []
  type: TYPE_NORMAL
- en: Storefront pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are not going to get into the details; you can check out the whole project
    and see how things are glued together.
  prefs: []
  type: TYPE_NORMAL
- en: Main layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To have a single layout definition, almost every template will extend a master
    template file. This master template file will contain all of the necessary markup
    of a full HTML document. The master layout file can be found under `apps/storefront/views/layout.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The main `layout.html` file defines blocks to inject content inside them. Because
    we have a `Shared` micro app, all the necessary assets are available to us, so
    we can import these assets using a separate file, `apps/storefront/views/includes/stylesheets.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: List products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To have full integration, let''s see how we can list our products. Create a
    new template file called `apps/storefront/views/home.html` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We just extend the `content` block with the preceding code, iterate through
    the products list, and create a new product using a partial view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at that partial view, `apps/storefront/views/partials/product.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The static HTML markup is turned into a dynamic view. We are using the same
    structure as in our `Admin` micro application built with Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in the rest of the code, go ahead to the project's repository
    at [https://github.com/robert52/mean-blueprints-ecommerce](https://github.com/robert52/mean-blueprints-ecommerce)
    and find out more details. This part of the application was only for showing a
    different approach that you can integrate into your MEAN stack. You can always
    extend your stack with different technologies and see what works for you better.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you need to combine things, but having a solid base can make your
    life easier in the long run. We could have built everything using Angular, but
    it's always great to see how we can extend our horizons.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was about building an e-commerce application. From the beginning
    of the chapter, we started experimenting with new application architecture, one
    that can be easily extended in the future, and also used for server-side rendering
    in the implementation of our storefront.
  prefs: []
  type: TYPE_NORMAL
- en: Although this was much different from the previous chapters, it served well
    for educational purposes and opened doors to new possibilities. Keep your architecture
    modular and only experiment with small portions first to see how things work out
    in your favor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll try to extend our existing e-commerce application
    with an auction application.
  prefs: []
  type: TYPE_NORMAL
