- en: Chapter 5. E-commerce Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 电子商务应用程序
- en: This chapter will focus on building an e-commerce like application. We are going
    to experiment with a different application architecture by building a core that
    will hold all the business logic and consume it with smaller apps. Also one more
    interesting thing to note is that the front store of our e-commerce application
    will be built using server-side rendering.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于构建一个类似电子商务的应用程序。我们将通过构建一个包含所有业务逻辑的核心并使用较小的应用程序来消费它来尝试不同的应用程序架构。还有一个有趣的事情要注意，那就是我们的电子商务应用程序的前端商店将使用服务器端渲染。
- en: This new architecture will enable us to build micro apps; for example, one app
    could be the admin application that is going to manage the product catalog. The
    benefit is that each micro app can be built using different approaches.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的架构将使我们能够构建微应用；例如，一个应用可以是管理产品目录的管理应用程序。好处是每个微应用都可以使用不同的方法构建。
- en: As a demonstration, we are not going to build our front store in Angular. Sounds
    crazy I know, but for educational purposes, it's going to be great. Also, we want
    to highlight how easy it is to build hybrid applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，我们不会在Angular中构建我们的前端商店。我知道这听起来很疯狂，但出于教育目的，这将非常棒。此外，我们还想强调构建混合应用程序是多么容易。
- en: The admin part of the application is going to be built using Angular 2\. Because
    of this, we are going to build a headless core backend service. This core application
    will be consumed by our micro apps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的管理部分将使用Angular 2来构建。因此，我们将构建一个无头核心后端服务。这个核心应用程序将被我们的微应用消费。
- en: Setting up the base application
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本应用程序
- en: In previous chapters, we used our own boilerplate to bootstrap the application's
    development. This chapter is going to have a fresh folder structure, but don't
    worry; we are still going to use a lot of code from the existing boilerplate.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用自己的样板文件来启动应用程序的开发。这一章将有一个全新的文件夹结构，但请放心；我们仍然会使用大量现有的样板代码。
- en: A new folder structure will give us more flexibility, as at the moment we have
    outgrown our initial architecture. One benefit, which we are not going to cover
    in this chapter, is that you can move each module to a separate package and install
    them as dependencies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 新的文件夹结构将给我们更多的灵活性，因为我们已经超出了最初的架构。一个好处，我们不会在本章中介绍，就是您可以将每个模块移动到单独的包中，并将它们作为依赖项安装。
- en: 'Before jumping into things, let''s see a high-level view of our architecture:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨之前，让我们先看看我们架构的高层次视图：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The explanation for the folder structure is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构的解释如下：
- en: '`apps`: This folder will contain several micro apps, such as `frontstore`,
    which will serve as the client application for users visiting our e-commerce store.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps`: 这个文件夹将包含多个微应用，例如`frontstore`，它将为访问我们电子商务商店的用户提供客户端应用程序。'
- en: '`core`: This is going to be the heart of our application, containing all the
    necessary business logic:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core`: 这将是我们的应用程序的核心，包含所有必要的业务逻辑：'
- en: '`middlewares`: In this folder, we''ll store all our pieces of functions that
    will manipulate the request and response object. A good example would be authentication
    middleware.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`middlewares`: 在这个文件夹中，我们将存储所有将操作请求和响应对象的函数片段。一个很好的例子就是身份验证中间件。'
- en: '`models`: This folder will store all the backend models.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`: 这个文件夹将存储所有后端模型。'
- en: '`services`: This will group all common sets of application logic available
    for different clients and will coordinate the consumption of business logic.'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`: 这将分组所有适用于不同客户端的通用应用程序逻辑集合，并将协调业务逻辑的消耗。'
- en: '`config`: All application configuration files go here.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`: 所有应用程序配置文件都放在这里。'
- en: '`environments`: This folder contains files loaded according to the current
    environment'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environments`: 这个文件夹包含根据当前环境加载的文件'
- en: '`tests`: This folder contains all the tests necessary to test the application
    backend logic.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`: 这个文件夹包含测试应用程序后端逻辑所需的所有测试。'
- en: Data modeling
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据建模
- en: Now that we have a high-level view of our architecture, let's define our models
    and see how they interact. This will give you a high-level view of how you are
    going to store your data in the database. Also, it will reflect the connections
    between different entities and you can decide, in the case of MongoDB, what documents
    will be embedded and which ones will be referenced.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对架构有了高层次的认识，让我们定义我们的模型并看看它们是如何交互的。这将为您提供一个高层次的数据存储方式，您将如何将数据存储在数据库中。此外，它还将反映不同实体之间的连接，您可以在MongoDB的情况下决定哪些文档将被嵌入，哪些将被引用。
- en: Custom money data type
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义货币数据类型
- en: In the earlier Expense Tracker application, we concluded that there is a way
    to work with monetary data in JavaScript and MongoDB. It only needs extra application
    logic to handle the Exact Precision solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的支出跟踪应用程序中，我们得出结论，在 JavaScript 和 MongoDB 中处理货币数据是有方法的。只需要额外的应用程序逻辑来处理精确精度解决方案。
- en: Because we are working with Mongoose as our ODM for Mongo, we can define a custom
    model for monetary data. I know it sounds strange, but it will give us the upper
    hand by defining virtual properties and reusing the money data type in our application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Mongoose 作为我们的 MongoDB ODM，我们可以为货币数据定义一个自定义模型。我知道这听起来很奇怪，但通过定义虚拟属性和在我们的应用程序中重用货币数据类型，这将给我们带来优势。
- en: 'Let''s create a file called `core/models/money.js` and add the following Mongoose
    schema:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `core/models/money.js` 的文件，并添加以下 Mongoose 架构：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For easier readability, I did the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，我做了以下操作：
- en: Defined a default currency with a default scale factor. To achieve better customization,
    you can add these into a configuration file.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个默认货币和默认缩放因子。为了实现更好的定制，你可以将这些添加到配置文件中。
- en: Added a virtual named `display`, which will be the display value of the money
    model, for example, 18.99.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个名为 `display` 的虚拟属性，它将是货币模型的显示值，例如，18.99。
- en: Now, having that out of the way, let's see what is going on with the preceding
    code. We created a custom Money model, which will serve us as a Money data type.
    As you can see, we disabled the autogeneration of the `_id` property. This way,
    if we use the model as an embedded document, Mongoose will not generate an `_id`
    property.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经解决了这个问题，让我们看看前面的代码。我们创建了一个自定义的 Money 模型，它将作为 Money 数据类型为我们服务。正如你所看到的，我们禁用了
    `_id` 属性的自动生成。这样，如果我们将模型用作嵌入式文档，Mongoose 不会生成 `_id` 属性。
- en: 'Let''s see an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When transforming the price to an object, the output will contain all of the
    necessary information and we don't need to do any calculations using floats. Remember
    that we are storing the scale factor and the currency within the price model because
    this needs to be consistent across the application with the currency.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当将价格转换为对象时，输出将包含所有必要的信息，我们不需要使用浮点数进行任何计算。记住，我们因为需要在整个应用程序中与货币保持一致性，所以将缩放因子和货币存储在价格模型中。
- en: The product model
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品模型
- en: When creating an e-commerce application, you have to think about storing many
    different product types in your catalog. The MongoDB data model will come in handy
    in this situation due to the fact that we can represent data in any structure.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建电子商务应用程序时，你必须考虑在目录中存储许多不同的产品类型。由于我们可以以任何结构表示数据，MongoDB 数据模型在这种情况下将非常有用。
- en: 'Structuring data in an RDBMS would be a little bit harder; for example, one
    approach would be to represent each product type in a separate table. Each would
    have a different table structure. An alternative and popular approach would be
    **EAV**, which stands for **Entity Attribute Values**. In this case, you maintain
    a table with at least three columns: `entity_id`, `attribute_id`, and `value`.
    The EAV solution is very flexible, but it comes with a downside. Complex queries
    require a large number of JOIN operations, which can degrade performance.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库管理系统（RDBMS）中结构化数据会稍微困难一些；例如，一种方法是将每种产品类型表示为单独的表。每个表都会有不同的结构。另一种替代且流行的方法是
    **EAV**，代表 **实体属性值**。在这种情况下，你维护一个至少包含三列的表：`entity_id`、`attribute_id` 和 `value`。EAV
    解决方案非常灵活，但也有一些缺点。复杂的查询需要大量的 JOIN 操作，这可能会降低性能。
- en: 'Luckily for us, as pointed out earlier, MongoDB has a dynamic schema solution,
    and we can store all of the product data in one collection. We could have generic
    information of a product and product-specific information for different product
    types. Let''s get down to business and define our product schema. Create a file
    called `core/models/product.js`, and add the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如之前指出的那样，MongoDB 有一个动态架构解决方案，我们可以将所有产品数据存储在一个集合中。我们可以存储产品的通用信息和针对不同产品类型的产品特定信息。让我们开始定义我们的产品架构。创建一个名为
    `core/models/product.js` 的文件，并添加以下代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we have a few fields that all types of products are going to
    have, and we have a mixed property called `details` that will hold all the necessary
    details about a specific product. Also we used our custom data type for the `price`
    property. A product, by default, will be flagged as inactive in the product catalog
    so that it will be shown only when all the necessary information is added.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一些字段，所有类型的商品都将拥有这些字段，并且我们有一个混合属性称为`details`，它将包含关于特定商品的所有必要细节。此外，我们为`price`属性使用了自定义数据类型。默认情况下，产品在产品目录中将被标记为非活动状态，这样它只有在所有必要信息添加后才会显示。
- en: Earlier in the book—more precisely in [Chapter 3](part0035_split_000.html#11C3M1-5c78d361d97340239270192b72d53e7b
    "Chapter 3. Job Board"), *Job Board*—we used the `slug` definition for URL-friendly
    titles for our job openings. This time, we are going to use it for our product
    titles. To simplify things, we are going to automatically generate them when a
    new entry is created.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期——更确切地说是在[第3章](part0035_split_000.html#11C3M1-5c78d361d97340239270192b72d53e7b
    "第3章。职位板")中——我们使用了`slug`定义来为我们的职位空缺创建URL友好的标题。这次，我们将用它来为我们的产品标题。为了简化问题，我们将在创建新条目时自动生成它们。
- en: 'Prepend the following code in your product model file, before the `module.exports`
    line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的产品模型文件中，在`module.exports`行之前，添加以下代码：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To freshen up your memory, we used the same technique in [Chapter 3](part0035_split_000.html#11C3M1-5c78d361d97340239270192b72d53e7b
    "Chapter 3. Job Board"), *Job Board* to create a slug from a title. So, this basically
    generates a URL-friendly string from the product title before saving in the database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了唤醒您的记忆，我们在[第3章](part0035_split_000.html#11C3M1-5c78d361d97340239270192b72d53e7b
    "第3章。职位板")中使用了相同的技巧，即*职位板*，从标题中创建一个缩略词。因此，这基本上是在数据库保存之前，从产品标题生成一个URL友好的字符串。
- en: This pretty much sums up our product schema and should give us a solid start
    for storing products in MongoDB.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上总结了我们的产品模式，并应该为我们存储产品在MongoDB中提供一个坚实的基础。
- en: The order model
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单模型
- en: Due to the fact that we are trying to build an e-commerce application, we somehow
    need to be able to store what users have purchased from our store. We are going
    to store all of this information in an `orders` collection in MongoDB. An `order`
    entry should contain information about what products were bought, shipping details,
    and who made the purchase.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在尝试构建一个电子商务应用程序，我们某种程度上需要能够存储用户从我们的商店购买的商品。我们将所有这些信息存储在MongoDB的`orders`集合中。一个`order`条目应包含有关购买的产品、运输细节以及谁进行了购买的信息。
- en: When you analyze this, the first thing that you think about is that we would
    also need to have a cart before placing an order. But if we reduce everything
    to a simple use case, we can consider that a cart is a special kind of an order.
    What I mean is that a cart holds product items that will be purchased and an order
    will be created for that purchase.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您分析这个问题时，您首先想到的是，我们在下订单之前也需要有一个购物车。但如果我们把一切都简化为简单的用例，我们可以考虑购物车是一种特殊的订单。我的意思是，购物车包含将要购买的产品项，而订单将为这次购买创建。
- en: 'So, in simple terms, only the perspective changes how we see an order. We could
    have a `type` property for an order to determine its state. So we have a few key
    points to define our order schema. Now we can create a new file called `core/models/order.js`,
    and add the following schema:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，只有视角的改变会影响我们看待订单的方式。我们可以为订单添加一个`type`属性来决定其状态。因此，我们有几个关键点来定义我们的订单模式。现在我们可以创建一个名为`core/models/order.js`的新文件，并添加以下模式：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, an order will store all selected products in the `items` property,
    together with simple information, such as the `sku`, `quantity`, and `price` of
    the product. We store some non-trivial data in the items list as the product's
    `title` so that we don't have to retrieve it for non-trivial operations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，订单将在`items`属性中存储所有选定的产品，以及一些简单信息，如产品的`sku`、`quantity`和`price`。我们在项目列表中存储一些非平凡数据，如产品的`title`，这样我们就不必在非平凡操作中检索它。
- en: When we are dealing with a `cart` entry, we want it to eventually expire if
    it is not finalized as an order. This is because we want to release items from
    the cart to be available.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理一个`cart`条目时，我们希望它最终过期，如果它没有被作为订单最终确定。这是因为我们希望释放购物车中的项目以供使用。
- en: Probably, we are going to store extra details about the order and shipping details
    that could vary from order to order. That's why we marked them as mixed data types.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，我们将存储关于订单和运输细节的额外信息，这些信息可能因订单而异。这就是为什么我们将它们标记为混合数据类型。
- en: The inventory model
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库存模型
- en: Until now, we have defined the product schema and the order schema. Neither
    mentioned anything about the inventory status. In the `order` schema, we store
    for each product item, what quantity was placed in the order, but this won't reflect
    the initial stock or the current stock.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了产品模式（schema）和订单模式（schema）。两者都没有提及库存状态。在 `order` 模式中，我们为每个产品项存储了订单中放置的数量，但这不会反映初始库存或当前库存。
- en: There are a few approaches when working with inventory data, each with its own
    benefits and downsides. For example, we can store a single record for each physical
    product; so if we have 100 stock units of a product, we store 100 records in the
    inventory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理库存数据时，有几种方法，每种方法都有其自身的优点和缺点。例如，我们可以为每个实体产品存储单个记录；因此，如果我们有一个产品的100个库存单位，我们将在库存中存储100条记录。
- en: In a large product catalog, this would not be a good solution, as the `inventory`
    collection would grow very quickly. Storing separate entries for each unit can
    be beneficial when you have physical products and a low volume of stock units.
    An example is a wood shop that builds furniture and wants to track more details
    for each physical unit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型产品目录中，这不会是一个好的解决方案，因为 `inventory` 集合会迅速增长。当你有实体产品和低库存单位数量时，为每个单位存储单独条目可能是有益的。例如，一个木工店制作家具并希望跟踪每个物理单位的更多详细信息。
- en: 'An alternative would be to store a single entry for each product, with the
    quantity of the product in stock. Now that we have a good hint about what needs
    to be done, let''s create the inventory model, called `core/models/inventory.js`,
    with the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是为每个产品存储单个条目，其中包含产品的库存数量。现在我们已经很好地了解了需要做什么，让我们创建一个名为 `core/models/inventory.js`
    的库存模型，代码如下：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We pushed things a little bit further and added a `carted` property. This will
    hold all the items that are active in a cart to help us track the progress of
    each reserved item in the inventory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将事情推进了一步，并添加了一个 `carted` 属性。这将保存购物车中所有活跃的项目，帮助我们跟踪库存中每个预留项目的进度。
- en: This way, you can have a clean history of the level of the inventory. You can
    omit the `carted` property and only rely on information from the `orders` collection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以有一个干净的库存水平历史记录。你可以省略 `carted` 属性，只依赖 `orders` 集合中的信息。
- en: The core Service Layer
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心服务层
- en: Because our application will have different clients consuming business logic,
    we are going to add a Service Layer; it will coordinate operations for different
    use cases. So, we are going to move most of our business logic from controllers
    to services. Probably, it's too early to see the benefits of this, but as we progress
    with this chapter, it will make more sense.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的应用程序将有不同的客户端消费业务逻辑，我们将添加一个服务层；它将协调不同用例的操作。因此，我们将把大部分业务逻辑从控制器移动到服务中。可能现在还太早看到这种做法的好处，但随着我们继续本章的学习，它将变得更加有意义。
- en: One benefit would be that you can simply expose your Service Layer as a RESTful
    API, or add another client that will render on the server-side templates and display
    all the necessary information to the user. Regardless of the application's client
    implementation, you can test the business logic of your application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好处是，你可以简单地暴露你的服务层作为RESTful API，或者添加另一个将在服务器端渲染模板并显示所有必要信息的客户端。无论应用程序的客户端实现如何，你都可以测试应用程序的业务逻辑。
- en: The product catalog
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品目录
- en: The product catalog will contain all the products you want to be shown or simply
    exist in the system. Each item in the catalog will be stored in MongoDB, in the
    `products` collection. We are going to create a `ProductCatalog` service, which
    will hold all the business logic for managing the products in our e-commerce application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 产品目录将包含你希望显示或仅存在于系统中的所有产品。目录中的每个项目都将存储在MongoDB的 `products` 集合中。我们将创建一个 `ProductCatalog`
    服务，它将包含我们电子商务应用程序中管理产品的所有业务逻辑。
- en: 'Let''s follow a few steps in order to create the product catalog service:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建产品目录服务：
- en: Create the service file, called `core/services/product-catalog.js`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `core/services/product-catalog.js` 的服务文件。
- en: 'Add the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Declare the class constructor:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明类构造函数：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Adding a product to the catalog:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将产品添加到目录中：
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We'll add each class method one by one.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将逐个添加类方法。
- en: 'Edit an existing product:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑现有产品：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'List all products:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有产品：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Get more details using the `sku` identifier:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sku` 标识符获取更多详细信息：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Get a product by `slug`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `slug` 获取产品：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We managed to put down a base for our product catalog service. As you can see,
    it only masks certain functionalities from the end module, which should not know
    of the underlining layer or how data is stored. It can be a database, as MongoDB
    is in our case, or simply a filesystem.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地为我们产品目录服务奠定了基础。正如你所看到的，它只掩盖了最终模块中的一些功能，这些模块不应该知道底层或数据是如何存储的。它可以是数据库，比如我们案例中的MongoDB，或者简单地是一个文件系统。
- en: 'The first benefit that we get is testability, as we can test our application''s
    business logic and run an integration test before even implementing a higher-level
    layer. For example, we can have the following piece of code, extracted from `tests/integration/product-catalog.test.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得的第一大好处是可测试性，因为我们可以在实现高级层之前测试应用程序的业务逻辑并运行集成测试。例如，我们可以有如下代码片段，它来自`tests/integration/product-catalog.test.js`：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding test case will simply check whether all the operations done by
    the service are correct. We did a lot of test-driven development in the earlier
    chapters, and in the later chapters, we focused more on functionality, but this
    does not mean that we skipped writing tests. The tests are available in the full
    source code for you to check out and follow while developing the application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试用例将简单地检查服务执行的所有操作是否正确。我们在前面的章节中进行了大量的测试驱动开发，在后面的章节中，我们更多地关注功能，但这并不意味着我们忽略了编写测试。测试可以在完整的源代码中找到，供你在开发应用程序时检查和遵循。
- en: The inventory manager
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库存管理器
- en: Lots of e-commerce solutions out in the wild come with an inventory manager,
    which will help you keep track of a product's stock level, replenish your product's
    stock level, or adjust it as desired.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 野外有许多电子商务解决方案都包含库存管理器，这将帮助你跟踪产品的库存水平，补充你的产品库存，或者按需调整。
- en: We didn't want to embed inventory information in the product document, so we
    are going to store it separately for each product. There are many ways you can
    track your inventory; we have chosen a solution that fits most of the use cases,
    and it's easy to implement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在产品文档中嵌入库存信息，所以我们将为每个产品单独存储它。你可以用很多方法跟踪你的库存；我们选择了一个适合大多数用例的解决方案，并且易于实现。
- en: 'Before we begin coding, I would like to go through the test cases to give you
    a hint about what we are going to implement:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我想通过测试用例给你一些提示，关于我们将要实现的内容：
- en: 'We should be able to track the inventory for a product:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该能够跟踪产品的库存：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A desired quantity of a given product should be reserved from the inventory
    on demand:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需求，应从库存中预留给定产品的期望数量：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If there is not adequate inventory, the service should not satisfy the request:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果库存不足，服务不应满足请求：
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Increase the available quantity:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加可用数量：
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or you can decrease the available quantity to make adjustments:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你可以减少可用数量以进行调整：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have taken a glance at what needs to be done, let''s follow a few
    steps to create our inventory manager service:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经大致了解了需要做什么，让我们遵循以下步骤来创建我们的库存管理器服务：
- en: Create a new file, `core/services/inventory-manager.js`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`core/services/inventory-manager.js`。
- en: 'Define a starting point:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个起点：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Complete the class constructor:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成类构造函数：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember that we can inject a custom `InventoryModel` inside our service as
    long as it has at least the necessary properties and methods.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，只要它具有至少必要的属性和方法，我们就可以在我们的服务中注入自定义的`InventoryModel`。
- en: 'Create a new inventory item method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的库存项目方法：
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the quantity private method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改数量私有方法：
- en: '[PRE23]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We created a private method, prefixed with an underscore for semantics. This
    will serve as the main entry point when manipulating stock levels. If nothing
    has changed, we return an error. After a successful operation, we return the current
    state of the inventory entry.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了一个私有方法，以下划线为前缀以增强语义。当操作库存水平时，这将成为主要入口点。如果没有变化，我们返回一个错误。在操作成功后，我们返回库存条目的当前状态。
- en: 'Increase and decrease the quantity:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加和减少数量：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code will reserve the available quantity of a product in the inventory.
    In some cases, the system cannot satisfy the requested quantity, so we check to
    make sure that we have the desired availability before decrementing the quantity.
    If we cannot fulfill the request, we return a specific error.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将预留库存中产品的可用数量。在某些情况下，系统无法满足请求的数量，所以我们检查在减少数量之前是否有所需的可用性。如果我们无法满足请求，我们返回一个特定的错误。
- en: Also you might notice that we have progressively added our own custom `Error`
    object, which also contains a suggestion for the status code itself. At this time,
    errors returned from the service have no standard format, due to the fact that
    the underlining ODM could return different `Error` objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，我们逐渐添加了自己的自定义 `Error` 对象，它还包含了对状态码本身的建议。目前，由于底层 ODM 可能返回不同的 `Error`
    对象，服务返回的错误没有标准格式。
- en: We won't be able to satisfy all use cases in this book, so sometimes you have
    to put the pieces together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们可能无法满足所有用例，所以有时你必须将各个部分组合起来。
- en: Shopping cart
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车
- en: By this time, we should have all the necessary services used by the shopping
    cart service. Now this service will be quite interesting, if you permit me to
    say so. Regularly, e-commerce solutions have a shopping cart in which customers
    can easily add or remove items, change quantities, and even abandon them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该已经拥有了购物车服务所需的所有必要服务。现在，如果你允许我说的话，这个服务将会非常有趣。通常，电子商务解决方案都有一个购物车，客户可以轻松地添加或移除商品，更改数量，甚至放弃购物。
- en: One important thing to note is that we have to make sure that a customer cannot
    add items that are unavailable. In other words, if a product stock doesn't match
    the requested quantity, the add action should not succeed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要注意，那就是我们必须确保客户不能添加不可用的商品。换句话说，如果产品库存与请求的数量不匹配，添加操作不应成功。
- en: Basically, our shopping cart service will handle all the business logic described
    previously. Also, when a customer adds an item to the cart, the inventory should
    be properly updated. Remember that our orders collection will hold the carts as
    well.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们的购物车服务将处理之前描述的所有业务逻辑。此外，当客户向购物车添加商品时，库存应该得到适当的更新。记住，我们的订单集合也会保存购物车。
- en: 'Things are pretty clear about what needs to be done. If not, go and take a
    quick look at the test cases. Let''s create our shopping cart service, `core/services/shopping-cart.js`,
    and add the following class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关于需要做什么事情已经很明确了。如果不清楚，可以去快速查看一下测试用例。让我们创建我们的购物车服务，`core/services/shopping-cart.js`，并添加以下类：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Noting fancy here. We can move on by adding our constructor:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的地方。我们可以通过添加构造函数来继续：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before I forget, we are going to use the other two services we implemented
    earlier to manage the inventory and retrieve products from our catalog. Moreover,
    before adding a new item into the cart, we need to create it. So let''s add the
    `createCart()` method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我忘记之前，我们将使用之前实现的其他两个服务来管理库存并从我们的目录中检索产品。此外，在将新商品添加到购物车之前，我们需要创建它。所以让我们添加 `createCart()`
    方法：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When adding a new item into the shopping cart, we have to take care of a few
    things, and we must verify that the inventory meets the request''s requirements.
    Let''s sketch out the `addProduct()` method of the cart service:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当将新产品添加到购物车时，我们必须注意一些事情，并且必须验证库存是否符合请求的要求。让我们绘制购物车服务的 `addProduct()` 方法：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When adding a product into the cart, we want to store some additional information,
    so we first need to retrieve the product from the catalog using the SKU. The product
    needs to be added with the desired quantity to the cart's items. After successfully
    populating the cart with the new item, we need to decrease the number of units
    available in the inventory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当将产品添加到购物车时，我们希望存储一些额外的信息，因此我们首先需要使用 SKU 从目录中检索产品。需要将所需数量的产品添加到购物车的商品中。在成功填充购物车后，我们需要减少库存中可用的单位数量。
- en: If there are not enough items in the inventory, we must roll back the cart update
    and raise an error in the application. Finally, we get a fresh copy of the persisted
    cart.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库存中的商品不足，我们必须回滚购物车更新并在应用程序中引发错误。最后，我们得到一个持久化的购物车副本。
- en: 'Beside the methods used from the other two services, we have a few left to
    implement for the `ShoppingCart` class, such as the `_pushItems()` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从其他两个服务中使用的其他方法外，我们还需要为 `ShoppingCart` 类实现一些方法，例如 `_pushItems()` 方法：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The cart must be active in order to add items to it. Also, we have to update
    the expiration date. Remember that we are doing atomic operations on our documents,
    so only the raw responses of the operations are returned.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车必须处于活动状态才能向其中添加商品。此外，我们还需要更新过期日期。记住，我们正在对文档执行原子操作，因此只返回操作的原始响应。
- en: 'If we want to roll back our cart, we need to pull out the added items; the
    `_pullItems()` method does exactly this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要回滚购物车，我们需要移除已添加的商品；`_pullItems()` 方法正是如此操作：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By this time, we should be able to manage our cart easily with the implemented
    functionalities. The `ShoppingCart` service has used both the `InventoryManager`
    and `ProductCatalog` services, exposing the exact business logic we need to handle
    operations on a cart.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该能够使用实现的功能轻松管理我们的购物车。`ShoppingCart`服务使用了`InventoryManager`和`ProductCatalog`服务，暴露了处理购物车操作所需的精确业务逻辑。
- en: The Auth micro app
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证微应用
- en: The `Auth` micro app will handle authentications in different scenarios. It's
    going to be our main entry point to authenticate users, using stateful and stateless
    approaches.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Auth`微应用将在不同场景下处理认证。它将成为我们认证用户的入口点，使用有状态和无状态的方法。'
- en: Our core module already exposes middleware to check whether a user is authenticated
    or not, and authorization-related middleware. This functionality can be used in
    any module or micro app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的核心模块已经暴露了中间件来检查用户是否已认证，以及与授权相关的中间件。此功能可以在任何模块或微应用中使用。
- en: Defining the class
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类
- en: 'This is going to be our first micro app, so let''s go through a few steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的第一个微应用，所以让我们一步一步来：
- en: Create a new micro app called `apps/auth/index.js`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`apps/auth/index.js`的新微应用。
- en: 'Add the following base content:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下基本内容：
- en: '[PRE31]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define the constructor:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义构造函数：
- en: '[PRE32]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We defined a base URL for our micro app and mounted the router on the main Express
    application. We also created a new instance of the Controller used in the `Auth`
    micro app.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为我们的微应用定义了一个基本URL，并在主Express应用上挂载了路由器。我们还创建了一个用于`Auth`微应用的Controller的新实例。
- en: 'Register all necessary routes:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册所有必要的路由：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In order to save development time, we borrowed code from previous chapters,
    so the preceding lines of code are probably already familiar to you.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了节省开发时间，我们从前几章借用了代码，所以前面的代码可能已经熟悉了。
- en: 'Initialize your micro app in the main `server.js` file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`server.js`文件中初始化您的微应用：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the main `server.js` file, we are going to initialize each app. You can take
    a look at the final version of the `server.js` file to see exactly where to put
    things.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`server.js`文件中，我们将初始化每个应用。您可以查看`server.js`文件的最终版本，以确切了解放置内容的位置。
- en: The controller
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Earlier, I stated that we are reusing code from previous chapters. We also
    did this for the controller. We turned our controller into a class called `AuthController`
    and exposed the following methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到我们正在重用前几章中的代码。我们也为Controller做了这件事。我们将Controller转换成了一个名为`AuthController`的类，并暴露了以下方法：
- en: 'To sign in users using a stateful authentication strategy:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用有状态认证策略登录用户：
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Authenticate using a stateless strategy:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无状态策略进行认证：
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In some cases, we don't need to persist the user's session. Instead, we create
    a token that will be used at each request to see who tries to access our endpoints.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在某些情况下，我们不需要持久化用户的会话。相反，我们创建一个将在每个请求中使用的令牌，以查看谁试图访问我们的端点。
- en: 'Register a user in our system:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的系统中注册一个用户：
- en: '[PRE37]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Exposing an API
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露API
- en: Our core business logic needs to be accessed in some way, and I think a RESTful
    API would serve us in a good way. In order to get a better understanding and move
    through the whole app, we are only going to showcase a few parts from our API.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的核心业务逻辑需要以某种方式访问，我认为RESTful API会为我们提供很好的服务。为了更好地理解并遍历整个应用，我们只展示API的几个部分。
- en: We are more interested in the whole app from an architectural point of view,
    instead of having detailed and fully integrated functionalities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更关注整个应用从架构的角度，而不是拥有详细和完全集成的功能。
- en: The Api class
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Api类
- en: 'For this micro app, we are going to group our files by type context. First,
    we are going to create our micro app class, `apps/api/index.js`, and add the following
    content:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个微应用，我们将按类型上下文分组我们的文件。首先，我们将创建我们的微应用类，`apps/api/index.js`，并添加以下内容：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This portion of the app mounts the routes exposed by `ProductRoutes` on the
    main Express app. The preceding `ProductRoutes` class takes a `ProductController`
    as a required parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用的这部分将`ProductRoutes`暴露的路由挂载到主Express应用上。前面的`ProductRoutes`类需要一个`ProductController`作为必需参数。
- en: Now we are not going to discuss each controller and route in particular, and
    are only going to focus on the product part. We are going to use the `ProductCatalog`
    core service and call the required business logic.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不会特别讨论每个Controller和路由，我们只关注产品部分。我们将使用`ProductCatalog`核心服务并调用所需业务逻辑。
- en: Product controller
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品控制器
- en: 'This controller is going to handle the requests to manage products. We are
    going to follow these steps to implement it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器将处理管理产品的请求。我们将按照以下步骤来实现它：
- en: Create a new file called `apps/api/controller/product.js`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `apps/api/controller/product.js` 的新文件。
- en: 'Define the controller:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义控制器：
- en: '[PRE39]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Attach the `getAll` products method:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `getAll` 产品方法：
- en: '[PRE40]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Product router
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品路由
- en: 'Defining the routes is similar to what we did earlier in the `Auth` micro app,
    but we moved our routes into a separate file, called `apps/api/routes/products.js`.
    The content of the file is fairly simple:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 定义路由与我们在 `Auth` 微应用中之前所做的方式类似，但我们把路由移动到了一个单独的文件中，称为 `apps/api/routes/products.js`。文件的内容相当简单：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, the bearer authentication middleware was used from the core
    module to check whether a user has a valid token or not. This function has the
    following body:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们从核心模块使用了 bearer 认证中间件来检查用户是否拥有有效的令牌。这个函数具有以下结构：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I think we have the big picture of how our `Api` micro app works and what needs
    to be done. You can follow the rest of the code in the project's repository.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们已经了解了我们的 `Api` 微应用是如何工作的以及需要做什么。你可以通过项目的代码仓库来查看其余的代码。
- en: Shared resources
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享资源
- en: Many of our micro apps will use the same static assets in order not to replicate
    these resources across apps. We can create a micro app that will serve all the
    shared resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 许多微应用将使用相同的静态资源，以避免在应用程序之间重复这些资源。我们可以创建一个微应用来提供所有共享资源。
- en: Instead of having a main `public` folder, each micro app that wants to serve
    static files can have a separate `public` folder. This means that we can move
    all of our shared static resources, and move them to the inner `public` folder.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是有一个主要的 `public` 文件夹，每个想要提供静态文件的微应用都可以有一个单独的 `public` 文件夹。这意味着我们可以将所有共享的静态资源移动到内部的
    `public` 文件夹中。
- en: 'We will have the following folder structure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拥有以下文件夹结构：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `index.js` file will have the following content:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js` 文件将包含以下内容：'
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We define a class and serve all the static resources from the `public` folder.
    The `resolve` method was used from the `path` module to resolve the path to the
    `public` folder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个类，并从 `public` 文件夹提供所有静态资源。我们使用了 `path` 模块中的 `resolve` 方法来解析到 `public`
    文件夹的路径。
- en: As you can see, it's fairly simple to make changes to our previous architecture
    from earlier chapters. Also, the preceding technique will be used in our `admin`
    micro app.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，修改我们之前章节中的架构相当简单。此外，前面的技术也将用于我们的 `admin` 微应用。
- en: The admin section
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理部分
- en: Usually, e-commerce solutions come with an admin section, where you can manage
    your products and inventory. The admin section for our application is going to
    be built with Angular 2\. Nothing fancy; we have already built a few apps with
    Angular, right?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，电子商务解决方案都包含一个管理部分，您可以在其中管理您的产品和库存。我们的应用的管理部分将使用 Angular 2 构建。没有什么特别的；我们不是已经用
    Angular 构建了一些应用吗？
- en: We are not going to go through all the details but only the most important parts
    of the application. Don't worry! Full source code is available for the project.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍所有细节，只介绍应用中最重要的一部分。不用担心！项目的完整源代码都是可用的。
- en: The admin micro app
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理微应用
- en: We made a few architectural changes right from the beginning. Each of our micro
    apps will serve a specific purpose. The `admin` micro app will host the administration
    application built using Angular 2.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一开始就做了一些架构上的改变。我们的每个微应用都将服务于特定的目的。`admin` 微应用将托管使用 Angular 2 构建的管理应用。
- en: In the preceding chapters, we used server-static to expose our `public` folder's
    content. This app will have its own `public` folder and will contain only the
    files related to our admin Angular application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了 server-static 来公开 `public` 文件夹的内容。这个应用将拥有自己的 `public` 文件夹，并且只包含与我们的
    Angular 管理应用相关的文件。
- en: 'This micro app is going to be fairly simple. Create a file called `apps/admin/index.js`
    with the following content:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微应用将会相当简单。创建一个名为 `apps/admin/index.js` 的文件，内容如下：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `Admin` class will define our micro app and use the `serverStaticFiles()`
    method to expose the public folder's content for external use. The file serving
    for the admin app is mounted on the `/admin` URL path.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Admin` 类将定义我们的微应用，并使用 `serverStaticFiles()` 方法公开公共文件夹的内容以供外部使用。文件服务在 `/admin`
    URL 路径上挂载。'
- en: Don't forget to take a look at the main `server.js` file to initialize your
    `admin` micro app correctly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记查看主要的 `server.js` 文件以正确初始化您的 `admin` 微应用。
- en: Changing the auth module
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改认证模块
- en: The `admin` app uses a token to grant access to the API's endpoints. So we need
    to make a few changes to our `AuthHttp` service, from `apps/admin/public/src/auth/auth-http.ts`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`admin`应用使用令牌来授权访问API的端点。因此，我们需要对我们的`AuthHttp`服务进行一些更改，从`apps/admin/public/src/auth/auth-http.ts`开始。'
- en: 'The changes affect the `request` method, which will look like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改会影响`request`方法，其外观将如下所示：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For each request, we add the `Authorization` header with the necessary token.
    Also, we need to retrieve the token from `localStorage` using the following method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，我们添加必要的令牌的`Authorization`头。此外，我们还需要使用以下方法从`localStorage`检索令牌：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The token will be persisted to the `localStorage` on a successful sign-in.
    In `AuthService`, we are going to store the current user and its token and persist
    to `localStorage`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌将在成功登录后持久化到`localStorage`。在`AuthService`中，我们将存储当前用户及其令牌并将其持久化到`localStorage`：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When the user successfully signs in, we store the current user in a subject
    and notify all subscribers of that change.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户成功登录时，我们将当前用户存储在主题中，并通知所有订阅该更改的订阅者。
- en: 'Remember that we can expose all the members from a context simply by using
    a single `index.ts` file, located in the root of the bounded context. For the
    `auth` module, we can have the following structure:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以通过使用位于边界上下文根目录的单个`index.ts`文件来简单地公开上下文的所有成员。对于`auth`模块，我们可以有如下结构：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For instance, our `AuthHttp` service can be exported with `index.ts` using
    the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`AuthHttp`服务可以通过以下方式在`index.ts`中导出：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And we can import it into another component using this line:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此行将其导入到另一个组件中：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Instead of the following approach:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是以下方法：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Products administration
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品管理
- en: On the backend part, we created a service and exposed an API to manage products.
    Now on the client side, we need to create a module that will consume the API and
    let us do different operations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端部分，我们创建了一个服务并公开了一个API来管理产品。现在在客户端，我们需要创建一个模块来消费该API并允许我们执行不同的操作。
- en: The product service
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品服务
- en: 'We are going to talk about only a few methods from our product service, because
    basically we are going to do only simple CRUD operations in the admin section.
    Let''s create a file called `apps/admin/public/src/services/product.service.ts`,
    with the following base content:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅讨论产品服务中的几个方法，因为我们基本上将在管理部分执行简单的CRUD操作。让我们创建一个名为`apps/admin/public/src/services/product.service.ts`的文件，并包含以下基本内容：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Following this, we''ll add the `getAll` products method. We are going to use
    this when we want to show a list of products. Append the following code to the
    `ProductService`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`getAll`产品方法。当我们想要显示产品列表时，我们将使用此方法。将以下代码添加到`ProductService`中：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The rest of the methods are in the full source code of the project.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法都在项目的完整源代码中。
- en: List products
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出产品
- en: 'In the main product administration section, we are going to list all the available
    products from the catalog. For this, we create another component found under `apps/admin/public/product/components/product-list.component.ts`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要产品管理部分，我们将列出目录中所有可用的产品。为此，我们在`apps/admin/public/product/components/product-list.component.ts`下创建了一个另一个组件：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding code will just list all the products retrieved from the service
    and have a route link to edit a specific product. You can easily list extra details
    of a product; you just need to modify the template.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将仅列出从服务检索的所有产品，并具有编辑特定产品的路由链接。您可以轻松列出产品的额外详细信息；您只需修改模板即可。
- en: The main product component
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要产品组件
- en: 'To manage our routes, we have to create a main entry point and create a component
    for this. To have a final picture, I''m going to show you the final version of
    `ProductComponent`, found under `apps/admin/public/src/product/product.component.ts`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理我们的路由，我们必须创建一个主入口点并创建一个组件来处理。为了有一个完整的画面，我将向您展示`ProductComponent`的最终版本，该版本位于`apps/admin/public/src/product/product.component.ts`下：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are using this component to configure our routes for the products listing,
    for creating a new product, and for editing an existing product by a specific
    SKU. This way, we can easily mount it on a higher level component.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此组件来配置产品列表、创建新产品以及通过特定SKU编辑现有产品的路由。这样，我们可以轻松地将它挂载在更高层次组件上。
- en: Add and edit a product
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和编辑产品
- en: Basically, what we did is used the same template to edit and add a product.
    In this application, when viewing the product details, you are actually editing
    the product. In this way, we don't have to implement or mask the edit functionality
    separately from the detailed view.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that the application is in an early stage and there is no difference
    between creating a new product and updating an existing one, we can reduce the
    workload and implement both at the same time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The edit product source code can be found in `apps/admin/public/src/product/components/product-edit.component.ts`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Order handling
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The system should handle orders, which means that someone needs to handle the
    status of the orders. Usually, orders can have a few states. I will try to explain
    some of these in the following table:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Status | Description |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| Pending | pending | The order is received (usually unpaid). |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| Failed | failed | Something went wrong; that is, the payment failed or was
    declined. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| Processing | processing | The order is awaiting fulfillment. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| Completed | completed | The order is fulfilled and completed. Usually, no
    further action is required. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| On-hold | on_hold | The stock is reduced but waiting further confirmation,
    that is, payment. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| Cancelled | cancelled | The order was cancelled by the customer or admin.
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: 'We are not going to handle all the scenarios we just described. The full version
    of the application supports only a few of them: pending, processing, cancelled,
    and completed. As we won''t implement a payment method, there is no need to handle
    all the scenarios.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: After so much code, I think we can take a break and only discuss this part.
    You can check out the working version from the GitHub repository.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving orders
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To manage all the incoming orders, we need to list all of them to the admin.
    We are not going to get into the details of the code because it is very similar
    to what we have done so far.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The service found at `public/src/order/order.service.ts` will handle all operations
    on the order entity. A nice touch that can be added in this application is getting
    a stream of orders from the backend. This is something similar to what we did
    in [Chapter 4](part0046_split_000.html#1BRPS1-5c78d361d97340239270192b72d53e7b
    "Chapter 4. Chat Application"), *Chat Application*, when we worked with WebSockets.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we can notify all clients of the new orders available as soon
    as they are added into the system. This will give a boost when you have a high
    volume of incoming orders and would like to be notified as soon as possible so
    as to handle them as quickly as you can.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: View and update orders
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, before handling an order, you would like to see more information about
    it, such as the shipping address, or any other information the client provided
    to you. But at the same time, the actions required to handle an order should be
    kept at a minimum.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping all this in mind, we went with a solution in which one can view and
    edit the order in the same context. So, `OrderDetailsComponent` does exactly that;
    it can be found under the following location: `public/src/order/components/order-details.ts`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们选择了这样一个解决方案：可以在同一上下文中查看和编辑订单。因此，`OrderDetailsComponent` 正好做到了这一点；它可以在以下位置找到：`public/src/order/components/order-details.ts`。
- en: The full source can be found in the repository, but I'll try to explain what
    we did there.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在仓库中找到，但我会尽量解释我们在那里做了什么。
- en: Building the Storefront
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Storefront
- en: As we discussed at the beginning of the chapter, we are going to try something
    different. Instead of building a single-page app for our Storefront, we are going
    to implement server-side-rendered pages.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所讨论的，我们将尝试一些不同的事情。我们不会为 Storefront 构建单页应用程序，而是将实现服务器端渲染的页面。
- en: Technically, we are going to build a classical web page. The pages are going
    to be dynamic, rendered using a view engine to render our templates.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们将构建一个经典的网页。页面将是动态的，使用视图引擎来渲染我们的模板。
- en: We want to truly leverage the benefits of our headless core application and
    see how we can integrate it with different client applications, so we are going
    to experiment a little bit with server-side-rendered pages using a third-party
    package.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望真正利用我们无头核心应用程序的优势，并看看我们如何将其与不同的客户端应用程序集成，因此我们将使用第三方包进行一些服务器端渲染页面的实验。
- en: We can easily build this using Angular, but I wanted to add a twist, to see
    more complex solutions in action.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地使用 Angular 来构建它，但我想要添加一些变化，看看更复杂的解决方案是如何实施的。
- en: Storefront micro app
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Storefront 微应用
- en: As we have seen before in the admin section of our application, we decoupled
    it from the main application into a micro app. So technically, we can just pull
    out the necessary code for the storefront from this application at any time, add
    it to a whole new Express app, and make all the calls across the network.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在应用程序的管理部分之前所看到的，我们将它从主应用程序解耦为一个微应用。因此，从技术上讲，我们可以在任何时间从这个应用程序中提取出 Storefront
    所需的代码，将其添加到一个全新的 Express 应用程序中，并在网络上进行所有调用。
- en: At first, this might seem a little strange, but as soon as your application
    starts growing and you need to scale your application, this will give you the
    upper hand to differentiate what part needs to be scaled or moved to a separate
    application for better scalability.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这可能会显得有些奇怪，但一旦你的应用程序开始增长并且你需要扩展应用程序，这将为你提供优势，以便区分哪些部分需要扩展或移动到单独的应用程序以实现更好的可扩展性。
- en: It is always a good thing to think ahead, but also, I'm not a big fan of early
    optimization. You cannot be certain from the beginning how your application will
    grow in time, but it is wise to plan ahead.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 事先考虑总是一件好事，但我也不是特别喜欢过早的优化。你无法从一开始就确定你的应用程序在将来会如何增长，但提前规划是明智的。
- en: The Storefront application is going to showcase how we can integrate different
    techniques in the same application. The focus is purely educational, and this
    was added to the book to show different approaches to building Express apps.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Storefront 应用程序将展示我们如何在同一应用程序中集成不同的技术。重点是纯粹的教育性，这被添加到书中，以展示构建 Express 应用程序的不同方法。
- en: Let's talk about the technologies used to build our Storefront. We are going
    to use `nunjucks`, which is a nice templating engine for JavaScript. It can be
    used both on the server side and the client side.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈构建我们的 Storefront 所使用的科技。我们将使用 `nunjucks`，这是一个为 JavaScript 设计的优秀的模板引擎。它可以在服务器端和客户端同时使用。
- en: 'Before we get to the templates part, we need to make some preparations:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达模板部分之前，我们需要做一些准备工作：
- en: Create a new apps folder under `apps/storefront`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `apps/storefront` 下创建一个新的 `apps` 文件夹。
- en: Add a new file, `apps/storefront/index.js`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的文件，`apps/storefront/index.js`。
- en: 'Define the micro app''s class:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义微应用的类：
- en: '[PRE57]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Configure the view engine:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置视图引擎：
- en: '[PRE58]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Register routes:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册路由：
- en: '[PRE59]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For this micro app, we started using a view engine to render our templates on
    the server side. The `configureViews()` method will initialize the `nunjucks`
    environment and load the template files from the filesystem. Also we are checking
    whether we should activate the cache and watch functionality from `nunjucks`.
    You can read more about this in the project's documentation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个微应用，我们开始使用视图引擎在服务器端渲染我们的模板。`configureViews()` 方法将初始化 `nunjucks` 环境，并从文件系统中加载模板文件。我们还检查是否应该从
    `nunjucks` 激活缓存和监视功能。你可以在项目的文档中了解更多信息。
- en: Finally, we register the application's routes as for each of our previous Express
    applications we built together. For easier reading, I've only added the home location
    and only instantiated `ProductController`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将应用程序的路由注册为我们在之前一起构建的每个Express应用程序所做的那样。为了便于阅读，我只添加了主页位置，并且只实例化了`ProductController`。
- en: 'In case you are wondering what the `ProductController` is, we just use a class
    approach for our controller files so that we can instantiate it, and pass the
    core of the application. Let''s take a look at a section of the code from `apps/storefront/controllers/product.js`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道`ProductController`是什么，我们只是使用类方法为我们的控制器文件，这样我们就可以实例化它，并传递应用程序的核心。让我们看看`apps/storefront/controllers/product.js`中的一个代码段：
- en: '[PRE60]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So basically, we are exporting a controller class, and in the `home()` method,
    we are retrieving products from the persistent storage—in our case, MongoDB—using
    our `ProductCatalog` service. After successfully getting all the products, we
    use the `render()` method from the response object to render an HTML response
    from our templates.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，我们导出了一个控制器类，在`home()`方法中，我们使用我们的`ProductCatalog`服务从持久存储（在我们的情况下，是MongoDB）检索产品。在成功获取所有产品后，我们使用响应对象的`render()`方法从我们的模板中渲染一个HTML响应。
- en: Storefront pages
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 店面页面
- en: We are not going to get into the details; you can check out the whole project
    and see how things are glued together.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入细节；你可以查看整个项目，看看事物是如何粘合在一起的。
- en: Main layout
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要布局
- en: 'To have a single layout definition, almost every template will extend a master
    template file. This master template file will contain all of the necessary markup
    of a full HTML document. The master layout file can be found under `apps/storefront/views/layout.html`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个单一的布局定义，几乎每个模板都会扩展一个主模板文件。这个主模板文件将包含一个完整HTML文档的所有必要标记。主布局文件可以在`apps/storefront/views/layout.html`下找到：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The main `layout.html` file defines blocks to inject content inside them. Because
    we have a `Shared` micro app, all the necessary assets are available to us, so
    we can import these assets using a separate file, `apps/storefront/views/includes/stylesheets.html`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的`layout.html`文件定义了注入内容的块。因为我们有一个`Shared`微应用，所以所有必要的资产都对我们可用，因此我们可以使用一个单独的文件，`apps/storefront/views/includes/stylesheets.html`来导入这些资产：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: List products
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出产品
- en: 'To have full integration, let''s see how we can list our products. Create a
    new template file called `apps/storefront/views/home.html` and add the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现完全集成，让我们看看我们如何列出我们的产品。创建一个新的模板文件`apps/storefront/views/home.html`并添加以下内容：
- en: '[PRE63]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We just extend the `content` block with the preceding code, iterate through
    the products list, and create a new product using a partial view.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是使用前面的代码扩展了`content`块，遍历产品列表，并使用部分视图创建一个新的产品。
- en: 'Let''s take a look at that partial view, `apps/storefront/views/partials/product.html`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那个部分视图，`apps/storefront/views/partials/product.html`：
- en: '[PRE64]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The static HTML markup is turned into a dynamic view. We are using the same
    structure as in our `Admin` micro application built with Angular 2.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 静态HTML标记被转换成了动态视图。我们使用与用Angular 2构建的`Admin`微应用相同的结构。
- en: If you are interested in the rest of the code, go ahead to the project's repository
    at [https://github.com/robert52/mean-blueprints-ecommerce](https://github.com/robert52/mean-blueprints-ecommerce)
    and find out more details. This part of the application was only for showing a
    different approach that you can integrate into your MEAN stack. You can always
    extend your stack with different technologies and see what works for you better.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对剩余的代码感兴趣，请前往项目的仓库[https://github.com/robert52/mean-blueprints-ecommerce](https://github.com/robert52/mean-blueprints-ecommerce)以获取更多详细信息。这部分应用程序只是为了展示你可以集成到你的MEAN堆栈中的不同方法。你总是可以扩展你的堆栈，使用不同的技术，看看什么更适合你。
- en: Sometimes, you need to combine things, but having a solid base can make your
    life easier in the long run. We could have built everything using Angular, but
    it's always great to see how we can extend our horizons.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要将事物结合起来，但有一个坚实的基础可以使你的生活长期更容易。我们本可以使用Angular构建一切，但看到我们如何扩展我们的视野总是很棒。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about building an e-commerce application. From the beginning
    of the chapter, we started experimenting with new application architecture, one
    that can be easily extended in the future, and also used for server-side rendering
    in the implementation of our storefront.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于构建电子商务应用程序。从本章的开始，我们就开始尝试新的应用程序架构，这种架构可以很容易地扩展到未来，并且也用于我们的店面实现中的服务器端渲染。
- en: Although this was much different from the previous chapters, it served well
    for educational purposes and opened doors to new possibilities. Keep your architecture
    modular and only experiment with small portions first to see how things work out
    in your favor.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这与前几章有很大不同，但它很好地服务于教育目的，并为新的可能性打开了大门。请保持您的架构模块化，并且首先只对小部分进行实验，以查看事情是否如您所愿地发展。
- en: In the next chapter, we'll try to extend our existing e-commerce application
    with an auction application.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将尝试通过添加拍卖应用来扩展我们现有的电子商务应用。
