- en: Chapter 10. Writing Flexible and Modular CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned about the most popular testing instruments
    under Node.js. We saw the importance of writing tests and learned about TDD and
    BDD. This chapter will be about **CSS** (**Cascading Style Sheets**) and the usage
    of preprocessors. The Web is built on the basis of three languages—HTML, CSS,
    and JavaScript. As part of modern technology, Node.js provides really helpful
    instruments to write CSS; in this chapter, we will have a look at these instruments
    and how they can improve our style sheets. This chapter will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Popular techniques to write modular CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Less preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Stylus preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sass preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AbsurdJS preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing modular CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS has changed a lot in the last few years. Developers used CSS2 as a declarative
    language to decorate the page. Today's CSS3 gives us many more capabilities. Nowadays,
    CSS is used widely to implement design ideas animating elements on the page or
    even applying logic such as hiding and showing content blocks. A lot of CSS code
    requires better architecture, file structuring, and proper CSS selectors. Let's
    explore a few concepts that could help with this.
  prefs: []
  type: TYPE_NORMAL
- en: BEM (block, element, modifier)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BEM ([http://bem.info/method/definitions](http://bem.info/method/definitions))
    is a naming convention introduced by Yandex back in 2007\. It became a popular
    concept to develop frontend applications. In fact, it is not only applicable for
    CSS but also for any other language because it has very few rules that work well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have the following HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The instant CSS which we can come up with is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it will probably not work really well because we may have another
    logo in the sidebar of the page. Of course, we could use descendant selectors
    such as `.site-header { ... }` and `.logo { ... }`, but these come with a new
    problem. It is not really a good practice to connect selectors in a tree because
    we can''t extract a part of it and use it somewhere else. BEM solves this problem
    by defining rules which we can follow. A block in the context of BEM is an independent
    entity. It can be a simple one or a compound one (containing other blocks). In
    the previous example, the `<header>` tag precedes the CSS block. The elements
    are placed inside the block and they are context-dependent, that is, they mean
    something only if they are placed inside the block which they belong to. The `.logo`
    and `.navigation` selectors in the block are the elements. There is one more type
    of selector called **modifiers**. To better understand them, we will use an example.
    Let''s say that Christmas will arrive soon and we need to make a holiday version
    of the logo. At the same time, we need to keep the old styles because after a
    few months we need to revert it to its previous version. This is what modifiers
    are made for. We apply them on already existing elements to set a new look or
    style. The same can be said for a button, which has a normal, pressed, or disabled
    state. To separate the different types of selectors, BEM introduces the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The name of the elements is added with double underscores and modifiers with
    double dashes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Object Oriented CSS approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Object Oriented CSS** (**OOCSS**) ([https://github.com/stubbornella/oocss/wiki](https://github.com/stubbornella/oocss/wiki))
    is another concept which helps us write better CSS. It was originally introduced
    by Nicole Sullivan and defines the following two principles.'
  prefs: []
  type: TYPE_NORMAL
- en: Separate structure and skin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are styles that describe the look and skin of the elements. The duplication
    is a good reason to extract them in a separate definition. Continue the preceding
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's nice that we can use the same `.colors-skin` class against other elements
    or even better, we can change the whole theme of the page with just one little
    modification in that particular class.
  prefs: []
  type: TYPE_NORMAL
- en: Separate container and content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The idea is that every element should have its styles applied no matter what
    context it is put in. Let''s use the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At some point, we may need to put the same form in the footer of the site. The
    `20px` value and the `#FF0033` color, which we applied, will be lost because the
    form does not live in the header anymore. So, avoiding such selectors will help
    us to prevent such situations. Of course, we can't follow this principle for every
    element, but it is a really good practice overall.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable and modular architecture for CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jonathan Snook introduced another interesting approach called **Scalable and
    modular architecture for CSS** (**SMACSS**) ([http://smacss.com/](http://smacss.com/)).
    His idea was to categorize the styles of the application into different categories
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic selectors**: Basic selectors such as those for float clearing or the
    base font sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout**: The CSS styles defining the grid of the page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules**: These are similar to the BEM block, that is, a group of elements
    that form a meaningful block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: CSS styles that define the state of the elements, for example, pressed,
    expanded, visible, hidden, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Theme**: Theme rules are similar to the state rules in which they describe
    how modules or layouts might look'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing the style sheet in this manner organizes the selectors very well.
    We can create different directories or files for the different categories, and
    in the end we will have everything properly set up.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Atomic design ([http://bradfrostweb.com/blog/post/atomic-web-design](http://bradfrostweb.com/blog/post/atomic-web-design)),
    a concept presented by Brad Frost, is a simple but really powerful approach. We
    know that the basic unit of matter is an atom. Applying this to CSS, we can define
    the atom as a simple HTML tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The atom contains some basic styling such as color, font size, or line height.
    Later, we can combine the atoms into molecules. The following example shows how
    a `form` tag is made of few atoms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Properly styling and combining little blocks brings flexibility. If we follow
    this concept, we can reuse the same atoms again and again or put any molecule
    in a different context. Brad Frost didn't stop here. He continued by saying that
    the molecules can be merged into organisms and the organisms into templates. For
    example, the login form and the main-menu molecules define an organism header.
  prefs: []
  type: TYPE_NORMAL
- en: All the concepts mentioned in this section are not ideal for every project.
    However, all of them have something valuable to use. We should try not to follow
    them strictly but get the rules which fit best in our current application.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring CSS preprocessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Preprocessors** are tools that accept code and compile it. In our context,
    such instruments output CSS. There are few big benefits of using preprocessors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concatenation**: Writing everything in one single `.css` file is not an option
    anymore. We all need to split our styles logically and this normally happens by
    creating a bunch of different files. CSS has a mechanism to import one file from
    another—the `@import` directive. However, by using it, we are forcing the browser
    to create another HTTP request to the server, which can decrease the performance
    of our application. CSS preprocessors normally deliver only one file by replacing
    the functionality of `@import` and simply concatenating all the used files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extending**: We don''t like to write things over and over again and with
    pure CSS coding, this happens all the time. The good news is that preprocessors
    provide a feature that solves this problem. It''s called a mixin. We can think
    of it as a function which is executed and all the styles defined in it are applied
    to the selector which calls it. We will see how this works in practice further
    in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: Normally, we need to repeat colors, widths, and font sizes
    all over the CSS file. By using the CSS preprocessor, we can put these values
    in variables and define them in only one place. Switching to a new color scheme
    or typography can happen really fast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax used in most preprocessors is similar to the normal CSS. This allows
    developers to start using them almost immediately. Let's check out the available
    CSS preprocessors.
  prefs: []
  type: TYPE_NORMAL
- en: Using Less
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Less is a CSS preprocessor based on Node.js. It is distributed as a Node.js
    module and can be installed using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the successful installation, we should be able to call the `lessc` command
    in the terminal. Create a new `styles.less` file somewhere and put the following
    code inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we run `lessc ./styles.less`, we will see the same CSS shown as a result.
    The approach, which is taken by Less, is to use a syntax close to the one used
    in the normal CSS. So, in practice, every existing CSS code could be compiled
    by Less, which comes in handy, because we can start using it without doing any
    preparation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The variables in Less are defined as we write the CSS properties. We just have
    to put the `@` sign in front of the property''s name, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Mixins** are very useful when we want to transfer specific styles from one
    place to another or even several places. Let''s say, for example, that we have
    constant borders that need to be set for different elements on our page. We will
    then use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can skip the brackets of `.my-border` but then we will have the same class
    in the resulted file. The code, as it is now, is compiled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The mixins can accept parameters, which makes them one of the most important
    features in Less.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, the size of the border is passed as a parameter. It also has
    a default value of two pixels. The result after the compilation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Structuring the styles into nested definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Very often, when we use descendent selectors, we end up with a really long
    style definition. This is annoying because we have to type more and it is difficult
    to read. CSS preprocessors solve that problem by allowing us to write nested styles.
    The next code shows how we may nest selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much easier to understand and follow. We don''t have to worry about
    collisions either. For example, the paragraph in the `.content` element will have
    a 24-pixel font size and will not be mixed with the styles of the footer. That''s
    because at the end, we have properly generated selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Less has a dozen other features such as math calculation, function definitions,
    conditional mixins, and even loops. We can write a whole new book on this topic.
    A full list of all the functionalities can be seen at [http://lesscss.org/](http://lesscss.org/),
    which is the official site of Less and contains its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Using Sass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another popular CSS preprocessor called **Sass**. It''s actually not
    based on Node.js but on Ruby. So, we need to install Ruby first. You can also
    find detail information about how to install Ruby on the official download page:
    [https://www.ruby-lang.org/en/downloads](https://www.ruby-lang.org/en/downloads).
    Once we have it properly set up, we need to run the following command to get Sass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After the execution, we have a command-line instrument installed, that is,
    `sass`, and we can run it against a `.sass` or `.scss` file. The syntax used in
    the `.sass` files looks like the one used in Stylus (we will learn about this
    in the *Using Stylus* section), and the syntax used in the `.scss` file is similar
    to the Less variant. At first, Less and Sass look pretty similar. Sass uses the
    `$` sign in front of the variables, while Less uses the `@` sign. Sass has the
    same features as Less—conditional statements, nesting, mixins, extending. The
    following code is a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two keywords: `@mixin` and `@include`. The first one defines the
    mixin and the second one is needed during its usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Stylus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Stylus** is another popular CSS preprocessor written in Node.js. Similar
    to Less, Stylus also accepts the usual CSS syntax. However, it introduces another
    type of writing—without braces, colons, and semicolons. The following code is
    a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In Stylus, the CSS code produced may look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The language uses the indentation to recognize the definitions. Stylus is distributed
    as a Node.js module and can be installed using the `npm install -g stylus` command
    line. Once the process is completed, we can compile with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is the command line where `styles.styl` contains the necessary CSS. As
    a result, we will get the `styles.css` file in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stylus is a little bit more advanced than Less. It still supports the same
    features but has more logical operators. Let''s see an example that demonstrates
    most of its features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines a variable called `brandColor`. Later, this variable
    is used to set the color of the paragraph. Stylus supports hash objects as a value
    of the variables. It''s really nice because we can define a set of options. In
    the preceding example, `borderSettings` holds the size and the position of the
    paragraph''s border. The `paragraph-border` mixin accepts two arguments. The second
    one is not mandatory and has a default value. There is an `if`-`else` statement
    that defines the type of the applied border. Similar to Less, we have the ability
    to nest selectors. The paragraph''s styles are nested inside the `body` selector.
    After the compilation, the resulted CSS is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Working with AbsurdJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AbsurdJS** is another CSS preprocessor available in Node.js that takes a
    slightly different direction. Instead of inventing a new syntax, it uses the already
    existing language—JavaScript. So, features such as variables, mixins, or logical
    operators came naturally without any additional effort.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the other preprocessors, AbsurdJS is distributed via the package
    manager of Node.js. The following command line installs the library on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSS styles are written in the `.js` files. In fact, the library accepts
    the `.css`, `.json`, and `.yaml` files and successfully processes them, but in
    this book we will stick to the JavaScript format because it is the most interesting
    one. Every file which is passed to AbsurdJS starts with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The function that is exported accepts the API of the module. All the operations
    work through the API object. Because everything is in JavaScript, the CSS styles
    are represented in the JSON format. The following is an example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is compiled to the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'AbsurdJS could work as a command-line tool. To process a `styles.js` file containing
    the preceding code snippet, we should execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-s` flag comes from the source and `-o` from the output. The module can
    be used in code as well as to integrate AbsurdJS into every Node.js application.
    All we have to do is add the library in our `package.json` file and require it
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Actually, the same thing is valid for the Less preprocessor. It could be used
    in a Node.js script too.
  prefs: []
  type: TYPE_NORMAL
- en: 'While discussing Sass and Stylus, we used an example: a few lines of code that
    put a border on the page''s `paragraph` tag. The following code elaborates how
    this can be achieved using AbsurdJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It's all about constructing JavaScript objects and passing them to the `add`
    method. There is still nesting, defining variables, and using a mixin (`paragraphBorder`).
  prefs: []
  type: TYPE_NORMAL
- en: Styling a simple login form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now write the CSS styles for a simple login form. The HTML markup is
    pretty simple. It has two labels, two input fields, and two buttons, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result that we want to achieve at the end looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling a simple login form](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a preprocessor, we are going to use AbsurdJS and write our styles in the
    JavaScript format. Let''s create an empty `style.js` file and enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We defined the settings of the page. They are only colors in our case, but it
    could be anything else, for example, font size, margin, or the space between the
    lines. The `api.lighten` and `api.darken` functions are used to produce variants
    of colors. They change the passed values by making them lighter or darker depending
    on the percentages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our configurations set up and we can continue with the following basic
    CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'These styles are applied to the `body` tag of our page. If we open the page
    now, we will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling a simple login form](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is because we have still not worked on the form. Let''s continue and define
    the basic rules for it, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#login` selector matches the form. We position it in the middle of the
    page and set padding from the top and bottom sides. We are also making the `label`
    tag a block element. Now the example looks much better, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling a simple login form](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we check the HTML markup, which we started from, we will see that the rest
    of the elements are the `input` tags, that is, two fields and two buttons. Let''s
    create a function (mixin), which will generate CSS for these elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `input` method accepts a selector and an object. Because we will use the
    function to style fields and at the same buttons, we need a mechanism to add custom
    rules. The `addons` object (if defined) holds those styles which need to be set
    in addition. There are two properties that may look strange: `-wm-border-radius`
    and `-wm-box-sizing`. The `-wm-` property, at the beginning, adds browser prefixes
    to the end CSS. For example, `-wm-box-sizing: border-box` produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&:focus` property is also a special property. The ampersand represents
    the selector in which the style is written. At the end of the function, we added
    the custom CSS. Now, let''s see the use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For the input fields, we call the input method with only a selector. However,
    for the buttons, we need more styles and they are passed as a JavaScript object.
    AbsurdJS has built-in mixins that allow us to generate cross-browser CSS, for
    example, the `gradient` and `transparent` properties. The result of the execution
    of the `gradient` property is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the result of the execution of the `transparent` property is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using a mixin is much easier than writing all these things by ourselves. Once
    we add the `input` invocations, we are done. AbsurdJS produces the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS is and will always be an important part of the Web. Making it simple, well-structured,
    and with a flexible markup leads to a good architecture. In this chapter, we learned
    about the most popular concept to write modular CSS. Along with that, we checked
    the latest trends in CSS preprocessing, the available tools, and their features.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is fast and is very often used as a REST API. In the next chapter, we
    will see how to write a REST API and what the best practices in this direction
    are.
  prefs: []
  type: TYPE_NORMAL
