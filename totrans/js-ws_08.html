<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-319"><a id="_idTextAnchor357"/>8. Browser APIs</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to explain what a web/browser API is; draw in HTML using JavaScript; create and control audio in the browser; store data in the browser; decide on the type of storage to use in different circumstances; measure and track a website's performance; and create and manage a sustained, two-way connection between the browser and server.</p>
			<p class="callout">In this chapter, you will learn about interesting browser APIs and look at JavaScript's extended capabilities.</p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor358"/>Introduction</h1>
			<p>In the previous chapter, we looked at the different examples of JavaScript runtime environments and had an overview of their components. We'll now look at one of those components in greater depth, that is, the <strong class="bold">Browser Object Model</strong> (<strong class="bold">BOM</strong>), and the APIs it exposes to JavaScript.</p>
			<p>The BOM is a set of properties and methods that are made available to JavaScript by the browser. Now, you've come across many parts of the BOM already, with methods such as <code>setTimeOut()</code>, and the document property, with its many methods, such as <code>addEventListener()</code>. It's a subtle but important point that the methods and properties we'll cover in this chapter are not part of the JavaScript programming language; that is to say, they're not part of the ECMAScript specification – the specification to which JavaScript engines are built – but they are methods and properties of the browser, and they form the interface between JavaScript and the browser (and by extension, between JavaScript and the rest of the system it's being run on).</p>
			<p>In the same way that every browser has its own implementation of the JavaScript engine, each browser implements the BOM in a slightly different way. So, it's important to check cross-browser compatibility for the features you want to use as a developer and implement <strong class="bold">fallbacks</strong> or <strong class="bold">polyfills</strong> for browsers that don't support certain features. It's often the case that the current version of a particular browser supports a certain functionality, but older versions do not. </p>
			<p>As we've already mentioned, you've seen many of the more commonly used methods of the BOM. Here, we will look at some of the most commonly used and useful browser APIs in more detail, as well as some less frequently used yet powerful aspects of the BOM that will greatly increase the number and functionality of tools at your disposal, and which can allow you to build some super cool and possibly even useful features into your sites and apps.</p>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor359"/>Canvas</h1>
			<p>Images and diagrams are a fundamental part of creating engaging websites and applications. We already know how to include images and videos in our pages, but we can also draw our own images, diagrams, and even complex visuals such as charts or game elements by using JavaScript and the <code>&lt;canvas&gt;</code> element using JavaScript. With it, we can draw paths and rectangles, and control things such as stroke and fill color, line dashes, and arc radiuses (or radii, if that's your flavor).</p>
			<p>The process of drawing inside an HTML canvas using JavaScript can be broken down into a few distinct steps:</p>
			<ul>
				<li>Get a reference to the HTML's canvas element.</li>
				<li>Get a new canvas rendering context that the graphic is drawn onto.</li>
				<li>Set various drawing styles and options as required (for example, line width and fill color).</li>
				<li>Define the paths that will make up the graphics.</li>
				<li>"Stroke" or fill the defined paths and shapes – this is the step where the actual drawing takes place.</li>
			</ul>
			<p>In the following exercise, we will start by using the <code>fillRect()</code> method. This method is one of the methods we can use for drawing on the canvas and, as its name suggests, draws a rectangle and fills it with color. To describe the rectangle, we require four pieces of information: the <code>x</code> and <code>y</code> coordinates of the top-left corner, the rectangle's width, and its height. Therefore, the parameters we will pass to <code>fillRect()</code> are an <code>x</code> coordinate, a <code>y</code> coordinate, the width, and the height.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor360"/>Exercise 8.01: Drawing Shapes Using Canvas Elements</h2>
			<p>Let's get started with an exercise in which we'll learn how to work with a Canvas element, some of the components that make up the API, and how we can use it to draw simple shapes. The Canvas API has many methods and interfaces. In this exercise, we'll look at a few of the most commonly used ones. Let's get started:</p>
			<ol>
				<li>Create an HTML file called <code>index.html</code> with a <code>&lt;canvas&gt;</code> element and a reference to a JavaScript file in the HTML body in the <code>DevTools</code> console. We'll call the JavaScript file <code>canvas.js</code>:<pre>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id='canvas' style="border: 1px solid"&gt;&lt;/canvas&gt;
    &lt;script src='canvas.js'&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre><p>We've given the canvas element an ID of <code>'canvas'</code> so that we can select it easily in JavaScript, and an inline style of <code>"border: 1px solid"</code> so that we can see the area that the canvas takes up on the HTML page.</p></li>
				<li>Next, we'll create our <code>canvas.js</code> file in the same directory as <code>index.html</code> and declare a variable that will hold a reference to our HTML canvas element:<pre>// canvas.js
let canvas = document.getElementById('canvas');</pre></li>
				<li>Now, we'll create a rendering context by calling the <code>getContext()</code> method with the <code>'2d'</code> parameter since we will be drawing 2D graphics. This method takes in a string to denote the context type and returns a drawing context that's used to draw and modify the graphics we want to display. There are several types of context, but for this introduction to Canvas, we will be looking only at <code>'2d'</code> contexts:<pre>let context = canvas.getContext('2d');</pre><p>Now that we have the context, we can start drawing. The canvas object works on a grid system, with its origin in the top left, so that the <code>0</code>,<code>0</code> coordinates are at the top left of the canvas. It's from this origin that we can draw our graphics.</p></li>
				<li>Finally, we'll use the <code>fillRect()</code> method to draw a <code>100</code> by <code>100</code> pixel rectangle on the canvas:<pre>context.fillRect(10,10, 100, 100);</pre><p>Now, open the HTML file in your browser. You should see something like this:</p><div><img alt="Figure 8.1: Simple canvas with a square inside&#13;&#10;" src="img/C14377_08_01.jpg"/></div><p class="figure-caption">Figure 8.1: Simple canvas with a square inside</p></li>
				<li>You've probably already noticed that the canvas element is fairly small. By default, a canvas is <code>300</code> by <code>150</code> pixels, so let's add a couple of lines to our JavaScript so that the canvas' dimensions match the size of our window when we load the HTML page. We'll use the window object's <code>innerWidth</code> and <code>innerHeight</code> properties – which tell us the viewport's width and height – to set the canvas' width and height:<pre>// canvas.js
let canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
let context = canvas.getContext('2d');
context.fillRect(10,10, 100, 100);</pre></li>
				<li>Now that we have a much larger canvas (assuming your browser window is bigger than <code>300</code> x <code>150</code> pixels), we can start to play around with this and other drawing methods. Let's add a few more rectangles but mix things up a bit:<pre>canvas.js
let canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
let context = canvas.getContext('2d');
context.fillStyle = 'yellow';
context.fillRect(10,10,200,200);
context.fillStyle = 'black';
context.strokeRect(230, 10, 200, 200);
context.setLineDash([10]);
context.strokeRect(450, 10, 200, 200);
context.setLineDash([0]);
context.strokeStyle = 'red';
context.strokeRect(10, 230, 200, 200);
context.fillRect(450, 230, 200, 200);
context.clearRect(500, 280, 100, 100);</pre></li>
				<li>We should now have five new rectangles that look something like this (there's actually six if you include <code>clearRect()</code> inside the filled black rectangle at the end):<div><img alt="Figure 8.2: Six more rectangles&#13;&#10;" src="img/C14377_08_02.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.2: Six more rectangles</p>
			<p>In this exercise, we learned how to draw all formats of rectangles using the <code>canvas</code> element.</p>
			<p>The additional lines of code in the exercise are pretty self-explanatory, but there are still a few things to point out:</p>
			<ul>
				<li>The <code>fillStyle</code> and <code>strokeStyle</code> properties can take any valid CSS color value (hexadecimal, RBG, RGBA, HSL, HSLA, or named color).</li>
				<li>The <code>setLineDash</code> property takes an array of numbers that determine the distances of drawn lines and spaces. The list is repeated, so if you pass [<code>5</code>], the lines and spaces will repeat at <code>5</code> pixels in length each. If you pass [<code>5</code>, <code>15</code>], then all the lines will be <code>5</code> pixels, and all the spaces will be <code>15</code> pixels. </li>
				<li>Once set, <code>fillStyle</code>, <code>strokeStyle</code>, and <code>setLineDashvalues</code> persist for anything drawn in the same context, so you need to make sure that you reset the value if you need to, as we have with the <code>setLineDash</code> property (otherwise the red rectangle will be dashed) and <code>fillStyle</code>.</li>
				<li>The <code>clearRect</code> method can be used to remove a drawn area from another part of the canvas.</li>
			</ul>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor361"/>Manipulate Shapes Using Path</h2>
			<p>Now that we've mastered drawing rectangles, we'll start drawing more interesting shapes with paths using some of the other methods available on the context object. A path is a list of points that are joined by lines. We can manipulate the properties of these paths, such as their curvature, color, and thickness. This time, we'll go through the methods first, and then see them in action:</p>
			<ul>
				<li><code>beginPath()</code>: Starts a new path list</li>
				<li><code>moveTo(x,y)</code>: Sets the point at which the next path will be drawn from</li>
				<li><code>lineTo(x,y)</code>: Creates a line from the current point to the coordinates passed to the method</li>
				<li><code>closePath()</code>: Creates a line from the most recent point to the first point, thereby closing off the shape</li>
				<li><code>stroke()</code>: Draws the shape that's been described</li>
				<li><code>fill()</code>: Fills in the described shape with a solid color</li>
			</ul>
			<p>These methods can be used to draw a big triangle that takes up most of the canvas' width and height. You can replace the previous code in canvas.js with the following, or create a new JavaScript file and change the <code>&lt;script&gt;</code> tag's source attribute in the HTML file to reflect the new JavaScript file:</p>
			<pre>canvas-1.js
let canvas = document.getElementById('canvas');
const width = window.innerWidth;
const height = window.innerHeight;
canvas.width = width
canvas.height = height
let context = canvas.getContext('2d');
context.beginPath();
context.moveTo(50, 50);
context.lineTo(width - 50, 50);
context.lineTo(width / 2, height - 50);
context.closePath();
context.stroke();</pre>
			<p>First of all, we assigned the window's innerWidth and innerHeight values to a variable because we'll be using them more than once. After getting a reference to the canvas object, we begin a new path and move our starting point to <code>50</code> pixels on both axes. Next, we plot a line from our current point to a point <code>50</code> pixels less than the innerWidth, and <code>50</code> pixels from the top. Then, we plot a line to a point half the innerWidth, and <code>50</code> pixels from the bottom. The final two methods are used to close the path and draw the entire shape with the <code>stroke()</code> method. </p>
			<div><div><img alt="Figure 8.3: A triangle&#13;&#10;" src="img/C14377_08_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: A triangle</p>
			<p>The steps to create a fractal pattern are fairly straightforward, but here are some pointers to keep in mind:</p>
			<ul>
				<li>The starting point should be the middle of the <code>canvas</code> element.</li>
				<li>The line is drawn in one of four directions.</li>
				<li>The line drawing part of the function should repeat as long as the point is within the bounds of the canvas.</li>
				<li>In the preceding example, the lines increase in length after every two plots of a line. You can, however, get a similar result by increasing the line length on every line.</li>
			</ul>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor362"/>Activity 8.01: Creating a Simple Fractal</h2>
			<p>We're now going to put what we've learned about HTML Canvas into practice. This time, we'll be using JavaScript to repeat the drawing steps to create a very <strong class="bold">simple fractal</strong>. Have a go at creating a pattern like this:</p>
			<div><div><img alt="Figure 8.4: A basic pattern&#13;&#10;" src="img/C14377_08_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4: A basic pattern</p>
			<p>Follow these steps to create a fractal:</p>
			<ol>
				<li value="1">Initialize a variable with coordinates for a starting point in the middle of the canvas.</li>
				<li>Create a loop. For every iteration of the loop, alternate between increasing and decreasing the coordinates and drawing the line:<ul><li>Increase or decrease the coordinate values to move the point outward in a spiral</li><li>Draw a line from the previous point to the new one</li></ul></li>
				<li>End the loop when the point reaches any edge of the canvas.</li>
			</ol>
			<p>Spend some time trying to do this on your own before checking the solution.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 732.</p>
			<p>For now, we'll move on to another web API: the Web Audio API.</p>
			<h1 id="_idParaDest-325"><a id="_idTextAnchor363"/>Web Audio API</h1>
			<p>This API provides a set of methods and objects that we can use to add audio to HTML from a variety of sources, even allowing developers to create new sounds from scratch. The API is feature-rich and supports effects such as panning, low-pass filters, and many others that can be combined to create different kinds of audio applications.</p>
			<p>Like the Canvas API, the <strong class="bold">Audio API</strong> starts with an audio context, and then multiple audio nodes are created within the context to form an audio processing graph:</p>
			<div><div><img alt="Figure 8.5. The audio context and its audio processing graph&#13;&#10;" src="img/C14377_08_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5. The audio context and its audio processing graph</p>
			<p>An <strong class="bold">audio node</strong> can be a source, a destination, or an audio processor, such as a filter or a gain node, and they can be combined to create the desired audio output, which can then be passed to the user's speakers or headphones.</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor364"/>Exercise 8.02: Creating an Oscillator Waveform</h2>
			<p>In this exercise, we will see how we can create <strong class="bold">a simple oscillator waveform</strong> in JavaScript and output it to the system's audio output device. Let's get started:</p>
			<ol>
				<li value="1">Let's start by creating an audio context and adding a volume and oscillator node. Type or copy and paste the following code into the console window of Google Chrome's Developer Tools (accessible using the <em class="italic">F12</em> key):<pre>// create the audio context
let context = new AudioContext();
// create a gain node
let gain = context.createGain(); 
// connect the gain node to the context destination
gain.connect(context.destination);
// create an oscillator node
let osci = context.createOscillator(); </pre></li>
				<li>Now, we'll set the oscillator type to <code>'sawtooth'</code> and set the frequency of oscillation to <code>100</code>. Instead of <code>'sawtooth'</code>, you can set the oscillator type to <code>'sine'</code>, <code>'square'</code>, or <code>'triangle'</code>. Feel free to experiment with the frequencies as well:<pre>// set the oscillation type
osci.type = 'sawtooth';
// set the oscillation frequency
osci.frequency.value = 100;</pre><p class="callout-heading">Note</p><p class="callout">The frequency of a waveform refers to how often the waveform completes one cycle or period, with <strong class="bold">1 Hertz</strong> (1 Hz) being 1 cycle per second. We perceive higher frequency sound waves as being higher pitched.</p></li>
				<li>Finally, we'll connect the oscillator to the gain node and call the oscillator's <code>start()</code> method:<pre>// connect the oscillator node to the gain node
osci.connect(gain);
// start the oscillation node playing
osci.start(); </pre></li>
			</ol>
			<p>If you run this code with the volume up, you should hear a continuous oscillating sound (the sound is similar to the static noise you hear on the radio when the channel you want cannot be found). Some browsers will not play a sound with the Audio API until the user has interacted in some way with the screen. This is to stop developers from making annoying pages that play unwanted sounds. If you encounter an error, just click somewhere on the screen before running the code.</p>
			<p>We can add multiple source nodes, either of the same type (an oscillator, in our example) or of different types, and they can each be controlled separately, or share other audio nodes such as gain or pan nodes. Of course, we can also make our audio contexts respond to some external input, such as user inputs or time events.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor365"/>Activity 8.02: Playing Sound and Controlling Frequency Using Two Oscillators</h2>
			<p>Let's make better use of the audio API by adding some interactivity. In this activity, we will have two oscillators playing a sound, and the user will be able to control their frequencies by moving their cursor around on an HTML page. One oscillator's frequency will be controlled by the cursor's <code>x</code> position, with the frequency increasing as the cursor moves toward the right of the page, and the other oscillator's frequency is controlled by the <code>y</code> position, with the frequency increasing as the cursor moves toward the bottom of the page.</p>
			<p>Before checking the solution, see if you can achieve this goal; it'll be good practice for the activity at the end of this chapter.</p>
			<p>Some points to get you started:</p>
			<ul>
				<li>The two oscillators should be in the same context and be connected to the same volume node.</li>
				<li>There are four preset oscillator types available to the oscillator node interface: <code>'sine'</code> (default), <code>'square'</code>, <code>'sawtooth'</code>, and <code>'triangle'</code>. Both our oscillators can have different types, so play around with them.</li>
			</ul>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Initialize an audio context and a volume node.</li>
				<li>Create a gain node and connect it to the context's destination.</li>
				<li>Initialize two oscillators (one for each coordinate of the cursor).</li>
				<li>Set the oscillator types, connect them to the gain node, and call their <code>start()</code> methods.</li>
				<li>Create an <code>document</code>.</li>
				<li>Set the oscillators' frequencies based on the cursor's position.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found on page 733.</p></li>
			</ol>
			<p>Before we move on to the next web API, here's some information on how we can extract data from a currently playing sound and use it to visualize that sound in our app.</p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor366"/>Audio Visualization</h2>
			<p>Audio visualization is a graphical representation of a sound. It's common to see this in an audio program, and it can produce very interesting patterns and shapes. Web audio has many kinds of audio nodes. One that opens up a lot of possibilities for audio visualization is the analyzer node, which gives you access to the waveform and frequency data of its audio input. Unless you're a sound technician, the inner workings of the node are quite arcane, so we'll just get straight into how we access the data. There is one additional property and one method we'll use to get some data that is useful for visualization:</p>
			<ul>
				<li><code>frequencyBinCount</code>: This essentially tells us how many data points we have available to us for our data visualizations.</li>
				<li><code>getFloatTimeDomainData()</code>: This method takes in a <strong class="bold">Float32Array</strong> as a parameter and copies the current waveform data to it. (A Float32Array is a special kind of array that takes in 32-bit floating-point numbers. The array represents the waveform when broken up into however many items there are in the array. Each item represents the amplitude of that part of the waveform, from -1 to 1).</li>
			</ul>
			<p>If we have, for example, an oscillator node, we can create an analyzer node, connect it to the oscillator, and use the preceding two properties to get the waveform data for the sound that's playing at that precise moment:</p>
			<pre>let oscillator = audioContect.createOscillator(); // create the oscillator
let analyser = audioContect.createAnalyser(); // create the analyser node
oscillator.connect(analyser); // connect the oscillator and the analyser
oscillator.start(); // start the oscillator playing
let waveform = new Float32Array(analyser.frequencyBinCount); 
// create a Float32Array which will hold the waveform data in the next step
analyser.getFloatTimeDomainData(waveform); // get the waveform data for the  sounds at this precise moment.</pre>
			<p>The <code>getFloatTimeDomainData</code> function would be called every frame when creating an audio visualization. The information in this subsection will be useful for the activity at the end of this chapter, so refer back to it then.</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor367"/>Web Storage API</h1>
			<p>Storing data in the browser can be a great way of improving the user's experience. It can save the user having to wait while the same data is fetched from the server, and it can be used to instantly bring a previously visited page back to the state it was left in, meaning, for example, that the user doesn't have to refill in the same parts of a form. The <strong class="bold">Web Storage API</strong> is used to store data in the browser in the form of key/value pairs. It can be used to store data that a user has entered into a form to allow them to easily come back to it and complete it later, or it could be preferences a user has chosen in the web app, data that you want to pass from one page to another within the same origin, or any other piece of data that you think would be useful to store. The Web Storage API is synchronous, so setting and retrieving data will block other JavaScript code until the web storage methods have completed. Web storage is intended for storing relatively small amounts of data, in which case being synchronous won't have a noticeable effect on performance.</p>
			<p>You've probably heard of cookies as being an example of data storage within a browser. Web storage is somewhat similar to cookies, although their respective use cases are different: cookies are meant for sending data to the server, whereas web storage is designed for storage on the client-side only. Also, web storage allows for much more data to be stored – typically, web storage has a limit of <code>10 MB</code> (although, like with so much in the world of web development, this depends entirely on the browser in question), while cookies are limited to <code>4 KB</code>. Another key difference is that cookies must either have an expiration date set, or they will expire at the end of the session, while on the other hand, one kind of web storage is only removed via JavaScript, or by clearing the browser's cache.</p>
			<p>The Web Storage API is very simple, but before we get into that, let's look at the two variants of web storage and cover some other key points about the interface.</p>
			<p>There are two kinds of web storage available through the API: <code>sessionStorage</code> and <code>localStorage</code>. The main difference between these two is that <code>sessionStorage</code> will only persist for as long as the current session is active; that is to say until the browser window is closed. <code>localStorage</code>, on the other hand, has no expiration date and will live on the client machine until cleared, either via JavaScript or by clearing the browser's cache. Both <code>sessionStorage</code> and <code>localStorage</code> work on the same origin principle, meaning that data that's stored by a particular domain is only available to that domain.</p>
			<p>The methods that are available to both <code>sessionStorage</code> and <code>localStorage</code> are the same, and the API is very simple to use. There are five methods at our disposal, but only three or four are commonly used:</p>
			<ul>
				<li>The <code>setItem()</code> method is how we store a key/value pair in web storage. It takes two parameters, both of the string type. The first is the item's key, while the second is its value:<pre>// Sets key 'dog' with value 'woof'
sessionStorage.setItem('dog', 'woof');</pre></li>
				<li>The <code>getItem()</code> method allows us to get any item set in the store. It takes a single parameter, that is, the key of the item we want to retrieve. If an item of the supplied key doesn't exist in the store, then it will return null:<pre>sessionStorge.getItem('dog');
// gets the value of key 'dog'</pre></li>
				<li>The <code>removeItem()</code> method takes one parameter, that is, the key of the item you wish to remove:<pre>sessionStorage.removeItem('dog');
// removes the key 'dog' and its value</pre></li>
				<li>The <code>clear()</code> method clears the whole storage for the current page's origin and takes no parameters:<pre>sessionStorage.clear();
// clears all sessionStorage for the current origin</pre></li>
				<li>The <code>key()</code> method takes an index as its parameter and returns the key of the items at that index, or <code>null</code> if no item exists for the index:<pre>sessionStorage.key(0); 
// returns the key of item at index 0 (if any)</pre></li>
			</ul>
			<p>There are also the <code>sessionStorage.length</code> and <code>localStorage.length</code> properties, which return the number of items stored in the browser storage object.</p>
			<p>Web storage objects behave much like JavaScript objects in that we can access their properties through dot notation as well as by using the <code>setItem</code> and <code>getItem</code> methods:</p>
			<pre>sessionStorage.planet = 'Mars'; 
// sets an item with the key 'planet'
sessionStorage.planet;
// returns the string 'Mars'</pre>
			<p>An important point to note is that the value of an item must be a primitive data type, but that doesn't mean we can't store more complicated objects using web storage. If we want to store an object in web storage, we can stringify it using the JSON object <code>obj</code> when we set it, and then parse it when we want to retrieve it again:</p>
			<pre>let obj = {
  name: 'Japan',
  continent: 'Asia'
};
sessionStorage.setItem('country', JSON.stringify(obj));</pre>
			<p>We can then combine <code>sessionStorage.getItem()</code> with <code>JSON.parse()</code> to retrieve the object:</p>
			<pre>JSON.parse(sessionStorage.getItem('country'));
// Outputs the country object 'obj' defined above.</pre>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor368"/>Exercise 8.03: Storing and Populating Name Using the localStorage API</h2>
			<p>Let's make a simple web page that takes some user information and stores it using the <code>localStorageAPI</code> so that it will be displayed when the user visits the page next. Browser support for web storage is very strong these days. Still, it's important to account for the possibility that web storage is not supported, so make sure to warn the user in case web storage is unsupported in their browser. In this exercise, let's ask the user for their first name and last name. Let's get started:</p>
			<ol>
				<li value="1">First of all, let's create an HTML file with standard boilerplate HTML, and add a couple of input boxes for the user's first and last name, along with a warning message in case the browser doesn't support web storage. We'll set the <code>&lt;p&gt;</code> tags' display style to none by default:<pre>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;input type="text" id='first-name' placeholder='First name'&gt;
    &lt;input type="text" id='last-name' placeholder='Last name'&gt;
    &lt;p style='display: none;' id='warning'&gt;Your browser doesn't support local storage&lt;/p&gt;
    &lt;script src='storage.js'&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre><p>If you open this HTML file in the browser, it will look like this:</p><div><img alt="Figure 8.6. The HTML page with two input boxes&#13;&#10;" src="img/C14377_08_06.jpg"/></div><p class="figure-caption">Figure 8.6. The HTML page with two input boxes</p></li>
				<li>Next, we'll create a JavaScript file, starting off with a check to see whether the <code>localStorage</code> method is available on the window object. If it's not available, we simply return and set the warning message to display block, thus alerting the user that there will be reduced functionality on the page:<pre>// storage.js
if (!window.localStorage) {
  // if localStorage is not supported then display the warning and return out to stop the rest of the code from being run.
  document.getElementById('warning').style.display = 'block';
} else {</pre></li>
				<li>If the browser does support localStorage, we'll proceed to assigning any values for the <code>firstName</code> and <code>lastName</code> keys that are currently held in <code>localStorage</code> to variables of the same name:<pre>  let firstName = localStorage.getItem('firstName');
  let lastName = localStorage.getItem('lastName');</pre></li>
				<li>Then, we'll grab the two input elements, and if <code>firstName</code> or <code>lastName</code> have a value, then that value is set as the respective text input's value, thereby populating any string saved in <code>localStorage</code> back into the relevant text input:<pre>  let inputFName = document.getElementById('first-name');
  let inputLName = document.getElementById('last-name');
  if (firstName) {
    inputFName.value = firstName;
  }
  if (lastName) {
    inputLName.value = lastName;
  }</pre></li>
				<li>The final thing we need to do is add an event listener to the two text inputs and store their current values in <code>localStorage</code> each time the input event is fired:<pre>  inputFName.addEventListener('input', event =&gt; {
    localStorage.setItem('firstName', event.target.value);
  });
  inputLName.addEventListener('input', event =&gt; {
    localStorage.setItem('lastName', event.target.value);
  });
}</pre></li>
			</ol>
			<p>The error output will be displayed as follows:</p>
			<div><div><img alt="Figure 8.7: Output error&#13;&#10;" src="img/C14377_08_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7: Output error</p>
			<p>The output is displayed as follows, with the two names stored:</p>
			<div><div><img alt="Figure 8.8: The HTML page with two input variables stored and populated&#13;&#10;" src="img/C14377_08_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8: The HTML page with two input variables stored and populated</p>
			<p>This completes our simple application. Assuming <code>localStorage</code> is supported, any string that's entered into either of the text inputs will be saved and repopulated, even after the page is refreshed or the browser or tab is closed. 	</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Here, our method of feature detection is not robust, and it will not detect, for example, when the feature has been disabled in the browser. A better approach for production code is to attempt to set and get an item in <code>localStorage</code>. If the get value is as expected, then we know that local storage is working.</p>
			<p>While the web storage API is extremely useful for storing relatively small amounts of data, it's not well suited for storing larger files or data structures. Firstly, we can only store string values in web storage, and more importantly, since the API is synchronous, an application would take a performance hit if it were storing and retrieving large amounts of data.</p>
			<p>In cases where we want the client to store large datasets, files, or blobs, we can make use of anther browser API: the <code>IndexedDB</code> API.</p>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor369"/>IndexedDB</h1>
			<p><strong class="bold">IndexedDB</strong> is another form of client-side data storage that differs from web storage in some important ways:</p>
			<ul>
				<li>Unlike web storage, it is well suited to storing large amounts of data, and for storing many different data types.</li>
				<li>The API has much greater functionality than the web storage API, allowing us to do things such as perform queries against indexed data.</li>
				<li>It's an asynchronous API, so working with data stored in indexedDB won't block the execution of other code.</li>
			</ul>
			<p>These last two points hint at the biggest drawback with using indexedDB over web storage: its API and workflow are more complex than the simple get and set methods we use for web storage. IndexedDB is often criticized for having an overly complex API, but it's necessary to ensure data integrity (more on that soon), and anyway, if we take the time to understand some core concepts, then we'll see that it's actually not that complex after all.</p>
			<p>Like web storage, indexedDB follows the same origin rule, meaning that only pages at the same domain, protocol, and port can access a particular instance of indexedDB. Before we start working with indexedDB, let's examine some of its components and core concepts.</p>
			<p>An indexedDB database comprises one or more <strong class="bold">object stores</strong>. An object store, as its name suggests, is a container for the objects we are storing in the database. Like web storage, objects in indexedDB are stored as key/value pairs, but unlike web storage, the value doesn't need to be of the string type. The value could be any JavaScript data type, or even blobs or files.</p>
			<p>These objects are typically all of the same type, but they do not need to have the exact same structure as each other, as you may expect with traditional databases. For example, let's say we're storing data on employees. Two objects in the object store may have the salary property, but one's value could be 30,000 and the other could be thirty thousand.</p>
			<p>Object stores can be linked to indexes (which are actually just a different kind of object store). These indexes are used to efficiently query the data we store in the database. The indexes are maintained automatically. We'll look at how we can use them in more detail shortly:</p>
			<div><div><img alt="Figure 8.9: Layout of indexedDB&#13;&#10;" src="img/C14377_08_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9: Layout of indexedDB</p>
			<p>With indexedDB, all of our <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations are performed inside of a <strong class="bold">transaction</strong>, which we'll look at in detail soon. Working inside of a transaction can seem like a convoluted way of doing things, but it's an effective way of preventing write operations happening on the same record at the same time. Consider two pages open on the same page, both of which are trying to update the same record. When a transaction is open on one page, the other is unable to perform operations on the same record.</p>
			<p>The process of working with indexedDB can be broken down into four steps:</p>
			<ol>
				<li value="1">Open the database.</li>
				<li>Create an object store if the required store doesn't exist yet.</li>
				<li>Process the transaction: create, read, update, or delete a record or records.</li>
				<li>Close the transaction.</li>
			</ol>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor370"/>Exercise 8.04: Creating an Object Store and Adding Data</h2>
			<p>Let's create a database that will hold records of animals. We'll go through the preceding steps in more detail to create a database, create an object store, start a transaction, and add some data to the database. Add the code that follows into the console of the Google Chrome developer tools:</p>
			<ol>
				<li value="1">We'll initialize a variable called request with the <code>indexedDB.open()</code> method and pass the database name <code>animals</code> and the database version number <code>1</code> as parameters. It returns a request object, which in turn will receive one of three events: <code>success</code>, <code>error</code>, or <code>upgradeneeded</code>:<pre>let request = window.indexedDB.open('animals', 1);</pre><p>When we call open for the first time, the <code>upgradeneeded</code> event is triggered, and we can attach an <code>onupgradeneeded</code> event handler function, in which we will define our object store.</p></li>
				<li>Then, we'll define a function to handle the <code>onupgradeneeded</code> event, assign the database at <code>event.target.results</code> in a <code>db</code> variable, and create a <code>'mammals'</code> object store:<pre>request.onupgradeneeded = event =&gt; { // handle the upgradeneeded event
  let db = event.target.result;
  db.createObjectStore('mammals', {
    keyPath: 'species'
  });
};</pre><p>Notice that we pass a second parameter, <code>1</code>, to the open method. This is the database's version number, which we can change to allow changes to object stores, or to add new object stores. We'll see how this works later.</p><p>The database itself is accessible at the request object's result property. We can access it either through the event object at event.target, or through the request object (the event target is the request object).</p><p>We then use the <code>createObjectStore()</code> method of the database to create a new store. We pass this method a name, which can be any string, but which should typically describe what kind of data is being stored. We also pass in an object, with a key of keypath and a value of the key we want to use to address the objects we store, and for accessing the objects stored.</p></li>
				<li>Now that we've created our database, we can go ahead and insert some objects. This time, when we call the open method of the indexedDB object -- assuming there are no errors -- the success event will be triggered, and we access the database and proceed with the transaction. Let's run through what we are doing with the <code>onsuccess</code> handler. Assign the database to a <code>db</code> variable again and handle the errors that may occur (for now, we'll just log them to the console):<pre>request.onsuccess = event =&gt; {
  let db = event.target.result;
  db.onerror = error =&gt; {
    console.log(error);
  }</pre></li>
				<li>Create a transaction with the <code>storeName</code> property of <code>'mammals'</code> and the type of <code>'readwrite'</code>. This limits the transaction to only be able to perform read/write operations to the <code>'mammals'</code> object store:<pre>  let transaction= db.transaction('mammals', 'readwrite');</pre></li>
				<li>Next, we assign the object store to the store variable and add two records to the store:<pre>  let store = transaction.objectStore('mammals');
  store.put({
    species: "Canis lupus",
    commonName: "Wolf",
    traits: ["Furry", "Likes to howl at moon"]
  });
  store.put({
    species: "Nycticebuscoucang",
    commonName: "Slow Loris",
    traits: ["Furry", "Every day is Sunday"]
  });</pre></li>
				<li>Then, we define the action that should happen when the transaction receives the <code>'complete'</code> event, which is to close the database, thereby completing our transaction:<pre>  transaction.oncomplete = () =&gt; {
    db.close();
  };
};</pre></li>
				<li>After running this code, and assuming there were no errors, you can open Chrome's developer tools, navigate to the <code>Application</code> tab, and expand the IndexedDB storage item on the left-hand side. In here, you'll see your newly created <code>animals</code> database, containing its mammals object store, and the two entries we added previously:<div><img alt="Figure 8.10: Viewing IndexedDB in DevTools&#13;&#10;" src="img/C14377_08_10.jpg"/></div><p class="figure-caption">Figure 8.10: Viewing IndexedDB in DevTools</p></li>
				<li>Now that you've saved some data in the database, let's learn how to retrieve it again. The process of retrieving data follows a similar pattern to storing it in the first place. When we created the object store, we set the <code>keyPath</code> to species as we know this will be a unique property. We can use this property to access a particular entry in the object store:<pre>indexedDB-v2.js
1 let request = window.indexedDB.open('animals', 1);
2 
3 request.onsuccess = event =&gt; {
4   let db = event.target.result;
5   db.onerror = error =&gt; {
6     // handle an error
7     console.log(error); 
8   }
9   let trx = db.transaction('mammals', 'readonly');
10   let store = trx.objectStore('mammals');
11   let animalReq = store.get('Nycticebuscoucang');
12   animalReq.onsuccess = (event) =&gt; {
13     console.log(event.target.result);
14   };
The full code is available at: <a href="https://packt.live/2q8v5bX">https://packt.live/2q8v5bX</a></pre></li>
				<li>Like we did previously, we must initiate a request to open the database and attach an <code>onsuccess</code> handler to that request. When the success event is emitted, we can access the database through either request.result or through the event object, that is, event.target.result. We can now create a transaction by calling the database's <code>transaction()</code> method and specify the object store and transaction type we want with mammals and readwrite. </li>
				<li>Next, we access the store by calling the <code>objectStore()</code> method of the transaction. We can now call the <code>get()</code> method and pass in the keyPath value of the entry we want to access. This <code>get()</code> method returns another request object, which also receives events for successes and errors. We attach one final success handler to the <code>onsuccess</code> property, which will access the <code>event.target.result</code> property. This contains the entry we are looking for.<p>When we first created the database, and every time we subsequently made a request to open it, we passed a database version number as the second parameter to the <code>indexedDB.open()</code> method. As long as we keep the version number the same, the database will open with consistent object stores, but we will not be allowed to make any changes to the structure of the stores, nor will we be able to add new object stores to the database. If we want to modify an object store or add a new one, we need to upgrade our database. We do this by simply creating an open request and passing a new version number to the second parameter. </p><p>This will trigger the request's onupgradeneeded event and allow us to create a version change transaction, which is the only type of transaction in which we can modify or add an object store. Version numbers must be integers, and any new version must be of a higher value than the database's current version number.</p><p>Let's say we want to add another object store, this time for animals in the <code>upgradeneeded</code> event is the same as when we first created the database. When a new object store is added, the success event will be triggered on the request object. This means we can add entries to our new object store immediately after creating it:</p></li>
			</ol>
			<pre>indexedDB-v3.js
2 let request = window.indexedDB.open('animals', 2);
3 
4 // handle the upgradeneeded event
5 request.onupgradeneeded = event =&gt; {
6   let db = event.target.result;
7   // Our new cephalopods store
8   db.createObjectStore('cephalopods', {
9     keyPath: 'species'
10   });
11 };
12 
13 request.onsuccess = event =&gt; {
14   let db = event.target.result;
15   db.onerror = error =&gt; {
16     console.log(error) 
The full code is available at: <a href="https://packt.live/2pdYCAr">https://packt.live/2pdYCAr</a></pre>
			<p>Looking again at the Application tab of Chrome's developer tools, we will see our newly created cephalopod store and its two new entries:</p>
			<div><div><img alt="Figure 8.11: New object store and entries in indexedDB&#13;&#10;" src="img/C14377_08_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: New object store and entries in indexedDB</p>
			<p>In this exercise, we created a database that holds records of animals. You can further try to add different object stores and add data to it.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor371"/>Querying IndexedDB</h2>
			<p>As well as accessing data by its key (species, in our examples so far), we can run simple queries against an object store to return multiple entries that match our query term. The data in indexedDB needs to be indexed by any key that we want to use for queries; unlike other databases, there is no in-built search functionality with indexedDB. If we decided we wanted to use a different key than the keyPath we set when we created our objectStore, we would need to create a new index.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor372"/>Exercise 8.05: Querying the Database</h2>
			<p>In this exercise, we will see how we can use a different key to the <code>keyPath</code> that we used when we created our <code>objectStore</code>. To do so, we will use the <code>createIndex</code> method, which takes in two parameters and an <code>options</code> object as the third parameter. The first is the name we want to associate the new index with, while the second is the data key we want to link to the index. Doing this requires updating the database version once again when we create the database open request. Let's work through the exercise to see how we can achieve this. Like we did previously, follow along in a code snippet in Google Chrome's developer tools:</p>
			<ol>
				<li value="1">Make a new request to open the animals database and assign a function to the <code>onupgradeneeded</code> event:<pre>let request = window.indexedDB.open('animals', 3); // version 3 of the DB
request.onupgradeneeded = event =&gt; {</pre></li>
				<li>Access the mammals store through <code>event.target.transaction.objectStore</code> and call the <code>createIndex()</code> method on it:<pre>  let store = event.target.transaction.objectStore('mammals');
  store.createIndex('traits', 'traits', {multiEntry: true, unique: false});
};</pre><p>As we mentioned previously, the <code>createIndex</code> method takes in two parameters. In our example, we use traits for both of these parameters. The third parameter is an <code>options</code> object. Here, you can set the unique property to true so that the database does not allow duplicates of this key to be stored, or to <code>false</code> to allow multiple records with the same value for this key. You can also set a <code>multiEntry</code> parameter. If it's set to <code>true</code>, then the database will add an entry for every item in an array; if it's set to <code>false</code>, then the entire array will be indexed as one entry. Setting this to true will allow us to query entries by a single trait, as we'll see now.</p></li>
				<li>Next, we instantiate a database open request object for version 3 of our database and create another <code>onsuccess</code> event handler function:<pre>let request = window.indexedDB.open('animals', 3);
request.onsuccess = event =&gt; {</pre></li>
				<li>We then get hold of the resulting database, create a transaction, access the store, and call the store's <code>index()</code> method with the name of the index we wish to query against:<pre>  let db = event.target.result;
  let trx = db.transaction('mammals', 'readonly');
  let store = trx.objectStore('mammals');
  let index = store.index('traits')</pre></li>
				<li>Then, we call <code>index.getAll()</code> with the value of <code>Furry</code> and assign the returned value to the <code>animalReq</code> variable. As usual, this object receives a success event, through which we can access an array of all the records matching our query:<pre>  let animalReq = index.getAll('Furry');
  animalReq.onsuccess = (event) =&gt; {
    console.log(event.target.result);
  };</pre></li>
				<li>Lastly, we create an error event handler to deal with any errors that may arise:<pre>  animalReq.onerror = (error) =&gt; {
    console.log(error); // handle any error
  };
};</pre></li>
				<li>If we run this code, we should get all the database entries that match our query:</li>
			</ol>
			<div><div><img alt="Figure 8.12: The result from accessing all the Furry mammals in the database&#13;&#10;" src="img/C14377_08_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12: The result from accessing all the Furry mammals in the database</p>
			<p>In this exercise, we learned to use a different key to the <code>keyPath</code> and the <code>createIndex</code> method, which took two parameters and an <code>options</code> object as the third parameter.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor373"/>IndexedDB Cursor</h2>
			<p>As we mentioned previously, indexedDB does not have native record search functionality for unindexed record keys. If we want this functionality in our database, we're on our own. IndexedDB does, however, provide us with a cursor, which is an object representing a location in an object store, and which we can use to iterate through objects in the database. Like other parts of the indexedDB API, the cursor object is event-based, so we must wait for a success event to be fired before proceeding with our operations:</p>
			<pre>let request = window.indexedDB.open('animals', 3);
request.onsuccess = event =&gt; {
  let db = event.target.result;
  let trx = db.transaction('mammals', 'readonly');
  let store = trx.objectStore('mammals'); 
  let cursorReq = store.openCursor();
  cursorReq.onsuccess = e =&gt; {
    let cursor = e.target.result;
    if (cursor) {
      console.log(cursor.value); // do something with this entry.
      cursor.continue();
    } else {
      console.log('end of entries');
    };
  };
};</pre>
			<p>Once again, we'll walk through the processes of gaining access to the database, opening a transaction, and accessing the store we're interested in. We can now use the <code>openCursor()</code> method of the object store to create our cursor. This method can take two optional parameters: a range of keys within which the cursor can iterate, and a direction that tells the cursor which direction to move in through the records when its <code>continue()</code> method or <code>advance() </code>method is called. The possible values for the direction parameter are <code>next</code>, <code>nextunique</code>, <code>prev</code>, and <code>prevunique</code>, with the default of next. </p>
			<p>In our case, we haven't provided any parameters to the <code>openCursor()</code> method, so it will iterate through all the keys and will move forward over each individual record.</p>
			<p>We then define an <code>cursor.delete()</code> method. In our example, we are simply logging the record to the console and then calling the <code>continue()</code> method. Calling <code>continue()</code> moves the cursor on to the next record, which then triggers the <code>cursorReq</code> object's success event, starting this part of the process again. If the cursor has reached the end of the records, the cursor object will be <code>null</code>, and we can terminate the process. </p>
			<p>There's been a lot to cover in indexedDB – this is unsurprising, really, given that it's a comprehensive client-side database that comes with a lot more functionality, and therefore complexity, than the Web Storage API we looked at previously.</p>
			<p>Before we move on to an exercise to solidify our understanding of indexedDB, here is a quick recap of what we've covered:</p>
			<ul>
				<li>IndexedDB is suitable for storing large amounts of data.</li>
				<li>It can store many more data types than web storage (any JavaScript data type, files, or blobs).</li>
				<li>It's event-based – pretty much all operations are requested from the database and receive various events.</li>
				<li>It's asynchronous.</li>
				<li>It comprises the database, one or more object stores, data objects, and indexes (a kind of object store).</li>
				<li>All operations happen inside of a transaction, which ensures that all the operations complete successfully or that the object store is reverted back to its pre-transaction state.</li>
				<li>We can query records against specified indexes.</li>
				<li>We can use a cursor to iterate through records in an object store and use this to create our own search features, as required for our application.</li>
			</ul>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor374"/>Exercise 8.06: Fetching, Storing, and Querying Data</h2>
			<p>In this exercise, we'll be fetching some data from a remote API, storing it in an indexedDB database, and then writing our own function to query the database for a particular subset of data. We'll do this by adding 200 <code>todo</code> items to the database and retrieving the tasks that are not complete. </p>
			<p>The API we'll be calling can be found at <a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a>. If we make a get request to its <code>todos</code> route, we will get a list of <code>todo</code> items in response.</p>
			<p>We will then create an indexedDB database and an object store and store all this data in the store. In this example, we will use the fetch API, which is another Browser API that's used for making HTTP requests in JavaScript. Let's get started:</p>
			<ol>
				<li value="1">In a new snippet in Google Chrome's developer tools, we'll get the data from the API:<pre>const http = new XMLHttpRequest();
http.open('GET', 'https://jsonplaceholder.typicode.com/todos');
http.send();
http.onload = event =&gt; {
  let todos = JSON.parse(event.target.responseText);</pre><p>Here, we're using the <code>XMLHttpRequest()</code> constructor to make a new HTTP get request to our API endpoint. </p></li>
				<li>Then, we're setting a function to the load event listener of the HTTP request object. This event handler is where we receive our <code>todos</code> data from the API and is where we will write the rest of our code. If we were to console log the <code>todos</code> variable, we would see an array of objects in the following format:<pre>{
  userId: 1,
  id: 1,
  completed: false,
  title: "delectusautautem"
}</pre></li>
				<li>Once we have our data in the <code>todos</code> variable, we'll create a new database called tasks and a new object store called <code>todos</code> and set the object store's <code>keyPath</code> to the id property of our <code>todo</code> items (again, everything is happening inside the http object's onload handler):<pre>  let dbRequest = window.indexedDB.open('tasks', 1);
  dbRequest.onupgradeneeded = event =&gt; {
    // handle the upgradeneeded event
    let db = event.target.result;
    db.createObjectStore('todos', {
      keyPath: 'id'
    });
  };</pre></li>
				<li>We can now go ahead and add our <code>todo</code> items to the database. Like we did previously, we'll add some lines of code to our http.onload event handler. This time, we'll add an <code>onsuccess</code> function to our <code>dbRequest</code> object, in which we'll get the database from the success event object and start a <code>readwrite</code> transaction targeting the <code>todos</code> store. We'll access the store from the transaction use a <code>forEach</code> loop to loop through the items in the <code>todos</code> array, and push each one into the database:<pre> dbRequest.onsuccess = event =&gt; {
    let db = event.target.result;
    let trx = db.transaction('todos', 'readwrite');
    let store = trx.objectStore('todos');
    todos.forEach(item =&gt; {
      store.put(item);
    });
    trx.oncomplete = () =&gt; {
      console.log('close');
      db.close();
    };
  };
};</pre></li>
				<li>Select the <code>Application</code> tab of the developer tools and expand the IndexedDB list on the left-hand side. Here, you should find our tasks database containing the <code>todos</code> object store, which should now have our 200 <code>todo</code> items:<div><img alt="Figure 8.13: Showing indexedDB after the data has been added&#13;&#10;" src="img/C14377_08_13.jpg"/></div><p class="figure-caption">Figure 8.13: Showing indexedDB after the data has been added</p></li>
				<li>With our data safely in the database, we'll write a query function to get all of our <code>todo</code> items that have completed set to false. First, we'll instantiate an empty array to hold our uncompleted <code>todos</code>. Then, we'll use the indexedDB cursor interface to iterate through the records. For each record, we'll check to see whether the completed property is <code>false</code>. If it is, we'll push the record into the array. Since we already have our data in the database, it's best to comment out the last block of code, otherwise, we'll make the HTTP request again and save duplicates of all the <code>todos</code>:</li>
			</ol>
			<pre>exercise-8_06_1.js
1 let dbRequest = window.indexedDB.open('tasks', 1);
2 let outstandingTodos = [];
3 dbRequest.onsuccess = event =&gt; {
4   let db = event.target.result;
5   let trx = db.transaction('todos', 'readonly');
6   let store = trx.objectStore('todos');
7   let cursorReq = store.openCursor();
8   cursorReq.onsuccess = e =&gt; {
9     let cursor = e.target.result;
10     if (cursor) {
11       console.log(cursor.value)
12       if (!cursor.value.completed) outstandingTodos.push(cursor.value);
The full code is available at: <a href="https://packt.live/2qRT6Ek">https://packt.live/2qRT6Ek</a></pre>
			<p>This results in the following output:</p>
			<div><div><img alt="Figure 8.14: The console output from our query function&#13;&#10;" src="img/C14377_08_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14: The console output from our query function</p>
			<p>We can see that the completed property is <code>false</code> from the preceding figure and uncompleted are <code>true</code>. In this exercise, we learned to fetch some data from a remote API, storing it in an <code>indexedDB</code> database, and then writing our own function to query the database for a particular subset of data.</p>
			<p>This section has covered one of the more complicated web APIs. Here's a quick recap of the IndexedDB API's core principles:</p>
			<ul>
				<li>IndexedDB databases comprise the database, which contains one or more object stores, which contain the actual data objects</li>
				<li>(Almost) everything happens with events, so you use event handlers a lot.</li>
				<li>Transactions are where the business happens. Transactions apply to only one object store and can be read-only, read-write, or version-change.</li>
				<li>You can fetch items by their key name if they have been indexed by that key, or you can use a cursor to iterate through a set of records.</li>
			</ul>
			<p>Now, we'll look at a browser API we can use to give us information on how performant a site or application is. This API is surprisingly called the Performance API.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor375"/>Performance API</h1>
			<p>When we're building sites and web apps, it's important to be able to measure the performance of our applications to help ensure good user experiences. We do this during development, testing stages, and in production. As our application grows and we add new features, it's equally important to make sure that the changes we're making aren't negatively affecting performance. There are a number of ways to measure this and some useful tools to help us. One such set of tools is the browser's <strong class="bold">Performance API</strong> and other closely related APIs.</p>
			<p>The Performance API allows us to time events with extreme accuracy: the time measurements we have access to are expressed in milliseconds but are accurate to about 5 microseconds. With these APIs, we can accurately measure the time it takes to complete specific actions, such as the following:</p>
			<ul>
				<li>The time it took to render the first pixel on our page</li>
				<li>The time between a user clicking an element and the next action (for example, the start of an animation, or sending a request to the server)</li>
				<li>The time it takes for various page resources to load</li>
				<li>The time it takes for information to be sent from the browser to the server, and then to get a reply</li>
			</ul>
			<p>The API also gives us access to particular data that the browser collects during events leading up to our site being loaded, such as the following:</p>
			<ul>
				<li>The type of navigation that leads to the page being loaded (from history, navigation event, or page reload)</li>
				<li>How long it took for the DNS to respond with the IP address of the webserver</li>
				<li>How long it took to establish a TCP connection</li>
			</ul>
			<p>You can also create custom measurements to see how long particular processes take in the application. Together, all of this information can be used to create detailed accounts of a site's performance, help identify areas of the application which need optimization, and track the performance improvements (or hits) as you make changes to your site.  </p>
			<p>Let's say you want to know how long your page takes to load. That's a reasonable question to ask, but you have to be a bit more specific about what you mean before answering this question accurately and usefully. First, you need to ask yourself what information you actually want: from a developer's point of view, this question could be interpreted as "how long does it take for my webserver to send all the requested resources to the browser, and for the browser to then process and render them?", but from the user's perspective, the question would be more akin to, "how long does it take from the moment I click a link to the moment the page has fully loaded?". Both of these questions are important, but the user's question requires more information to answer than the developer's. So, we can start to see that we need to break down all the events taking place to be able to answer these, and other, questions. This is where the Performance API comes in: it gives us many metrics we can use, including from processes that happen before our page is requested.</p>
			<p>First, let's break down some of the key steps that take place when a user clicks on a link to a site at a new domain. In practice, there are more steps involved than those shown here, but it's not really necessary to unpick the whole process for this example:</p>
			<div><div><img alt="Figure 8.15: Overview of processes after a user clicks a link&#13;&#10;" src="img/C14377_08_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15: Overview of processes after a user clicks a link</p>
			<p>Let's go through the following steps:</p>
			<ol>
				<li value="1">When a user clicks on a link – say a Google search result – the browser sends a request to the <strong class="bold">domain name server</strong> (<strong class="bold">DNS</strong>) and receives the IP address of the webserver for that domain. </li>
				<li>The browser then opens a TCP connection with the server at the IP address. </li>
				<li>When this connection process has finished, the browser requests the page data.</li>
				<li>The server responds with that data and the browser process and displays the page to the user. This is a very high-level, stripped-down, simplified account of what happens when a browser wants to load a page, and it assumes nothing went wrong. The takeaway here is that there's a lot going on and that there are many potential areas for navigation and page loads to be slowed down. Using the Performance API gives us the timings for many key events.</li>
			</ol>
			<p>Open your browser to any page. In the console, you can view the performance data for that page. We can get a navigation timing object from the browser, which will give us much of the information we're looking for. First, we'll assign the navigation entry of the Performance API to a variable:</p>
			<pre>let navTiming = performance.getEntriesByType("navigation")[0]; // this returns an array, but we're only interested in one object.</pre>
			<p>The <code>getEntriesByType</code> method returns all the performance timing entries that the browser has stored of the specified type. Here, we've said we want all the navigation type entries (there's only one entry, so we'll get an array with one object).</p>
			<p>After assigning a reference to the <code>0th</code> object in the returned array, we can view the object by entering the variable's name (that is, <code>navTiming</code>) in the console:</p>
			<div><div><img alt="Figure 8.16: Expanded navigation timing object&#13;&#10;" src="img/C14377_08_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.16: Expanded navigation timing object</p>
			<p>Expanding the navigation entry object, we can see many properties that we can use to calculate how long the various actions took during navigation and loading the current page. Let's run through a couple of examples so that you get the idea:</p>
			<pre>let dnsLookupTime = navTiming.domainLookupEnd - navTiming.domainLookupStart;</pre>
			<p>This will give us the total time take for the domain name service to respond with the IP address of the requested domain. The browser will typically cache the IP address of a particular domain, so it may well result in zero if you've previously visited the page you're testing. Let's take a look at the following code:</p>
			<pre>let tcpConnectTime = navTiming.connectEnd - navTiming.connectStart</pre>
			<p>The <code>connectStart</code> and <code>connectEnd</code> properties are the times at which the client established a TCP connection with the server and the time at which the connection process was complete. Taking one from the other gives us the total connection time. Let's take a look at the following code:</p>
			<pre>navTiming.domComplete;</pre>
			<p>The <code>domComplete</code> property is the time at which the browser finished loading the document and all its resources, such as CSS and images, and the <code>document.readyState</code> property is set to complete. This would be the answer to our user's question: "how long does it take from the moment I click a link to the moment page has fully loaded?".</p>
			<p>As you can see, there are many other metrics you can use in this navigation timing entry for timing the navigation and loading a page. But what about once our page has loaded and the user is interacting with it? We obviously want to be able to measure the performance of our site during its usage, and the Performance API gives us some useful methods for doing just that.</p>
			<p>We can use the Performance API to measure the performance of any part of our site or application by making use of the <code>mark()</code> and <code>measure()</code> methods of the interface. For example, let's say part of your application involves some CPU-intensive processing that you want to optimize. You can use performance marks to measure the time it takes to a high degree of precision and measure the success of different optimization approaches:</p>
			<pre>function complicatedFunction() {
  let n = 0;
  for (let i = 0; i&lt; 1e9;) {
    n = n + i++;
  }
  return n;
};</pre>
			<p>Here, we've defined a function that performs some arbitrary calculation <code>for</code> loop, we can use the <code>performance.mark()</code> method at the beginning and end of the loop, then use the <code>performance.measure()</code> method to measure the two marks and return the resulting measure:</p>
			<pre>functioncomplicatedFunction() {
  let n = 0;
  performance.mark('compStart');
  for (let i = 0; i&lt; 1e9;) {
    n = n + i++;
  }; 
  performance.mark('compEnd');
  console.log(n);
  performance.measure('compMeasure', 'compStart', 'compEnd');
  console.log(performance.getEntriesByName('compMeasure')[0].duration);
};</pre>
			<p>Calling the mark method creates a performance timeline entry with the name provided (we called our <code>compStart</code> and <code>compEnd</code>). We can then use <code>performance.measure()</code> to create a <code>performance.measure</code> entry, which will give us the precise times between the start and end marks. Running <code>complicatedFunction()</code> will give us the following output:</p>
			<div><div><img alt="Figure 8.17: Output from running the function&#13;&#10;" src="img/C14377_08_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.17: Output from running the function</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor376"/>Exercise 8.07: Assessing Performance</h2>
			<p>Let's say we want to add a new feature to our app that involves a similar CPU-intensive process to our preceding example, so we want to make sure we write the function in the most efficient way possible. We can use the Performance API's <code>mark()</code> and <code>measure()</code> methods to find the precise time taken to run a particular section of code, and we can then compare two different implementations of the same logic. In this exercise, we will use the <code>mark()</code> method to mark the start and endpoints of the blocks of code we want to compare, and we will use the <code>measure()</code> method to measure the exact time between the marks. Our output will be the time difference.</p>
			<p>Let's take the preceding example and compare the performance of different looping functions in JavaScript. Let's get started:</p>
			<ol>
				<li value="1">This first function will measure the performance of a <code>for</code> loop. Start by declaring a function and initializing a variable that will hold a value that was used in the loop:<pre>function complicatedForLoop() {
  let n = 0;</pre></li>
				<li>Now, we'll use the <code>performance.mark()</code> method to mark the start of the looping function, and we'll give the mark a name of <code>forLoopStart</code>:<pre>  performance.mark('forLoopStart');</pre></li>
				<li>Next, we'll run the for loop, which does the same calculations as it did in the preceding example:<pre>  for (let i = 0; i&lt; 1e9;) {
    n = n + i++;
  }
  performance.mark('forLoopEnd');
  console.log(n);
  performance.measure('forLoopMeasure', 'forLoopStart', 'forLoopEnd');
  console.log(`for loop: ${performance.getEntriesByName('forLoopMeasure')[0].duration}`);
};</pre></li>
				<li>This second function will measure the performance of a while loop:<pre>function complicatedWhileLoop() {
  let n = 0;
  let i = 0;
  performance.mark('whileLoopStart');
  while(i&lt;1e9) {
    n = n + i++;
  }
  performance.mark('whileLoopEnd');
  console.log(n);
  performance.measure('whileLoopMeasure', 'whileLoopStart', 'whileLoopEnd');
  console.log(`while loop: ${performance.getEntriesByName('whileLoopMeasure')[0].duration}`)
}</pre></li>
				<li>Now, let's run both of these functions and see how the performance compares:<pre>complicatedForLoop();
complicatedWhileLoop();</pre></li>
			</ol>
			<p>Here, we have declared two functions, both of which produce the same result, but using different JavaScript looping functions: a <code>for</code> loop and a <code>while</code> loop. We are marking the moment before each loop starts, and again marking the moment the loops end. We then measure the marks and log the measured duration to the console. What results did you get?</p>
			<div><div><img alt="Figure 8.18: Results from the performance tests on a for loop and a while loop&#13;&#10;" src="img/C14377_08_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.18: Results from the performance tests on a for loop and a while loop</p>
			<p>Your results may be quite different, depending on the system and the JavaScript engine you're running the code on, but you should still see a marked difference between the two loop statements. This section has dipped into a fairly advanced topic and one that may not be quite as exciting as, say, drawing triangles. However, application performance is important to keep in mind as failing to do so can lead to slow apps that people will find frustrating and may ultimately abandon.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor377"/>Web Socket API</h1>
			<p>Typically, when a browser connects to a server during normal browsing, it does so over HTTP or HTTPS. For the purposes of this topic, all we really need to know about HTTP is that each time a browser wants to send or receive a piece of information from the server, it has to open a new connection to that server, make its request, and then close the connection. This is fine for most situations, but it's a one-way street; the server cannot open a connection with the browser. This means that if the server receives some new data, it has no way of alerting the browser, and instead has to rely on the browser querying the server at some point and asking for the data. A lot of the time, this is ok because we developers know when we can expect new data to be available, or we know when in our application we want to request any new data.</p>
			<p>Relying on a developers' savviness falls short, of course, in situations where we don't have full control over when or how often new data is made available to the server. The classic example of such a situation is with real-time chat apps, for example, Facebook's instant messaging or WeChat. We're probably all familiar with the basic functionality of these apps: two or more people can send messages to each other, and they will appear on the receiver's device instantly (minus the network latency and processing time). </p>
			<p>But how is this functionality achieved? If we think about this in terms of HTTP, there's no elegant solution: Client A wants to send a message to Client B via the server. Sending the message from Client A to the server is no problem – the client can open an HTTP connection, send the message over, and the server will receive the message. But when it comes to the server relaying that message to Client B, the server is unable to open the connection on its end. In this situation, the solution would be for all connected clients to ask the server whether there are any new messages at regular intervals, say every 30 seconds. This is not a great solution; it means there will be lots of unnecessary opening and closing of connections, each one carrying a relatively large amount of data, in the form of HTTP headers. Also, if a client sends a message at second 1, then the receiving client won't know about that message for at least 29 seconds – and what if it's something important?</p>
			<p><strong class="bold">WebSockets</strong> are an alternative way for browsers and clients to communicate with each other and allow for bidirectional communication; that is to say that the server can send a message to the client at any time. The connection process is fairly simple at a high level: the client connects to a server over HTTP with a WebSocket handshake request containing an Upgrade header (which basically tells the server that the client wants to upgrade the protocol to WebSocket), the server sends a handshake response, and the HTTP connection is upgraded to a WebSocket connection. And then the party starts.</p>
			<p>This WebSocket connection stays active indefinitely, and the server keeps a list of connected clients that it can talk to at any moment. If a connection breaks, then the client can try to open the connection again. As long as the connection is active, then either side can send messages to the other at any moment, and the other side can reply to those messages if necessary. It's an open, bidirectional channel of communication, and it's up to us developers to decide what we're going to use it for.</p>
			<p>WebSocket messages can contain data of several types, including <strong class="bold">Strings</strong>, <strong class="bold">ArrayBuffers</strong>, and <strong class="bold">Blobs</strong>. To send and receive JavaScript objects, we can easily convert them into strings by using the JSON object before sending them and then parse them on the receiving side.</p>
			<p>Setting up a WebSocket server is fairly involved and would be too much detail to include in this chapter. However, we can easily set up a WebSocket client and connect to one of a number of WebSocket testing servers online.</p>
			<p>There are several WebSocket testing servers that we can use. In this example, we will use the server at <code>wss://echo.websocket.org</code>. If it's not working, feel free to find another online. One thing to note is that the client and server must start on the same HTTP protocol, so if the page that you've opened the console on is on HTTPS, then the WebSocket server must be on the WSS protocol (and not WS).</p>
			<p>Open your browser to any page of your choosing, open the developer tools, and open the console.</p>
			<p>WebSocket connections are event-driven, so when we create a connection, we must assign functions to the events we want to handle.</p>
			<p>To start off, let's create a new WebSocket connection using the browser's WebSocket constructor function. It takes the server address as a parameter:</p>
			<pre>let socket = new WebSocket('wss://echo.websocket.org');</pre>
			<p>If you run this code, and then access the socket object in the console, you will see the new connection object we have created:</p>
			<div><div><img alt="Figure 8.19: The WebSocket connection object&#13;&#10;" src="img/C14377_08_19.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.19: The WebSocket connection object</p>
			<p>Here, we can see the URL of the server we're connected to, and also that there are event listeners for <code>onmessage</code> property:</p>
			<pre>socket.onmessage = event =&gt; console.log(event);</pre>
			<p>Now, we are ready to send a message to the WebSocket server:</p>
			<pre>socket.send("Hello websocket server");</pre>
			<p>The server I have chosen – and surely any other WebSocket testing server – will simply output whatever message you send to it back as a response. Since we have an event handler attached to the message event, which will log the event to the console, we should get this event object logged to our console soon after we send the message:</p>
			<div><div><img alt="Figure 8.20: The response from the WebSocket server&#13;&#10;" src="img/C14377_08_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.20: The response from the WebSocket server</p>
			<p>We now have a functioning WebSocket connection. If the server were programmed to do so, it would be able to send us messages at any time, as long as the connection stays open. Because WebSockets are useful for many different kinds of applications, there is no specific functionality built into them, even though there are some very common use cases. It's up to us to develop systems to handle different kinds of messages, for example, sending a message with a "join chat group" action versus a regular "send message to the user" action.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor378"/>Exercise 8.08: Creating Chat Rooms Using Websockets</h2>
			<p>Let's create a small application to make some extended use of this WebSocket server. We'll be creating an application with two chat rooms: one is a group chat and one is a direct message chat room with a single user. We're a bit limited by the WebSocket server's functionality since all it does it send the message it receives back to the client. Since we're only one client, and the server will only respond with the message we send, it'll be a bit of a lonely chat.</p>
			<p>For this application, we'll need an HTML page with two lists of chat messages: one for the group chat and one for the direct messaging chat. We'll also need an input box for both chat threads so that we can type our messages in, as well as a few other elements along the way. We'll give most of the elements relevant IDs so that we can easily get hold of them in JavaScript later on. Let's get started:</p>
			<ol>
				<li value="1">Let's start off by creating an HTML page, adding our opening HTML tag, adding a head tag with a script referencing a JavaScript file in the <code>DevTools</code> console, and adding our opening body tag:<pre>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src='scripts.js'&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;</pre></li>
				<li>Now, inside the body, we'll add an <code>&lt;h1&gt;</code> element as our page's title:<pre>    &lt;h1&gt;The Echo Chamber&lt;/h1&gt;</pre></li>
				<li>Let's add an <code>&lt;h4&gt;</code> element, which will let us know if the socket is open or closed (the default is closed):<pre>    &lt;h4 id='socket-status'&gt;Socket is closed&lt;/h4&gt;</pre></li>
				<li>Let's add an <code>&lt;h6&gt;</code> element for our group chat message list header:<pre>    &lt;h6&gt;Group Chat&lt;/h6&gt;</pre></li>
				<li>Let's add a  <code>&lt;ul&gt;</code> element to which we will append new group messages:<pre>    &lt;ul id='group-list'&gt;&lt;/ul&gt;</pre></li>
				<li>Let's add an <code>&lt;input&gt;</code> element in which we will write messages to the group chat:<pre>    &lt;input type="text" id='group-input'&gt;</pre></li>
				<li>Let's add another <code>&lt;h6&gt;</code> element for the private chat room:<pre>    &lt;h6&gt;Private Chat&lt;/h6&gt;</pre></li>
				<li>Let's add a <code>&lt;ul&gt;</code> element for the private chat messages list:<pre>    &lt;ul id='dm-list'&gt;&lt;/ul&gt;</pre></li>
				<li>The following is the input we need for writing private messages:<pre>    &lt;input type="text" id='dm-input'&gt;</pre></li>
				<li>Finally, we need to add our closing <code>&lt;body&gt;</code> and <code>&lt;html&gt;</code> tags:<pre>  &lt;/body&gt;
&lt;/html&gt;</pre><p>This results in the following output:</p><div><img alt="Figure 8.21: Our new chat app's HTML&#13;&#10;" src="img/C14377_08_21.jpg"/></div><p class="figure-caption">Figure 8.21: Our new chat app's HTML</p><p>Now for the JavaScript: let's go through the functionality we need in a bit more detail. We'll need to get hold of some of our HTML elements so that we can work with them in our JavaScript. We need to open a new web socket connection to our server, that is, <code>wss://echo.websocket.org</code>. We'll want to notify the user when the socket is open or closed, so we'll add socket event handlers for <code>onopen</code> and <code>onclose</code> and set our <code>&lt;h4&gt;</code> element's text accordingly. We'll listen for when a user has pressed the <em class="italic">Enter</em> key on either of the input boxes and then send a message to the socket server. The server will echo our messages back to us, so we'll want to listen for incoming messages, decode them, and attach them to the end of the correct message list. </p><p>That's a high-level breakdown of what our JavaScript will do, so let's walk through the code.</p></li>
				<li>We'll start the JavaScript file with an event listener listening for the <code>DOMContentLoaded</code> event, and we'll put our code inside the event listener's callback function:<pre>// scripts.js
// wait for page load
document.addEventListener('DOMContentLoaded', () =&gt; { </pre></li>
				<li>Next, we'll create a new socket connection to our chosen server:<pre>  let socket = new WebSocket("wss://echo.websocket.org"); // create new  socket connection</pre></li>
				<li>Let's grab the references to the various HTML elements we'll need:<pre>  let dmInput = document.getElementById('dm-id'); // get the DM text input
  let groupInput = document.getElementById('group-input'); // get the group text input
  let dmList = document.getElementById('dm-list'); // get the dm messages list
  let groupList = document.getElementById('group-list'); // get the group  messages list</pre></li>
				<li>Now, we'll set the socket's onopen event handler function, which will set the socket-status element's inner text to Socket is open:<pre>  socket.onopen = event =&gt; {
    document.getElementById('socket-status').innerText = "Socket is open"; 
    // set the status on open
  };</pre></li>
				<li>We'll also set a function for the socket's <code>onclose</code> event, which will revert the status to Socket is closed:<pre>  socket.onclose = event =&gt; {
    document.getElementById('socket-status').innerText = "Socket is closed";
    // set the status on close
  };</pre></li>
				<li>Next, we'll set the socket's <code>onmessage</code> function. This event is triggered when a message is received from the websocket server:<pre>  // prepare to receive socket messages
  socket.onmessage = event =&gt; { </pre></li>
				<li>We'll parse the incoming data from a string back to a JavaScript object using the JSON object's <code>parse()</code> method and assign the result to a variable:<pre>    // parse the data
    let messageData = JSON.parse(event.data); </pre></li>
				<li>We'll create a new <code>&lt;li&gt;</code> element and assign it to a variable called <code>newMessage</code>:<pre>    // create a new HTML &lt;li&gt; element
    let newMessage = document.createElement('li'); </pre></li>
				<li>Next, we'll set the inner text value of <code>newMessage</code> <code>&lt;li&gt;</code> to the value of the message data's message property:<pre>    // set the &lt;li&gt; element's innerText to the message text
    newMessage.innerText = messageData.message; </pre></li>
				<li>Now, we'll check whether the message is meant for the group chat, and if it is, we'll append it to the <code>groupList</code>: <pre>    // if it's a group message
    if (messageData.action === 'group') { 
      // append to the group list
      groupList.append(newMessage); </pre></li>
				<li>If it's not meant for the group chat, then we'll append it to the DM list instead, and then close off this event handler function:<pre>    } else {
      // append to the dm list
      dmList.append(newMessage); 
    };
  };</pre></li>
				<li>Next, will iterate through both of the HTML's input elements:<pre>  // For each input element
  Array.from(document.getElementsByTagName('input')).forEach(input =&gt; { </pre></li>
				<li>We'll add a <code>keydown</code> event listener to the input elements and assign a handler function to the event:<pre>    // add a keydown event listener
    input.addEventListener('keydown', event =&gt; { </pre></li>
				<li>If the <code>keydown</code> event was triggered by the key with <code>messageData</code>:<pre>      // if it's keyCode 13 (the enter key)
      if (event.keyCode === 13) {
        // declare the message data object
        let messageData = {
          message: event.target.value,
        };</pre></li>
				<li>Now, we'll check whether the target input is the one with the ID of <code>group-input</code>, in which case we'll set an action property on the <code>messageData</code> variable with a value of group:<pre>        // check the message type by looking at the input element's ID
        if (event.target.id === 'group-input') {
          messageData.action = 'group';</pre></li>
				<li>Otherwise, we'll assign the same property, but with a value of dm:<pre>        } else {
          messageData.action = 'dm';
        };</pre></li>
				<li>Then, we'll turn the <code>messageData</code> object into a string with the <code>JSON.stringify()</code> method and send it to the websocket server with the <code>send()</code> method of the socket connection object we created at the start:<pre>        // stringify the message and send it through the socket connection
        socket.send(JSON.stringify(messageData));</pre></li>
				<li>Finally, we'll clear the target input box and close off the functions:<pre>        // clear the input element
        event.target.value = ''; 
      };
    });
  });
});</pre></li>
			</ol>
			<p>Open the HTML file in your browser and if you type a message into either of the input boxes, you should see it echoed back in the chat list:</p>
			<div><div><img alt="Figure 8.22: The Echo Chamber chat app with message&#13;&#10;" src="img/C14377_08_22.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.22: The Echo Chamber chat app with message</p>
			<p>This is a quick insight into how we can add our own functionality to the WebSocket API. Websockets can be useful any time we need real-time data to be shown in the browser, such as stock market price updates, or when it makes sense to have a sustained open connection with the server, such as in a chat app.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor379"/>Activity 8.03: Audio Visualization </h2>
			<p>We're going to tie together a couple of the interfaces we looked at right at the start of this chapter, that is, the Canvas API and the Web Audio API. The aim of this activity is to create a page that is displaying a graphic, and for that graphic to animate based on the Audio <code>API's getFloatTimeDomainData</code> method that we looked in the <em class="italic">Audio API</em> section. The Audio API's sound should be controlled by the user, and the graphic should represent the audio in some way (the animation could change based on the sound's volume, or its frequency, for example).</p>
			<p>This is quite a broad specification for the activity, but you can build the exercises for the two APIs to come up with something, or you can make use of information in the <em class="italic">Audio Visualization</em> subsection of the <em class="italic">Web Audio API </em>section earlier in this chapter. See what you can come up with before checking out the solution.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Create a simple HTML file with a link to a JavaScript file.</li>
				<li>Add an event listener on the document that's listening for a click event.</li>
				<li>Set up an HTML canvas element and a canvas rendering context.</li>
				<li>Set up an Audio context with one or more oscillators, or other audio sources if you like.</li>
				<li>Connect an audio analyzer to the audio context.</li>
				<li>Start the audio source.</li>
				<li>Inside a continuous loop, draw in the Canvas context using the output from the audio API's <code>getFloatTimeDomainData()</code> method to modify one or more of the parameters of the graphic on each iteration of the loop.</li>
			</ol>
			<p>The expected output should be as follows:</p>
			<div><div><img alt="Figure 8.23: One frame of the audio visualization output image&#13;&#10;" src="img/C14377_08_23.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.23: One frame of the audio visualization output image</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 734.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor380"/>Summary</h1>
			<p>In this chapter, we've looked at a few of the most useful and interesting browser APIs that open up a wide range of functionality that we can make use of in our JavaScript applications. We've seen that while these APIs are commonly accessed through JavaScript, they are not a part of the ECMAScript specification to which JavaScript engines are programmed and are not part of JavaScript's core functionality. Even though we covered quite a lot of information in this chapter, there are many more APIs available to us. When working with browser APIs, it's important to check how much browser support there is for that particular feature, as some APIs are experimental or non-standard, while others are deprecated or obsolete. Often, some browsers will fully support a feature, others will support certain aspects of the same interface, and then others will not support it at all. It is a bit of a minefield, but make use of <a href="http://caniuse.com">caniuse.com</a>, which you looked at earlier in this book, to steer yourself and your projects in the right direction. </p>
			<p>For a list of available Web APIs, check out the Mozilla Developer Network's page: <a href="https://developer.mozilla.org/en-US/docs/Web/API">https://developer.mozilla.org/en-US/docs/Web/API</a>.</p>
			<p>So far, you have been mostly learning about traditional, browser-based JavaScript. However, there are many other environments outside of the browser where JavaScript can run. In the next chapter, we'll look at some of these other environments, notably <strong class="bold">Node.js</strong>, which is typically used for server-side JavaScript execution.</p>
		</div>
	</body></html>