["```js\nnpm install ramda @types/ramda\n```", "```js\nconst compose = <T>(f: (x: T) => T, g: (x: T) => T) => (x: T) => f(g(x));\n```", "```js\nconst trim = (s: string) => s.trim();\nconst capitalize = (s: string) => s.toUpperCase();\nconst trimAndCapitalize = compose(trim, capitalize);\nconst result = trimAndCapitalize(\" hello world \");\nconsole.log(result); // \"HELLO WORLD\"\n```", "```js\nimport R from \"ramda\";\n\nconst trim = (s: string) => s.trim();\nconst capitalize = (s: string) => s.toUpperCase();\nconst trimAndCapitalize = R.compose(trim, capitalize);\nconst result = trimAndCapitalize(\" hello world \");\nconsole.log(result); // \"HELLO WORLD\"\n```", "```js\nfunction curry3<T1, T2, T3, T4>(fn: (a: T1, b: T2, c: T3) => T4) {\n    return (a: T1) => (b: T2) => (c: T3) => fn(a, b, c);\n}\n\nconst trim = (s: string) => s.trim();\nconst capitalize = (s: string) => s.toUpperCase();\nconst trimAndCapitalize = R.compose(trim, capitalize);\nconst replace = (s: string, f: string, r: string) => s.split(f).join(r);\n\nconst curriedReplace = curry3(replace);\n\nconst trimCapitalizeAndReplace = compose(\n    trimAndCapitalize,\n    curriedReplace(\"/\")(\"-\")\n);\n\nconst result = trimCapitalizeAndReplace(\" 13/feb/1989 \");\nconsole.log(result); // \"13-FEB-1989\"\n```", "```js\nimport R from \"ramda\";\n\nconst trim = (s: string) => s.trim();\nconst capitalize = (s: string) => s.toUpperCase();\nconst replace = (s: string, f: string, r: string) => s.split(f).join(r);\n\nconst trimCapitalizeAndReplace = R.compose(\n R.compose(trim, capitalize),\n R.curry(replace)(\"/\")(\"-\")\n);\n\nconst result = trimCapitalizeAndReplace(\" 13/feb/1989 \");\nconsole.log(result); // \"13-FEB-1989\"\n```", "```js\ninterface Lens<T1, T2> {\n    get(o: T1): T2;\n    set(o: T2, v: T1): T1;\n}\n\ntype Prop<T, K extends keyof T> = (o: T) => T[K];\ntype Assoc<T, K extends keyof T> = (v: T[K], o: T) => T;\n\nconst lens = <T1, K extends keyof T1>(\n    getter: Prop<T1, K>,\n    setter: Assoc<T1, K>,\n): Lens<T1, T1[K]> => {\n    return {\n        get: (obj: T1) => getter(obj),\n        set: (val: T1[K], obj: T1) => setter(val, obj),\n    };\n}\n\nconst view = <T1, T2>(lens: Lens<T1, T2>, obj: T1) => lens.get(obj);\n\nconst set = <T1, K extends keyof T1>(\n    lens: Lens<T1, T1[K]>,\n    val: T1[K],\n    obj: T1\n) => lens.set(val, obj);\n```", "```js\nclass Street {\n\n    public readonly num: number;\n    public readonly name: string;\n\n    public constructor(num: number, name: string) {\n        this.num = num;\n        this.name = name;\n    }\n\n}\n\nclass Address {\n\n    public readonly city: string;\n    public readonly street: Street;\n\n    public constructor(city: string, street: Street) {\n        this.city = city;\n        this.street = street;\n    }\n\n}\n\nconst propStreet: Prop<Address, \"street\"> = (o: Address) => o.street;\n\nconst assocStreet: Assoc<Address, \"street\"> = (v: Address[\"street\"], o: Address) => {\n    return new Address(o.city, v);\n};\n\nconst streetLens = lens(propStreet, assocStreet);\n```", "```js\n\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n\nconst street = view(streetLens, address);\n\nconst address2 = set(\n    streetLens,\n    new Street(\n        address.street.num,\n        R.toUpper(address.street.name)\n    ),\n    address\n);\n```", "```js\nimport R from \"ramda\";\n\nclass Street {\n\n    public readonly num: number;\n    public readonly name: string;\n\n    public constructor(num: number, name: string) {\n        this.num = num;\n        this.name = name;\n    }\n\n}\n\nclass Address {\n\n    public readonly city: string;\n    public readonly street: Street;\n\n    public constructor(city: string, street: Street) {\n        this.city = city;\n        this.street = street;\n    }\n\n}\n\nconst streetLens = R.lensProp(\"street\");\n\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n\nconst street = R.view<Address, Street>(streetLens, address);\n\nconst address2 = R.set<Address, Street>(\n    streetLens,\n    new Street(\n        address.street.num,\n        R.toUpper(address.street.name)\n    ),\n    address\n);\n```", "```js\nclass Street {\n\n    public readonly num: number;\n    public readonly name: string;\n\n    public constructor(num: number, name: string) {\n        this.num = num;\n        this.name = name;\n    }\n\n}\n\nclass Address {\n\n    public readonly city: string;\n    public readonly street: Street;\n\n    public constructor(city: string, street: Street) {\n        this.city = city;\n        this.street = street;\n    }\n\n}\n```", "```js\nnpm install immutable\n```", "```js\nimport { Record } from \"immutable\";\n\ninterface StreetInterface {\n    num: number;\n    name: string;\n}\n\nconst StreetRecord = Record({\n    num: 0,\n    name: \"\"\n});\n\nclass Street extends StreetRecord implements StreetInterface {\n    constructor(props: StreetInterface) {\n        super(props);\n    }\n}\n```", "```js\ninterface AddressInterface {\n    city: string;\n    street: Street;\n}\n\nconst AddressRecord = Record({\n    city: \"\",\n    street: new Street({\n        num: 0,\n        name: \"\"\n    })\n});\n\nclass Address extends AddressRecord implements AddressInterface {\n    constructor(props: AddressInterface) {\n        super(props);\n    }\n}\n```", "```js\nconst address = new Address({\n    city: \"Lonson\",\n    street: new Street({\n        num: 1,\n        name: \"rathbone square\"\n    })\n});\n```", "```js\nconst street = address.get(\"street\");\nconst street2 = street.set(\"name\", \"Rathbone square\");\nconst address2 = address.set(\"street\", street2);\n\nconsole.log(\n    address.toJS(),\n    address2.toJS()\n);\n```", "```js\nnpm install immer\n```", "```js\nimport produce from \"immer\";\n\nclass Street {\n\n    public readonly num: number;\n    public readonly name: string;\n\n    public constructor(num: number, name: string) {\n        this.num = num;\n        this.name = name;\n    }\n\n}\n\nclass Address {\n\n    public readonly city: string;\n    public readonly street: Street;\n\n    public constructor(city: string, street: Street) {\n        this.city = city;\n        this.street = street;\n    }\n\n}\n\nconst address = new Address(\n    \"London\",\n    new Street(1, \"rathbone square\")\n);\n```", "```js\nconst address2 = produce(address, draftAddress => {\n    draftAddress.street.name = \"Rathbone square\";\n});\n```", "```js\nnpm install funfix @types/funfix\n```", "```js\nnpm install node-fetch @type/node-fetch @types/node\n```", "```js\nimport * as R from \"ramda\";\nimport * as fs from \"fs\";\nimport { IO } from \"funfix\";\n\nconst argsIO = IO.of(() => R.tail(R.tail(process.argv))[0]);\nconst readFile = (filename: string) => IO.of(() => fs.readFileSync(filename, \"utf8\"));\nconst stdoutWrite = (data: string) => IO.of(() => process.stdout.write(data));\n\nconst loudCat = argsIO.chain(readFile)\n     .map(R.toUpper)\n     .chain(stdoutWrite);\n\ntry {\n   loudCat.run();\n} catch(e) {\n   console.log(e);\n}\n```", "```js\nnode example.js test.txt \n```", "```js\nimport { IO, Success, Failure, Either, Left, Right } from \"funfix\";\nimport fetch from \"node-fetch\";\n\ninterface Todo {\n    userId: number;\n    id: number;\n    title: string;\n    completed: boolean;\n}\n\nconst getTodos = IO.async<Either<Error, Todo[]>>((ec, cb) => {\n   fetch(\n       \"https://jsonplaceholder.typicode.com/todos\"\n   ).then(response => {\n       return response.json().then(\n           (json: Todo[]) => cb(Success(Right(json)))\n       )\n   })\n   .catch(err => cb(Failure(Left(err))));\n});\n\nconst logTodos = getTodos.map((either) => {\n   return either.map(todos => todos.map(t => console.log(t.title)));\n});\n\nlogTodos.run();\n```"]