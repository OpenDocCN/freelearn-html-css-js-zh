- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Editing Form Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding two chapters showed how to build an HTML form to add new birthdays
    into the *Birthdays* application and how to add server-side validation for that
    form. This chapter wraps up the form implementation by adding the ability to edit
    existing birthday information.
  prefs: []
  type: TYPE_NORMAL
- en: Doing this will involve adding Svelte component state to track whether the edit
    form is in listing or editing mode.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, the server has stored data in a plain JavaScript array. We
    have been using TDD to force the simplest implementation that could possibly work.
    This chapter brings in a more complex implementation that uses a `Map` object,
    which we’ll do as part of the *Refactor* step as part of the *Red-Green-Refactor*
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning the path ahead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Playwright test for editing form data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolving the repository to allow ID lookup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the form action to handle edits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the list page with a new edit mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have seen how TDD is used to evolve system
    design when you increase the functionality of a software system.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter06/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter06/Start).
  prefs: []
  type: TYPE_NORMAL
- en: Planning the path ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started with the code, let’s do a little upfront design so we
    have a rough course of action.
  prefs: []
  type: TYPE_NORMAL
- en: The overall goal is to allow every birthday entry in the system to be modified.
    We’d like to reuse the existing `BirthdayForm` component so that it can be used
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.1* shows a diagram of how we could update the system to support
    this new feature. Each list item will have an `Birthday` component will be switched
    to a `BirthdayForm` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – A mockup of editing birthdays](img/Figure_6.1_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – A mockup of editing birthdays
  prefs: []
  type: TYPE_NORMAL
- en: While in this edit mode, it makes sense to hide the form for adding a birthday
    and also prohibit editing other birthdays, just to ensure that there’s only ever
    one active form on display.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one question remaining, and that’s how do we let the backend form action
    know that we’re editing a birthday and not adding one?
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward approach to doing this is to add a special `id` property to
    each birthday data object. This is a unique value that the server can use to identify
    each individual object. The `id` will never change and cannot be edited, whereas
    the other data items can be changed. And the user never needs to see the `id`
    value. Its purpose is simply to enable modification of existing data items.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the standard JavaScript `randomUUID` function to give us a unique
    string to create an `id` for each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.2* shows the various SvelteKit components and functions, together
    with the important bits of data that are needed to make this work, including a
    new editing state variable in the page component and the `id` field used to pick
    out the birthday for editing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Using the component state and a lookup table to implement edit
    behavior](img/Figure_6.2_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Using the component state and a lookup table to implement edit
    behavior
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, it’s worth noting that our current birthday repository holds
    its `birthday` objects in a plain JavaScript array. This is fine for listing and
    adding new items, but it’s not ideal for replacing existing items without updated
    versions. A better data structure is a `Map` object, which allows us to easily
    update items based on a key. Since we’ve already realized we need a fixed `id`
    value to represent each birthday, we already have a good choice for a key.
  prefs: []
  type: TYPE_NORMAL
- en: That covers our up front design. With a plan in place, it’s time for an end-to-end
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Playwright test for editing form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll build the latest Playwright test for our system. Because
    this test is quite long, we’ll build it bit by bit. In [*Chapter 7*](B19611_07.xhtml#_idTextAnchor093),
    *Tidying up Test Suites*, we’ll look at how this test script can be shortened.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow these steps to create the test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `tests/birthday.test.js`, begin the test with the following code, which
    loads the application, the `/birthdays` endpoint, and then completes the form
    to add a new birthday for `Ares`. We have to be careful to find the button specifically
    with the **Save** name. That’s because we’ll now have multiple buttons on the
    page: one named **Save**, and then multiple buttons named **Edit**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following command to find the `Ares`. This uses the special `getByRole(''listitem'').filter(...)`
    chain command, which finds an element with the `listitem` role (meaning the `li`
    elements) that also contains the `''Ares''` text. We then find the **Edit** button
    within that list item element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now assume that a new form has appeared for editing the birthday information
    for `Ares`. Continue the test with the following code, which replaces the `Date
    of birth` field with another value, and then click the **Save** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finish off the new test with a couple of expectations. We check that the original
    date of birth no longer appears and that the new date of birth does appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the previous Playwright tests need to be modified. Each test assumed
    that there was just one button on the page, the `find a button` and change them
    to be `find a button named Save`. Find all the lines that look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And update them to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That completes the new test. You can see we’ve already made some design decisions
    about the new **Edit** buttons and how they operate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run tests now with the `npm test` command, you’ll see the new test timeout
    waiting for the **Edit** button to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll translate that into decisions about the application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving the repository to allow ID lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s now time to update our birthday data items to include an `id` field.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a new test to check that `id` is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding this test into the `src/routes/birthdays/page.server.test.js`
    file, within the `describe` block named `/birthdays - default action`. It checks
    that each birthday has a unique `id` field associated with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass in `src/lib/server/birthdayRepository.js`. Start by adding the
    `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then update the definition of the `addNew` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run tests now, you’ll see that the test passes, but we have a new failure
    in a different part of the test suite. The `returns a fixture of two items` test
    is now erroring because of these new `id` fields. We can fix this by using the
    `expect.objectContaining` constraining function, which is useful for for saying,
    *I don’t care about anything except these properties*. It’s a useful tool for
    reducing the brittleness of tests. Update that test now to read as shown in the
    following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add this next test, which checks that if we send in a request with an `id`
    property, then we should choose to update the item matching that `id`, rather
    than adding a new birthday. Notice the use of the `storedId` function, which pulls
    out the `id` property that was saved into the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It’s now a great time to refactor our `db` value to be a `Map` object rather
    than an array, as we discussed in the previous section. Doing that refactor will
    make this new test straightforward. But we don’t *refactor* on *Red*. So, begin
    by skipping the test you just wrote and checking the test suite is *Green*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/lib/server/birthdayRepository.js`, replace `db`, `addNew`, `getAll`,
    and `clear` with this implementation that uses the `Map` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your tests after this change and make sure they are still *Green*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactoring with confidence
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the presence of your unit tests removes any fear of change when you
    completely replace the internal data structure. The tests encourage you to make
    whatever change you need without worrying about unintentional changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: All the tests should pass – fantastic!
  prefs: []
  type: TYPE_NORMAL
- en: This section has shown you another example of how we can use TDD to delay complex
    designs until the point that our unit tests force us. You’ve seen how we can migrate
    an important variable from an array to a `Map` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s get on with building the edit feature.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the form action to handle edits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll continue with updating the repository to handle updating
    birthdays in addition to adding new ones. We’ll tackle this in three parts: first,
    replacing items in the `db` field, second, guarding against invalid `id` values,
    and third, ensuring that `id` values are passed back in validation errors so that
    the same birthday can be corrected by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing items in the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started with the test you wrote in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Un-skip the last test you wrote in the `src/routes/birthdays/page.server.test.js`
    file. Make sure to run the tests and watch it fail, ensuring you’re on *Red*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that test pass, start by adding a `replace` function to `src/lib/server/birthdayRepository.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, import that new function into `src/routes/birthdays/+page.server.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `actions` constant, first by pulling out `id` from the request,
    and then using that `id` value to switch behavior. If `id` is present, then call
    the `replace` function; otherwise, call the `addNew` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Re run your tests; you should now be on *Green*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s ensure that only valid `id` values are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting against unknown identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final validation we need is to make sure that we don’t try to update items
    in the repository that don’t exist. Let’s begin with a new test context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in `src/routes/birthdays/page.server.test.js`, add a new nested `describe`
    block to the *validation errors* context, as shown in the following code. I’ve
    skipped ahead and included *three* tests here since we’ve solved these kinds of
    tests before, and we can feel confident about solving them at the same time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, start by adding a new `has` function to `src/lib/server/birthdayRepository.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then import that into `src/routes/birthdays/+page.server.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And finally, make use of it by adding a new guard clause.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re almost done with the form action validations, but there’s one more thing
    we need to do.
  prefs: []
  type: TYPE_NORMAL
- en: Updating return values to include identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a validation error occurs, such as when the `name` field is empty, we need
    to ensure the `id` form value is included in the return error value. That ensures
    that back in the web browser, the correct edit form can be reopened to allow the
    user to correct their edits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we launch into the code changes, let’s discuss the strategy. This is
    how the application code will end up looking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you make that change, however, think about how you’ll test this. We
    already have a test that checks the contents of the return value, so one option
    is to go back and edit this test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: But don’t do this.
  prefs: []
  type: TYPE_NORMAL
- en: I find that editing previous tests is generally a bad idea. The reason for that
    is it can produce tests that end up specifying invalid scenarios that can never
    happen. The preceding example is indeed an invalid scenario. That’s because there’s
    no birthday in the system with an `id` value of `123`. To make it valid, we’d
    need new test setup instructions that create the birthday with the `id` value
    of `123` to ensure the `id` value is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we do that, then we have no test for the original scenario of adding
    a birthday! Instead, let’s create new tests that cover each of the two use cases
    that can happen: an invalid name or an invalid date of birth when a birthday is
    being edited.'
  prefs: []
  type: TYPE_NORMAL
- en: Scenario-based testing
  prefs: []
  type: TYPE_NORMAL
- en: When you’re writing unit tests, always make sure your tests cover valid scenarios.
    If you’re following TDD, that generally means always adding new tests rather than
    going back to modify existing tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by adding a new nested context inside the `validation` `errors`
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `describe` context with its associated `beforeEach` block,
    which adds a birthday into the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the first test into the context. It attempts to edit the created birthday
    but has an empty name. The expectation checks that the same `id` value is passed
    back in the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, include the `id` property in the relevant guard clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a test for an invalid date of birth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, update the second guard clause, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the changes to the form action.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to your tests
  prefs: []
  type: TYPE_NORMAL
- en: It’s very important to listen to your tests. If they are a slog to write and
    update, that’s a sign that either the tests can be improved or the application
    code design can be improved.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B19611_09.xhtml#_idTextAnchor111), *Extracting Logic Out of
    the Framework*, we’ll move validation into the birthday repository, and this will
    give us a chance to rethink how these tests are structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has covered a whole bunch of changes: adding repository functionality
    for replacing items, updating the form action to either add or replace items,
    adding another guard clause to protect against invalid replacements, and finally,
    updating the existing guard clauses to return the `id` value.'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to update the page component to display `BirthdayForm` in edit
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the list page with a new edit mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll update the page so that it can toggle into an edit mode
    for a given birthday. That relies on having a hidden form field for the `id` value.
  prefs: []
  type: TYPE_NORMAL
- en: Testing hidden fields
  prefs: []
  type: TYPE_NORMAL
- en: Testing Library doesn’t give us an easy way to query the `hidden` input fields
    because it generally concerns itself with what is visible to the user, and our
    `id` field is purposefully designed to be an internal system detail.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can fall back to the standard **Document Object Model** (**DOM**)
    Form API to figure this out.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of writing unit tests for frameworks such as SvelteKit means that
    sometimes you’re checking for internal details like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a new test in a new nested `describe` block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/routes/birthdays/BirthdayForm.test.js` file, and within the `BirthdayForm`
    root in the `describe` block, add this new nested `describe` block and test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, update the `BirthdayForm` component (in `src/routes/birthdays/BirthdayForm.svelte`)
    to include a new hidden field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how we need optional chaining (with `form?`) to ensure our existing
    tests, with no `form` prop, continue to work. However, this presents a problem:
    what is the value of the `id` field if we’re not editing but creating? We need
    another test, which you can add to the same `describe` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, pull up the optional chain into a conditional that wraps
    the hidden `input` element in the `BirthdayForm` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Okay, that’s it for the `BirthdayForm` component itself. Now what about the
    page component?
  prefs: []
  type: TYPE_NORMAL
- en: Adding a toggle mode to the page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll introduce a component state variable named `editing`
    that allows us to toggle between *create* and *update* mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by displaying the **Edit** buttons for each of the birthdays listed
    on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/routes/birthdays/page.test.js`, add the following test. Remember that
    the repository has, by default, two items, so this test allows us to test that
    *both* have an **Edit** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, in `/src/routes/birthdays/+page.svelte`, update each `li`
    element to contain a new `button` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, what happens when we click that button? Let’s add a set of tests for
    checking the behavior when the `beforeEach` function that we’re going to use to
    pull out some common setup for each of our tests. The second is for the `click`
    function, which will be used to simulate a DOM click event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add this new nested `describe` block and test. The `beforeEach` function
    is used to pull out the *Arrange* portion of the test to avoid having to repeat
    it in each of the subsequent tests. This code also makes use of a helper function
    named `firstEditButton` that keeps the tests readable and short:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, start by introducing a new component state variable named
    `editing` into the page component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the `editing` to the specific `birthday` object, which is given to us
    by the `each` construct. We can then wrap the original `Birthday` component in
    a conditional; if `editing` is equal to the current `birthday` object, then don’t
    show `Birthday`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we also want to hide the original form for adding the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, wrap the last bit of the page component in `if`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But hang on a second! We’re now defining behavior on a static element that
    we’ve never tested before: the heading. The `Add a new birthday` text was something
    we didn’t bother testing. But now that it’s an integral part of our test suite,
    surely we should have a test to prove that it’s initially there? (Otherwise, the
    most straightforward way to get the last test to *Green* would have been to delete
    the heading.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, do that now. Go ahead and delete it and watch your test suite happily
    pass. To bring it back in, we need a failing test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this new test right at the top of the test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Watch the test fail, and then go ahead and undelete the heading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Onto the next test. This time, let’s check that `BirthdayForm` is shown. We
    can do that by looking for a `Name` field that has the existing name in there
    (in this case, that’s `Hercules`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, flesh out the `if` conditional block with a new `:else`
    block. Notice the order of proceedings swaps around here: if `editing` is equal
    to `birthday`, then display `BirthdayForm`; otherwise, display `Birthday`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have a **Save** button on the page, shouldn’t we hide all the **Edit**
    buttons? Yes, let’s do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, introduce another `if` block around the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There’s one final test left. This is an important one. It checks that if SvelteKit
    passes us back a `form` object with an `id` value, then we need to immediately
    start in *edit* mode for that birthday. Since the `id` value is important here,
    this test includes its own `data` and `form` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using factory methods to shorten tests
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B19611_07.xhtml#_idTextAnchor093), *Tidying up Test Suites*,
    you’ll create a factory method for birthdays that will shorten this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests allude to the fact that the initial value of `editing` depends on
    `form`. So, update that now to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, because we’re dealing with different objects, we can no longer use equality
    based on object identity to match the currently edited birthday. So, update the
    first `if` to be the one shown in the following code, which checks `id` rather
    than the whole object itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, because of this new reliance on the `id` field, you’ll find other tests
    breaking. Update the `birthdays` array to include the `id` values like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this point, your tests should pass, including your Playwright test.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.3* shows what the application looks like if you fire up the dev
    server (with the `npm run dev` command) and try to replace an existing birthday
    with an invalid date:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – A validation error when editing a birthday](img/Figure_6.3_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – A validation error when editing a birthday
  prefs: []
  type: TYPE_NORMAL
- en: This section has shown you how you can use the Svelte component state to switch
    between add and edit modes of a form and how you can test-drive those modifications
    in both the form component and the page component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has demonstrated how the TDD process works once you have a substantial
    amount of code in place. In addition, you have seen how we can build feature upon
    feature using the same *Red-Green-Refactor* workflow that you learned about in
    [*Chapter 2*](B19611_02.xhtml#_idTextAnchor036), *Introducing the Red-Green-Refactor
    Workflow*: first, by refactoring the store implementation, and then by introducing
    Svelte component state.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll stop to look at some of the ways we can simplify
    the current code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Refactoring Tests and Application Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve learned about and practiced the test-driven development workflow,
    it’s time to focus on practices and strategies that will keep your automated tests
    and application code neat and tidy. The chapters in this part will provide you
    with guidance on creating elegant and maintainable automated test suites.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19611_07.xhtml#_idTextAnchor093), *Tidying up Test Suites*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19611_08.xhtml#_idTextAnchor100), *Creating Matchers to Simplify
    Tests*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19611_09.xhtml#_idTextAnchor111), *Extracting Logic Out of the
    Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19611_10.xhtml#_idTextAnchor119), *Test-Driving API Endpoints*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19611_11.xhtml#_idTextAnchor127), *Replacing Behavior with
    a Side-By-Side Implementation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19611_12.xhtml#_idTextAnchor134), *Using Component Mocks to
    Clarify Tests*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19611_13.xhtml#_idTextAnchor148), *Adding Cucumber Tests*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
