- en: Chapter 5. Practical – a CMS Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we explored the more theoretical side of application architecture
    as well as the cast of tools we'll use to support us. We've reviewed design patterns,
    methods of structuring our application. Now, it's time to understand how these
    can fit together to create a well-structured application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll create a basic user interface for a **content management
    system** (**CMS**). While many businesses will work with an off-the-shelf CMS
    (such as Joomla! or Drupal), the vastly varying requirements from business-to-business
    means that a bespoke content management system is a fairly common project.
  prefs: []
  type: TYPE_NORMAL
- en: It's also a deceptively-complicated proposition. With such a range of business-specific
    requirements, the basic CMS can quickly become a complex application with modules
    and interface elements that are tailored for the problem at hand. This makes it
    even more important that the basics are taken care of, for example, code structure
    and naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In reflection of this, we''ll only be creating a basic starter-level CMS. We''ll
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a data structure and the corresponding Ext JS model and store implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a full class structure and mapping the interactions between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sketching out pseudocode for some more complex interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fleshing out our design into a full implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is also the general pattern that the next few chapters will take. In this
    particular chapter, our application will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: A hierarchical treeview of website structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A form panel showing page detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A create, update, read, and delete functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we'll have put our knowledge to test in a basic real-world
    application using Ext JS 5's MVVM architecture to structure our code in a way
    that's clean and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: A content-managed system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to be producing a bare-bone, but usable implementation of a CMS,
    which uses some of the Ext JS architectural concepts we''ve already touched on,
    such as view models and view controllers, event listeners, and data binding. Here''s
    a look at the desired final product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A content-managed system](img/5308OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Architecture CMS: our first example application'
  prefs: []
  type: TYPE_NORMAL
- en: Long before we get to this point, we need to go through the requirements for
    the application, design its various application layers, and come up with a design.
    Only then can we start talking about the code level. Let's get started with checking
    out our client's request.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We receive two documents as our project brief from the client: a wireframe
    and a set of criteria to meet. A wireframe is the layout of our application in
    broad strokes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The requirements](img/5308OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wireframe graphic for "Architecture CMS"
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately, we know that this is a very simple single-page application with
    a tree view, editor panel, and a search bar. The criterion fleshes out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: REST backend API provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The treeview to show all pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search that will highlight the matching page in the treeview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The required HTML editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URLs that must be customizable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages that can be published or unpublished
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User must be able to create, view, update, and delete pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's assess these criteria in terms of Ext JS. Firstly, we know that REST support
    is available in Ext JS via `Ext.data.proxy.Rest`, which we can use through our
    models and stores. However, note that the second point requires a tree view representing
    the hierarchical structure. While Ext JS provides a `TreePanel` component and
    there's a dedicated `TreeStore` to handle hierarchical data, there may be a possibility
    that loading this kind of nested data via a REST API could have some complications.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we could consult with our team and even write some prototype
    code to investigate this REST issue before getting fully underway with development.
    It's important to resolve any uncertainty before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: With this cleared up, we now look at the requirement for search. We know that
    `Ext.data.NodeInterface`, the class that powers nodes in a `TreePanel`, has a
    `findChildBy` method that allows you to traverse a tree from the root and perform
    an arbitrary action when we find what we need.
  prefs: []
  type: TYPE_NORMAL
- en: The customer specified that an HTML editor is required, which is fine as Ext
    JS ships with a well-featured WYSIWYG HTML editor in `Ext.form.field.HtmlEditor`.
    For the URL customization, we don't have to do anything special other than be
    aware that the client has asked for this field to be included when editing; likewise
    the same with the published/unpublished flag.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we know the operations that the customer would like to perform on pages,
    which dictates how our application will interact with the existing backend. Given
    the REST API available to us, supporting the required **create, read, update,
    and delete** (**CRUD**) actions should be trivial with an implementation of `Ext.data.Model`.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting the challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've reviewed the client's criteria against the tools available to us, we
    can confidently accept the challenge laid down for us. Without performing due
    diligence on customer requirements, we could begin a project without being 100
    percent certain of whether we could complete it, potentially risking the success
    of the project and costing valuable time and money.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at the bottom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client stated that we have a REST API available to us. In fact, they have
    other Ext JS applications to be built on top of this API and so we''re lucky.
    The data is returned as JSON that can be easily consumed by `Ext.data`. The customer
    provided documentation on how the API operates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At this point, your developers will be dancing a little jig because not only
    do you have documentation, but also the API is very straightforward supports only
    a few operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our part of the data implementation becomes easy now. We know that we want
    to implement a treeview. The data coming back from `/pages` is already formatted
    correctly for this with an array of children and both ID and text properties.
    We only need one model to represent a page, so it''ll look something like this
    in pseudo-UML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll have a super simple store to collect these models together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There's no custom logic hanging off the store so that's literally our full definition,
    although we know that our implementation will be configured to use our `ArchitectureCms.model.Page`.
  prefs: []
  type: TYPE_NORMAL
- en: The data layer is the one through which everything will be built on. Although
    our design for this layer is super simple for this application, it's worth writing
    it in case we see any glaring issues. We can now look at how these data classes
    will interact with the user interface and glue classes in the rest of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Work your way up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Controllers are the glue that binds your application together; it''s often
    useful to look at our wireframe again and break down the aspects that represent
    view classes and will need a controller to orchestrate their actions. The basic
    wireframe can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Work your way up](img/5308OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The wireframe broken down: yellow, green, and blue are all identified as separate
    views'
  prefs: []
  type: TYPE_NORMAL
- en: In this application, as we have a very straightforward layout and set of interactions
    between components, we can get away with a very simple architecture.
  prefs: []
  type: TYPE_NORMAL
- en: While it's important to create a strong starting structure in the early days
    of an application, you should always strive to build something that is clearly
    designed and doesn't contain classes that have been added just in case they are
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**You Aren''t Going To Need it** (**YAGNI**) is a popular term with some software
    developers who believe that less is more—don''t write code based on some far-future
    assumption about what you might need. Instead, iterate on your architecture with
    every addition and take as much care with these additions as you would at the
    start of a project.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Ext JS MVVM architecture, a top-level controller is used to mediate interactions
    between other controllers. Here, we've elected to create just one controller (a
    view controller called `Main`) that will coordinate all of the actions of the
    views within its namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how these new classes will look when working together
    and in association with our data layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Work your way up](img/5308OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram clearly shows how data flows through our application
    (from the data layer that interfaces with the client''s API to controllers and
    then down to views via view models). We can now flesh out each of these classes
    by naming them and specifying their methods and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's break this down a bit and talk about the reasons we've designed the application
    in this way.
  prefs: []
  type: TYPE_NORMAL
- en: The devil is in the detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's immediately clear that the controller is where most of the interesting
    stuff is happening, but it's important to remember to keep your controllers slim.
    If you find yourself with lots of methods in there, it's a good sign you need
    another controller—look for the logical place one might split off.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, a future iteration of the application might have separate view
    controllers for the tree and for the detail panel with an overarching controller
    to enable communication between the two. For now though, we just don't need this.
    All we have in our `MainController` class is four methods that will handle actions
    from our views.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Controllers are there to support everything else. Focus on your data first,
    then your views, and use the controllers to connect them. As such, work out which
    events your views are going to fire and your controller will pretty much write
    itself—all it'll be doing is handling these events and passing off the hard work
    somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great opportunity to put implementation details to one side for a
    moment and think about how these classes would look if they were designed to make
    our life easy.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the view model called `PageModel` has a method called `isUnsavedPage`,
    which allows you to ensure that the user doesn't navigate away before they save
    a new page, ensuring they won't lose any data.
  prefs: []
  type: TYPE_NORMAL
- en: Designing like this up front enables us to think about all of the great features
    that make for a good user experience without having to get worked up about the
    code that will make it happen. Of course, every situation is different. We need
    to make sure that we don't let our imagination run away with itself and start
    dreaming up features that aren't required!
  prefs: []
  type: TYPE_NORMAL
- en: There's a short discussion to be had with regard to the `searchFor` method on
    the `Tree` class. In controllers, we pull together a few parts of our application
    and hand off the real work to them, not to the controller itself. That's exactly
    what we're doing here. Think of this method in the same way you would use the
    `expandPath` method on the `Ext.tree.Panel` base—a method that acts on the tree
    interface without breaking out and interacting with anything else. Its logical
    place is as an augmentation to the tree UI.
  prefs: []
  type: TYPE_NORMAL
- en: Where the wild things are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have our design, so let''s step a little closer and examine the parts of
    the application where a little more detail may be required. For example, we have
    a controller method called `onAddClick` that will be handling the process of adding
    a new record, but what will this actually entail and are there any pain points
    hidden within? Here''s what needs to happen when this handler is done with its
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the user for a name for the new page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new blank record with default values and the page name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the page as a child node of the current page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load the record in the detail panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the new record in the tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s a lot for a single controller action. Let''s look at how we might code
    it to see whether we''re trying to do too much. We''ll write some pseudocode (fake
    code) to drill down into some detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's no JavaScript here, no Ext JS classes in use. We're just writing the
    code we wish we could write if there weren't any language or framework constraints.
    Given that, this code looks good—it's clear what's happening and we're not doing
    too much.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice is that `Ext.panel.Tree` doesn't have a native `addAndSelect`
    method. We'll need to write this, but if it makes our controller code cleaner
    and shorter, then that's a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Spiky and hairy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a truism in software development that code is harder to read than it's
    to write. Comprehending someone else's code without having the reasoning behind
    it can be difficult. Having said that, there's a difference between code that's
    a little hairy, a little scary—something that doesn't shout out its intent via
    comments, variable naming or method naming, and code that shows consideration
    for future maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: In writing pseudocode, we're trying to ensure that the concepts behind our code
    are well fleshed out beforehand and that any difficulties are taken care of before
    we really start work on our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In complex cases, pseudocode won''t go far enough. We''ll have to write some
    real code in the form of a spike. In *Kent Beck''s Guide to Better Smalltalk:
    A Sorted Collection*, *SIGS*, he talks a bit about this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Sometimes I call this a "spike", because we are driving a spike through the
    entire design. […] Because people variously associate "spike" with volleyball,
    railroads, or dogs, I have begun using "architectural prototype" to describe this
    implementation."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When creating a spike, we're pushing through any assumptions we have and testing
    our design decision on a tiny prototype (the smallest code snippet or application
    we can build to prove our idea).
  prefs: []
  type: TYPE_NORMAL
- en: This firms up our design by eliminating further unknowns. We can be sure that
    a UI component will support the feature we require because we've actually tested
    it in a practical example. If it's an architectural code spike, we can see whether
    the various elements of our design hang together in a way that "feels right",
    if it works within the framework being used, and the design patterns that have
    been chosen.
  prefs: []
  type: TYPE_NORMAL
- en: We can perform a spike on the `addAndSelect` method described previously, but
    we know that `Ext.tree.Panel` already has an `add` method and that the underlying
    `selectionModel` will allow us to mark a node as selected. Therefore, now that
    we have alleviated our concerns with pseudocode, there's no need to continue on
    to real code until we implement the real deal. As developers working under constraints
    of time and money, we need to be pragmatic, as long as we are certain that due
    diligence has been performed.
  prefs: []
  type: TYPE_NORMAL
- en: The real deal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've designed the data layer and the UI layer, the glue that dictates how the
    two interact, and tackled the remaining bits of the client requirements that look
    like they may cause trouble. We're in good shape to start putting our fingers
    on the keyboard in our favorite text editor and show how the design can be implemented
    in Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: A short interlude on data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the introduction of view models in Ext JS, the concept of data binding
    has also been brought to prominence. In short, data binding binds one value to
    another value. When the first changes, the second updates automatically. Two-way
    data binding means that when either value changes, the other updates accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: On the whole, Ext JS has implemented this idea via view models. A UI component
    may have its title bound to a value and when this value is updated by another
    part of the application, the title automatically changes. This removes the need
    for the developer to wire up change events and ensures that data will be consistent
    across an application.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use data binding heavily in this example application and across
    all our practical chapters. In many cases, a little bit of binding configuration
    can remove a lot of boilerplate event wiring, so we're going to take advantage
    of it where we can.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using our knowledge from previous chapters, we''ll create an application skeleton
    using Sencha Cmd and use it as a basis for our work. We''re familiar with this
    by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With a simple command, we''re up and running with a template. Let''s fire up
    a web server and look for changes in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now launch a web browser and navigate to `http://localhost:1841` to
    see the template in action. We don''t want any of the example code that''s been
    generated. So, we can remove it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we've got a clean directory structure on which we can build our content
    management system.
  prefs: []
  type: TYPE_NORMAL
- en: Data-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same way that we designed our application by looking at the data layer
    first, we''ll write the Ext JS model and store code first. Here''s the model,
    which we''ll build bit-by-bit to explain the thought process behind the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's look back at our design for this class. We're defining the same fields
    we laid out there with the exception of the children field, which is a special
    case as we're using `Ext.data.TreeModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this isn''t enough to drive a real-world Ext JS model. This is where
    the design now differs from the implementation. Let''s connect the model to the
    client''s API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Woah! The design is mostly language agnostic, but the implementation now shows
    off configuration options that are very Ext JS-specific. There are two ways of
    configuring a model. One way to configure is via its proxy and another is via
    its schema. The proxy configuration works just fine, but in larger applications,
    the schema can be shared between models and provides a central place to configure
    the base API URL and the path to fetch for a particular model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, we''re going to start off using schema even though we''re
    only dealing with a single model in this application. Let''s look at the various
    configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`namespace`: This is the segment of the model''s class name that represents
    the namespace. This means that Ext JS can remove the namespace part of the full
    class name and be left with nothing but the model, which it can then use to automatically
    build URLs. In this case, we set the namespace as `ArchitectureCms.model`, which
    allows Ext JS to work out that the model name is just `Page`. We''ll use this
    later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urlPrefix`: This is generally the hostname or the API endpoint to use in combination
    with the path to the specific resource being consumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy.type`: This is the type of proxy, which when dealing with the server
    will likely be `ajax` or `rest`. We know that our customer has a REST API, so
    it''s set to `rest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy.url`: This uses all the preceding options to build a URL. The segments
    in curly brackets will be replaced in order to build a full URL to the resource
    being consumed. `{prefix}` is the `urlPrefix` from above, `{entityName:uncapitalize}`
    is the model''s name parsed from the class name without the namespace in lower
    case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phew! At this point, we've done a pretty deep dive into Ext JS configuration
    options. This chapter, and indeed this book, is supposed to be about architecture.
    So from now on, there will be some cases where we'll skip over this kind of detail
    on the assumption that you've worked with Ext JS before and understand these configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re trying to design this application; we''re not trying to teach JavaScript
    or Ext JS. Although, we''ll look at aspects of the Ext JS framework that contribute
    to a successful application, we''re not going to regurgitate the Sencha documentation.
    With this in mind, let''s add a little bit more to our model and talk about how
    it helps us meet the customer requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is the final iteration of the `Page` class, now with an identifier configured.
    We know that we need to differentiate between a saved and an unsaved model, and
    we know that the server will return `clientId` if it's supplied, so here we explicitly
    state that it's going to have the `Unsaved-` string in the ID until the server
    supplies an auto-incremented identifier to replaced it on save.
  prefs: []
  type: TYPE_NORMAL
- en: A model store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The store for this application is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Everything here is self-explanatory, although there is a caveat. With the current
    version of Ext JS (5.0.1), we need to set an empty root node that allows you to
    use data binding to bind this store to a UI component. If we don't, an error will
    be thrown, so this is a simple workaround.
  prefs: []
  type: TYPE_NORMAL
- en: A room with a view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned that it was a good idea to design your application (starting with
    the data layer and then moving to the views) so that it's easier to understand
    the interactions that your controllers will have to deal with. When moving from
    the design to the code, the same applies, so we will write the user interface
    for this application and then later wire it up to the data via controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, we need a viewport. We only have one page in the CMS, so the viewport
    is the container for all of the individual subviews (such as the tree and the
    detail panel). This application is fairly focused, so we''re going to put all
    our views and associated classes under the `ArchitectureCms.view.main.* namespace`.
    Here''s the code for our `ArchictureCms.view.main.Main` viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is mostly straightforward (we extend `Ext.Panel` rather than `Ext.Container`
    to give us support for a title bar). Next up, we require the view classes we're
    going to use in the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: The `session` option is set to `true`. We'll discuss this in more detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The view controller and view model are specified by their aliases; we'll create
    these classes later. Sencha Cmd knows that these are "auto-dependencies", so we
    will automatically require them without having to include them in the `requires`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a default title, namely, `Architect CMS`, but in the next line, we
    have our first use of the `bind` option. Let''s break down what''s happening here.
    We''ve already specified a view model for this class and always have to bind to
    a value in a view model. Not only this, the `bind` option is only triggered when
    the view model value changes, which is why we need to specify a default value
    via the title configuration. For the bind configuration, we specify the values
    we want to bind against (in this case title) and then provide a binding expression.
    Here, it''s just a string. The segment in curly brackets determines the value
    on the view model to bind to. Later, we''ll look at `currentPage.text` and see
    how this gets set, but it will suffice for now to realize that when this value
    changes; it gets incorporated into the value for title. We''ll see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A room with a view](img/5308OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that this will happen without having to wire up any event handlers. It's
    a little sprinkle of magic that reduces the boilerplate code we have to write.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we specify a border layout and then fill the items array with the tree
    and detail panel, referencing them by their `xtype`. Thanks to our configuration
    of the `requires` option, Ext JS is already aware of these classes, so we can
    use the aliases as shorthand.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the binding configuration and a bit of auto-requiring magic, there's
    nothing special happening here. The key, in terms of application design, is the
    introduction of the binding concept in association with view models and view controllers.
    Hopefully, we've shown how these ideas can be introduced with barely any additional
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The tree panel and searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve got our viewport container, we can introduce the views themselves.
    First, we''ll look at the code for the tree that shows the page hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: More binding expressions! One important thing to realize is that a view model
    declared on a high-level component, in this case our `ArchitectureCms.view.main.Main`
    viewport, will cascade down and become available to child components. This means
    that our binding expressions in the tree will refer to the `Page` view model we
    assigned to the main viewport. What customer requirement are we trying to fulfill
    by using binding in the tree?
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to be able to search for a page and have it highlighted in the tree.
    To do so, when we type in `textfield`, the value has to be passed to the tree.
    A traditional way of doing this would be to listen for a change event or `keypress`
    on `textfield`, then trigger a `search` method on the tree. Rather than doing
    this manually, we can use data binding via a view model to achieve the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The tree panel and searching](img/5308OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data flows between UI components through the view model
  prefs: []
  type: TYPE_NORMAL
- en: The `searchTerm` value on the view model can flow back and forth between the
    `searchFor` config on the tree and the value on `textfield`. However, in this
    case, it's only one direction (from `textfield` down to the tree).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we tell the tree to bind to the pages value on the view model;
    we know we're going to need a list of pages from somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The missing piece in this puzzle is the part that actually does the searching
    on the tree. Thanks to the Ext JS configuration system, any `config` option that
    is specified also creates an `applyConfigName` method on the class instance and
    this is called every time the `config` option changes. This means that by creating
    `applySearchFor` on the tree, every time `searchFor` updates via its binding,
    we can run a piece of code to do something with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we put a function placeholder in the last code snippet (the `Ext.emptyFn`
    part). Here''s the actual code we''re going to use here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In brief, use a regular expression to do a case-insensitive match on the search
    term against the text of each tree node. If a match is found, expand the tree
    to this point and call its `highlight` method to produce a visual cue.
  prefs: []
  type: TYPE_NORMAL
- en: Pages in detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tree is used to browse the hierarchy of trees in the CMS, so we now need
    a way to look at the detail of each page. The detail pane is a panel containing
    a number of form fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each of the form fields has a binding expression, which ties the field value
    to a value on the `currentPage` object of the view model. When the user changes
    the field, the view model will automatically get updated. Note that we don't have
    to specifically state the property to bind to because form fields have their `defaultBindProperty`
    set to `value`.
  prefs: []
  type: TYPE_NORMAL
- en: The whole form panel has its hidden value bound to `currentPage`, so if this
    value is not set, the panel will be hidden. This allows you to hide the form when
    no page is selected. We've also got a warning message as the first item in the
    panel, which will be hidden when the view model's `isUnsavedPage` value changes
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: We've only written a little bit of code outside the UI configuration, yet with
    the addition of the view model, we'll already have a populated tree panel with
    search tied to a detail panel. Next, we'll look at the view model code itself.
  prefs: []
  type: TYPE_NORMAL
- en: The magical page view model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This view model uses a simple formula to provide a calculated value to the
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Considering the functionality that this class enables, that's very little code.
    The store definition is fairly self-explanatory, just using the `ArchitectureCms.store.Pages`
    alias to specify that the view model has a page value powered by this store.
  prefs: []
  type: TYPE_NORMAL
- en: The formulas definition is a little more interesting. It's a way of declaring
    that a value will be returned based on other values in the view model. In this
    case, as we specified on our model that newly created records would use a prefix
    of `Unsaved-`, we can look for this to determine whether the record's been saved
    to the server or not. So, `isUnsavedPage` returns `true` or `false` depending
    on whether the record's ID contains this prefix or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only missing thing here is the `currentPage` value. We can set arbitrary
    values on the view model. So, this gets set elsewhere in the controller. Before
    we talk about this, let''s jump back to discuss a new concept in Ext JS 5: `Ext.data.Session`.'
  prefs: []
  type: TYPE_NORMAL
- en: This data is now in session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `Ext.data.Session` is a way of centralizing data in an application, ensuring
    that stores are working with the same set of data without having redundant reloading.
    It also allows much easier batched updates and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we set `session`, set to `true` on our top-level viewport,
    which tells Ext JS to automatically create a session and make it available to
    any other code that requests it. This is the simplest way of constructing a session,
    although there's a lot more customization that we can do if need be.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we use a session in this application is to allow us to link the data
    that the tree and the detail panel uses. This helps with data binding too; we
    can use exactly the same model instance in the tree and the detail panel, which
    means that updates made in the detail panel will flow through the view model and
    into the correct page instance in the tree. In a moment, when we look at our view
    controller, we'll use the session a little more and get a glimpse of how it can
    help manage your data.
  prefs: []
  type: TYPE_NORMAL
- en: The glue controlling all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In previous chapters, we''ve looked at how the controller can use event domains
    to hook into anything interesting happening elsewhere in the application. Here,
    we use the same approach, which we discussed previously, and get the controller
    to hook up a bunch of event handlers to deal with user actions in the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This view controller handles the following four events:'
  prefs: []
  type: TYPE_NORMAL
- en: The `select` event on the tree handled by the `onPageSelect` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `click` event on the detail panel's save button handled by `onSaveClick`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `click` event on the detail panel's add child button handled by `onAddChildClick`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `click` event on the detail panel's delete button handled by `onDeleteClick`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of this will be self-explanatory, some relates to data binding, and some
    relates to the session. Let's break down the important parts.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the tree fires a `select` event, the view controller's `onPageSelect` method
    gets passed the model for the selected tree node. We mentioned earlier that we
    can set arbitrary values on the view model, specifically the `currentPage` value,
    and so this is what we do here, but with a twist.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than just setting the data, we give Ext JS a hint that we want to set
    a model instance by using the links configuration. By supplying the name of the
    model class and its ID, Ext JS will use the matching instance if it's already
    available in the current `Ext.data.Session` or it'll automatically load it from
    the server. It's a handy shortcut for reducing the number of requests to the backend
    API and another example of how to use a session.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The view controller listens for events on a button with an item ID of `#addChild`.
    When it fires, we ask the user for the name of the new page, and the next step
    is to actually create a page record. Rather than using `Ext.create`, we call `createRecord`
    on the current `Ext.data.Session`, which allows you to continue to make Ext JS
    aware of the records we're managing. It also allows you to maintain a global understanding
    of the saved and unsaved records. This would be even more useful in an application
    where we need to do batch updates of records.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a model instance, we follow the pseudocode we wrote earlier in
    the chapter, but tie it to actual Ext JS methods and add the page to the tree
    data structure before selecting it in the tree UI itself.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is fairly straightforward (handle the `click` event from the `#delete`
    button and then grab the `currentPage` from the view model). We also remove the
    leftover page from the view model so that the detail panel automatically clears
    itself, rather than leaving a dead record available to edit. We display a notification
    to the user with `Ext.toast`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving a page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is even simpler (handling a click on the #save button, grabbing the `currentPage`
    from the view model, and then calling its `save` method). There''s nothing special
    happening here. The only thing to note is that if this is a new record, the server
    will respond with a new ID and replace the one that Ext JS automatically allocated.
    Thanks to the binding to `isUnsavedPage` on the view model, this will cause the
    "unsaved" message to disappear from the detail panel.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our first practical application, we've taken the theoretical ideas discussed
    in previous chapters and shown how they apply to the creation of a useful code
    base. From analysis to what the customer really needs to see, whether we can fulfill
    their request to sketching out designs, and undertaking short code spikes down
    to applying the MVVM pattern via view models and their supporting infrastructure,
    we've built an application brain-first rather than code-first.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll create a more complicated real-world application,
    but this time, we won't have to discuss the basics of data binding in so much
    detail. We'll apply our growing knowledge to build a more complex app, a log analyzer,
    which could be used by a system administrator to monitor their infrastructure.
    This will require more thought about how to design the various moving parts that
    will make up our second application.
  prefs: []
  type: TYPE_NORMAL
