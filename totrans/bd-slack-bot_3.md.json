["```js\n'use strict';\n\nconst RtmClient = require('@slack/client').RtmClient;\nconst MemoryDataStore = require('@slack/client').MemoryDataStore;\nconst CLIENT_EVENTS = require('@slack/client').CLIENT_EVENTS;\nconst RTM_EVENTS = require('@slack/client').RTM_EVENTS;\n\nclass Bot {\n  constructor(opts) {\n    let slackToken = opts.token;\n    let autoReconnect = opts.autoReconnect || true;\n    let autoMark = opts.autoMark || true;\n\n    this.slack = new RtmClient(slackToken, { \n      // Sets the level of logging we require\n      logLevel: 'error', \n      // Initialize a data store for our client, \n      // this will load additional helper\n      // functions for the storing and retrieval of data\n      dataStore: new MemoryDataStore(),\n      // Boolean indicating whether Slack should automatically \n      // reconnect after an error response\n      autoReconnect: autoReconnect,\n      // Boolean indicating whether each message should be marked\n      // as read or not after it is processed\n      autoMark: autoMark\n    });\n\n    this.slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () => {\n      let user = this.slack.dataStore.getUserById(this.slack.activeUserId)\n      let team = this.slack.dataStore.getTeamById(this.slack.activeTeamId);\n\n      this.name = user.name;\n\n      console.log(`Connected to ${team.name} as ${user.name}`);      \n    });\n\n    this.slack.start();\n  }\n}\n\n// Export the Bot class, which will be imported when 'require' is \n// used\nmodule.exports = Bot;\n```", "```js\nconstructor(opts) {\n    let slackToken = opts.token;\n    let autoReconnect = opts.autoReconnect || true;\n    let autoMark = opts.autoMark || true;\n\n    this.slack = new RtmClient(slackToken, { \n      logLevel: 'error', \n      dataStore: new MemoryDataStore(),\n      autoReconnect: autoReconnect,\n      autoMark: autoMark\n    });\n\n    this.slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () => {\n      let user = this.slack.dataStore.getUserById(this.slack.activeUserId)\n      let team = this.slack.dataStore.getTeamById(this.slack.activeTeamId);\n\n      this.name = user.name;\n\n      console.log(`Connected to ${team.name} as ${user.name}`);      \n    });\n\n    this.slack.start();\n  }\n```", "```js\nmodule.exports = Bot;\n```", "```js\n'use strict';\n\nlet Bot = require('./Bot');\n\nconst bot = new Bot({\n  token: process.env.SLACK_TOKEN,\n  autoReconnect: true,\n  autoMark: true\n});\n```", "```js\nSLACK_TOKEN=[YOUR_TOKEN_HERE] node index.js\n\n```", "```js\nif (/(hello|hi) (bot|awesomebot)/g.test(msg)) {\n  // do stuff...\n}\n\nif (/uptime/g.test(msg)) {\n  // do more stuff...\n}\n```", "```js\n// Create an ES6 Map to store our regular expressions\nthis.keywords = new Map();\n\nthis.slack.on(RTM_EVENTS.MESSAGE, (message) => {\n  // Only process text messages\n  if (!message.text) {\n    return;\n  }\n\n  let channel = this.slack.dataStore.getChannelGroupOrDMById(message.channel);\n  let user = this.slack.dataStore.getUserById(message.user);\n\n  // Loop over the keys of the keywords Map object and test each\n  // regular expression against the message's text property\n  for (let regex of this.keywords.keys()) {    \n    if (regex.test(message.text)) {\n      let callback = this.keywords.get(regex);\n      callback(message, channel, user);\n    }\n  }\n});\n```", "```js\nrespondTo(keywords, callback, start) {\n  // If 'start' is truthy, prepend the '^' anchor to instruct the\n  // expression to look for matches at the beginning of the string\n  if (start) {\n    keywords = '^' + keywords;\n  }\n\n  // Create a new regular expression, setting the case \n  // insensitive (i) flag\n  let regex = new RegExp(keywords, 'i');\n\n  // Set the regular expression to be the key, with the callback\n  // function as the value\n  this.keywords.set(regex, callback);\n}\n```", "```js\n// Loop over the keys of the keywords Map object and test each\n// regular expression against the message's text property\nfor (let regex of this.keywords.keys()) {    \n  if (regex.test(message.text)) {\n    let callback = this.keywords.get(regex);\n    callback(message, channel, user);\n  }\n}\n```", "```js\n  // Send a message to a channel, with an optional callback\n  send(message, channel, cb) {\n    this.slack.sendMessage(message, channel.id, () => {\n      if (cb) {\n        cb();\n      }\n    });\n  }\n```", "```js\n'use strict';\n\nlet Bot = require('./Bot');\n\nconst bot = new Bot({\n  token: process.env.SLACK_TOKEN,\n  autoReconnect: true,\n  autoMark: true\n});\n\nbot.respondTo('hello', (message, channel, user) => {\n  bot.send(`Hello to you too, ${user.name}!`, channel)\n}, true);\n```", "```js\nbot.respondTo('roll', (message, channel, user) => {\n  // get the arguments from the message body\n  let args = getArgs(message.text);\n\n  // Roll two random numbers between 0 and 100\n  let firstRoll = Math.round(Math.random() * 100);\n  let secondRoll = Math.round(Math.random() * 100);\n\n  let challenger = user.name;\n  let opponent = args[0];\n\n  // reroll in the unlikely event that it's a tie\n  while (firstRoll === secondRoll) {\n    secondRoll = Math.round(Math.random() * 100);\n  }\n\n  let winner = firstRoll > secondRoll ? challenger : opponent;\n\n  // Using new line characters (\\n) to format our response\n  bot.send(\n    `${challenger} fancies their chances against ${opponent}!\\n\n    ${challenger} rolls: ${firstRoll}\\n\n    ${opponent} rolls: ${secondRoll}\\n\\n\n    *${winner} is the winner!*`\n  , channel);\n\n}, true);\n\n// Take the message text and return the arguments\nfunction getArgs(msg) {\n  return msg.split(' ').slice(1);\n}\n```", "```js\n  // if args is empty, return with a warning\n  if (args.length < 1) {\n    channel.send('You have to provide the name of the person you wish to challenge!');\n    return;\n  }\n```", "```js\ngetMembersByChannel(channel) {\n    // If the channel has no members then that means we're in a DM\n    if (!channel.members) {\n      return false;\n    }\n\n    // Only select members which are active and not a bot\n    let members = channel.members.filter((member) => {\n      let m = this.slack.dataStore.getUserById(member);\n      // Make sure the member is active (i.e. not set to 'away' status)\n      return (m.presence === 'active' && !m.is_bot);\n    });\n\n    // Get the names of the members\n    members = members.map((member) => {\n      return this.slack.dataStore.getUserById(member).name;\n    });\n\n    return members;\n  }\n```", "```js\nbot.respondTo('roll', (message, channel, user) => {\n  // get the members of the channel\n  const members = bot.getMembersByChannel(channel);\n\n  // make sure there actually members to interact with. If there\n  // aren't then it usually means that the command was given in a \n  // direct message\n  if (!members) {\n    bot.send('You have to challenge someone in a channel, not a direct message!', channel);\n    return;\n  }\n\n  // get the arguments from the message body\n  let args = getArgs(message.text);\n\n  // if args is empty, return with a warning\n  if (args.length < 1) {\n    bot.send('You have to provide the name of the person you wish to challenge!', channel);\n    return;\n  }\n\n  // does the opponent exist in this channel?\n  if (members.indexOf(args[0]) < 0) {\n    bot.send(`Sorry ${user.name}, but I either can't find ${args[0]} in this channel, or they are a bot!`, channel);\n    return;\n  }\n\n  // Roll two random numbers between 0 and 100\n  let firstRoll = Math.round(Math.random() * 100);\n  let secondRoll = Math.round(Math.random() * 100);\n\n  let challenger = user.name;\n  let opponent = args[0];\n\n  // reroll in the unlikely event that it's a tie\n  while (firstRoll === secondRoll) {\n    secondRoll = Math.round(Math.random() * 100);\n  }\n\n  let winner = firstRoll > secondRoll ? challenger : opponent;\n\n  // Using new line characters (\\n) to format our response\n  bot.send(\n    `${challenger} fancies their changes against ${opponent}!\\n\n    ${challenger} rolls: ${firstRoll}\\n\n    ${opponent} rolls: ${secondRoll}\\n\\n\n    *${winner} is the winner!*`\n  , channel);\n\n}, true);\n```", "```js\n// the user shouldn't challenge themselves\nif (args.indexOf(user.name) > -1) {\n  bot.send(`Challenging yourself is probably not the best use of your or my time, ${user.name}`, channel);\n  return;\n}\n```", "```js\n'use strict';\n\nconst Bot = require('./Bot');\nconst request = require('superagent');\n```", "```js\nnpm install superagent --save\n\n```", "```js\nconst wikiAPI = \"https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro=&explaintext=&titles=\"\nconst wikiURL = 'https://en.wikipedia.org/wiki/';\n```", "```js\nconst bot = new Bot({\n  token: process.env.SLACK_TOKEN,\n  autoReconnect: true,\n  autoMark: true\n});\n```", "```js\nfunction getWikiSummary(term, cb) {\n  // replace spaces with unicode\n  let parameters = term.replace(/ /g, '%20');\n```", "```js\n  request\n    .get(wikiAPI + parameters)\n    .end((err, res) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      let url = wikiURL + parameters;\n\n      cb(null, JSON.parse(res.text), url);\n    });\n}\n```", "```js\nbot.respondTo('help', (message, channel) => {  \n  bot.send(`To use my Wikipedia functionality, type \\`wiki\\` followed by your search query`, channel); \n}, true);\n```", "```js\nbot.respondTo('wiki', (message, channel, user) => {\n  if (user && user.is_bot) {\n    return;\n  }\n```", "```js\n  // grab the search parameters, but remove the command 'wiki' // from\n  // the beginning of the message first\n  let args = message.text.split(' ').slice(1).join(' ');\n```", "```js\n  getWikiSummary(args, (err, result, url) => {\n    if (err) {\n      bot.send(`I\\'m sorry, but something went wrong with your query`, channel);\n      console.error(err);\n      return;\n    }\n```", "```js\n    let pageID = Object.keys(result.query.pages)[0];\n```", "```js\n{\n  \"batchcomplete\": \"\",\n  \"query\": {\n    \"normalized\": [\n      {\n        \"from\": \"duck\",\n        \"to\": \"Duck\"\n      }\n    ],\n    \"pages\": {\n      \"37674\": {\n        \"pageid\": 37674,\n        \"ns\": 0,\n        \"title\": \"Duck\",\n        \"extract\": \"Duck is the common name for a large number of species in the waterfowl family Anatidae, which also includes swans and geese. The ducks are divided among several subfamilies in the family Anatidae; they do not represent a monophyletic group (the group of all descendants of a single common ancestral species) but a form taxon, since swans and geese are not considered ducks. Ducks are mostly aquatic birds, mostly smaller than the swans and geese, and may be found in both fresh water and sea water.\\nDucks are sometimes confused with several types of unrelated water birds with similar forms, such as loons or divers, grebes, gallinules, and coots.\\n\\n\"\n      }\n    }\n  }\n}\n```", "```js\n    // -1 indicates that the article doesn't exist\n    if (parseInt(pageID, 10) === -1) {\n      bot.send('That page does not exist yet, perhaps you\\'d like to create it:', channel);\n      bot.send(url, channel);\n      return;\n    }\n```", "```js\n    let page = result.query.pages[pageID];\n    let summary = page.extract;\n\n    if (/may refer to/i.test(summary)) {\n      bot.send('Your search query may refer to multiple things, please be more specific or visit:', channel);\n      bot.send(url, channel);\n      return;\n    }\n```", "```js\n    if (summary !== '') {\n      bot.send(url, channel);\n```", "```js\n      let paragraphs = summary.split('\\n');\n```", "```js\nparagraphs.forEach((paragraph) => {\n  if (paragraph !== '') {\n    bot.send(`> ${paragraph}`, channel);\n  }\n});\n```", "```js\n} else {\n      bot.send('I\\'m sorry, I couldn\\'t find anything on that subject. Try another one!', channel);\n    }\n  });\n}, true);\n```", "```js\n  setTypingIndicator(channel) {\n    this.slack.send({ type: 'typing', channel: channel.id });\n  }\n```", "```js\nbot.respondTo('test', (message, channel) => {\n  bot.setTypingIndicator(message.channel);\n  setTimeout(() => {\n    bot.send('Not typing anymore!', channel);\n  }, 1000);\n}, true);\n```", "```js\nbot.setTypingIndicator(message.channel);\n```"]