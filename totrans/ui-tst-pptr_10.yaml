- en: '*Chapter 10*: Evaluating and Improving the Performance of a Website'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：评估和改进网站性能'
- en: Many things can make a website a success or a complete failure. In [*Chapter
    9*](B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156), *Scraping tools*, we talked
    about a real estate website that can't be launched without content. On many websites,
    content is the number-one feature. [Amazon.com](http://Amazon.com) could be the
    best website in the world, but if it doesn't have the book you are looking for,
    you will go somewhere else.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多事情可以使一个网站成功或完全失败。在 [*第9章*](B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156)
    中，我们讨论了没有内容就无法发布的房地产网站。在许多网站上，内容是排名第一的特性。[Amazon.com](http://Amazon.com) 可能是世界上最棒的网站，但如果它没有你要找的书，你将去其他地方。
- en: For other websites, functionality is the number-one feature. A website such
    as [Trello.com](http://Trello.com) is a success because you can move cards from
    one list to another easily and intuitively. But functionality is not only about
    rich web pages. If we go back to the Amazon website, the website is pretty straightforward.
    It doesn't use any cool UI framework, but it has a great search and well-planned
    navigation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他网站，功能是排名第一的特性。像 [Trello.com](http://Trello.com) 这样的网站之所以成功，是因为你可以轻松直观地将卡片从一个列表移动到另一个列表。但功能不仅仅是关于丰富的网页。如果我们回到
    Amazon 网站，该网站非常直接。它没有使用任何酷的 UI 框架，但它有一个出色的搜索和周密的导航规划。
- en: The website design can also be considered a feature. While some websites such
    as [www.google.com](http://www.google.com) might look simple and focused on delivering
    content, you can see that other websites, such as [www.apple.com](http://www.apple.com),
    invest a lot in design. You can see that design is the number-one feature on [www.apple.com](http://www.apple.com).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网站设计也可以被视为一个特性。虽然一些网站，如 [www.google.com](http://www.google.com)，可能看起来简单且专注于内容传递，但你也可以看到其他网站，如
    [www.apple.com](http://www.apple.com)，在设计上投入了大量资金。你可以在 [www.apple.com](http://www.apple.com)
    上看到设计是排名第一的特性。
- en: 'But most websites will share the same feature: **speed**. **Speed is a feature**.
    When planning a website, the stakeholders might argue whether they want to invest
    in a rich client or not. They can discuss whether they should hire a designer
    or not. But if you ask about the speed, there is only one answer: "We need the
    website to be fast."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但大多数网站都会共享同一个特性：**速度**。**速度是一个特性**。在规划网站时，利益相关者可能会争论他们是否想要投资于丰富的客户端。他们可以讨论是否应该雇佣设计师。但如果你询问速度，只有一个答案：“我们需要网站快速。”
- en: In this chapter, we will learn how to use performance metrics to solve several
    issues that can arise with websites. We will look at functionality, speed, and
    how we can measure these key performance points with Google Lighthouse.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用性能指标来解决可能出现在网站上的几个问题。我们将查看功能、速度，以及我们如何使用 Google Lighthouse 测量这些关键性能点。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: The issue of performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能问题
- en: Getting started with Google Lighthouse
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Google Lighthouse
- en: Tracing pages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪页面
- en: Analyzing code coverage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析代码覆盖率
- en: By the end of this chapter, you will be able to implement performance metrics
    on your website and help the development team improve the website's performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够在你的网站上实施性能指标，并帮助开发团队提高网站的性能。
- en: Let's get started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code of this chapter on the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter10` directory. Remember to run `npm install` on that directory,
    and then go to the `Chapter10/vuejs-firebase-shopping-cart` directory and run
    `npm install` again.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 GitHub 仓库 ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    的 `Chapter10` 目录下找到本章的所有代码。请记住在那个目录中运行 `npm install`，然后进入 `Chapter10/vuejs-firebase-shopping-cart`
    目录并再次运行 `npm install`。
- en: The Issue of Performance
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能问题
- en: 'As I mentioned in the introduction, speed is a feature. You might be asked
    to make a simple website, but no one, ever, will tell you to make a slow website.
    Websites need to be fast. **Performance is the key to success**. Performance increases
    user satisfaction; it results in high conversion rates and higher revenue. Let
    me share some facts with you:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在引言中提到的，速度是一个特性。你可能会被要求制作一个简单的网站，但没有人会要求你制作一个速度慢的网站。网站需要快速。**性能是成功的关键**。性能提升用户满意度；它导致高转化率和更高的收入。让我与你分享一些事实：
- en: Rebuilding Pinterest pages for performance increased conversion rates by 15%
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/pinterest-case](https://www.hardkoded.com/ui-testing-with-puppeteer/pinterest-case)).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了性能而重建Pinterest页面提高了15%的转化率([https://www.hardkoded.com/ui-testing-with-puppeteer/pinterest-case](https://www.hardkoded.com/ui-testing-with-puppeteer/pinterest-case))。
- en: By reducing the response size of the JSON needed for displaying comments, Instagram
    saw increased impressions ([https://www.hardkoded.com/ui-testing-with-puppeteer/instagram-case](https://www.hardkoded.com/ui-testing-with-puppeteer/instagram-case)).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过减少显示评论所需的JSON响应大小，Instagram看到了印象的增加([https://www.hardkoded.com/ui-testing-with-puppeteer/instagram-case](https://www.hardkoded.com/ui-testing-with-puppeteer/instagram-case))。
- en: Walmart saw a 1% increase in revenue for every 100 ms improvement in page load
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/walmart-case](https://www.hardkoded.com/ui-testing-with-puppeteer/walmart-case)).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次页面加载改善100毫秒，沃尔玛的收入就增加了1%([https://www.hardkoded.com/ui-testing-with-puppeteer/walmart-case](https://www.hardkoded.com/ui-testing-with-puppeteer/walmart-case))。
- en: As you can see, performance puts money in your pocket.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，性能把钱放进你的口袋。
- en: 'There is one more thing on which I''m sure you will agree with me: No matter
    the website, no matter what they sell or offer, performance is the number-one
    feature in the mobile experience. When you are on the street, you don''t care
    about the style; you don''t care about functionality. The first thing you need
    is the website to load, and load fast. You need to measure the performance on
    mobile.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一件事，我相信你会同意我的观点：无论是什么网站，无论他们卖什么或提供什么，性能都是移动体验中的首要功能。当你在大街上时，你不会在乎风格；你不会在乎功能。你首先需要的是网站能够快速加载。你需要测量移动端的性能。
- en: 'The problem with this feature is that, in general, people don''t know how to
    measure speed. If we go back to the other features, they are easy to measure.
    It''s easy to discuss content. Content is easy to measure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的问题在于，一般来说，人们不知道如何衡量速度。如果我们回到其他功能，它们很容易衡量。讨论内容很容易。内容很容易衡量：
- en: I want to ship the website with content.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望带着内容发布网站。
- en: How many items?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少项？
- en: Over 1,000.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超过1,000。
- en: 'Functionality is, in general, something you can write down on a spec:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性通常是你可以在规范上写下来的东西：
- en: I want an e-commerce site with an outstanding search experience.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想要一个具有出色搜索体验的电子商务网站。
- en: What does that mean?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那是什么意思？
- en: It should support typos, and I should be able to search for part of a word.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该支持拼写错误，我应该能够搜索单词的一部分。
- en: 'Design is about whether you want to put effort into the look and feel or not:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设计关乎你是否愿意在外观和感觉上投入精力：
- en: We need a website with a great design.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个设计出色的网站。
- en: OK, we need three designers.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好吧，我们需要三个设计师。
- en: Perfect.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完美。
- en: 'But speed is hard to discuss:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但速度很难讨论：
- en: The website needs to be fast.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站需要快。
- en: How fast?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多快？
- en: I don't know… fast?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我不知道……快？
- en: But how fast do you think it should be?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但你认为它应该有多快？
- en: I don't know… faster?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我不知道……更快？
- en: The second problem is that we tend to react to performance issues. We don't
    realize something needs to be fast until we realize it's slow.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，我们倾向于对性能问题做出反应。直到我们意识到它很慢，我们才意识到需要快。
- en: Third, speed is a matter of expectation and comparison. The user would say that
    the website is slow. They would also say that they use Google Drive and that it's
    way faster. The developer would reply that the website seems fast in their opinion,
    and, of course, that they don't have Google's budget.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，速度是期望和比较的问题。用户会说网站很慢。他们也会说他们使用Google Drive，而且它要快得多。开发者会回答说，在他们看来网站似乎很快，当然，他们也没有谷歌的预算。
- en: And the last problem is that we don't know how to test the website's performance.
    We would get a bug report from a user, saying that the website is slow, and the
    QA analyst would grab that bug report to validate it, but what's the tool that
    the analyst has to validate that issue? Going to the website and checking whether
    it "feels" slow to them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是我们不知道如何测试网站的性能。我们会收到用户的错误报告，说网站很慢，质量保证分析师会抓取那个错误报告来验证它，但分析师用来验证那个问题的工具是什么？去网站检查它是否“感觉”慢。
- en: 'That is the perfect cocktail for a disaster: No way to measure, no plan—it''s
    all about feelings and different expectations.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那是灾难的完美鸡尾酒：没有衡量方法，没有计划——一切都关于感觉和不同的期望。
- en: We won't be able to solve all these problems in just one chapter in a web automation
    book. But, we will see some strategies and tools to help you and your team to
    measure and improve your website's performance. Let me share some tips with you
    to get started.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不可能在一本关于网络自动化的书中解决所有这些问题。但，我们将看到一些策略和工具，帮助你和你的团队测量和改进你网站的性能。让我与你分享一些开始的建议。
- en: First, **choose what you need to measure**. If it's the entire website, that's
    OK. But I would start with the most popular pages first. Begin with the home page.
    Then, continue with the main workflow of the website. For instance, for an e-commerce
    website, you would want to test the product details and the checkout page. Ask
    the people in charge of analytics what pages bring more conversions, and focus
    on those pages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**选择你需要测量的内容**。如果是整个网站，那也行。但我会从最受欢迎的页面开始。从主页开始。然后，继续进行网站的流程。例如，对于一个电子商务网站，你想要测试产品详情和结账页面。询问负责分析的人哪些页面带来更多的转化，并专注于这些页面。
- en: Second, **define the maximum amount of time a page can take to load**. You could
    say that the home page should never take more than 30 seconds to load, under any
    circumstances. This is an excellent use for *Checkly*, the platform we saw in
    [*Chapter 6*](B16113_06_Final_SK_ePub.xhtml#_idTextAnchor104), *Executing and
    Injecting JavaScript*. You could code a test to check that the page doesn't take
    more than 30 seconds to load in production and keep that check running on *Checkly*.
    We will see how to implement this later in this chapter. Once you have set up
    that check, you and your team can set more strict goals. For instance, the search
    page should never take more than a second to load.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，**定义页面最大加载时间**。你可以这样说，主页在任何情况下都不应超过30秒加载。这是一个很好的使用*Checkly*的例子，我们在[*第6章*](B16113_06_Final_SK_ePub.xhtml#_idTextAnchor104)中看到的，*执行和注入JavaScript*。你可以编写一个测试来检查页面在生产环境中是否不超过30秒加载，并在*Checkly*上持续进行该检查。我们将在本章后面看到如何实现这一点。一旦你设置了这项检查，你和你的团队可以设定更严格的目标。例如，搜索页面不应超过一秒加载。
- en: Third, **measure performance degradation**. Many times, setting a limit is hard,
    and it can become a guessing game. You can start by measuring how the performance
    evolves over time. Is the website becoming faster or slower? Are we getting better
    or worse? This is a great approach, but it requires a little bit more work. You
    need to start storing data over time and build something to visualize that information.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，**测量性能下降**。很多时候，设定一个限制是困难的，它可能变成一场猜测游戏。你可以从测量性能随时间如何演变开始。网站是变快了还是变慢了？我们是变得更好还是更差了？这是一个很好的方法，但它需要做更多的工作。你需要开始存储随时间变化的数据，并构建一些可视化这些信息的东西。
- en: And lastly, use the tools you learned in this book. We talked about Checkly,
    but remember all the emulation techniques we learned back in [*Chapter 8*](B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137),
    *Environments emulation*? You can set different goals for different network speeds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用你在本书中学到的工具。我们谈到了Checkly，但记得我们在[*第8章*](B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137)中学习的所有模拟技术吗？你可以为不同的网络速度设定不同的目标。
- en: This is all you can do to measure a website's performance. In this chapter,
    I want to show you which tools you have to implement these ideas. Let's start
    with Google Lighthouse, a tool we can use to measure several important metrics.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以用来测量网站性能的所有方法。在本章中，我想向你展示你可以使用哪些工具来实现这些想法。让我们从Google Lighthouse开始，这是一个我们可以用来测量几个重要指标的工具。
- en: Getting started with Google Lighthouse
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Google Lighthouse
- en: As we saw in the previous section, it's not easy to determine how fast "fast"
    is. Google came up with an idea. They built Lighthouse, "*an open-source, automated
    tool for improving the quality of web pages. You can run it against any web page,
    public or requiring authentication. It has audits for performance, accessibility,
    progressive web apps, SEO and more*" ([https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse](https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，确定“快”有多快并不容易。谷歌想出了一个主意。他们开发了Lighthouse，“*一个开源的、自动化的工具，用于提高网页质量。你可以对任何网页运行它，无论是公开的还是需要认证的。它有性能、可访问性、渐进式网页应用、SEO等方面的审核*”([https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse](https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse))。
- en: 'Lighthouse will grab the website you choose, apply a list of metrics and recommendations
    it finds important, and give you a score from 0 to 100\. It will analyze the website
    under five categories:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse将抓取你选择的网站，应用它认为重要的指标和推荐列表，并给你一个从0到100的评分。它将在五个类别下分析网站：
- en: '**Performance**: The most popular category. Lighthouse will measure how optimized
    the website is, that is, how fast it gets ready for user interaction.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**: 最受欢迎的类别。Lighthouse将测量网站优化程度，即网站准备与用户交互的速度有多快。'
- en: '**Accessibility**: I would love to see developers paying more attention to
    this category. Here, Lighthouse will evaluate how accessible the website is.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性**: 我希望看到开发者更多地关注这个类别。在这里，Lighthouse将评估网站的易访问性。'
- en: '**Best practices**: This is another popular category. Lighthouse will evaluate
    a few good practices to incorporate into the website.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳实践**: 这是另一个受欢迎的类别。Lighthouse将评估一些良好的实践，并将其纳入网站中。'
- en: '**SEO**: This category is used a lot by people in charge of marketing. Some
    companies even have SEO experts looking at this. This category is about how optimized
    the website is for search engines. You might agree or not on how the other categories
    are measured, but here Google is telling you: "This is how we measure your website."
    You will want a score of 100 if you want to secure your spot on the first page
    of Google.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SEO**: 这个类别常被负责营销的人士使用。一些公司甚至有SEO专家来关注这个。这个类别是关于网站对搜索引擎的优化程度。你可能会同意或不同意其他类别的测量方式，但在这里，谷歌告诉你：“这是我们衡量你网站的方式。”如果你想确保你的网站出现在谷歌的第一页，你希望得到100分的评分。'
- en: '**Progressive Web App**: If the website is a progressive web app, this category
    will evaluate aspects of that progressive web app.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渐进式Web应用**: 如果网站是渐进式Web应用，这个类别将评估该渐进式Web应用的各个方面。'
- en: Important Note
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**Progressive web apps** (**PWAs**) are websites prepared to be installed as
    native applications. Many PWAs have offline capabilities and try to get close
    to a native app experience.'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**渐进式Web应用**（**PWAs**）是准备作为原生应用程序安装的网站。许多PWAs具有离线功能，并试图接近原生应用程序的体验。'
- en: In this chapter, we will focus only on the Performance category. But before
    getting into the details of the performance category, let's see how we can run
    this tool. Lighthouse comes in four flavors, which we will cover in the following
    sections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将只关注性能类别。但在深入了解性能类别之前，让我们看看我们如何运行这个工具。Lighthouse有四种版本，我们将在接下来的章节中介绍。
- en: As part of Chrome DevTools
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为Chrome DevTools的一部分
- en: 'If you open DevTools, you will find a **Lighthouse** tab. If you can''t find
    it, you can add it by clicking on the three dots in the tool''s right corner,
    then going to **More tools**, and then finding the **Lighthouse** options. You
    should see something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开DevTools，你会找到一个**Lighthouse**标签。如果你找不到，你可以通过点击工具右上角的三个点，然后转到**更多工具**，再找到**Lighthouse**选项来添加它。你应该会看到类似这样的内容：
- en: '![Lighthouse inside DevTools'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![Lighthouse在DevTools中'
- en: '](img/Figure_10.01_B16113.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.01_B16113.jpg)'
- en: Lighthouse inside DevTools
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse在DevTools中
- en: You should now have the tab there with all the options to generate the report.
    The process will run Lighthouse locally, which is good, but that would mean that
    the Lighthouse results will be based on your hardware, CPU, available RAM, network
    speed, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有一个带有所有生成报告选项的标签页。这个过程将在本地运行Lighthouse，这是好的，但这也意味着Lighthouse的结果将基于你的硬件、CPU、可用RAM、网络速度等等。
- en: Using PageSpeed Insights
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PageSpeed Insights
- en: Google saw that results might fluctuate based on your hardware, so they made
    a PageSpeed Insights ([https://www.hardkoded.com/ui-testing-with-puppeteer/pagespeed](https://www.hardkoded.com/ui-testing-with-puppeteer/pagespeed))
    where you can run Lighthouse using Google's hardware. That would make it more
    stable, but you could get different results even using Google's hardware.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于谷歌发现结果可能会根据你的硬件而波动，所以他们创建了一个PageSpeed Insights（[https://www.hardkoded.com/ui-testing-with-puppeteer/pagespeed](https://www.hardkoded.com/ui-testing-with-puppeteer/pagespeed)），你可以在那里使用谷歌的硬件运行Lighthouse。这将使其更加稳定，但即使使用谷歌的硬件，你可能会得到不同的结果。
- en: Using the command line
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行
- en: You can also use Lighthouse from the command line. I wasn't that excited about
    having Lighthouse in the command line first. But then I realized that it's way
    more productive to use it from the command line than opening a browser, going
    to DevTools, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从命令行使用Lighthouse。一开始我对在命令行中拥有Lighthouse并不那么兴奋。但后来我意识到，从命令行使用它比打开浏览器、进入DevTools等要高效得多。
- en: 'You can install the Lighthouse `-g` flag like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样安装Lighthouse的`-g`标志：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: NPM global modules
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: NPM全局模块
- en: When you run `npm install` with the `-g` flag, the module will be installed
    in a shared directory rather than in the `node_modules` folder, and it will be
    accessible by any app. Additionally, if the module provides an executable command,
    it will be accessible from the command line like this Lighthouse module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`-g`标志运行`npm install`时，模块将被安装在共享目录中，而不是在`node_modules`文件夹中，并且任何应用程序都可以访问它。此外，如果模块提供了一个可执行命令，它将像这个Lighthouse模块一样可以从命令行访问。
- en: Once installed, you will be able to launch `lighthouse` from the command line,
    passing the URL and, additionally, extra command-line arguments such as `--view`,
    which will launch the report after evaluating the website.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将能够从命令行启动`lighthouse`，传递URL，以及额外的命令行参数，如`--view`，这将评估网站后在启动报告。
- en: 'With this line of code, you will be able to see the Lighthouse result for [www.packtpub.com](http://www.packtpub.com):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这一行代码，你将能够看到[www.packtpub.com](http://www.packtpub.com)的Lighthouse结果：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Wondering what the result is? We'll get there.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道结果是什么？我们很快就会知道。
- en: The last option available is one that we will use a lot, and it's using the
    node module as part of our code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可用的选项是我们会大量使用的，那就是将节点模块作为我们代码的一部分来使用。
- en: Using the node module
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用节点模块
- en: 'We will be able to use Lighthouse in our unit tests using the node module.
    Let''s take a look at the example from the Lighthouse repository ([https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse-programmatically](https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse-programmatically)):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够使用节点模块在我们的单元测试中使用Lighthouse。让我们看看Lighthouse存储库中的示例([https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse-programmatically](https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse-programmatically))：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code is not very complicated. We launch a Chrome browser using the `chrome-launcher`
    module. Then we launch `lighthouse`, passing a URL and a set of options. The `lighthouse`
    function will return an object, I called it `runnerResult`, which contains a `report`
    property with the report as HTML and also a property called `lhr` (Lighthouse
    result) with all the results as an object. We will use that property to assert
    the minimum values we want to get.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并不复杂。我们使用`chrome-launcher`模块启动Chrome浏览器。然后我们启动`lighthouse`，传递一个URL和一组选项。`lighthouse`函数将返回一个对象，我称之为`runnerResult`，它包含一个`report`属性，其中包含作为HTML的报告，还有一个名为`lhr`（Lighthouse结果）的属性，其中包含所有结果作为一个对象。我们将使用该属性来断言我们想要得到的最低值。
- en: 'Now that we know how to launch Lighthouse, let''s see how the report looks.
    In order to avoid hurting feelings, we will run Lighthouse against the very same
    Lighthouse website: [https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse](https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse).
    Let''s see whether it is as fast as they say. As I mentioned before, I felt really
    comfortable with the command-line tool, so I will run this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何启动Lighthouse，让我们看看报告看起来如何。为了避免伤害感情，我们将对同一个Lighthouse网站运行Lighthouse：[https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse](https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse)。让我们看看它是否像他们说的那样快。正如我之前提到的，我对命令行工具感到非常舒适，所以我将运行以下命令：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running that, I got a new tab in my browser with the following result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行之后，我在浏览器中打开了一个新标签页，以下是我得到的结果：
- en: '![Lighthouse result'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![Lighthouse结果'
- en: '](img/Figure_10.02_B16113.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![灯塔结果'
- en: Lighthouse result
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 灯塔结果
- en: To be honest, I picked a Google website on purpose. As you can see in the screenshot,
    the results can be rough. A score of 55 doesn't mean that your site is terrible.
    It just means that the website can be improved a lot.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，我故意选择了一个谷歌网站。正如你在截图中所见，结果可能很粗糙。55分的评分并不意味着你的网站很糟糕。这只是意味着网站有很大的改进空间。
- en: You also have to keep in mind that a single company made this scoring system
    and, although many companies use it as a marketing number to show off how good
    the score is, this is not the final word. It's just one way to measure the performance
    of your website.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须记住，这个评分系统是由一家公司制作的，尽管许多公司将其作为营销数字来展示分数有多高，但这并不是最终结论。这只是衡量你网站性能的一种方式。
- en: Another thing to keep in mind is that although it measures many things, its
    focus is on the time taken to load the page, and you should know that performance
    is more than that.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是，尽管它衡量了许多事情，但它的重点是页面加载所需的时间，你应该知道性能不仅仅是这些。
- en: Let's dive into the performance category details.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解性能类别的细节。
- en: The performance category
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能类别
- en: 'Each category in Lighthouse consists of three sections: metrics, opportunities,
    and diagnostics. Although only the metrics are used for the category score, it
    is by implementing the opportunities and looking at the diagnostics that you will
    improve the metrics.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse中的每个类别都包含三个部分：指标、机会和诊断。尽管只有指标被用于类别评分，但通过实施机会和查看诊断，你将能够提高指标。
- en: Each category has its own set of metrics, opportunities, and diagnostics. In
    particular, the performance category has 6 metrics, 17 opportunities, and 13 diagnostics.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别都有自己的指标、机会和诊断集合。特别是，性能类别有6个指标、17个机会和13个诊断。
- en: Let's take a look at the performance metrics.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看性能指标。
- en: Performance metrics
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能指标
- en: The first metric is **First Contentful Paint**. It has a weight of 15% on the
    overall performance score. According to Google, this metric "*measures how long
    it takes the browser to render the first piece of DOM content after a user navigates
    to your page. Images, non-white <canvas> elements, and SVGs on your page are considered
    DOM content; anything inside an iframe isn't included*." You will get a green
    score if this metric is under 2 seconds. You can read more about this metric and
    how to improve the score at [https://web.dev/first-contentful-paint/](https://web.dev/first-contentful-paint/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指标是**首次内容渲染**。它在整体性能评分中占15%的权重。根据谷歌，这个指标“*衡量用户导航到你的页面后浏览器渲染第一块DOM内容所需的时间。页面上的图像、非白色<canvas>元素和SVG被认为是DOM内容；任何在iframe内的内容都不包括在内*。”如果这个指标低于2秒，你会得到一个绿色分数。你可以阅读更多关于这个指标以及如何提高分数的信息，请访问[https://web.dev/first-contentful-paint/](https://web.dev/first-contentful-paint/)。
- en: The second metric is **Speed Index**. It has a weight of 15% on the overall
    performance score. According to Google, this metric "*measures how quickly content
    is visually displayed during page load. Lighthouse first captures a video of the
    page loading in the browser and computes the visual progression between frames.
    Lighthouse then uses the* Speedline Node.js module *to generate the Speed Index
    score*." You will get a green score if this metric is under 4.3 seconds. You can
    read more about this metric and how to improve the score at [https://web.dev/speed-index/](https://web.dev/speed-index/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个指标是**速度指数**。它在整体性能评分中占15%的权重。根据谷歌，这个指标“*衡量内容在页面加载期间视觉显示的速度。Lighthouse首先捕获浏览器中页面加载的视频，并计算帧之间的视觉进度。然后，Lighthouse使用*
    Speedline Node.js模块 *生成速度指数分数*。”如果这个指标低于4.3秒，你会得到一个绿色分数。你可以阅读更多关于这个指标以及如何提高分数的信息，请访问[https://web.dev/speed-index/](https://web.dev/speed-index/)。
- en: With a weight of 25%, the third metric is **Largest Contentful Paint** and is
    one of the most important metrics. According to Google, this metric "*measures
    the render time of the largest image or text block visible within the viewport*."
    You will get a green score if this metric is under 2.5 seconds. If you are interested
    in how they get to know what the "largest contentful element" is, check out their
    article at [https://web.dev/lcp/](https://web.dev/lcp/).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个指标是**最大内容渲染**，权重为25%，是最重要的指标之一。根据谷歌，这个指标“*衡量视口中可见的最大图像或文本块的渲染时间*。”如果这个指标低于2.5秒，你会得到一个绿色分数。如果你对如何确定“最大内容元素”感兴趣，可以查看他们的文章，请访问[https://web.dev/lcp/](https://web.dev/lcp/)。
- en: The fourth metric is **Time to Interactive**. It has a weight of 15% on the
    overall performance score. According to Google, this metric "*measures how long
    it takes a page to become fully interactive*." You will get a green score if this
    metric is under 3.8 seconds. You can read more about this metric and how to improve
    the score at [https://web.dev/interactive/](https://web.dev/interactive/).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个指标是**交互时间**。它在整体性能评分中占15%的权重。根据谷歌，这个指标“*衡量页面完全交互所需的时间*。”如果这个指标低于3.8秒，你会得到一个绿色分数。你可以阅读更多关于这个指标以及如何提高分数的信息，请访问[https://web.dev/interactive/](https://web.dev/interactive/)。
- en: The fifth metric is **Total Blocking Time**, which is the second metric with
    a weight of 25% on the overall performance score. According to Google, this metric
    "*measures the total amount of time that a page is blocked from responding to
    user input, such as mouse clicks, screen taps, or keyboard presses*." You will
    get a green score if this metric is under 300 milliseconds. You can read more
    about this metric and how to improve the score at [https://web.dev/lighthouse-total-blocking-time/](https://web.dev/lighthouse-total-blocking-time/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个指标是**总阻塞时间**，这是在整体性能评分中权重为25%的第二个指标。根据谷歌的说法，这个指标"*衡量页面从响应用户输入（如鼠标点击、屏幕触摸或键盘按键）被阻塞的总时间*"。如果这个指标低于300毫秒，你会得到一个绿色的分数。你可以阅读更多关于这个指标以及如何提高分数的信息，请访问[https://web.dev/lighthouse-total-blocking-time/](https://web.dev/lighthouse-total-blocking-time/)。
- en: With a weight of just 5%, the last metric is **Cumulative Layout Shift**. According
    to Google, this metric "*measures the sum total of all individual layout shift
    scores for every unexpected layout shift that occurs during the entire lifespan
    of the page*." You will get a green mark if the score is under 0.1\. You can read
    more about this metric and how to improve the score at [https://web.dev/cls](https://web.dev/cls).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个指标的权重仅为5%，它是**累积布局偏移**。根据谷歌的说法，这个指标"*衡量在整个页面生命周期中发生的所有意外布局偏移的个别布局偏移分数的总和*"。如果分数低于0.1，你会得到一个绿色的标记。你可以阅读更多关于这个指标以及如何提高分数的信息，请访问[https://web.dev/cls](https://web.dev/cls)。
- en: I came to a few conclusions after digging into all these metrics. First, it's
    clear that they were made by web performance professionals. It would have been
    impossible for me to build all these metrics in my daily job. The research behind
    these metrics is impressive.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究所有这些指标后，我得出了一些结论。首先，很明显，它们是由网络性能专业人士制作的。在我日常工作中构建所有这些指标是不可能的。这些指标背后的研究令人印象深刻。
- en: On the other side, when you look at the weights and thresholds, while they look
    well thought out, they might sound quite arbitrary. Why is total blocking time
    more important than time to interactive? Or why do I get a green mark on a speed
    index under 4.3 seconds? Why not 4.2? Why not 4.4? But this is better than nothing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一方面来看，当你查看权重和阈值时，虽然它们看起来经过深思熟虑，但可能听起来相当随意。为什么总阻塞时间比交互时间更重要？或者为什么我在小于4.3秒的速度指数上得到一个绿色的标记？为什么不选择4.2秒？为什么不选择4.4秒？但总比没有好。
- en: You might also have had the feeling of this being too complicated or hard to
    understand. Some concepts, such as **Largest Contentful Paint**, sound like rocket
    science, at least to me. That's why you might find it easier to understand and
    follow the opportunities section of the report.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也感觉这太复杂或难以理解。一些概念，例如**最大内容渲染时间**，听起来像是火箭科学，至少对我来说是这样的。这就是为什么你可能觉得理解并遵循报告中的机会部分更容易。
- en: Performance opportunities
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能机会
- en: 'Opportunities are calls to action. These are not just simple recommendations.
    Here, Lighthouse will get to the point: "If you do this, you might get this bump
    in performance."'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 机会是行动的召唤。这不仅仅是简单的建议。在这里，灯塔会直接指出：“如果你这样做，你可能会获得这种性能提升。”
- en: As I mentioned before, there are 17 opportunities under the performance category.
    We won't cover all of them. But I would like to go through a few of them so you
    get an idea of what this section is about.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，性能类别下有17个机会。我们不会涵盖所有这些。但我希望详细介绍其中几个，以便你了解这一部分的内容。
- en: 'Let''s cover only the opportunities shown when we process the Lighthouse website.
    These are the opportunities I got in my report:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只关注我们在处理Lighthouse网站时显示的机会。这些是我报告中得到的机会：
- en: '![Performance opportunities for the Lighthouse website'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![Lighthouse网站的性能机会'
- en: '](img/Figure_10.03_B16113.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.03_B16113.jpg)'
- en: Performance opportunities for the Lighthouse website
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse网站的性能机会
- en: 'Here, we have five opportunities. Let''s unpack them:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有五个机会。让我们逐一分析：
- en: '**Properly size images**: Lighthouse found images that are bigger than the
    size shown on the page.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确调整图像大小**：灯塔发现了一些比页面上显示的大小更大的图像。'
- en: '**Serve images in next-gen formats**: Here, Lighthouse checks whether you are
    using JPEG or PNG files instead of "next-gen" formats such as WebP. I''m not particularly
    a fan of this opportunity. Although WebP is supported in most popular browsers
    these days, it is not a popular format in general yet.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以下一代格式提供图像**：在这里，灯塔会检查你是否正在使用JPEG或PNG文件而不是“下一代”格式，如WebP。我并不是特别喜欢这个机会。尽管如今WebP在大多数流行的浏览器中都有支持，但它在一般意义上还不是一种流行的格式。'
- en: '**Eliminate render-blocking resources**: I think this is a critical opportunity.
    Here, Lighthouse found that many resources are blocking the first paint of the
    page. Paying attention to this opportunity would improve your metrics considerably.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除渲染阻塞资源**：我认为这是一个关键的机会。在这里，Lighthouse发现许多资源正在阻止页面的首次绘制。关注这个机会将大大提高你的指标。'
- en: '**Remove unused JavaScript**: Lighthouse found JavaScript code that is not
    being used. Although this would be easy to detect by Lighthouse, this issue is
    not that easy to solve by developers. Developers these days use bundlers to pack
    all their JavaScript code, and shrinking the final code to only the code that
    the page needs can be challenging.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除未使用的JavaScript**：Lighthouse发现了一些未被使用的JavaScript代码。尽管这个问题Lighthouse可以轻松检测到，但开发者解决这个问题的难度并不小。如今，开发者使用打包器将所有JavaScript代码打包在一起，将最终代码缩减到页面需要的代码可能具有挑战性。'
- en: '**Remove unused CSS**: This opportunity is similar to the previous one, but
    it''s related to CSS styles.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除未使用的CSS**：这个机会与上一个类似，但它与CSS样式相关。'
- en: 'I love this section because Lighthouse doesn''t just tell you what the opportunities
    are; it also gives details showing you where the opportunity is and what would
    be the performance bump. Let''s see, for instance, what we get when we click on
    the **Properly size images** row:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个部分，因为Lighthouse不仅告诉你有哪些机会；它还提供了详细的说明，告诉你机会在哪里以及性能提升会是什么样子。让我们看看，例如，当我们点击**正确调整图片大小**这一行时，我们会得到什么：
- en: '![Properly size images section'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![正确调整图片大小部分'
- en: '](img/Figure_10.04_B16113.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.04_B16113.jpg)'
- en: Properly size images section
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正确调整图片大小部分
- en: As you can see there, Lighthouse is showing us which images we can improve and
    what the potential savings we could get are. You will get the same kind of details
    on every opportunity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Lighthouse向我们展示了哪些图片可以改进以及我们可能获得的潜在节省。你将在每个机会上获得相同类型的详细信息。
- en: The last section within a Lighthouse category is the diagnostics.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse类别中的最后一个部分是诊断部分。
- en: Performance Diagnostics
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能诊断
- en: I see the diagnostics section as a list of things you should consider to improve
    your website. As I mentioned before, the performance category has 13 diagnostics,
    but you will see this number change over time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为诊断部分是你应该考虑以提高你网站的一些事情列表。正如我之前提到的，性能类别有13个诊断，但你将看到这个数字会随着时间的推移而变化。
- en: 'This is how the diagnostics section looks:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是诊断部分的外观：
- en: '![Performance diagnostics for the Lighthouse website'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![Lighthouse网站的性能诊断'
- en: '](img/Figure_10.05_B16113.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.05_B16113.jpg)'
- en: Performance diagnostics for the Lighthouse website
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse网站的性能诊断
- en: 'As you can see, you will have the same level of detail as in the opportunities
    section, but these diagnostics sound more like recommendations to improve over
    time on your website. For instance, let''s take a look at the **Minimize main-thread
    work** section:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你将获得与机会部分相同级别的详细信息，但这些诊断听起来更像是对你网站进行长期改进的建议。例如，让我们看看**最小化主线程工作**这一部分：
- en: '![Minimize main-thread work section'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![最小化主线程工作部分'
- en: '](img/Figure_10.06_B16113.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.06_B16113.jpg)'
- en: Minimize main-thread work section
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化主线程工作部分
- en: As you can see, it seems to make sense what the diagnostics section reports.
    There is some script evaluation that is taking 1,490 ms. But that doesn't sound
    like a call to action. It's more something to consider if you need to improve
    the website's performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，诊断部分报告的内容似乎是有意义的。有一些脚本评估耗时1,490毫秒。但这听起来并不像是一个行动号召。它更像是在你需要提高网站性能时需要考虑的事情。
- en: Now that we have learned about what Lighthouse is, let's see how we can test
    our website's performance by adding Lighthouse to our tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了Lighthouse是什么，让我们看看如何通过将Lighthouse添加到我们的测试中来测试我们网站的性能。
- en: Using Lighthouse for testing
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Lighthouse进行测试
- en: Let's be clear, Lighthouse is not a testing tool. It's a tool used more for
    developers to check their websites' performance. But, as we mentioned many times
    in this book, the role of QA is to honor the customer. It's to ensure that the
    customer gets the best product the team can deliver. We will use Lighthouse to
    ensure that the customer will get the fastest website we can deliver.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一点，Lighthouse不是一个测试工具。它是一个开发者用来检查他们网站性能的工具。但是，正如我们在本书中多次提到的，QA的角色是尊重客户。它的目的是确保客户得到团队可以提供的最佳产品。我们将使用Lighthouse来确保客户将获得我们能够提供的最快的网站。
- en: 'I can think of three ways we can test a Lighthouse report:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我能想到三种测试Lighthouse报告的方法：
- en: Ensure that a page has a minimum performance score.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保一个页面有最低的性能分数。
- en: Ensure that a metric is below a threshold.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保一个指标低于阈值。
- en: Ensure that an opportunity is not found.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保不会找到机会。
- en: Let's begin by checking the performance score.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查性能分数开始。
- en: Ensure that a page has a minimum performance score
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保一个页面有最低的性能分数
- en: 'The first test we can make using Lighthouse is making sure that our page performance
    won''t degrade over time. We will check that our page never falls below a specific
    score. How can we pick the minimum score? As we want to be sure that our website
    won''t degrade over time, let''s see the current performance score and enforce
    that. Let''s go to the `vuejs-firebase-shopping-cart` directory, under `Chapter10`
    of the repository, and we will run `npm run serve` and launch the web application:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Lighthouse进行的第一个测试是确保我们的页面性能不会随着时间的推移而下降。我们将检查我们的页面永远不会低于特定的分数。我们如何选择最低分数？由于我们想要确保我们的网站不会随着时间的推移而退化，让我们查看当前的性能分数并强制执行。让我们转到`vuejs-firebase-shopping-cart`目录下的`repository`的`Chapter10`，然后我们将运行`npm
    run serve`并启动Web应用程序：
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That command should start the website. Once started, let''s open another terminal
    and run Lighthouse on the home page:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该启动网站。一旦启动，让我们打开另一个终端并在主页上运行Lighthouse：
- en: '[PRE5]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The result of that process was a score of 30 for performance. We can set our
    target score at 25\. Time to write our test.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的得分结果是30分（性能）。我们可以将目标分数设置为25。现在是时候编写我们的测试了。
- en: Important Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As Lighthouse runs locally, you might get different results on different machines.
    You should consider that when picking your score goal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lighthouse是本地运行的，你可能会在不同的机器上得到不同的结果。在选择你的分数目标时，你应该考虑这一点。
- en: 'We are going to add our test in the `homepage.tests.js` file. But before creating
    the test, we need to install the `lighthouse` module by running the following
    command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`homepage.tests.js`文件中添加我们的测试。但在创建测试之前，我们需要通过运行以下命令安装`lighthouse`模块：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That will get us Lighthouse in our tests. The next step is importing the lighthouse
    module using the `require` function. Let''s add this line at the top of the file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使Lighthouse在我们的测试中可用。下一步是使用`require`函数导入lighthouse模块。让我们在文件顶部添加这一行：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will make Lighthouse available in our tests. Now, let''s see how our test
    would look:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使Lighthouse在我们的测试中可用。现在，让我们看看我们的测试将是什么样子：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We solved the test using only two statements. We first call `lighthouse`, passing
    the URL we want to process, in this case, `config.baseURL`, and then we pass an
    `options` object. There we are passing the `port` it has to use to connect to
    the browser that Puppeteer is using. We get it by doing `new URL(browser.wsEndpoint())).port`,
    and then we tell Lighthouse we only want to process the `performance` category.
    We won't cover all the available options here. You can take a look at the full
    list of options at [https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse-configuration](https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse-configuration).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅使用两条语句解决了这个测试。我们首先调用`lighthouse`，传递我们想要处理的URL，在这个例子中，是`config.baseURL`，然后我们传递一个`options`对象。在那里我们传递它需要用来连接Puppeteer所使用的浏览器的`port`。我们通过`new
    URL(browser.wsEndpoint())).port`获取它，然后我们告诉Lighthouse我们只想处理`performance`类别。这里不会涵盖所有可用的选项。你可以查看完整的选项列表，请参阅[https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse-configuration](https://www.hardkoded.com/ui-testing-with-puppeteer/lighthouse-configuration)。
- en: In the next line, we just assert that the score of the performance category
    is greater or equal to 0.25\. When you see the report, scores are in the range
    of 0 to 100\. But in the JSON object, the range is from 0 to 1\. That's why we
    need to use 0.25 instead of 25.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们只是断言性能类别的分数大于或等于0.25。当你看到报告时，分数范围是0到100。但在JSON对象中，范围是从0到1。这就是为什么我们需要使用0.25而不是25。
- en: The next test is checking for specific metrics.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是检查特定的指标。
- en: Ensure that a metric is below a threshold
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保一个指标低于阈值
- en: 'We can also be more specific. We could say that, for instance, regardless of
    the performance score we want to check, **First Contentful Paint** should never
    take longer than 30 seconds. Our code will be similar to our previous test:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以更加具体。例如，无论我们想要检查的性能分数如何，**首次内容渲染**的耗时不应超过30秒。我们的代码将与之前的测试类似：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we can see that the `lhr` object also contains an `audits` dictionary
    with all the metrics. We can grab the `first-contentful-paint` entry call and
    check that `numericValue` (in milliseconds) is under 30,000 (30 seconds expressed
    in milliseconds).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`lhr`对象也包含一个包含所有指标的`audits`字典。我们可以获取`first-contentful-paint`条目的调用，并检查`numericValue`（以毫秒为单位）是否低于30,000（以毫秒表示的30秒）。
- en: 'How can we know what the available metrics are? The easiest way is to add a
    breakpoint in your test and add a watch to see the value of `result.lhr`. You
    will see something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道可用的指标有哪些？最简单的方法是在你的测试中添加一个断点，并添加一个监视器来查看`result.lhr`的值。你会看到类似以下的内容：
- en: '![result.lhr content'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![result.lhr内容'
- en: '](img/Figure_10.07_B16113.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.07_B16113.jpg)'
- en: Result.lhr content
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Result.lhr内容
- en: There you will be able to see not only the available entries but also `numericUnit`,
    among many other properties.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，你将能够看到可用的条目，以及许多其他属性中的`numericUnit`。
- en: Based on this example, making sure that an opportunity is not found will be
    easy.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个例子，确保没有找到机会将会很容易。
- en: Ensure that an opportunity is not found
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保没有找到机会
- en: 'I think this is the most solid way to use Lighthouse. We introduced some arbitrary
    numbers in our previous examples, 30 for the score and 30 seconds for the metric.
    Now, let''s say we don''t want to get a certain opportunity; for instance, we
    don''t want any images of the wrong size. We can look at the audits and try to
    find an entry with the name `user-responsive-images`. With that entry, we can
    write the following test:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是使用Lighthouse最可靠的方法。我们在之前的例子中引入了一些任意数字，30用于分数，30秒用于指标。现在，假设我们不想获得某个机会；例如，我们不想有任何错误尺寸的图片。我们可以查看审核，尝试找到一个名为`user-responsive-images`的条目。有了这个条目，我们可以编写以下测试：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code is the same as the previous example, but here, we assert that the metric
    value should be 0\. That will mean that all the images are properly sized.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一个例子相同，但在这里，我们断言指标值应该是0。这意味着所有图片都正确设置了尺寸。
- en: It's impressive all we can do with Lighthouse, but to be honest, you won't see
    many teams applying these ideas to their project. If you get to test your website's
    performance using Lighthouse, you will add a lot of value to your team.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse所能做到的一切都令人印象深刻，但说实话，你不会看到很多团队将这些想法应用到他们的项目中。如果你能够使用Lighthouse测试你网站的性能，这将给你的团队带来很大的价值。
- en: Lighthouse is kind of a black box that you call, get values, and act in response.
    But what if you want to build your own metric? What if you want to analyze the
    performance of a page in a more granular way? Let's now explore all the **tracing**
    features Puppeteer offers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse有点像一个黑盒，你可以调用它，获取值，并做出响应。但如果你想要构建自己的指标呢？如果你想要以更细粒度的方式分析页面的性能呢？现在让我们探索Puppeteer提供的所有**跟踪**功能。
- en: Tracing Pages
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪页面
- en: 'In this section, we will cover how to get performance information using the
    `tracing` object you can find on the **page.tracing** property. I saw this question
    more than once on Stack Overflow: How can I get the Performance tab''s information
    using Puppeteer? The answer is: You can get all that information from the tracing
    result. There is a high chance that you will get a reply like: "Yes, I say that,
    but the result is too complex." And yes, the tracing result is quite complicated.
    But we will try to see what we can get from that object in this section.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何使用可以在**page.tracing**属性中找到的`tracing`对象来获取性能信息。我在Stack Overflow上看到过这个问题不止一次：我如何使用Puppeteer获取性能选项卡的信息？答案是：你可以从跟踪结果中获取所有这些信息。有很大可能性你会得到这样的回复：“是的，我这么说，但结果太复杂了。”是的，跟踪结果相当复杂。但我们将尝试在本节中看看我们能从这个对象中得到什么。
- en: 'If you open DevTools, you should see a **Performance** tab like this one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开开发者工具，你应该看到一个**性能**选项卡，如下所示：
- en: '![Performance tab'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![性能选项卡'
- en: '](img/Figure_10.08_B16113.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.08_B16113.jpg)'
- en: Performance tab
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 性能选项卡
- en: As you can see, the **Performance** tab is not processing information all the
    time because it's a costly process. You need to start "recording" the tracing,
    Chrome will begin collecting lots of data from the browser, and then you have
    to stop the tracing process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**性能**选项卡并不是一直在处理信息，因为这是一个成本高昂的过程。你需要开始“记录”跟踪，Chrome将开始从浏览器收集大量数据，然后你必须停止跟踪过程。
- en: 'If you click on the second button, which looks like a reload, it will automatically
    reload the page and start the tracing. If you click on that button and then stop
    the tracing when the page loads, you will get something like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击第二个按钮，它看起来像是一个刷新按钮，它将自动刷新页面并开始跟踪。如果你点击该按钮并在页面加载时停止跟踪，你将得到类似这样的结果：
- en: '![Performance result'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![性能结果'
- en: '](img/Figure_10.09_B16113.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.09_B16113.jpg)'
- en: Performance result
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 性能结果
- en: The level of detail of that panel is impressive. You get to see every paint
    action, every HTML parsing, every JavaScript execution, everything the browser
    did to render the page there.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该面板的详细程度令人印象深刻。你可以看到每一个绘制动作，每一个 HTML 解析，每一个 JavaScript 执行，浏览器为了渲染页面所做的一切。
- en: 'We can get the same using the `tracing` object. Let''s create a test called
    `Should have a good first contentful paint metric using tracing` in our `homepage.tests.js`
    file, but we will add only the tracing calls for now:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `tracing` 对象得到相同的结果。让我们在我们的 `homepage.tests.js` 文件中创建一个名为 `Should have
    a good first contentful paint metric using tracing` 的测试，但现在我们只添加跟踪调用：
- en: '[PRE11]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code is straightforward. We start the tracing, we go to the page, and we
    stop the tracing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单。我们开始跟踪，我们转到页面，然后我们停止跟踪。
- en: 'The `start` function expects an `options` object, which has three properties:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 函数期望一个 `options` 对象，它有三个属性：'
- en: The `screenshots` property will determine whether we want Chromium to take screenshots
    during the tracing.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`screenshots` 属性将决定我们是否希望在跟踪期间让 Chromium 捕获屏幕截图。'
- en: If you set the `path` property, the tracing result will be written in that JSON
    file.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你设置了 `path` 属性，跟踪结果将写入该 JSON 文件。
- en: Finally, you'll find a `categories` property, where you will be able to pass
    an array of properties you want to trace.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你将找到一个 `categories` 属性，你可以在其中传递一个你想要跟踪的属性数组。
- en: 'There is no fixed list of categories, but these are the categories I find more
    relevant to us:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 没有固定的类别列表，但这些都是我认为对我们更相关的类别：
- en: Under the **rail** category, we will find many useful traces such as **domInteractive**,
    **firstPaint**, and **firstContentfulPaint**.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **rail** 类别下，我们将找到许多有用的跟踪，例如 **domInteractive**、**firstPaint** 和 **firstContentfulPaint**。
- en: If you set `screenshots` to `true`, you will find all the screenshots under
    the **disabled-by-default-devtools.screenshot** category.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将 `screenshots` 设置为 `true`，你将在 **disabled-by-default-devtools.screenshot**
    类别下找到所有屏幕截图。
- en: You will find that lots of entries will come under the **devtools.timeline**
    category. This category represents one of those items you see in the performance
    timeline.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会发现很多条目都位于 **devtools.timeline** 类别下。这个类别代表你在性能时间线中看到的项目之一。
- en: When you call the `stop` function, you will get the result in the file you passed
    to the `start` function, and, whether you passed a path or not, the `stop` function
    will return the result as a `Buffer`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `stop` 函数时，你将在你传递给 `start` 函数的文件中获取结果，无论你是否传递了路径，`stop` 函数都将返回一个 `Buffer`
    类型的结果。
- en: 'The resulting JSON will be an object with two properties: A `metadata` object
    with information about the trace and the browser, and a `traceEvents` array, with
    all the trace information.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 JSON 将是一个具有两个属性的对象：一个包含关于跟踪和浏览器信息的 `metadata` 对象，以及一个包含所有跟踪信息的 `traceEvents`
    数组。
- en: In my simple test example, `traceEvents` gave me `16,693`. That was just for
    navigating to the page. I think now you get why this can be scary for some users.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的简单测试示例中，`traceEvents` 给了我 `16,693`。那只是导航到页面的结果。我想你现在明白为什么这可能会让一些用户感到害怕。
- en: 'The shape of each trace event might vary based on the category. But you will
    find these properties:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个跟踪事件的形状可能会根据类别而变化。但你会发现这些属性：
- en: '`cat` will tell you the categories for the event, separated by commas.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat` 将告诉你事件的类别，用逗号分隔。'
- en: '`name` will give you the name of the event, as you would see it in the **Performance**
    tab.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 将给你事件的名称，就像你在 **Performance** 选项卡中看到的那样。'
- en: '`ts` will give you the tracking clock, expressed in microseconds (1 microsecond
    is 0.000001 seconds). Most events are relative to the beginning of the trace.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts` 将为你提供跟踪时钟，以微秒为单位表示（1 微秒等于 0.000001 秒）。大多数事件都是相对于跟踪开始的时间。'
- en: '`pid` is the process ID. I don''t think you will care about that.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid` 是进程 ID。我认为你不会关心那个。'
- en: '`tid` is the thread ID. You won''t care about that either.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tid` 是线程 ID。你也不会关心那个。'
- en: '`args` will give you an object with specific information for that event type.
    For instance, you will get the URL and the HTTP method of a request. For a screenshot,
    you will get the image in Base64 format.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`将为你提供一个对象，其中包含该事件类型的特定信息。例如，你将获得请求的URL和HTTP方法。对于截图，你将获得Base64格式的图像。'
- en: 'With all this information, let''s code our first contentful paint test using
    tracing values. We are going to write a test that will start the tracing, navigate
    to a page, and then evaluate the results. It would be something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些信息的基础上，让我们使用跟踪值编写我们的第一个内容渲染测试。我们将编写一个测试，该测试将启动跟踪，导航到页面，然后评估结果。它可能看起来像这样：
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have some tricks to explain here. After stopping the trace, we get the result
    and parse it. That will give us the `result` with a `traceEvents` property. As
    `ts` is based on the beginning of the trace, we need to find the `baseEvent`,
    looking for an event with the name `TracingStartedInBrowser`. Then we look for
    the event with the name `firstContentfulPaint`, and finally, we calculate the
    difference. As it's in microseconds, we need to divide it by 1,000, so we can
    compare it with our target goal of 500 ms.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一些技巧要解释。在停止跟踪后，我们得到结果并解析它。这将给我们一个带有`traceEvents`属性的`result`。由于`ts`是基于跟踪的开始，我们需要找到名为`TracingStartedInBrowser`的事件的`baseEvent`。然后我们寻找名为`firstContentfulPaint`的事件，并最终计算差异。由于它是微秒级的，我们需要将其除以1,000，以便我们可以将其与我们的目标500
    ms进行比较。
- en: Notice that in this example, our goal is 500 ms versus the 30 seconds we used
    in the Lighthouse example. This is because, by default, Lighthouse performs several
    runs emulating different conditions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，我们的目标是500 ms，而我们在Lighthouse示例中使用了30秒。这是因为，默认情况下，Lighthouse会执行多次运行，模拟不同的条件。
- en: 'Another thing we could do here is export the screenshots generated by the tracing
    tool for later analysis. We can add something like this at the end of the test:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在这里做的一件事是导出跟踪工具生成的截图，以供以后分析。我们可以在测试的末尾添加类似的内容：
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There, we are filtering screenshots events with a valid screenshot, and then
    we just write all those Base64 snapshots to the filesystem. With that, you will
    see how the page was being rendered during the loading process. You would even
    code your own first contentful paint algorithm with those images.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，我们正在通过有效的截图过滤截图事件，然后我们只需将所有这些Base64快照写入文件系统。有了这个，你将看到页面在加载过程中的渲染情况。你甚至可以用这些图像编写自己的第一个内容渲染算法。
- en: Now you might be wondering whether you should use Lighthouse or Puppeteer's
    tracing. I think there are some pros and cons to every approach. Lighthouse is
    easy to use, and as we saw, it gives us metrics that would take us lots of effort
    to build by ourselves. With Lighthouse, you just call the `lighthouse` function
    and evaluate the results. But it can be slow, even if you select only one category.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能想知道你是否应该使用Lighthouse或Puppeteer的跟踪。我认为每种方法都有其优缺点。Lighthouse易于使用，正如我们所见，它提供了我们花费大量努力才能构建的指标。使用Lighthouse，你只需调用`lighthouse`函数并评估结果。但它可能很慢，即使你只选择一个类别。
- en: On the other hand, Puppeteer's tracing can be hard to read and process, but
    if you know how to take the metric you need from the tracing result, it will be
    way faster than Lighthouse. Another important difference is that Lighthouse only
    evaluates the page load, whereas with Puppeteer's tracing, you could start the
    tracing at any moment. For instance, you could go to a page, start the tracing,
    click on a button, and then evaluate what the browser did to process that click.
    At the end of the day, it's about picking the right tool for your job.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Puppeteer的跟踪可能难以阅读和处理，但如果你知道如何从跟踪结果中获取所需的指标，它将比Lighthouse快得多。另一个重要的区别是，Lighthouse只评估页面加载，而使用Puppeteer的跟踪，你可以在任何时刻开始跟踪。例如，你可以打开一个页面，开始跟踪，点击一个按钮，然后评估浏览器为了处理该点击所做的事情。最终，这关乎选择适合你工作的正确工具。
- en: 'Lighthouse also gives us two interesting metrics: **Remove unused JavaScript**
    and **Remove unused CSS**. Let''s see how we can solve those metrics using Puppeteer.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse还给我们提供了两个有趣的指标：**移除未使用的JavaScript**和**移除未使用的CSS**。让我们看看我们如何使用Puppeteer解决这些指标。
- en: Analyzing code coverage
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析代码覆盖率
- en: In this last section, we will see how we can get code coverage using the `Coverage`
    class from Puppeteer. Code coverage is a metric that can be applied to any piece
    of code. To get the code coverage of a piece of code, you need some kind of tool
    to trace which lines of code are being executed, execute that code, and get the
    tracing result. It's like the performance tracing, but instead of measuring time,
    it measures executed lines of code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我们将了解如何使用 Puppeteer 的 `Coverage` 类来获取代码覆盖率。代码覆盖率是一个可以应用于任何代码片段的指标。要获取某段代码的代码覆盖率，你需要某种工具来跟踪哪些代码行正在被执行，执行那段代码，并获取跟踪结果。这就像性能跟踪，但不是测量时间，而是测量执行的代码行数。
- en: 'You can see the code coverage on a page on Chrome using the **Coverage** tab.
    I didn''t have that tab by default, so I needed to add it using the **More tools**
    option, as in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Chrome 的 **Coverage** 选项卡中查看页面上的代码覆盖率。我默认没有那个选项卡，所以我需要使用 **更多工具** 选项来添加它，就像下面的截图所示：
- en: '![Coverage tab'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![Coverage 选项卡'
- en: '](img/Figure_10.10_B16113.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.10_B16113.jpg)'
- en: Coverage tab
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Coverage 选项卡
- en: The **Coverage** tab works like the **Performance** tab. You need to start the
    tracing, run the page, or perform an action, then stop the tracing to get the
    results.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**Coverage** 选项卡的工作方式类似于 **Performance** 选项卡。你需要开始跟踪，运行页面，或执行操作，然后停止跟踪以获取结果。'
- en: 'The result will be something like what we see in the preceding screenshot:
    A list of resources with the total bytes of that resources and the unused bytes.
    At the bottom of the window, we can see that over 90% of the code was used (executed)
    during the tracing. That''s pretty good. We could write a test to ensure that
    we will always have a code coverage of over 90%.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于我们在前面的截图中所看到的那样：一个包含资源总字节数和未使用字节数的资源列表。在窗口底部，我们可以看到在跟踪过程中，超过90%的代码被使用（执行）了。这相当不错。我们可以编写一个测试来确保我们始终拥有超过90%的代码覆盖率。
- en: 'The JavaScript and the CSS code coverage have two sets of functions in Puppeteer.
    If you want to get the JavaScript code coverage, you need to run `startJSCoverage`
    to start the coverage and `stopJSCoverage` to stop it. `startJSCoverage` supports
    an `options` argument with two properties:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 中 JavaScript 和 CSS 代码覆盖率有两套函数。如果你想获取 JavaScript 代码覆盖率，你需要运行 `startJSCoverage`
    来开始覆盖率，并使用 `stopJSCoverage` 来停止它。`startJSCoverage` 支持一个带有两个属性的 `options` 参数：
- en: '`resetOnNavigation` is a Boolean property we can use to tell Puppeteer to start
    over with the tracing if navigation was detected.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resetOnNavigation` 是一个布尔属性，我们可以用它来告诉 Puppeteer 如果检测到导航，则重新开始跟踪。'
- en: '`reportAnonymousScripts` is a Boolean property we can use to tell Puppeteer
    to ignore, or not, dynamically generated JavaScript code.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reportAnonymousScripts` 是一个布尔属性，我们可以用它来告诉 Puppeteer 忽略或不禁用动态生成的 JavaScript
    代码。'
- en: If we want to get CSS coverage, we need to use the `startCSSCoverage` and `stopCSSCoverage`
    functions. `startCSSCoverage` also expects an `options` argument, but, in this
    case, it only has the `resetOnNavigation` property.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取 CSS 覆盖率，我们需要使用 `startCSSCoverage` 和 `stopCSSCoverage` 函数。`startCSSCoverage`
    也期望一个 `options` 参数，但在这个情况下，它只有 `resetOnNavigation` 属性。
- en: 'Once we run the coverage, both `stopCSSCoverage` and `stopJSCoverage` will
    return the same type of value. Both will return an array of objects with these
    properties:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行覆盖率，`stopCSSCoverage` 和 `stopJSCoverage` 都将返回相同类型的值。它们都将返回一个具有这些属性的对象数组：
- en: '`url` will give us the resource URL.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url` 将给我们资源 URL。'
- en: '`content` will be the CSS or the script content.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content` 将是 CSS 或脚本内容。'
- en: '`ranges`, which will contain an array of objects telling us which were the
    portion of code that has been executed. Each entry will contain two properties,
    `start` and `end`, telling us where that text range starts and ends.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges` 将包含一个对象数组，告诉我们哪些代码部分已被执行。每个条目将包含两个属性，`start` 和 `end`，告诉我们文本范围从哪里开始和结束。'
- en: 'Now we have all this information, we can write our code coverage test. Let''s
    take a look at it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有这些信息，我们可以编写我们的代码覆盖率测试。让我们来看看：
- en: '[PRE14]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start our test by starting both code coverages. We put `startJSCoverage`
    and `startCSSCoverage` inside `Promise.all`, so we wait for both coverages to
    be confirmed. Then we go to the page, and after that, we stop both coverages.
    That will give us two arrays that we can join (because they share the same shape)
    using `[...jsCoverage, ...cssCoverage]`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始测试是通过启动两个代码覆盖率。我们将 `startJSCoverage` 和 `startCSSCoverage` 放在 `Promise.all`
    中，这样我们就可以等待两个覆盖率都得到确认。然后我们转到页面，之后停止两个覆盖率。这将给我们两个可以连接（因为它们具有相同的形状）的数组，使用 `[...jsCoverage,
    ...cssCoverage]`。
- en: Once we have both coverages, we get the total size of the resource by using
    `entry.text.length`, and then we get the size of the coverage by adding the length
    of all the ranges.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了两种覆盖率，我们就可以通过使用`entry.text.length`来获取资源的总大小，然后通过添加所有范围的长度来获取覆盖率的大小。
- en: The result will give us the total code coverage of our tracing, which we will
    check whether it's over 90%.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将给我们提供我们跟踪的总代码覆盖率，我们将检查它是否超过90%。
- en: The pros and cons of this solution compared with Lighthouse are the same as
    we saw in the previous section. On one side we have Lighthouse, which gives us
    all the numbers already cooked. But here, we have more control over what we want
    to measure. This test was quite simple, but you could improve it by filtering
    out all the resources you don't want to measure. You can also download that result
    to a file and share it with your team if the test fails.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与Lighthouse相比，这个解决方案的优缺点与我们在上一节看到的是相同的。一方面我们有Lighthouse，它已经为我们准备好了所有数据。但在这里，我们对自己的测量内容有更多的控制。这个测试相当简单，但你可以通过过滤掉所有你不想测量的资源来改进它。如果测试失败，你还可以将结果下载到文件中并与你的团队分享。
- en: Now it's time to wrap up this chapter and this book.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候总结这一章和这本书了。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you get to apply performance tests in your team, you will be on a whole new
    level.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能在你的团队中应用性能测试，你将进入一个全新的层次。
- en: We started the chapter by talking about Lighthouse. We only covered the Performance
    category. But now that you know how it works, I encourage you to keep digging
    into the other categories and think about how to create tests for that. I would
    love to see more tests about accessibility.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从讨论Lighthouse开始这一章。我们只覆盖了性能类别。但现在你已经知道了它是如何工作的，我鼓励你继续深入研究其他类别，并思考如何为它们创建测试。我很乐意看到更多关于无障碍性的测试。
- en: We also learned how to use Lighthouse in our tests. That's not something you
    will see quite often. You will be able to test very complex metrics using two
    lines of code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何在测试中使用Lighthouse。这不是你经常能看到的事情。你将能够使用两行代码测试非常复杂的指标。
- en: Most developers would run away from Puppeteer's tracing results. Although what
    you can get from there is way more than what we covered, we learned the foundations
    of such a powerful tool in this chapter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者都会避开Puppeteer的跟踪结果。尽管你可以从那里得到的信息远比我们覆盖的要多，但我们在这章中学习了这样一个强大工具的基础。
- en: The size of a page is critical for performance; that's why we learned about
    code coverage and how to measure it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的尺寸对性能至关重要；这就是为什么我们学习了代码覆盖率及其测量方法。
- en: And this is also a wrap on this book. When I planned this book, my goal was
    to write a book that would cover the entire Puppeteer API, without being a reference
    book. And I think we accomplished that goal. We learned how to write high-quality
    end-to-end tests using Puppeteer and, at the same time, we covered most of the
    Puppeteer API.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是这本书的结束。当我计划这本书的时候，我的目标是写一本涵盖整个Puppeteer API的书，而不只是一本参考书。我认为我们实现了这个目标。我们学习了如何使用Puppeteer编写高质量的端到端测试，同时我们也覆盖了Puppeteer
    API的大部分内容。
- en: With this goal in mind, we covered topics that were not strictly related to
    unit testing. We talked about PDF generation and Web Scraping. We also covered
    topics that many people would run away from, such as the tracing model.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个目标，我们涵盖了与单元测试严格无关的主题。我们讨论了PDF生成和Web抓取。我们还涵盖了很多人会避开的话题，比如跟踪模型。
- en: If you read this book from cover to cover, I can assure you that you will know
    way more about Puppeteer than the average user of this library.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从头到尾阅读这本书，我可以向你保证，你将比这个库的普通用户对Puppeteer了解得多得多。
- en: But I also hope you learned more than just a Node package. In this book, we
    also learned about the foundations of the web, and how to write good tests. We
    talked about the internet ecosystem, scraping ethics, and web performance. You
    have also empowered your role. QA is more than just about testing web pages. It's
    about honoring your users by delivering high-quality software they can enjoy using.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但我也希望你们不仅仅学到了一个Node包。在这本书中，我们还学习了网络的基础知识以及如何编写好的测试。我们讨论了互联网生态系统、抓取伦理和网络性能。你们也提升了你们的角色。质量保证（QA）不仅仅是测试网页。它关乎通过提供高质量的软件来尊重用户，让他们能够享受使用。
