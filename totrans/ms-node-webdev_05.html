<html><head></head><body>
<div><h1 class="chapternumber">5</h1>
<h1 class="chaptertitle" id="_idParaDest-97">Handling HTTP Requests</h1>
<p class="normal1">The foundation of server-side web development is the ability to receive HTTP requests from clients and generate responses. In this chapter, I introduce the Node.js API for creating HTTP servers and explain how it can be used to receive and respond to requests. <em class="italic">Table 5.1</em> puts the Node.js HTTP API in context.</p>
<p class="packt_figref">Table 5.1: Putting the Node.js API in context</p>
<table class="table-container" id="table001-2">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What is it?</p>
</td>
<td class="table-cell">
<p class="normal">The <code class="inlinecode">http</code> and <code class="inlinecode">https</code> modules contain the functions and classes required to create HTTP and HTTPS servers, receive requests, and generate responses. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why is it useful?</p>
</td>
<td class="table-cell">
<p class="normal">Receiving and responding to HTTP requests is the core feature of server-side web application development. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How is it used?</p>
</td>
<td class="table-cell">
<p class="normal">Servers are created with the <code class="inlinecode">createServer</code> function, which emits events when requests are received. Callback functions are invoked to handle the request and generate a response. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">Handler functions can become complex and mix the statements that match requests with the statements that generate responses. Third-party packages, such as the Express package introduced in this chapter, build on the Node.js API to streamline request handling.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">No. The Node.js HTTP and HTTPS APIs are integral to server-side web application development. Third-party packages can make the API easier to use but are built on the same features. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 5.2</em> summarizes the chapter.</p>
<p class="packt_figref">Table 5.2: Chapter summary</p>
<table class="table-container" id="table002-2">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Listing for HTTP requests</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">createServer</code> function to create a <code class="inlinecode">Server</code> object and use the <code class="inlinecode">listen</code> method to start listening for requests.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">4</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Inspect an HTTP request</p>
</td>
<td class="table-cell">
<p class="normal">Use the features provided by the <code class="inlinecode">IncomingRequest</code> class.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">5</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Parse a request URL</p>
</td>
<td class="table-cell">
<p class="normal">Use the <code class="inlinecode">URL</code> class in the <code class="inlinecode">url</code> module.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">6</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Create an HTTP response</p>
</td>
<td class="table-cell">
<p class="normal">Use the features provided by the <code class="inlinecode">ServerResponse</code> class.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">7</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Listen for HTTPS requests</p>
</td>
<td class="table-cell">
<p class="normal">Use the features provided by the <code class="inlinecode">https</code> module.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">8, 9</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Detect HTTPS requests </p>
</td>
<td class="table-cell">
<p class="normal">Check the value of the <code class="inlinecode">socket.encrypted</code> property on the <code class="inlinecode">IncomingRequest</code> object.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">10</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Redirect insecure requests</p>
</td>
<td class="table-cell">
<p class="normal">Send a 302 header to the HTTPS port.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">11, 12</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Simplify request processing</p>
</td>
<td class="table-cell">
<p class="normal">Use a third-party router and enhanced request and response classes.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">13-19</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-98">Preparing for this chapter</h1>
<p class="normal1">In this chapter, I continue to use the <code class="inlinecode">webapp</code> project created in <em class="italic">Chapter 4</em>. To prepare for this chapter, replace the contents of the <code class="inlinecode">handler.ts</code> file in the <code class="inlinecode">src</code> folder with the code shown in <em class="italic">Listing 5.1</em>.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 5.1: Replacing the contents of the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const handler = async (req: IncomingMessage, resp: ServerResponse) =&gt; {
    resp.end("Hello, World");
};
</code></pre>
<p class="normal">Replace the contents of the <code class="inlinecode">server.ts</code> file in the <code class="inlinecode">src</code> folder with the code shown in <em class="italic">Listing 5.2</em>.</p>
<p class="packt_figref">Listing 5.2: Replacing the contents of the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import { handler } from "./handler";
const port = 5000;
const server = createServer();
server.on("request", handler);
server.listen(port);
server.on("listening", () =&gt; {
    console.log(`(Event) Server listening on port ${port}`);
});
</code></pre>
<p class="normal">Run the command shown in <em class="italic">Listing 5.3</em> in the <code class="inlinecode">webapp</code> folder to start the watcher that compiles TypeScript files and executes the JavaScript that is produced.</p>
<p class="packt_figref">Listing 5.3: Starting the project</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">The <code class="inlinecode">server.ts</code> file in the <code class="inlinecode">src</code> folder will be compiled to produce a pure JavaScript file named <code class="inlinecode">server.js</code> in the <code class="inlinecode">dist</code> folder. The JavaScript code will be executed by the Node.js runtime, which will start listening for HTTP requests. Open a web browser and request <code class="inlinecode">http://localhost:5000</code> and you will see the response shown in <em class="italic">Figure 5.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_05_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 5.1: Running the example project</p>
<h1 class="heading" id="_idParaDest-99">Listening for HTTP requests</h1>
<p class="normal1">In <em class="italic">Chapter 4</em>, I created a simple web server so that I could demonstrate the way that JavaScript code is<a id="_idIndexMarker245" class="calibre3"/> executed. In doing so, I skipped over the details of how the code worked, but now it is time to go back and dig into the details.</p>
<p class="normal">The <code class="inlinecode">createServer</code> function in the <code class="inlinecode">http</code> module is used to create <code class="inlinecode">Server</code> objects that can be used to listen for and process HTTP requests. The <code class="inlinecode">Server</code> object requires configuration before it starts listening for requests and the most useful methods and properties defined by the <code class="inlinecode">Server</code> class are described in <em class="italic">Table 5.3</em>. </p>
<p class="packt_figref">Table 5.3: Useful server methods and properties</p>
<table class="table-container" id="table003-2">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">listen(port)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method starts listening for requests on a specified port.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">close()</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method stops listening for requests. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">requestTimeout</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This property gets or sets the request timeout period, which can also be used using the configuration object passed to the <code class="inlinecode">createServer</code> function.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Once the <code class="inlinecode">Server</code> object has been configured, it emits events that denote important changes in state. The<a id="_idIndexMarker246" class="calibre3"/> most useful events are <a id="_idIndexMarker247" class="calibre3"/>described in <em class="italic">Table 5.4</em>. </p>
<p class="packt_figref">Table 5.4: Useful server events</p>
<table class="table-container" id="table004-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">listening</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This event is triggered when the server starts listening for requests. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">request</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This event is triggered when a new request is received. The callback function that handles this event is invoked with arguments that represent the HTTP request and response.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">error</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This event is triggered when there is a network error.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The use of events to invoke callback functions is typical of the JavaScript code execution model described in <em class="italic">Chapter 4</em>. The <code class="inlinecode">request</code> event will be triggered each time an HTTP request is received, and the JavaScript execution model means that only one HTTP request will be handled at a time.</p>
<p class="normal">The Node.js API often allows event handlers to be specified through other methods. The <code class="inlinecode">createServer</code> function used to create a <code class="inlinecode">Server</code> object accepts an optional function argument that is registered as a handler for the <code class="inlinecode">request</code> event, and the <code class="inlinecode">Server.listen</code> method accepts an optional function argument that is used to handle the <code class="inlinecode">listening</code> event. </p>
<p class="normal">These convenience features can be used to combine the statements that create and configure the HTTP server with the callback functions that handle the events, as shown in <em class="italic">Listing 5.4</em>.</p>
<p class="packt_figref">Listing 5.4: Using the event convenience features in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import { handler } from "./handler";
const port = 5000;
<strong class="screentext">const server = createServer(handler);</strong>
<strong class="screentext">//server.on("request", handler);</strong>
<strong class="screentext">server.listen(port,</strong>
<strong class="screentext">    () =&gt; console</strong><strong class="screentext">.log(`(Event) Server listening on port ${port}`));</strong>
<strong class="screentext">// server.on("listening", () =&gt; {</strong>
<strong class="screentext">//     console.log(`(Event) Server listening on port ${port}`);</strong>
<strong class="screentext">// });</strong>
</code></pre>
<p class="normal">This code has the <a id="_idIndexMarker248" class="calibre3"/>same effect as <em class="italic">Listing 5.2</em> but is more concise and easier to read.</p>
<h2 class="heading1" id="_idParaDest-100">Understanding the Server configuration object</h2>
<p class="normal1">The arguments for the <code class="inlinecode">createServer</code> function are a configuration object and a request-handling function. The <a id="_idIndexMarker249" class="calibre3"/>configuration object is used to change the way that requests are received, and the most useful settings are described in <em class="italic">Table 5.5</em>. </p>
<p class="packt_figref">Table 5.5: Useful createServer configuration object settings</p>
<table class="table-container" id="table005-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">IncomingMessage</code></p>
</td>
<td class="table-cell">
<p class="normal">This property specifies the class used to represent requests. The default is the <code class="inlinecode">IncomingMessage</code> class, defined in the <code class="inlinecode">http</code> module.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">ServerResponse</code></p>
</td>
<td class="table-cell">
<p class="normal">This property specifies the class used to represent responses. The default is the <code class="inlinecode">ServerResponse</code> class, defined in the <code class="inlinecode">http</code> module.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">requestTimeout</code></p>
</td>
<td class="table-cell">
<p class="normal">This property specifies the amount of time, in milliseconds, allowed for a client to send requests, after which the request times out. The default value is 300,000 milliseconds.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The configuration object can be omitted if the default values are required. The handler function is invoked when an HTTP request has been received and its parameters are objects whose types are those specified by the <code class="inlinecode">IncomingMessage</code> and <code class="inlinecode">ServerResponse</code> properties, or the default types if the configuration hasn’t been changed. The code in <em class="italic">Listing 5.4</em> omits the configuration object, which means that the default types will be used to represent the HTTP request <a id="_idIndexMarker250" class="calibre3"/>and response when the handler function for the request event is invoked, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
export const handler = async (<strong class="screentext">req: IncomingMessage, resp: ServerResponse</strong>) =&gt; {
    resp.end("Hello, World");
};
...
</code></pre>
<p class="normal">Later examples in this chapter demonstrate using different types, but the default representations of the HTTP request and response provide all the features needed to process HTTP, as explained in the following sections.</p>
<h1 class="heading" id="_idParaDest-101">Understanding HTTP requests</h1>
<p class="normal1">Node.js represents HTTP requests using the <code class="inlinecode">IncomingMessage</code> class, which is defined in the <code class="inlinecode">http</code> module. The<a id="_idIndexMarker251" class="calibre3"/> four main building blocks of an HTTP request are: </p>
<ul class="calibre4">
<li class="bulletlist">The HTTP method, which describes the operation the client wants to perform.</li>
<li class="bulletlist1">The URL, which identifies the resource the request should be applied to.</li>
<li class="bulletlist1">The headers, which provide additional information about the request and the capabilities of the client.</li>
<li class="bulletlist1">The request body, which provides the data required for the requested operation.</li>
</ul>
<p class="normal">The <code class="inlinecode">IncomingMessage</code> class provides <a id="_idIndexMarker252" class="calibre3"/>access to all of these building blocks, allowing them to be inspected so the server can generate a suitable response. <em class="italic">Table 5.6</em> lists the properties provided for the first three request building blocks, and I explain how to deal with the request body in <em class="italic">Chapter 6</em>. </p>
<p class="packt_figref">Table 5.6: Useful IncomingMessage properties </p>
<table class="table-container" id="table006-1">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">headers</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns an <code class="inlinecode">IncomingHttpHeaders</code> object, which defines properties for common headers and can also be used as a key/value object that maps the names of the headers in the request to the header values. The headers are normalized, as described below.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">headersDistinct</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a key/value object that maps the names of the headers in the request to the header values. The values are normalized, as described below this table.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">httpVersion</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">string</code> value containing the version of HTTP used in the request. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">method</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">string</code> value containing the HTTP method specified by the request. This value may be <code class="inlinecode5">undefined.</code></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">url</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">string</code> value containing the request URL. This value may be <code class="inlinecode">undefined</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">socket</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns an object that represents the network socket used to receive the connection, which is useful when detecting HTTPS requests, as demonstrated in the <em class="italic">Detecting HTTPS requests</em> section.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">HTTP headers can be difficult to work <a id="_idIndexMarker253" class="calibre3"/>with and the <code class="inlinecode">headers</code> and <code class="inlinecode">headersDistinct</code> properties normalize headers so that they are easier to use. Some HTTP headers should only appear once in a request, so Node.js removes<a id="_idIndexMarker254" class="calibre3"/> duplicate values. Other headers can have multiple values, and these are concatenated into a single <code class="inlinecode">string</code> value by the <code class="inlinecode">headers</code> property and into an array of strings by the <code class="inlinecode">headersDistinct</code> property. The exception is the <code class="inlinecode">set-cookie</code> header, which is always presented as a <code class="inlinecode">string</code> array. (I describe how cookies are used in detail in <em class="italic">Part 2</em>.)</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">The <code class="inlinecode">IncomingRequest</code> class also defines the <code class="inlinecode">rawHeaders</code> property, which provides access to the headers as they were received, with no normalization. This property can be useful if you need to perform custom normalization, but the <code class="inlinecode">headers</code> and <code class="inlinecode">headersDistinct</code> properties are more useful for mainstream development projects.</p>
</div>
<p class="normal">As a rule of thumb, the <code class="inlinecode">headers</code> property is more useful for displaying or logging headers, while the <code class="inlinecode">headersDistinct</code> property is more useful when using headers to decide what kind of response to produce. <em class="italic">Listing 5.5</em> updates the example to<a id="_idIndexMarker255" class="calibre3"/> log the details of the request to the Node.js console.</p>
<p class="packt_figref">Listing 5.5: Logging request details in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
export const handler = async (req: IncomingMessage, resp: ServerResponse) =&gt; {
    <strong class="screentext">console.log(`---- HTTP Method: ${req.method}, URL: ${req.url}`);</strong>
<strong class="screentext">    console.log(`host: ${req.headers.host}`);</strong>
<strong class="screentext">    console</strong><strong class="screentext">.log(`accept: ${req.headers.accept}`);</strong>
<strong class="screentext">    console.log(`user-agent: ${req.headers["user-agent"]}`)</strong>
    resp.end("Hello, World");
};
</code></pre>
<p class="normal">This example writes out the HTTP method, the request URL, and three headers: the <code class="inlinecode">host</code> header, which specifies the hostname and port to which the request was sent; the <code class="inlinecode">accept</code> header, which specifies the formats the client is willing to accept in the response; and the <code class="inlinecode">user-agent</code> header, which identifies the client.</p>
<p class="normal">I used the <code class="inlinecode">headers</code> property in <em class="italic">Listing 5.5</em>, which allows me to access headers using properties that correspond to the header name, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
console.log(`host: ${<strong class="screentext">req.headers.host</strong>}`);
...
</code></pre>
<p class="normal">Not all HTTP header names can be used as JavaScript property names, and there is no property for the <code class="inlinecode">user-agent</code> header because JavaScript property names cannot contain hyphens. Instead, I have to access the <code class="inlinecode">user-agent</code> header by specifying the property name as a string, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
console.log(`user-agent: ${<strong class="screentext">req.headers["user-agent"]</strong>}`)
...
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000</code> and you will see output similar to the following, although you may see different values for the headers (and I have elided <a id="_idIndexMarker256" class="calibre3"/>the header values for brevity):</p>
<pre class="programlisting"><code class="hljs-code">...
---- HTTP Method: GET, URL: /
host: localhost:5000
accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,...
user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (...
---- HTTP Method: GET, URL: /favicon.ico
host: localhost:5000
accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (...
...
</code></pre>
<p class="normal">This output shows two requests because browsers will often request <code class="inlinecode">/favicon.ico</code>, which is used as the icon for the tab. You may not see the <code class="inlinecode">favicon.ico</code> request if you recently used your browser for the examples in the previous chapter, where a <code class="inlinecode">404 Not Found</code> response was produced. You can clear your browser’s cache if you want to see both requests, but it isn’t important for the examples that follow.</p>
<h2 class="heading1" id="_idParaDest-102">Parsing URLs</h2>
<p class="normal1">Node.js provides the <code class="inlinecode">URL</code> class in the <code class="inlinecode">url</code> module to parse URLs into their parts, making it easier to inspect <a id="_idIndexMarker257" class="calibre3"/>URLs to make decisions about what kind of response will be sent. URLs are parsed by creating a new <code class="inlinecode">URL</code> object and reading the properties described in <em class="italic">Table 5.7</em>. </p>
<p class="packt_figref">Table 5.7: Useful URL properties</p>
<table class="table-container" id="table007">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">hostname</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">string</code> containing the URL hostname component.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">pathname</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">string</code> containing the URL pathname component.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">port</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">string</code> containing the URL port component. The value will be an empty string if the request has been made to the default port for the URL’s protocol (such as port <code class="inlinecode">80</code> for unsecured HTTP requests).</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">protocol</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">string</code> containing the URL protocol component.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">search</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">string</code> containing the entire query portion of the URL.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">searchParams</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns a <code class="inlinecode">URLSeachParams</code> object that provides key/value access to the query portion of the URL.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Listing 5.6</em> creates a new URL object to parse the request URL.</p>
<p class="packt_figref">Listing 5.6: Parsing a URL in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { URL } from "url";
export const handler = async (req: IncomingMessage, resp: ServerResponse) =&gt; {
    console.log(`---- HTTP Method: ${req.method}, URL: ${req.url}`);
    <strong class="screentext">// console.log(`host: ${req.headers.host}`);</strong>
<strong class="screentext">    // console.log(`accept: ${req.headers.accept}`);</strong>
<strong class="screentext">    // console.log(`user-agent: ${req.headers["user-agent"]}`)</strong>
<strong class="screentext">    const parsedURL = new </strong><strong class="screentext">URL(req.url ?? "", `http://${req.headers.host}`);</strong>
<strong class="screentext">    console.log(`protocol: ${parsedURL.protocol}`);</strong>
<strong class="screentext">    console.</strong><strong class="screentext">log(`hostname: ${parsedURL.hostname}`);</strong>
<strong class="screentext">    console.log(`port: ${parsedURL.port}`);</strong>
<strong class="screentext">    console.log(`pathname: ${parsedURL.pathname}</strong><strong class="screentext">`);</strong>
<strong class="screentext">    parsedURL.searchParams.forEach((val, key) =&gt; {</strong>
<strong class="screentext">        console.log(`Search param: ${key}: ${val}`)</strong>
<strong class="screentext">    });</strong>
   
    resp.end("Hello, World");
};
</code></pre>
<p class="normal">Creating a <code class="inlinecode">URL</code> object to parse a URL requires a little work. The <code class="inlinecode">IncomingMessage.url</code> property returns a relative URL, which the <code class="inlinecode">URL</code> class constructor will accept as an<a id="_idIndexMarker258" class="calibre3"/> argument, but only if the base part of the URL (the protocol, hostname, and port) is specified as a second argument. The hostname and port can be obtained from the <code class="inlinecode">host</code> request header, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
const parsedURL = new URL(req.url ?? "", `http://${<strong class="screentext">req.headers.host</strong>}`);
...
</code></pre>
<p class="normal">The missing piece is the protocol. The example only accepts regular unsecured HTTP requests so I can specify <code class="inlinecode">http</code> as the protocol, safe in the knowledge that it will be correct. I will demonstrate how to determine the protocol properly when I demonstrate the use of HTTPS later in the chapter.</p>
<p class="normal">The properties described in <em class="italic">Table 5.7</em> can be used to inspect the individual parts of the URL once the <code class="inlinecode">URL</code> object has been created, and the example writes out the <code class="inlinecode">protocol</code>, <code class="inlinecode">hostname</code>, <code class="inlinecode">port</code>, and <code class="inlinecode">pathname</code> values. </p>
<p class="normal">The <code class="inlinecode">URL</code> class parses the query section of the URL and presents it as a set of key/value pairs and these are also written out. Use a browser to request the following URL: <code class="inlinecode">http://localhost:5000/myrequest?first=Bob&amp;last=Smith</code></p>
<p class="normal">This URL has a path and a query, and you will see output similar to the following when the URL is parsed:</p>
<pre class="programlisting1"><code class="hljs-con">---- HTTP Method: GET, URL: /myrequest?first=Bob&amp;last=Smith
protocol: http:
hostname: localhost
port: 5000
pathname: /myrequest
Search param: first: Bob
Search param: last: Smith
---- HTTP Method: GET, URL: /favicon.ico
protocol: http:
hostname: localhost
port: 5000
pathname: /favicon.ico
</code></pre>
<p class="normal">The output shows that the browser has sent a second request, for <code class="inlinecode">/favicon.ico</code>, in addition to <a id="_idIndexMarker259" class="calibre3"/>the URL that was explicitly requested.</p>
<h1 class="heading" id="_idParaDest-103">Understanding HTTP responses</h1>
<p class="normal1">The purpose of inspecting an<a id="_idIndexMarker260" class="calibre3"/> HTTP request is to determine what kind of response is required. Responses are produced using the features provided by the <code class="inlinecode">ServerResponse</code> class, the most useful of which are described in <em class="italic">Table 5.8</em>. </p>
<p class="packt_figref">Table 5.8: Useful ServerResponse members </p>
<table class="table-container" id="table008">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">sendDate</code></p>
</td>
<td class="table-cell">
<p class="normal">This <code class="inlinecode">boolean</code> property determines whether Node.js automatically generates the <code class="inlinecode">Date</code> header and adds it to the response. The default is <code class="inlinecode">true</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">setHeader(name, value)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method sets a response header using the specified name and value.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">statusCode</code></p>
</td>
<td class="table-cell">
<p class="normal">This <code class="inlinecode">number</code> property is used to set the response status code.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">statusMessage</code></p>
</td>
<td class="table-cell">
<p class="normal">This <code class="inlinecode">string</code> property is used to set the response status message.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">writeHead(code, msg, headers)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method is used to set the status code and, optionally, the status message and response headers. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">write(data)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method writes data to the response body, which is expressed as a <code class="inlinecode">string</code> or a <code class="inlinecode">Buffer</code>. This method accepts optional arguments that specify the encoding for the data and a callback function that is invoked when the operation is complete.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">end()</code></p>
</td>
<td class="table-cell">
<p class="normal">This method tells Node.js that the response is complete and can be sent to the client. The method can be invoked with an optional <code class="inlinecode">data</code> argument, which will be added to the response body, an encoding for the data, and a callback function that will be invoked when the response has been sent.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The basic approach to generating a response is to set the status code and status message, define any headers that will help the client process the response, write the data<a id="_idIndexMarker261" class="calibre3"/> for the body – if there is one – and then send the response to the client.</p>
<p class="normal"><em class="italic">Listing 5.7</em> inspects the requests that are received to determine how the features provided by the <code class="inlinecode">ServerResponse</code> class are used to create a response.</p>
<p class="packt_figref">Listing 5.7: Generating HTTP responses in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { URL } from "url";
export const handler = async (req: IncomingMessage, resp: ServerResponse) =&gt; {
    <strong class="screentext">const</strong><strong class="screentext"> parsedURL = new URL(req.url ?? "", `http://${req.headers.host}`);</strong>
<strong class="screentext">    if (req.method !== "GET" || parsedURL.pathname</strong><strong class="screentext"> == "/favicon.ico") {</strong>
<strong class="screentext">        resp.writeHead(404, "Not Found");</strong>
<strong class="screentext">        resp.end();</strong>
<strong class="screentext">        return;</strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        resp.writeHead(200, "OK"</strong><strong class="screentext">);</strong>
<strong class="screentext">        if (!parsedURL.searchParams.has("keyword")) {</strong>
<strong class="screentext">            resp.write("Hello, HTTP");</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            resp.write(`Hello, ${parsedURL.searchParams.get("keyword"</strong><strong class="screentext">)}`);</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        resp.end();</strong>
<strong class="screentext">        return;       </strong>
<strong class="screentext">    }</strong>
};
</code></pre>
<p class="normal">This example generates three different responses. For requests that don’t specify the HTTP GET method or request <code class="inlinecode">/favicon.ico</code>, the status code is set to 404, which tells the browser the requested resource doesn’t exist, the human-readable status message is set to <code class="inlinecode">Not Found</code>, and the <code class="inlinecode">end</code> method is called to complete the request.</p>
<p class="normal">For all other requests, the status code is set to 200, indicating a successful response and the status message is set to <code class="inlinecode">OK</code>. The query component of the request URL is checked to see if there is a <code class="inlinecode">keyword</code> parameter and, if there is, the value is included in the response body.</p>
<p class="normal">Notice that I use the <code class="inlinecode">return</code> keyword after calling the <code class="inlinecode">end</code> method. This is not a requirement, but it is an error to set headers or write data after the <code class="inlinecode">end</code> method has been called, and<a id="_idIndexMarker262" class="calibre3"/> explicitly returning from the function avoids this problem.</p>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000/favicon.ico</code>, <code class="inlinecode">http://localhost:5000?keyword=World</code>, and <code class="inlinecode">http://localhost:5000</code> and you will see the responses shown in <em class="italic">Figure 5.2</em>. (The browser usually requests the <code class="inlinecode">favicon.ico</code> file behind the scenes, but requesting it explicitly makes it easier to see the <code class="inlinecode">HTTP 404</code> response.)</p>
<figure class="mediaobject"><img alt="" src="img/B21959_05_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 5.2: Generating HTTP responses</p>
<h1 class="heading" id="_idParaDest-104">Supporting HTTPS requests</h1>
<p class="normal1">Most web applications use HTTPS, where HTTP requests are sent over an encrypted network connection using the TLS/SSL protocol. Using HTTPS ensures that the request and response cannot be inspected as they traverse public networks.</p>
<p class="normal">Supporting SSL requires a <a id="_idIndexMarker263" class="calibre3"/>certificate that establishes the identity of the server and is used as the basis for the encryption that secures HTTPS requests. For this chapter, I am going to use a self-signed certificate, which is sufficient for development and testing, but should not be used for deployment. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">See <a href="https://letsencrypt.org" class="calibre3">https://letsencrypt.org</a> if you want a certificate for deployment. The Let’s Encrypt service is supported by a non-profit organization and offers free certificates suitable for use with HTTPS.</p>
</div>
<h2 class="heading1" id="_idParaDest-105">Creating the self-signed certificate</h2>
<p class="normal1">The easiest way to<a id="_idIndexMarker264" class="calibre3"/> create a self-signed certificate is to use the OpenSSL package, which is an open-source <a id="_idIndexMarker265" class="calibre3"/>toolkit for security-related tasks. The OpenSSL project can be found at <a href="https://www.openssl.org" class="calibre3">https://www.openssl.org</a> and OpenSSL is part of many popular Linux distributions. A list of binaries and installers, including installers for Windows, can be found at <a href="https://wiki.openssl.org/index.php/binaries" class="calibre3">https://wiki.openssl.org/index.php/binaries</a>. </p>
<p class="normal">Alternatively, the Git client includes OpenSSL in the <code class="inlinecode">usr/bin</code> folder (<code class="inlinecode">C:\Program Files\Git\usr\bin</code> on Windows), which can be used to create self-signed certificates without needing to install the OpenSSL package.</p>
<p class="normal">Ensure that the OpenSSL executable is in your command prompt path and run the command shown in <em class="italic">Listing 5.8</em> in the <code class="inlinecode">webapp</code> folder, entering the entire command on one line.</p>
<p class="packt_figref">Listing 5.8: Generating a self-signed certificate</p>
<pre class="programlisting1"><code class="hljs-con">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes
</code></pre>
<p class="normal">This command <a id="_idIndexMarker266" class="calibre3"/>prompts for the details that will be included in the certificate. Press the <em class="italic">Enter</em> key to select<a id="_idIndexMarker267" class="calibre3"/> the default value for each option:</p>
<pre class="programlisting1"><code class="hljs-con">...
Country Name (2 letter code) [AU]:
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:
...
</code></pre>
<p class="normal">The details don’t matter because the certificate will be used only for development. When the command completes, there will be two new files in the <code class="inlinecode">webapp</code> folder: the <code class="inlinecode">cert.pem</code> file (which contains the self-signed certificate) and the <code class="inlinecode">key.pem</code> file (which contains the private key for the certificate).</p>
<h2 class="heading1" id="_idParaDest-106">Handling HTTPS requests</h2>
<p class="normal1">The next step is to use the <a id="_idIndexMarker268" class="calibre3"/>API provided by Node.js to receive HTTPS requests, as shown in <em class="italic">Listing 5.9</em>.</p>
<p class="packt_figref">Listing 5.9: Handling HTTPS requests in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import { handler } from "./handler";
<strong class="screentext">import { createServer as createHttpsServer } from "https";</strong>
<strong class="screentext">import { readFileSync } from</strong><strong class="screentext"> "fs";</strong>
const port = 5000;
<strong class="screentext">const https_port = 5500;</strong>
const server = createServer(handler);
server.listen(port,
    () =&gt; console.log(`(Event) Server listening on port ${port}`));
<strong class="screentext">const httpsConfig = {</strong>
<strong class="screentext">    key: readFileSync("key.pem"),</strong>
<strong class="screentext">    cert: readFileSync</strong><strong class="screentext">("cert.pem")</strong>
<strong class="screentext">};   </strong>
<strong class="screentext">const httpsServer = createHttpsServer(httpsConfig, handler);</strong>
<strong class="screentext">httpsServer.listen(https_port,</strong>
<strong class="screentext">    () =&gt; console.log(`HTTPS Server listening on port ${https_port}</strong><strong class="screentext">`));</strong>
</code></pre>
<p class="normal">The process for receiving <a id="_idIndexMarker269" class="calibre3"/>HTTPS requests is similar to regular HTTP, to the extent that the function for creating an HTTPS server is named <code class="inlinecode">createServer</code>, which is the same name used for HTTP. To use both versions of the <code class="inlinecode">createServer</code> function in the same code file, I have used an alias in the <code class="inlinecode">import</code> statement, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
import { createServer <strong class="screentext">as createHttpsServer</strong> } from "https";
...
</code></pre>
<p class="normal">This statement imports the <code class="inlinecode">createServer</code> function from the <code class="inlinecode">https</code> module and the <code class="inlinecode">as</code> keyword is used to assign a name that doesn’t conflict with other imports. In this case, the name I have chosen is <code class="inlinecode">createHttpsServer</code>.</p>
<p class="normal">A configuration object is required to specify the certificate files that were created in the previous section with properties named <code class="inlinecode">key</code> and <code class="inlinecode">cert</code>: </p>
<pre class="programlisting"><code class="hljs-code">...
const httpsConfig = {
    <strong class="screentext">key</strong>: readFileSync("key.pem"),
    <strong class="screentext">cert</strong>: readFileSync("cert.pem")
};
...
</code></pre>
<p class="normal">The <code class="inlinecode">key</code> and <code class="inlinecode">cert</code> properties can be assigned <code class="inlinecode">string</code> or <code class="inlinecode">Buffer</code> values. I use the <code class="inlinecode">readFileSync</code> functions from the <code class="inlinecode">fs</code> module to read the contents of the <code class="inlinecode">key.pem</code> and <code class="inlinecode">cert.pem</code> files, which produces <code class="inlinecode">Buffer</code> values that contain byte arrays.</p>
<div><p class="normal"><strong class="screentext">Understanding synchronous file reads</strong></p>
<p class="normal">In <em class="italic">Chapter 4</em>, I explained that it can make sense to use blocking operations when you know that there is no other work to be performed by the main thread. In this case, I need to read the contents of the <code class="inlinecode">key.pem</code> and <code class="inlinecode">cert.pem</code> files as part of the application startup. There is little benefit to using a callback or a promise because I need the contents of those files to configure Node.js to listen for HTTPS requests and using non-blocking operations produces code like this:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">...</code>
<code class="inlinecode2">readFile("key.pem", (err, keyBuffer) =&gt; {</code>
<code class="inlinecode2">    readFile("cert.pem", (err, certBuffer) =&gt; {</code>
<code class="inlinecode2">        const server = createServer(handler);</code>
<code class="inlinecode2"> </code>
<code class="inlinecode2">        server.listen(port,</code>
<code class="inlinecode2">            () =&gt; console.log(`HTTP Server listening on port ${port}`));</code>
<code class="inlinecode2"> </code>
<code class="inlinecode2">        const httpsServer = createHttpsServer({</code>
<code class="inlinecode2">            key: keyBuffer, cert: certBuffer           </code>
<code class="inlinecode2">        }, handler);</code>
<code class="inlinecode2"> </code>
<code class="inlinecode2">        httpsServer.listen(https_port,</code>
<code class="inlinecode2">            () =&gt; console.log(</code>
<code class="inlinecode2">                `HTTPS Server listening on port ${https_port}`));       </code>
<code class="inlinecode2">    });</code>
<code class="inlinecode2">});</code>
<code class="inlinecode2">...</code>
</code></pre>
<p class="normal">This code shows you <em class="italic">can</em> read the files using the non-blocking <code class="inlinecode">readFile</code> function, but the nested callbacks are harder to make sense of. Promises don’t help either because the <code class="inlinecode">await</code> keyword can only be used within functions, which means the <code class="inlinecode">then</code> syntax demonstrated in <em class="italic">Chapter 4</em> must be used.</p>
<p class="normal">It is important to avoid blocking the main thread in almost every situation, but there are a few occasions when it doesn’t matter, and non-blocking features are less useful.</p>
</div>
<p class="normal">There are many <a id="_idIndexMarker270" class="calibre3"/>configuration options available, described at <a href="https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener" class="calibre3">https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener</a>, but the <code class="inlinecode">key</code> and <code class="inlinecode">cert</code> options are enough to get started. The configuration object is passed to the <code class="inlinecode">createServer</code> function, which I have aliased as <code class="inlinecode">createHttpsServer</code> in this example, and the <code class="inlinecode">listen</code> method is called on the result to start listening for HTTPS requests:</p>
<pre class="programlisting"><code class="hljs-code">...
const httpsServer = <strong class="screentext">createHttpsServer</strong>(httpsConfig, handler);
httpsServer.<strong class="screentext">listen</strong>(https_port,
    () =&gt; console.log(`HTTPS Server listening on port ${https_port}`));
...
</code></pre>
<p class="normal">Open a web browser and request <code class="inlinecode">https://localhost:5500</code>, which will send an HTTPS request to the port on which Node.js has been configured to listen. Browsers will display warnings for self-signed certificates, and you will typically have to confirm you want to proceed, as shown in <em class="italic">Figure 5.3</em>, which shows the warning presented by Chrome.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_05_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 5.3: Accepting a self-signed certificate</p>
<p class="normal">Node.js is still listening for regular HTTP requests on port <code class="inlinecode">5000</code>, which you can confirm by requesting <code class="inlinecode">http://localhost:5000</code>.</p>
<h2 class="heading1" id="_idParaDest-107">Detecting HTTPS requests</h2>
<p class="normal1">The Node.js API uses the <code class="inlinecode">IncomingMessage</code> and <code class="inlinecode">ServerResponse</code> classes for both HTTP and HTTPS requests, which means that the same handler function can be used for both request types. However, it can <a id="_idIndexMarker271" class="calibre3"/>be useful to know which kind of request is being processed so that different responses can be generated, as shown in <em class="italic">Listing 5.10</em>. </p>
<p class="packt_figref">Listing 5.10: Detecting HTTPS requests in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">import { TLSSocket } from "tls";</strong>
import { URL } from "url";
<strong class="screentext">export const isHttps = (req: IncomingMessage) : boolean =&gt; {</strong>
<strong class="screentext">    return req.socket instanceof TLSSocket</strong><strong class="screentext"> &amp;&amp; req.socket.encrypted;</strong>
<strong class="screentext">}</strong>
export const handler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
<strong class="screentext">    const protocol = isHttps(req) ? "https" : "http"</strong><strong class="screentext">;</strong>
<strong class="screentext">    const parsedURL =</strong>
<strong class="screentext">        new URL(req.url ?? "", `${protocol}://${req.headers.host}`);</strong>
    if (req.method !== "GET" || parsedURL.pathname == "/favicon.ico") {
        resp.writeHead(404, "Not Found");
        resp.end();
        return;
    } else {
        resp.writeHead(200, "OK");
        if (!parsedURL.searchParams.has("keyword")) {
            <strong class="screentext">resp.write(`Hello, ${protocol.toUpperCase()}`);</strong>
        } else {
            resp.write(`Hello, ${parsedURL.searchParams.get("keyword")}`);           
        }
        resp.end();
        return;       
    }
};
</code></pre>
<p class="normal">The <code class="inlinecode">socket</code> property defined by the <code class="inlinecode">IncomingMessage</code> class will return an instance of the <code class="inlinecode">TLSSocket</code> class for secure requests and this class defines an <code class="inlinecode">encrypted</code> property that always returns <code class="inlinecode">true</code>. Checking if this property exists allows HTTPS and HTTP <a id="_idIndexMarker272" class="calibre3"/>connections to be identified so that different responses can be produced.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">A common deployment pattern for Node.js is to use a proxy that receives HTTPS requests from clients and fans them out to Node.js servers using plain HTTP. In this situation, you can usually check the <code class="inlinecode">X-Forwarded-Proto</code> request header, which proxies use to pass on details of the encryption used by the client. See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto" class="calibre3">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto</a> for details.</p>
</div>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000</code> and <code class="inlinecode">https://localhost:5500</code> and you will see the responses shown in <em class="italic">Figure 5.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_05_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 5.4: Identifying HTTPS requests</p>
<h2 class="heading1" id="_idParaDest-108">Redirecting insecure requests</h2>
<p class="normal1">HTTPS has become the preferred <a id="_idIndexMarker273" class="calibre3"/>way to offer web functionality and it is common practice to respond to regular HTTP requests with a response that directs the client to use HTTPS instead, as shown in <em class="italic">Listing 5.11</em>. </p>
<p class="packt_figref">Listing 5.11: Redirecting HTTP requests in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { TLSSocket } from "tls";
import { URL } from "url";
<strong class="screentext">export const isHttps = (req: IncomingMessage) : boolean</strong><strong class="screentext"> =&gt; {</strong>
<strong class="screentext">    return req.socket instanceof TLSSocket &amp;&amp; req.socket.encrypted;</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export const redirectionHandler</strong>
<strong class="screentext">        = (</strong><strong class="screentext">req: IncomingMessage, resp: ServerResponse) =&gt; {</strong>
<strong class="screentext">    resp.writeHead(302, {</strong>
<strong class="screentext">        "Location": "https://localhost:5500"</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    resp.end();</strong>
}
export const handler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    // ...statements omitted for brevity...
};
</code></pre>
<p class="normal">The new handler uses the <code class="inlinecode">writeHead</code> method to set the status code to <code class="inlinecode">302</code>, which denotes a<a id="_idIndexMarker274" class="calibre3"/> redirection, and sets the <code class="inlinecode">Location</code> header, which specifies the URL the browser should request instead. <em class="italic">Listing 5.12</em> applies the new handler so that it is used to generate responses for all HTTP requests.</p>
<p class="packt_figref">Listing 5.12: Applying a handler in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
<strong class="screentext">import { handler, redirectionHandler } from</strong><strong class="screentext"> "./handler";</strong>
import { createServer as createHttpsServer } from "https";
import { readFileSync } from "fs";
const port = 5000;
const https_port = 5500;
<strong class="screentext">const server = createServer(redirectionHandler);</strong>
server.listen(port,
    () =&gt; console.log(`(Event) Server listening on port ${port}`));
const httpsConfig = {
    key: readFileSync("key.pem"),
    cert: readFileSync("cert.pem")
};   
const httpsServer = createHttpsServer(httpsConfig, handler);
httpsServer.listen(https_port,
    () =&gt; console.log(`HTTPS Server listening on port ${https_port}`));
</code></pre>
<p class="normal">If you use the browser to request <code class="inlinecode">http://localhost:5000</code>, the response sent by the new handler will cause the browser to request <code class="inlinecode">https://localhost:5500</code>. If you examine the network connections made by the browser in the <em class="italic">F12</em> developer tools window, you will see the redirection response and the <a id="_idIndexMarker275" class="calibre3"/>subsequent <a id="_idIndexMarker276" class="calibre3"/>HTTPS request, as shown in <em class="italic">Figure 5.5</em>.</p>
<div><p class="normal"><strong class="screentext">Using HTTP Strict Transport Security (HSTS)</strong></p>
<p class="normal">Redirecting HTTP requests to an HTTPS URL means that the initial communication between the client and server is unencrypted, which presents the potential for the HTTP request to be hijacked by a man-in-the-middle attack that redirects clients to a malicious URL instead. The <strong class="screentext">HTTP Strict Transport Security</strong> (<strong class="screentext">HSTS</strong>) header can be used to tell browsers not to only use HTTPS requests for a domain. See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security" class="calibre3">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security</a> for details. </p>
</div>
<figure class="mediaobject"><img alt="" src="img/B21959_05_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 5.5: Redirecting HTTP requests</p>
<div><p class="normal"><strong class="screentext">Understanding HTTP/2</strong></p>
<p class="normal">All the examples in this chapter use HTTP/1.1, which tends to be the default for Node.js web application development. </p>
<p class="normal">HTTP/2 is an update to the HTTP protocol that is intended to improve performance. HTTP/2 uses a single network connection to interleave multiple requests from the client, sends headers in a compact binary format, and allows the server to “push” content to the client before it is requested. Node.js provides support for HTTP/2 in the <code class="inlinecode">http2</code> module and even includes a compatibility API that uses the approach shown in this chapter to handle HTTP/1.1 and HTTP/2 requests with the same code. (See <a href="https://nodejs.org/dist/latest-v20.x/docs/api/http2.html" class="calibre3">https://nodejs.org/dist/latest-v20.x/docs/api/http2.html</a> for details.)</p>
</div>
<div><p class="normal">But HTTP/2 isn’t an automatic choice for Node.js projects, even though it is more efficient. That’s because HTTP/2 benefits applications that have a large volume of requests, and applications of that size use a proxy to receive requests and fan them out to multiple Node.js servers. The proxy receives HTTP/2 requests from clients but communicates with Node.js using HTTP/1.1 requests because the HTTP/2 features don’t have much impact inside the data center. You can see an example of this type of deployment in <em class="italic">Part 3</em> of this book.</p>
<p class="normal">For applications that don’t use a proxy, the volume of requests is small enough that the efficiencies of HTTP/2 don’t justify the additional complexity that HTTP/2 adds to development, such as requiring encryption for all requests.</p>
<p class="normal">Most Node.js applications still use HTTP/1.1 and you can see this reflected in the way that open-source packages for Node.js, such as the Express package I use in the next section, remain hugely popular even though they don’t support HTTP/2.</p>
</div>
<h1 class="heading" id="_idParaDest-109">Using third-party enhancements</h1>
<p class="normal1">The API that Node.js provides<a id="_idIndexMarker277" class="calibre3"/> for HTTP and HTTPS is comprehensive but can produce verbose code that is difficult to read and maintain. One of the joys of JavaScript development is the huge range of open-source packages that are available and there are many packages that are built on the Node.js API to simplify request handling.</p>
<p class="normal">The most popular of these packages is Express. Run the commands shown in <em class="italic">Listing 5.13</em> in the <code class="inlinecode">webapp</code> folder to install the Express package and the TypeScript types for Express in the example project. </p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">Don’t worry if you don’t like the way that Express works because there are plenty of other packages available that do similar things. A quick web search for Express alternatives will give you several options to consider. Bear in mind when choosing a package that, as I noted in <em class="italic">Chapter 2</em>, not all JavaScript packages receive long-term support from their creators, and it is worth considering how widely a package has been adopted before using it in a project.</p>
</div>
<p class="packt_figref">Listing 5.13: Installing the Express package</p>
<pre class="programlisting1"><code class="hljs-con">npm install express@4.18.2
npm install --save-dev @types/express@4.17.20
</code></pre>
<p class="normal">Express has many features, which are described in detail at <a href="https://expressjs.com" class="calibre3">https://expressjs.com</a>, but the two that are most useful are the request router and the enhanced request/response types, both of which are described in the sections that follow.</p>
<h2 class="heading1" id="_idParaDest-110">Using the Express router</h2>
<p class="normal1">Request handler functions that use the Node.js API mix the statements that inspect requests with the code<a id="_idIndexMarker278" class="calibre3"/> that generates<a id="_idIndexMarker279" class="calibre3"/> responses. A new branch of code is required every time a new URL is supported by the application, as shown in <em class="italic">Listing 5.14</em>. </p>
<p class="packt_figref">Listing 5.14: Supporting a new URL in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { TLSSocket } from "tls";
import { URL } from "url";
export const isHttps = (req: IncomingMessage) : boolean =&gt; {
    return req.socket instanceof TLSSocket &amp;&amp; req.socket.encrypted;
}
export const redirectionHandler
        = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    resp.writeHead(302, {
        "Location": "https://localhost:5500"
    });
    resp.end();
}
export const handler = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    const protocol = isHttps(req) ? "https" : "http";
    const parsedURL
        = new URL(req.url ?? "", `${protocol}://${req.headers.host}`);
    if (req.method !== "GET" || parsedURL.pathname == "/favicon.ico") {
        resp.writeHead(404, "Not Found");
        resp.end();
        return;
    } else {
        resp.writeHead(200, "OK");
        <strong class="screentext">if (parsedURL.pathname == "/newurl") {</strong>
<strong class="screentext">            resp.write("Hello, New URL");</strong>
<strong class="screentext">        } else if (!parsedURL.searchParams.</strong><strong class="screentext">has("keyword")) {</strong>
            resp.write(`Hello, ${protocol.toUpperCase()}`);
        } else {
            resp.write(`Hello, ${parsedURL.searchParams.get("keyword")}`);           
        }
        resp.end();
        return;       
    }
};
</code></pre>
<p class="normal">Each new addition makes the code more complex and increases the chances of a coding error that <a id="_idIndexMarker280" class="calibre3"/>either doesn’t match the right requests or generates the wrong response.</p>
<p class="normal">The Express <em class="italic">router</em> solves this <a id="_idIndexMarker281" class="calibre3"/>problem by separating request matching from generating responses. The first step towards using the Express router is to refactor the existing request handler code into separate functions that generate responses without the statements that inspect requests, as shown in <em class="italic">Listing 5.15</em>. </p>
<p class="packt_figref">Listing 5.15: Refactoring in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
import { TLSSocket } from "tls";
import { URL } from "url";
export const isHttps = (req: IncomingMessage) : boolean =&gt; {
    return req.socket instanceof TLSSocket &amp;&amp; req.socket.encrypted;
}
export const redirectionHandler
        = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    resp.writeHead(302, {
        "Location": "https://localhost:5500"
    });
    resp.end();
}
<strong class="screentext">export const</strong><strong class="screentext"> notFoundHandler</strong>
<strong class="screentext">        = (req: IncomingMessage, resp: ServerResponse) =&gt; {</strong>
<strong class="screentext">    resp.writeHead(404, "Not Found");</strong>
<strong class="screentext">    resp.end();</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export const newUrlHandler</strong>
<strong class="screentext">        = (</strong><strong class="screentext">req: IncomingMessage, resp: ServerResponse) =&gt; {</strong>
<strong class="screentext">    resp.writeHead(200, "OK");   </strong>
<strong class="screentext">    resp.write("Hello, New URL");</strong>
<strong class="screentext">    resp.end();</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export const defaultHandler</strong>
<strong class="screentext">        = (req: IncomingMessage, resp: ServerResponse) =&gt; {</strong>
<strong class="screentext">    resp.writeHead(200, "OK");</strong>
<strong class="screentext">    const protocol = isHttps(req) ? "https" : "http";</strong>
<strong class="screentext">    const parsedURL = new</strong><strong class="screentext"> URL(req.url ?? "",</strong>
<strong class="screentext">        `${protocol}://${req.headers.host}`);   </strong>
<strong class="screentext">    if (!parsedURL.searchParams.has("keyword"</strong><strong class="screentext">)) {</strong>
<strong class="screentext">        resp.write(`Hello, ${protocol.toUpperCase()}`);</strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        resp.write(`Hello, ${parsedURL.searchParams.get("keyword")}`);           </strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    resp.end();</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The responses are generated in the same way as earlier examples, but each response is created by<a id="_idIndexMarker282" class="calibre3"/> a separate handler function, without the code that matches requests. The next step is to use the Express<a id="_idIndexMarker283" class="calibre3"/> router to match requests and select one of the handlers from <em class="italic">Listing 5.15</em> to produce a result, as shown in <em class="italic">Listing 5.16</em>.</p>
<p class="packt_figref">Listing 5.16: Using the Express router in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
<strong class="screentext">import { redirectionHandler, newUrlHandler, defaultHandler,</strong>
<strong class="screentext">            notFoundHandler } from "./handler";</strong>
import { createServer as createHttpsServer } from "https";
import { readFileSync } from "fs";
<strong class="screentext">import express, { Express } from "express";</strong>
const port = 5000;
const https_port = 5500;
const server = createServer(redirectionHandler);
server.listen(port,
    () =&gt; console.log(`(Event) Server listening on port ${port}`));
const httpsConfig = {
    key: readFileSync("key.pem"),
    cert: readFileSync("cert.pem")
};   
<strong class="screentext">const </strong><strong class="screentext">expressApp: Express = express();</strong>
<strong class="screentext">expressApp.get("/favicon.ico", notFoundHandler);</strong>
<strong class="screentext">expressApp.get("/newurl", newUrlHandler);</strong>
<strong class="screentext">expressApp.get("*", defaultHandler);</strong>
<strong class="screentext">const</strong><strong class="screentext"> httpsServer = createHttpsServer(httpsConfig, expressApp);</strong>
httpsServer.listen(https_port,
    () =&gt; console.log(`HTTPS Server listening on port ${https_port}`));
</code></pre>
<p class="normal">The <code class="inlinecode">Express</code> package <a id="_idIndexMarker284" class="calibre3"/>contains a default export, which is<a id="_idIndexMarker285" class="calibre3"/> a function named <code class="inlinecode">express</code>, and this is why the new <code class="inlinecode">import</code> statement looks different:</p>
<pre class="programlisting"><code class="hljs-code">...
import <strong class="screentext">express</strong>, { Express } from "express";
...
</code></pre>
<p class="normal">The <code class="inlinecode">express</code> function is invoked to create an <code class="inlinecode">Express</code> object, which provides methods for mapping requests to handler functions. <em class="italic">Table 5.9</em> describes the most useful methods, most of which incorporate the HTTP method into the matching process. </p>
<p class="packt_figref">Table 5.9: Useful Express methods</p>
<table class="table-container" id="table009">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">get(path, handler)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method routes HTTP GET requests that match the path to the specified handler function.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">post(path, handler)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method routes HTTP POST requests that match the path to the specified handler function.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">put(path, handler)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method routes HTTP PUT requests that match the path to the specified handler function.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">delete(path, handler)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method routes HTTP DELETE requests that match the path to the specified handler function.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">all(path, handler)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method routes all requests that match the path to the specified handler function.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">use(handler)</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This method adds a middleware component, which is able to inspect and intercept all requests. Later chapters contain examples that use middleware. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal">I am only interested in GET requests in this chapter, and so I used the <code class="inlinecode">get</code> method to specify URL paths and<a id="_idIndexMarker286" class="calibre3"/> the functions<a id="_idIndexMarker287" class="calibre3"/> that will generate responses:</p>
<pre class="programlisting"><code class="hljs-code">...
expressApp.<strong class="screentext">get</strong>("/favicon.ico", notFoundHandler);
expressApp.<strong class="screentext">get</strong>("/newurl", newUrlHandler);
expressApp.<strong class="screentext">get</strong>("*", defaultHandler);
...
</code></pre>
<p class="normal">These statements are <em class="italic">routes</em>, and the URLs are specified as patterns that allow wildcards, such as the <code class="inlinecode">*</code> character in this route:</p>
<pre class="programlisting"><code class="hljs-code">...
expressApp.get(<strong class="screentext">"*"</strong>, defaultHandler);
...
</code></pre>
<p class="normal">This matches any GET request and routes it to the <code class="inlinecode">defaultHandler</code> function. Express matches requests to routes in the order in which they are defined, and so this is a catch-all route that will be applied if requests are not matched by the other routes.</p>
<p class="normal">In addition to the methods described in <em class="italic">Table 5.9</em>, the <code class="inlinecode">Express</code> object is also a handler function that can be used with the Node.js <code class="inlinecode">createServer</code> functions defined in the <code class="inlinecode">http</code> and <code class="inlinecode">https</code> modules:</p>
<pre class="programlisting"><code class="hljs-code">...
const httpsServer = createHttpsServer(httpsConfig, <strong class="screentext">expressApp</strong>);
...
</code></pre>
<p class="normal">Express processes all the HTTP requests that Node.js receives and routes them to the appropriate <a id="_idIndexMarker288" class="calibre3"/>handler.</p>
<h2 class="heading1" id="_idParaDest-111">Using the request and response enhancements</h2>
<p class="normal1">In addition to routing, Express provides enhancements to the <code class="inlinecode">IncomingRequest</code> and <code class="inlinecode">ServerResponse</code> objects that <a id="_idIndexMarker289" class="calibre3"/>are passed to handler functions. The object that represents the HTTP request is <a id="_idIndexMarker290" class="calibre3"/>named <code class="inlinecode">Request</code> and it extends the <code class="inlinecode">IncomingRequest</code> type. The most useful <code class="inlinecode">Request</code> enhancements are described in <em class="italic">Table 5.10</em>. </p>
<p class="packt_figref">Table 5.10: Useful Express request enhancements</p>
<table class="table-container" id="table010">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">hostname</code></p>
</td>
<td class="table-cell">
<p class="normal">This property provides convenient access to the value of the <code class="inlinecode">hostname</code> header.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">params</code></p>
</td>
<td class="table-cell">
<p class="normal">This property provides access to the route parameters, which are described in the <em class="italic">Using Express route parameters</em> section of this chapter.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">path</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns the path component of the request URL.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">protocol</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns the protocol used to make the request, which will be either <code class="inlinecode">http</code> or <code class="inlinecode">https</code>.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">query</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns an object whose properties correspond to the query string parameters. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">secure</code></p>
</td>
<td class="table-cell">
<p class="normal">This property returns <code class="inlinecode">true</code> if the request has been made using HTTPS.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">body</code></p>
</td>
<td class="table-cell">
<p class="normal">This property is assigned the parsed contents of the request body, as demonstrated in <em class="italic">Chapter 6</em>.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The object that Express uses to represent the HTTP response is named <code class="inlinecode">Response</code> and it extends the <code class="inlinecode">ServerResponse</code> type. The most useful basic <code class="inlinecode">Response</code> enhancements are described in <em class="italic">Table 5.11</em>. </p>
<p class="packt_figref">Table 5.11: Useful basic Express response enhancements</p>
<table class="table-container" id="table011">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">redirect(code, path)</code></p>
<p class="normal"><code class="inlinecode3">redirect(path)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method sends a redirection response. The <code class="inlinecode">code</code> argument is used to set the response status code and message. The <code class="inlinecode">path</code> argument is used to set the value of the <code class="inlinecode">Location</code> header. If the <code class="inlinecode">code</code> argument is omitted, then a temporary redirection, with status code <code class="inlinecode">302</code>, is sent.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">send(data)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method is used to send a response to the server. The status code is set to <code class="inlinecode">200</code>. This method sets response headers to describe the content, including the <code class="inlinecode">Content-Length</code> and <code class="inlinecode">Content-Type</code> headers. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">sendStatus(code)</code></p>
</td>
<td class="table-cell">
<p class="normal">This method is used to send a status code response and will automatically set the status message for well-known status codes, so that a status code of <code class="inlinecode">200</code> will lead to the <strong class="screentext">OK</strong> message being used, for example.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Other Express enhancements <a id="_idIndexMarker291" class="calibre3"/>relate to features described in later chapters, but the basic additions described in <em class="italic">Table 5.10</em> and <em class="italic">Table 5.11</em> are enough to simplify the<a id="_idIndexMarker292" class="calibre3"/> way that responses are generated by the example application, as shown in <em class="italic">Listing 5.17</em>.</p>
<p class="packt_figref">Listing 5.17: Using the Express enhancements in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { IncomingMessage, ServerResponse } from "http";
<strong class="screentext">//import { TLSSocket } from "tls";</strong>
<strong class="screentext">//import { URL } from "url";</strong>
<strong class="screentext">import</strong><strong class="screentext"> { Request, Response } from "express";</strong>
<strong class="screentext">// export const isHttps = (req: IncomingMessage) : boolean =&gt; {</strong>
<strong class="screentext">//     return req.socket instanceof TLSSocket &amp;&amp; req.socket.encrypted;</strong>
<strong class="screentext">// }</strong>
export const redirectionHandler
        = (req: IncomingMessage, resp: ServerResponse) =&gt; {
    resp.writeHead(302, {
        "Location": "https://localhost:5500"
    });
    resp.end();
}
<strong class="screentext">export const notFoundHandler = (req: Request, resp: Response) =&gt; {</strong>
<strong class="screentext">    resp.sendStatus(</strong><strong class="screentext">404);</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export const newUrlHandler = (req: Request, resp: Response) =&gt; {</strong>
<strong class="screentext">    resp.send("Hello, New URL");</strong>
<strong class="screentext">}</strong>
<strong class="screentext">export const </strong><strong class="screentext">defaultHandler = (req: Request, resp: Response) =&gt; {</strong>
<strong class="screentext">    if (req.query.keyword) {</strong>
<strong class="screentext">        resp.send(`Hello, ${req.query.keyword}`);                   </strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        resp.send(</strong><strong class="screentext">`Hello, ${req.protocol.toUpperCase()}`);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">Express automatically<a id="_idIndexMarker293" class="calibre3"/> parses the request URL and makes its parts accessible through the <code class="inlinecode">Response</code> properties described in <em class="italic">Table 5.10</em>, which means I don’t have to parse the URL explicitly. The convenient <code class="inlinecode">secure</code> property means that I can <a id="_idIndexMarker294" class="calibre3"/>remove the <code class="inlinecode">isHttps</code> function.</p>
<p class="normal">The <code class="inlinecode">Response</code> methods described in <em class="italic">Table 5.11</em> reduce the number of statements required to produce responses. The <code class="inlinecode">send</code> method, for example, takes care of setting the response status code, sets some useful headers, and calls the <code class="inlinecode">end</code> method to tell Node.js that the response is complete.</p>
<p class="normal">If you request <code class="inlinecode">https://localhost:5500/newurl</code> and <code class="inlinecode">https://localhost:5500?keyword=Express</code>, you will see the responses shown in <em class="italic">Figure 5.6</em>.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Your browser may use a different font to display these responses, which happens because the <code class="inlinecode">Response</code> methods used to generate responses in <em class="italic">Listing 5.17</em> set the <code class="inlinecode">Content-Type</code> header in the response to <code class="inlinecode">text/html</code>. This header was not set in previous examples, and it alters the way that most browsers display the content.</p>
</div>
<figure class="mediaobject"><img alt="" src="img/B21959_05_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 5.6: Generating responses using Express</p>
<h2 class="heading1" id="_idParaDest-112">Using Express route parameters</h2>
<p class="normal1">It is important to understand that Express doesn’t do anything magical and its features are built on those provided by Node.js described earlier in the chapter. The value of Express is that<a id="_idIndexMarker295" class="calibre3"/> it makes the Node.js API easier to consume, with the result that the code is easier to understand and maintain. </p>
<p class="normal">One especially useful feature that Express provides is specifying <em class="italic">route parameters</em>, which extract values from URL paths when matching requests and make them easily accessible through the <code class="inlinecode">Response.params</code> property, as shown in <em class="italic">Listing 5.18</em>.</p>
<p class="packt_figref">Listing 5.18: Using route parameters in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">...
const expressApp: Express = express();
expressApp.get("/favicon.ico", notFoundHandler);
<strong class="screentext">expressApp.get("/newurl/:message?", newUrlHandler);</strong>
expressApp.get("*", defaultHandler);
...
</code></pre>
<p class="normal">The modified route matches requests when the path begins with <code class="inlinecode">/newurl</code>. The second segment in the URL path is assigned to a route parameter named <code class="inlinecode">message</code>. The parameter is denoted by the colon (the <code class="inlinecode">:</code> character). For the URL path <code class="inlinecode">/newurl/London</code>, for example, the <code class="inlinecode">message</code> parameter will be assigned the value <code class="inlinecode">London</code>. The question mark (the <code class="inlinecode">?</code> character) denotes this is an optional parameter, which means the route will match requests even if there is no second URL segment.</p>
<p class="normal">Route parameters are an effective way to increase the range of URLs that a route can match. <em class="italic">Listing 5.19</em> uses the <code class="inlinecode">Response.params</code> property to get the value of the <code class="inlinecode">message</code> parameter<a id="_idIndexMarker296" class="calibre3"/> and incorporate it into the response.</p>
<p class="packt_figref">Listing 5.19: Consuming a route parameter in the handler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">...
export const newUrlHandler = (req: Request, resp: Response) =&gt; {
    <strong class="screentext">const msg = req.params.message ?? "(No Message)";</strong>
<strong class="screentext">    resp.send(`Hello, ${msg}`);</strong>
}
...
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">https://localhost:5500/newurl/London</code> and you will see the response shown in <em class="italic">Figure 5.7</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_05_07.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 5.7: Using a route parameter</p>
<h1 class="heading" id="_idParaDest-113">Summary</h1>
<p class="normal1">In this chapter, I described the API features that Node.js provides for receiving HTTP requests and producing responses, which is the backbone of server-side web application development:</p>
<ul class="calibre4">
<li class="bulletlist">The Node.js API provides support for receiving HTTP and HTTPS requests.</li>
<li class="bulletlist1">Node.js emits events when requests are received and invokes callback functions to handle those requests.</li>
<li class="bulletlist1">Some additional work, such as parsing URLs, is generally required when using the Node.js API.</li>
<li class="bulletlist1">Third-party packages, such as Express, build on the Node.js APIs to streamline request processing and simplify the code that generates responses.</li>
</ul>
<p class="normal">In the next chapter, I describe the features Node.js provides for reading and writing data.</p>
</div>
</body></html>