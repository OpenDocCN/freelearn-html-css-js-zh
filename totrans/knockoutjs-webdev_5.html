<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. The Joy of Templates</h1></div></div></div><p>A quick walk through history tells the story of how server-side code turned templates into magic. Data mixed with these templates and returned meaningful HTML for the client. These templates dynamically adapted to produce flexible and functional custom HTML pages. Along came AJAX and robbed the developer of this powerful approach to coding. But wait, templates are back again! Now they run at the client side. This chapter will teach you how to create the magic at the client side with Knockout. In this chapter, we will focus on:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Native templates</li><li class="listitem" style="list-style-type: disc">Enhanced collection handling</li><li class="listitem" style="list-style-type: disc">Render events</li><li class="listitem" style="list-style-type: disc">Third-party templates</li><li class="listitem" style="list-style-type: disc">Awesome template options</li></ul></div><p>Knockout is not just about two-way binding. Done right, it is about more elegant and sustainable code. We will learn how to come around for another layer of making our page creation simpler as we<a id="id245" class="indexterm"/> learn to use the power of templating in KnockoutJS.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Native templates</h1></div></div></div><p>Templates<a id="id246" class="indexterm"/> are patterns for how we merge data and the stuff the data fits into. The most popular form <a id="id247" class="indexterm"/>of templates <a id="id248" class="indexterm"/>on computers in the early days was something we called a mail merge. Programs <a id="id249" class="indexterm"/>like Microsoft Word would use a mail merge document and a data file, and merge them together. The original purpose was for printing.</p><p>Over the time, we shifted to using this same type of technology to do web pages. When a user would go to a website and request a web page, the servers started getting smarter. The data was mixed into a template and the merged result was returned to the browser as HTML. This was an amazing game changer for shopping sites and other sites where the basic page was the same. This is why we call these pieces of code templates.</p><p>One way to<a id="id250" class="indexterm"/> look at this is to think about when people decorate houses. We have things we call stencils. While the stencil defines how the shape of the result will look, it does not control what color you paint something with. If you have an apple stencil you can <a id="id251" class="indexterm"/>paint a red apple, a green Granny Smith style apple, a yellow Golden Delicious apple, or go off standard and have a purple and yellow striped apple. The stencil only controls the container the content will be placed in.</p><p>In the same fashion, web templates frame the content. Well, mostly. You see, this is a program and it's a bit smarter than a wall painting stencil; so we can add in conditional logic and do things like repeat information or conditionally choose if we want to show any information at all. This is the power of a template.</p><p>We will have a bit more complex data set in this chapter because we want to get ourselves in touch with more real-life site pages, which we will be using outside this book. Here is the code section for this page. Not all the data will be used here. We will expand on the data as we progress through the chapter, so just focus on the stuff we actually use:</p><div><pre class="programlisting">var mySeminar = {
  guest1 : { name: "Pete", seating: "standard" },
  guest2 : { name: "Re-Pete", seating: "balcony" },
  conference : {
    name: "KnockOut 2K",
    byLine: "MVVM That Works"
  }, speakers : [
    { id: 1, name: "John Doe", bio: 'This is the bio for John.',
      skills: [ "jQuery","KnockoutJS","SammyJS","NodeJS" ] },
    { id: 2, name: "Mary Smith", bio: 'This is the bio for Mary.',
      skills: [ "jQuery","KnockoutJS","PHP" ] },
    { id: 3, name: "TBA", bio: 'This is the bio for ???.',
      skills: [ "HTML5","SQL","JavaScript" ] }
  ], sessions : [
    { name: "SPA Applications", speakerId: 1 },
    { name: "MVVM Best Practices", speakerId: 1 },
    { name: "Mapping Madness", speakerId: 2 },
    { name: "Custom Components", speakerId: 2 },
    { name: "Browser Database for Beginners", speakerId: 3 }
  ]
};
vm = ko.mapping.fromJS(mySeminar);
ko.applyBindings( vm );</pre></div><p>You probably guessed, looking at our data, that we will be showing a pseudo, meaning fake in this case but pseudo sounds so much nicer, seminar page. One thing you should realize is that data will come in all kinds of forms. You may need to arrange data before it works best for your pages. Don't think there is any strict pattern here that you have to follow. If you need to rearrange your data that is part of any template approach to code, you can do it.</p><p>Now, I said this<a id="id252" class="indexterm"/> section was going to be about native templates. This means you are going to create these <a id="id253" class="indexterm"/>templates in, the standard Knockout way of creating templates. This is what you should do most of the time. We will show later how to integrate external template libraries; but let me say right up front that in the real world this is a very rare approach to how developers use templates on Knockout pages.</p><p>Knockout follows the approach most browser-side templates are using. The actual template is nested inside a set of script tags. If you are new to this and are wondering why there is no JavaScript error when doing this, let me explain. In days past Microsoft Internet Explorer used a script called VBScript. Most other browsers used a script called JavaScript. Today we are seeing some other scripts come out on Internet Explorer again. TypeScript is an example, but it seems to require Visual Studio to function correctly and does not work as a native script; so staying with JavaScript for portability seems the way to go. These tags created a way to declare the type of content within them. If the content is not recognized, it is essentially ignored.</p><p>When the script is ignored, it means there is no DOM created from the markup code. JavaScript can still see this code though. So by declaring a different type attribute we are able to convert nested HTML into actionable code to use for our templates. This also allows us to actually use the familiar HTML scripting. Many people use something like jQuery to create content but it is nowhere near as elegant as a template approach. In fact, for a season, jQuery had its own templating. It pulled back with the reasoning that templates were not part of its solution focus.</p><p>Here is the first template we will use for our page. We will need to include the Knockout and mapping library for the code example here. The mapping library is not needed to do the template code. We are using it just to make our examples simpler. This makes for a focused approach on the subject and less coding for you as you go through the book.</p><div><pre class="programlisting">&lt;script type="text/html" id="guest-template"&gt;
    &lt;h3 data-bind="text: name"&gt;&lt;/h3&gt;
    &lt;p&gt;Seating: &lt;span data-bind="text: seating"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/script&gt;</pre></div><p>You will notice that we put an <code class="literal">id</code> attribute on our template code segment. Each template will need a unique ID to work properly. Inside our template this looks pretty identical to<a id="id254" class="indexterm"/> the Knockout code we have been seeing all through this book. This is one <a id="id255" class="indexterm"/>of the great things about Knockout templating. It builds on what you already know and use with hardly any exceptions. An important consideration when doing templates is that the template should come before the actual call to binding the ViewModel. Following are the two external libraries we will include to make this page work. The <code class="literal">script</code> tag can come before or after them. It only needs to come before the binding call to prevent issues.</p><div><pre class="programlisting">&lt;script src="img/knockout.js"&gt;&lt;/script&gt;
&lt;script src="img/knockout.mapping.js"&gt;&lt;/script&gt;</pre></div><p>The last thing we need to do, to use template binding, is place a call to the template within the code. A template is similar to the wall stencil. You get to choose what you put inside the pattern. You get to choose what is merged into the template. This means you have to have data that matches the template. In this template, you need to pass in a ViewModel structure that contains structure items for name and seating. Here is a call to the template with the data declared:</p><div><pre class="programlisting">&lt;div data-bind="template: { name: 'guest-template', data: guest1 }"&gt;&lt;/div&gt;</pre></div><p>If you have a template you want to use that doesn't have any data merges, you could reuse it on the page. I am not sure why you would want to do that but it is possible. Notice that with passing data to the template we are using the classic JSON format approach to what gets passed in. Let's modify the preceding code just a bit farther and have two templates with different data passed in, and a little markup near the templates:</p><div><pre class="programlisting">&lt;h2&gt;Guests&lt;/h2&gt;
These are the guests:
&lt;div data-bind="template: { name: 'guest-template', data: guest1 }"&gt;&lt;/div&gt;
&lt;div data-bind="template: { name: 'guest-template', data: guest2 }"&gt;&lt;/div&gt;</pre></div><p>Notice that we have used our template twice in a row with the only difference being they have a different ViewModel structure passed through to them. You should also notice that the template name is the value of the <code class="literal">id</code> attribute in our scripted template declaration. Here is the resulting screenshot for this template:</p><div><img src="img/1028OS_05_01.jpg" alt="Native templates"/></div><p>Since name and<a id="id256" class="indexterm"/> seating <a id="id257" class="indexterm"/>are variables of the structure, the scope is automatically understood by the template merging. It is a common practice to call the merging of the data with the template rendering, if you hear the term.</p><p>The actual data we merged to our template, before being inserted into the ViewModel, is as follows:</p><div><pre class="programlisting">guest1 : { name: "Pete", seating: "standard" }</pre></div><p>Well, we can now see our data being mixed with the template fast and easy. If we go to our browser developer tools to reach the console, we can input the following command. We want to modify the data inside our ViewModel to see if the binding has an instant effect on our View:</p><div><pre class="programlisting">vm.guest1.name('Peter')</pre></div><p>When we do this, notice the template smartly and immediately updates the content. So we see our data binding is locked into templates just like the binding outside of templates. There are different templates out in the open source market. What makes Knockout powerful is that it binds the rendered content to regenerate when the connected data changes. There have been a few comparisons of frameworks, and Knockout also performed better than others in terms of speed for this type of functionality. So, unless you are doing something incredibly large, having this run live should not greatly affect your user experience. With that said, don't forget to test performance as that is always the best practice. Here is the updated screenshot:</p><div><img src="img/1028OS_05_02.jpg" alt="Native templates"/></div><p>Well, where are Pete, or Peter at the moment, and Re-Pete guests? That is our next block of code. We already have the data but the part of the data we will be using is this segment:</p><div><pre class="programlisting">conference : {
  name: "KnockOut 2K",
  byLine: "MVVM That Works"
}</pre></div><p>Here is the code for the display and the template that binds to it:</p><div><pre class="programlisting">&lt;h2&gt;Seminar&lt;/h2&gt;
&lt;div data-bind="template: { name: 'tmpl-Seminar', data: conference }"&gt;&lt;/div&gt;</pre></div><p>We will need <a id="id258" class="indexterm"/>another <a id="id259" class="indexterm"/>template to demonstrate the merging of a different set of data. Here is the code for that template:</p><div><pre class="programlisting">&lt;script type="text/html" id="tmpl-Seminar"&gt;
  &lt;h3 data-bind="text:name"&gt;&lt;/h3&gt;
  &lt;p&gt;Theme: &lt;span data-bind="text:byLine"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/script&gt;</pre></div><p>Notice that our first template used a variable called <code class="literal">name</code>. In this template, we are also using a variable called <code class="literal">name</code>. Each template, when rendered, will look just at the data passed to it to merge the contents. Here is the screenshot from the template rendered to the page in this example:</p><div><img src="img/1028OS_05_03.jpg" alt="Native templates"/></div><p>There is no basic limit to the number of templates you can use on a page or the amount of data that can be merged. We are not going to assume that some developer or some client request could not go over the top. Yet, browsers and computers are so fast that these issues will rarely be something to focus on. The only time they may become an issue is if you are doing something complex with a variable that is in your ViewModel, and it is based on a computed value with complex logic. But I have not found a case so far where it is an issue in work, my company has produced for our clients.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Enhanced collection handling</h1></div></div></div><p>In our first segment, native templates, we focused on single sets of data. In JavaScript, we often have collections of data stored in arrays. We will be including an example here to <a id="id260" class="indexterm"/>show <a id="id261" class="indexterm"/>how to use templates stored in arrays.</p><p>We can copy the data from our last example page to this page. We will be using more of the structure this time around. We will start by focusing on the speakers. This array contains structured items for each speaker. The code section of our <code class="literal">script</code> tag should look like this:</p><div><pre class="programlisting">vm = ko.mapping.fromJS(mySeminar);
ko.applyBindings( vm );</pre></div><p>If you think this looks basically the same as the last example of code, you are right. It will change soon, but we are looking to make a point here. Arrays and non-arrays are not coded differently for routine binding functionality. Here is the segment of data that we will be using for this part of the exercise:</p><div><pre class="programlisting">speakers : [
  { id: 1, name: "John Doe", bio: 'This is the bio for John.',
    skills: [ "jQuery","KnockoutJS","SammyJS","NodeJS" ] },
  { id: 2, name: "Mary Smith", bio: 'This is the bio for Mary.',
    skills: [ "jQuery","KnockoutJS","PHP" ] },
  { id: 3, name: "TBA", bio: 'This is the bio for ???.',
    skills: [ "HTML5","SQL","JavaScript" ] }
],</pre></div><p>We will be mixing this data with the following template structure and it will be enhanced as we go:</p><div><pre class="programlisting">&lt;script type="text/html" id="tmpl-Speakers"&gt;
  &lt;h3 data-bind="text:name"&gt;&lt;/h3&gt;
  &lt;p&gt;Bio: &lt;span data-bind="text:bio"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/script&gt;</pre></div><p>Here, we see the name and bio will be mixed into our page, pulling the name and bio from the data of each collection record. Here is the template call we will use on our page:</p><div><pre class="programlisting">&lt;h2&gt;Speakers&lt;/h2&gt;
&lt;div data-bind="template: { name: 'tmpl-Speakers', foreach: speakers, as: 'speaker' }"&gt;&lt;/div&gt;</pre></div><p>This time we are using foreach rather than data in our template code. When using data it will pass in the entire data structure once. Using foreach will pass in the data structure as one collection item at a time. The template actually has no awareness of how the data is being passed to it. This is controlled by how we call the template. Here is<a id="id262" class="indexterm"/> the result <a id="id263" class="indexterm"/>we will see when run the code:</p><div><img src="img/1028OS_05_04.jpg" alt="Enhanced collection handling"/></div><p>Well, that was collection handling; but this section is called enhanced collection handling. We are going to go a little deeper and while using Knockout, we are still going to keep things pretty simple and the code very light.</p><p>As you can see in the following code, nested inside each speaker record, there is another simple collection of speaker skills. Here is the first item in the collection for clarity:</p><div><pre class="programlisting">{ id: 1, name: "John Doe", bio: 'This is the bio for John.',
    skills: [ "jQuery","KnockoutJS","SammyJS","NodeJS" ] },</pre></div><p>We see that John Doe has skills in using jQuery, KnockoutJS, SammyJS, and NodeJS. This is a JavaScript dude! He probably has other talents that he didn't list, but we can only show the ones he gave us, of course. How do we go about doing this? Well, one of the sweet powers of Knockout templates is the ability to nest other template calls inside templates. Here is the new template we will add to show the skills:</p><div><pre class="programlisting">&lt;script type="text/html" id="tmpl-SpeakerSkills"&gt;
    &lt;li data-bind="text:skill"&gt;&lt;/li&gt;
&lt;/script&gt;</pre></div><p>We will obviously need to modify the primary template to have this work. We are using an HTML list to show the skills, so we will need to nest the list in a list wrapper tag. We are also going to want to add a heading to clarify what this list represents. Here is our modified template with the new code highlighted:</p><div><pre class="programlisting">&lt;script type="text/html" id="tmpl-Speakers"&gt;
  &lt;h3 data-bind="text:name"&gt;&lt;/h3&gt;
  &lt;p&gt;Bio: &lt;span data-bind="text:bio"&gt;&lt;/span&gt;&lt;/p&gt;
  <strong>&lt;h4&gt;Skills&lt;/h4&gt;</strong>
<strong>  &lt;ul data-bind="template: { name: 'tmpl-SpeakerSkills', foreach: $data.skills, as: 'skill' }"&gt;&lt;/ul&gt;</strong>
&lt;/script&gt;</pre></div><p>Notice that<a id="id264" class="indexterm"/> there is <a id="id265" class="indexterm"/>another foreach template binding, as the data being passed in is a collection. The last time it was a collection of structures and this time it is a collection of simple values. It does not matter to Knockout what type of items exist in the collection. It needs to be a collection or rather an array you designate when using the <code class="literal">foreach</code> passing of data.</p><p>The original call to the speaker template does need to be modified. Here is what our first speaker record looks like now. Of course, all the other records also have the added skills, but we wanted to conserve space; so please make sure you are doing all these examples in the browser, with code you entered by hand, to maximize your learning experience.</p><div><img src="img/1028OS_05_05.jpg" alt="Enhanced collection handling"/></div><p>This is pretty good but it is not good enough. We promised to cover enhanced collection template techniques and there is one more thing we want to show you. Nesting is the simplest form of enhancing our collection templates. Now, we want to show you how to do some relational data handling with the session records. Here is the session records data segment we will be mixing in:</p><div><pre class="programlisting">sessions : [
  { name: "SPA Applications", speakerId: 1 },
  { name: "MVVM Best Practices", speakerId: 1 },
  { name: "Mapping Madness", speakerId: 2 },
  { name: "Custom Components", speakerId: 2 },
  { name: "Browser Database for Beginners", speakerId: 3 }
]</pre></div><p>You should have noted that the <code class="literal">speakerId</code> attribute is part of this data collection. This is how <a id="id266" class="indexterm"/>we will tie <a id="id267" class="indexterm"/>the records in. It will take a minor amount of code to tie this in correctly, but it truly is a minor amount of code. We will need to add the following highlighted code to make this work. We have added this code between our mapping and binding:</p><div><pre class="programlisting">vm = ko.mapping.fromJS(mySeminar);
<strong>vm.speakerSessions = function(speakerId){</strong>
<strong>  var mySessions = [];</strong>
<strong>  ko.utils.arrayMap(vm.sessions(),function(session){</strong>
<strong>    if(speakerId() == session.speakerId()){</strong>
<strong>      mySessions.push(session);</strong>
<strong>    }</strong>
<strong>  });</strong>
<strong>  return mySessions;</strong>
<strong>};</strong>
</pre></div><p>This time we are not using a collection to pass to the template; well, not a bound array collection. We will be calling the data by triggering a function that will filter and return an array collection. This means that as long as we are passing an array when the call is made, the template call does not care.</p><p>We are also using the <code class="literal">arrayMap</code> method of our Knockout utilities to filter data versus filter down. Notice that we call by designation the ViewModel as the first argument of the filter. It will then pass in each session item one at a time to see if the item should be placed in the filtered collection. Then, it will return the results. Pretty simple code. Oh, yes, it does receive the <code class="literal">speakerId</code> attribute as an argument when calling. That is key to making things work. Take a look at the following <code class="literal">script</code> code:</p><div><pre class="programlisting">&lt;script type="text/html" id="tmpl-SpeakerSessions"&gt;
  &lt;h4&gt;Sessions&lt;/h4&gt;
  &lt;ul data-bind="foreach:$root.speakerSessions(id)"&gt;
    &lt;li data-bind="text:name() +' with '+ speaker.name()"&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/script&gt;</pre></div><p>Notice that we have used the <code class="literal">$root</code> designation to call our method. This is because we wanted to remind you that because this is a nested template, we need to make sure our method <a id="id268" class="indexterm"/>call is at the right level. The <code class="literal">$root</code> designation allows you to address the actual root level of the <a id="id269" class="indexterm"/>ViewModel. The ID that is passed in matches the speaker data item. The <code class="literal">speakerSessions</code> code we added will then match that ID with the records that have the same ID. If there is more than one session, it will show them.</p><p>We will need to also include a nested call to the sessions in our primary template for this to work. Again, we will not need to modify the original call to the speakers. Here is the code with the new part highlighted:</p><div><pre class="programlisting">&lt;script type="text/html" id="tmpl-Speakers"&gt;
  &lt;h3 data-bind="text:name"&gt;&lt;/h3&gt;
  &lt;p&gt;Bio: &lt;span data-bind="text:bio"&gt;&lt;/span&gt;&lt;/p&gt;
<strong>  &lt;div data-bind="template: { name: 'tmpl-SpeakerSessions', data: $data }"&gt;&lt;/div&gt;</strong>
  &lt;h4&gt;Skills&lt;/h4&gt;
  &lt;ul data-bind="template: { name: 'tmpl-SpeakerSkills', foreach: $data.skills, as: 'skill' }"&gt;&lt;/ul&gt;
&lt;/script&gt;</pre></div><p>Take a moment and look at the code; discover the difference between the call to our additional nested template and the first nested template. You will see that in our additional method we did not pass in the data using the <code class="literal">foreach</code> designator. This time we used the data designator to pass in our collection. Both of these are valid approaches, but we wanted to give you examples of doing both for your experience.</p><p>Here is the resulting first record (again, not showing everything to save space). Notice how this time the nested template is handling the <code class="literal">foreach</code> designator using classic binding for Knockout:</p><div><img src="img/1028OS_05_06.jpg" alt="Enhanced collection handling"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Render event handling</h1></div></div></div><p>One of the <a id="id270" class="indexterm"/>things you grow to appreciate as your experience grows is the ability to do event handling. I have not needed this functionality yet with Knockout code in the live sites we have <a id="id271" class="indexterm"/>built; but it is awesome to know it is there if we do need it.</p><p>We will be using the following code this time. We will use a different data set for this example to keep our code simpler and focus on just this section:</p><div><pre class="programlisting">&lt;script&gt;
    var ViewModel = function(){
        seasons = ko.observableArray([
            { name: 'Spring', months: [ 'March', 'April', 'May' ] },
            { name: 'Summer', months: [ 'June', 'July', 'August' ] },
            { name: 'Autumn', months: [ 'September', 'October', 'November' ] },
            { name: 'Winter', months: [ 'December', 'January', 'February' ] }
        ]);
    showRendered = function(e){
      $(e).wrapInner("&lt;em style='color:green'&gt;&lt;/em&gt;");
    };
    };
  vm = new ViewModel();
    ko.applyBindings(vm);
&lt;/script&gt;</pre></div><p>This also tells us that we will not always consider the mapping to be the best method. It is usually best in the early prototyping of pages to use mapping as it speeds up the creation of the stuff we need. Then, we migrate, if needed, to a non-mapped ViewModel when appropriate, to maximize productivity. If your experience varies then follow your instinct and use the approach that works best in your group.</p><p>The data and binding are obvious by now. The function we added will use jQuery to perform a wrap of each designated item, rendered by Knockout with italics and in green. One pragmatic use I have thought of for this is a log of a unit test to make sure the output is what is expected. Regardless of what you use it for, it will show you a couple of things.</p><p>First, we are not totally disconnected from jQuery while using Knockout. There is a way I like to describe this to people who are anxious that using Knockout will eliminate the <a id="id272" class="indexterm"/>use <a id="id273" class="indexterm"/>of jQuery. Yes, I remember how hard JavaScript was for most people before jQuery. They both have different strengths. Knockout shines at data binding and jQuery shines at AJAX communications between the client and the server, as well as at DOM manipulation. Together, they make a great team with each having areas and different challenges that they are best suited to meet.</p><p>Here are the templates we will use in this example. We will be using nested templates again. This is the root template:</p><div><pre class="programlisting">&lt;script type="text/html" id="seasonTemplate"&gt;
    &lt;li&gt;
        &lt;strong data-bind="text: "&gt;&lt;/strong&gt;
        &lt;strong data-bind="text: name"&gt;&lt;/strong&gt;
        &lt;ul data-bind="template: { name: 'monthTemplate', foreach: months, as: 'month' , afterRender: showRendered}"&gt;&lt;/ul&gt;
    &lt;/li&gt;
&lt;/script&gt;</pre></div><p>We have called the months as nested template calls. While we could have just rendered all this with regular tags, it would not have shown us how the event handlers work. Look closely at the nested data binding in the template call and you will see a setting for <code class="literal">afterRender</code>. You will see it calls the function we added to our code. Since it is in the root template, it will not need to use the <code class="literal">$root</code> designator to correctly call the function method to handle the render event. Here is the nested template that it will call to render the month items:</p><div><pre class="programlisting">&lt;script type="text/html" id="monthTemplate"&gt;
    &lt;li&gt;
        &lt;span data-bind="text: month"&gt;&lt;/span&gt;
        is in
        &lt;span data-bind="text: season.name"&gt;&lt;/span&gt;
    &lt;/li&gt;
&lt;/script&gt;</pre></div><p>There is something special I wanted you to see here also. Noticed that we use the variable <code class="literal">season.name</code> in this template. We were able to address the parent's data structure from the nested template. The guys who wrote the Knockout library had many awesome moments putting things like this together. So, where is the season declared? Look at the actual call to the root template:</p><div><pre class="programlisting">&lt;ul data-bind="template: { name: 'seasonTemplate', foreach: seasons, as: 'season' }"&gt;&lt;/ul&gt;</pre></div><p>You will see an <code class="literal">as</code> designator with the <code class="literal">season</code> string declared as the alias of the structure. So, we could use <code class="literal">$data</code> in the first level of the template, but it would not work right to use <code class="literal">$data</code> in the second level of the template. By declaring the alias <code class="literal">season</code>, we can use that in the nested child, and it will properly target the right data set. Awesome!</p><p>Now, when we<a id="id274" class="indexterm"/> look at <a id="id275" class="indexterm"/>our results we get things properly handled and rendered. I admit that while I have used jQuery since just before Version 1.2, my history with Knockout was delayed more than that. If you are having issues with earlier versions that may not support every feature we are teaching here, jump into the online group. You will find it listed at the Knockout site. The community is awesome in how they support each other there.</p><p>Here is a screenshot of the results of this code:</p><div><img src="img/1028OS_05_07.jpg" alt="Render event handling"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Third-party template options</h1></div></div></div><p>There was <a id="id276" class="indexterm"/>a time <a id="id277" class="indexterm"/>when jQuery was exploring creating its own templates, but that effort did not<a id="id278" class="indexterm"/> mature to a full release. So we will not cover that template here. The most popular template used with Knockout seems to have <a id="id279" class="indexterm"/>been <strong>Underscore</strong> as a result. Personally, before jumping into Knockout my template of choice was, well is, <strong>Handlebars</strong>. Yet, I have enjoyed Knockout templates so much that it has never compelled <a id="id280" class="indexterm"/>me to go as far as integrating Handlebars with Knockout yet.</p><p>I have played around with Underscore just to get a taste of why others use Underscore with Knockout; to see if I was missing something. It came down to a developer style difference that some developers like to use the Underscore style of template <a id="id281" class="indexterm"/>coding <a id="id282" class="indexterm"/>and others prefer to use native Knockout templates. In this section, we will be honoring the Underscore fans' approach.</p><p>We suggest some copy and paste from the <code class="literal">done</code> directory of the example code for this to prevent typos. If you are awesome enough, just go ahead and type this in though. Remember again, your examples should be going into the <code class="literal">do</code> folder for each chapter.</p><p>Here is our base code for this example:</p><div><pre class="programlisting">&lt;script&gt;
var viewModel = {
    people: ko.observableArray([
        { name: ko.observable('Rod'), age: ko.observable(123) },
        { name: ko.observable('Jane'), age: ko.observable(125) }, 
        { name: ko.observable('Mary'), age: ko.observable(25) }
    ])
};
ko.applyBindings(viewModel);
&lt;/script&gt;</pre></div><p>Here is our code for calling the template:</p><div><pre class="programlisting">&lt;h1&gt;People&lt;/h1&gt;
&lt;ul data-bind="template: { name: 'peopleList' }"&gt;&lt;/ul&gt;</pre></div><p>Now, here is our template. You should notice that the style of the template is different here. If you are accustomed to Underscore, this will work great. If you are not using Underscore you should not assume the code in this template will be an example of native Knockout templates.</p><div><pre class="programlisting">&lt;script type="text/html" id="peopleList"&gt;
    &lt;% _.each(people(), function(person) { %&gt;
        &lt;li&gt;
            &lt;b data-bind="text: person.name"&gt;&lt;/b&gt; is &lt;%= person.age() %&gt; years old
        &lt;/li&gt;
    &lt;% }) %&gt;
&lt;/script&gt;</pre></div><p>This screenshot shows that we will produce the following results. Wait! There is one piece missing, but we did want to show you the results first.</p><div><img src="img/1028OS_05_08.jpg" alt="Third-party template options"/></div><p>As far as the <a id="id283" class="indexterm"/>end user is concerned, there is no difference. Using third-party templates<a id="id284" class="indexterm"/> is for the benefit of the developers. Well, if you are doing a contract that requires the use of Underscore, that would be another benefit to this approach as it would let you do the job with Underscore and Knockout, if permitted otherwise. It might be good to verify that in advance just to make sure.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Modified template handling with Underscore</h2></div></div></div><p>Let me express my gratitude again and say thanks to the Knockout community on Google <a id="id285" class="indexterm"/>groups. This, in addition to several sites online, is where I learned how to do template<a id="id286" class="indexterm"/> handling. The technique allows us to manage the template engine and pass the results out to process through the Underscore engine. The key code is highlighted as follows:</p><div><pre class="programlisting">/* ---- Begin integration of Underscore template engine with Knockout. Could go in a separate file of course. ---- */
    ko.underscoreTemplateEngine = function () { }
    ko.underscoreTemplateEngine.prototype = ko.utils.extend(new ko.templateEngine(), {
        renderTemplateSource: function (templateSource, bindingContext, options) {
            // Precompile and cache the templates for efficiency
<strong>            var precompiled = templateSource['data']('precompiled');</strong>
<strong>            if (!precompiled) {</strong>
<strong>                precompiled = _.template("&lt;% with($data) { %&gt; " + templateSource.text() + " &lt;% } %&gt;");</strong>
<strong>                templateSource['data']('precompiled', precompiled);</strong>
<strong>            }</strong>
            // Run the template and parse its output into an array of DOM elements
<strong>            var renderedMarkup = precompiled(bindingContext).replace(/\s+/g, " ");</strong>
            return ko.utils.parseHtmlFragment(renderedMarkup);
        },
        createJavaScriptEvaluatorBlock: function(script) {
            return "&lt;%= " + script + " %&gt;";
        }
    });
    ko.setTemplateEngine(new ko.underscoreTemplateEngine());
/* ---- End integration of Underscore template engine with Knockout ---- */</pre></div><p>The first <a id="id287" class="indexterm"/>highlighted <a id="id288" class="indexterm"/>section passes the code and data into the Underscore template handler to be rendered by Underscore. Underscore does produce some results that need to be cleaned up to work right here, so the second highlighted section is there to clean up the rendered code.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Live updates and the subscribe method in Knockout</h2></div></div></div><p>We are <a id="id289" class="indexterm"/>going to <a id="id290" class="indexterm"/>create the <a id="id291" class="indexterm"/>ability to add items with an edit form on the screen. Here is the markup for the View that we will add for this functionality:</p><div><pre class="programlisting">&lt;input data-bind="value: name" /&gt;
&lt;input data-bind="value: age" /&gt;
&lt;button data-bind="click: addItem"&gt;Add&lt;/button&gt;</pre></div><p>We will need to also add the ViewModel structure and it will include these items:</p><div><pre class="programlisting">name: ko.observable(),
age: ko.observable(),
    
addItem: function() {
var item = { name: ko.observable(viewModel.name()), age: ko.observable(viewModel.age()) };
   viewModel.people.push(item);
   viewModel.name("");
   viewModel.age("");
}</pre></div><p>When adding items or removing them, Knockout gives us the ability to monitor these changes, and that is what we wanted to illustrate. This is the code we use to tell Knockout we want to subscribe, or listen, to events. The particular event we will be listening to will be the <code class="literal">arrayChange</code> event on the <code class="literal">people</code> array collection. Here is the code for it. Notice that we are also dumping the results into the console. We also will be pushing the results of the changes to another attribute for the people changes.</p><div><pre class="programlisting">viewModel.people.subscribe(function(e){
  console.log(e);
}, viewModel, "arrayChange");
viewModel.people.subscribe(viewModel.peopleChange, viewModel, "arrayChange");</pre></div><p>The results that <a id="id292" class="indexterm"/>we pass into <code class="literal">peopleChange</code>, we will handle by converting them to JSON using the binding on the View as follows. Anytime our value in <code class="literal">peopleChange</code> is updated, the results <a id="id293" class="indexterm"/>will be <a id="id294" class="indexterm"/>displayed as a JSON structure.</p><div><pre class="programlisting">&lt;pre data-bind="text: ko.toJSON(peopleChange, null, 2)"&gt;&lt;/pre&gt;</pre></div><p>Now, just in case that was confusing on the first pass or you don't want to download the code, let me give you the markup View code here:</p><div><pre class="programlisting">&lt;h1&gt;People&lt;/h1&gt;
&lt;ul data-bind="template: { name: 'peopleList' }"&gt;&lt;/ul&gt;
&lt;script type="text/html" id="peopleList"&gt;
    &lt;% _.each(people(), function(person) { %&gt;
        &lt;li&gt;
            &lt;b data-bind="text: person.name"&gt;&lt;/b&gt; is &lt;%= person.age() %&gt; years old
        &lt;/li&gt;
    &lt;% }) %&gt;
&lt;/script&gt;
&lt;pre data-bind="text: ko.toJSON(peopleChange, null, 2)"&gt;&lt;/pre&gt;
&lt;input data-bind="value: name" /&gt;
&lt;input data-bind="value: age" /&gt;
&lt;button data-bind="click: addItem"&gt;Add&lt;/button&gt;</pre></div><p>It looks much simpler when all in one place; well, it does to me. There are more scripts included this time; here is the collection we need for this example:</p><div><pre class="programlisting">&lt;script  src="img/jquery.mi n.js"&gt;&lt;/script&gt;
&lt;script  src="img/bootstrap.min.js "&gt;&lt;/script&gt;
&lt;script src="img/knockout.js"&gt;&lt;/script&gt;
&lt;script  src="img/underscore- min.js"&gt;&lt;/script&gt;</pre></div><p>Yes, these do <a id="id295" class="indexterm"/>work with the current version of jQuery also, if you have that question. We will now show the <a id="id296" class="indexterm"/>code for <a id="id297" class="indexterm"/>this example page:</p><div><pre class="programlisting">&lt;script&gt;
/* ---- Begin integration of Underscore template engine with Knockout. Could go in a separate file of course. ---- */
    ko.underscoreTemplateEngine = function () { }
    ko.underscoreTemplateEngine.prototype = ko.utils.extend(new ko.templateEngine(), {
        renderTemplateSource: function (templateSource, bindingContext, options) {
            // Precompile and cache the templates for efficiency
            var precompiled = templateSource['data']('precompiled');
            if (!precompiled) {
                precompiled = _.template("&lt;% with($data) { %&gt; " + templateSource.text() + " &lt;% } %&gt;");
                templateSource['data']('precompiled', precompiled);
            }
            // Run the template and parse its output into an array of DOM elements
            var renderedMarkup = precompiled(bindingContext).replace(/\s+/g, " ");
            return ko.utils.parseHtmlFragment(renderedMarkup);
        },
        createJavaScriptEvaluatorBlock: function(script) {
            return "&lt;%= " + script + " %&gt;";
        }
    });
    ko.setTemplateEngine(new ko.underscoreTemplateEngine());
/* ---- End integration of Underscore template engine with Knockout ---- */
var viewModel = {
    people: ko.observableArray([
        { name: ko.observable('Rod'), age: ko.observable(123) },
        { name: ko.observable('Jane'), age: ko.observable(125) }, 
        { name: ko.observable('Mary'), age: ko.observable(25) }
    ]),
  peopleChange: ko.observable(),
    name: ko.observable(),
    age: ko.observable(),
    addItem: function() {
       var item = { name: ko.observable(viewModel.name()), age: ko.observable(viewModel.age()) };
       viewModel.people.push(item);
       viewModel.name("");
       viewModel.age("");
    },
    removeItem: function(item) {
       viewModel.people.remove(item);
    }
};
viewModel.people.subscribe(viewModel.peopleChange, viewModel, "arrayChange");
viewModel.people.subscribe(function(e){
  console.log(e);
}, viewModel, "arrayChange");
ko.applyBindings(viewModel);
&lt;/script&gt;</pre></div><p>Now, we <a id="id298" class="indexterm"/>have <a id="id299" class="indexterm"/>code that <a id="id300" class="indexterm"/>will show us third-party templates, subscriptions, and dynamic modification of the data stored in our binding. Here is what the screen will look like. Well, in my <code class="literal">done</code> version of the code it is wrapped in Bootstrap, so this is what it looks like in Bootstrap:</p><div><img src="img/1028OS_05_09.jpg" alt="Live updates and the subscribe method in Knockout"/></div><p>We will go ahead and add <code class="literal">John</code> to the list and make him <code class="literal">40</code> years old. Here is what you will see in the screenshot with the results of <code class="literal">subscribe</code> put out as a JSON structure. If a record had been deleted it would show that as well; another reason why Knockout is so flexible to work with. You will have also noticed in our code that as soon as we added the items to the structure of our data via the binding, we also cleared the input boxes to keep a clean interface for the user. Here is the resultant screenshot:</p><div><img src="img/1028OS_05_10.jpg" alt="Live updates and the subscribe method in Knockout"/></div><p>Let me say <a id="id301" class="indexterm"/>again<a id="id302" class="indexterm"/> that <a id="id303" class="indexterm"/>most people do not use third-party templates as the native templates are very powerful. This doesn't mean to do so is wrong, but the need to do so could be just a need to learn how to use the abilities of the native template. If that is the case, we hope this chapter has been the answer to that need.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Awesome template options</h1></div></div></div><p>There is one <a id="id304" class="indexterm"/>more time someone may want to do something with templates different from the pure native style of using templates with Knockout. This is because you may like to use a slightly different kind of coding style. In this last section of the chapter, we will give you a few more options.</p><p>We are back to native templates; I thought we should mention that in case someone had a question. Here are the templates that we will be using on this page:</p><div><pre class="programlisting">&lt;script type="text/html" id="guest-template"&gt;
    &lt;h3&gt;{{name}}&lt;/h3&gt;
    &lt;p&gt;Seating: {{seating}}&lt;/p&gt;
&lt;/script&gt;
&lt;script type="text/html" id="guest-template-alt"&gt;
    &lt;h3&gt;Others&lt;/h3&gt;
    &lt;p&gt;Seating: General Seating&lt;/p&gt;
&lt;/script&gt;
&lt;script type="text/html" id="tmpl-Seminar"&gt;
  &lt;h3&gt;{{name}}&lt;/h3&gt;
  &lt;p&gt;Theme: {{byLine}}&lt;/p&gt;
&lt;/script&gt;</pre></div><p>We will be <a id="id305" class="indexterm"/>using the data that we used from the beginning of the chapter with this example. Other than that, we will also be adding one more plugin library to this example. It is clearly one of my favorite Knockout libraries, the <strong>Punches</strong> library. After all, what would Knockout be without punches? So we need to include jQuery, Knockout, Knockout-mapping, and Knockout punches, and that will work for now.</p><p>Here is the binding data for our traditional template included on this page:</p><div><pre class="programlisting">&lt;h2&gt;Guests&lt;/h2&gt;
These are the guests:
&lt;div data-bind="template: { name: 'guest-template', data: guest1 }"&gt;&lt;/div&gt;
&lt;div data-bind="template: { name: 'guest-template', data: guest2 }"&gt;&lt;/div&gt;</pre></div><p>Here is the output we get from this section of code on our page. If you took time to look at our templates, you may have noticed something different. The style of coding we used to tell our templates what variables we wanted to merge is now surrounded with double curly brackets. Yet, our output is just as we would expect without the need to dig in and use the <code class="literal">data-bind</code> attribute to deliver the results:</p><div><img src="img/1028OS_05_11.jpg" alt="Awesome template options"/></div><p>Now, we will take a look at Punches template syntax. We are including the code for the standard bindings to make sure someone does not assume that this is the code that belongs in the <code class="literal">script</code> tags. This is HTML code and should be added right to the View code on our page as follows:</p><div><pre class="programlisting">&lt;h2&gt;Guests&lt;/h2&gt;
These are the guests:
&lt;div data-bind="template: { name: 'guest-template', data: guest1 }"&gt;&lt;/div&gt;
&lt;div data-bind="template: { name: 'guest-template', data: guest2 }"&gt;&lt;/div&gt;
{{#template {name:'guest-template', data: guest1} /}}
{{#template {name:'guest-template', data: guest2} /}}</pre></div><p>When you run <a id="id306" class="indexterm"/>the code again you will see <strong>Pete</strong> and <strong>Re-Pete</strong> are putting out the same results twice. Some people, because of their personal style, may prefer the Punches style of coding. You may have remembered that I mentioned my former favorite style of coding was Handlebars. This is similar to Handlebars coding syntax, so it works best for me; if it's not your style then just count it as a difference in developer personality. Here is the updated screenshot:</p><div><img src="img/1028OS_05_12.jpg" alt="Awesome template options"/></div><p>There is one other approach that I am using now to put templates on a page. I am using Knockout-powered custom tags. Well, sort of. They are modified with a library that, I call "KOmponents". You will learn more about Knockout custom tags in the next chapter, but it seemed fitting to show you one in action here. We will put the output on the page a third time. Here is the modified View markup:</p><div><pre class="programlisting">&lt;h2&gt;Guests&lt;/h2&gt;
These are the guests:
&lt;div data-bind="template: { name: 'guest-template', data: guest1 }"&gt;&lt;/div&gt;
&lt;div data-bind="template: { name: 'guest-template', data: guest2 }"&gt;&lt;/div&gt;
{{#template {name:'guest-template', data: guest1} /}}
{{#template {name:'guest-template', data: guest2} /}}
&lt;kom-template data="guest1" template="'guest-template'"&gt;&lt;/kom- template&gt;
&lt;kom-template data="guest2" template="'guest-template'"&gt;&lt;/kom- template&gt;</pre></div><p>Here we go; run the code and you will see we get a third set of <strong>Pete</strong> and <strong>Re-Pete</strong> on the page. We will skip <em>repeating</em> another copy of <strong>Pete</strong> and <strong>Re-Pete</strong> in our screen images. The goal <a id="id307" class="indexterm"/>was to show you that they all put out the same content.</p><p>We will complete this by adding this to the bottom of our View markup below all the <code class="literal">guest-template</code> sections:</p><div><pre class="programlisting">&lt;hr&gt;
{{#template 'guest-template-alt'/}}
&lt;hr&gt;
&lt;h2&gt;Seminar&lt;/h2&gt;
&lt;div data-bind="template: { name: 'tmpl-Seminar', data: conference }"&gt;&lt;/div&gt;</pre></div><p>These will put out the content of the templates with the following results. You see, we have chosen to use the Punches with the Handlebars-style approach in one of them again.</p><div><img src="img/1028OS_05_13.jpg" alt="Awesome template options"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Summary</h1></div></div></div><p>This chapter has given you a well-rounded introduction to Knockout templates. If you have never used templates before, we hope you appreciate the concept of templates. If you have used them before, we hope you like the richer data-bound auto-updating ability of templates using Knockout.</p><p>In this chapter we have learned what templates do and how to use them with Knockout. We have learned how to nest templates with collections and non-collection structures. We have learned how to use event triggers and mixed a little jQuery in to modify template results. We have also learned how to mix in third-party template technology, the concept of subscribing to observables, and a couple of extra ways to merge templates onto our page. We also learned to use an alternative style of binding with the Punches library.</p><p>In our next chapter, we will dive into the wonder of building our own custom HTML tags. Has there ever been a time when you thought that standard HTML tags were limited? You actually wanted to have some programmable interactive features of HTML-style tags? Jump into the next chapter and you will find what you are looking for in both cases.</p></div></body></html>