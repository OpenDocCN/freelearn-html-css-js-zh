- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stack Development Technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing what tools and apps to use can speed up your development process significantly.
    That is why we need to prepare our development environment first before typing
    lines of code. The development environment should make you feel comfortable and
    help you throughout the process of learning and writing your microservices.
  prefs: []
  type: TYPE_NORMAL
- en: It is like building a house. Choosing the right tools can speed up the process
    and save you time. Of course, having the right tools doesn’t mean you will succeed,
    but it is better to fail with the right ones than to have the cause of failure
    be the choice of tools.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on installing the required tools. The programming language
    and frameworks are also tools for us to build microservices. In one form or another,
    everything we use while writing software is a tool for us. It makes no sense to
    install all the tools we plan to use at this point, but at least understanding
    how to install most of them will help us to switch to coding faster.
  prefs: []
  type: TYPE_NORMAL
- en: We will also have a look at some of the Node.js frameworks that we plan to use
    in this book. Understanding them is crucial for fast and easy development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and its installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and installing Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and installing Apache Kafka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and installing Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this chapter, you only need a browser of your choice and
    an internet connection. Regarding the rest of the tools we plan to use, we will
    learn how to install them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and its installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in the previous chapter, Node.js is a runtime environment built
    on Google’s V8 engine. You can build a wide variety of applications using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web applications**: Node.js is a popular choice for building both the backend
    and frontend of web applications. Its JavaScript-based environment makes it easy
    for developers to work on both sides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time applications**: Node.js’s event-driven architecture and non-blocking
    I/O model make it ideal for building real-time applications such as chat apps,
    collaboration tools, and streaming services. These applications require constant
    communication between users and the server, and Node.js can handle this efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single-page applications** (**SPAs**): SPAs are web applications that load
    a single HTML page and update the content dynamically using JavaScript. Node.js
    can be used to build the backend API that provides data to the SPA client-side
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API-driven applications**: Many modern applications rely on **application
    programming interfaces** (**APIs**) to access data and functionality from other
    services. Node.js is a great choice for building these APIs due to its ability
    to handle many concurrent requests efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices**: Node.js is well-suited for building microservices because
    of its modular nature and asynchronous capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-line tools**: Node.js can be used to create command-line tools that
    automate tasks or interact with other systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Desktop applications**: While less common, Node.js can also be used to build
    desktop applications with frameworks such as Electron.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, this is not the full list, but it gives you a good idea of the wide
    range of applications that can be built with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Learning some technology or language mostly starts with installing the required
    tools. The same applies to Node.js. So, let’s dive into its installation process.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js for Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be surprised but I’m a big fan of Microsoft and its products. This
    means I’m using a Windows **operating system** (**OS**). All types of installations
    will be explained using mainly the *Windows OS,* but I will provide the relevant
    links to help non-Windows users be on the same level of progress.
  prefs: []
  type: TYPE_NORMAL
- en: When installing Node.js from the official page ([www.nodejs.org](http://www.nodejs.org)),
    it automatically detects your OS and provides the exact OS instructions to install
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We also have different ways of installing Node.js, even for the same OS. The
    most popular ones are prebuilt installers and installation via package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow these step-by-step instructions to install Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [www.nodejs.org/en/download](http://www.nodejs.org/en/download). In my
    case, I’ll be using Windows-based instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **prebuilt installer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the tab, select the required version of Node.js, along with the OS and
    CPU architecture to run it (*Figure 4**.1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You might be wondering which version of Node.js to choose – **LTS** or **Current**?
    Well, the answer is easy:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For long-term use, where things need to stay stable and work well together,
    the **LTS** version is a safe bet. It’s a reliable option.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the **Current** version has all the latest bells and whistles,
    which is great for programmers who want to try out new features.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For our code examples, the LTS version is sufficient. Select it and continue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1: The Node.js installation page](img/B09148_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The Node.js installation page'
  prefs: []
  type: TYPE_NORMAL
- en: These same instructions are applicable for *non-Windows* users. You need to
    select your appropriate OS and its platform and click the green **Download Node.js**
    **v<version_number>** button. Depending on the selected version, the version on
    the button will automatically be updated. We’ll look at this installation in depth
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When installing, just accept the license and follow the wizard’s instructions
    without any custom setup configuration. In the middle of the installation, the
    wizard will require you to select how the app will behave when compiling native
    modules. It is preferable to select the checkbox shown in (*Figure 4**.2*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2: Node.js’s “Tools for Native Modules” window](img/B09148_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Node.js’s “Tools for Native Modules” window'
  prefs: []
  type: TYPE_NORMAL
- en: If you select the **Automatically install** checkbox (*Figure 4**.2*), it will
    install additional tools like Chocolatey, Python, and Visual Studio Build Tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, just press the *Win* + *R* combination and type `node`
    in the window that opens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3: The input window for running your commands](img/B09148_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The input window for running your commands'
  prefs: []
  type: TYPE_NORMAL
- en: 'After typing `node`, hit *Enter*. You should see the following app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4: Node command line](img/B09148_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Node command line'
  prefs: []
  type: TYPE_NORMAL
- en: The window shown in *Figure 4**.4* is a **read-eval-print loop** (**REPL**),
    which serves as a programming language environment, akin to a console window (*Figure
    4**.5*). It accepts a single expression as input from the user, processes it,
    and then displays the result in the console. It is a handy method for promptly
    experimenting with basic JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Node.js REPL](img/B09148_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Node.js REPL'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s continue our discussion of installing Node.js in terms of macOS and
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js for macOS and Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the easiest options for macOS and Linux users is to use a package-manager-based
    installation. Select your OS and go to the **Package Manager** section. From the
    **using** section, you can select the active management tool (*NVM*, *Brew*, *Chocolatey*,
    or *Docker*) and follow the instructions provided in that window (*Figure 4**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Node.js installation for different OSs](img/B09148_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Node.js installation for different OSs'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to download Node.js for Linux distributions using NVM, you should
    follow the instructions provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Please note that Node.js versions may differ while you read this book. For more
    up-to-date installation instructions, please read Node.js’s official page.
  prefs: []
  type: TYPE_NORMAL
- en: While Node.js is our primary tool while developing microservices, throughout
    the learning process, we will also use some of Node.js’s frameworks to make our
    lives easier. The most popular ones that we’ll use in this book are *NestJS* and
    *Express.js*.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has a lot of interesting frameworks. We’ll be using *NestJS* and *Express.js*
    (we look at more on these frameworks shortly) but of course, more frameworks rely
    on Node.js, and it is impossible to use all of them in a single book and even
    if possible, it doesn’t make too much sense to do it.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, Node.js is not a framework but a runtime environment that
    executes JavaScript code outside the browser. Some developers call it a framework
    but that is not true. We need to understand the term framework to understand whether
    something is a framework or not. In programming, a **framework** is essentially
    a pre-built structure that serves as a foundation for creating software applications.
    It’s like a blueprint that you can customize to fit your specific needs, rather
    than having to start entirely from scratch. Frameworks come with pre-written code
    for common functionalities, such as handling user input, database interactions,
    or security. These components act as building blocks that you can leverage to
    save time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks often have a defined way of organizing your code, which ensures consistency
    and makes it easier for other developers to understand and maintain the code base.
  prefs: []
  type: TYPE_NORMAL
- en: A key aspect of frameworks is an *inversion of control*. Instead of your code
    calling into the framework, the framework calls your code at specific points.
    This allows the framework to manage the overall flow of the application.
  prefs: []
  type: TYPE_NORMAL
- en: With that information, you can tell Node.js is not a framework. It is just a
    runtime, but we have frameworks that are built on *top* of Node.js. The most popular
    ones are *NestJS*, *Express.js*, *MeteorJS*, and *SailsJS*. Oh, by the way – many
    popular frameworks, such as *Sails*, *NestJS*, *Kraken*, *poet*, and *Item API*,
    are built on Express. As mentioned previously, we’ll be using NestJS and Express.js,
    so let’s look at them closely.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Express.js** simplifies the web development process. By using Express.js
    effectively, you can create dynamic and interactive web experiences for your users.
    Because Express.js is lightweight, it’s a great choice for creating web applications
    that need to perform well under heavy traffic. One of the key features of Express.js
    is its ability to handle different routes, which are essentially paths users take
    to access specific parts of your web application.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine Node.js as the building blocks and tools, like bricks and mortar. Express.js
    is like prefabricated walls and plumbing – it gives you a structured way to assemble
    those blocks to create a web application faster. Building a complex web application
    with just Node.js can get messy. Express.js provides a framework so that you can
    organize your code into routes, middleware, and views, making it more maintainable
    and easier for others to understand.
  prefs: []
  type: TYPE_NORMAL
- en: While you can build everything from scratch with Node.js, Express.js offers
    built-in features for handling routes, handling HTTP requests and responses, and
    creating APIs, saving you time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js is a popular framework with a vast community of developers. This
    means you have access to a wealth of resources, tutorials, and additional libraries
    to streamline development. While there are other Node.js frameworks available,
    Express.js is a strong choice due to its simplicity, flexibility, and large community
    support.
  prefs: []
  type: TYPE_NORMAL
- en: NestJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NestJS** is a framework built on top of Node.js that is specifically useful
    for building robust and scalable server-side applications.'
  prefs: []
  type: TYPE_NORMAL
- en: NestJS enforces a clear and organized architecture for your application. This
    makes complex projects easier to manage and maintain, especially for teams of
    developers. It integrates seamlessly with TypeScript, a superset of JavaScript
    that adds static typing for improved code reliability and fewer errors. It also
    promotes a modular approach, where you break down your application into smaller,
    reusable components. This makes your code base more organized and easier to scale
    as your application grows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Another piece of good news is that if you’re familiar with *Angular*, a popular
    frontend framework that NestJS borrows many concepts, it makes it easier to learn
    and use for Angular developers.
  prefs: []
  type: TYPE_NORMAL
- en: NestJS goes beyond basic web applications. You can build RESTful APIs, GraphQL
    APIs, WebSockets applications, and even command-line interfaces using this framework.
  prefs: []
  type: TYPE_NORMAL
- en: It also utilizes **dependency injection**, a powerful technique for managing
    dependencies between different parts of your application. This promotes loose
    coupling and makes your code more testable.
  prefs: []
  type: TYPE_NORMAL
- en: Long story short, NestJS provides a structured and feature-rich toolkit on top
    of Node.js, allowing you to build scalable and maintainable server-side applications
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between Express.js and Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book is not about Node.js frameworks, and our aim is not to provide full
    information about them. However, having fundamental knowledge about the differences
    between these two will help us to have a broader understanding. Let’s outline
    some situations where either of these frameworks would be a good fit. With this
    understanding, you’ll be able to make a more informed decision and pick the right
    framework for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Express.js in the** **following situations**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your project is small or medium-sized. For simpler web applications or APIs,
    Express.js’s lightweight and flexible nature might be ideal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you prioritize flexibility. Express.js offers more control over your application’s
    structure, allowing you to tailor it to your specific needs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re familiar with JavaScript. If you’re comfortable with vanilla JavaScript,
    the learning curve for Express.js is gentler.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use NestJS in the** **following situations**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your project is large or complex. NestJS’s structured architecture and features
    are beneficial for managing and maintaining bigger applications with multiple
    developers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you value scalability. NestJS’s modular design makes it easier to scale your
    application as it grows in terms of features and complexity.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want built-in features. NestJS offers features such as dependency injection
    and support for TypeScript out of the box, improving code maintainability and
    reliability.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If your team is familiar with Angular. If your developers have experience with
    Angular, NestJS’s similar structure can ease the learning curve.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After installing Node.js, we need to prepare our **integrated development environment**
    (**IDE**) for development.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing the right IDE may help you do fast development. For Node.js development,
    especially to follow our code examples, we don’t have strict requirements related
    to IDE. You can use your favorite text editor or built-in text editor for your
    OS. Choosing the right IDE is a taste and functionality preference. An IDE helps
    you in syntax highlighting, autocompletion, and refactoring, and also easily interacts
    with important libraries. You can use different IDEs, such as *Visual Studio Code*,
    *Eclipse Che*, *Sublime Text*, *WebStorm*, and *IntelliJ IDEA*.
  prefs: []
  type: TYPE_NORMAL
- en: We prefer Visual Studio Code because it is free, easy to use, can be extended
    using extensions, is cross-platform compatible, easily configurable, and supports
    multiple programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install Visual Studio Code. To install it, just follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://code.visualstudio.com/download](https://code.visualstudio.com/download).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on your OS version and wait for the download to be completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the file you’ve downloaded and follow the default instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you learn microservices development, you’ll become familiar with the classical
    application installation process. For that reason, we haven’t provided detailed
    screenshots and won’t be spending too much time on installation details. For more
    information, you can simply search for the relevant application installation instructions
    on Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code provides a rich extension library for all needs (*Figure
    4**.7*). You can download anything you want to help you do fast development, refactor,
    highlight your code, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Visual Studio Code’s EXTENSIONS section](img/B09148_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Visual Studio Code’s EXTENSIONS section'
  prefs: []
  type: TYPE_NORMAL
- en: After installing our IDE, it is time to install Docker. It is a must-have tool,
    especially nowadays for microservice application development. We’ll be actively
    using Docker in our development, so let’s dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before installing Docker, we need to understand its value and purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** is like a shipping container for your software. It packages everything
    your application needs to run – the code, libraries, and settings – and bundles
    them together. This ensures your application runs everywhere, in any OS without
    any issues. It guarantees that if the application works locally, it will work
    globally.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker guarantees your application runs exactly how you built it, every time.
    No more surprises due to different computer setups.
  prefs: []
  type: TYPE_NORMAL
- en: The main concepts in Docker are images and containers. **Containers** are lightweight
    and start up quickly, making testing and development cycles much smoother. You
    can simply ship the Docker container to any environment, cloud-based or not, and
    be confident it will work. Containers share the underlying OS, so you can run
    more applications on a single machine without bogging it down.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of Docker, an **image** is like a blueprint for a Docker container.
    It’s a set of instructions that specify what goes inside the container, including
    the software, libraries, and configurations needed for your application to run.
    You build an image once, and you can use it to create many containers, saving
    you time and effort. Images can be shared and downloaded easily, allowing you
    to run your application on any machine with Docker. One of the advantages of images
    is that everyone using the same image gets the same environment, reducing surprises
    and ensuring reliable application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to install some applications to your computer *forever* and
    easily remove them after development is done, it would be better to not directly
    install them but use Docker for your installation.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, Docker simplifies the process of building, shipping, and running
    applications. It’s like having a universal box for your software, ensuring it
    runs flawlessly wherever it goes.
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough theory – let’s dive into the Docker installation process.
  prefs: []
  type: TYPE_NORMAL
- en: You can install Docker for almost all popular OSs, such as Windows, Linux, and
    Mac. It may have specific requirements for your OS, which you can learn about
    by navigating to [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
    Then, you can select your OS to install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that requirements may vary by the OS’s internal version. In the **System
    requirements** section, you’ll see prerequisites based on the internal version
    of the selected OS (*Figure 4**.8*). For instance, for Windows, we have **WSL
    2 backend** and **Hyper-V backend and Windows containers** system requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Docker’s System requirements section](img/B09148_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Docker’s System requirements section'
  prefs: []
  type: TYPE_NORMAL
- en: If your OS meets the provided system requirements, you’ll be able to install
    Docker Desktop (*Figure 4**.8*). For Windows, **WSL 2** is recommended over **Hyper-V**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation is a straightforward process and doesn’t require any additional
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Docker Desktop](img/B09148_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Docker Desktop'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker is not the only powerful tool that we need to use when building microservices.
    We have another great tool that helps us have real-time communication between
    our microservices: Apache Kafka.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and installing Apache Kafka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Apache Kafka** is an open-source platform that handles real-time data streams.
    Originally designed as a messaging queue, it has evolved into a robust system
    for streaming data and building event-driven architectures. Communication between
    microservices is crucial, and that’s where Kafka shines.'
  prefs: []
  type: TYPE_NORMAL
- en: Kafka itself is a huge concept that needs a different book. In this book, we’re
    going to provide enough information that we’ll be able to integrate and use it
    for our microservices. For more detailed information, you can follow my *Apache
    Kafka for Distributed Systems* course on the Udemy platform ([https://www.udemy.com/course/apache-kafka-for-distributed-systems/](https://www.udemy.com/course/apache-kafka-for-distributed-systems/)).
  prefs: []
  type: TYPE_NORMAL
- en: Kafka uses a **publish-subscribe** messaging model. Services, acting as producers,
    publish events to specific channels known as **topics** within Kafka. Other services,
    functioning as consumers, subscribe to relevant topics and receive these events
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: This approach beautifully decouples services from one another. Producers don’t
    need to wait for consumers to be available, and consumers can process events at
    their own pace. This improves scalability and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Kafka also acts as a buffer, storing events until consumers are ready. This
    enables asynchronous processing, which prevents bottlenecks and improves overall
    system responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Kafka is built for reliability. It replicates data across multiple nodes, ensuring
    that messages aren’t lost even if a server fails. This enhances fault tolerance
    within the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to know that Kafka scales horizontally. You can easily add more
    nodes to handle increasing data volumes without impacting existing services. This
    caters perfectly to the dynamic nature of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, a key feature of Kafka is its ability to handle real-time
    data streams. This is valuable for microservices that need to react to events
    promptly, such as in fraud detection or stock trading applications.
  prefs: []
  type: TYPE_NORMAL
- en: Kafka is flexibly related to programming languages and integrates seamlessly
    with various programming languages, making it adaptable to diverse microservice
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kafka Streams**, a powerful API within Kafka, empowers you to perform real-time
    computations and transformations on data streams within the Kafka cluster itself.
    This stream processing capability adds significant value to microservice architectures.'
  prefs: []
  type: TYPE_NORMAL
- en: Long story short, by integrating Apache Kafka, microservice development benefits
    from increased scalability, resilience, and agility. It fosters a loosely coupled,
    event-driven approach that empowers microservices to communicate and react to
    changes effectively. This translates to a more robust, adaptable, and high-performing
    application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Kafka’s installation varies by OS, and you need some additional configuration
    per OS.
  prefs: []
  type: TYPE_NORMAL
- en: Also, along with Apache Kafka, we may use Zookeeper and Kafka UI. Starting from
    Apache Kafka `v4`, you won’t need Zookeeper. However, this feature is still in
    development, so it makes sense to understand it also. Zookeeper has multiple responsibilities
    and plays a critical role as the coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: Kafka itself is a CLI-based tool, so if you want to see things graphically,
    you’ll need additional tools, such as Kafka UI, Offset Explorer, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'But I have good news for you. If you have Docker installed, there is no need
    to dive into the details of the installation process. We can create a `docker-compose`
    file to combine the required tools and install them together. You can download
    files one by one, but `docker-compose` helps you to create a special YAML file
    where you can define all the tools and application dependencies and install them
    together. Here is our `docker-compose` file’s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To install Apache Kafka, you need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Docker Desktop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to `Ch04``/docker-compose.yml` and download it to your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the command line from the folder and type `docker-compose` `up -d`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker should start pooling the images and create containers based on these
    images (*Figure 4**.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Docker with running containers](img/B09148_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Docker with running containers'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to move forward and understand how to install Git, an essential
    tool under a developer’s belt.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and installing Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is a powerful **version control system** (**VCS**) for software development.
    Imagine it as a time machine for your code. It tracks every change you make to
    your project, like a detailed logbook.
  prefs: []
  type: TYPE_NORMAL
- en: With Git, you can easily revert to a previous version of your code, essentially
    undoing any errors.
  prefs: []
  type: TYPE_NORMAL
- en: It makes collaboration easy. Working with a team? Git lets everyone collaborate
    seamlessly. Each team member can work on their part of the project, and Git helps
    merge their changes smoothly, avoiding conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: It also keeps a detailed history of all the changes, allowing you to see exactly
    what modifications were made and by whom. This is crucial for tracking progress
    and understanding the project’s journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git is one of the most important tools that we use in our day-to-day development
    process. You can install Git for any popular OS, particularly for Linux, Windows,
    and Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed instructions for *Linux*, go to [https://git-scm.com/download/linux](https://git-scm.com/download/linux).
    There, you can find a Linux-distribution-based installation for Git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with other popular tools, we have multiple options to install Git on *macOS*.
    Go to [https://git-scm.com/download/mac](https://git-scm.com/download/mac) to
    learn more about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For *Windows*, I prefer to use the **Git for Windows** tool. You can download
    it from [https://gitforwindows.org/](https://gitforwindows.org/). This application
    provides Git Bash and Git GUI mechanisms (*Figure 4**.11*). You can use any of
    them throughout your development:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.11: Git for Windows](img/B09148_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Git for Windows'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another tool we need to install. Let’s continue our installation journey
    with Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The penultimate tool we’ll cover in this chapter is Postman. We’ll build a lot
    of APIs, and we need some tools to rapidly and easily test them. It’s a tool that
    helps developers interact with and test APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what Postman helps you do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build APIs**: You can design and plan out your API using Postman’s tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test APIs**: Send requests (such as asking for information) and see the responses
    (the information you get back) from the API. This helps ensure the API works as
    expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Work with APIs**: Postman lets you easily send different kinds of requests
    to APIs and see the results. It’s like having a remote control for the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how you can install it:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.postman.com/downloads/](https://www.postman.com/downloads/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on your OS’s name and download the relevant file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After installing Postman, open it. At this point, you can insert any URL into
    the URL section. There, you can also select the HTTP method (`GET`, `POST`, `PUT`,
    and so on) for that URL and send the request (*Figure 4**.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: An overview of Postman](img/B09148_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: An overview of Postman'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, let’s move on to the final tool in this chapter: MongoDB.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a popular NoSQL database. We will use it when we develop microservices
    and it might be a good choice for you in the future when you build microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may consider MongoDB based on the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document-oriented**: Unlike traditional relational databases, which store
    data in tables with rows and columns, MongoDB stores data in flexible JSON-like
    documents. This makes it easier to represent complex data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable**: MongoDB can handle large datasets and high-traffic applications
    by scaling horizontally. It does this by adding more servers to the database cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible schema**: MongoDB allows for flexible schema design. Documents within
    a collection can have different structures. This is useful for storing data that
    doesn’t fit neatly into rigid table structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform**: MongoDB runs on various OSs, including Windows, Linux,
    and macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source**: The core MongoDB server is open source and free to use, with
    a variety of commercial licenses available for additional features and support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install MongoDB Server, just navigate to [https://www.mongodb.com/docs/manual/installation/](https://www.mongodb.com/docs/manual/installation/)
    and select your platform. At the time of writing, you can install it on Linux,
    macOS, Windows, and Docker. MongoDB has two available editions: Community and
    Enterprise. To experiment and test it, the Community edition will be enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful product for interacting with MongoDB is the MongoDB Compass
    application. It can be found at [https://www.mongodb.com/try/download/compass](https://www.mongodb.com/try/download/compass)
    and is free. You can install it for different platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: MongoDB Compass supports different platforms](img/B09148_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: MongoDB Compass supports different platforms'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB Compass is a free, **graphical user interface** (**GUI**) tool specifically
    designed for interacting with MongoDB databases. It essentially acts as a user-friendly
    client application that simplifies managing and working with your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use it for the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visualizing data**: Compass allows you to browse collections, view documents
    in a clear and organized format, and explore the structure of your data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Querying**: You can write and execute queries directly within Compass to
    filter and retrieve specific data from your MongoDB databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building complex queries**: Compass provides a visual interface for building
    aggregation pipelines, which are powerful tools for transforming and analyzing
    your data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CRUD operations**: Compass allows you to easily'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**create, read, update, and delete** (**CRUD**) documents within your collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema analysis**: Compass helps you understand the structure and relationships
    within your data by providing schema visualization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Index optimization**: Compass can recommend and assist with creating indexes
    on your collections to optimize query performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection management**: Compass allows you to connect to various MongoDB
    deployments, including local servers, cloud instances, and containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, MongoDB Compass offers a user-friendly and intuitive way to interact
    with your MongoDB databases. It’s a valuable tool for database administrators,
    developers, and anyone who needs to explore, analyze, and manage their MongoDB
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a well-prepared development environment is crucial for a smooth and efficient
    software development process. By installing the necessary tools and programs beforehand,
    you eliminate the need to scramble for them mid-development, saving valuable time.
    A configured environment ensures a consistent workflow. You know exactly where
    your files are located, how to run them, and what commands to use. This reduces
    cognitive load and lets you focus on coding.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same tools throughout the project helps maintain code style and consistency.
    This makes the code easier to read, understand, and maintain for yourself and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: When everyone on the team uses the same development environment, collaboration
    becomes smoother. They can easily share code, troubleshoot issues, and understand
    each other’s work.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we talked about the tools we need to install before starting
    our development journey. Of course, we haven’t installed all the tools, but the
    main ones are here. We’ll introduce additional tools as needed in future chapters,
    ensuring the installation process is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re here, then congratulations! Starting from the next chapter, we will
    dive into the details of microservice development in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Building and Managing Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will dive into the practical aspects of building microservices
    with JavaScript. We’ll start by creating a basic CRUD (Create, Read/Retrieve,
    Update, Delete) microservice and then move on to more advanced concepts, such
    as synchronous and asynchronous communication between services. We will also cover
    real-time data streaming, which is essential for creating responsive and dynamic
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B09148_05.xhtml#_idTextAnchor074), *Basic CRUD* *Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B09148_06.xhtml#_idTextAnchor104), *Synchronous Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B09148_07.xhtml#_idTextAnchor121), *Asynchronous Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B09148_08.xhtml#_idTextAnchor135), *Real-Time Data Streaming
    Using Microservices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
