- en: '*Chapter 3*: Navigating through a website'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：浏览网站'
- en: We have already laid the foundations for the rest of the book. In [*Chapter
    1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Getting started with Puppeteer*,
    we learned about browser automation and headless browsers. [*Chapter 2*](B16113_02_Final_SK_ePub.xhtml#_idTextAnchor038),
    *Automated Testing and Test runners*, was about automated testing and test runners.
    Now it's time to get more practical. In this chapter, we will learn about UI testing,
    but in the real world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为本书的其余部分奠定了基础。在[*第1章*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014) *Puppeteer入门*中，我们学习了浏览器自动化和无头浏览器。[*第2章*](B16113_02_Final_SK_ePub.xhtml#_idTextAnchor038)
    *自动化测试和测试运行器*是关于自动化测试和测试运行器。现在是时候更实际一些了。在本章中，我们将学习关于UI测试，但是在现实世界中。
- en: In the following chapters, we will pick an open-source website made with Vue.js
    to test, but we are also going to navigate through many other public websites.
    I want you to learn techniques that help you test websites no matter the framework
    they use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将选择一个用Vue.js制作的开源网站进行测试，但我们也将浏览许多其他公共网站。我希望你学习到可以帮助你测试任何框架的网站的技术。
- en: I also want to share some tools with you, so you can finish this book with a
    complete toolbox. In this chapter, we will learn how to ship our code to GitHub
    and run our tests using GitHub Actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想与你分享一些工具，这样你就可以带着一个完整的工具箱完成这本书。在本章中，我们将学习如何将我们的代码推送到GitHub并使用GitHub Actions运行测试。
- en: In the previous chapter, we created a test project, and we ran a few tests without
    paying too much attention to the Puppeteer APIs we were using. In this chapter,
    we will create a test project again, but this time we will go deeper and see what
    Puppeteer has to offer on each API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个测试项目，并运行了一些测试，但没有过多关注我们使用的Puppeteer API。在本章中，我们将再次创建一个测试项目，但这次我们将更深入地了解Puppeteer在每个API上能提供什么。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introducing the test site for this chapter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍本章的测试网站
- en: Creating a Puppeteer browser
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Puppeteer浏览器
- en: Navigating through a site
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览网站
- en: Using the Response object
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应对象
- en: Introduction to Continuous Integration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成简介
- en: By the end of this chapter, we will have tested a real website, pushed it to
    GitHub, and run our tests automatically, learning many new APIs. Let's see what
    test sites we can use in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将测试一个真实网站，将其推送到GitHub，并自动运行我们的测试，学习许多新的API。让我们看看本章我们可以使用哪些测试网站。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will find all the code of this chapter in the GitHub repository ([https://github.com/PacktPublishing/ui-testing-with-puppeteer](https://github.com/PacktPublishing/ui-testing-with-puppeteer))
    under the `Chapter3` directory. We will consider `Chapter3` as the base path for
    all the demos. Inside the `Chapter3` directory, you will find three directories:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库（[https://github.com/PacktPublishing/ui-testing-with-puppeteer](https://github.com/PacktPublishing/ui-testing-with-puppeteer)）下的`Chapter3`目录中找到本章的所有代码。我们将把`Chapter3`作为所有演示的基础路径。在`Chapter3`目录内，你会找到三个子目录：
- en: '`vuejs-firebase-shopping-cart` contains the test site.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vuejs-firebase-shopping-cart`包含测试网站。'
- en: '`init` is the directory you can use to follow this chapter.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`是你可以用来跟随本章的目录。'
- en: '`demo` contains the final code from this chapter.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`demo`包含本章的最终代码。'
- en: Introducing the tests sites for this chapter
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍本章的测试网站
- en: 'In this chapter, we will test a site made with Vue.js. Thang Minh Vu ([https://me.coddeine.com/](https://me.coddeine.com/))
    wrote a great Vue.js example: **vuejs-firebase-shopping-cart** ([https://github.com/ittus/vuejs-firebase-shopping-cart](https://github.com/ittus/vuejs-firebase-shopping-cart)).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将测试一个用Vue.js制作的网站。Thang Minh Vu ([https://me.coddeine.com/](https://me.coddeine.com/))编写了一个很好的Vue.js示例：**vuejs-firebase-shopping-cart**
    ([https://github.com/ittus/vuejs-firebase-shopping-cart](https://github.com/ittus/vuejs-firebase-shopping-cart))。
- en: Tip
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you look for projects on GitHub or any other site like GitHub, you need
    to pay attention to the license the project uses. The fact that the code is open
    source doesn't mean that you can use it as you wish. This project uses the **MIT
    License**, which is one of the most permissive licenses. This license basically
    states that you can use the code *without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is furnished
    to do so.*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在GitHub或任何其他类似GitHub的网站上寻找项目时，你需要注意该项目使用的许可证。代码是开源的并不意味着你可以随意使用它。本项目使用的是**MIT许可证**，这是最宽松的许可证之一。这个许可证基本上表明你可以无限制地使用代码，包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或销售软件副本，并允许软件提供者这样做。
- en: As we don't want you to deal with firebase setup, I forked this project (made
    a copy on GitHub), removing all the firebase code. You can find the base structure
    of the code used in this chapter inside the `init` directory. You just need to
    run `npm install` in the base folder and then run the following commands on the
    `vuejs-firebase-shopping-cart` folder.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望你处理firebase设置，我在GitHub上分叉了这个项目（在GitHub上创建了一个副本），移除了所有的firebase代码。你可以在这个章节中使用的代码的基本结构在`init`目录中找到。你只需要在基本文件夹中运行`npm
    install`，然后在`vuejs-firebase-shopping-cart`文件夹中运行以下命令。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the terminal, you should have got a success message and the URL the site
    is now running:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，你应该已经收到了成功消息和网站现在运行的URL：
- en: '![Site running'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![网站运行中'
- en: '](img/Figure_3.01_B16113.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B16113.jpg)'
- en: Site running
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 网站运行中
- en: Now we should have a nice site running on port `8080`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该在端口`8080`上运行一个不错的网站。
- en: '![Demo site running'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![示例网站运行中'
- en: '](img/Figure_3.02_B16113.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B16113.jpg)'
- en: Demo site running
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例网站运行中
- en: We'll need two terminals to work on this project. In one terminal, we are going
    to run the website. In the second, we are going to launch our tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个终端来完成这个项目。在一个终端中，我们将运行网站。在第二个终端中，我们将启动我们的测试。
- en: If you are using VS Code, notice that the **TERMINAL** tab has a plus button.
    If you click on that button, a new terminal will be created. You can switch between
    terminals using the selection list to the left of that button.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用VS Code，请注意**终端**标签页有一个加号按钮。如果你点击那个按钮，将创建一个新的终端。你可以通过按钮左侧的选择列表在终端之间切换。
- en: '![New terminal option'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![新终端选项'
- en: '](img/Figure_3.03_B16113.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B16113.jpg)'
- en: New terminal option
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 新终端选项
- en: 'Let''s run the site in one terminal using the same commands we used before:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前使用的相同命令在一个终端中运行网站：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should get something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似以下的内容：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let''s run the tests in another terminal:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在另一个终端中运行测试：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here, you should be getting something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应该得到类似以下的内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous chapter, we didn't pay much attention to how we were using Puppeteer.
    We just knew that if we did `browser = await puppeteer.launch();` we would get
    a new browser. How? No idea. Well, it's time to understand a little bit more about
    how Puppeteer works.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们没有过多关注我们如何使用Puppeteer。我们只知道如果我们执行`browser = await puppeteer.launch();`，我们会得到一个新的浏览器。如何？不知道。好吧，现在是时候更深入地了解Puppeteer是如何工作的了。
- en: Creating a Puppeteer browser
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Puppeteer浏览器
- en: The signature of the `launch` function is not `launch()`, but `launch(options)`.
    Thanks to the freedom we have in JavaScript, we can just avoid passing that argument,
    and the `launch` function will get `options` as `undefined`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch`函数的签名不是`launch()`，而是`launch(options)`。由于JavaScript给予我们的自由度，我们可以直接不传递那个参数，`launch`函数将获取`options`作为`undefined`。'
- en: Using the Puppeteer.launch function
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Puppeteer.launch函数
- en: 'These are all the options `Puppeteer.launch` supports in Puppeteer 7 according
    to the official docs ([https://github.com/puppeteer/puppeteer/blob/v7.0.0/docs/api.md#puppeteerlaunchoptions](https://github.com/puppeteer/puppeteer/blob/v7.0.0/docs/api.md#puppeteerlaunchoptions)):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档，以下是Puppeteer 7支持的`Puppeteer.launch`的所有选项（[https://github.com/puppeteer/puppeteer/blob/v7.0.0/docs/api.md#puppeteerlaunchoptions](https://github.com/puppeteer/puppeteer/blob/v7.0.0/docs/api.md#puppeteerlaunchoptions)）：
- en: '`product`: Which browser to launch. At this time, this is either `chrome` or `firefox`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`: 要启动哪个浏览器。在这个时候，这将是`chrome`或`firefox`。'
- en: '`ignoreHTTPSErrors`: Whether to ignore HTTPS errors during navigation. This
    option will become handy when you want to automate websites with invalid or missing
    SSL certificates. This will prevent Chromium from returning an invalid certificate
    page in those cases.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreHTTPSErrors`: 在导航期间是否忽略 HTTPS 错误。当你想自动化具有无效或缺失 SSL 证书的网站时，此选项将变得很有用。这将防止
    Chromium 在这些情况下返回无效证书页面。'
- en: '`headless`: Whether to run the browser in headless mode. Defaults to `true` unless
    the `devtools` option is `true`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headless`: 是否以无头模式运行浏览器。默认为 `true`，除非 `devtools` 选项为 `true`。'
- en: '`executablePath`: Path to a browser executable to run instead of the bundled
    Chromium.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executablePath`: 运行浏览器可执行文件的路径，而不是捆绑的 Chromium。'
- en: '`slowMo`: Slows down Puppeteer operations by the specified number of milliseconds.
    Useful so that you can see what is going on.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slowMo`: 通过指定的毫秒数减慢 Puppeteer 操作。这很有用，可以让你看到正在发生的事情。'
- en: '`defaultViewport`: Sets a consistent viewport for each page. Defaults to an
    800x600 viewport. `null` disables the default viewport. A viewport is an object
    with the following properties:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultViewport`: 为每个页面设置一致的视口。默认为 800x600 视口。`null` 禁用默认视口。视口是一个具有以下属性的对象：'
- en: 'a) `width`: page width in pixels.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'a) `width`: 以像素为单位的页面宽度。'
- en: 'b) `height`: page height in pixels.'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'b) `height`: 以像素为单位的页面高度。'
- en: 'c) `deviceScaleFactor`: Specify device scale factor.'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'c) `deviceScaleFactor`: 指定设备缩放因子。'
- en: 'd) `isMobile`: Whether the `meta viewport` tag is taken into account.'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'd) `isMobile`: 是否考虑 `meta viewport` 标签。'
- en: 'e) `hasTouch`: Specifies whether the viewport supports touch events.'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'e) `hasTouch`: 指定视口是否支持触摸事件。'
- en: 'f) `isLandscape`: Specifies whether the viewport is in landscape mode.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'f) `isLandscape`: 指定视口是否处于横幅模式。'
- en: '`args`: Additional arguments to pass to the browser instance.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`: 传递给浏览器实例的附加参数。'
- en: '`ignoreDefaultArgs`: If `true`, then do not use `puppeteer.defaultArgs()`.
    If an array is given, then filter out the given default arguments.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreDefaultArgs`: 如果为 `true`，则不使用 `puppeteer.defaultArgs()`。如果提供了一个数组，则过滤掉给定的默认参数。'
- en: '`handleSIGINT`: Close the browser process on *Ctrl +C*.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleSIGINT`: 在按下 *Ctrl +C* 时关闭浏览器进程。'
- en: '`handleSIGTERM`: Close the browser process on `SIGTERM`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleSIGTERM`: 在接收到 `SIGTERM` 信号时关闭浏览器进程。'
- en: '`handleSIGHUP`: Close the browser process on `SIGHUP`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleSIGHUP`: 在接收到 `SIGHUP` 信号时关闭浏览器进程。'
- en: '`timeout`: Maximum time in milliseconds to wait for the browser instance to
    `start`. Defaults to `30000` (30 seconds). Passing `0` disables the timeout.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`: 等待浏览器实例启动的最大时间（以毫秒为单位）。默认为 `30000`（30秒）。传递 `0` 将禁用超时。'
- en: '`dumpio`: Whether to pipe the browser process `stdout` and `stderr` into `process.stdout` and `process.stderr`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dumpio`: 是否将浏览器进程的 `stdout` 和 `stderr` 管道连接到 `process.stdout` 和 `process.stderr`。'
- en: '`userDataDir`: Path to a user data directory.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userDataDir`: 用户数据目录的路径。'
- en: '`env`: Specify environment variables that will be visible to the browser.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`: 指定对浏览器可见的环境变量。'
- en: '`devtools`: Whether to auto-open a DevTools panel for each tab. If this option
    is `true`, the `headless` option will be set to `false`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtools`: 是否为每个标签自动打开 DevTools 面板。如果此选项为 `true`，则 `headless` 选项将设置为 `false`。'
- en: '`pipe`: Connects to the browser over a pipe instead of a WebSocket. Defaults
    to `false`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipe`: 通过管道连接到浏览器而不是 WebSocket。默认为 `false`。'
- en: '`extraPrefsFirefox`: Additional preferences that can be passed to Firefox.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extraPrefsFirefox`: 可以传递给 Firefox 的附加首选项。'
- en: That's a long list, I know. But I didn't want to just write about the features
    I think are interesting. I want you to have the full picture of the `launch` option.
    Now, let's talk about about the options you do need to know.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一份很长的列表，我知道。但我不想只写我认为有趣的特性。我想让你全面了解 `launch` 选项。现在，让我们谈谈你需要了解的选项。
- en: Headless
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无头模式
- en: 'I think the `headless` option is the most used. Remember I told you we were
    going to use headless browsers? I won''t say that I lied, but I lied. Headless
    mode is the default mode, but in fact, you could launch a browser with `headless`
    in `false`, also known as *"headful mode."* Headful mode is useful while debugging
    automation code because you will see what is going on in the browser. I bet that
    will be the default local setting. This is how you can launch the browser in headful
    mode:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 `headless` 选项是最常用的。记得我告诉过你我们要使用无头浏览器吗？我不会说我骗了你，但我确实骗了你。无头模式是默认模式，但实际上，你可以通过将
    `headless` 设置为 `false` 来启动浏览器，这被称为 *"有头模式"*。有头模式在调试自动化代码时很有用，因为你将看到浏览器中的情况。我敢打赌这将是默认的本地设置。这就是你可以在有头模式下启动浏览器的方式：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This line of code will launch a browser that will almost look like a normal
    browser.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将启动一个几乎看起来像正常浏览器的浏览器。
- en: '![A browser in headful mode'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![Headful模式下的浏览器'
- en: '](img/Figure_3.04_B16113.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B16113.jpg)'
- en: A browser in headful mode
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Headful模式下的浏览器
- en: As you can see, that's a full working browser. The only difference is that you
    will get that banner saying that *"Chrome is being controlled by automated test
    software."* If someone asks you, no, you can't remove that banner. I believe that
    with so much phishing and hacking around the internet, it's important to tell
    a potential user of the browser that there is an app behind it controlling and
    monitoring the browser activity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个完整的运行中的浏览器。唯一的区别是，你将看到一个横幅，上面写着“Chrome正在被自动化测试软件控制。”如果有人问你，不，你不能移除那个横幅。我相信，在互联网上到处都是钓鱼和黑客活动的情况下，告诉潜在的用户浏览器后面有一个应用程序在控制和监控浏览器活动是很重要的。
- en: The user data directory
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户数据目录
- en: The `userDataDir`, Puppeteer will create a new directory before launching the
    browser. Then it will delete it when the browser is closed. That would mean that
    sessions or anything we store in cookies won't be preserved across test runs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`userDataDir`，在启动浏览器之前，Puppeteer将创建一个新的目录。然后当浏览器关闭时，它将删除它。这意味着会话或我们存储在cookies中的任何内容都不会在测试运行之间保留。'
- en: In UI testing, we might want to use this option to check whether the site uses
    the local storage (for example, cookies) as expected. Does the site remember the
    logged-in user? Is the cart being preserved?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI测试中，我们可能想要使用这个选项来检查网站是否如预期地使用了本地存储（例如，cookies）。网站是否记得登录用户？购物车是否被保留？
- en: Executable Path
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行路径
- en: The `executablePath` option is not common on UI testing. Most tests will run
    using the browser downloaded by Puppeteer. Still, this option is used a lot in
    task automation or scraping, when you want to use the browser you would normally
    use, or in some continuous integration environments, where you want to run an
    already downloaded browser.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`executablePath`选项在UI测试中并不常见。大多数测试将使用Puppeteer下载的浏览器运行。尽管如此，这个选项在任务自动化或抓取时使用得很多，当你想要使用你通常使用的浏览器，或者在某些持续集成环境中，你想要运行已经下载的浏览器时。'
- en: As we saw in [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Getting started with Puppeteer*, Puppeteer is guaranteed to work with a specific
    version of Chromium. In the case of Puppeteer 7.0.0, the Chromium version is 90.0.4403.0\.
    That doesn't mean that it will not work with any other version, but it's not guaranteed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[*第一章*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014)中看到的，“使用Puppeteer入门”，Puppeteer保证与特定版本的Chromium兼容。在Puppeteer
    7.0.0的情况下，Chromium版本是90.0.4403.0。这并不意味着它不能与任何其他版本一起工作，但它没有保证。
- en: Tip
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you are a macOS user, the Chrome executable will be inside the application
    bundle `Google Chrome.app`. For example, `/Applications/Google Chrome.app/Contents/MacOS/Google
    Chrome`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名macOS用户，Chrome可执行文件将位于应用程序包`Google Chrome.app`内部。例如，`/Applications/Google
    Chrome.app/Contents/MacOS/Google Chrome`。
- en: Using the `executablePath` option won't be enough if we want to use the exact
    same browser we would normally use. Remember that Puppeteer will create a new
    user data directory if we don't pass one. We need to pass the user data directory
    our browser uses. It should be `%LOCALAPPDATA%\Google\Chrome\User Data` in Windows,
    `~/Library/Application Support/Google/Chrome` in Mac, or `~/.config/google-chrome`
    in Linux. If you want to double-check that value, you can navigate to `chrome://version/`
    using your browser. There you will see the current **Profile Path**. You need
    to remove the Default directory in macOS.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用我们通常使用的确切相同的浏览器，仅使用`executablePath`选项是不够的。请记住，如果我们不传递一个，Puppeteer将创建一个新的用户数据目录。我们需要传递浏览器使用的用户数据目录。在Windows中应该是`%LOCALAPPDATA%\Google\Chrome\User
    Data`，在Mac中是`~/Library/Application Support/Google/Chrome`，在Linux中是`~/.config/google-chrome`。如果你想双重检查这个值，你可以使用你的浏览器导航到`chrome://version/`。在那里你会看到当前的**配置文件路径**。你需要从MacOS中删除默认目录。
- en: Tip
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you are going to use your own browser, you can install puppeteer-core instead
    of Puppeteer. puppeteer-core won't download a browser, speeding up your install
    time and saving disk space.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用自己的浏览器，你可以安装puppeteer-core而不是Puppeteer。puppeteer-core不会下载浏览器，这样可以加快安装时间并节省磁盘空间。
- en: Default Viewport
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认视口
- en: 'If you tried the headful mode, you might have seen something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试了headful模式，你可能看到如下内容：
- en: '![Headful mode with no default viewport'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![无默认视口的Headful模式'
- en: '](img/Figure_3.05_B16113.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B16113.jpg)'
- en: Headful mode with no default viewport
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无默认视口的Headful模式
- en: No, the site is not broken. If we don't pass a `defaultViewport`, Puppeteer
    will default to a viewport of 800x600\. If you were wondering what a viewport
    is, according to Wikipedia, *a viewport is the visible portion of the entire document*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不，网站没有出问题。如果我们不传递 `defaultViewport`，Puppeteer 将默认为 800x600 的视口。如果你想知道视口是什么，根据维基百科，“视口是整个文档的可视部分。”
- en: 'The viewport is an important piece of UI testing. UX experts and designers
    make a significant effort trying to give the user the best experience for the
    device they are using. Frontend developers use CSS breakpoints to determine which
    layout to show based on the viewport size. Rico Sta. Cruz, on his blog post *What
    media query breakpoints should I use?* ([https://ricostacruz.com/til/css-media-query-breakpoints](https://ricostacruz.com/til/css-media-query-breakpoints)),
    posted this excellent list of breakpoints:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 视口是 UI 测试的一个重要组成部分。用户体验专家和设计师会付出很大的努力，试图为用户使用设备提供最佳体验。前端开发者使用 CSS 断点来确定根据视口大小显示哪种布局。Rico
    Sta. Cruz 在他的博客文章 *我应该使用哪些媒体查询断点？* ([https://ricostacruz.com/til/css-media-query-breakpoints](https://ricostacruz.com/til/css-media-query-breakpoints))
    中发布了这个出色的断点列表：
- en: 'Mobile devices in portrait: From 320px to 414px.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动设备在竖屏模式下：从 320px 到 414px。
- en: 'Mobile devices in landscape: From 568px to 812px.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动设备在横屏模式下：从 568px 到 812px。
- en: 'Table in portrait: From 768px to 834px.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竖屏表格：从 768px 到 834px。
- en: 'Table in landscape: From 1024px to 1112px.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横屏表格：从 1024px 到 1112px。
- en: 'Laptops: From 1366px to 1440px.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本电脑：从 1366px 到 1440px。
- en: 'Desktop displays: 1680px to 1920px.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面显示器：1680px 到 1920px。
- en: You don't need to have many devices to test this. Just open a browser and change
    the size of the window.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要很多设备来测试这个。只需打开一个浏览器并更改窗口大小。
- en: '![Different breakpoints Packtpub.com uses'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![Packtpub.com使用的不同断点](img/Figure_3.06_B16113.jpg)'
- en: '](img/Figure_3.06_B16113.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B16113.jpg)'
- en: Different breakpoints Packtpub.com uses
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Packtpub.com使用的不同断点
- en: If you look at that screenshot, you will see that the site shows or hides different
    elements based on the viewport. It would show a big search bar in a big viewport,
    assuming a desktop experience. When it detects a small viewport, assuming a mobile
    device, it will hide the search bar and show a hamburger button.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看那张截图，你会看到该网站根据视口显示或隐藏不同的元素。在大的视口中，它会显示一个大的搜索栏，假设是桌面体验。当它检测到小的视口，假设是移动设备，它会隐藏搜索栏并显示汉堡按钮。
- en: We need to consider all these changes when writing our tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的测试时，我们需要考虑所有这些变化。
- en: Tip
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Instead of trying to guess viewports, ask your frontend team what breakpoints
    they are using. But keep in mind that many bugs emerge on those precise breakpoints,
    test the breakpoints, and check whether they are appropriate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图猜测视口大小，询问你的前端团队他们使用哪些断点。但请记住，许多错误正是在这些精确的断点出现的，测试断点，并检查它们是否合适。
- en: We will go deeper into this topic in [*Chapter 8*](B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137),
    *Environments emulation*, when we talk about mobile emulation. One last trick
    here. If we pass `null`, the viewport will adapt to the window size, as you would
    expect in a normal browser.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论移动仿真时，我们将在[*第 8 章*](B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137)“环境仿真”中更深入地探讨这个话题。这里有一个最后的技巧。如果我们传递
    `null`，视口将适应窗口大小，就像在正常浏览器中预期的那样。
- en: Product
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品
- en: 'Are you saying that we can automate Firefox with Puppeteer? Yes, we can. Although
    it is still experimental. This is the official definition of "experimental": *Official
    Firefox support is currently experimental. The ongoing collaboration with Mozilla
    aims to support common end-to-end testing use cases, for which developers expect
    cross-browser coverage. The Puppeteer team needs input from users to stabilize
    Firefox support and to bring missing APIs to our attention.* My unofficial definition
    would be: *It uses a nightly build of Firefox, and the long-term support doesn''t
    seem guaranteed.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你是说我们可以用 Puppeteer 自动化 Firefox 吗？是的，我们可以。尽管这仍然是实验性的。这是“实验性”的官方定义：“目前官方对 Firefox
    的支持是实验性的。与 Mozilla 的持续合作旨在支持常见的端到端测试用例，开发者期望跨浏览器覆盖。Puppeteer 团队需要用户的反馈来稳定 Firefox
    支持，并将缺失的 API 提到我们的注意。”我的非官方定义是：“它使用 Firefox 的夜间构建版本，长期支持似乎没有保证。”
- en: 'Disclaimers aside, if you want to launch a Firefox browser, you need first
    to install Puppeteer setting the `PUPPETEER_PRODUCT` variable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 声明除外，如果你想启动 Firefox 浏览器，你首先需要安装 Puppeteer 并设置 `PUPPETEER_PRODUCT` 变量：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And then you can set Firefox as a product:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以将 Firefox 设置为产品：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Browser Arguments
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器参数
- en: The `args` option is an array of arguments or **flags** you can pass to the
    browser. There are over 1,400 flags ([https://www.hardkoded.com/ui-testing-with-puppeteer/chrome-flags](https://www.hardkoded.com/ui-testing-with-puppeteer/chrome-flags)).
    It would be impossible to cover all 1,400 flags.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`args` 选项是一个可以传递给浏览器的参数或 **标志** 的数组。有超过 1,400 个标志 ([https://www.hardkoded.com/ui-testing-with-puppeteer/chrome-flags](https://www.hardkoded.com/ui-testing-with-puppeteer/chrome-flags))。涵盖所有
    1,400 个标志是不可能的。'
- en: '`--no-sandbox` is the most common flag. From the official documentation: *In
    order to protect the host environment from untrusted web content, Chrome uses
    multiple layers of sandboxing. For this to work properly, the host should be configured
    first.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`--no-sandbox` 是最常见的标志。根据官方文档：*为了保护主机环境免受不受信任的网页内容的影响，Chrome 使用多层沙盒。为了正确工作，主机应首先配置。*'
- en: The key phrase here is *"the host should be configured first."* You might need
    to create a user with the right permissions to use Puppeteer in a more restricted
    context, such as `–no-sandbox` flag, which would bypass the sandboxing system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键短语是 *"主机应首先配置。"* 你可能需要创建一个具有正确权限的用户，以便在更受限的环境中（如使用 `–no-sandbox` 标志）使用
    Puppeteer，这将绕过沙盒系统。
- en: 'Other common flags are the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见标志如下：
- en: '`--window-size` to set the window size.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--window-size` 用于设置窗口大小。'
- en: '`--proxy-server` and `--proxy-bypass-list` to set up proxy settings.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--proxy-server` 和 `--proxy-bypass-list` 用于设置代理设置。'
- en: There is another option called `extraPrefsFirefox`. You can use this property
    to set Firefox flags. Hopefully, you won't need to deal with these flags much.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个选项称为 `extraPrefsFirefox`。您可以使用此属性来设置 Firefox 标志。希望您不需要处理这些标志太多。
- en: Mobile options
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动选项
- en: '`deviceScaleFactor`, `isMobile`, `hasTouch`, and `isLandscape` will help us
    set up mobile emulation. We will cover these options more deeply in [*Chapter
    8*](B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137), *Environments emulation*.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`deviceScaleFactor`、`isMobile`、`hasTouch` 和 `isLandscape` 将帮助我们设置移动仿真。我们将在
    [*第8章*](B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137) *环境仿真* 中更深入地介绍这些选项。'
- en: As you can see, `puppeteer.launch()` is way more than that, and there are many
    others for you to keep digging.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`puppeteer.launch()` 远不止这些，还有许多其他功能供您继续挖掘。
- en: Options in practice
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践中的选项
- en: Now let's see how we can apply these new features in the real world. The first
    thing we can do now, and you should do from now on, is to load the options object
    from the config file. Remember that the config class we have is JavaScript code.
    We can add a property there called `launchOptions` and pass that to the `launch`
    function. You don't even need to populate it if you don't want to, but it will
    be there, ready to be used.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在现实世界中应用这些新特性。我们现在可以做的第一件事，以及你应该从现在开始做的，是从配置文件中加载选项对象。记住，我们拥有的配置类是
    JavaScript 代码。我们可以在其中添加一个名为 `launchOptions` 的属性，并将其传递给 `launch` 函数。如果你不想填充它，你甚至不需要这样做，但它将存在，随时可以使用。
- en: 'Your config file will look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您的配置文件将看起来像这样：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, when we run these tests using the `local` config, it will launch the browser
    in headful mode. The next step is passing this option to the `launch` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们使用 `local` 配置运行这些测试时，它将以全屏模式启动浏览器。下一步是将此选项传递给 `launch` 函数：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's try to code a real-life test. We want to test that the login action
    is being persisted after closing a browser.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试编写一个真实的测试。我们想测试在关闭浏览器后登录操作是否被持久化。
- en: 'These are the steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是步骤：
- en: Open a browser using a user data directory.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用用户数据目录打开浏览器。
- en: Check that we are logged out (checking that the login button says **Login**).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否已注销（检查登录按钮是否显示 **登录**）。
- en: Log in.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录。
- en: Check that we are logged in (checking that the logout button says **Logout**).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否已登录（检查注销按钮是否显示 **注销**）。
- en: Close the browser.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: Open the browser.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器。
- en: We should be logged in.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该已经登录。
- en: 'We won''t be able to reuse the browser we are using in other tests because
    we will need to create our own user data directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将无法在其他测试中重用我们正在使用的浏览器，因为我们需要创建自己的用户数据目录：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This test is longer than the others because we need to create a browser, a page,
    and a model twice. Ignore how the `loginState` and `login` functions work. We
    will cover those functions in the following chapters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试比其他测试要长，因为我们需要创建两次浏览器、页面和模型。忽略 `loginState` 和 `login` 函数的工作原理。我们将在接下来的章节中介绍这些函数。
- en: It's impressive, all the functionality that can be hidden inside a single line.
    Now let's see how we can improve our navigation skills.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 非常令人印象深刻，所有这些功能都可以隐藏在单行代码中。现在让我们看看如何提高我们的导航技能。
- en: Navigating through a site
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网站中导航
- en: 'If you look at how you navigate through different pages on a browser, there
    are basically four ways:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看如何在浏览器中导航到不同的页面，基本上有四种方式：
- en: You type a URL in the address bar or using a bookmark.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在地址栏中输入 URL 或使用书签。
- en: You use the browser functions to go back, forward, or reload a page.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用浏览器函数来后退、前进或重新加载页面。
- en: You click on elements on a page.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在页面上点击元素。
- en: The site you are browsing redirects to another page.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在浏览的网站将重定向到另一个页面。
- en: 'The `goto` function emulates the first option, navigating to a site. We use
    that to navigate to the page we want to test:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 函数模拟了第一个选项，即导航到网站。我们使用它来导航到我们想要测试的页面：'
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, guess what? The `goto` signature isn't `goto(url)` but `goto(url, options)`.
    You will see this pattern being repeated over and over – a function with one or
    more required arguments (or none), and then a set of extra options.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，猜猜看？`goto` 的签名不是 `goto(url)`，而是 `goto(url, options)`。你会发现这个模式反复出现——一个具有一个或多个必需参数（或没有）的函数，然后是一组额外选项。
- en: 'Luckily for us, the options `goto` expects is not as big as the one we saw
    in the `launch` options. It only has three options:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`goto` 期望的选项并不像我们在 `launch` 选项中看到的那样多。它只有三个选项：
- en: '`timeout`: Maximum navigation time in milliseconds.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`: 最大导航时间（以毫秒为单位）。'
- en: '`waitUntil`: When to consider navigation succeeded.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitUntil`: 当何时认为导航成功。'
- en: '`referrer`: Referrer header value.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referrer`: 引用者头部值。'
- en: Let's unpack these options.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些选项。
- en: Timeouts
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超时
- en: 'You will see the `timeout` argument in many functions. Puppeteer groups timeouts
    in two groups: **navigation timeouts** and **generic timeouts** (this is not the
    official name; I named them in this way just to make these concepts easier to
    understand).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在许多函数中看到 `timeout` 参数。Puppeteer 将超时分为两组：**导航超时**和**通用超时**（这不是官方名称；我只是这样命名，以便更容易理解这些概念）。
- en: If we wanted to set a default timeout in all our navigation calls, we could
    create a property in our config file and use it in every place. That sounds like
    a great idea, but there is an even better solution. We can use a property in our
    config file, but instead of passing that to every function we use, we can call
    `page.setDefaultTimeout(timeout)` or `page.setDefaultNavigationTimeout(timeout)`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在所有导航调用中设置默认超时，我们可以在配置文件中创建一个属性并在每个地方使用它。这听起来是个不错的想法，但有一个更好的解决方案。我们可以在配置文件中使用一个属性，但不是将它们传递给每个函数，而是调用
    `page.setDefaultTimeout(timeout)` 或 `page.setDefaultNavigationTimeout(timeout)`。
- en: The `page` object will store the timeout you pass to these functions and use
    them as a default value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`page` 对象将存储传递给这些函数的超时时间，并将其用作默认值。'
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you don't pass a timeout to a function, nor set a default timeout, Puppeteer
    will set the timeout to 30 seconds (30,000 milliseconds).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有向函数传递超时时间，也没有设置默认超时，Puppeteer 将将超时设置为 30 秒（30,000 毫秒）。
- en: 'If we are testing a site locally, waiting 30 seconds for a page to load sounds
    like a lot. Let''s reduce that time to 5 seconds. We can add a new property in
    our config file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在本地测试网站，等待 30 秒来加载页面听起来好像很多。让我们将时间减少到 5 秒。我们可以在配置文件中添加一个新的属性：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And then, we can set that value using the default timeout:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用默认超时来设置该值：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You don't need to `await` `setDefaultTimeout` or `setDefaultNavigationTimeout`
    because they are not `async`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要 `await` `setDefaultTimeout` 或 `setDefaultNavigationTimeout`，因为它们不是 `async`。
- en: The next option is the most interesting option in `goto`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是 `goto` 中最有趣的一个选项。
- en: waitUntil
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: waitUntil
- en: You might be thinking, "Wait until what?". Imagine if, when you do something
    like `await page.goto('https://www.packtpub.com/')`, Puppeteer resolves the `promise`
    as soon as the command is sent to the browser. The next command you run will get
    an empty page because it takes some time to be ready to be used. I bet you experience
    watching a white screen while waiting for a page to load. You have to **wait until**
    the page is ready.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“等待什么？”想象一下，当你执行类似 `await page.goto('https://www.packtpub.com/')` 的操作时，Puppeteer
    会在命令发送到浏览器后立即解析 `promise`。你运行的下一个命令将得到一个空页面，因为它需要一些时间才能准备好使用。我敢打赌你在等待页面加载时看到过白屏。你必须
    **等待** 页面准备好。
- en: '![Empty page'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![空页面'
- en: '](img/Figure_3.07_B16113.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07_B16113.jpg)'
- en: Empty page
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 空页面
- en: 'Waiting for the page to be ready is key in browser automation. Many of the
    questions I see on Stack Overflow are related to this question: How do you know
    the page is ready? I hope when you finish this book, you can master this topic.
    In [*Chapter 5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087), *Waiting for
    elements and network calls*, we will walk through many techniques to answer this
    question, but `page.goto` gives us this first tool: the `waitUntil` option.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 等待页面准备就绪在浏览器自动化中是关键。我看到的大多数Stack Overflow问题都与这个问题相关：你怎么知道页面已经准备好了？我希望当你完成这本书时，你能掌握这个主题。在[*第五章*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087)，“等待元素和网络调用”，我们将探讨许多技术来回答这个问题，但`page.goto`给我们提供了这个第一个工具：`waitUntil`选项。
- en: '`waitUntil` supports four options:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitUntil`支持四个选项：'
- en: The first option, and the default option, is `load`. If you pass `load` (or
    no option), the `promise` will be resolved then the `load` event is fired. According
    to Mozilla, the load event is fired *when the whole page has loaded, including
    all dependent resources such as stylesheets and images*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项，也是默认选项，是`load`。如果你传递`load`（或没有选项），当`load`事件触发时，`promise`将被解析。根据Mozilla的说法，`load`事件在整个页面加载时触发，包括所有依赖资源，如样式表和图像。
- en: The second option is `domcontentloaded`, which relies on the `DOMContentLoaded`
    event. According to Mozilla, the `DOMContentLoaded` is fired *when the initial
    HTML document has been completely loaded and parsed, without waiting for stylesheets,
    images, and subframes to finish loading.*
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是`domcontentloaded`，它依赖于`DOMContentLoaded`事件。根据Mozilla的说法，`DOMContentLoaded`在初始HTML文档已完全加载和解析时触发，无需等待样式表、图像和子框架完成加载。
- en: The last two options are network-related. `networkidle0` will resolve the promise
    *when there are no more network connections for the past 500ms*. On the other
    hand, `networkidle2` will resolve the promise *when there are no more than 2 network
    connections for the past 500ms*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个选项与网络相关。`networkidle0`将在过去500毫秒内没有更多网络连接时解析承诺。另一方面，`networkidle2`将在过去500毫秒内不超过2个网络连接时解析承诺。
- en: Which one is better? Generally speaking, the default is good enough and pretty
    safe. You might need to switch to the network ones if you have many **AJAX** calls
    after the **DOM** is loaded, and you want to wait for the page to stop loading
    data from the server. We will see more about this in [*Chapter 5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087),
    *Waiting for elements and network calls*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个更好？一般来说，默认选项就足够好，而且相当安全。如果你在**DOM**加载后有很多**AJAX**调用，并且你想等待页面停止从服务器加载数据，你可能需要切换到网络选项。我们将在[*第五章*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087)，“等待元素和网络调用”中了解更多关于这一点。
- en: What is an AJAX call?
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是AJAX调用？
- en: AJAX calls became so popular that many developers stopped calling them AJAX
    calls. You might also hear this referred to as "calling an endpoint" or "calling
    a (REST) API."
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX调用变得如此流行，以至于许多开发者停止了将它们称为AJAX调用。你也可能听到这被称为“调用端点”或“调用（REST）API”。
- en: But, basically, it is an asynchronous call made to a server by the page to fetch
    more data or send data to the server. Don't worry, we'll go way deeper in [*Chapter
    5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087), *Waiting for elements and
    network calls*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但基本上，它是对服务器进行的一个异步调用，用于获取更多数据或将数据发送到服务器。别担心，我们将在[*第五章*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087)，“等待元素和网络调用”中深入探讨这一点。
- en: What is the DOM?
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是DOM？
- en: The **Document Object Model** (**DOM**) is the object representation that the
    browser built based on the HTML sent by the server or created in JavaScript.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）是浏览器基于服务器发送的HTML或由JavaScript创建的HTML构建的对象表示。'
- en: Remember that an HTML page is no more than a text file sent through the network.
    The browser loads that text, builds the model (DOM) representation, and then the
    browser engine renders that DOM. At that moment, the browser can say that `load`
    event.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个HTML页面不过是通过网络发送的文本文件。浏览器加载这个文本，构建模型（DOM）表示，然后浏览器引擎渲染这个DOM。在那个时刻，浏览器可以说发生了`load`事件。
- en: 'This takes us to the last option: the referrer.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了最后一个选项：引用者。
- en: Referrer
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用者
- en: The referrer is an HTTP header that the browser sends to the server to inform
    it what page is requesting that resource.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 引用者是一个浏览器发送到服务器的HTTP头，告知服务器请求该资源的页面。
- en: You can see that if you go to [https://www.packtpub.com/](https://www.packtpub.com/),
    open the developer tools, and check any CSS file under the network tab.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看，如果你去[https://www.packtpub.com/](https://www.packtpub.com/)，打开开发者工具，并在网络标签下检查任何CSS文件。
- en: '![Referrer'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![Referrer'
- en: '](img/Figure_3.08_B16113.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.08_B16113](img/Figure_3.08_B16113.jpg)'
- en: Referrer
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 来源网址
- en: Fun fact, the HTTP header is called `referer` due to a typo in the HTTP specification.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实，HTTP头被称为`referer`是因为HTTP规范中的一个错误。
- en: 'When would you use this? Well, this option is not so common, but some pages
    could change the behavior based on the referrer. Some sites might use them as
    a validation: *"This page only can be navigated when coming from this site."*
    You force that scenario using the `referer` option.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你什么时候会用到这个选项呢？嗯，这个选项并不常见，但有些页面可能会根据来源网址改变行为。一些网站可能会将其用作验证：“只有从该网站进入时，此页面才能进行导航。”你可以通过使用`referer`选项强制这种情况。
- en: 'Early in this section, we mentioned that other types of navigation were the
    browser functions to go back, forward, and reload. Puppeteer provides an API for
    all those actions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开头，我们提到其他类型的导航是浏览器返回、前进和重新加载的功能。Puppeteer为所有这些动作提供了一个API：
- en: '`page.goBack(options)`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page.goBack(options)`'
- en: '`page.goForward(options)`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page.goForward(options)`'
- en: '`page.reload(options)`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page.reload(options)`'
- en: These functions have the same behavior as `page.goto`. You don't need to pass
    a URL because it can be inferred from the action itself. `goBack` and `goForward`
    are based on the browsing history, and `reload` will use the same URL.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的行为与`page.goto`相同。你不需要传递一个网址，因为它可以从动作本身推断出来。`goBack`和`goForward`基于浏览历史，而`reload`将使用相同的网址。
- en: Another difference is that they don't support the `referer` option because it
    will use the same referrer used in the first navigation because these actions
    are repeating navigation performed in the past.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，它们不支持`referer`选项，因为它将使用第一次导航中使用的相同的来源网址，因为这些操作是过去重复执行的导航。
- en: But that's not all; `goto` hides a nice surprise. Well, it's not hidden; it
    is documented. The next thing we need to know about `goto` is that it has a return
    value. It returns a `response` object.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部；`goto`隐藏了一个惊喜。好吧，它并不是隐藏的；它是文档化的。接下来我们需要了解的是，`goto`有一个返回值。它返回一个`response`对象。
- en: Using the response object
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应对象
- en: The response is an important concept on the web. There is a corresponding **response**
    for every **request** the browser sends to the server.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是网络中的一个重要概念。对于浏览器发送到服务器的每个请求都有一个相应的**响应**。
- en: It makes sense that the `goto` returns a `response`. It makes a `request`, and
    the result is the corresponding `response`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`返回一个`response`是有意义的。它发起了一个请求，结果是相应的响应。'
- en: There are many things we can do with the response. We won't cover all the functionality
    in this chapter. But these are the most relevant functions we can use as a response
    to a `goto` action.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用响应做很多事情。我们不会在本章中涵盖所有功能。但这些都是我们可以用作`goto`动作响应的最相关函数。
- en: Getting the response URL
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取响应网址
- en: Why would I want to know the URL if I know the URL I want to go to?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我知道我想要去的网址，为什么还要知道网址呢？
- en: The server could redirect you to another page. For instance, if you open the
    browser in incognito/private mode and navigate to [https://mail.google.com/](https://mail.google.com/),
    you will see that the server redirects you to [https://accounts.google.com/signin](https://accounts.google.com/signin).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能会将你重定向到另一个页面。例如，如果你在隐身/私密模式下打开浏览器并导航到[https://mail.google.com/](https://mail.google.com/)，你会看到服务器将你重定向到[https://accounts.google.com/signin](https://accounts.google.com/signin)。
- en: I'm not saying that you should always check the response URL just in case, but
    you have to know that the site you are testing might behave like that. One common
    scenario is the login check. You navigate to a page, and if the response URL is
    the login page, you perform the login action, and then you can go back to the
    previous page and resume your test.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是说你应该总是检查响应网址以防万一，但你必须知道你正在测试的网站可能会那样表现。一个常见的场景是登录检查。你导航到一个页面，如果响应网址是登录页面，你执行登录操作，然后你可以返回到上一个页面并继续测试。
- en: Getting the response status code
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取响应状态码
- en: 'Every response has an HTTP status code. It tells you how the server reacted
    to your request. Status codes are grouped into five categories. These are the
    definitions according to Wikipedia ([https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个响应都有一个HTTP状态码。它告诉你服务器如何响应你的请求。状态码被分为五个类别。这些是根据维基百科的定义（[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)）：
- en: '**1xx informational response**: *the request was received, continuing process*.
    You won''t need to deal with these.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**1xx信息响应**：*请求已接收，正在继续处理*。你不需要处理这些。'
- en: '**2xx successful**: *the request was successfully received, understood, and
    accepted.* There are some differences between all the 2xx codes, but what you
    have to know is that a 2xx code means that everything went well. The status code
    **200** is the most common.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**2xx 成功**：*请求已成功接收、理解并被接受。* 所有 2xx 代码之间有一些差异，但您必须知道的是，2xx 代码意味着一切顺利。状态码 **200**
    是最常见的。'
- en: '**3xx redirection**: *further action needs to be taken in order to complete
    the request.*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**3xx 重定向**：*为了完成请求，需要采取进一步的操作。*'
- en: 'When the server wants to redirect the user, that''s not a server action but
    something that the browser needs to do. The server tells the browser: "You asked
    for [https://mail.google.com/](https://mail.google.com/), but you have to go to
    https://accounts.google.com/signin." The browser needs to take the new URL and
    perform another request.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器想要重定向用户时，这不是服务器操作，而是浏览器需要执行的操作。服务器告诉浏览器：“你请求了 [https://mail.google.com/](https://mail.google.com/)，但你必须转到
    https://accounts.google.com/signin。” 浏览器需要获取新的 URL 并执行另一个请求。
- en: The most common status codes are **301 – Permanent Redirect** and **302 –Temporary
    Redirect**. **301** tells the browser that the old URL shouldn't be used anymore,
    and the browser should always use the new URL. **302** is the most commonly used.
    It tells the browser that it should temporarily go to the new URL. That's the
    case of the login scenario.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的状态码是 **301 – 永久重定向** 和 **302 – 临时重定向**。**301** 告诉浏览器旧的 URL 不再使用，浏览器应始终使用新的
    URL。**302** 是最常用的。它告诉浏览器应暂时跳转到新的 URL。这就是登录场景的情况。
- en: '**4xx client error**: *the request contains bad syntax or cannot be fulfilled.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**4xx 客户端错误**：*请求包含语法错误或无法满足。*'
- en: 4xx codes are known as *"it was your fault"* errors. There was something wrong
    with the request. The list of 4xx codes is huge. For these scenarios, the most
    common code that I think everybody knows is the world-famous **404**, which tells
    you that the resource was **not found**. The other errors you might face are **401
    – Unauthorized** and **403 – Forbidden**, which are related to security issues.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 4xx 代码被称为 *"是你的错"* 错误。请求中存在某些问题。4xx 代码列表非常庞大。对于这些场景，我认为大家最熟悉的代码是闻名世界的 **404**，它告诉您资源
    **未找到**。您可能遇到的其它错误是 **401 – 未授权** 和 **403 – 禁止访问**，它们与安全问题相关。
- en: '**5xx server error**: *the server failed to fulfill an apparently valid request.*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**5xx 服务器错误**：*服务器未能满足显然有效的请求。*'
- en: 5xx codes are known as *"it was the server's fault"* errors. The most common
    is the **500**, which means that the server has failed. I hope you never see this,
    but if you try to scrape a site and you get a **503**, that means that the **server
    is unavailable**, which means that the server started to reject your requests
    or that you took the server down.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 5xx 代码被称为 *"是服务器的错"* 错误。最常见的是 **500**，这意味着服务器已失败。我希望您永远看不到这个，但如果您尝试抓取一个网站并得到
    **503**，这意味着 **服务器不可用**，这意味着服务器开始拒绝您的请求或您使服务器关闭。
- en: The function `response.status()` will return the status code associated with
    the response.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `response.status()` 将返回与响应关联的状态码。
- en: 'If you just want to know whether the response was successful, there is a shortcut
    for that: `response.ok()`. This function will return true if the status code is
    between 200 and 299.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想知道响应是否成功，有一个快捷方式：`response.ok()`。此函数将在状态码在 200 到 299 之间时返回 true。
- en: 'Let''s test some of these features by implementing the following test: *"The
    admin page should redirect you to the login page"*. In the `test` directory you
    will find that we have an `admin.tests.js` file, where we can put our admin page
    tests. To test the redirection, we can do something like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现以下测试来测试这些功能：“管理员页面应将您重定向到登录页面”。在 `test` 目录中，您会发现我们有一个 `admin.tests.js`
    文件，我们可以在这里放置我们的管理员页面测试。为了测试重定向，我们可以这样做：
- en: '[PRE14]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The final status could be `response.url()` to get the URL of that response.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最终状态可以是 `response.url()` 来获取该响应的 URL。
- en: What if I wanted to check that I was effectively redirected from the admin page?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想检查我是否有效地从管理员页面重定向了？
- en: Well, that's trickier. We mentioned that every response is tied to a request.
    Puppeteer exposes that using the `response.request()` function. We won't get into
    the `request` object yet, but one thing you need to know now is that the request
    contains the list of all the redirections a request went through. Puppeteer represents
    them with the `redirectChain()` function. With this, we have the entire redirect
    map.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这有点棘手。我们提到每个响应都与一个请求相关联。Puppeteer使用`response.request()`函数公开这一点。我们不会立即深入研究`request`对象，但你现在需要知道的是，请求包含了一个请求经过的所有重定向的列表。Puppeteer使用`redirectChain()`函数来表示它们。有了这个，我们就有了整个重定向映射。
- en: '![Redirect chain'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![重定向链'
- en: '](img/Figure_3.09_B16113.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.09_B16113.jpg](img/Figure_3.09_B16113.jpg)'
- en: Redirect chain
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向链
- en: 'It might sound complex, but you will get the idea once you start playing with
    it. The final code will look like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但一旦你开始尝试，你就能理解这个概念。最终的代码将看起来像这样：
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We learned a lot about the `launch` function and navigation with Puppeteer.
    As I mentioned at the beginning of this chapter, I also want to share some tools
    to add to your toolbox. Let's talk about continuous integration.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Puppeteer的`launch`函数和导航中学到了很多。正如我在本章开头提到的，我还想分享一些可以添加到你的工具箱中的工具。让我们谈谈持续集成。
- en: Introduction to continuous integration
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连续集成简介
- en: Wouldn't it be great if a tool would guarantee that not a single line of code
    would break the functionality you are testing?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个工具可以保证不会有一行代码破坏你正在测试的功能，那岂不是很好？
- en: 'That''s what **continuous integration** (**CI**) is about. CI is the practice
    of running test code before introducing a change into the code base. Atlassian
    wrote a great definition of CI ([https://www.atlassian.com/continuous-delivery/continuous-integration](https://www.atlassian.com/continuous-delivery/continuous-integration)):
    **Continuous integration** (**CI**) *is the practice of automating the integration
    of code changes from multiple contributors into a single software project. It''s
    a primary DevOps best practice, allowing developers to frequently merge code changes
    into a central repository where builds and tests then run. Automated tools are
    used to assert the new code''s correctness before integration.*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**持续集成**（**CI**）的含义。持续集成是在将更改引入代码库之前运行测试代码的实践。Atlassian给出了一个很好的定义（[https://www.atlassian.com/continuous-delivery/continuous-integration](https://www.atlassian.com/continuous-delivery/continuous-integration)）：**持续集成**（**CI**）*是自动化将多个贡献者的代码更改集成到单个软件项目的实践。它是DevOps的最佳实践之一，允许开发者频繁地将代码更改合并到中央仓库中，然后运行构建和测试。在集成之前，使用自动化工具来断言新代码的正确性。*
- en: 'Let''s review an ideal workflow:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个理想的流程：
- en: We have our code base in a source control repository. It could be GitHub, Gitlab,
    Bitbucket, or a local server hosting a Git server.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码库存储在源代码控制仓库中。它可能是GitHub、Gitlab、Bitbucket，或者是一个本地服务器，该服务器托管一个Git服务器。
- en: A developer creates a new branch from that main code base.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者从主代码库中创建一个新的分支。
- en: We make some changes in that branch.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在那个分支上做了一些更改。
- en: And then, it creates a Pull Request or Merge Request. The developer requests
    that their changes are reviewed and incorporated into the main code base.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它创建一个拉取请求或合并请求。开发者请求他们的更改被审查并合并到主代码库中。
- en: Other developers will review the change, but the CI process will also run the
    tests on that branch.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他开发者将审查更改，但持续集成过程也将在该分支上运行。
- en: If the developers approve the change and the CI runs successfully, the code
    will be ready to be merged into the main code base.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果开发者批准更改并且持续集成运行成功，代码将准备好合并到主代码库中。
- en: It sounds like an ideal world, right? Although life won't be that perfect all
    the time, we can achieve that. If you can implement this workflow when you start
    a new project, it will be easy to follow. Implementing all this in an ongoing
    project will be more challenging. My advice would be to make these changes little
    by little, not to affect productivity too much.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一个理想的世界，对吧？尽管生活不会总是那么完美，我们可以实现这一点。如果你在开始新项目时实施这个工作流程，那么遵循它将会很容易。在一个持续的项目中实施所有这些将会更具挑战性。我的建议是逐步进行这些更改，不要过多地影响生产力。
- en: 'There are many CIs available on the market. Most of them have an entry-level
    free tier and then some paid tiers. The main differences you will see between
    them are the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有很多持续集成工具。大多数都有入门级的免费层和一些付费层。你将在它们之间看到的以下主要区别：
- en: 'Support for private repositories: Some CIs offer free tiers only for public
    repositories.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对私有仓库的支持：一些持续集成工具只提供免费层用于公共仓库。
- en: 'The number of parallel runs: This will be quite important if you have quite
    a big team with many Pull Requests opened simultaneously.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行的数量：如果你有一个相当大的团队，同时打开了多个Pull Requests，这将非常重要。
- en: 'Compute power: They could give you better virtual machines on higher tiers.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算能力：他们可能会在更高等级上提供更好的虚拟机。
- en: 'Reporting: You will find different types of reports.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告：你将找到不同类型的报告。
- en: 'These are the most popular CIs in 2021; there are many others, but these are
    the ones you will see around:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是2021年最受欢迎的持续集成工具；还有很多其他的，但这些都是你会在周围看到的：
- en: Travis CI
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis CI
- en: Circle CI
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Circle CI
- en: AppVeyor
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppVeyor
- en: Jenkins
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: GitHub Actions
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: We will test our code using GitHub Actions, just because we would only need
    a GitHub account, and we can do everything from our repository.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GitHub Actions测试我们的代码，仅仅因为我们只需要一个GitHub账户，我们就可以从我们的仓库做所有事情。
- en: First, let's create a new repository on GitHub. If you don't have a GitHub account,
    you can create one at [https://github.com/join](https://github.com/join). Once
    you have an account, you can create a repository at https://github.com/new.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在GitHub上创建一个新的仓库。如果你没有GitHub账户，你可以在[https://github.com/join](https://github.com/join)创建一个。一旦你有了账户，你可以在https://github.com/new创建一个仓库。
- en: '![Creating a new repository'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![创建新的仓库'
- en: '](img/Figure_3.10_B16113.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.10_B16113.jpg]'
- en: Creating a new repository
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的仓库
- en: One important thing here is to pick `.gitignore` template, so we don't commit
    the `node_modules` folder.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个重要的事情是要选择`.gitignore`模板，这样我们就不提交`node_modules`文件夹。
- en: 'Once you create the repository, you can get the Git URL using the **Code**
    button:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了仓库，你就可以使用**代码**按钮获取Git URL。
- en: '![Git remote URL'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![Git远程URL'
- en: '](img/Figure_3.11_B16113.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.11_B16113.jpg]'
- en: Git remote URL
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Git远程URL
- en: 'We will now clone this Git repository into a new folder, copy our working code
    there, and **push** it to GitHub:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将把这个Git仓库克隆到一个新的文件夹中，把我们的工作代码复制到那里，并将其**推送到**GitHub：
- en: '[PRE16]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that you need to use **your** Git URL, not mine.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要使用**你的**Git URL，而不是我的。
- en: 'Next, we need to copy our current code to that folder. Make sure you delete
    any extra `git` folders when you copy these projects. After that, we need to run
    these three commands to commit our code and push it to GitHub:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要把我们的当前代码复制到那个文件夹中。确保你在复制这些项目时删除任何额外的`git`文件夹。之后，我们需要运行这三个命令来提交我们的代码并将其推送到GitHub：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now it''s time to set up the CI. CI tasks in GitHub actions are YAML files
    inside the `. github/workflows` directory. This is what we need to do:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是设置CI的时候了。GitHub actions中的CI任务位于`.github/workflows`目录内的YAML文件。这是我们需要的步骤：
- en: Checkout the branch.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检出分支。
- en: Build the site.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建网站。
- en: Build the tests package.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建测试包。
- en: Launch the site.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动网站。
- en: Run tests.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: 'The following example doesn''t pretend to be the canonical way to run Puppeteer
    tests in GitHub actions. There many different ways to implement this. Let''s create
    a YAML file inside the `.github/workflows` directory called `test.yml` (you can
    pick any name). The file will look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例并不假装是GitHub Actions中运行Puppeteer测试的规范方式。有许多不同的实现方式。让我们在`.github/workflows`目录内创建一个名为`test.yml`的YAML文件（你可以选择任何名称）。文件看起来像这样：
- en: '[PRE18]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we are saying when we want to run this action. Then, we are setting up
    this action to run on every `master` branch. But also, it will run on every `master`
    branch. This means that it will also run after the Pull Request is merged.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们说的是我们想要何时运行这个操作。然后，我们设置这个操作在每次`master`分支上运行。但也会在每次`master`分支上运行。这意味着在Pull
    Request合并后也会运行。
- en: '`- uses: actions/checkout@master` will check out our code.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- uses: actions/checkout@master`将检出我们的代码。'
- en: 'Under `- name: Install Web Dependencies`, we build the site.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在`- name: 安装Web依赖`下，我们构建网站。'
- en: 'Under `- name: Install Test Dependencies`, we build the test project.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在`- name: 安装测试依赖`下，我们构建测试项目。'
- en: 'Under `- name: Run Site Test Code`, we run the site and the tests using the
    shell file `test.sh`, which is as simple as this:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在`- name: 运行网站测试代码`下，我们使用shell文件`test.sh`运行网站和测试，这个文件很简单，如下所示：'
- en: '[PRE19]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, I'm waiting for `npm run serve` to print an http://localhost:8080
    before running the tests.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我在运行测试之前正在等待`npm run serve`打印出http://localhost:8080。
- en: 'You will find that we are using `uses: mujo-code/puppeteer-headful@master`.
    Running a browser in a VM can be challenging. These VMs have many restrictions.
    You will need to find recipes that can help you launch a browser in a VM.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '你会发现我们正在使用`uses: mujo-code/puppeteer-headful@master`。在虚拟机中运行浏览器可能具有挑战性。这些虚拟机有许多限制。你需要找到可以帮助你在虚拟机中启动浏览器的食谱。'
- en: 'In this case, `mujo-code/puppeteer-headful` leaves us a browser ready to be
    used. That''s why we use the environment variable `PUPPETEER_SKIP_CHROMIUM_DOWNLOAD:
    ''true''`, so when we run `npm install`, Puppeteer won''t download a browser because
    we are going to use an existing one.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，`mujo-code/puppeteer-headful`为我们留下了一个可以使用的浏览器。这就是为什么我们设置环境变量`PUPPETEER_SKIP_CHROMIUM_DOWNLOAD:
    ''true''`，这样当我们运行`npm install`时，Puppeteer不会下载浏览器，因为我们将使用现有的一个。'
- en: 'As we''re going to use an existing browser, and we are going to run this in
    a restricted environment, we will need a new set of launch options. That''s why
    a set the environment variable `TESTENV: ''CI''`, and I added a new setting in
    the config file:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们将使用现有的浏览器，并且我们将在受限环境中运行它，我们需要一组新的启动选项。这就是为什么我设置了环境变量`TESTENV: ''CI''`，并在配置文件中添加了一个新的设置：'
- en: '[PRE20]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I'm setting as the executable path the environment variable `PUPPETEER_EXEC_PATH`,
    which is set by `mujo-code/puppeteer-headful`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我将可执行文件路径设置为环境变量`PUPPETEER_EXEC_PATH`，这是由`mujo-code/puppeteer-headful`设置的。
- en: After setting up all this, you will start getting builds in your pull requests.
    Let's say that a developer comes and creates a Pull Request changing a color.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好所有这些之后，您将开始在您的拉取请求中看到构建。假设一个开发者来创建一个更改颜色的拉取请求。
- en: '![A Pull request changing a piece of code'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个更改代码片段的拉取请求'
- en: '](img/Figure_3.12_B16113.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B16113.jpg)'
- en: A Pull request changing a piece of code
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更改代码片段的拉取请求
- en: 'If you go to the **Checks** tab, you will see all the actions and their status.
    In this case, we can see that our test runs correctly:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您转到**检查**选项卡，您将看到所有操作及其状态。在这种情况下，我们可以看到我们的测试运行正确：
- en: '![Build result in Pull Requests'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![拉取请求中的构建结果'
- en: '](img/Figure_3.13_B16113.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B16113.jpg)'
- en: Build result in Pull Requests
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求中的构建结果
- en: There, you will find all the build details, with all the test results. But these
    results also propagate to other pages on GitHub. You will be able to see the build
    results on the main page of the Pull Request and even in the Pull Requests list.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您将找到所有构建细节，包括所有测试结果。但这些结果也会传播到GitHub上的其他页面。您将能够在拉取请求的主页上看到构建结果，甚至在拉取请求列表中。
- en: '![Build result on the Pull Request main page'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![拉取请求主页面上的构建结果'
- en: '](img/Figure_3.14_B16113.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B16113.jpg)'
- en: Build result on the Pull Request main page
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求主页面上的构建结果
- en: There, you are not going to see the full details, but it will give you a quick
    view so you can know whether the Pull Request is ready to be merged or not.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您将看不到全部细节，但它会为您提供快速查看，以便您知道拉取请求是否准备好合并。
- en: I know that this might feel overwhelming. Take this as an idea about how that
    looks, what is possible, and the challenges you might find while setting up all
    this. It's not easy, but it is worth the effort.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这可能会让人感到不知所措。把这当作一个想法，看看它看起来是什么样子，可能有哪些可能性，以及您在设置所有这些时可能会遇到的挑战。这并不容易，但值得付出努力。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see, we started to go deeper into the Puppeteer API. We learned about
    all the different options we can use when launching a browser. We also learned
    how to navigate through a site and the different options we have to go from one
    page to another. We also saw new objects that weren't mentioned before, such as
    the `Response` and the `Request` class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们开始深入探索Puppeteer API。我们了解了在启动浏览器时我们可以使用的所有不同选项。我们还学习了如何导航网站，以及我们从一个页面跳转到另一个页面时拥有的不同选项。我们还看到了之前未提及的新对象，例如`Response`和`Request`类。
- en: I hope you found the continuous integration section valuable. There are many
    tools and many different ways to run tests automatically in the cloud. This is
    an essential tool to add to your toolbox.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您觉得持续集成部分很有价值。在云中运行测试有很多工具和不同的方法。这是您工具箱中必须添加的一个基本工具。
- en: In the next chapter, we will get even more practical. We will see how to interact
    with the page, from CSS selectors to mouse and keyboard emulation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更加实用。我们将看到如何与页面交互，从CSS选择器到鼠标和键盘模拟。
