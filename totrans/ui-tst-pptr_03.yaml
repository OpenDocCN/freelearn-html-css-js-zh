- en: '*Chapter 3*: Navigating through a website'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already laid the foundations for the rest of the book. In [*Chapter
    1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Getting started with Puppeteer*,
    we learned about browser automation and headless browsers. [*Chapter 2*](B16113_02_Final_SK_ePub.xhtml#_idTextAnchor038),
    *Automated Testing and Test runners*, was about automated testing and test runners.
    Now it's time to get more practical. In this chapter, we will learn about UI testing,
    but in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we will pick an open-source website made with Vue.js
    to test, but we are also going to navigate through many other public websites.
    I want you to learn techniques that help you test websites no matter the framework
    they use.
  prefs: []
  type: TYPE_NORMAL
- en: I also want to share some tools with you, so you can finish this book with a
    complete toolbox. In this chapter, we will learn how to ship our code to GitHub
    and run our tests using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we created a test project, and we ran a few tests without
    paying too much attention to the Puppeteer APIs we were using. In this chapter,
    we will create a test project again, but this time we will go deeper and see what
    Puppeteer has to offer on each API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the test site for this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Puppeteer browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through a site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Response object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Continuous Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have tested a real website, pushed it to
    GitHub, and run our tests automatically, learning many new APIs. Let's see what
    test sites we can use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will find all the code of this chapter in the GitHub repository ([https://github.com/PacktPublishing/ui-testing-with-puppeteer](https://github.com/PacktPublishing/ui-testing-with-puppeteer))
    under the `Chapter3` directory. We will consider `Chapter3` as the base path for
    all the demos. Inside the `Chapter3` directory, you will find three directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vuejs-firebase-shopping-cart` contains the test site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init` is the directory you can use to follow this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`demo` contains the final code from this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the tests sites for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will test a site made with Vue.js. Thang Minh Vu ([https://me.coddeine.com/](https://me.coddeine.com/))
    wrote a great Vue.js example: **vuejs-firebase-shopping-cart** ([https://github.com/ittus/vuejs-firebase-shopping-cart](https://github.com/ittus/vuejs-firebase-shopping-cart)).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When you look for projects on GitHub or any other site like GitHub, you need
    to pay attention to the license the project uses. The fact that the code is open
    source doesn't mean that you can use it as you wish. This project uses the **MIT
    License**, which is one of the most permissive licenses. This license basically
    states that you can use the code *without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is furnished
    to do so.*
  prefs: []
  type: TYPE_NORMAL
- en: As we don't want you to deal with firebase setup, I forked this project (made
    a copy on GitHub), removing all the firebase code. You can find the base structure
    of the code used in this chapter inside the `init` directory. You just need to
    run `npm install` in the base folder and then run the following commands on the
    `vuejs-firebase-shopping-cart` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the terminal, you should have got a success message and the URL the site
    is now running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Site running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Site running
  prefs: []
  type: TYPE_NORMAL
- en: Now we should have a nice site running on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Demo site running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Demo site running
  prefs: []
  type: TYPE_NORMAL
- en: We'll need two terminals to work on this project. In one terminal, we are going
    to run the website. In the second, we are going to launch our tests.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using VS Code, notice that the **TERMINAL** tab has a plus button.
    If you click on that button, a new terminal will be created. You can switch between
    terminals using the selection list to the left of that button.
  prefs: []
  type: TYPE_NORMAL
- en: '![New terminal option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: New terminal option
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the site in one terminal using the same commands we used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the tests in another terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, you should be getting something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter, we didn't pay much attention to how we were using Puppeteer.
    We just knew that if we did `browser = await puppeteer.launch();` we would get
    a new browser. How? No idea. Well, it's time to understand a little bit more about
    how Puppeteer works.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Puppeteer browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The signature of the `launch` function is not `launch()`, but `launch(options)`.
    Thanks to the freedom we have in JavaScript, we can just avoid passing that argument,
    and the `launch` function will get `options` as `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Puppeteer.launch function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are all the options `Puppeteer.launch` supports in Puppeteer 7 according
    to the official docs ([https://github.com/puppeteer/puppeteer/blob/v7.0.0/docs/api.md#puppeteerlaunchoptions](https://github.com/puppeteer/puppeteer/blob/v7.0.0/docs/api.md#puppeteerlaunchoptions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`product`: Which browser to launch. At this time, this is either `chrome` or `firefox`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreHTTPSErrors`: Whether to ignore HTTPS errors during navigation. This
    option will become handy when you want to automate websites with invalid or missing
    SSL certificates. This will prevent Chromium from returning an invalid certificate
    page in those cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headless`: Whether to run the browser in headless mode. Defaults to `true` unless
    the `devtools` option is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executablePath`: Path to a browser executable to run instead of the bundled
    Chromium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slowMo`: Slows down Puppeteer operations by the specified number of milliseconds.
    Useful so that you can see what is going on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultViewport`: Sets a consistent viewport for each page. Defaults to an
    800x600 viewport. `null` disables the default viewport. A viewport is an object
    with the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a) `width`: page width in pixels.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b) `height`: page height in pixels.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c) `deviceScaleFactor`: Specify device scale factor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd) `isMobile`: Whether the `meta viewport` tag is taken into account.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'e) `hasTouch`: Specifies whether the viewport supports touch events.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'f) `isLandscape`: Specifies whether the viewport is in landscape mode.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`args`: Additional arguments to pass to the browser instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreDefaultArgs`: If `true`, then do not use `puppeteer.defaultArgs()`.
    If an array is given, then filter out the given default arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleSIGINT`: Close the browser process on *Ctrl +C*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleSIGTERM`: Close the browser process on `SIGTERM`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleSIGHUP`: Close the browser process on `SIGHUP`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`: Maximum time in milliseconds to wait for the browser instance to
    `start`. Defaults to `30000` (30 seconds). Passing `0` disables the timeout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dumpio`: Whether to pipe the browser process `stdout` and `stderr` into `process.stdout` and `process.stderr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userDataDir`: Path to a user data directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`env`: Specify environment variables that will be visible to the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devtools`: Whether to auto-open a DevTools panel for each tab. If this option
    is `true`, the `headless` option will be set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipe`: Connects to the browser over a pipe instead of a WebSocket. Defaults
    to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extraPrefsFirefox`: Additional preferences that can be passed to Firefox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a long list, I know. But I didn't want to just write about the features
    I think are interesting. I want you to have the full picture of the `launch` option.
    Now, let's talk about about the options you do need to know.
  prefs: []
  type: TYPE_NORMAL
- en: Headless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I think the `headless` option is the most used. Remember I told you we were
    going to use headless browsers? I won''t say that I lied, but I lied. Headless
    mode is the default mode, but in fact, you could launch a browser with `headless`
    in `false`, also known as *"headful mode."* Headful mode is useful while debugging
    automation code because you will see what is going on in the browser. I bet that
    will be the default local setting. This is how you can launch the browser in headful
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This line of code will launch a browser that will almost look like a normal
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![A browser in headful mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: A browser in headful mode
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, that's a full working browser. The only difference is that you
    will get that banner saying that *"Chrome is being controlled by automated test
    software."* If someone asks you, no, you can't remove that banner. I believe that
    with so much phishing and hacking around the internet, it's important to tell
    a potential user of the browser that there is an app behind it controlling and
    monitoring the browser activity.
  prefs: []
  type: TYPE_NORMAL
- en: The user data directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `userDataDir`, Puppeteer will create a new directory before launching the
    browser. Then it will delete it when the browser is closed. That would mean that
    sessions or anything we store in cookies won't be preserved across test runs.
  prefs: []
  type: TYPE_NORMAL
- en: In UI testing, we might want to use this option to check whether the site uses
    the local storage (for example, cookies) as expected. Does the site remember the
    logged-in user? Is the cart being preserved?
  prefs: []
  type: TYPE_NORMAL
- en: Executable Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `executablePath` option is not common on UI testing. Most tests will run
    using the browser downloaded by Puppeteer. Still, this option is used a lot in
    task automation or scraping, when you want to use the browser you would normally
    use, or in some continuous integration environments, where you want to run an
    already downloaded browser.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Getting started with Puppeteer*, Puppeteer is guaranteed to work with a specific
    version of Chromium. In the case of Puppeteer 7.0.0, the Chromium version is 90.0.4403.0\.
    That doesn't mean that it will not work with any other version, but it's not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you are a macOS user, the Chrome executable will be inside the application
    bundle `Google Chrome.app`. For example, `/Applications/Google Chrome.app/Contents/MacOS/Google
    Chrome`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `executablePath` option won't be enough if we want to use the exact
    same browser we would normally use. Remember that Puppeteer will create a new
    user data directory if we don't pass one. We need to pass the user data directory
    our browser uses. It should be `%LOCALAPPDATA%\Google\Chrome\User Data` in Windows,
    `~/Library/Application Support/Google/Chrome` in Mac, or `~/.config/google-chrome`
    in Linux. If you want to double-check that value, you can navigate to `chrome://version/`
    using your browser. There you will see the current **Profile Path**. You need
    to remove the Default directory in macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to use your own browser, you can install puppeteer-core instead
    of Puppeteer. puppeteer-core won't download a browser, speeding up your install
    time and saving disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Default Viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you tried the headful mode, you might have seen something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Headful mode with no default viewport'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Headful mode with no default viewport
  prefs: []
  type: TYPE_NORMAL
- en: No, the site is not broken. If we don't pass a `defaultViewport`, Puppeteer
    will default to a viewport of 800x600\. If you were wondering what a viewport
    is, according to Wikipedia, *a viewport is the visible portion of the entire document*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The viewport is an important piece of UI testing. UX experts and designers
    make a significant effort trying to give the user the best experience for the
    device they are using. Frontend developers use CSS breakpoints to determine which
    layout to show based on the viewport size. Rico Sta. Cruz, on his blog post *What
    media query breakpoints should I use?* ([https://ricostacruz.com/til/css-media-query-breakpoints](https://ricostacruz.com/til/css-media-query-breakpoints)),
    posted this excellent list of breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mobile devices in portrait: From 320px to 414px.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mobile devices in landscape: From 568px to 812px.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table in portrait: From 768px to 834px.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table in landscape: From 1024px to 1112px.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Laptops: From 1366px to 1440px.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Desktop displays: 1680px to 1920px.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't need to have many devices to test this. Just open a browser and change
    the size of the window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Different breakpoints Packtpub.com uses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Different breakpoints Packtpub.com uses
  prefs: []
  type: TYPE_NORMAL
- en: If you look at that screenshot, you will see that the site shows or hides different
    elements based on the viewport. It would show a big search bar in a big viewport,
    assuming a desktop experience. When it detects a small viewport, assuming a mobile
    device, it will hide the search bar and show a hamburger button.
  prefs: []
  type: TYPE_NORMAL
- en: We need to consider all these changes when writing our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Instead of trying to guess viewports, ask your frontend team what breakpoints
    they are using. But keep in mind that many bugs emerge on those precise breakpoints,
    test the breakpoints, and check whether they are appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: We will go deeper into this topic in [*Chapter 8*](B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137),
    *Environments emulation*, when we talk about mobile emulation. One last trick
    here. If we pass `null`, the viewport will adapt to the window size, as you would
    expect in a normal browser.
  prefs: []
  type: TYPE_NORMAL
- en: Product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Are you saying that we can automate Firefox with Puppeteer? Yes, we can. Although
    it is still experimental. This is the official definition of "experimental": *Official
    Firefox support is currently experimental. The ongoing collaboration with Mozilla
    aims to support common end-to-end testing use cases, for which developers expect
    cross-browser coverage. The Puppeteer team needs input from users to stabilize
    Firefox support and to bring missing APIs to our attention.* My unofficial definition
    would be: *It uses a nightly build of Firefox, and the long-term support doesn''t
    seem guaranteed.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disclaimers aside, if you want to launch a Firefox browser, you need first
    to install Puppeteer setting the `PUPPETEER_PRODUCT` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you can set Firefox as a product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Browser Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `args` option is an array of arguments or **flags** you can pass to the
    browser. There are over 1,400 flags ([https://www.hardkoded.com/ui-testing-with-puppeteer/chrome-flags](https://www.hardkoded.com/ui-testing-with-puppeteer/chrome-flags)).
    It would be impossible to cover all 1,400 flags.
  prefs: []
  type: TYPE_NORMAL
- en: '`--no-sandbox` is the most common flag. From the official documentation: *In
    order to protect the host environment from untrusted web content, Chrome uses
    multiple layers of sandboxing. For this to work properly, the host should be configured
    first.*'
  prefs: []
  type: TYPE_NORMAL
- en: The key phrase here is *"the host should be configured first."* You might need
    to create a user with the right permissions to use Puppeteer in a more restricted
    context, such as `–no-sandbox` flag, which would bypass the sandboxing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other common flags are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--window-size` to set the window size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--proxy-server` and `--proxy-bypass-list` to set up proxy settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another option called `extraPrefsFirefox`. You can use this property
    to set Firefox flags. Hopefully, you won't need to deal with these flags much.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`deviceScaleFactor`, `isMobile`, `hasTouch`, and `isLandscape` will help us
    set up mobile emulation. We will cover these options more deeply in [*Chapter
    8*](B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137), *Environments emulation*.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `puppeteer.launch()` is way more than that, and there are many
    others for you to keep digging.
  prefs: []
  type: TYPE_NORMAL
- en: Options in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's see how we can apply these new features in the real world. The first
    thing we can do now, and you should do from now on, is to load the options object
    from the config file. Remember that the config class we have is JavaScript code.
    We can add a property there called `launchOptions` and pass that to the `launch`
    function. You don't even need to populate it if you don't want to, but it will
    be there, ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your config file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run these tests using the `local` config, it will launch the browser
    in headful mode. The next step is passing this option to the `launch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now let's try to code a real-life test. We want to test that the login action
    is being persisted after closing a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a browser using a user data directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that we are logged out (checking that the login button says **Login**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that we are logged in (checking that the logout button says **Logout**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should be logged in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We won''t be able to reuse the browser we are using in other tests because
    we will need to create our own user data directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This test is longer than the others because we need to create a browser, a page,
    and a model twice. Ignore how the `loginState` and `login` functions work. We
    will cover those functions in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: It's impressive, all the functionality that can be hidden inside a single line.
    Now let's see how we can improve our navigation skills.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through a site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at how you navigate through different pages on a browser, there
    are basically four ways:'
  prefs: []
  type: TYPE_NORMAL
- en: You type a URL in the address bar or using a bookmark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use the browser functions to go back, forward, or reload a page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You click on elements on a page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The site you are browsing redirects to another page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `goto` function emulates the first option, navigating to a site. We use
    that to navigate to the page we want to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, guess what? The `goto` signature isn't `goto(url)` but `goto(url, options)`.
    You will see this pattern being repeated over and over – a function with one or
    more required arguments (or none), and then a set of extra options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, the options `goto` expects is not as big as the one we saw
    in the `launch` options. It only has three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timeout`: Maximum navigation time in milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitUntil`: When to consider navigation succeeded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`referrer`: Referrer header value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's unpack these options.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will see the `timeout` argument in many functions. Puppeteer groups timeouts
    in two groups: **navigation timeouts** and **generic timeouts** (this is not the
    official name; I named them in this way just to make these concepts easier to
    understand).'
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to set a default timeout in all our navigation calls, we could
    create a property in our config file and use it in every place. That sounds like
    a great idea, but there is an even better solution. We can use a property in our
    config file, but instead of passing that to every function we use, we can call
    `page.setDefaultTimeout(timeout)` or `page.setDefaultNavigationTimeout(timeout)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `page` object will store the timeout you pass to these functions and use
    them as a default value.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you don't pass a timeout to a function, nor set a default timeout, Puppeteer
    will set the timeout to 30 seconds (30,000 milliseconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are testing a site locally, waiting 30 seconds for a page to load sounds
    like a lot. Let''s reduce that time to 5 seconds. We can add a new property in
    our config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we can set that value using the default timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to `await` `setDefaultTimeout` or `setDefaultNavigationTimeout`
    because they are not `async`.
  prefs: []
  type: TYPE_NORMAL
- en: The next option is the most interesting option in `goto`.
  prefs: []
  type: TYPE_NORMAL
- en: waitUntil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be thinking, "Wait until what?". Imagine if, when you do something
    like `await page.goto('https://www.packtpub.com/')`, Puppeteer resolves the `promise`
    as soon as the command is sent to the browser. The next command you run will get
    an empty page because it takes some time to be ready to be used. I bet you experience
    watching a white screen while waiting for a page to load. You have to **wait until**
    the page is ready.
  prefs: []
  type: TYPE_NORMAL
- en: '![Empty page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Empty page
  prefs: []
  type: TYPE_NORMAL
- en: 'Waiting for the page to be ready is key in browser automation. Many of the
    questions I see on Stack Overflow are related to this question: How do you know
    the page is ready? I hope when you finish this book, you can master this topic.
    In [*Chapter 5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087), *Waiting for
    elements and network calls*, we will walk through many techniques to answer this
    question, but `page.goto` gives us this first tool: the `waitUntil` option.'
  prefs: []
  type: TYPE_NORMAL
- en: '`waitUntil` supports four options:'
  prefs: []
  type: TYPE_NORMAL
- en: The first option, and the default option, is `load`. If you pass `load` (or
    no option), the `promise` will be resolved then the `load` event is fired. According
    to Mozilla, the load event is fired *when the whole page has loaded, including
    all dependent resources such as stylesheets and images*.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is `domcontentloaded`, which relies on the `DOMContentLoaded`
    event. According to Mozilla, the `DOMContentLoaded` is fired *when the initial
    HTML document has been completely loaded and parsed, without waiting for stylesheets,
    images, and subframes to finish loading.*
  prefs: []
  type: TYPE_NORMAL
- en: The last two options are network-related. `networkidle0` will resolve the promise
    *when there are no more network connections for the past 500ms*. On the other
    hand, `networkidle2` will resolve the promise *when there are no more than 2 network
    connections for the past 500ms*.
  prefs: []
  type: TYPE_NORMAL
- en: Which one is better? Generally speaking, the default is good enough and pretty
    safe. You might need to switch to the network ones if you have many **AJAX** calls
    after the **DOM** is loaded, and you want to wait for the page to stop loading
    data from the server. We will see more about this in [*Chapter 5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087),
    *Waiting for elements and network calls*.
  prefs: []
  type: TYPE_NORMAL
- en: What is an AJAX call?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AJAX calls became so popular that many developers stopped calling them AJAX
    calls. You might also hear this referred to as "calling an endpoint" or "calling
    a (REST) API."
  prefs: []
  type: TYPE_NORMAL
- en: But, basically, it is an asynchronous call made to a server by the page to fetch
    more data or send data to the server. Don't worry, we'll go way deeper in [*Chapter
    5*](B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087), *Waiting for elements and
    network calls*.
  prefs: []
  type: TYPE_NORMAL
- en: What is the DOM?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Document Object Model** (**DOM**) is the object representation that the
    browser built based on the HTML sent by the server or created in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that an HTML page is no more than a text file sent through the network.
    The browser loads that text, builds the model (DOM) representation, and then the
    browser engine renders that DOM. At that moment, the browser can say that `load`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'This takes us to the last option: the referrer.'
  prefs: []
  type: TYPE_NORMAL
- en: Referrer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The referrer is an HTTP header that the browser sends to the server to inform
    it what page is requesting that resource.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that if you go to [https://www.packtpub.com/](https://www.packtpub.com/),
    open the developer tools, and check any CSS file under the network tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Referrer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.08_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Referrer
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact, the HTTP header is called `referer` due to a typo in the HTTP specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'When would you use this? Well, this option is not so common, but some pages
    could change the behavior based on the referrer. Some sites might use them as
    a validation: *"This page only can be navigated when coming from this site."*
    You force that scenario using the `referer` option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Early in this section, we mentioned that other types of navigation were the
    browser functions to go back, forward, and reload. Puppeteer provides an API for
    all those actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`page.goBack(options)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page.goForward(options)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page.reload(options)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions have the same behavior as `page.goto`. You don't need to pass
    a URL because it can be inferred from the action itself. `goBack` and `goForward`
    are based on the browsing history, and `reload` will use the same URL.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that they don't support the `referer` option because it
    will use the same referrer used in the first navigation because these actions
    are repeating navigation performed in the past.
  prefs: []
  type: TYPE_NORMAL
- en: But that's not all; `goto` hides a nice surprise. Well, it's not hidden; it
    is documented. The next thing we need to know about `goto` is that it has a return
    value. It returns a `response` object.
  prefs: []
  type: TYPE_NORMAL
- en: Using the response object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The response is an important concept on the web. There is a corresponding **response**
    for every **request** the browser sends to the server.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense that the `goto` returns a `response`. It makes a `request`, and
    the result is the corresponding `response`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many things we can do with the response. We won't cover all the functionality
    in this chapter. But these are the most relevant functions we can use as a response
    to a `goto` action.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the response URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why would I want to know the URL if I know the URL I want to go to?
  prefs: []
  type: TYPE_NORMAL
- en: The server could redirect you to another page. For instance, if you open the
    browser in incognito/private mode and navigate to [https://mail.google.com/](https://mail.google.com/),
    you will see that the server redirects you to [https://accounts.google.com/signin](https://accounts.google.com/signin).
  prefs: []
  type: TYPE_NORMAL
- en: I'm not saying that you should always check the response URL just in case, but
    you have to know that the site you are testing might behave like that. One common
    scenario is the login check. You navigate to a page, and if the response URL is
    the login page, you perform the login action, and then you can go back to the
    previous page and resume your test.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the response status code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every response has an HTTP status code. It tells you how the server reacted
    to your request. Status codes are grouped into five categories. These are the
    definitions according to Wikipedia ([https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**1xx informational response**: *the request was received, continuing process*.
    You won''t need to deal with these.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2xx successful**: *the request was successfully received, understood, and
    accepted.* There are some differences between all the 2xx codes, but what you
    have to know is that a 2xx code means that everything went well. The status code
    **200** is the most common.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3xx redirection**: *further action needs to be taken in order to complete
    the request.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the server wants to redirect the user, that''s not a server action but
    something that the browser needs to do. The server tells the browser: "You asked
    for [https://mail.google.com/](https://mail.google.com/), but you have to go to
    https://accounts.google.com/signin." The browser needs to take the new URL and
    perform another request.'
  prefs: []
  type: TYPE_NORMAL
- en: The most common status codes are **301 – Permanent Redirect** and **302 –Temporary
    Redirect**. **301** tells the browser that the old URL shouldn't be used anymore,
    and the browser should always use the new URL. **302** is the most commonly used.
    It tells the browser that it should temporarily go to the new URL. That's the
    case of the login scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '**4xx client error**: *the request contains bad syntax or cannot be fulfilled.*'
  prefs: []
  type: TYPE_NORMAL
- en: 4xx codes are known as *"it was your fault"* errors. There was something wrong
    with the request. The list of 4xx codes is huge. For these scenarios, the most
    common code that I think everybody knows is the world-famous **404**, which tells
    you that the resource was **not found**. The other errors you might face are **401
    – Unauthorized** and **403 – Forbidden**, which are related to security issues.
  prefs: []
  type: TYPE_NORMAL
- en: '**5xx server error**: *the server failed to fulfill an apparently valid request.*'
  prefs: []
  type: TYPE_NORMAL
- en: 5xx codes are known as *"it was the server's fault"* errors. The most common
    is the **500**, which means that the server has failed. I hope you never see this,
    but if you try to scrape a site and you get a **503**, that means that the **server
    is unavailable**, which means that the server started to reject your requests
    or that you took the server down.
  prefs: []
  type: TYPE_NORMAL
- en: The function `response.status()` will return the status code associated with
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to know whether the response was successful, there is a shortcut
    for that: `response.ok()`. This function will return true if the status code is
    between 200 and 299.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test some of these features by implementing the following test: *"The
    admin page should redirect you to the login page"*. In the `test` directory you
    will find that we have an `admin.tests.js` file, where we can put our admin page
    tests. To test the redirection, we can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The final status could be `response.url()` to get the URL of that response.
  prefs: []
  type: TYPE_NORMAL
- en: What if I wanted to check that I was effectively redirected from the admin page?
  prefs: []
  type: TYPE_NORMAL
- en: Well, that's trickier. We mentioned that every response is tied to a request.
    Puppeteer exposes that using the `response.request()` function. We won't get into
    the `request` object yet, but one thing you need to know now is that the request
    contains the list of all the redirections a request went through. Puppeteer represents
    them with the `redirectChain()` function. With this, we have the entire redirect
    map.
  prefs: []
  type: TYPE_NORMAL
- en: '![Redirect chain'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.09_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect chain
  prefs: []
  type: TYPE_NORMAL
- en: 'It might sound complex, but you will get the idea once you start playing with
    it. The final code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We learned a lot about the `launch` function and navigation with Puppeteer.
    As I mentioned at the beginning of this chapter, I also want to share some tools
    to add to your toolbox. Let's talk about continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wouldn't it be great if a tool would guarantee that not a single line of code
    would break the functionality you are testing?
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s what **continuous integration** (**CI**) is about. CI is the practice
    of running test code before introducing a change into the code base. Atlassian
    wrote a great definition of CI ([https://www.atlassian.com/continuous-delivery/continuous-integration](https://www.atlassian.com/continuous-delivery/continuous-integration)):
    **Continuous integration** (**CI**) *is the practice of automating the integration
    of code changes from multiple contributors into a single software project. It''s
    a primary DevOps best practice, allowing developers to frequently merge code changes
    into a central repository where builds and tests then run. Automated tools are
    used to assert the new code''s correctness before integration.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an ideal workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: We have our code base in a source control repository. It could be GitHub, Gitlab,
    Bitbucket, or a local server hosting a Git server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A developer creates a new branch from that main code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make some changes in that branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And then, it creates a Pull Request or Merge Request. The developer requests
    that their changes are reviewed and incorporated into the main code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other developers will review the change, but the CI process will also run the
    tests on that branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the developers approve the change and the CI runs successfully, the code
    will be ready to be merged into the main code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sounds like an ideal world, right? Although life won't be that perfect all
    the time, we can achieve that. If you can implement this workflow when you start
    a new project, it will be easy to follow. Implementing all this in an ongoing
    project will be more challenging. My advice would be to make these changes little
    by little, not to affect productivity too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many CIs available on the market. Most of them have an entry-level
    free tier and then some paid tiers. The main differences you will see between
    them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for private repositories: Some CIs offer free tiers only for public
    repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number of parallel runs: This will be quite important if you have quite
    a big team with many Pull Requests opened simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compute power: They could give you better virtual machines on higher tiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reporting: You will find different types of reports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the most popular CIs in 2021; there are many others, but these are
    the ones you will see around:'
  prefs: []
  type: TYPE_NORMAL
- en: Travis CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circle CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AppVeyor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will test our code using GitHub Actions, just because we would only need
    a GitHub account, and we can do everything from our repository.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create a new repository on GitHub. If you don't have a GitHub account,
    you can create one at [https://github.com/join](https://github.com/join). Once
    you have an account, you can create a repository at https://github.com/new.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new repository
  prefs: []
  type: TYPE_NORMAL
- en: One important thing here is to pick `.gitignore` template, so we don't commit
    the `node_modules` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create the repository, you can get the Git URL using the **Code**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Git remote URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Git remote URL
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now clone this Git repository into a new folder, copy our working code
    there, and **push** it to GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you need to use **your** Git URL, not mine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to copy our current code to that folder. Make sure you delete
    any extra `git` folders when you copy these projects. After that, we need to run
    these three commands to commit our code and push it to GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to set up the CI. CI tasks in GitHub actions are YAML files
    inside the `. github/workflows` directory. This is what we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Checkout the branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the site.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the tests package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch the site.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example doesn''t pretend to be the canonical way to run Puppeteer
    tests in GitHub actions. There many different ways to implement this. Let''s create
    a YAML file inside the `.github/workflows` directory called `test.yml` (you can
    pick any name). The file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we are saying when we want to run this action. Then, we are setting up
    this action to run on every `master` branch. But also, it will run on every `master`
    branch. This means that it will also run after the Pull Request is merged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- uses: actions/checkout@master` will check out our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under `- name: Install Web Dependencies`, we build the site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under `- name: Install Test Dependencies`, we build the test project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under `- name: Run Site Test Code`, we run the site and the tests using the
    shell file `test.sh`, which is as simple as this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, I'm waiting for `npm run serve` to print an http://localhost:8080
    before running the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find that we are using `uses: mujo-code/puppeteer-headful@master`.
    Running a browser in a VM can be challenging. These VMs have many restrictions.
    You will need to find recipes that can help you launch a browser in a VM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, `mujo-code/puppeteer-headful` leaves us a browser ready to be
    used. That''s why we use the environment variable `PUPPETEER_SKIP_CHROMIUM_DOWNLOAD:
    ''true''`, so when we run `npm install`, Puppeteer won''t download a browser because
    we are going to use an existing one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''re going to use an existing browser, and we are going to run this in
    a restricted environment, we will need a new set of launch options. That''s why
    a set the environment variable `TESTENV: ''CI''`, and I added a new setting in
    the config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I'm setting as the executable path the environment variable `PUPPETEER_EXEC_PATH`,
    which is set by `mujo-code/puppeteer-headful`.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up all this, you will start getting builds in your pull requests.
    Let's say that a developer comes and creates a Pull Request changing a color.
  prefs: []
  type: TYPE_NORMAL
- en: '![A Pull request changing a piece of code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: A Pull request changing a piece of code
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to the **Checks** tab, you will see all the actions and their status.
    In this case, we can see that our test runs correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build result in Pull Requests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Build result in Pull Requests
  prefs: []
  type: TYPE_NORMAL
- en: There, you will find all the build details, with all the test results. But these
    results also propagate to other pages on GitHub. You will be able to see the build
    results on the main page of the Pull Request and even in the Pull Requests list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Build result on the Pull Request main page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Build result on the Pull Request main page
  prefs: []
  type: TYPE_NORMAL
- en: There, you are not going to see the full details, but it will give you a quick
    view so you can know whether the Pull Request is ready to be merged or not.
  prefs: []
  type: TYPE_NORMAL
- en: I know that this might feel overwhelming. Take this as an idea about how that
    looks, what is possible, and the challenges you might find while setting up all
    this. It's not easy, but it is worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, we started to go deeper into the Puppeteer API. We learned about
    all the different options we can use when launching a browser. We also learned
    how to navigate through a site and the different options we have to go from one
    page to another. We also saw new objects that weren't mentioned before, such as
    the `Response` and the `Request` class.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you found the continuous integration section valuable. There are many
    tools and many different ways to run tests automatically in the cloud. This is
    an essential tool to add to your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get even more practical. We will see how to interact
    with the page, from CSS selectors to mouse and keyboard emulation.
  prefs: []
  type: TYPE_NORMAL
