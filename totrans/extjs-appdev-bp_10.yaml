- en: Chapter 10. Debugging and Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed the role of the architect as being one with
    many facets. From understanding client requirements to designing the code structure
    based on UI wireframes right down to coding standards and naming conventions,
    an architect will wear many hats during the lifetime of a project.
  prefs: []
  type: TYPE_NORMAL
- en: One of these hats is that of planning with knowledge of the technology at hand.
    In order to make sure that the users of a software platform have a responsive
    experience that won't result in frustration, we need to make sure that the design
    that's in place will load quickly and will promptly react to user input. With
    Ext JS, this means having an understanding of the right component to use at the
    right time, working with layouts in an efficient manner, designing your view model
    hierarchy to avoid overnesting, and so on. There are lots of things to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Once the design is complete, there may be unexpected performance issues or bugs
    as development progresses. In these situations, the architect may take on the
    role of an expert problem solver, jumping in to apply their practical knowledge
    of the technology. Working with third-party developer tools to step through source
    code and profile areas of slow performance are key aspects to driving a project
    through to completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover these topics in the context of Ext JS and more:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with browser tooling to debug and track performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking through the Ext JS source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ext JS performance do's and don'ts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common pitfalls of Ext JS development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we'll have the ability to work as project firefighters,
    jumping into situations that need fast, authoritative solutions before they spiral
    out of control.
  prefs: []
  type: TYPE_NORMAL
- en: In-browser debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll examine several features of the Developer Tools of the Google Chrome browser
    (firstly, stepping through code and debugging it). Why Google Chrome? Aside from
    the fact that it's my own browser of choice, its tools feel a little slicker than
    those in, for example, Firefox. Having said that, Firefox will allow you to do
    most of what we'll discuss in this chapter if you'd prefer to stick with Mozilla.
    At the time of writing this book, Chrome was at version 40, but most of these
    features have been around for at least a year.
  prefs: []
  type: TYPE_NORMAL
- en: During development, there will inevitably be situations in which we'll deal
    with code that doesn't work exactly as we'd expect, whether that's the code we've
    written, code from another member of our development team, or code in a third-party
    library (such as Ext JS).
  prefs: []
  type: TYPE_NORMAL
- en: When this happens, it's useful to be able to halt code execution and inspect
    the state of the application directly. This is exactly what the Chrome Debugger
    allows us to do.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Documentation on using Chrome Developer Tools to debug JavaScript can be found
    at [https://developer.chrome.com/devtools/docs/javascript-debugging](https://developer.chrome.com/devtools/docs/javascript-debugging).
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the Alcohology app from [Chapter 9](ch09.html "Chapter 9. A Shopping
    Application"), *A Shopping Application*, to show how a debugging session might
    play out.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s load up the Alcohology project in Chrome and navigate to a product,
    then pop up the Chrome Developer Tools by going to the **View** menu, then **Developer**,
    and **Developer Tools**. Select the **Sources** pane on the Developer Tools and
    you should end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stepping in](img/5308OT_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Alcohology app with Chrome Developer Tools
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine a theoretical situation in which something's not quite right when
    we add this product to the shopping cart. We'd like to drop into the code that
    handles the `click` event on the **Add to Cart** button, so in the left pane of
    Developer Tools, we use the file explorer to navigate to `/app/view/product/ProductController.js`
    and scroll to the `onAddToCart` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the line number for line **54**, a blue indicator appears to
    show that we have set a "breakpoint" in the code at the beginning of the `onAddToCart`
    method. When code execution reaches line **54**, the debugger will pause execution
    and give us a chance to inspect the application state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stepping in](img/5308OT_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ProductController.js with a breakpoint (indicated in blue) on line 54
  prefs: []
  type: TYPE_NORMAL
- en: The breakpoint has been set, so the next step is to trigger the execution of
    this code and examine `onAddToCart`.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clicking on the **Add to Cart** button will call the `onAddToCart` click handler
    and pause the execution on line 54\. The whole line will become highlighted in
    blue to show the location we're paused on. This line of code grabs the current
    product from the view model and stores it in a `product` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the highlighted line of code is yet to run and so the product
    variable will be undefined. Let''s move on to the next line and examine the contents
    of product by clicking on the curving arrow in the right pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking point](img/5308OT_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The "step over next function call" button highlighted in a red circle
  prefs: []
  type: TYPE_NORMAL
- en: This will skip the current line and move to the next, this time highlighting
    line 56 in blue.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the product variable will be set, so you can hover the mouse
    over it and a popup will appear showing its various properties and methods. As
    it's an instance of `Alcohology.model.Product`, which is `Ext.data.Model`, we'll
    see all of the properties and methods on the object provided by all of the classes
    in the inheritance chain.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the exact structure of the inheritance chain, some of these properties
    and methods will only be revealed by drilling down through the `__proto__` property
    and expanding it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__proto__` property is an internal property on a JS object that points
    to the prototype of this object. Ext JS replicates classical inheritance by using
    JavaScript's prototypal inheritance. You can read about this in more detail at
    MDN [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain).
  prefs: []
  type: TYPE_NORMAL
- en: 'The line 56 looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we''d like to drill down into the `addProduct` method and investigate
    what''s happening in here. The **Step in to next function call** button will let
    us do this (it''s the downward arrow next to the **Skip over** button). The trouble
    is that it does exactly what it says, that is, steps into the next function call.
    Line 56 actually consists of three separate function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: A call to `getViewModel` that returns the view model assigned to this view controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A call to get with the parameter 'cart' that returns the cart from the view
    model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the call to `addProduct` with the product variable as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result is that the first time we click on **Step In**, we''ll end up in
    the Ext JS framework code for `getViewModel`. We then click on the **Step Out**
    upward arrow to return to line 56\. **Step In** and **Step Out** again takes us
    in and then back out of `get`. Finally, on the third party of our little dance,
    **Step In** will take us into the source of the `addProduct` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking point](img/5308OT_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stepping in to the addProduct code
  prefs: []
  type: TYPE_NORMAL
- en: We can now examine how the product is used in this method and verify that the
    code is behaving as expected and if not, why not?
  prefs: []
  type: TYPE_NORMAL
- en: The repeated stepping in/out can be painful and confusing, particularly for
    new developers looking to use these advanced tools. As the problem-solving architect,
    we need to understand these quirks for both our own sake and to assist our team
    in debugging sessions. There are a couple of ways around this; we'll look at these
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Black box and cut to the chase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chrome has a feature known as "blackboxing", which tells Chrome to bypass a
    code file when debugging. This is exactly what we need in order to avoid the step
    in/out dance we saw earlier; by blackboxing the Ext JS source, Chrome will not
    step into this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to set up blackboxing. Just use the left-hand side file navigator
    to open the Ext JS source code, which in development builds will likely be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also opened this file earlier as we stepped through the code, so we have
    an alternative method of getting it open in the central pane. When we''ve got
    the file in question, it''s a simple matter of right-clicking on it and choosing
    the **Blackbox Script** option from the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Black box and cut to the chase](img/5308OT_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The options menu for a source file with the Blackbox Script option highlighted
  prefs: []
  type: TYPE_NORMAL
- en: A banner will appear at the top of the pane to indicate that the file has been
    blackboxed. This is a great way to simplify debugging sessions. As the Ext JS
    source code is more than 100,000 lines long, it can also speed up the process
    a great deal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are multiple methods of blackboxing a script. Refer to [https://developer.chrome.com/devtools/docs/blackboxing](https://developer.chrome.com/devtools/docs/blackboxing)
    for more information on the Chrome Developer Tools documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The second method of avoiding step in/out pain is to bypass the code in question
    altogether. If we know the source of the method we really want to debug, then
    why not just set another breakpoint there instead? In our previous example, it
    would have made more sense to set the breakpoint on line 9 of Cart.js, right inside
    the `addProduct` method. By clicking on the **Resume Script Execution** icon,
    represented by a blue right-facing arrow, we could have jumped immediately from
    the breakpoint in the `ProductController` to the one in the `Cart` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an adage in software development: writing code is easier than reading
    code. Taking the time to work through and understand code that others have written
    is a key skill that all developers should acquire, but it''s of particular value
    to architects who are often in the position of evaluating existing code and understanding
    how it fits into a bigger picture.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and stepping through code is a key part of this, tracing the execution
    of different paths to build a picture of how the application is behaving.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking and busting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At some point in the development of a project, a developer will inevitably
    be faced with an obscure error, which is raised from the depths of Ext JS when
    the application loads. This raises an issue with the way Ext JS sets up its caching
    mechanism. For example, a normal (if slightly naïve) request for a JavaScript
    file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Out of the box, `Ext.Loader` will pull scripts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It appends a timestamp query variable to the request. This is designed to ensure
    that we always get the latest version of the script by bypassing browser caching
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: This can be very useful; however in our situation, it means that any breakpoints
    set in our code will be removed when the page reloads because Chrome thinks the
    file is different as the timestamp's different.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we resolve this? It turns out to be really simple; just open `app.json`
    in the root of an Ext JS project and search for the comment starting "this option
    is used to configure the dynamic loader". The comment contains various options
    to be passed to the loader, such as passing `true`, which "allows requests to
    receive cached responses". So, we can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Also, the cache-busting timestamps will be removed. Note the trailing comma.
    This is required to ensure the file remains as parsable JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Caught in the act
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back to the situation in which errors pop up to surprise us. There may be an
    error that happens on page load, on user interaction, or because of some background
    job. It would be great to be able to catch errors as they happens so that we can
    poke around with the debugger and try and establish what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Chrome provides a feature that does exactly this: "break on error",
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Caught in the act](img/5308OT_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The "break on error" icon, highlighted by a red circle
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a contrived example. Click on the "break on error" button and it
    turns blue, then open up the Alcohology project''s `Application.js` file, and
    add the following code to the launch method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and reload the web browser. Chrome will immediately jump to the source
    of the error deep into the Ext JS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Caught in the act](img/5308OT_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chrome's debugged paused on a line of code which is throwing an error
  prefs: []
  type: TYPE_NORMAL
- en: 'The original error thrown is `Uncaught TypeError: Cannot read property ''dom''
    of null`. This doesn''t make much sense out of context. Now that we''re in the
    code, we can see the surrounding variables and work out exactly what was null,
    in this case, the `el` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the **Call Stack** panel in the right-hand pane to jump up
    through the call stack to the code that originally initiated this code path and
    view all of the code calls in between. This is great in complicated scenarios
    to let us trace the root source of an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Caught in the act](img/5308OT_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alone, none of this will help us solve the problem. Being able to see the error,
    the state of the application when it was raised, and the path through the code
    to the original call site, all in combination with an understanding of Ext JS
    and a bit of intuition give us a smoking gun to resolve this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `el` variable, short for "element" is null, and looking back at our code
    in the launch method shows that we set our panel to `renderTo` an element called
    `myElement`. Using the **Call Stack** pane, we can step down to the constructor
    and do some detective work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ext.create` will call the constructor for the panel; we can see this by clicking
    on `Ext.panel.Panel` in the **Call Stack** pane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This in turn calls the render method on the `Ext.util.Renderable` mixin. It
    passes the value of the `renderTo` config as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the render method, this argument is called container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The render method calls `Ext.DomHelper.append` with a container argument, which
    the debugger shows to be null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This indicates that the container variable is being manipulated elsewhere within
    the render method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tracing back, we find the culprit: `container = me.initContainer(container)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `initComponent` contains the line `container.dom ? container : Ext.get(container)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of this leads us to the root source of this particular error: `the string
    myElement is passed to Ext.get`. As we haven''t added an element with this ID
    to the HTML page, Ext JS cannot find it. This means that the panel doesn''t have
    a valid container to render to and causes an error to be thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to undertake this kind of investigation can be the difference between
    a project that meets its deadlines and one that stalls due to unexpected issues.
    Diving deep into the code in this way is an essential skill to avoid roadblocks
    and keep your developers moving.
  prefs: []
  type: TYPE_NORMAL
- en: Performance in Ext JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As architects, we'll start a project with a lengthy list of requirements from
    the client that need to be implemented for them to be satisfied. There'll be explicit
    things such as "login feature" and "mobile friendly", but there are requirements
    that are not included in this list that nonetheless are unavoidable requirements
    for every client.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these is that the application should perform well. This is a catchall
    term that could include:'
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness of UI elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial application start up time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote requests such as load/save
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slow application is a key source of user frustration and the first step to
    diagnosing any issues of this nature is to collect information.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the various ways in which Chrome Developer Tools can help us and
    address common problems using Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: Network performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen in our examples, many Ext JS applications will communicate with
    a backend API service in order to read and write data. If user feedback shows
    that remote requests are unresponsive, we need to first diagnose the calls that
    are causing problems. Chrome can help us here.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Developer Tools open, click on the **Network** tab and refresh the
    page. We get a list of all of the resources requested as the application loads;
    we can filter this by clicking on one of the headers at the top of the pane. Here''s
    the Alcohology application filtered to "XHR" or Ajax requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network performance](img/5308OT_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chrome Developer Tools with an Ajax request selected
  prefs: []
  type: TYPE_NORMAL
- en: In this example, one of the requests has been selected and a breakdown of timing
    details in shown on the right-hand side. While the Alcohology application has
    a very fast response time, it serves as a good illustration of how to analyze
    network performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details about the **Network** panel can be found at [https://developer.chrome.com/devtools/docs/network](https://developer.chrome.com/devtools/docs/network).
  prefs: []
  type: TYPE_NORMAL
- en: How does this help us? If the remote server is slow, then as frontend developers,
    there's not much we can do about this; other than keeping our remote requests
    to a minimum, we're stuck with what's available. Here's one example that we can
    act on in order to speed things up.
  prefs: []
  type: TYPE_NORMAL
- en: Note the "stalled" entry in the timings. This is often caused due to the limit
    that browsers impose on the number of connections that can be active to one origin
    (such as a domain or subdomain) at a time. When this number is exceeded, the browser
    will block any new requests until a connection becomes available. This knowledge
    gives us several opportunities for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Make fewer requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The no-brainer approach to this problem is to simply request fewer things from
    the server and Ext JS gives us several ways to do this. First up is a technique
    we used in the Alcohology app (use an icon font such as `FontAwesome` instead
    of image icons). This means that we'll only have to download one font file rather
    than multiple icon files. The `glyph` config on menu items and buttons gives us
    a really easy way to use this feature and negate the need to use bitmap images
    for icons.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is nested data. This is an approach that we used in the `Questionnaire`
    component, but one that needs to be used carefully. By setting up model associations,
    we can request data for the whole hierarchy and populate our data model all at
    once, rather than per mode type.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for the `Questionnaire` component, we could have loaded the questionnaire,
    the steps, and the questions in three separate requests, but by bringing it all
    down at once, we avoided the two remote requests. There are two caveats to this
    idea; firstly, the server needs to support nested data; secondly, the size of
    the nested data maybe much larger and therefore result in a slower response time.
    Multiple separate requests might result in better perceived performance, so application
    of this concept strongly depends on the situation, speaking of the perception
    of performance, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Perceived performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some cases in which we can't improve the load time of certain aspects
    of an application, for example, it could be report generation where the number
    crunching involved is a long-running operation.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we need to do what we can to improve the user's perception of
    performance and assure them that the action they're undertaking is underway and
    will finish soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ext JS, one key mechanism to do this is `Ext.LoadMask`. It''s used by Ext
    JS internally in several situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Perceived performance](img/5308OT_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous example from the Ext JS Kitchen Sink, a grid with a paging toolbar
    will automatically use `LoadMask` while waiting for the server to return the next
    page.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage to the user is that while they have to wait, they're at least
    being told that they have to wait. Without `LoadMask`, they'd have hit a button
    and received no feedback that the server was thinking about the request.
  prefs: []
  type: TYPE_NORMAL
- en: We can leverage `LoadMask` in our own code by creating a new instance when we
    need it, but it's more likely that we'd use it on an existing container and leverage
    the fact that many Ext JS components have `LoadMask` functionality baked in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use event domains, which we discussed back in [Chapter 2](ch02.html
    "Chapter 2. MVC and MVVM"), *MVC and MVVM*, as one way of hooking into remote
    requests and masking our components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet that we added to the `ProductController` on Alcohology,
    we tell the `listen` config to watch out for `beforeload` and `load` events on
    the products store. The listener can use the "products" alias that we'd already
    set up on the products `store` class. When the `beforeload` event fires, we grab
    the product list view and call its mask method to show its `LoadMask`. When the
    server response returns and the `load` event fires, we call the mask method with
    the false argument to hide it again.
  prefs: []
  type: TYPE_NORMAL
- en: It's a simple and an unobtrusive way to wire up the loading mechanism and give
    the user that all-important feedback, showing that their actions have triggered
    an effect.
  prefs: []
  type: TYPE_NORMAL
- en: Load less
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One very simple way to speed up the response of Ajax requests is to simply request
    less stuff! If the server supports paging, then any component powered by a store
    can immediately become more performant by requesting a single page of data rather
    than pulling it down all at once.
  prefs: []
  type: TYPE_NORMAL
- en: '`Ext.PagingToolbar` can be linked to a store and placed anywhere in an application
    to provide a pagination UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, for example, is how we''d begin to add a paging toolbar to the Alcohology
    application''s product list view. It automatically takes on touch-friendly styling
    from the theme we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load less](img/5308OT_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alcohology's product list complete with paging toolbar
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced version of this technique involves using the `Ext.data.reader.Reader.metaData`
    property or the `Ext.data.proxy.Proxy.metachange` event. This can be used to pass
    data from the server to the client, which is in turn used to configure the Ext
    JS application; a common example is to allow the server to specify the columns
    that a grid contains when it first loads.
  prefs: []
  type: TYPE_NORMAL
- en: This could mean that on initial load, the server omits a field and matching
    grid column, such as a description, which may contain a lot of data. The user
    could customize the grid via the column header UI to show it when they need it.
  prefs: []
  type: TYPE_NORMAL
- en: Optimistic updating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When saving a record to the server, we''d normally see the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: User clicks a button to save the record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ext JS displays a "saving" message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save completes and a "success" message is displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some situations though, we can trust that the server is going to save successfully
    and cut the actions down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User clicks on a button to save the record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save proceeds and a "saved" message is displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the save action happens entirely in the background and doesn't
    block the user from performing other actions. You can see this kind of behavior
    in many e-mail applications with the server interaction happening behind the scenes
    and an "outbox" to store messages that fail to send on the first try.
  prefs: []
  type: TYPE_NORMAL
- en: In the event that the server does raise some kind of error, we can display a
    failure message and rollback the changes that the user performed. The Ext JS grid
    includes UI to do this; it will highlight changed values with a red marker that
    can be cleared when we're sure the record has been successfully committed to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: This is an advanced technique that requires extra UI design work, but it can
    immeasurably improve your user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Quick on the draw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to ensuring that the way our application interacts with the server
    is always done in a timely fashion, we also need to be concerned with the speed
    at which the user interface renders and how quickly the browser draws the UI.
    There are a number of common pitfalls with Ext JS in this regard:'
  prefs: []
  type: TYPE_NORMAL
- en: Overuse of panels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Panels have several features such as a header containing tool icons, the ability
    to be draggable, collapsible, and have docked items. In many situations, these
    features just aren't required. In this situation, a container is a much better
    choice. It's more lightweight in memory and the markup it generates.
  prefs: []
  type: TYPE_NORMAL
- en: Overnesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overnesting of containers and panels, particularly those implementing border
    layouts, are a very common source of performance issues, particularly if the user
    needs to move between various screens containing over-nested components. Ext JS
    needs to perform lots of calculations to build a viewport and the layout process
    is particularly expensive. Every time we find ourselves adding a new component
    to the hierarchy, it should cause us to stop and re-evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to think about how a deep hierarchy could affect cases in which
    we are querying our component structure. With a more complex component tree and
    a more complicated DOM, any operations to fetch either components or elements
    from the application will be slower. In many cases, this slowdown will be marginal;
    in some cases, it'll be a critical consideration when improving your application's
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a container or panel with a card layout, by default the layout
    will immediate render all components within each card. This is usually unnecessary
    because the user will only see the first card to begin with. Instead, we can use
    the `deferredRender` configuration option on the card layout to render items only
    when their parent card becomes active. This reduces the initial render time, therefore,
    the time until the application can respond to user input.
  prefs: []
  type: TYPE_NORMAL
- en: Another similar approach involves grids. Ext JS allows you to load a large server
    response into a store and attempts to display it on a grid, but in situation with
    thousands of records, the store causes memory usage to balloon and the browser
    will struggle to keep things smooth with such a large number of DOM nodes making
    up the grid rows.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to swap out a standard store for `Ext.data.BufferedStore`. This
    uses an enhanced paging mechanism to preload pages of data in advance. Meanwhile,
    the grid will automatically use `Ext.grid.plugin.BufferedRenderer` and as the
    user scrolls through the grid entries, the backing `BufferedStore` will automatically
    load in new pages of data while removing old pages. It does this seamlessly, so
    the user has no idea that the rows are being loaded from the server on the fly.
    The `BufferedRenderer` will also dispose of DOM nodes from old nodes as they scroll
    past, removing the memory burden of such a large amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: All of these techniques have their place. They are also useful tools to be aware
    of at the start of the architecture process. If a client asks whether the application
    can handle 10,000 records in a datagrid, we now know that a buffered store can
    deliver the goods. On the flipside, we need to be conscious of premature optimization;
    there's no point implementing a buffered store when we're only dealing with a
    handful of records.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with performance issues is initially a problem of intelligence gathering.
    There can be multiple reasons why an application feels slow, and the feedback
    of users often doesn't help. Describing a part of the app as "sticky" just isn't
    a great way to diagnose the root cause. We need to get firm facts and figures
    in front of us before we can hope to find a solution. While we'll look at metrics
    such as rendering and response times, there are many considerations that must
    be taken into account, such as memory usage and user perception. These topics
    are left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Chrome Developer Tools come to the rescue again. This time, we''ll look
    at two main features that help diagnose performance problems: profiles and the
    timeline.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, there are two situations in which Ext JS applications feel slow:
    poor design decisions and over-complicated apps. Having said that, these techniques
    are invaluable when the problem does crop up and are applicable to any JavaScript
    technology.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The profiler can be found by bringing up the Developer Tools and selecting
    the **Profiles** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing performance](img/5308OT_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While there are several types of profiles that can be issued, we''ll take a
    look at the CPU profile. In the preceding screenshot, we''d click on **Start**
    to immediately begin profiling. Here''s a look at what happens when you click
    on a product in Alcohology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing performance](img/5308OT_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The grid is ordered with the most time-consuming function calls at the top and
    each line can be expanded so that we can see the functions that were called in
    turn. The **Self** column shows the percentage of time spent in just that function's
    body; the **Total** column shows the time spent in that function as well as all
    of the functions it called.
  prefs: []
  type: TYPE_NORMAL
- en: While this part of the Alcohology application is performing just fine, this
    simple view of the heavily-used parts of code is a key avenue to diagnose serious
    performance problems. However, we can do more.
  prefs: []
  type: TYPE_NORMAL
- en: We've used Chrome Developer Tools to evaluate the performance of remote requests
    and now we've used them to track down hotspots in our code. What about a single
    view that could help us track the general behavior of our application and help
    us visualize the types of interactions that are slowing things down? This is exactly
    what the **Timeline** tab offers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a whistle-stop tour of **Timeline**. Refer to [https://developer.chrome.com/devtools/docs/timeline](https://developer.chrome.com/devtools/docs/timeline)
    for more details and full documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'By selecting the **Timeline** tab and clicking on the **Record** button, Chrome
    immediately begins recording every event currently taking place on the page. Clicking
    on **Record** again allows you to analyze the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing performance](img/5308OT_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Timeline allows you to filter down a timeframe of events and view each in turn,
    from user clicks to Ajax requests to URL changes and browser repaints. From the
    first event, we can trace down each subsequent event, viewing stack traces, detailed
    timings and warnings regarding problematic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Timeline is a powerful tool and you will need time and experience to use it
    to the fullest. It's time well spent; it can reveal clues that would be difficult
    or impossible to discover any other way. These clues can help resolve problems
    that would otherwise take days to tackle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has given us a number of angles to approach two of the most important
    parts of building a successful application: fixing issues and adding polish. While
    explicit customer requirements form the main body of our work, we should always
    strive to make sure that our projects are performant and as bug-free as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome Developer Tools are an invaluable weapon in our arsenal. By opening
    a window in the otherwise dark world of debugging and performance, we can take
    educated steps to quickly resolve issues. Stepping through our own code and that
    of the Ext JS framework becomes significantly easier with the power of breakpoints
    and the call stack explorer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take our final step to building a well-rounded and
    robust application. While we are constantly working to build the best architecture
    we can, automated testing can provide a level of reassurance that takes the solidity
    of our work to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Code changes and refactoring can be done with confidence when our test suite
    can tell us if we've broken something with our latest amendments. Integration
    tests can provide assurances that our final application meets customer requirements
    and unit tests can encourage separation of code and ensure that our business logic
    is sound.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into a variety of ways to implement these ideas
    and more.
  prefs: []
  type: TYPE_NORMAL
