- en: Chapter 10. Debugging and Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。调试和性能
- en: In previous chapters, we discussed the role of the architect as being one with
    many facets. From understanding client requirements to designing the code structure
    based on UI wireframes right down to coding standards and naming conventions,
    an architect will wear many hats during the lifetime of a project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了架构师的多面角色。从理解客户需求到根据 UI 线框设计代码结构，再到编码标准和命名约定，架构师在项目生命周期中会戴许多帽子。
- en: One of these hats is that of planning with knowledge of the technology at hand.
    In order to make sure that the users of a software platform have a responsive
    experience that won't result in frustration, we need to make sure that the design
    that's in place will load quickly and will promptly react to user input. With
    Ext JS, this means having an understanding of the right component to use at the
    right time, working with layouts in an efficient manner, designing your view model
    hierarchy to avoid overnesting, and so on. There are lots of things to consider.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个角色是利用现有技术的知识进行规划。为了确保软件平台的使用者获得响应式体验，不会导致挫败感，我们需要确保现有的设计能够快速加载，并能迅速响应用户输入。使用
    Ext JS，这意味着要理解在正确的时间使用正确的组件，以高效的方式处理布局，设计视图模型层次结构以避免过度嵌套，等等。有许多事情需要考虑。
- en: Once the design is complete, there may be unexpected performance issues or bugs
    as development progresses. In these situations, the architect may take on the
    role of an expert problem solver, jumping in to apply their practical knowledge
    of the technology. Working with third-party developer tools to step through source
    code and profile areas of slow performance are key aspects to driving a project
    through to completion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设计完成，随着开发的进行，可能会出现意外的性能问题或错误。在这些情况下，架构师可能需要承担专家问题解决者的角色，跳入应用他们对技术的实际知识。与第三方开发工具一起逐步检查源代码和性能缓慢的区域是推动项目完成的要点。
- en: 'In this chapter, we''ll cover these topics in the context of Ext JS and more:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从 Ext JS 和更多背景下涵盖这些主题：
- en: Working with browser tooling to debug and track performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器工具进行调试和跟踪性能
- en: Picking through the Ext JS source code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Ext JS 源代码
- en: Ext JS performance do's and don'ts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 性能的要点和禁忌
- en: Common pitfalls of Ext JS development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 开发的常见陷阱
- en: By the end of this chapter, we'll have the ability to work as project firefighters,
    jumping into situations that need fast, authoritative solutions before they spiral
    out of control.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将具备作为项目救火员的能力，在情况失控之前，迅速跳入需要快速、权威解决方案的情境。
- en: In-browser debugging
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器内调试
- en: We'll examine several features of the Developer Tools of the Google Chrome browser
    (firstly, stepping through code and debugging it). Why Google Chrome? Aside from
    the fact that it's my own browser of choice, its tools feel a little slicker than
    those in, for example, Firefox. Having said that, Firefox will allow you to do
    most of what we'll discuss in this chapter if you'd prefer to stick with Mozilla.
    At the time of writing this book, Chrome was at version 40, but most of these
    features have been around for at least a year.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查 Google Chrome 浏览器开发者工具的几个功能（首先是逐步执行代码和调试）。为什么是 Google Chrome？除了它是我的首选浏览器之外，它的工具感觉比
    Firefox 等浏览器更流畅。话虽如此，如果你更喜欢坚持使用 Mozilla，Firefox 也会让你完成本章中讨论的大部分内容。在撰写本书时，Chrome
    的版本是 40，但这些功能中大多数至少已经存在一年了。
- en: During development, there will inevitably be situations in which we'll deal
    with code that doesn't work exactly as we'd expect, whether that's the code we've
    written, code from another member of our development team, or code in a third-party
    library (such as Ext JS).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，不可避免地会遇到代码无法按预期工作的情况，无论是我们编写的代码，还是我们开发团队其他成员的代码，或者是第三方库（如 Ext JS）中的代码。
- en: When this happens, it's useful to be able to halt code execution and inspect
    the state of the application directly. This is exactly what the Chrome Debugger
    allows us to do.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，能够直接停止代码执行并检查应用程序的状态是非常有用的。这正是 Chrome 调试器允许我们做到的。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Documentation on using Chrome Developer Tools to debug JavaScript can be found
    at [https://developer.chrome.com/devtools/docs/javascript-debugging](https://developer.chrome.com/devtools/docs/javascript-debugging).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chrome 开发者工具调试 JavaScript 的文档可以在 [https://developer.chrome.com/devtools/docs/javascript-debugging](https://developer.chrome.com/devtools/docs/javascript-debugging)
    找到。
- en: We'll use the Alcohology app from [Chapter 9](ch09.html "Chapter 9. A Shopping
    Application"), *A Shopping Application*, to show how a debugging session might
    play out.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自[第9章](ch09.html "第9章。购物应用程序")的Alcohology应用，*购物应用程序*，来展示调试会话可能如何进行。
- en: Stepping in
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步入
- en: 'Let''s load up the Alcohology project in Chrome and navigate to a product,
    then pop up the Chrome Developer Tools by going to the **View** menu, then **Developer**,
    and **Developer Tools**. Select the **Sources** pane on the Developer Tools and
    you should end up with something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Chrome中加载Alcohology项目并导航到一个产品，然后通过访问**视图**菜单，然后**开发者**，以及**开发者工具**来弹出Chrome开发者工具。选择开发者工具中的**源**选项卡，你应该会看到类似这样的内容：
- en: '![Stepping in](img/5308OT_10_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![步入](img/5308OT_10_01.jpg)'
- en: The Alcohology app with Chrome Developer Tools
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chrome开发者工具的Alcohology应用
- en: Let's imagine a theoretical situation in which something's not quite right when
    we add this product to the shopping cart. We'd like to drop into the code that
    handles the `click` event on the **Add to Cart** button, so in the left pane of
    Developer Tools, we use the file explorer to navigate to `/app/view/product/ProductController.js`
    and scroll to the `onAddToCart` method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个理论情况，当我们将此产品添加到购物车时，可能有些不对劲。我们希望进入处理**添加到购物车**按钮**点击**事件的代码，因此我们在开发者工具的左侧面板中使用文件资源管理器导航到`/app/view/product/ProductController.js`并滚动到`onAddToCart`方法。
- en: 'By clicking on the line number for line **54**, a blue indicator appears to
    show that we have set a "breakpoint" in the code at the beginning of the `onAddToCart`
    method. When code execution reaches line **54**, the debugger will pause execution
    and give us a chance to inspect the application state:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单击第**54**行的行号，将出现一个蓝色指示器，表示我们在`onAddToCart`方法的开头设置了“断点”。当代码执行到达第**54**行时，调试器将暂停执行，并给我们机会检查应用程序状态：
- en: '![Stepping in](img/5308OT_10_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![步入](img/5308OT_10_02.jpg)'
- en: ProductController.js with a breakpoint (indicated in blue) on line 54
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ProductController.js在第54行设置了断点（以蓝色表示）
- en: The breakpoint has been set, so the next step is to trigger the execution of
    this code and examine `onAddToCart`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 已经设置了断点，所以下一步是触发此代码的执行并检查`onAddToCart`。
- en: Breaking point
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点
- en: Clicking on the **Add to Cart** button will call the `onAddToCart` click handler
    and pause the execution on line 54\. The whole line will become highlighted in
    blue to show the location we're paused on. This line of code grabs the current
    product from the view model and stores it in a `product` variable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加到购物车**按钮将调用`onAddToCart`点击处理程序并在第54行暂停执行。整行将高亮显示为蓝色，以显示我们暂停的位置。这一行代码从视图模型中获取当前产品并将其存储在`product`变量中。
- en: 'At this point, the highlighted line of code is yet to run and so the product
    variable will be undefined. Let''s move on to the next line and examine the contents
    of product by clicking on the curving arrow in the right pane:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，高亮显示的代码行尚未运行，因此`product`变量将是未定义的。让我们继续到下一行，通过点击右侧面板中的曲线箭头来检查`product`的内容：
- en: '![Breaking point](img/5308OT_10_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![断点](img/5308OT_10_03.jpg)'
- en: The "step over next function call" button highlighted in a red circle
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 红圈中高亮显示的“跳过下一个函数调用”按钮
- en: This will skip the current line and move to the next, this time highlighting
    line 56 in blue.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将跳过当前行并移动到下一行，这次将第56行高亮显示为蓝色。
- en: At this point, the product variable will be set, so you can hover the mouse
    over it and a popup will appear showing its various properties and methods. As
    it's an instance of `Alcohology.model.Product`, which is `Ext.data.Model`, we'll
    see all of the properties and methods on the object provided by all of the classes
    in the inheritance chain.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`product`变量将被设置，因此你可以将鼠标悬停在其上，将出现一个弹出窗口显示其各种属性和方法。由于它是一个`Alcohology.model.Product`的实例，而`Alcohology.model.Product`是`Ext.data.Model`，我们将看到继承链中所有类提供的对象上的所有属性和方法。
- en: Depending on the exact structure of the inheritance chain, some of these properties
    and methods will only be revealed by drilling down through the `__proto__` property
    and expanding it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据继承链的确切结构，一些属性和方法只能通过通过`__proto__`属性向下钻取并展开来揭示。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `__proto__` property is an internal property on a JS object that points
    to the prototype of this object. Ext JS replicates classical inheritance by using
    JavaScript's prototypal inheritance. You can read about this in more detail at
    MDN [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`__proto__`属性是一个指向此对象原型的JS对象的内部属性。Ext JS通过使用JavaScript的原型继承来复制经典继承。你可以在MDN上了解更多详细信息[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain)。'
- en: 'The line 56 looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第56行看起来是这样的：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s say we''d like to drill down into the `addProduct` method and investigate
    what''s happening in here. The **Step in to next function call** button will let
    us do this (it''s the downward arrow next to the **Skip over** button). The trouble
    is that it does exactly what it says, that is, steps into the next function call.
    Line 56 actually consists of three separate function calls:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想深入到`addProduct`方法中，调查这里发生了什么。**Step in to next function call**按钮将允许我们这样做（它位于**Skip
    over**按钮旁边的向下箭头）。问题是它确实做了它所说的，那就是进入下一个函数调用。第56行实际上由三个单独的函数调用组成：
- en: A call to `getViewModel` that returns the view model assigned to this view controller
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个调用`getViewModel`，它返回分配给这个视图控制器的视图模型
- en: A call to get with the parameter 'cart' that returns the cart from the view
    model
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有参数'cart'的`get`调用，它从视图中返回购物车
- en: Finally, the call to `addProduct` with the product variable as a parameter
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，带有产品变量作为参数的`addProduct`调用
- en: 'The result is that the first time we click on **Step In**, we''ll end up in
    the Ext JS framework code for `getViewModel`. We then click on the **Step Out**
    upward arrow to return to line 56\. **Step In** and **Step Out** again takes us
    in and then back out of `get`. Finally, on the third party of our little dance,
    **Step In** will take us into the source of the `addProduct` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们第一次点击**Step In**时，会进入`getViewModel`的Ext JS框架代码。然后我们点击向上的箭头**Step Out**返回到第56行。再次点击**Step
    In**和**Step Out**会将我们带入`get`并再次退出。最后，在我们这个小舞蹈的第三部分，**Step In**会带我们进入`addProduct`方法的源代码：
- en: '![Breaking point](img/5308OT_10_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![断裂点](img/5308OT_10_04.jpg)'
- en: Stepping in to the addProduct code
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`addProduct`代码
- en: We can now examine how the product is used in this method and verify that the
    code is behaving as expected and if not, why not?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查产品在这个方法中的使用情况，并验证代码是否按预期运行，如果不是，原因是什么？
- en: The repeated stepping in/out can be painful and confusing, particularly for
    new developers looking to use these advanced tools. As the problem-solving architect,
    we need to understand these quirks for both our own sake and to assist our team
    in debugging sessions. There are a couple of ways around this; we'll look at these
    next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的进入/退出可能会很痛苦且令人困惑，尤其是对于想要使用这些高级工具的新开发者来说。作为问题解决架构师，我们需要为了我们自己以及帮助我们的团队在调试会话中理解这些怪癖。有几种方法可以解决这个问题；我们将在下一节中探讨这些方法。
- en: Black box and cut to the chase
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑盒化和直截了当
- en: Chrome has a feature known as "blackboxing", which tells Chrome to bypass a
    code file when debugging. This is exactly what we need in order to avoid the step
    in/out dance we saw earlier; by blackboxing the Ext JS source, Chrome will not
    step into this code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome有一个名为“黑盒化”的功能，它告诉Chrome在调试时跳过代码文件。这正是我们需要的，以避免我们之前看到的进入/退出舞蹈；通过黑盒化Ext
    JS源代码，Chrome将不会进入此代码。
- en: 'It''s easy to set up blackboxing. Just use the left-hand side file navigator
    to open the Ext JS source code, which in development builds will likely be something
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 设置黑盒化很容易。只需使用左侧的文件导航器打开Ext JS源代码，在开发构建中可能类似于这样：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also opened this file earlier as we stepped through the code, so we have
    an alternative method of getting it open in the central pane. When we''ve got
    the file in question, it''s a simple matter of right-clicking on it and choosing
    the **Blackbox Script** option from the menu:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在遍历代码时也打开了此文件，因此我们有一种替代方法在中央面板中打开它。当我们得到有问题的文件时，只需右键单击它并从菜单中选择**Blackbox Script**选项即可：
- en: '![Black box and cut to the chase](img/5308OT_10_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![黑盒化和直截了当](img/5308OT_10_05.jpg)'
- en: The options menu for a source file with the Blackbox Script option highlighted
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 带有高亮Blackbox Script选项的源文件选项菜单
- en: A banner will appear at the top of the pane to indicate that the file has been
    blackboxed. This is a great way to simplify debugging sessions. As the Ext JS
    source code is more than 100,000 lines long, it can also speed up the process
    a great deal.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 会在窗格顶部出现一个横幅，指示文件已被黑盒化。这是一种简化调试会话的好方法。由于 Ext JS 源代码超过 10 万行，这也可以大大加快过程。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are multiple methods of blackboxing a script. Refer to [https://developer.chrome.com/devtools/docs/blackboxing](https://developer.chrome.com/devtools/docs/blackboxing)
    for more information on the Chrome Developer Tools documentation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以将脚本黑盒化。有关 Chrome 开发者工具文档的更多信息，请参阅 [https://developer.chrome.com/devtools/docs/blackboxing](https://developer.chrome.com/devtools/docs/blackboxing)。
- en: The second method of avoiding step in/out pain is to bypass the code in question
    altogether. If we know the source of the method we really want to debug, then
    why not just set another breakpoint there instead? In our previous example, it
    would have made more sense to set the breakpoint on line 9 of Cart.js, right inside
    the `addProduct` method. By clicking on the **Resume Script Execution** icon,
    represented by a blue right-facing arrow, we could have jumped immediately from
    the breakpoint in the `ProductController` to the one in the `Cart` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 避免逐步进入/退出痛苦的第二种方法是完全绕过相关的代码。如果我们知道我们真正想要调试的方法的来源，那么为什么不在那里设置另一个断点呢？在我们的上一个例子中，在
    Cart.js 的第 9 行设置断点，正好在 `addProduct` 方法中，会更有意义。通过点击表示为蓝色向右箭头的 **恢复脚本执行** 图标，我们可以立即从
    `ProductController` 中的断点跳转到 `Cart` 类中的断点。
- en: 'There''s an adage in software development: writing code is easier than reading
    code. Taking the time to work through and understand code that others have written
    is a key skill that all developers should acquire, but it''s of particular value
    to architects who are often in the position of evaluating existing code and understanding
    how it fits into a bigger picture.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中有一个谚语：写代码比读代码容易。花时间去理解别人写的代码是一项所有开发者都应该掌握的关键技能，但对于经常处于评估现有代码和理解其如何融入更大图景的架构师来说，尤其有价值。
- en: Debugging and stepping through code is a key part of this, tracing the execution
    of different paths to build a picture of how the application is behaving.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和逐步执行代码是这个过程中的关键部分，追踪不同路径的执行以构建应用程序行为的图景。
- en: Breaking and busting
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破和破解
- en: 'At some point in the development of a project, a developer will inevitably
    be faced with an obscure error, which is raised from the depths of Ext JS when
    the application loads. This raises an issue with the way Ext JS sets up its caching
    mechanism. For example, a normal (if slightly naïve) request for a JavaScript
    file might look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的某个开发阶段，开发者不可避免地会面临一个晦涩的错误，这个错误是在应用程序加载时从 Ext JS 的深处抛出的。这引发了 Ext JS 设置其缓存机制的方式问题。例如，一个正常（如果稍微有些天真）的
    JavaScript 文件请求可能看起来像这样：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Out of the box, `Ext.Loader` will pull scripts like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Ext.Loader` 将拉取如下脚本：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It appends a timestamp query variable to the request. This is designed to ensure
    that we always get the latest version of the script by bypassing browser caching
    mechanisms.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它将时间戳查询变量附加到请求中。这是为了确保我们总是通过绕过浏览器缓存机制来获取脚本的最新版本。
- en: This can be very useful; however in our situation, it means that any breakpoints
    set in our code will be removed when the page reloads because Chrome thinks the
    file is different as the timestamp's different.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能非常有用；然而，在我们的情况下，这意味着当页面重新加载时，我们代码中设置的任何断点都将被移除，因为 Chrome 认为文件是不同的，因为时间戳不同。
- en: 'How can we resolve this? It turns out to be really simple; just open `app.json`
    in the root of an Ext JS project and search for the comment starting "this option
    is used to configure the dynamic loader". The comment contains various options
    to be passed to the loader, such as passing `true`, which "allows requests to
    receive cached responses". So, we can add the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何解决这个问题？实际上非常简单；只需在 Ext JS 项目的根目录中打开 `app.json` 并搜索以 "this option is used
    to configure the dynamic loader" 开头的注释。该注释包含传递给加载器的各种选项，例如传递 `true`，这 "允许请求接收缓存的响应"。因此，我们可以添加以下代码：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Also, the cache-busting timestamps will be removed. Note the trailing comma.
    This is required to ensure the file remains as parsable JSON.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，缓存破坏的时间戳也将被移除。注意尾随逗号。这是确保文件保持可解析 JSON 的必要条件。
- en: Caught in the act
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被当场抓住
- en: Back to the situation in which errors pop up to surprise us. There may be an
    error that happens on page load, on user interaction, or because of some background
    job. It would be great to be able to catch errors as they happens so that we can
    poke around with the debugger and try and establish what went wrong.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回到出现错误让我们感到惊讶的情况。错误可能发生在页面加载时，用户交互时，或者由于某些后台任务。能够捕捉到错误发生时的情况将非常棒，这样我们就可以用调试器四处探索并尝试确定出了什么问题。
- en: 'Fortunately, Chrome provides a feature that does exactly this: "break on error",
    as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Chrome提供了一个正好做这件事的功能：“断点错误”，如下所示：
- en: '![Caught in the act](img/5308OT_10_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![现场被抓](img/5308OT_10_06.jpg)'
- en: The "break on error" icon, highlighted by a red circle
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 被红色圆圈高亮的“断点错误”图标
- en: 'Let''s try a contrived example. Click on the "break on error" button and it
    turns blue, then open up the Alcohology project''s `Application.js` file, and
    add the following code to the launch method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个假设的例子。点击“断点错误”按钮，它变成蓝色，然后打开Alcohology项目的`Application.js`文件，并在启动方法中添加以下代码：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save and reload the web browser. Chrome will immediately jump to the source
    of the error deep into the Ext JS code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重新加载网页浏览器。Chrome将立即跳转到Ext JS代码深处错误的源头：
- en: '![Caught in the act](img/5308OT_10_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![现场被抓](img/5308OT_10_07.jpg)'
- en: Chrome's debugged paused on a line of code which is throwing an error
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome调试暂停在抛出错误的代码行上
- en: 'The original error thrown is `Uncaught TypeError: Cannot read property ''dom''
    of null`. This doesn''t make much sense out of context. Now that we''re in the
    code, we can see the surrounding variables and work out exactly what was null,
    in this case, the `el` variable.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '原始抛出的错误是`Uncaught TypeError: Cannot read property ''dom'' of null`。在没有上下文的情况下，这没有太多意义。现在我们处于代码中，我们可以看到周围的变量并确定到底哪个变量为null，在这个例子中，是`el`变量。'
- en: 'We can also use the **Call Stack** panel in the right-hand pane to jump up
    through the call stack to the code that originally initiated this code path and
    view all of the code calls in between. This is great in complicated scenarios
    to let us trace the root source of an error:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用右侧面板中的**调用栈**面板跳过调用栈，到最初发起这个代码路径的代码，并查看中间的所有代码调用。这在复杂场景中非常好，可以让我们追踪错误的根本原因：
- en: '![Caught in the act](img/5308OT_10_08.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![现场被抓](img/5308OT_10_08.jpg)'
- en: Alone, none of this will help us solve the problem. Being able to see the error,
    the state of the application when it was raised, and the path through the code
    to the original call site, all in combination with an understanding of Ext JS
    and a bit of intuition give us a smoking gun to resolve this issue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这些都无法帮助我们解决问题。能够看到错误、错误发生时应用程序的状态以及通过代码到原始调用站的路径，所有这些结合对Ext JS的理解和一些直觉，给我们提供了解决这个问题的有力证据。
- en: 'The `el` variable, short for "element" is null, and looking back at our code
    in the launch method shows that we set our panel to `renderTo` an element called
    `myElement`. Using the **Call Stack** pane, we can step down to the constructor
    and do some detective work:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`el`变量，简称"元素"，为空，回顾我们在启动方法中的代码，我们发现我们将面板设置为`renderTo`一个名为`myElement`的元素。使用**调用栈**面板，我们可以向下到构造函数并做一些侦探工作：'
- en: '`Ext.create` will call the constructor for the panel; we can see this by clicking
    on `Ext.panel.Panel` in the **Call Stack** pane.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext.create`将调用面板的构造函数；我们可以通过在**调用栈**面板中点击`Ext.panel.Panel`来看到这一点。'
- en: This in turn calls the render method on the `Ext.util.Renderable` mixin. It
    passes the value of the `renderTo` config as an argument.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这反过来又调用了`Ext.util.Renderable`混入的渲染方法。它传递了`renderTo`配置的值作为参数。
- en: Within the render method, this argument is called container.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染方法中，这个参数被称为容器。
- en: The render method calls `Ext.DomHelper.append` with a container argument, which
    the debugger shows to be null.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染方法调用`Ext.DomHelper.append`并带有容器参数，调试器显示该参数为null。
- en: This indicates that the container variable is being manipulated elsewhere within
    the render method.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这表明容器变量在渲染方法中被其他地方操作。
- en: 'Tracing back, we find the culprit: `container = me.initContainer(container)`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追溯回去，我们发现罪魁祸首：`container = me.initContainer(container)`。
- en: 'The `initComponent` contains the line `container.dom ? container : Ext.get(container)`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initComponent`包含以下行`container.dom ? container : Ext.get(container)`。'
- en: 'All of this leads us to the root source of this particular error: `the string
    myElement is passed to Ext.get`. As we haven''t added an element with this ID
    to the HTML page, Ext JS cannot find it. This means that the panel doesn''t have
    a valid container to render to and causes an error to be thrown.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些最终都指向这个特定错误的根本原因：`将字符串myElement传递给Ext.get`。由于我们没有在HTML页面上添加具有此ID的元素，Ext
    JS无法找到它。这意味着面板没有有效的容器来渲染，从而导致抛出错误。
- en: The ability to undertake this kind of investigation can be the difference between
    a project that meets its deadlines and one that stalls due to unexpected issues.
    Diving deep into the code in this way is an essential skill to avoid roadblocks
    and keep your developers moving.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 能够进行这种调查的能力可能是一个项目能否按时完成与因意外问题而停滞之间的区别。以这种方式深入代码是一种避免障碍并保持开发者前进的必要技能。
- en: Performance in Ext JS
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext JS中的性能
- en: As architects, we'll start a project with a lengthy list of requirements from
    the client that need to be implemented for them to be satisfied. There'll be explicit
    things such as "login feature" and "mobile friendly", but there are requirements
    that are not included in this list that nonetheless are unavoidable requirements
    for every client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为架构师，我们将从客户那里开始一个项目，客户会提供一个需要实现的长长的需求列表，以满足他们的需求。其中会有明确的事项，例如“登录功能”和“移动友好”，但还有一些需求并未包含在这个列表中，然而这些却是每个客户不可避免的需求。
- en: 'One of these is that the application should perform well. This is a catchall
    term that could include:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是应用程序应该表现良好。这是一个包含以下内容的通用术语：
- en: Responsiveness of UI elements
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI元素的响应性
- en: Initial application start up time
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序初始启动时间
- en: Remote requests such as load/save
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程请求，如加载/保存
- en: A slow application is a key source of user frustration and the first step to
    diagnosing any issues of this nature is to collect information.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 慢速应用程序是用户沮丧的关键来源，诊断此类问题的第一步是收集信息。
- en: Let's look at the various ways in which Chrome Developer Tools can help us and
    address common problems using Ext JS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Chrome开发者工具如何帮助我们以各种方式解决使用Ext JS的常见问题。
- en: Network performance
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络性能
- en: As we've seen in our examples, many Ext JS applications will communicate with
    a backend API service in order to read and write data. If user feedback shows
    that remote requests are unresponsive, we need to first diagnose the calls that
    are causing problems. Chrome can help us here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中所看到的，许多Ext JS应用程序将通过与后端API服务进行通信来读取和写入数据。如果用户反馈显示远程请求无响应，我们需要首先诊断导致问题的调用。Chrome在这里可以帮助我们。
- en: 'With the Developer Tools open, click on the **Network** tab and refresh the
    page. We get a list of all of the resources requested as the application loads;
    we can filter this by clicking on one of the headers at the top of the pane. Here''s
    the Alcohology application filtered to "XHR" or Ajax requests:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开开发者工具的情况下，点击**网络**选项卡并刷新页面。我们得到了应用程序加载时请求的所有资源的列表；我们可以通过点击面板顶部的其中一个标题来过滤这些资源。以下是过滤到“XHR”或Ajax请求的Alcohology应用程序：
- en: '![Network performance](img/5308OT_10_09.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![网络性能](img/5308OT_10_09.jpg)'
- en: Chrome Developer Tools with an Ajax request selected
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 已选择Ajax请求的Chrome开发者工具
- en: In this example, one of the requests has been selected and a breakdown of timing
    details in shown on the right-hand side. While the Alcohology application has
    a very fast response time, it serves as a good illustration of how to analyze
    network performance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，已经选择了一个请求，并在右侧显示了时间细节的分解。虽然Alcohology应用程序的响应时间非常快，但它很好地说明了如何分析网络性能。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More details about the **Network** panel can be found at [https://developer.chrome.com/devtools/docs/network](https://developer.chrome.com/devtools/docs/network).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于**网络**面板的详细信息可以在[https://developer.chrome.com/devtools/docs/network](https://developer.chrome.com/devtools/docs/network)找到。
- en: How does this help us? If the remote server is slow, then as frontend developers,
    there's not much we can do about this; other than keeping our remote requests
    to a minimum, we're stuck with what's available. Here's one example that we can
    act on in order to speed things up.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们有什么帮助？如果远程服务器很慢，那么作为前端开发者，我们对此无能为力；除了将我们的远程请求保持在最低限度外，我们只能接受现有的情况。以下是我们可以采取行动来加快速度的一个例子。
- en: Note the "stalled" entry in the timings. This is often caused due to the limit
    that browsers impose on the number of connections that can be active to one origin
    (such as a domain or subdomain) at a time. When this number is exceeded, the browser
    will block any new requests until a connection becomes available. This knowledge
    gives us several opportunities for optimization.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意“停滞”的条目在时间线中。这通常是由于浏览器对一次可以活跃到同一来源（如域名或子域名）的连接数所施加的限制。当这个数字超过时，浏览器将阻止任何新的请求，直到有连接可用。这种知识给我们提供了几个优化的机会。
- en: Make fewer requests
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少请求数量
- en: The no-brainer approach to this problem is to simply request fewer things from
    the server and Ext JS gives us several ways to do this. First up is a technique
    we used in the Alcohology app (use an icon font such as `FontAwesome` instead
    of image icons). This means that we'll only have to download one font file rather
    than multiple icon files. The `glyph` config on menu items and buttons gives us
    a really easy way to use this feature and negate the need to use bitmap images
    for icons.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是从服务器请求更少的东西，而Ext JS提供了几种方法来实现这一点。首先是一个我们在Alcohology应用中使用的技术（使用图标字体，如`FontAwesome`而不是图像图标）。这意味着我们只需要下载一个字体文件，而不是多个图标文件。菜单项和按钮上的`glyph`配置为我们提供了一个非常简单的方式来使用这个功能，并消除使用位图图像作为图标的需要。
- en: Next up is nested data. This is an approach that we used in the `Questionnaire`
    component, but one that needs to be used carefully. By setting up model associations,
    we can request data for the whole hierarchy and populate our data model all at
    once, rather than per mode type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是嵌套数据。这是我们用于`Questionnaire`组件的方法，但需要谨慎使用。通过设置模型关联，我们可以一次性请求整个层次结构的数据，并填充我们的数据模型，而不是按模式类型逐个请求。
- en: For example, for the `Questionnaire` component, we could have loaded the questionnaire,
    the steps, and the questions in three separate requests, but by bringing it all
    down at once, we avoided the two remote requests. There are two caveats to this
    idea; firstly, the server needs to support nested data; secondly, the size of
    the nested data maybe much larger and therefore result in a slower response time.
    Multiple separate requests might result in better perceived performance, so application
    of this concept strongly depends on the situation, speaking of the perception
    of performance, and so on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于`Questionnaire`组件，我们本可以分别通过三个单独的请求加载问卷、步骤和问题，但通过一次性下载所有内容，我们避免了两次远程请求。这个想法有两个注意事项；首先，服务器需要支持嵌套数据；其次，嵌套数据的大小可能更大，因此可能导致更慢的响应时间。多个单独的请求可能会带来更好的感知性能，因此这个概念的应用强烈依赖于具体情况，比如性能感知等。
- en: Perceived performance
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 感知性能
- en: There are some cases in which we can't improve the load time of certain aspects
    of an application, for example, it could be report generation where the number
    crunching involved is a long-running operation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们无法提高应用程序某些方面的加载时间，例如，可能是报告生成，其中涉及的计算是一个长时间运行的操作。
- en: In these cases, we need to do what we can to improve the user's perception of
    performance and assure them that the action they're undertaking is underway and
    will finish soon.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要尽我们所能来提高用户对性能的认知，并确保他们正在执行的操作正在进行中，并且很快就会完成。
- en: 'In Ext JS, one key mechanism to do this is `Ext.LoadMask`. It''s used by Ext
    JS internally in several situations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS中，实现这一目标的一个关键机制是`Ext.LoadMask`。它在Ext JS内部在几种情况下被使用：
- en: '![Perceived performance](img/5308OT_10_10.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![感知性能](img/5308OT_10_10.jpg)'
- en: In the previous example from the Ext JS Kitchen Sink, a grid with a paging toolbar
    will automatically use `LoadMask` while waiting for the server to return the next
    page.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS Kitchen Sink的先前示例中，一个带有分页工具栏的网格在等待服务器返回下一页时会自动使用`LoadMask`。
- en: The advantage to the user is that while they have to wait, they're at least
    being told that they have to wait. Without `LoadMask`, they'd have hit a button
    and received no feedback that the server was thinking about the request.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，优点是他们虽然必须等待，但至少被告知他们必须等待。如果没有`LoadMask`，他们可能会点击按钮，但不会收到服务器正在考虑请求的任何反馈。
- en: We can leverage `LoadMask` in our own code by creating a new instance when we
    need it, but it's more likely that we'd use it on an existing container and leverage
    the fact that many Ext JS components have `LoadMask` functionality baked in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在需要时创建一个新的实例来在我们的代码中利用`LoadMask`，但更有可能的是，我们会在现有的容器上使用它，并利用许多Ext JS组件内置的`LoadMask`功能。
- en: 'We can use event domains, which we discussed back in [Chapter 2](ch02.html
    "Chapter 2. MVC and MVVM"), *MVC and MVVM*, as one way of hooking into remote
    requests and masking our components:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用事件域，这是我们之前在[第2章](ch02.html "第2章。MVC和MVVM")中讨论的，作为钩入远程请求和屏蔽我们组件的一种方式：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this code snippet that we added to the `ProductController` on Alcohology,
    we tell the `listen` config to watch out for `beforeload` and `load` events on
    the products store. The listener can use the "products" alias that we'd already
    set up on the products `store` class. When the `beforeload` event fires, we grab
    the product list view and call its mask method to show its `LoadMask`. When the
    server response returns and the `load` event fires, we call the mask method with
    the false argument to hide it again.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加到Alcohology的`ProductController`的这段代码中，我们告诉`listen`配置监视产品存储上的`beforeload`和`load`事件。监听器可以使用我们在产品`store`类上已经设置好的“products”别名。当`beforeload`事件触发时，我们获取产品列表视图并调用其mask方法来显示其`LoadMask`。当服务器响应返回并且`load`事件触发时，我们使用false参数调用mask方法来再次隐藏它。
- en: It's a simple and an unobtrusive way to wire up the loading mechanism and give
    the user that all-important feedback, showing that their actions have triggered
    an effect.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单且不引人注目的方法来连接加载机制，并给用户提供至关重要的反馈，显示他们的操作已经触发了效果。
- en: Load less
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载较少
- en: One very simple way to speed up the response of Ajax requests is to simply request
    less stuff! If the server supports paging, then any component powered by a store
    can immediately become more performant by requesting a single page of data rather
    than pulling it down all at once.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常简单的方法来加快Ajax请求的响应速度是请求更少的东西！如果服务器支持分页，那么任何由存储支持的组件都可以通过请求单页数据而不是一次性拉取数据来立即提高性能。
- en: '`Ext.PagingToolbar` can be linked to a store and placed anywhere in an application
    to provide a pagination UI:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.PagingToolbar`可以链接到存储并在应用程序的任何位置放置，以提供分页UI：'
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, for example, is how we''d begin to add a paging toolbar to the Alcohology
    application''s product list view. It automatically takes on touch-friendly styling
    from the theme we used:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是我们在Alcohology应用程序的产品列表视图中添加分页工具栏的开始。它自动采用我们使用的主题的触摸友好样式：
- en: '![Load less](img/5308OT_10_11.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![加载较少](img/5308OT_10_11.jpg)'
- en: Alcohology's product list complete with paging toolbar
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Alcohology的产品列表，包括分页工具栏
- en: A more advanced version of this technique involves using the `Ext.data.reader.Reader.metaData`
    property or the `Ext.data.proxy.Proxy.metachange` event. This can be used to pass
    data from the server to the client, which is in turn used to configure the Ext
    JS application; a common example is to allow the server to specify the columns
    that a grid contains when it first loads.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的更高级版本涉及使用`Ext.data.reader.Reader.metaData`属性或`Ext.data.proxy.Proxy.metachange`事件。这可以用来从服务器传递数据到客户端，然后用于配置Ext
    JS应用程序；一个常见的例子是允许服务器在首次加载时指定网格包含的列。
- en: This could mean that on initial load, the server omits a field and matching
    grid column, such as a description, which may contain a lot of data. The user
    could customize the grid via the column header UI to show it when they need it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能意味着在初始加载时，服务器省略了一个字段和匹配的网格列，例如描述，这可能包含大量数据。用户可以通过列标题UI自定义网格，在他们需要时显示它。
- en: Optimistic updating
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乐观更新
- en: 'When saving a record to the server, we''d normally see the following actions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当将记录保存到服务器时，我们通常会看到以下操作：
- en: User clicks a button to save the record
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击按钮保存记录
- en: Ext JS displays a "saving" message
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS显示“正在保存”消息
- en: Save completes and a "success" message is displayed
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存完成并显示“成功”消息
- en: 'In some situations though, we can trust that the server is going to save successfully
    and cut the actions down to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们可以相信服务器将成功保存，并将操作简化为以下内容：
- en: User clicks on a button to save the record
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击按钮保存记录
- en: Save proceeds and a "saved" message is displayed
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存进行并显示“已保存”消息
- en: In this case, the save action happens entirely in the background and doesn't
    block the user from performing other actions. You can see this kind of behavior
    in many e-mail applications with the server interaction happening behind the scenes
    and an "outbox" to store messages that fail to send on the first try.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，保存操作完全在后台进行，不会阻止用户执行其他操作。您可以在许多电子邮件应用程序中看到这种行为，服务器交互在幕后进行，并且有一个“发件箱”来存储第一次尝试发送失败的消息。
- en: In the event that the server does raise some kind of error, we can display a
    failure message and rollback the changes that the user performed. The Ext JS grid
    includes UI to do this; it will highlight changed values with a red marker that
    can be cleared when we're sure the record has been successfully committed to the
    server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器确实抛出某种错误，我们可以显示一个错误消息并回滚用户所做的更改。Ext JS 网格包括用于此目的的 UI；它将以红色标记突出显示更改的值，当我们确信记录已成功提交到服务器时可以清除这些标记。
- en: This is an advanced technique that requires extra UI design work, but it can
    immeasurably improve your user experience.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要额外 UI 设计工作的高级技术，但它可以极大地改善用户体验。
- en: Quick on the draw
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速反应
- en: 'In addition to ensuring that the way our application interacts with the server
    is always done in a timely fashion, we also need to be concerned with the speed
    at which the user interface renders and how quickly the browser draws the UI.
    There are a number of common pitfalls with Ext JS in this regard:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保我们的应用程序与服务器交互的方式始终及时外，我们还需要关注用户界面的渲染速度以及浏览器绘制 UI 的速度。在这一点上，Ext JS 存在一些常见的陷阱：
- en: Overuse of panels
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过度使用面板
- en: Panels have several features such as a header containing tool icons, the ability
    to be draggable, collapsible, and have docked items. In many situations, these
    features just aren't required. In this situation, a container is a much better
    choice. It's more lightweight in memory and the markup it generates.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 面板具有一些功能，例如包含工具图标的标题、可拖动、可折叠以及具有停靠项的能力。在许多情况下，这些功能根本不是必需的。在这种情况下，容器是一个更好的选择。它在内存中更轻量级，并且它生成的标记也更少。
- en: Overnesting
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过度嵌套
- en: Overnesting of containers and panels, particularly those implementing border
    layouts, are a very common source of performance issues, particularly if the user
    needs to move between various screens containing over-nested components. Ext JS
    needs to perform lots of calculations to build a viewport and the layout process
    is particularly expensive. Every time we find ourselves adding a new component
    to the hierarchy, it should cause us to stop and re-evaluate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和面板的过度嵌套，尤其是那些实现边框布局的，是性能问题的一个非常常见来源，尤其是当用户需要在包含过度嵌套组件的各种屏幕之间移动时。Ext JS 需要进行大量的计算来构建视口，布局过程尤其昂贵。每次我们发现自己在层次结构中添加一个新的组件时，都应该让我们停下来重新评估。
- en: We also need to think about how a deep hierarchy could affect cases in which
    we are querying our component structure. With a more complex component tree and
    a more complicated DOM, any operations to fetch either components or elements
    from the application will be slower. In many cases, this slowdown will be marginal;
    in some cases, it'll be a critical consideration when improving your application's
    performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑一个深层层次结构可能如何影响我们查询组件结构的情况。随着组件树变得更加复杂和 DOM 更加复杂，从应用程序中获取组件或元素的操作将会变慢。在许多情况下，这种减速将是微不足道的；在某些情况下，当提高应用程序性能时，它将是一个关键的考虑因素。
- en: Deferred rendering
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟渲染
- en: When creating a container or panel with a card layout, by default the layout
    will immediate render all components within each card. This is usually unnecessary
    because the user will only see the first card to begin with. Instead, we can use
    the `deferredRender` configuration option on the card layout to render items only
    when their parent card becomes active. This reduces the initial render time, therefore,
    the time until the application can respond to user input.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建具有卡片布局的容器或面板时，默认情况下，布局将立即渲染每个卡片内的所有组件。这通常是不必要的，因为用户一开始只会看到第一张卡片。相反，我们可以使用卡片布局上的
    `deferredRender` 配置选项，仅在父卡片变为活动状态时渲染项目。这减少了初始渲染时间，因此，直到应用程序可以响应用户输入的时间。
- en: Another similar approach involves grids. Ext JS allows you to load a large server
    response into a store and attempts to display it on a grid, but in situation with
    thousands of records, the store causes memory usage to balloon and the browser
    will struggle to keep things smooth with such a large number of DOM nodes making
    up the grid rows.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类似的方法涉及网格。Ext JS 允许你将大量的服务器响应加载到存储中，并尝试在网格上显示它，但在有数千条记录的情况下，存储会导致内存使用激增，浏览器将难以保持如此大量
    DOM 节点组成的网格行的流畅性。
- en: The solution is to swap out a standard store for `Ext.data.BufferedStore`. This
    uses an enhanced paging mechanism to preload pages of data in advance. Meanwhile,
    the grid will automatically use `Ext.grid.plugin.BufferedRenderer` and as the
    user scrolls through the grid entries, the backing `BufferedStore` will automatically
    load in new pages of data while removing old pages. It does this seamlessly, so
    the user has no idea that the rows are being loaded from the server on the fly.
    The `BufferedRenderer` will also dispose of DOM nodes from old nodes as they scroll
    past, removing the memory burden of such a large amount of data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是替换为`Ext.data.BufferedStore`标准存储。这使用增强的分页机制预先加载数据页。同时，网格将自动使用`Ext.grid.plugin.BufferedRenderer`，当用户滚动网格条目时，后端的`BufferedStore`将自动加载新页面数据，同时删除旧页面。它这样做无缝，因此用户不会意识到行是从服务器即时加载的。`BufferedRenderer`还会在它们滚动过去时销毁旧节点中的DOM节点，从而减轻大量数据的内存负担。
- en: All of these techniques have their place. They are also useful tools to be aware
    of at the start of the architecture process. If a client asks whether the application
    can handle 10,000 records in a datagrid, we now know that a buffered store can
    deliver the goods. On the flipside, we need to be conscious of premature optimization;
    there's no point implementing a buffered store when we're only dealing with a
    handful of records.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都有其位置。它们也是架构过程开始时需要了解的有用工具。如果客户询问应用程序是否可以处理数据网格中的10,000条记录，我们现在知道缓冲存储可以提供所需的功能。另一方面，我们需要意识到过早优化；当我们只处理少量记录时，实现缓冲存储是没有意义的。
- en: Analyzing performance
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: Dealing with performance issues is initially a problem of intelligence gathering.
    There can be multiple reasons why an application feels slow, and the feedback
    of users often doesn't help. Describing a part of the app as "sticky" just isn't
    a great way to diagnose the root cause. We need to get firm facts and figures
    in front of us before we can hope to find a solution. While we'll look at metrics
    such as rendering and response times, there are many considerations that must
    be taken into account, such as memory usage and user perception. These topics
    are left as an exercise for the reader.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 处理性能问题最初是一个情报收集的问题。应用程序感觉缓慢可能有多个原因，用户的反馈往往无助于解决问题。将应用程序的一部分描述为“粘性”并不是诊断根本原因的好方法。在我们希望找到解决方案之前，我们需要将确凿的事实和数字摆在我们面前。虽然我们将查看渲染和响应时间等指标，但必须考虑许多因素，例如内存使用和用户感知。这些主题留作读者练习。
- en: 'The Chrome Developer Tools come to the rescue again. This time, we''ll look
    at two main features that help diagnose performance problems: profiles and the
    timeline.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 开发者工具再次伸出援手。这次，我们将探讨两个有助于诊断性能问题的主要功能：配置文件和时序图。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In general, there are two situations in which Ext JS applications feel slow:
    poor design decisions and over-complicated apps. Having said that, these techniques
    are invaluable when the problem does crop up and are applicable to any JavaScript
    technology.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当Ext JS应用程序感觉缓慢时，有两种情况：糟糕的设计决策和过度复杂的应用程序。话虽如此，当问题出现时，这些技术非常有价值，并且适用于任何JavaScript技术。
- en: 'The profiler can be found by bringing up the Developer Tools and selecting
    the **Profiles** tab:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过打开开发者工具并选择**配置文件**选项卡来找到分析器：
- en: '![Analyzing performance](img/5308OT_10_12.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![性能分析](img/5308OT_10_12.jpg)'
- en: 'While there are several types of profiles that can be issued, we''ll take a
    look at the CPU profile. In the preceding screenshot, we''d click on **Start**
    to immediately begin profiling. Here''s a look at what happens when you click
    on a product in Alcohology:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以发出多种类型的配置文件，但我们将查看CPU配置文件。在前面的屏幕截图中，我们会点击**开始**立即开始分析。以下是在Alcohology中点击产品时发生的情况：
- en: '![Analyzing performance](img/5308OT_10_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![性能分析](img/5308OT_10_13.jpg)'
- en: The grid is ordered with the most time-consuming function calls at the top and
    each line can be expanded so that we can see the functions that were called in
    turn. The **Self** column shows the percentage of time spent in just that function's
    body; the **Total** column shows the time spent in that function as well as all
    of the functions it called.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 网格按耗时最长的函数调用从上到下排序，并且每一行都可以展开，以便我们可以看到依次调用的函数。**Self**列显示在该函数体内花费的时间百分比；**Total**列显示该函数以及它调用的所有函数所花费的时间。
- en: While this part of the Alcohology application is performing just fine, this
    simple view of the heavily-used parts of code is a key avenue to diagnose serious
    performance problems. However, we can do more.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Alcohology应用的这部分运行得很好，但这个简单查看代码中频繁使用部分的视图是诊断严重性能问题的关键途径。然而，我们还能做更多。
- en: We've used Chrome Developer Tools to evaluate the performance of remote requests
    and now we've used them to track down hotspots in our code. What about a single
    view that could help us track the general behavior of our application and help
    us visualize the types of interactions that are slowing things down? This is exactly
    what the **Timeline** tab offers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用Chrome开发者工具评估了远程请求的性能，现在我们使用它们来追踪代码中的热点。那么，有没有一个单一的视图可以帮助我们跟踪应用程序的一般行为，并帮助我们可视化那些减慢事情进展的交互类型？这正是**时间线**标签提供的。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a whistle-stop tour of **Timeline**. Refer to [https://developer.chrome.com/devtools/docs/timeline](https://developer.chrome.com/devtools/docs/timeline)
    for more details and full documentation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对**时间线**的快速浏览。有关更多详细信息及完整文档，请参阅[https://developer.chrome.com/devtools/docs/timeline](https://developer.chrome.com/devtools/docs/timeline)。
- en: 'By selecting the **Timeline** tab and clicking on the **Record** button, Chrome
    immediately begins recording every event currently taking place on the page. Clicking
    on **Record** again allows you to analyze the results:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择**时间线**标签并点击**记录**按钮，Chrome会立即开始记录页面上当前发生的每个事件。再次点击**记录**按钮，您可以分析结果：
- en: '![Analyzing performance](img/5308OT_10_14.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![分析性能](img/5308OT_10_14.jpg)'
- en: Timeline allows you to filter down a timeframe of events and view each in turn,
    from user clicks to Ajax requests to URL changes and browser repaints. From the
    first event, we can trace down each subsequent event, viewing stack traces, detailed
    timings and warnings regarding problematic behavior.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线允许您筛选事件的时间范围，并依次查看每个事件，从用户点击到Ajax请求，再到URL更改和浏览器重绘。从第一个事件开始，我们可以追踪每个后续事件，查看堆栈跟踪、详细的计时和有关问题行为的警告。
- en: Timeline is a powerful tool and you will need time and experience to use it
    to the fullest. It's time well spent; it can reveal clues that would be difficult
    or impossible to discover any other way. These clues can help resolve problems
    that would otherwise take days to tackle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线是一个强大的工具，您需要时间和经验才能充分利用它。这是值得花费的时间；它可以揭示其他方式难以或无法发现的线索。这些线索可以帮助解决其他方式可能需要几天时间才能解决的问题。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter has given us a number of angles to approach two of the most important
    parts of building a successful application: fixing issues and adding polish. While
    explicit customer requirements form the main body of our work, we should always
    strive to make sure that our projects are performant and as bug-free as possible.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了多个角度来处理构建成功应用的两个最重要的部分：解决问题和添加润色。虽然明确的客户需求构成了我们工作的主体，但我们始终应努力确保我们的项目性能良好，尽可能无错误。
- en: The Chrome Developer Tools are an invaluable weapon in our arsenal. By opening
    a window in the otherwise dark world of debugging and performance, we can take
    educated steps to quickly resolve issues. Stepping through our own code and that
    of the Ext JS framework becomes significantly easier with the power of breakpoints
    and the call stack explorer.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具是我们武器库中的无价之宝。通过在调试和性能的黑暗世界中打开一个窗口，我们可以采取有针对性的步骤来快速解决问题。利用断点和调用堆栈探索器的力量，我们可以更容易地逐步执行我们的代码以及Ext
    JS框架的代码。
- en: In the next chapter, we'll take our final step to building a well-rounded and
    robust application. While we are constantly working to build the best architecture
    we can, automated testing can provide a level of reassurance that takes the solidity
    of our work to the next level.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将迈出构建全面且稳健应用的最后一步。虽然我们一直在努力构建最佳架构，但自动化测试可以提供一种保证，将我们工作的稳定性提升到新的水平。
- en: Code changes and refactoring can be done with confidence when our test suite
    can tell us if we've broken something with our latest amendments. Integration
    tests can provide assurances that our final application meets customer requirements
    and unit tests can encourage separation of code and ensure that our business logic
    is sound.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的测试套件能够告诉我们是否因最新的修改而破坏了某些内容时，我们可以有信心地进行代码更改和重构。集成测试可以确保我们的最终应用满足客户需求，单元测试可以鼓励代码分离并确保我们的业务逻辑正确。
- en: In the next chapter, we'll look into a variety of ways to implement these ideas
    and more.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨多种实现这些想法及更多内容的方法。
