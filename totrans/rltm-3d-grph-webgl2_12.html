<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Journey Ahead</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this book, we have covered the foundational concepts, techniques, and resources required to build interactive 3D web applications with WebGL 2. Now that you're on your way to becoming a computer graphics expert, the resources in this final chapter are dedicated to helping you on that journey.</p>
<p class="mce-root">In this concluding chapter, you will do the following:</p>
<ul>
<li>Cover WebGL libraries of various sizes and capabilities.</li>
<li>Investigate strategies for testing WebGL applications.</li>
<li>Learn about 3D reconstruction.</li>
<li>Explore the power of physically-based rendering.</li>
<li>Meet various graphics communities.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebGL Libraries</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before we dive into various WebGL libraries, we should first define what a software library is. Although <strong>library</strong> and <strong>framework</strong> are often used interchangeably, they refer to <em>different</em> concepts in computer science. A software library comprises defined code, configuration, documentation, classes, scripts, and more, so that developers may include them in their programs to enhance their products. For example, in developing a program requiring extensive mathematical operations, a developer may include a suitable software library (for example, <kbd>glMatrix</kbd>) to reduce the need for writing those operations themselves.</p>
<p class="mce-root">That being said, as you may have noticed, we've built our 3D application in such a way that the classes, utilities, and overall architecture could, eventually, be turned into a library. This process was done intentionally so that we could learn concepts in isolation and also write code that could eventually comprise a feature-rich WebGL library that can be used by other applications.</p>
<p class="mce-root">That being said, it's important to know when and where to use libraries, so let's cover a few WebGL libraries of various sizes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Small Libraries</h1>
                </header>
            
            <article>
                
<p>Here are a few examples of small, non-prescriptive WebGL libraries that provide many helpers, utilities, and abstraction layers over WebGL's low-level API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TWGL</h1>
                </header>
            
            <article>
                
<p><strong>TWGL</strong> (<a href="https://github.com/greggman/twgl.js">https://github.com/greggman/twgl.js</a>) is an open-source WebGL library that serves to "<span><em>make using the WebGL API less verbose</em>". For example, here's a simple TWGL demo that shows its intelligible, yet low-level, API on top of WebGL:</span></p>
<pre><span>const<br/></span><span>  </span>canvas = document.<span>getElementById</span>(<span>'webgl-canvas'</span>)<span>,<br/></span><span>  </span>gl = canvas.<span>getContext</span>(<span>'webgl'</span>)<span>,<br/></span><span>  </span>program = twgl.createProgramInfo(gl<span>, </span>[<span>'vertex-shader'</span><span>, </span><span>'fragment-shader'</span>])<span>,<br/></span><span>  </span>arrays = {<br/>    <span>position</span>: [<br/>      -<span>1</span><span>, </span>-<span>1</span><span>, </span><span>0</span><span>,<br/></span><span>      </span><span>1</span><span>, </span>-<span>1</span><span>, </span><span>0</span><span>,<br/></span><span>      </span>-<span>1</span><span>, </span><span>1</span><span>, </span><span>0</span><span>,<br/></span><span>      </span>-<span>1</span><span>, </span><span>1</span><span>, </span><span>0</span><span>,<br/></span><span>      </span><span>1</span><span>, </span>-<span>1</span><span>, </span><span>0</span><span>,<br/></span><span>      </span><span>1</span><span>, </span><span>1</span><span>, </span><span>0<br/></span><span>    </span>]<span>,<br/></span><span>  </span>}<span>,<br/></span><span>  </span>bufferInfo = twgl.createBufferInfoFromArrays(gl<span>, </span>arrays)<span>;<br/></span><span><br/></span><span>function </span><span>draw</span>(time) {<br/>  <span>const </span>{ <span>width</span><span>, </span><span>height </span>} = gl.<span>canvas</span><span>;<br/></span><span><br/></span><span>  </span>twgl.resizeCanvasToDisplaySize(gl.<span>canvas</span>)<span>;<br/></span><span>  </span>gl.<span>viewport</span>(<span>0</span><span>, </span><span>0</span><span>, </span><span>width</span><span>, </span><span>height</span>)<span>;<br/></span><span><br/></span><span>  </span><span>const </span>uniforms = {<br/>    <span>time</span>: time * <span>0.001</span><span>,<br/></span><span>    </span><span>resolution</span>: [<span>width</span><span>, </span><span>height</span>]<span>,<br/></span><span>  </span>}<span>;<br/></span><span><br/></span><span>  </span>gl.<span>useProgram</span>(program.<span>program</span>)<span>;<br/></span><span><br/></span><span>  </span>twgl.setBuffersAndAttributes(gl<span>, </span>program<span>, </span>bufferInfo)<span>;<br/></span><span>  </span>twgl.setUniforms(program<span>, </span>uniforms)<span>;<br/></span><span>  </span>twgl.drawBufferInfo(gl<span>, </span>bufferInfo)<span>;<br/></span><span><br/></span><span>  </span><span>requestAnimationFrame</span>(<span>draw</span>)<span>;<br/></span>}<br/><br/><span>requestAnimationFrame</span>(<span>draw</span>)<span>;</span></pre>
<p>You can see the live demo on their GitHub page, which resembles the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c0b4a0d0-7e57-4002-9977-83c5d9d53ad5.png" style="width:39.58em;height:22.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regl</h1>
                </header>
            
            <article>
                
<p><strong>Regl</strong> (<a href="https://github.com/regl-project/regl">https://github.com/regl-project/regl</a>) is an open-source WebGL library with a functional flavor. As its documentation explains, Regl "<em>simplifies WebGL programming by removing as much shared state as it can get away with. To do this, it replaces the WebGL API with two fundamental abstractions,<span> </span><strong>resources</strong> and<span> </span><strong>commands</strong></em>". Here's the snippet of code that illustrates the functional Regl API:</p>
<pre><span>const </span>regl = require(<span>'regl'</span>)()<span>;<br/></span><span><br/></span><span>const </span>vertexShader = <span>`<br/></span><span>  precision mediump float;<br/></span><span><br/></span><span>  attribute vec2 position;<br/></span><span>    <br/></span><span>  void main(void) {<br/></span><span>    gl_Position = vec4(position, 0, 1);<br/></span><span>  }<br/></span><span>`</span><span>;<br/></span><span><br/></span><span>const </span>fragmentShader = <span>`<br/></span><span>  precision mediump float;<br/></span><span><br/></span><span>  uniform vec4 color;<br/></span><span><br/></span><span>  void main(void) {<br/></span><span>    gl_FragColor = color;<br/></span><span>  }<br/></span><span>`</span><span>;<br/></span><span><br/></span><span>const </span>drawTriangle = regl({<br/>  <span>vert</span>: vertexShader<span>,<br/></span><span>  </span><span>frag</span>: fragmentShader<span>,<br/></span><span>  </span><span>attributes</span>: {<br/>    <span>position</span>: regl.<span>buffer</span>([<br/>      [-<span>2</span><span>, </span>-<span>2</span>]<span>,<br/></span><span>      </span>[<span>4</span><span>, </span>-<span>2</span>]<span>,<br/></span><span>      </span>[<span>4</span><span>, </span><span>4</span>]<br/>    ])<br/>  }<span>,<br/></span><span>  </span><span>uniforms</span>: {<br/>    <span>color</span>: regl.<span>prop</span>(<span>'color'</span>)<br/>  }<span>,<br/></span><span>  </span><span>count</span>: <span>3<br/></span>})<span>;<br/></span><span><br/></span>regl.<span>frame</span>(({ time }) =&gt; {<br/>  <br/>  regl.<span>clear</span>({<br/>    <span>color</span>: [<span>1</span><span>, </span><span>1</span><span>, </span><span>1</span><span>, </span><span>1</span>]<span>,<br/></span><span>    </span><span>depth</span>: <span>1<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span>drawTriangle({<br/>    <span>color</span>: [<br/>      Math.<span>cos</span>(time * <span>0.001</span>)<span>,<br/></span><span>      </span>Math.<span>sin</span>(time * <span>0.0008</span>)<span>,<br/></span><span>      </span>Math.<span>cos</span>(time * <span>0.003</span>)<span>,<br/></span><span>      </span><span>1<br/></span><span>    </span>]<br/>  })<span>;<br/></span><span>  <br/></span>})<span>;</span></pre>
<p>You can see the live demo on their GitHub page, which resembles the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c8c1263a-a6bb-49b0-a9b1-d9f466f47869.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StackGL</h1>
                </header>
            
            <article>
                
<p><strong>StackGL</strong> (<a href="http://stack.gl/">http://stack.gl</a>) is an open source WebGL project with an interesting approach to building WebGL applications. Instead of being bundled as a single library, it's an ecosystem, comprised of many small, lean modules, inspired by the Unix philosophy.</p>
<div class="packt_infobox"><span class="packt_screen">Unix philosophy</span><strong><br/>
<br/></strong> The Unix mindset is a philosophical approach to writing minimalist, modular software, often expressed with the mantra "do one thing, and do it well!". For more information, please visit the following URL: <a href="https://en.wikipedia.org/wiki/Unix_philosophy">https://en.wikipedia.org/wiki/Unix_philosophy</a>.<strong><br/></strong></div>
<p>Unlike many 3D engines, StackGL emphasizes lean, modular code that is focused on writing shader code. That being said, be sure to visit their website, as it includes extensive documentation and demos that will help you master this approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Feature-Rich Libraries</h1>
                </header>
            
            <article>
                
<p>While small, lean, and modular WebGL libraries are useful, they may not be enough for complex applications. Here are several feature-rich WebGL libraries that offer an extensive list of features and capabilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Three.js</h1>
                </header>
            
            <article>
                
<p><strong>Three.js</strong> (<a href="https://github.com/mrdoob/three.js">https://github.com/mrdoob/three.js</a>) <span>is an open source library that powers many of the WebGL applications on the web. It aims to create an easy to use, lightweight, 3D library, with multiple renderers that target 2D <kbd>canvas</kbd>, WebGL, SVG, and CSS3D. </span>Here's a neat demo of a rotating cube, showcasing the simplicity of the Three.js API:</p>
<pre><span>let<br/></span><span>  </span>renderer<span>,<br/></span><span>  </span>scene<span>,<br/></span><span>  </span>camera<span>,<br/></span><span>  </span>mesh<span>,<br/></span><span>  </span>width = window.<span>innerWidth</span><span>,<br/></span><span>  </span>height = window.<span>innerHeight</span><span>;<br/></span><span><br/></span><span>function </span><span>init</span>() {<br/>  camera = <span>new </span>THREE.PerspectiveCamera(<span>70</span><span>, </span>width / height<span>, </span><span>0.01</span><span>, </span><span>10</span>)<span>;<br/></span><span>  </span>camera.<span>position</span>.<span>z </span>= <span>1</span><span>;<br/></span><span><br/></span><span>  </span>scene = <span>new </span>THREE.Scene()<span>;<br/></span><span><br/></span><span>  </span><span>const </span>mesh = <span>new </span>THREE.Mesh(<br/>    <span>// geometry<br/></span><span>    </span><span>new </span>THREE.BoxGeometry(<span>0.2</span><span>, </span><span>0.2</span><span>, </span><span>0.2</span>)<span>,<br/></span><span>    </span><span>// material<br/></span><span>    </span><span>new </span>THREE.MeshNormalMaterial()<br/>  )<span>;<br/></span><span>  </span>scene.<span>add</span>(mesh)<span>;<br/></span><span><br/></span><span>  </span>renderer = <span>new </span>THREE.WebGLRenderer({ <span>antialias</span>: <span>true </span>})<span>;<br/></span><span>  </span>renderer.setSize(width<span>, </span>height)<span>;<br/></span><span>  </span>document.<span>body</span>.<span>appendChild</span>(renderer.<span>domElement</span>)<span>;<br/></span>}<br/><br/><span>function </span><span>render</span>() {<br/>  <span>requestAnimationFrame</span>(<span>render</span>)<span>;<br/></span><span>  </span>mesh.<span>rotation</span>.<span>x </span>+= <span>0.01</span><span>;<br/></span><span>  </span>mesh.<span>rotation</span>.<span>y </span>+= <span>0.02</span><span>;<br/></span><span>  </span>renderer.render(scene<span>, </span>camera)<span>;<br/></span>}<br/><br/><span>init</span>()<span>;<br/></span><span>render</span>()<span>;</span></pre>
<p>You can see the live demo on their GitHub page, which resembles the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3895b6f4-3ce0-4b9a-bf70-85410f41a675.png" style="width:42.67em;height:24.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Babylon.js</h1>
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign"><span><strong>Babylon.js</strong> (</span><a href="https://github.com/mrdoob/three.js">https://github.com/mrdoob/three.js</a><span>) </span><span>is an open source WebGL library that came to fruition inside of Microsoft. It is a powerful library that was recently rewritten entirely in TypeScript.</span></p>
<div class="packt_infobox"><span class="packt_screen">TypeScript</span><strong><br/>
<br/></strong> <span>TypeScript is an open source language developed by Microsoft. It is a powerful language that is a strict syntactical superset of JavaScript and adds optional static typing to JavaScript.</span><span> For more information, visit <a href="https://github.com/Microsoft/TypeScript">https://github.com/Microsoft/TypeScript</a>.</span><strong><br/></strong></div>
<p>Although choosing Babylon.js doesn't require using TypeScript, it can be a major advantage over other libraries if you or your team prefer the features that TypeScript provides. <span>Here's an interesting JavaScript demo, showcasing the simple Babylon.js API:</span></p>
<pre><span>const </span>canvas = document.<span>getElementById</span>(<span>'webgl-canvas'</span>)<span>;<br/></span><span><br/></span><span>const </span>engine = <span>new </span>BABYLON.Engine(<br/>  canvas<span>,<br/></span><span>  </span><span>true</span><span>,<br/></span><span>  </span>{<br/>    <span>preserveDrawingBuffer</span>: <span>true</span><span>,<br/></span><span>    </span><span>stencil</span>: <span>true<br/></span><span>  </span>}<br/>)<span>;<br/></span><span><br/></span><span>function </span><span>initScene</span>() {<br/>  <span>const </span>scene = <span>new </span>BABYLON.Scene(engine)<span>;<br/></span><span><br/></span><span>  </span><span>const </span>camera = <span>new </span>BABYLON.FreeCamera(<span>'camera'</span><span>, </span><span>new </span>BABYLON.Vector3(<span>0</span><span>, </span><span>5</span><span>, <br/></span>   -<span>10</span>)<span>, </span>scene)<span>;<br/></span><span>  </span>camera.setTarget(BABYLON.Vector3.Zero())<span>;<br/></span><span>  </span>camera.attachControl(canvas<span>, </span><span>false</span>)<span>;<br/></span><span><br/></span><span>  </span><span>const </span>ground = BABYLON.Mesh.CreateGround(<span>'ground'</span><span>, </span><span>6</span><span>, </span><span>6</span><span>, </span><span>2</span><span>, </span>scene<span>, <br/></span><span>   false</span>)<span>;<br/></span><span><br/></span><span>  </span><span>const </span>sphere = BABYLON.Mesh.CreateSphere(<span>'sphere'</span><span>, </span><span>16</span><span>, </span><span>2</span><span>, </span>scene<span>, </span><span>false</span><span>, <br/></span>   BABYLON.Mesh.FRONTSIDE)<span>;<br/></span><span>  </span>sphere.<span>position</span>.<span>y </span>= <span>1</span><span>;<br/></span><span><br/></span><span>  </span><span>const </span>light = <span>new </span>BABYLON.HemisphericLight(<span>'light'</span><span>, </span><span>new <br/></span>   BABYLON.Vector3(<span>0</span><span>, </span><span>1</span><span>, </span><span>0</span>)<span>, </span>scene)<span>;<br/></span><span><br/></span><span>  </span><span>return </span>scene<span>;<br/></span>}<br/><br/><span>const </span>scene = <span>initScene</span>()<span>;<br/></span>engine.runRenderLoop(() =&gt; scene.render())<span>;</span></pre>
<p>You can see the live demo on their GitHub page, which resembles the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1702a52c-6226-4c6a-8df2-fe558719fb60.png" style="width:33.00em;height:20.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A-Frame</h1>
                </header>
            
            <article>
                
<p><strong>A-Frame</strong> (<a href="https://github.com/aframevr/aframe">https://github.com/aframevr/aframe</a>) is an open-source web framework for building virtual reality (VR) experiences. It is primarily maintained by Mozilla and the WebVR community. Although other WebGL libraries, such as Three.js and Babylon.js, offer VR support, A-Frame was designed entirely for building VR applications for the web.</p>
<div class="packt_infobox"><strong><span class="packt_screen">A-Frame Core</span><br/>
<br/></strong> Although A-Frame is an entirely new project, it is built on top of the Three.js game engine.</div>
<p><span>Here's a demo showcasing the A-Frame's declarative API:</span></p>
<pre><span>&lt;!DOCTYPE </span><span>html</span><span>&gt;<br/></span><span>&lt;html&gt;<br/></span><span>&lt;head&gt;<br/></span><span>  &lt;title&gt;</span>Hello, WebVR! - A-Frame<span>&lt;/title&gt;<br/></span><span>  &lt;meta </span><span>name=</span><span>"description" </span><span>content=</span><span>"Hello, WebVR! - A-Frame"</span><span>&gt;<br/></span><span>  &lt;script </span><span>src=</span><span>"https://aframe.io/releases/0.8.2/aframe.min.js"</span><span>&gt;&lt;/script&gt;<br/></span><span>&lt;/head&gt;<br/></span><span>&lt;body&gt;<br/></span><span>&lt;a-scene&gt;<br/></span><span>  &lt;a-box </span><span>position=</span><span>"-1 0.5 -3" </span><span>rotation=</span><span>"0 45 0" </span><span>color=</span><span>"#4CC3D9" </span><span>shadow</span><span>&gt;<br/>  &lt;/a-box&gt;<br/></span><span>  &lt;a-sphere </span><span>position=</span><span>"0 1.25 -5" </span><span>radius=</span><span>"1.25" </span><span>color=</span><span>"#EF2D5E" </span><span>shadow</span><span>&gt;<br/>  &lt;/a-sphere&gt;<br/></span><span>  &lt;a-cylinder </span><span>position=</span><span>"1 0.75 -3" </span><span>radius=</span><span>"0.5" </span><span>height=</span><span>"1.5" <br/></span><span>   color=</span><span>"#FFC65D" </span><span>shadow</span><span>&gt;&lt;/a-cylinder&gt;<br/></span><span>  &lt;a-plane </span><span>position=</span><span>"0 0 -4" </span><span>rotation=</span><span>"-90 0 0" </span><span>width=</span><span>"4" </span><span>height=</span><span>"4" <br/></span><span>   color=</span><span>"#7BC8A4" </span><span>shadow</span><span>&gt;&lt;/a-plane&gt;<br/></span><span>  &lt;a-sky </span><span>color=</span><span>"#ECECEC"</span><span>&gt;&lt;/a-sky&gt;<br/></span><span>&lt;/a-scene&gt;<br/></span><span>&lt;/body&gt;<br/></span><span>&lt;/html&gt;</span></pre>
<p>You can see the live demo on their GitHub page, which resembles the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9c40dbc3-8d84-4d5b-b29f-c7637f975221.png" style="width:35.50em;height:19.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Game Engines</h1>
                </header>
            
            <article>
                
<p>Another approach to building complex 3D applications is to use an established game engine. A game engine is a software development <span>environment</span> designed so that people can build complex 3D applications. Although developers use 3D engines to create games for consoles, mobile devices, and personal computers, they can also be used to build interactive web applications. Two powerful game engines that you can use in building complex WebGL applications are Unity and PlayCanvas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unity</h1>
                </header>
            
            <article>
                
<p><span><strong>Unity</strong> (<a href="https://unity3d.com">https://unity3D.com</a>) is a portable game engine developed by Unity Technologies that offers cross-platform capabilities. It was first announced and released in June 2005 at the Apple Inc. Worldwide Developers Conference as an OS X-exclusive game engine. Over the years, it has become the leading game engine for delivering some of the most well-known games across diverse platforms. Although Unity prioritizes native over web-based outputs, it does offer WebGL support:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bb5f5311-2d9d-4f91-ad52-41bdc1e36b2e.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PlayCanvas</h1>
                </header>
            
            <article>
                
<p><strong>PlayCanvas</strong> (<a href="https://playcanvas.com/">https://playcanvas.com</a>) is an open source 3D game engine that also offers a proprietary cloud-hosted creation platform. Although other game engines, such as Unity, offer WebGL support, PlayCanvas was built from the ground-up for the web. Additionally, PlayCanvas offers a <span>wonderful</span> development experience since it has many powerful features, such as a visual workspace, full WebGL 2 support, simultaneous editing from multiple computers, and more:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/452bd9d3-1a44-4fec-9ca8-0b7747c26161.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing WebGL 2 Applications</h1>
                </header>
            
            <article>
                
<p>If you happened to open your browser's debugger tools throughout this book, you may have noticed that the <kbd>canvas</kbd> you saw was a complete "black box". That is, you <span>cannot</span> inspect any of its elements as you could with the DOM elements on a web page. If you come from a traditional web-development background, this may seem like a big problem, since we're used to leveraging the DOM to help us query elements to test our application. So, how can we ensure the quality and stability of our WebGL applications?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visual Regression Testing</h1>
                </header>
            
            <article>
                
<p>Image comparisons of <span>various</span> application states throughout the development cycle is a common approach for testing WebGL applications. This technique, often <span>referred</span> to as <strong>visual regression testing</strong>, performs front-end or user-interface regression testing by capturing the screenshots of web pages/UI and comparing them with the original images (either historical baseline screenshots or reference images from a live website):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/497212fa-0ccd-4cda-9853-6e16eadb74cb.png"/></p>
<p>In the previous screenshot, you can see how the <span class="packt_screen">Baseline </span>and <span class="packt_screen">Change </span>are different via the final <span class="packt_screen">Diff</span> output. This technique can be an effective approach for ensuring that your WebGL application continues to behave as expected.</p>
<div class="packt_infobox"><span class="packt_screen">Visual Regression Testing Tools</span><strong><br/>
<br/></strong> <span>Given your language of choice, you can find many open source visual regression testing tools that fit your technology stack on GitHub (<a href="https://github.com/search?q=visual+regression">https://github.com/search?q=visual+regression</a>).</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application Introspection Testing</h1>
                </header>
            
            <article>
                
<p>Another approach is to <span>mimic</span> the DOM API by <span>exposing</span> your WebGL elements via a custom API. For example, if we want to query a DOM element by its ID, we would do so via <kbd>document.getElementById('element-id')</kbd>. We could do the same with jQuery's simpler API via <kbd>$('#element-id')</kbd>.</p>
<div class="packt_infobox"><span class="packt_screen">jQuery</span><strong><br/>
<br/></strong> <span>jQuery is a JavaScript library designed to simplify many of the common client-side scripting operations that are available. It is a free, open source software that uses the permissive MIT License. For more information, please visit <a href="https://jquery.com">https://jquery.com</a>.</span></div>
<p>To see an implementation of this approach, please <span>refer</span> to <strong>Three Musketeers</strong> (<a href="https://github.com/webgl/three-musketeer">https://github.com/webgl/three-musketeer</a>), an open source library, which can be included in <em>any</em> Three.js application with a single line of code. By including <kbd>three-musketeers</kbd>, we can run a variety of queries on elements in our scene, similar to DOM elements in a web page. Here are some sample queries for further illustration:</p>
<div class="highlight highlight-source-js">
<pre>$$$.<span class="pl-en">debug</span>();</pre>
<p><span class="pl-c"><kbd>$$$</kbd> is an alias for a <kbd>three-musketeers</kbd> instance. The <kbd>debug</kbd> method enables visual debugging mode:</span></p>
<pre>$$$<br/>.<span class="pl-c1">find</span><span>(</span><span class="pl-s"><span class="pl-pds">'</span>Cube_1<span class="pl-pds">'</span></span><span>)</span><span class="pl-c"><br/></span>.exists<span>();<br/></span><span class="pl-c">// returns true<br/></span></pre>
<p><span class="pl-c">The <kbd>find</kbd> method searches the scene for an item with the ID of <kbd>Cube_1</kbd>. By calling <kbd>exists</kbd>, it returns a Boolean on whether it exists:</span></p>
<pre>$$$<br/>.<span class="pl-en">findAll</span><span>((</span><span class="pl-smi">node</span><span>) </span><span class="pl-k">=&gt;</span><span> </span><span class="pl-smi">node</span><span>.</span><span class="pl-smi">geometry</span><span>.</span><span class="pl-c1">type</span><span> </span><span class="pl-k">===</span><span> </span><span class="pl-s"><span class="pl-pds">'</span>BoxGeometry<span class="pl-pds">'</span></span><span>);<br/></span></pre>
<p><span class="pl-c">Similar to <kbd>find</kbd>, <kbd>findAll</kbd> returns an array of items. In this case, instead of searching for a unique ID, we're looking for all of the geometries that match the <kbd>BoxGeometry</kbd> type:</span></p>
<pre>$$$<br/>.<span class="pl-c1">find</span><span>(</span><span class="pl-s"><span class="pl-pds">'</span>Cube_1<span class="pl-pds">'</span></span><span>)<br/></span>.<span class="pl-c1">click</span><span>();<br/></span></pre>
<p>We find the geometry with the unique ID, <kbd>Cube_1</kbd>, and trigger a mouse click event on the <em>appropriate</em> coordinates:</p>
<pre>window<span>.</span><span class="pl-c1">addEventListener</span><span>(</span><span class="pl-s"><span class="pl-pds">'</span>click<span class="pl-pds">'</span></span><span>, (</span><span class="pl-c1">event</span><span>) </span><span class="pl-k">=&gt;</span><span> {<br/></span> const<span> </span><span class="pl-c1">intersectedItems</span><span> </span><span class="pl-k">=</span><span> </span><span class="pl-smi">$$$</span><span>.</span><span class="pl-en">pickFromEvent</span><span>(</span><span class="pl-c1">event</span><span>);<br/></span> console<span>.</span><span class="pl-c1">log</span><span>(intersectedItems);<br/></span>});</pre>
<p>This is a simple technique that's very helpful for debugging. Every time we click in our web page, we log all intersected geometries, given the mouse click's 2D coordinates mapped onto our 3D scene.</p>
</div>
<p>For more information, be <span>sure</span> to check out <kbd>three-musketeers</kbd> on GitHub (<a href="https://github.com/webgl/three-musketeers">https://github.com/webgl/three-musketeers</a>) or its documentation (<a href="https://webgl.github.io/three-musketeers">https://webgl.github.io/three-musketeers</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">3D Reconstruction</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we <span>either</span> constructed our own geometries or imported models that have been created in 3D modeling tools, such as Maya or Blender. Although these are common approaches for building 3D assets, they require manual labor to create them. Are there other techniques for getting geometries? Yes, of course! <strong>3D reconstruction</strong> is the process of creating 3D models from images. It is the reverse process of obtaining 2D images from 3D scenes. Here's an example of a 3D model that has been generated purely from aerial photographs by a technique called Photogrammetry:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/03ed1032-51a4-43f3-a709-b6e1b15fc530.png" style="width:40.50em;height:21.50em;"/></p>
<div class="packt_infobox"><span class="packt_screen">Photogrammetry</span><br/>
<br/>
Photogrammetry<span> </span>is the science of making spatial measuring from photographs. This is a powerful technique for recovering the exact positions of surface points. For more information, please visit <a href="https://en.wikipedia.org/wiki/Photogrammetry">https://en.wikipedia.org/wiki/Photogrammetry</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Physically-Based Rendering</h1>
                </header>
            
            <article>
                
<p>In <a href="0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml" target="_blank">Chapter 3</a>, <em>Lights</em>, we learned how to illuminate our scene by mimicking light. We did so by leveraging various shading and light reflection <span>techniques</span> that use two main components: specular and diffuse. Although we've been modeling materials with specular and diffuse in computer graphics for a long time, these techniques produce results that are not very realistic. For example, changing the specularity of a material doesn't change the diffuse:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/87673064-c2cb-4076-b77b-ec9b248335fc.png" style="width:34.58em;height:25.92em;"/></p>
<p>The preceding screenshot demonstrates that changing the two parameters of specular intensity and specular hardness only changes the whitish part of the reflection. The blue diffuse reflection doesn't change at all—that's not how our physical world works! So, in applications aiming for more realistic effects, an artist would be tasked with manually tuning these values for each <span>material</span> until it "looked right", which is an inefficient method at best. There has to be a better way!</p>
<p class="mce-root">Enter <strong>Physically-Based Rendering</strong> (<strong>PBR</strong>), an approach to validate our material descriptions in the more objective, measurable, and scientific <span>properties</span> of real surfaces. One of the most apparent properties is the conservation of energy: a rougher surface will scatter light diffusely, while a smoother/more metallic surface will reflect light more directly, even though it's the same pool of light they are both drawn from. So, with all things being equal, the rule follows that as materials become shinier, the diffuse component should darken:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/afb0dd66-850e-4184-9567-0de0c84ea098.png" style="width:39.83em;height:14.83em;"/></p>
<p>Of course, there's more to physically-based rendering than energy conservation; however, this is a clear example that demonstrates the properties of a physically-based system. By keeping the reflection models similar to the way materials work in real life, we reduce the need for subjective manual tuning and produce real-world materials that look realistic under a variety of light conditions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Communities</h1>
                </header>
            
            <article>
                
<p>Computer graphics is a vast landscape of complex, beautiful, and inspiring concepts. One of the best ways to learn, share, and inspire others is to involve yourself in communities dedicated to this discipline. Here is a non-exhaustive list of some of the most<span><span> popular</span></span> communities:</p>
<ul>
<li><strong>Chrome</strong> <strong>Experiments</strong> (<a href="https://experiments.withgoogle.com/">https://experiments.withgoogle.com</a>) is an <span>online</span> showroom of web browser-based experiments, interactive programs, and artistic projects.</li>
<li><strong>WebGL.com (</strong><a href="https://webgl.com/">https://WebGL.com</a>) is the <span>leading</span> community for WebGL developers and comprises demos, tutorials, news, and more.</li>
<li><strong>SketchFab </strong>(<a href="https://sketchfab.com/">https://sketchfab.com</a>) is a <span>platform</span> to publish, share, discover, buy, and sell 3D, VR, and AR content. It provides a viewer based on the WebGL and WebVR technologies that allows users to display 3D models on the web.</li>
<li><strong>ShaderToy </strong>(<a href="https://www.shadertoy.com/">https://www.shadertoy.com</a>) is a cross-browser online community and tool for creating and sharing <span>shaders</span> through WebGL, used both for learning and teaching 3D computer graphics in a web browser.</li>
<li><strong>CGTrader </strong>(<a href="https://www.cgtrader.com/3d-models">https://www.cgtrader.com/3D-models</a>) is an <span>online</span> platform that allows designers and modeling studios to upload and either sell or share their 3D models with their community.</li>
<li><strong>TurboSquid </strong>(<a href="https://www.turbosquid.com/">https://www.turbosquid.com</a>) is a <span>digital</span> media company that sells stock 3D models used in 3D graphics to a variety of industries, including computer games, architecture, and interactive training.</li>
<li><strong>Poly </strong>(<a href="https://poly.google.com/">https://poly.google.com</a>) is a website<span> that was created</span> by Google for users to browse, distribute, and download 3D objects. It features a free library containing thousands of 3D objects that can be used in virtual reality and augmented reality applications.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Thank you for taking the time to read this book. By covering a wide range of topics—such as rendering, shaders, 3D math, lighting, cameras, textures, and many more—and guiding you in building compelling 3D applications, we hope that it has accomplished its goal of helping you learn interactive 3D computer graphics with WebGL 2.</p>
<div class="packt_quote"><span>“Stories don't end," he says. "They just turn into new beginnings." </span></div>
<div class="packt_quote CDPAlignRight CDPAlign"><span>– </span><span class="authorOrTitle">Lindsay Eagar,<span> </span></span><span>Hour of the Bees</span></div>
<p>With that in mind, please be sure to stay in touch and share your work—we look forward to seeing what you build! If you have any questions or feedback, please refer to the preface of this book for contact details.</p>


            </article>

            
        </section>
    </body></html>