- en: Chapter 4. Weight Weight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will explore an optional add-on package to the Sencha Touch
    Framework. The package is called Sencha Charts and it enables us to create charts
    using a data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the basic application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the data stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Sencha Charts package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the stores to Sencha Charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and displaying the charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sencha Charts overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic Sencha Touch Framework has a number of components for displaying data.
    However, business and other intensive software products often require something
    a bit more robust. By using Sencha Touch Charts, we can also display complex graphical
    data as part of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot exemplifies an overview of chart and graph types for
    displaying data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sencha Charts overview](img/8901OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These new components use data stores to display a wide range of chart and graph
    types including:'
  prefs: []
  type: TYPE_NORMAL
- en: Pie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Candlestick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gauge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using a few of these charts to provide a more user-friendly display
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of writing, the Sencha Charts package is only available as a part of Sencha
    Complete, or the open source version (GPL) of Sencha Touch 2.1 download. For this
    chapter, we will be using the open source version, which can be downloaded for
    free from the web page at [http://www.sencha.com/products/touch/download/](http://www.sencha.com/products/touch/download/).
  prefs: []
  type: TYPE_NORMAL
- en: Later on in the chapter, we will cover the basic setup for using Sencha Charts,
    but first, we will take a look at setting up the basic application.
  prefs: []
  type: TYPE_NORMAL
- en: The basic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the Sencha Charts package to create a program for tracking weight,
    exercise, calories, and water consumption. We will also allow the user to tag
    entries for adding additional information to the charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application consists of four basic pieces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A form for entering data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview that will provide a group of charts on a single page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A details section for viewing a specific chart in greater detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A configuration section that will allow the user to set goals for our four categories,
    and define the units of measurement for weight and water consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by setting up the basic application and building our form.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the application and building the form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using the Sencha Command SDK to create the application as described
    in the previous chapter. You will need to execute this command from the `Sencha
    Touch` directory. The basic command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer, you can create the initial directories and files yourself. Your
    file and directory structure should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the application and building the form](img/8901OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows the structure that is automatically generated
    with the `sencha app create` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `touch` directory contains a copy of the Sencha Touch Framework including
    our chart functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `resources` directory will contain our images and CSS files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `app` directory will contain the bulk of our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To begin, we need to define our main view. This file will be called `main.js`
    and it belongs to the `views` folder. The `main.js` file is a simple tab panel
    with four items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to make sure that this component is added into our `app.js` file
    in the `views` section of our `Ext.application` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the name we list under the view is not the file name (`Main.js`),
    it''s the last part of the define statement at the top of our code: `WeightWeight.view.Main`.
    Once we have this setup, let''s create four placeholder files, one for each panel
    in our tab view.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a placeholder for `dataentry`, `overview`, `details`, and
    `configform` panels. These files will contain starter code for each panel or form
    in our application. This will let us test our application without getting errors
    for missing files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how to test our application by using the starter code
    for each panel:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `dataentry.js` file in the `views` directory. This will be a form
    panel so the starter code should be set as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create an `overview.js` file with a simple panel in the `views`
    directory and set the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `view/details.js` file is also a panel like the previous `overview.js`
    file. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the `views/config.js` file, which is also a form panel like the
    `dataentry.js` file. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once all the views are created, we need to remember to add them to the `views`
    section in our `app.js` file (where we added `Main` previously). In the `app js`
    file, set the `views` section as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should now be able to load the code and test our panels.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Small steps**'
  prefs: []
  type: TYPE_NORMAL
- en: Creating code can be a very involved process. It is often helpful to make small
    changes and then test, rather than changing a few hundred lines of code and then
    testing. By changing small amounts of code, you should be able to track down problems
    quicker when they occur. In this case, by creating these starter files, we can
    test to make sure that Sencha is locating the files correctly and that the application
    starts without errors. We can then work on one file at a time and limit the places
    where we need to look when things go boom.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the application and building the form](img/8901OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, our application should simply start and allow us to switch between
    our views. This confirms that the application is working and then we can start
    creating our form.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the data entry form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our data entry form consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three fields: `datepickerfield` for setting the date, `numberfield` for each
    of our four categories (weight, water, calories, and exercise), and `hiddenfield`
    for storing our tag value for the entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three buttons: One for adding tags, one for saving, and one for canceling and
    clearing the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also place the **Cancel** and **Save** buttons inside an Hbox layout
    container. This will let us display the buttons side by side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will replace the line in `view/DataEntry.js` that says `html: ''Data Entry''`
    so that the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also provided margins for each of our items to add spacing to the form,
    making it more readable. The end result should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the data entry form](img/8901OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next view we need to create is the one for adding our tags. We will use
    a sheet to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AddTag view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AddTag` view is embedded in an `ActionSheet` component. This view will
    allow us to add new tags or select from the previous ones, and the `ActionSheet`
    component will display the view as an overlay that slides up from the bottom of
    the screen. The form contains a single field called `textfield`, a `list` view,
    and two buttons. Create the file in the `views` directory and call it `AddTag.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `alias` configuration to give this component an `xtype` property.
    This will let us quickly create and remove it within our program. We have also
    given the component an `id` property so that we can reference it in our controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the AddTag view](img/8901OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `list` component is a placeholder for now. We will finish it later once
    we have our data stores set up.
  prefs: []
  type: TYPE_NORMAL
- en: The next view we need to set up is the config form. This will be similar to
    our data entry form with a few different field types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the config form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by editing the `Config.js` placeholder file that we set up earlier
    in the chapter. The code for it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `alias` property allows us to call the panel by a custom xtype of config
    form. This is the `xtype` property we used in our `Main.js` file for the fourth
    panel. The `title` and `iconCls` properties control how the navigation for this
    panel appears in the main view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add some items to our panel. We will start by adding number
    fields for `Starting Weight` and `Target Weight`. By using a `numberfield` component
    we make sure that the number keyboard will appear on most mobile devices. To keep
    the field organized, we will put them in a `fieldset` component. This will go
    in the empty `items` config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add a set of spinner fields. The `spinnerfield` component allows
    the user to increment the field values using **+** and **-** buttons. These will
    also be in a `fieldset` component like the previous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `spinnerfield` component also allows us to set a `stepValue`
    configuration, which controls how much the field will increase or decrease when
    the buttons are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we will add our units of measurement section with radio buttons for
    different selections as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The end form should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the config form](img/8901OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our two forms, let's start working on the controllers for them.
    We'll start with the data entry controller.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DataEntry controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start off with a bare controller like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We start off by extending the basic controller and then adding a `config` section
    that will contain the rest of our initial setup code. The `refs` section will
    contain references to other components we need, and the `control` section will
    assign functions to our buttons and other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `refs` section is where we will add a reference to our `AddTag` sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is occasionally written out in a longer form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Both ways will work just fine. The reference looks for a component selector,
    in this case a component with an `id` value of `addTagSheet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By creating this reference using the `id` configuration of our `AddTag` sheet,
    we can access it anywhere in the controller by typing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that despite the fact that we use `tagSheet` as the reference, the `get`
    function capitalizes the first letter in our reference to `getTagSheet`. Since
    JavaScript is case sensitive, if you tried using gettagSheet, JavaScript will
    return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our reference, we need to add controls to the **Add Tag**
    button in our `DataEntry` form and the two buttons on our `AddTag` sheet. The
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of our controls has three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A DOM selector that tells the program which component we want to bind to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event we want it to listen for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function to fire when the event occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will add additional controls later on when we create our data stores. For
    now, let's add in the functions that need to fire when these three buttons are
    clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is a `showAddTag` function. It calls our `AddTag` sheet and displays
    it. The function is added after the end of the `config` section and looks similar
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, we check to see if there is already a sheet in the memory (using the
    `this.getTagSheet()` function automatically created by our reference in the `refs`
    section), and if not, then we create a new one using the `Ext.Widget()` function
    to create a new component with an `xtype` property of `addtag`. We then add this
    sheet to the view port and show it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Cancel** button in our `AddTag` sheet has a very simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is also used as our autogenerated reference function to grab the open sheet
    and close it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will duplicate this function for our last `saveAddTag` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will simply hide that sheet as well. We will add the code to save our tag
    data once we get our stores created. For now, save and test the code to make sure
    that the sheet appears and hides as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the DataEntry controller](img/8901OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the basic forms, we need to create our stores and models. This
    will provide us with places to store the data from our various forms.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the models and stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, we will be using the local storage offered by HTML5 to store
    our data. We will begin by defining the model for our data entry form. We will
    just call this one `Entry.js` and it goes in the `models` folder. The code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The model is pretty straightforward, defining the various data types and names.
    One thing to be aware of is the `entryDate` field, which has a `type` field of
    `date`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you use a date type in a model, you should always declare a `dateFormat
    component`. This tells the model how to store and retrieve the data. It also provides
    a common translation for the components that grab data from the model. Failure
    to set the `dateFormat` component often leads to foul language and extreme frustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next model we need is a model for the tags. The `Tag.js` file goes in the
    `models` folder and it is pretty simple. It only has an `id` field and a `text`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As before, we just use a `localstorage` proxy and give it a unique ID. This
    ID makes sure that the data is stored in its own separate table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last model we need is our `Config.js` model. This model follows the same
    format as a local storage proxy and the fields from our `config` form. The code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We also include some default values as part of the model. These values will
    get pulled into the form when we create a new config record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our models, we need to create our data store. The `EntryStore.js`
    file is created and it goes into the `stores` folder. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is a very basic store that we will expand later. For now, we will be using
    the model to do most of the heavy lifting. We give the store a `storeId` value
    of `EntryStore`, so that we can easily address it with our `DataEntry` controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a store for our tags. Since we only need very limited control
    over the tag store (it only feeds the list in our `AddTag` form), we are going
    to add the store as part of the component itself. Open the `AddTag.js` file and
    modify the `list` entry so that it looks similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This simple store format creates the store as part of the `list` entry and does
    not need to be added to our `app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of the `app.js` file, we should add other models and stores near the
    top of the `Ext.Application` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a model or store is within its own file, then it needs to be added into the
    `app.js` file. But, since the simple store format for our `list` is part of the
    component itself, we don't need to add it to the `app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our `Config` model, there will only be one config record for
    the application. This means that we don't actually need a store to use it. We
    will take care of that back in our controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, back in the controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in our controllers, it's time to put those stores to work for us, saving
    and displaying our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our `DataEntry` controller. First, we are going to add a
    few more references, so that we can get to our components easier. Update the `DataEntry.js`
    references as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This provides us with easy access to our tag adding sheet, the list of tags,
    the input and hidden fields, as well as the button that opens the sheet. We also
    add references to our data entry form and both of its buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, in the `control` section we need to assign events and functions to each
    of these items. We can also use our reference names here to address the controls
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we used the reference name for most of these. However, for the `Save`
    and `Cancel` buttons on our `tagSheet`, we used the component query reference.
    This is because we don't really need any additional control over those two pieces.
    They are basically single purpose components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our `showAddTag` and `cancelAddTag` functions both need to be
    able to grab the sheet itself in order to show and hide it. Since we have a reference
    of `TagSheet` assigned to it, we can call it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since we don't modify the `Save` and `Cancel` buttons once they have been created,
    there is no need to create a reference for them. However, we will be making some
    modifications to our `AddTagButton` when we save our tag, so we created a reference
    for that one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `saveAddTag` function and see how that''s done. Change the
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Right from the start we begin using the `get` functions automatically created
    by our references. We get the value of the `textfield` in our form using `this.getTagInput().getValue()`
    and then we get the store we use for our tag list by calling the `this.getTagList().getStore()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the list store is the one we created as part of the component instead
    of a separate `store.js` file. However, since we can get to the list, and the
    list knows what store it is using, we have easy access to everything we need.
    The reference to the parent also gives us quick access to its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check to see if the user entered anything into the field (if the value
    of `tag != ""`) and if so, we set the text on our button to say **Tag:** and whatever
    the user entered. This provides the user with easy feedback as to what tag is
    on the current entry, so if we tag our entry as **Tired**, then the button will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Meanwhile, back in the controllers](img/8901OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we set the value of our hidden field to the same value. We do this because
    we will need to load our form into a record to save it. We can load values from
    a form field but we cannot load values from a button name. We use the hidden field
    to hold the value within the form for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to find out if the tag is the one that we have entered previously,
    or if it is something new. To do this, we need to search the store using `store.findExact(''text'',
    tag)`. This will return `-1` if the value of `tag` is not found in the `text`
    field for any of the store''s data. If we don''t find the tag, we add it to our
    store using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, if the user has cleared the `textfield` out leaving it blank, we remove
    the previous tag text from the button and clear out the value of the hidden field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next function controls when the user selects an existing tag from the list
    of tags in the sheet (instead of entering a new one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When the user selects an item in the list, we put the text of the item in the
    text field for saving. The `saveAddTag` function will take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a similar function that deselects the items in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Our text field has a clear icon that removes the value of the field. We tie
    into the `clearicontap` event that we set up in our `controllers` section to fire
    this `deselectTag` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our tags taken care of, we will be able to save the full entry.
    We do this by adding the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This function grabs the values from our form and creates a new entry for our
    store. Since the form names match the names of our model, we can use `Ext.Create`
    to create a new entry record and assign the values directly. We then add the new
    record to the store and sync. Finally, we alert the user that the new data has
    been saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final function clears the fields in our form by using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This function resets our form and the text of the button. This function will
    be fired by the **Cancel** button in our data entry form.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up the `DataEntry.js` controller. We can now move on to the `Config.js`
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: Config.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new file in the `controllers` folder called `Config.js` (make sure
    to also add it to the `app.js` file in the list of controllers). We will start
    with just the basic controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This sets up the controller with our views, models, and references. It also
    assigns a function to our form so that when it is initialized it calls `getSavedConfig`.
    This function is also the first one we need to create.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, we should keep in mind a few things about `config`. This
    will be like a set of preferences for the application. There will only be one
    record for `config`, which is why we don't need to create a store. We can use
    the `Config.js` model to create, load, and save the record directly. Let's take
    a look at how this gets done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beneath the `config` section, we need to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create an instance of our `Config` model and attempt to load the first
    record from the HTML5 local storage (remember this should also be the only record).
    There are two possible outcomes here:'
  prefs: []
  type: TYPE_NORMAL
- en: If the load fails, it means that this is the first time the user has accessed
    the `Config` section and we have no record. In this case, we will call another
    function called `createSavedConfig`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the load succeeds then we need to load the data into our form for display.
    This will happen in the `bindRecordToForm` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By setting the scope of the function to `this` (meaning the controller itself),
    we can make these two functions part of the controller and call them with `this.createSavedConfig`
    and `this.bindRecordToForm` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding our new functions beneath the previous `getSavedConfig`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This function creates a new empty record with the default values we defined
    in the `config` object and then saves the record. If this is successful, we call
    our next function, which binds the data record to our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This function is called by both `getSavedConfig` and `createSavedConfig`, which
    pass along the data record automatically. We set this record to be our `savedConfig`,
    which allows us to get at the config data from anywhere in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next we grab the form and use `setRecord` to populate the form with our data.
    Once the form is populated, we also need a way to save the data. To do this, we
    are going to use an interesting technique called **delegate**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delegate allows us to set listeners and functions on specific children within
    the form. In this case, we do `form.on({ delegate: ''field''`, which lets us set
    a group of listeners on every field in our form:'
  prefs: []
  type: TYPE_NORMAL
- en: The `numberfield` component understands the `change` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spinnerfield` component understands the `spin` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `checkboxfield` component understands the `check` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these events will call `this.updateValue` to save the data. While the
    other fields pass along both the field and value automatically, the checkboxes
    actually only pass the field when the `check` event fires. This means we do a
    tiny bit of extra work to get them to pass both field and value to our next function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `updateValue` function takes the field and value passed in our previous
    function, and saves the data for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This saves our data to local storage. Now that we have a way to save data and
    our goals, we can start looking at the charting functions for displaying the data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Sencha Touch Charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we noted at the beginning of the chapter, Sencha Touch Charts is currently
    only available as part of Sencha Complete or the open source version of Sencha
    Touch 2.1\. Previously, Sencha Touch Charts was a separate download, which had
    to be installed and configured as part of your application in order to function.
    This is no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should also be noted that if you are using the standalone commercial version
    of Sencha Touch 2.1 (which is not part of the Sencha Complete package), you will
    not be able to use the new Sencha Charts functions. While this standalone commercial
    version of Sencha Touch 2.1 includes an empty `src/charts` directory, it does
    not have any of the actual chart functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the overview chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The overview chart is a single-line chart, tracking weight and exercise. Our
    chart will have three axes, with weight ranges displayed on the left, date ranges
    displayed across the bottom, and exercise time ranges along the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot describes the preceding explanation in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the overview chart](img/8901OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will start with a few changes to our placeholder for the `OverviewChart.js`
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've replaced the `html` configuration and included a single `chart`
    item as part of our panel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previous versions of the Sencha Touch Chart software used a `chartPanel` object,
    which automatically included the `chart` item as part of the panel. The current
    Version 2.1 treats the `chart` item as a separate object, which allows the `chart`
    item to be embedded in a panel or a container.
  prefs: []
  type: TYPE_NORMAL
- en: We have given the `chart` item a `store` value to grab data from, and positioned
    the `legend` section at the `bottom` of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the axes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next piece we need to add is our axes. As we mentioned earlier, there are
    three for this graph. The code for them goes inside the `chart` section of the
    `config` definition (below our `legend` definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first axis has a `title` section of `weight` and it's a `numeric` axis.
    We position it on the left-hand side and then tell the axis which fields we are
    tracking (in this case, `weight`).
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed from the name `fields`, this means we can have multiple
    items tracked along the same axis. This works well if you have multiple items
    with the same numeric range of data. In this case, we have too much variation
    in the range of `exercise` and `weight`, so we keep them on different axes.
  prefs: []
  type: TYPE_NORMAL
- en: The `exercise` axis is set up in a similar fashion, but positioned on the right.
  prefs: []
  type: TYPE_NORMAL
- en: The `date` axis is a bit different. It has a type of `date` and a `dateFormat`
    for display.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to set up the series.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `series` section goes inside the chart configuration and beneath our axes
    section. The `series` section describes how the data points should align on the
    graph and how they should be formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our overview graph is a line graph display, tracking weight and exercise over
    time. We need one entry for weight and a second one for exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This defines our two series (`Weight` and `Exercise`). The `type` configuration
    defines which kind of series we are using. The `xField` configuration determines
    which data field is tracked along the horizontal axis (`entryDate` for both) and
    the `yField` configuration determines which field is tracked along the vertical
    axis (`weight` for the first series and `exercise` for the second). The `axis`
    configuration tells the series which part of the graph to map its values to.
  prefs: []
  type: TYPE_NORMAL
- en: The `style` section determines how the line for our series will appear. The
    `marker` section gives us the appearance of each data point along the line. The
    `highlightCfg` section uses `scale` to increase the size of a selected marker,
    so when the user clicks on a data point, the marker will increase to 1.25 times
    its normal size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `marker` section itself is actually a `sprite` reference, which means that
    we can use any of the available Sencha Touch `sprite` objects for our `marker`.
    These include things such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ellipses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A full list of available sprites and their configuration options can be found
    at [http://docs.sencha.com/touch/2-1/](http://docs.sencha.com/touch/2-1/) in the
    **draw** | **sprite** section of the API. To use these sprites, you just need
    to set the type configuration to the sprite name. The name for each sprite can
    be found at the top of the documentation as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the series](img/8901OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the `type` config is set for the `marker` section, you can use any of the
    sprite's configuration options to customize the marker's appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the series configuration is complete, we can also add some interactions
    to the graph to make it more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The interactions section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `interactions` section allows us to respond to the user''s taps and gestures
    to expand the amount of information we provide. The current types of interactions
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ItemCompare`: This lets the user select two items and see a data comparison'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemHightlight`: This lets the user tap and highlight a series of data items
    in the chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemInfo`: This lets the user tap and get a detailed view of the data record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PanZoom`: This lets the user pinch the chart to zoom in and out, or let them
    tap and drag to pan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PieGrouping`: This lets the user select and merge consecutive pie slices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rotate`: This lets the user tap and drag around the center of the pie or radar
    charts to rotate the chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToggleStacked`: This lets the user toggle between stacked and grouped orientations
    on a bar or column series chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this application, we will allow the user to tap the data points and get
    back all of the details for that particular day. We set up an interaction with
    a `type` value of `iteminfo` and define a `tpl` tag, which is used to display
    the data in the panel. The interaction receives the entire data record for the
    tapped data point so the `tpl` tag can use any of our values for weight, exercise,
    water, calories, or tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This template will display our detailed item info. Next, we need to add the
    listener that will show the window when we click on one of the data points in
    our `OverviewChart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The listener starts by setting `var record = item.record;` and then getting
    the date out of the record so that we can format it properly for our `setTitle`
    function at the end of the listener.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we grab our single config record so that we can get the units of measurement
    for weight and water consumption. Then we set the data for the panel to the combined
    `record` and `configRecord` objects (using `Ext.apply()`). This gets both sets
    of data into our `tpl` for display.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, since this is a special floating panel in Sencha Touch, it has no `title`
    attribute, but we can create one using the first docked component in the panel.
    We set this `title` to the formatted date we grabbed at the top of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![The interactions section](img/8901OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should be able to save your work now and click on any of the data points
    to see our new detailed item info.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we want to cover is creating the details view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the details view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the details chart, we have decided to make something a little more reusable.
    Our overall details view will contain three similar charts and a radar chart.
    Since we don't want to create the same chart over and over, we need a view we
    can call up with a different configuration for each of our charts. This will be
    a simple bar style chart with two axes; one for the date and one for the amount.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the details view](img/8901OS_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This reusable chart will be our `goalChart` view. We will create the `goalChart`
    view with its own `xtype`, which will allow us to reuse it with different configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the goalChart view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start by creating a `goalChart` view and setting it up to load our `config`
    file when it initializes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set our panel's store to the `EntryStore` that contains all of our
    data (this gives us access to every record). Next, our `constructor` function
    will take whatever configuration options are passed to it, and applies them to
    the panel using `Ext.apply(this, config);`. This is where we will set an individual
    `title`, `dataField`, `goalField`, and `colorSet` for each chart.
  prefs: []
  type: TYPE_NORMAL
- en: Once these options are set, the panel then loads the goals and measurements
    from our single `configRecord` in much the same way as our previous chart panel.
    This time when the `Config` successfully loads, we call a new function called
    `createChart`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createChart` function comes right after our `constructor` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createChart` function starts by creating a second `store` called the `goalStore`
    and gives it three fields as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entryDate`: This is the date field from our store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goal`: This is the the goal passed from our `configRecord`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.dataField`: This will be passed to us as one of our config options when
    we use the `goalChart` view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then loop through our data in the main store (`EntryData`) and look for any
    values in the field that match the value we received for `this.dataField`. As
    we find matches, we add them to our `goalStore`. The `goalStore` is the actual
    store that will feed the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could use the following code to create a `goalChart` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `goalChart` view would use the `dataField` value to look for any data we
    have for `exercise` and create the chart. It would also use the `goalField` value
    of `exercisePerDay` to grab that number from our config record and add it to the
    display.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of our `goalChart` sets up the series and axes much like the
    previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The main difference from the previous charts is that we have some values that
    will be supplied by our `config`, and we use the `Ext.factory` function to create
    the chart object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, our use of `Ext.factory` is equivalent to `Ext.create`, but `Ext.factory`
    can also be used to update the configuration of existing objects. We chose to
    use `Ext.factory` here, rather than `Ext.create`, solely because most of the Sencha
    Charts examples refer to `Ext.factory` when creating charts, and we wanted to
    be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can re-use the chart for our exercise, water, and weight charts just
    by setting different `config` values for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dataField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goalField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chartTitle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorSet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at the `DetailChart.js` file in our example code to see how this
    works.
  prefs: []
  type: TYPE_NORMAL
- en: The last chart we need to touch on is the word chart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the word chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `wordChart` view is set up much like our `goalChart` with its own `constructor`
    and `createChart` function. However, the goal chart uses our tags to create a
    different type of chart called a radar chart. Our `wordChart.js` file checks for
    the number of occurrences of specific words and uses the information to draw our
    radar chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the word chart](img/8901OS_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The beginning of the `wordChart.js` file looks almost the same as our `goalChart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After the end of the `constructor`, we set up our `createChart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This grabs our `configRecord` like we did previously and then filters our `store`
    to find only the records that have `tag` data. We then `group` the fields by `tag`
    so that we can generate a `count` for each `tag`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a second `store`, much like in our `goalCharts` and we transfer
    our tag names and our counts into the second `store`. This one is called our `wordStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a `wordStore` that consists only of the tag name and the number
    of times it occurs, we can use it to feed our new chart. Again, we use the `Ext.Factory`
    to create our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The radar style chart uses an `xtype` value of `polar` as part of its chart
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Polar** charts include circular chart systems such as the pie and radar style
    charts, whereas **Cartesian** charts are line-based charts such as the area and
    bar charts.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `series` section, the `type` value for our chart is then set to `radar`,
    which gives us our specific chart appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with our previous charts, we also set `marker` and `style` configurations.
    Finally, we finish our `wordChart` by setting up the axes, closing out the chart
    object, and adding it to our panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two axes here: a `numeric` axis for our tag counts and a `category`
    axis for our tag names. We map these axes to the correct `field` and set `grid`
    to `true`. This will give us an underlying grid for our radar chart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `style` setting of `estStepSize: 1` ensures that all of our words will
    show up around the edge of our radar chart, without skipping any words.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `wordChart` is finished, we need to assemble all of our charts
    into a single page for our full details view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the word chart](img/8901OS_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Back in our `details.js` placeholder file, we need to set up a new layout and
    add our four charts. As you can see in the screenshot, we have our four charts
    arranged in a square on the page with one chart in each corner. The easiest way
    to accomplish this is with a set of nested `hbox` and `vbox` layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the word chart](img/8901OS_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the previous image, our details panel will have a `layout`
    section of `hbox`, with two containers inside, one on top of the other. In our
    `config` section, add the layout as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `stretch` and `center` values ensure that our containers will expand to
    fill the available space and occupy the center of our details panel. The `flex`
    value makes the inner containers equal in size. These two containers will have
    a layout of `vbox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add these two containers in an `items` section within our `config` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The two containers form a top and bottom layout with two charts each. The goal
    charts each have slightly different configurations so that they display exercise,
    calories, and water consumption. We also color them differently to provide more
    visual appeal. The `wordchart` uses a similar configuration to include only the
    data from our tags.
  prefs: []
  type: TYPE_NORMAL
- en: With this last panel completed, you should be able to enter data into the application
    and test all of the charts.
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take some time to play around with the different types of charts and see what
    is available. The Sencha website has an excellent guide for using charts and interactions
    at [http://docs.sencha.com/touch/2-1/#!/guide/drawing_and_charting](http://docs.sencha.com/touch/2-1/#!/guide/drawing_and_charting).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we talked about:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the basic application to create the different views for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the stores that will hold the data and feed our charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the controllers for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the overview chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the details chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will look at creating a simple application to work with
    an external API.
  prefs: []
  type: TYPE_NORMAL
