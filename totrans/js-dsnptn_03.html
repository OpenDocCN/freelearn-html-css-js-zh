<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor057" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor058" class="pcalibre1 calibre6 pcalibre"/>2</h1>
<h1 id="_idParaDest-32" class="calibre5"><a id="_idTextAnchor059" class="pcalibre1 calibre6 pcalibre"/> Implementing Structural Design Patterns</h1>
<p class="calibre3">Structural design patterns give us tools to handle <em class="italic">connecting</em> different objects; in other words, managing the relationships between objects. This includes techniques to reduce memory usage and develop functionality with existing classes without modifying these existing classes. In addition, JavaScript features allow us to more effectively apply these patterns. Modern JavaScript includes some built-ins that allow us to implement structural design patterns in a more efficient manner.</p>
<p class="calibre3">We’ll cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Defining structural design patterns as a whole, and proxy, decorator, flyweight, and adapter specifically</li>
<li class="calibre11">An implementation of the proxy pattern with a class-based approach as well as an alternative using Proxy and Reflect</li>
<li class="calibre11">Multiple implementations of the decorator pattern, leveraging JavaScript first-class support for functions</li>
<li class="calibre11">An iterative approach to implementing flyweight in JavaScript, including ergonomic improvements using modern JavaScript features</li>
<li class="calibre11">Class- and function-based adapter implementations</li>
</ul>
<p class="calibre3">At the end of this chapter, you’ll be able to make informed decisions on when and how to use structural design patterns in JavaScript.</p>
<h1 id="_idParaDest-33" class="calibre5"><a id="_idTextAnchor060" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<h1 id="_idParaDest-34" class="calibre5"><a id="_idTextAnchor061" class="pcalibre1 calibre6 pcalibre"/>What are structural design patterns?</h1>
<p class="calibre3">When building software, we want to be able to <em class="italic">connect</em> different pieces of code (e.g., classes and functions) and change how the parties involved in these connections and relationships interact without<a id="_idIndexMarker056" class="pcalibre1 calibre6 pcalibre"/> having to jump through multiple fragmented parts of the codebase.</p>
<p class="calibre3">Structural design patterns allow us to add, remove, and change functionality in modules and classes safely. The “structural” aspect of these patterns is due to the fact that we can play around with implementations if the exposed interfaces are stable.</p>
<p class="calibre3">Structural design patterns are a good way to maintain the separation of concerns and loose coupling of different classes and modules while maintaining a high development velocity.</p>
<p class="calibre3">In the next section, we’ll look at multiple approaches to implement the Proxy pattern in JavaScript.<a id="_idTextAnchor062" class="pcalibre1 calibre6 pcalibre"/></p>
<h1 id="_idParaDest-35" class="calibre5"><a id="_idTextAnchor063" class="pcalibre1 calibre6 pcalibre"/>Implementing the Proxy pattern with Proxy and Reflect</h1>
<p class="calibre3">The proxy pattern involves<a id="_idIndexMarker057" class="pcalibre1 calibre6 pcalibre"/> providing an object (the <code>subject</code>, or <code>real</code> object) that fulfills a certain interface. The <code>proxy</code> (a <code>placeholder</code> or <code>wrapper</code> object) controls access to the <code>subject</code>. This allows us to provide additional functionality on top of the <a id="_idIndexMarker058" class="pcalibre1 calibre6 pcalibre"/>subject without changing a<a id="_idIndexMarker059" class="pcalibre1 calibre6 pcalibre"/> consumer’s interactions with the <code>subject</code>.</p>
<p class="calibre3">This means that a proxy needs to provide an interface matching the <code>subject</code>.</p>
<p class="calibre3">By using the proxy pattern, we can intercept all operations on the original object and either pass them through or change their implementation. This follows the open/closed principle, where both the <code>subject</code> and <code>consumer</code> are closed for modification, but the proxy provides us with a hook to <code>extend</code>, which means the design is open to extensi<a id="_idTextAnchor064" class="pcalibre1 calibre6 pcalibre"/>on.</p>
<h2 id="_idParaDest-36" class="calibre7"><a id="_idTextAnchor065" class="pcalibre1 calibre6 pcalibre"/>A redaction proxy implementation</h2>
<p class="calibre3">We’ll start with the following<a id="_idIndexMarker060" class="pcalibre1 calibre6 pcalibre"/> implementation class that has<a id="_idIndexMarker061" class="pcalibre1 calibre6 pcalibre"/> a couple of methods that output strings:</p>
<pre class="source-code">
class Implementation {
  someFn() {
    return 'some-output';
  }
  sensitiveFn() {
    return 'sensitive-output';
  }
}</pre> <p class="calibre3">Let’s imagine that the <code>sensitive</code> string in the output should be redacted.</p>
<p class="calibre3">Here’s how a <code>RedactionProxy</code> class could look:</p>
<pre class="source-code">
class RedactionProxy {
  constructor() {
    this.impl = new Implementation();
  }
  someFn() {
    return this.impl.someFn();
  }
  sensitiveFn() {
    return this.impl.sensitiveFn().replace('sensitive',
      '[REDACTED]');
  }
}</pre> <p class="calibre3">In this case, <code>RedactionProxy</code> does what we call a <code>someFn()</code> calls. In other words, <code>RedactionProxy#someFn</code> simply forwards the <code>someFn</code> call to <code>Implementation</code>. See the<a id="_idIndexMarker062" class="pcalibre1 calibre6 pcalibre"/> following<a id="_idIndexMarker063" class="pcalibre1 calibre6 pcalibre"/> illustration:</p>
<pre class="source-code">
const redactionProxy = new RedactionProxy();
console.assert(
  redactionProxy.someFn() === newImplementation().someFn(),
    'Proxy implementation calls through to original'
);</pre> <p class="calibre3">When it comes to <code>sensitiveFn</code>, <code>RedactionProxy</code> implements the same interface as <code>Implementation</code> except it overrides the output, replacing <code>sensitive</code> with <code>[REDACTED]</code>.</p>
<p class="calibre3">This means the interface for <code>RedactionProxy</code> and <code>Implementation</code> is the same, but <code>RedactionProxy </code>can control which method calls and fields are available along with their implementation. See the following example of this behavior:</p>
<pre class="source-code">
console.assert(
  redactionProxy.sensitiveFn() !== new
    Implementation().sensitiveFn()&amp;&amp;
      redactionProxy.sensitiveFn() === '[REDACTED]-output',
      'Proxy implementation adds new behavi<a id="_idTextAnchor066" class="pcalibre1 calibre16 pcalibre"/>our'
);</pre> <h2 id="_idParaDest-37" class="calibre7"><a id="_idTextAnchor067" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">The proxy pattern allows us to intercept calls to an object (the <code>implementation</code> or <code>subject</code>) and augment them, either<a id="_idIndexMarker064" class="pcalibre1 calibre6 pcalibre"/> by manipulating the output or by adding a side-effect.</p>
<p class="calibre3">Our example of redaction is a good use case for it, but any other type of instrumentation is also a good use case. The instrumentation could be concerned with measuring something about a function/field access (e.g. the time it takes) or ensuring access to a property triggers a certain effect. For example, the <strong class="bold">reactivity</strong> system of Vue.js and Alpine.js is based on proxies, where a JavaScript Proxy object is used to wrap the reactive data objects. This allows the library (Vue or Alpine) to detect when properties are changed and<a id="_idIndexMarker065" class="pcalibre1 calibre6 pcalibre"/> run things such as watchers, effects, and re<a id="_idTextAnchor068" class="pcalibre1 calibre6 pcalibre"/>-renders.</p>
<h2 id="_idParaDest-38" class="calibre7"><a id="_idTextAnchor069" class="pcalibre1 calibre6 pcalibre"/>Improving the proxy pattern in JavaScript with the Proxy and Reflect global objects</h2>
<p class="calibre3">Back to our example, what happens when<a id="_idIndexMarker066" class="pcalibre1 calibre6 pcalibre"/> we need to redact more functions?</p>
<p class="calibre3">Let’s take an <code>Implementation</code> class with three methods (<code>someFn</code>, <code>sensitiveFn</code>, and <code>otherSensitiveFn</code>):</p>
<pre class="source-code">
class Implementation {
  someFn() {
    return 'sensitive-some-output';
  }
  sensitiveFn() {
    return 'sensitive-output';
  }
  otherSensitiveFn() {
    return 'sensitive-other-output';
  }
}</pre> <p class="calibre3">A naïve implementation of an extended proxy looks as follows, where each method calls the implementation’s method and then replaces <code>sensitive</code> in its output:</p>
<pre class="source-code">
class RedactionProxyNaive {
  constructor() {
    this.impl = new Implementation();
  }
  someFn() {
    return this.impl.someFn().replace
      ('sensitive', '[REDACTED]');
  }
  sensitiveFn() {
    return this.impl.sensitiveFn().replace('sensitive',
      '[REDACTED]');
  }
  otherSensitiveFn() {
    return this.impl.otherSensitiveFn().
      replace('sensitive', '[REDACTED]');
  }
}</pre> <p class="calibre3">This implementation of the <code>Proxy</code> works, as we <a id="_idIndexMarker067" class="pcalibre1 calibre6 pcalibre"/>can ensure with the following code:</p>
<pre class="source-code">
console.assert(
  !new RedactionProxyNaive().someFn().includes('sensitive')
    &amp;&amp;
    !new RedactionProxyNaive().sensitiveFn().includes
      ('sensitive') &amp;&amp;
    !new RedactionProxyNaive().otherSensitiveFn().includes
      ('sensitive'),
  'naive proxy redacts correctly'
);</pre> <p class="calibre3">One improvement we can make here is to extract a <code>#redact</code> private method to handle the replacement <a id="_idIndexMarker068" class="pcalibre1 calibre6 pcalibre"/>of <code>sensitive</code>:</p>
<pre class="source-code">
class RedactionProxyNaiveRefactored {
  constructor() {
    this.impl = new Implementation();
  }
  #redact(str) {
    return str.replace('sensitive', '[REDACTED]');
  }
  someFn() {
    return this.#redact(this.impl.someFn());
  }
  sensitiveFn() {
    return this.#redact(this.impl.sensitiveFn());
  }
  otherSensitiveFn() {
    return this.#redact(this.impl.otherSensitiveFn());
  }
}
console.assert(
  !new RedactionProxyNaiveRefactored().someFn().includes
    ('sensitive') &amp;&amp;
    !new RedactionProxyNaiveRefactored().sensitiveFn().
      includes('sensitive') &amp;&amp;
    !new RedactionProxyNaiveRefactored()
      .otherSensitiveFn()
      .includes('sensitive'),
  'refactored naive proxy redacts correctly'
);</pre> <p class="calibre3">The downside of this approach is that every method on the <code>Implementation</code> object (the subject) will require a <a id="_idIndexMarker069" class="pcalibre1 calibre6 pcalibre"/>change to our Proxy implementation.</p>
<p class="calibre3">Fortunately, JavaScript has a built-in class to programmatically manage these situations. The JavaScript class is aptly called <code>Proxy</code>.</p>
<p class="calibre3">Let’s take the following plain JavaScript object (this also works for class instances) with both fields and functions:</p>
<pre class="source-code">
const obj = {
  someFn() {
    return 'sensitive-some-output';
  },
  sensitiveFn() {
    return 'sensitive-output';
  },
  otherSensitiveFn() {
    return 'sensitive-other-output';
  },
  field: 'sensitive-data',
  sensitiveField: 'redact-everything',
};</pre> <p class="calibre3">We want to be able to completely redact (i.e., keep none of the original output) those fields that contain <code>sensitive</code> in the field or method name. We also want to have a value redaction functionality when the output contains the string <code>sensitive</code>, where we replace <code>sensitive</code> with <code>[REDACTED]</code>.</p>
<p class="calibre3">To achieve this, we define a Proxy that will wrap our <code>obj</code> object. We instantiate the Proxy with a “get trap,” which allows us to intercept all property accesses (which includes function access).</p>
<p class="calibre3">The <code>get</code> function receives a <code>target</code> and <code>property</code>. The target is the object being wrapped (<code>obj</code>), <code>property</code> is the property being accessed.</p>
<p class="calibre3">Based on whether <code>target[property]</code> is a function or not, we’ll replace it with a wrapper function that will collect all the arguments, call <code>target[property]</code> with those arguments, intercept the<a id="_idIndexMarker070" class="pcalibre1 calibre6 pcalibre"/> output, and replace <code>sensitive</code> with <code>[REDACTED]</code>. We also return <code>[REDACTED]</code> if the property name includes <code>sensitive</code> (in our case, using <code>sensitiveFn</code>).</p>
<p class="calibre3">In cases where <code>target[property]</code> is not a function, we’ll do a full redaction if the property name includes <code>sensitive</code> and also replace <code>sensitive</code> in the output for all other properties:</p>
<pre class="source-code">
const redactedObjProxy = new Proxy(obj, {
  get(target, property, _receiver) {
    if (target[property] instanceof Function) {
      return (...args) =&gt; {
        if (property.includes('sensitive')) {
          return '[REDACTED]';
        }
        const output = target[property](...args);
        if (typeof output === 'string') {
          return output.replace('sensitive', '[REDACTED]');
        }
        return output;
      };
    }
    if (property.includes('sensitive')) {
      return '[REDACTED]';
    }
    return target[property].replace('sensitive',
      '[REDACTED]');
  },
});</pre> <p class="calibre3">The following code ensures our Proxy implementation works as expected. <code>sensitive</code> is not present in any of the function <a id="_idIndexMarker071" class="pcalibre1 calibre6 pcalibre"/>output or in the <code>field</code> value:</p>
<pre class="source-code">
console.assert(
  !redactedObjProxy.someFn().includes('sensitive') &amp;&amp;
    !redactedObjProxy.sensitiveFn().includes('sensitive') &amp;&amp;
    !redactedObjProxy.otherSensitiveFn().includes
      ('sensitive'),
  'JavaScript Proxy redacts correctly for all functions'
);
console.assert(
  !redactedObjProxy.field.includes('sensitive'),
  'JavaScript Proxy redacts field values by value
    correctly'
);
console.assert(
  redactedObjProxy.sensitiveField === '[REDACTED]',
  'JavaScript Proxy redacts field values by property name
    correctly'
);</pre> <p class="calibre3">One of the key benefits is the simplicity of the setup; all the redaction logic is contained in the <code>get</code> function, which keeps it localized.</p>
<p class="calibre3">As an effect of the co-located <a id="_idIndexMarker072" class="pcalibre1 calibre6 pcalibre"/>logic, we’ve been able to add redaction by property name in addition to redacting values.</p>
<p class="calibre3">There are still some slight issues with our current Proxy-based approach since we’re losing the <code>this</code> context on functions. We call <code>target[property](...args)</code>, which is fine as long as our object is not accessing <code>this</code>. We’ll further refactor our implementation to make further extension easier, as well as leveraging the <code>Reflect</code> global built-in object to simplify our code.</p>
<p class="calibre3"><code>Reflect</code> provides functions with the same name as the <code>Proxy</code> trap with the same arguments; for example, <code>Reflect.get(target, </code><code>property, receiver)</code>.</p>
<p class="calibre3">We’ll extract a <code>redact</code> function, which takes a <code>propertyName</code> and a <code>redactionValue</code>. It will keep our redaction logic even more in sync by abstracting it to a separate function:</p>
<pre class="source-code">
const redact = (propertyName, redactionValue) =&gt; {
  if (propertyName.includes('sensitive')) {
    return '[REDACTED]';
  }
  if (typeof redactionValue === 'string') {
    return redactionValue.replace('sensitive','[REDACTED]'
    );
  }
  // Could implement redaction of objects/Arrays and so on
  return redactionValue;
};</pre> <p class="calibre3">We can then use <code>redact</code> where necessary, use <code>Reflect.get()</code> as a shortcut to <code>target[property]</code>, and<a id="_idIndexMarker073" class="pcalibre1 calibre6 pcalibre"/> use <code>Reflect.apply</code> to maintain the <code>this</code> context:</p>
<pre class="source-code">
const redactedObjProxyImproved = new Proxy(obj, {
  get(target, property, receiver) {
    const targetPropertyValue = Reflect.get(target,
      property, receiver);
    if (targetPropertyValue instanceof Function) {
      return (...args) =&gt; {
        const output = Reflect.apply(
          targetPropertyValue,
          this === receiver ? this : target,
          args
        );
        return redact(property, output);
      };
    }
    return redact(property, targetPropertyValue);
  },
});</pre> <p class="calibre3">Our redaction still functions the same over values, function outputs, and property and function names:</p>
<pre class="source-code">
console.assert(
  !redactedObjProxyImproved.someFn().includes
    ('sensitive') &amp;&amp;
    !redactedObjProxyImproved.sensitiveFn().includes
      ('sensitive') &amp;&amp;
    !redactedObjProxyImproved.otherSensitiveFn().includes
      ('sensitive'),
  'JavaScript Proxy with Reflect redacts correctly for all
    functions'
);
console.assert(
  !redactedObjProxyImproved.field.includes('sensitive'),
  'JavaScript Proxy with Reflect redacts field values
    correctly'
);
console.assert(
  redactedObjProxyImproved.sensitiveField === '[REDACTED]',
  'JavaScript Proxy with Reflect redacts field values
    correctly'
);</pre> <p class="calibre3">Now that we’ve delved<a id="_idIndexMarker074" class="pcalibre1 calibre6 pcalibre"/> into how to implement the proxy pattern, we’ll contrast it with the decorator pattern and which JavaScript tools we can us<a id="_idTextAnchor070" class="pcalibre1 calibre6 pcalibre"/>e to implement it.</p>
<h1 id="_idParaDest-39" class="calibre5"><a id="_idTextAnchor071" class="pcalibre1 calibre6 pcalibre"/>Decorator in JavaScript</h1>
<p class="calibre3">The decorator pattern is similar to <a id="_idIndexMarker075" class="pcalibre1 calibre6 pcalibre"/>the proxy pattern in that it’s about “wrapping” an <a id="_idIndexMarker076" class="pcalibre1 calibre6 pcalibre"/>object. However, the decorator pattern is about adding functionality to an object at runtime. Different decorators can be applied to an object to add different fu<a id="_idTextAnchor072" class="pcalibre1 calibre6 pcalibre"/>nctionalities to it.</p>
<h2 id="_idParaDest-40" class="calibre7"><a id="_idTextAnchor073" class="pcalibre1 calibre6 pcalibre"/>Implementation</h2>
<p class="calibre3">Given the following <code>HttpClient</code> class based on the <code>fetch</code> API, we want to instrument the requests <a id="_idIndexMarker077" class="pcalibre1 calibre6 pcalibre"/>made through this client. <code>HttpClient</code> implements <code>getJson</code> and returns JSON output if the <code>fetch</code> request succeeds:</p>
<pre class="source-code">
class HttpClient {
  async getJson(url) {
    const response = await fetch(url);
    if (response.ok) {
      return response.json();
    }
    throw new Error(`Error loading ${url}`);
  }
}</pre> <p class="calibre3"><code>InstrumentedHttpClient</code>, which is a decorator, might look like the following, where we expose the same <code>getJson</code> method but have the added <code>requestTimings</code> field on the instance.</p>
<p class="calibre3">When <code>getJson</code> is called, we track the start and end time of the <code>HttpClient#getJson</code> method call and add it to the instance’s <code>requestTimings</code>:</p>
<pre class="source-code">
class InstrumentedHttpClient {
  constructor(client) {
    this.client = client;
    this.requestTimings = {};
  }
  async getJson(url) {
    const start = performance.now();
    const output = await this.client.getJson(url);
    const end = performance.now();
    if (!Array.isArray(this.requestTimings[url])) {
      this.requestTimings[url] = [];
    }
    this.requestTimings[url].push(end - start);
    return output;
  }
}</pre> <p class="calibre3">We can<a id="_idIndexMarker078" class="pcalibre1 calibre6 pcalibre"/> ensure that the <code>InstrumentedHttpClient</code> works as described with the following code:</p>
<pre class="source-code">
const httpClient = new HttpClient();
const instrumentedClient = new InstrumentedHttpClient
  (httpClient);
await instrumentedClient.getJson
  ('https://ifconfig.io/all.json');
console.assert(
  Object.keys(instrumentedClient.requestTimings).length &gt;0,
  'Tracks request timings'
);
await instrumentedClient.getJson
  ('https://ifconfig.io/all.json');
console.assert(
  instrumentedClient.requestTimings
    ['https://ifconfig.io/all.json'].length === 2,
  'Trac<a id="_idTextAnchor074" class="pcalibre1 calibre16 pcalibre"/>ks per URL timings'
);</pre> <h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor075" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">The decorator pattern, much like the proxy pattern, can be used to instrument or intercept operations on a “subject”.</p>
<p class="calibre3">One key difference is that the decorator is about adding “new members” to the class, not just maintaining the interface one to <a id="_idIndexMarker079" class="pcalibre1 calibre6 pcalibre"/>one. That’s why it’s normal for us to save an additional <code>requestTimings</code> field and access it from the “decorated” class, <code>InstrumentedHttpClient</code>.</p>
<p class="calibre3">This means that multiple decorators can “stack” on top of each other. For example, we can have our <code>InstrumentedHttpClient</code>, which has <code>requestTimings</code>, and then create another decorator class that does something useful with the timing information. An example here is sending a “client-time” heuristic header that allows the server to stop processing a request once a certain amount time of time has passed since it knows the client will have aborted <a id="_idTextAnchor076" class="pcalibre1 calibre6 pcalibre"/>the connection by then.</p>
<h2 id="_idParaDest-42" class="calibre7"><a id="_idTextAnchor077" class="pcalibre1 calibre6 pcalibre"/>Improvements/limitations</h2>
<p class="calibre3">Due to JavaScript’s first-class support for<a id="_idIndexMarker080" class="pcalibre1 calibre6 pcalibre"/> functions, we can use functions as the basis for decoration instead of classes.</p>
<p class="calibre3">Our <code>getJson</code> function could look as follows, with similar logic to the <code>HttpClient.getJson</code> method:</p>
<pre class="source-code">
async function getJson(url) {
  const response = await fetch(url);
  if (response.ok) {
    return response.json();
  }
  throw new Error(`Error loading ${url}`);
}</pre> <p class="calibre3">We can then create an <code>addTiming</code> method that stores the request times in an <code>allOperationTimings</code> <code>Map</code> instance.</p>
<p class="calibre3">We’re using both aspects of first-class functions here – we’re passing a function as a parameter (<code>getJson</code>) and <a id="_idIndexMarker081" class="pcalibre1 calibre6 pcalibre"/>returning a function:</p>
<pre class="source-code">
const allOperationTimings = new Map();
function addTiming(getJson) {
  return async (url) =&gt; {
    const start = performance.now();
    const output = await getJson(url);
    const end = performance.now();
    const previousOperationTimings =
       allOperationTimings.get(url) || [];
    allOperationTimings.set(url,
      previousOperationTimings.concat(end - start));
    return output;
  };
}</pre> <p class="calibre3">Using our decorator function is done as follows:</p>
<pre class="source-code">
const getJsonWithTiming = addTiming(getJson);</pre> <p class="calibre3">We can then invoke our instrumented function and check that it adds timings to our <code>allOperationTimings</code> <code>Map</code>:</p>
<pre class="source-code">
await getJsonWithTiming('https://ifconfig.io/all.json');
await getJsonWithTiming('https://ifconfig.io/all.json');
console.assert(
  allOperationTimings.size === 1,
  'operation timings tracks by url'
);
console.assert(
  allOperationTimings.get('https://ifconfig.io/all.json').
    length === 2,
  'operation timings tracks number of calls by url'
);</pre> <p class="calibre3">One thing you might’ve noticed is that our <code>addTiming</code> <em class="italic">is</em> still aware of the <code>getJson</code> interface (it knows to pass a URL parameter and that <code>getJson</code> returns a Promise object). We’ll leave it as an exercise for the reader to implement, but it would be possible to turn <code>addTiming</code> into<a id="_idIndexMarker082" class="pcalibre1 calibre6 pcalibre"/> a function that can instrument the operation time of <em class="italic">any</em> JavaScript function; the tricky part is to find a good key for our operations map.</p>
<p class="calibre3">In the next part of the chapter, we’ll look<a id="_idTextAnchor078" class="pcalibre1 calibre6 pcalibre"/> at the flyweight pattern.</p>
<h1 id="_idParaDest-43" class="calibre5"><a id="_idTextAnchor079" class="pcalibre1 calibre6 pcalibre"/>Flyweight in JavaScript</h1>
<p class="calibre3">The flyweight pattern is where the subset of object properties that have the same value are stored in shared “flyweight” objects.</p>
<p class="calibre3">The flyweight pattern is useful <a id="_idIndexMarker083" class="pcalibre1 calibre6 pcalibre"/>when generating large quantities of objects that share a<a id="_idTextAnchor080" class="pcalibre1 calibre6 pcalibre"/> subset of the same values.</p>
<h2 id="_idParaDest-44" class="calibre7"><a id="_idTextAnchor081" class="pcalibre1 calibre6 pcalibre"/>Implementation</h2>
<p class="calibre3">One concept from domain-driven <a id="_idIndexMarker084" class="pcalibre1 calibre6 pcalibre"/>design by Eric Evans is “value objects”. These value objects have the property that their contents matter more than their identity. Let’s take the example of a value object being a “coin” where, for the purposes of payment, two 50-cent coins are interchangeable.</p>
<p class="calibre3">Value objects are interchangeable and immutable (a 50-cent coin can’t become a 10-cent coin). These types of objects are therefore a great fit for the Flyweight pattern.</p>
<p class="calibre3">Not all properties of a “coin” are “value”-driven, for example, certain coins are made from certain materials and coins tend to be issued in a certain year. These two properties (material and year of issue) might be interesting to collectors and in this respect, real-world coins are not only value objects as two 1993 coins might be interesting in different ways in the context of a coin collection.</p>
<p class="calibre3">We therefore model our <code>Wallet</code> as containing <a id="_idIndexMarker085" class="pcalibre1 calibre6 pcalibre"/>a list of coins and our <code>Coin</code> as containing an amount (in cents or other “minor currency”), a currency, a year of issue, and a list of materials.</p>
<div><div><img alt="Figure 2.1: Class diagram where a Wallet has associated coins and methods to operate over them" src="img/B19109_02_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.1: Class diagram where a Wallet has associated coins and methods to operate over them</p>
<p class="calibre3">Our <code>CoinFlyweight</code> will be our “value object” and contain the <code>amount</code> and <code>currency</code>, as follows:</p>
<pre class="source-code">
class CoinFlyweight {
  /**
   * @param {Number} amount – amount in minor currency
   * @param {String} currency
   */
  constructor(amount, currency) {
    this.amount = amount;
    this.currency = currency;
  }
}</pre> <p class="calibre3">The key benefit of the flyweight pattern is that we can reuse our flyweight objects. In order to do so, we need to control the instantiation of the flyweights with a factory (as covered in <a href="B19109_01.xhtml#_idTextAnchor018" class="pcalibre1 calibre6 pcalibre"><em class="italic">Chapter 1</em></a><em class="italic">, Working with Creational Design Patterns</em>, The factory pattern in JavaScript section). We therefore define <code>CoinFlyweightFactory</code> with a static <code>get</code> method that takes the flyweight’s initialization parameters but only instantiates a new <code>CoinFlyweight</code> if one with the right amount and currency is not <a id="_idIndexMarker086" class="pcalibre1 calibre6 pcalibre"/>already present in memory. It also provides a <code>getCount</code> method to return the amount of flyweights currently instantiated:</p>
<pre class="source-code">
class CoinFlyweightFactory {
  static flyweights = {};
  static get(amount, currency) {
    const flyWeightKey = `${amount}-${currency}`;
    if (this.flyweights[flyWeightKey]) {
      return this.flyweights[flyWeightKey];
    }
    const instance = new CoinFlyweight(amount, currency);
    this.flyweights[flyWeightKey] = instance;
    return instance;
  }
  static getCount() {
    return Object.keys(this.flyweights).length;
  }
}</pre> <p class="calibre3">Another opportunity to use the Flyweight pattern is with materials. We can similarly create a <code>MaterialFlyweight</code> and reuse its values via a <code>MaterialFlyweightFactory</code>:</p>
<pre class="source-code">
class MaterialFlyweight {
  constructor(materialName) {
    this.name = materialName;
  }
}
class MaterialFlyweightFactory {
  static flyweights = {};
  static get(materialName) {
    if (this.flyweights[materialName]) {
      return this.flyweights[materialName];
    }
    const instance = new MaterialFlyweight(materialName);
    this.flyweights[materialName] = instance;
    return instance;
  }
  static getCount() {
    return Object.keys(this.flyweights).length;
  }
}</pre> <p class="calibre3">Finally, we can implement the <code>Coin</code> and <code>Wallet</code> classes. Our <code>Coin</code> instance has a <code>flyweight</code> field, which is<a id="_idIndexMarker087" class="pcalibre1 calibre6 pcalibre"/> populated using the <code>CoinFlyweightFactory</code>. The <code>Coin#materials</code> field is populated with a regular array but the array’s contents are of <code>MaterialFlyweight</code>, loaded using the <code>MaterialFlyweightFactory</code>:</p>
<pre class="source-code">
class Coin {
  constructor(amount, currency, yearOfIssue, materials) {
    this.flyweight = CoinFlyweightFactory.get
      (amount, currency);
    this.yearOfIssue = yearOfIssue;
    this.materials = materials.map((material) =&gt;
      MaterialFlyweightFactory.get(material)
    );
  }
}</pre> <p class="calibre3">The <code>Wallet</code> is a plain JavaScript object. Its <code>add </code>method creates a new <code>Coin</code> instance and pushes it into the <a id="_idIndexMarker088" class="pcalibre1 calibre6 pcalibre"/>Wallet’s <code>coins</code> field. <code>getTotalValueForCurrency</code> sums the coin’s values for a given currency:</p>
<pre class="source-code">
class Wallet {
  constructor() {
    this.coins = [];
  }
  add(amount, currency, yearOfIssue, materials) {
    const coin = new Coin(amount, currency, yearOfIssue,
      materials);
    this.coins.push(coin);
  }
  getCount() {
    return this.coins.length;
  }
  getTotalValueForCurrency(currency) {
    return this.coins
      .filter((coin) =&gt; coin.flyweight.currency ===
        currency)
      .reduce((acc, curr) =&gt; acc + curr.flyweight.amount, 0);
  }
}</pre> <p class="calibre3">The wallet can be used as <a id="_idIndexMarker089" class="pcalibre1 calibre6 pcalibre"/>follows, adding GBP and USD of different denominations:</p>
<pre class="source-code">
const wallet = new Wallet();
wallet.add(100, 'GBP', '2023', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2022', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2021', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2021', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(200, 'GBP', '2021', ['nickel-brass',
  'cupro-nickel']);
wallet.add(100, 'USD', '1990', ['copper', 'nickel']);
wallet.add(5, 'USD', '1990', ['copper', 'nickel']);
wallet.add(1, 'USD', '2010', ['copper', 'zinc']);</pre> <p class="calibre3">Note that while the wallet instance contains eight coins, we’ve created six <code>CoinFlyweight</code> and five <code>MaterialFlyweight</code> instances:</p>
<pre class="source-code">
console.assert(
  wallet.getCount() === 8,
  'wallet.add adds coin instances are created once given
    the same cache key'
);
console.assert(
  CoinFlyweightFactory.getCount() === 5,
  'CoinFlyweights are created once given the same
    cache key'
);
console.assert(
  MaterialFlyweightFactory.getCount() === 6,
  'MaterialFlyweights are created once given the same
     cache key'
);
console.assert(
  wallet.getTotalValueForCurrency('GBP') === 600,
  'Summing GBP works'
);
console.assert(
  wallet.getTotalValueForCurrency('USD') =<a id="_idTextAnchor082" class="pcalibre1 calibre16 pcalibre"/>== 106,
  'Summing USD works'
);</pre> <h2 id="_idParaDest-45" class="calibre7"><a id="_idTextAnchor083" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">The flyweight pattern is <a id="_idIndexMarker090" class="pcalibre1 calibre6 pcalibre"/>a normalization technique<a id="_idIndexMarker091" class="pcalibre1 calibre6 pcalibre"/> that reduces the memory footprint at the cost of cognitive overhead when accessing and running computations over objects using this pattern. Flyweight can be leveraged as a performance optimization when handling large numbers of objects.</p>
<p class="calibre3">It’s <em class="italic">very</em> well suited to modeling<a id="_idIndexMarker092" class="pcalibre1 calibre6 pcalibre"/> value objects as we’ve shown in the previous section. The only drawback was the <code>getTotalValueForCurrency</code>, where we had to read <code>coin.flyweight.<a id="_idTextAnchor084" class="pcalibre1 calibre6 pcalibre"/>currency</code> and <code>coin.flyweight.amount</code>.</p>
<h2 id="_idParaDest-46" class="calibre7"><a id="_idTextAnchor085" class="pcalibre1 calibre6 pcalibre"/>Improvements/limitations</h2>
<p class="calibre3">There are a few improvements we can <a id="_idIndexMarker093" class="pcalibre1 calibre6 pcalibre"/>make to our flyweight wallet/coin setup. A few of the improvements center on the “factories”. The <code>flyweights</code> shouldn’t really be accessed from outside of the <code>get</code> function, so we can make it a private field using <code>#flyweights</code>. We can also leverage the <code>Map</code> object, still with the same cache key, although <code>Map</code> has greater flexibility in terms of what keys can be used and a different property access interface (<code>.get(key)</code> instead of <code>[key]</code> access). Using a <code>Map</code> means we need to use <code>this.#flyweights.size</code> in <code>getCount</code>:</p>
<pre class="source-code">
class CoinFlyweightFactory {
  static #flyweights = new Map();
  static get(amount, currency) {
    const flyWeightKey = `${amount}-${currency}`;
    if (this.#flyweights.get(flyWeightKey)) {
      return this.#flyweights.get(flyWeightKey);
    }
    const instance = new CoinFlyweight(amount, currency);
    this.#flyweights.set(flyWeightKey, instance);
    return instance;
  }
  static getCount() {
    return this.#flyweights.size;
  }
}</pre> <p class="calibre3">Another change we’ll make is in light of the fact that there were not any material gains by making <code>materials</code> a flyweight, so we’ll revert it to storing the list of strings per <code>Coin</code> instance.</p>
<p class="calibre3">Again, we want to make <code>#flyweight</code> private, this will change the interface of <code>Coin</code> since consumers will not be able to access <code>coin.#flyweight</code> (it’s a private field).</p>
<p class="calibre3">What we’ll do is tackle the mismatch of having to read <code>coin.flyweight.amount</code> and <code>coin.flyweight.currency</code>. We’ll supply two getters, <code>get amount()</code> and <code>get currency()</code>, which will <a id="_idIndexMarker094" class="pcalibre1 calibre6 pcalibre"/>return <code>this.#flyweight.amount</code> and <code>this.#flyweight.currency</code> respectively:</p>
<pre class="source-code">
class Coin {
  #flyweight;
  constructor(amount, currency, yearOfIssue, materials) {
    this.#flyweight = CoinFlyweightFactory.get
      (amount, currency);
    this.yearOfIssue = yearOfIssue;
    this.materials = materials;
  }
  get amount() {
    return this.#flyweight.amount;
  }
  get currency() {
    return this.#flyweight.currency;
  }
}</pre> <p class="calibre3">As mentioned, the interface of <code>Coin</code> doesn’t have a <code>flyweight</code> property so <code>getTotalValueForCurrency</code> will read from <code>Coin#currency</code> and <code>Coin#amount</code>. As far as <code>Wallet</code> is concerned, <code>currency</code> and <code>amount</code> are fields on the <code>Coin</code> instance, although<a id="_idIndexMarker095" class="pcalibre1 calibre6 pcalibre"/> they’re getters:</p>
<pre class="source-code">
class Wallet {
  constructor() {
    this.coins = [];
  }
  add(amount, currency, yearOfIssue, materials) {
    const coin = new Coin(amount, currency, yearOfIssue,
      materials);
    this.coins.push(coin);
  }
  getCount() {
    return this.coins.length;
  }
  getTotalValueForCurrency(currency) {
    return this.coins
      .filter((coin) =&gt; coin.currency === currency)
      .reduce((acc, curr) =&gt; acc + curr.amount, 0);
  }
}</pre> <p class="calibre3">We can check that our new <code>Wallet</code> and <code>Coin</code> implementations work as expected by using the same tests as in our earlier iteration of the code:</p>
<pre class="source-code">
const wallet = new Wallet();
wallet.add(100, 'GBP', '2023', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2022', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2021', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2021', ['nickel-brass',
  'nickel-plated alloy']);
Wallet.add(200, 'GBP', '2021', ['nickel-brass',
  'cupro-nickel']);
wallet.add(100, 'USD', '1990', ['copper', 'nickel']);
wallet.add(5, 'USD', '1990', ['copper', 'nickel']);
wallet.add(1, 'USD', '2010', ['copper', 'zinc']);
console.assert(
  wallet.getCount() === 8,
  'wallet.add adds coin instances are created once
    given the same cache key'
);
console.assert(
  CoinFlyweightFactory.getCount() === 5,
  'CoinFlyweights are created once given the same
   cache key'
);
console.assert(
  wallet.getTotalValueForCurrency('GBP') === 600,
  'Summing GBP works'
);
console.assert(
  wallet.getTotalValueForCurrency('USD') === 106,
  'Summing USD works'
);</pre> <p class="calibre3">We’ve seen how the <a id="_idIndexMarker096" class="pcalibre1 calibre6 pcalibre"/>flyweight pattern can be used to optimize memory usage by using shared value objects.</p>
<p class="calibre3">In the next part of the chapter, we’ll look at the last structural design pattern covered in this b<a id="_idTextAnchor086" class="pcalibre1 calibre6 pcalibre"/>ook, the adapter pattern in JavaScript.</p>
<h1 id="_idParaDest-47" class="calibre5"><a id="_idTextAnchor087" class="pcalibre1 calibre6 pcalibre"/>Adapter in JavaScript</h1>
<p class="calibre3">The adapter pattern, similar to the other <a id="_idIndexMarker097" class="pcalibre1 calibre6 pcalibre"/>structural design patterns, focuses on interfaces.</p>
<p class="calibre3">In the adapter pattern’s case, it involves being able to use a new implementation without changing the consumer or the implementation’s interface. The “adapter” takes the new implementation and “adapts” the interface to match what the consumer expects.</p>
<p class="calibre3">We’re not changing the implementation <em class="italic">or</em> the consumer; rather, we’re building an adapter to wrap the implementation and plug it in<a id="_idTextAnchor088" class="pcalibre1 calibre6 pcalibre"/>to the consumer without changing either.</p>
<h3 class="calibre9">Implementation</h3>
<p class="calibre3">Let’s start with a simple in-memory <a id="_idIndexMarker098" class="pcalibre1 calibre6 pcalibre"/>database that uses a naive <code>IdGenerator</code> to generate keys for the database entries by encoding the object as a string.</p>
<p class="calibre3"><code>Database</code> has a <code>createEntry</code> method that stores given data using the <code>IdGenerator</code> to generate a key. <code>Database</code> also has a <code>get</code> method to recall entries by ID:</p>
<pre class="source-code">
class IdGenerator {
  get(entry) {
    return JSON.stringify(entry);
  }
}
class Database {
  constructor(idGenerator) {
    this.idGenerator = idGenerator;
    this.entries = {};
  }
  createEntry(entryData) {
    const id = this.idGenerator.get(entryData);
    this.entries[id] = entryData;
    return id;
  }
  get(id) {
    return this.entries[id];
  }
}</pre> <p class="calibre3">By composing <code>Database</code> with an <code>IdGenerator</code> instance, we get a key-value lookup database instance with<a id="_idIndexMarker099" class="pcalibre1 calibre6 pcalibre"/> the key equal to the JSON representation of the value:</p>
<pre class="source-code">
const naiveIdDatabase = new Database(new IdGenerator());
naiveIdDatabase.createEntry({
  name: 'pear',
});
console.assert(
  naiveIdDatabase.get('{"name":"pear"}').name === 'pear',
  'stringIdDatabase recalls entries by stringified entry'
);</pre> <p class="calibre3">Now, the naive ID generation that encodes the whole entry value in the key is not ideal. An alternative is to use a UUID. Here’s a <code>UuidFactory</code> using the <code>uuid</code> npm module. The key operation it exposes is <code>generateUuid</code>:</p>
<pre class="source-code">
import { v4 as uuidv4 } from 'uuid';
class UuidFactory {
  generateUuid() {
    return uuidv4();
  }
}</pre> <p class="calibre3">To use the <code>UuidFactory</code> with our <code>Database</code>, we would need a <code>get</code> method instead of a <code>generateUuid</code> method. This is <a id="_idIndexMarker100" class="pcalibre1 calibre6 pcalibre"/>where our adapter comes in – we can wrap the <code>UuidFactory</code> in a class that exposes <code>get(entry)</code> but calls <code>generateUuid</code> on the <code>UuidFactor</code> instance:</p>
<pre class="source-code">
class UuidIdGeneratorAdapter {
  constructor() {
    this.uuidFactory = new UuidFactory();
  }
  get(_entry) {
    return this.uuidFactory.generateUuid();
  }
}</pre> <p class="calibre3">The <code>UuidIdGeneratorAdapter</code> can then be passed as the <code>idGenerator</code> to <code>Database</code>. It all works as expected, where<a id="_idIndexMarker101" class="pcalibre1 calibre6 pcalibre"/> the entry IDs for the database are UUIDs:</p>
<pre class="source-code">
const uuidIdDatabase = new Database(new UuidIdGeneratorAdapter());
const uuidEntryId = uuidIdDatabase.createEntry({
  name: 'pear',
});
console.assert(
  uuidIdDatabase.get(uuidEntryId).name === 'pear',
  'uuidIdDatabase recalls entries by uuid'
);
import { validate as isUuid } from 'uuid';
console.assert(isUuid(uuidEntryId), 'uuidIdDatabase generated uuid ids');</pre> <p class="calibre3">Another example that makes use of the fact that the <code>entry</code> is being passed to <code>idGenerator.get()</code> is to generate prefixed auto-incrementing IDs based on the <code>entry</code> contents. Here, <code>name</code> will be used as the prefix. We have a <code>Counter</code> class that implements <code>getAndIncrement(prefix)</code>, which generates incrementing IDs given a prefix (or no prefix):</p>
<pre class="source-code">
class Counter {
  constructor(startValue = 1) {
    this.startValue = startValue;
    this.nextId = startValue;
    this.nextIdByPrefix = {};
  }
  getAndIncrement(prefix) {
    if (prefix) {
      if (!this.nextIdByPrefix[prefix]) {
        this.nextIdByPrefix[prefix] = this.startValue;
      }
      const nextId = this.nextIdByPrefix[prefix]++;
      return `${prefix}:${nextId}`;
    }
    return String(this.nextId++);
  }
}</pre> <p class="calibre3">Again, <code>getAndIncrement(prefix)</code> doesn’t match the <code>IdGenerator</code> interface (no <code>get</code> method). We can <a id="_idIndexMarker102" class="pcalibre1 calibre6 pcalibre"/>wrap <code>Counter</code> in a <code>PrefixedAutoIncrementIdGeneratorAdapter</code> to expose an <code>IdGenerator</code> interface but using the <code>Counter</code> implementation:</p>
<pre class="source-code">
class PrefixedAutoIncrementIdGeneratorAdapter {
  constructor() {
    this.counter = new Counter();
  }
  get(entry) {
    return this.counter.getAndIncrement(entry.name);
  }
}</pre> <p class="calibre3">We can ensure the prefixing logic works as expected for the <code>Database</code> since it creates entries keyed by prefixed auto-incrementing IDs:</p>
<pre class="source-code">
const prefixAutoIncrementDatabase = new Database(
  new PrefixedAutoIncrementIdGeneratorAdapter()
);</pre> <p class="calibre3">We can check that the case <a id="_idIndexMarker103" class="pcalibre1 calibre6 pcalibre"/>where no <code>name</code> field is set works as expected:</p>
<pre class="source-code">
const noPrefixIncrementingEntryId1 =
  prefixAutoIncrementDatabase.createEntry({
  type: 'no-prefix',
});
const noPrefixIncrementingEntryId2 =
  prefixAutoIncrementDatabase.createEntry({
  type: 'no-prefix',
});
console.assert(
  noPrefixIncrementingEntryId1 === '1' &amp;&amp;
    noPrefixIncrementingEntryId2 === '2',
  'prefixAutoIncrementDatabase generates autoincrementing
    ids with no prefix if no name property is set'
);
console.assert(
  prefixAutoIncrementDatabase.get
    (noPrefixIncrementingEntryId1).type ===
    'no-prefix' &amp;&amp;
    prefixAutoIncrementDatabase.get
      (noPrefixIncrementingEntryId2).type ===
      'no-prefix',
  'prefixAutoIncrementDatabase recalls entries by
     autoincrementing id'
);</pre> <p class="calibre3">And the scenarios where a <a id="_idIndexMarker104" class="pcalibre1 calibre6 pcalibre"/>prefix is available also functions correctly per the following example:</p>
<pre class="source-code">
const prefixIncrementingEntryIdPear1 =
  prefixAutoIncrementDatabase.createEntry({
  name: 'pear',
});
const prefixIncrementingEntryIdPear2 =
  prefixAutoIncrementDatabase.createEntry({
  name: 'pear',
});
const prefixIncrementingEntryIdApple1 =
  prefixAutoIncrementDatabase.createEntry(
  {
    name: 'apple',
  }
);
console.assert(
  prefixIncrementingEntryIdPear1 === 'pear:1' &amp;&amp;
    prefixIncrementingEntryIdPear2 === 'pear:2' &amp;&amp;
    prefixIncrementingEntryIdApple1 === 'apple:1',
  'prefixAutoIncrementDatabase generates prefixed
    autoincrementing ids'
);
console.assert(
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdPear1).name ===
    'pear',
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdPear2).name ===
    'pear',
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdApple1).name ===
    'apple',
  'prefixAutoIncrementD<a id="_idTextAnchor089" class="pcalibre1 calibre16 pcalibre"/>atabase recalls entries by prefixed
    id'
);</pre> <h2 id="_idParaDest-48" class="calibre7"><a id="_idTextAnchor090" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">The adapter pattern is useful when <a id="_idIndexMarker105" class="pcalibre1 calibre6 pcalibre"/>you need to use two classes that weren’t specifically designed to work together. Consider, for example, a third-party library or module that exposes a function (such as the <code>uuid</code> module or even <code>UuidFactory</code> from our scenario). We want to abstract the implementation behind an interface, in our case the interface of <code>IdGenerator</code>, which is just a <code>get</code> method, so that any implementation can be used.</p>
<p class="calibre3">Our example showcased the value of the adapter pattern. We were able to create very differently behaving databases without changing <code>UuidFactory</code>, <code>Counter</code>, or <code>Database</code> for that matter. This is very important when having to connect two third-party modules or modules which are self-contained and shouldn’t be changed.</p>
<p class="calibre3">Using the adapter pattern therefore<a id="_idIndexMarker106" class="pcalibre1 calibre6 pcalibre"/> means that we can avoid changing difficult-to-understand <a id="_idTextAnchor091" class="pcalibre1 calibre6 pcalibre"/>code while delivering the required functionality.</p>
<h2 id="_idParaDest-49" class="calibre7"><a id="_idTextAnchor092" class="pcalibre1 calibre6 pcalibre"/>Improvements/limitations</h2>
<p class="calibre3">Similarly, to the <em class="italic">Decorator in JavaScript - Improvements/limitations</em> section, one of the JavaScript features that can help <a id="_idIndexMarker107" class="pcalibre1 calibre6 pcalibre"/>when implementing structural design patterns is the first-class support for functions.</p>
<p class="calibre3">Instead of an <code>IdGenerator</code> class, we can have a <code>defaultIdGenerator</code> function that takes an entry and returns a string:</p>
<pre class="source-code">
function defaultIdGenerator(entry) {
  return JSON.stringify(entry);
}</pre> <p class="calibre3">The <code>Database</code> class would now look something as follows, where <code>this.idGenerator(entryData)</code> is called directly:</p>
<pre class="source-code">
class Database {
  constructor(idGenerator) {
    this.idGenerator = idGenerator;
    this.entries = {};
  }
  createEntry(entryData) {
    const id = this.idGenerator(entryData);
    this.entries[id] = entryData;
    return id;
  }
  get(id) {
    return this.entries[id];
  }
}</pre> <p class="calibre3">We can validate that the naive<a id="_idIndexMarker108" class="pcalibre1 calibre6 pcalibre"/> implementation still works by serializing whatever is passed to it as JSON:</p>
<pre class="source-code">
const naiveIdDatabase = new Database(defaultIdGenerator);
naiveIdDatabase.createEntry({
  name: 'pear',
});
console.assert(
  naiveIdDatabase.get('{"name":"pear"}').name === 'pear',
  'stringIdDatabase recalls entries by stringified entry'
);</pre> <p class="calibre3">This approach shines when we need to plug in the UUID and prefix generators.</p>
<p class="calibre3">A <code>uuidGenerator</code> function can call <code>uuidv4()</code>. We can validate that <code>uuidIdDatabase</code> uses UUIDs to key and recall the entries:</p>
<pre class="source-code">
function uuidGenerator() {
  return uuidv4();
}
const uuidIdDatabase = new Database(uuidGenerator);
const uuidEntryId = uuidIdDatabase.createEntry({
  name: 'pear',
});
console.assert(
  uuidIdDatabase.get(uuidEntryId).name === 'pear',
  'uuidIdDatabase recalls entries by uuid'
);
console.assert(isUuid(uuidEntryId), 'uuidIdDatabase
  generated uuid ids');</pre> <p class="calibre3">Finally, a <code>prefixAutoIncrementIdGenerator</code> would look as follows. We’re using module-scoped variables, which is <a id="_idIndexMarker109" class="pcalibre1 calibre6 pcalibre"/>another feature of JavaScript:</p>
<pre class="source-code">
const startValue = 1;
let nextId = startValue;
let nextIdByPrefix = {};
function prefixAutoIncrementIdGenerator(entry) {
  const prefix = entry.name;
  if (prefix) {
    if (!nextIdByPrefix[prefix]) {
      nextIdByPrefix[prefix] = startValue;
    }
    const nextId = nextIdByPrefix[prefix]++;
    return `${prefix}:${nextId}`;
  }
  return String(nextId++);
}</pre> <p class="calibre3">This code would be in a different module than its consumer, so it would be <code>export function prefixAutoIncrementIdGenerator</code> and its consumer would import <code>{prefixAutoIncrementIdGenerator}</code> from <code>'./path-to-module.js'</code>.</p>
<p class="calibre3"><code>prefixAutoIncrementIdGenerator</code> functions like the <code>PrefixedAutoIncrementIdGeneratorAdapter</code> class did, generating auto-incrementing IDs and<a id="_idIndexMarker110" class="pcalibre1 calibre6 pcalibre"/> prefixing them where possible by <code>entry.name</code>:</p>
<pre class="source-code">
const prefixAutoIncrementDatabase = new Database(
  prefixAutoIncrementIdGenerator
);
const noPrefixIncrementingEntryId1 =
  prefixAutoIncrementDatabase.createEntry({
  type: 'no-prefix',
});
const noPrefixIncrementingEntryId2 =
  prefixAutoIncrementDatabase.createEntry({
  type: 'no-prefix',
});
console.assert(
  noPrefixIncrementingEntryId1 === '1' &amp;&amp;
    noPrefixIncrementingEntryId2 === '2',
  'prefixAutoIncrementDatabase generates autoincrementing
     ids with no prefix if no name property is set'
);
console.assert(
  prefixAutoIncrementDatabase.get
    (noPrefixIncrementingEntryId1).type ===
    'no-prefix' &amp;&amp;
    prefixAutoIncrementDatabase.get
      (noPrefixIncrementingEntryId2).type ===
      'no-prefix',
  'prefixAutoIncrementDatabase recalls entries by
    autoincrementing id'
);
const prefixIncrementingEntryIdPear1 =
  prefixAutoIncrementDatabase.createEntry({
  name: 'pear',
});
const prefixIncrementingEntryIdPear2 =
  prefixAutoIncrementDatabase.createEntry({
  name: 'pear',
});
const prefixIncrementingEntryIdApple1 =
  prefixAutoIncrementDatabase.createEntry(
  {
    name: 'apple',
  }
);
console.assert(
  prefixIncrementingEntryIdPear1 === 'pear:1' &amp;&amp;
    prefixIncrementingEntryIdPear2 === 'pear:2' &amp;&amp;
    prefixIncrementingEntryIdApple1 === 'apple:1',
  'prefixAutoIncrementDatabase generates prefixed
    autoincrementing ids'
);
console.assert(
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdPear1).name ===
    'pear',
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdPear2).name ===
    'pear',
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdApple1).name ===
    'apple',
  'prefixAutoIncrementDatabase recalls entries by prefixed
    id'
);</pre> <p class="calibre3">In this final section of the<a id="_idIndexMarker111" class="pcalibre1 calibre6 pcalibre"/> chapter, we covered the adapter pattern and how to use it when the consu<a id="_idTextAnchor093" class="pcalibre1 calibre6 pcalibre"/>mer expects a class but also a function in JavaScript.</p>
<h1 id="_idParaDest-50" class="calibre5"><a id="_idTextAnchor094" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we’ve looked at how structural design patterns enable the extension of functionality without needing to rework interfaces in JavaScript.</p>
<p class="calibre3">The proxy design pattern is useful when we want to intercept calls to an object without changing the interface.</p>
<p class="calibre3">By contrast, the decorator design pattern concerns itself with dynamically adding functionality through new instance members.</p>
<p class="calibre3">The flyweight pattern can be used effectively for managing large numbers of objects, which is especially useful for value objects. There are workarounds in JavaScript for some of the ergonomic drawbacks of it.</p>
<p class="calibre3">The adapter pattern allows us to integrate multiple classes, modules, or functions with different opinions and interfaces without modifying them. The shape of the adapter is dictated by the existing modules and classes that we’re attempting to connect together.</p>
<p class="calibre3">Now that we know how to organize relationships between different objects and classes with structural design patterns, in the next chapter, we’ll cover how to use behavioral design patterns to organize communication between objects.</p>
</div>
</body></html>