<html><head></head><body>
<div id="_idContainer010" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor057" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor058" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-32" class="calibre5"><a id="_idTextAnchor059" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1"> Implementing Structural Design Patterns</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Structural design patterns give us tools to handle </span><em class="italic"><span class="kobospan" id="kobo.4.1">connecting</span></em><span class="kobospan" id="kobo.5.1"> different objects; in other words, managing the relationships between objects. </span><span class="kobospan" id="kobo.5.2">This includes techniques to reduce memory usage and develop functionality with existing classes without modifying these existing classes. </span><span class="kobospan" id="kobo.5.3">In addition, JavaScript features allow us to more effectively apply these patterns. </span><span class="kobospan" id="kobo.5.4">Modern JavaScript includes some built-ins that allow us to implement structural design patterns in a more </span><span><span class="kobospan" id="kobo.6.1">efficient manner.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">We’ll cover the following topics in </span><span><span class="kobospan" id="kobo.8.1">this chapter:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Defining structural design patterns as a whole, and proxy, decorator, flyweight, and </span><span><span class="kobospan" id="kobo.10.1">adapter specifically</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">An implementation of the proxy pattern with a class-based approach as well as an alternative using Proxy </span><span><span class="kobospan" id="kobo.12.1">and Reflect</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Multiple implementations of the decorator pattern, leveraging JavaScript first-class support </span><span><span class="kobospan" id="kobo.14.1">for functions</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.15.1">An iterative approach to implementing flyweight in JavaScript, including ergonomic improvements using modern </span><span><span class="kobospan" id="kobo.16.1">JavaScript features</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.17.1">Class- and function-based </span><span><span class="kobospan" id="kobo.18.1">adapter implementations</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.19.1">At the end of this chapter, you’ll be able to make informed decisions on when and how to use structural design patterns </span><span><span class="kobospan" id="kobo.20.1">in JavaScript.</span></span></p>
<h1 id="_idParaDest-33" class="calibre5"><a id="_idTextAnchor060" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.21.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.22.1">You can find the code files for this chapter on GitHub </span><span><span class="kobospan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.24.1">https://github.com/PacktPublishing/Javascript-Design-Patterns</span></span></a></p>
<h1 id="_idParaDest-34" class="calibre5"><a id="_idTextAnchor061" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.25.1">What are structural design patterns?</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">When building software, we want to be able to </span><em class="italic"><span class="kobospan" id="kobo.27.1">connect</span></em><span class="kobospan" id="kobo.28.1"> different pieces of code (e.g., classes and functions) and change how the parties involved in these connections and relationships interact without</span><a id="_idIndexMarker056" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.29.1"> having to jump through multiple fragmented parts of </span><span><span class="kobospan" id="kobo.30.1">the codebase.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">Structural design patterns allow us to add, remove, and change functionality in modules and classes safely. </span><span class="kobospan" id="kobo.31.2">The “structural” aspect of these patterns is due to the fact that we can play around with implementations if the exposed interfaces </span><span><span class="kobospan" id="kobo.32.1">are stable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.33.1">Structural design patterns are a good way to maintain the separation of concerns and loose coupling of different classes and modules while maintaining a high </span><span><span class="kobospan" id="kobo.34.1">development velocity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">In the next section, we’ll look at multiple approaches to implement the Proxy pattern </span><span><span class="kobospan" id="kobo.36.1">in JavaScript.</span></span><a id="_idTextAnchor062" class="pcalibre1 calibre6 pcalibre"/></p>
<h1 id="_idParaDest-35" class="calibre5"><a id="_idTextAnchor063" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.37.1">Implementing the Proxy pattern with Proxy and Reflect</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.38.1">The proxy pattern involves</span><a id="_idIndexMarker057" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.39.1"> providing an object (the </span><strong class="source-inline"><span class="kobospan" id="kobo.40.1">subject</span></strong><span class="kobospan" id="kobo.41.1">, or </span><strong class="source-inline"><span class="kobospan" id="kobo.42.1">real</span></strong><span class="kobospan" id="kobo.43.1"> object) that fulfills a certain interface. </span><span class="kobospan" id="kobo.43.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.44.1">proxy</span></strong><span class="kobospan" id="kobo.45.1"> (a </span><strong class="source-inline"><span class="kobospan" id="kobo.46.1">placeholder</span></strong><span class="kobospan" id="kobo.47.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.48.1">wrapper</span></strong><span class="kobospan" id="kobo.49.1"> object) controls access to the </span><strong class="source-inline"><span class="kobospan" id="kobo.50.1">subject</span></strong><span class="kobospan" id="kobo.51.1">. </span><span class="kobospan" id="kobo.51.2">This allows us to provide additional functionality on top of the </span><a id="_idIndexMarker058" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.52.1">subject without changing a</span><a id="_idIndexMarker059" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.53.1"> consumer’s interactions with </span><span><span class="kobospan" id="kobo.54.1">the </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.55.1">subject</span></strong></span><span><span class="kobospan" id="kobo.56.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.57.1">This means that a proxy needs to provide an interface matching </span><span><span class="kobospan" id="kobo.58.1">the </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.59.1">subject</span></strong></span><span><span class="kobospan" id="kobo.60.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.61.1">By using the proxy pattern, we can intercept all operations on the original object and either pass them through or change their implementation. </span><span class="kobospan" id="kobo.61.2">This follows the open/closed principle, where both the </span><strong class="source-inline"><span class="kobospan" id="kobo.62.1">subject</span></strong><span class="kobospan" id="kobo.63.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.64.1">consumer</span></strong><span class="kobospan" id="kobo.65.1"> are closed for modification, but the proxy provides us with a hook to </span><strong class="source-inline"><span class="kobospan" id="kobo.66.1">extend</span></strong><span class="kobospan" id="kobo.67.1">, which means the design is open </span><span><span class="kobospan" id="kobo.68.1">to extensi</span><a id="_idTextAnchor064" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.69.1">on.</span></span></p>
<h2 id="_idParaDest-36" class="calibre7"><a id="_idTextAnchor065" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.70.1">A redaction proxy implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.71.1">We’ll start with the following</span><a id="_idIndexMarker060" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.72.1"> implementation class that has</span><a id="_idIndexMarker061" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.73.1"> a couple of methods that </span><span><span class="kobospan" id="kobo.74.1">output strings:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.75.1">
class Implementation {
  someFn() {
    return 'some-output';
  }
  sensitiveFn() {
    return 'sensitive-output';
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.76.1">Let’s imagine that the </span><strong class="source-inline"><span class="kobospan" id="kobo.77.1">sensitive</span></strong><span class="kobospan" id="kobo.78.1"> string in the output should </span><span><span class="kobospan" id="kobo.79.1">be redacted.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.80.1">Here’s how a </span><strong class="source-inline"><span class="kobospan" id="kobo.81.1">RedactionProxy</span></strong><span class="kobospan" id="kobo.82.1"> class </span><span><span class="kobospan" id="kobo.83.1">could look:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.84.1">
class RedactionProxy {
  constructor() {
    this.impl = new Implementation();
  }
  someFn() {
    return this.impl.someFn();
  }
  sensitiveFn() {
    return this.impl.sensitiveFn().replace('sensitive',
      '[REDACTED]');
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.85.1">In this case, </span><strong class="source-inline"><span class="kobospan" id="kobo.86.1">RedactionProxy</span></strong><span class="kobospan" id="kobo.87.1"> does what we call a </span><strong class="bold"><span class="kobospan" id="kobo.88.1">pass-through</span></strong><span class="kobospan" id="kobo.89.1"> of </span><strong class="source-inline"><span class="kobospan" id="kobo.90.1">someFn()</span></strong><span class="kobospan" id="kobo.91.1"> calls. </span><span class="kobospan" id="kobo.91.2">In other words, </span><strong class="source-inline"><span class="kobospan" id="kobo.92.1">RedactionProxy#someFn</span></strong><span class="kobospan" id="kobo.93.1"> simply forwards the </span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">someFn</span></strong><span class="kobospan" id="kobo.95.1"> call to </span><strong class="source-inline"><span class="kobospan" id="kobo.96.1">Implementation</span></strong><span class="kobospan" id="kobo.97.1">. </span><span class="kobospan" id="kobo.97.2">See the</span><a id="_idIndexMarker062" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.98.1">following</span></span><span><a id="_idIndexMarker063" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.99.1"> illustration:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.100.1">
const redactionProxy = new RedactionProxy();
console.assert(
  redactionProxy.someFn() === newImplementation().someFn(),
    'Proxy implementation calls through to original'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.101.1">When it comes to </span><strong class="source-inline"><span class="kobospan" id="kobo.102.1">sensitiveFn</span></strong><span class="kobospan" id="kobo.103.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.104.1">RedactionProxy</span></strong><span class="kobospan" id="kobo.105.1"> implements the same interface as </span><strong class="source-inline"><span class="kobospan" id="kobo.106.1">Implementation</span></strong><span class="kobospan" id="kobo.107.1"> except it overrides the output, replacing </span><strong class="source-inline"><span class="kobospan" id="kobo.108.1">sensitive</span></strong> <span><span class="kobospan" id="kobo.109.1">with </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.110.1">[REDACTED]</span></strong></span><span><span class="kobospan" id="kobo.111.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.112.1">This means the interface for </span><strong class="source-inline"><span class="kobospan" id="kobo.113.1">RedactionProxy</span></strong><span class="kobospan" id="kobo.114.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.115.1">Implementation</span></strong><span class="kobospan" id="kobo.116.1"> is the same, but </span><strong class="source-inline"><span class="kobospan" id="kobo.117.1">RedactionProxy </span></strong><span class="kobospan" id="kobo.118.1">can control which method calls and fields are available along with their implementation. </span><span class="kobospan" id="kobo.118.2">See the following example of </span><span><span class="kobospan" id="kobo.119.1">this behavior:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.120.1">
console.assert(
  redactionProxy.sensitiveFn() !== new
    Implementation().sensitiveFn()&amp;&amp;
      redactionProxy.sensitiveFn() === '[REDACTED]-output',
      'Proxy implementation adds new behavi</span><a id="_idTextAnchor066" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.121.1">our'
);</span></pre> <h2 id="_idParaDest-37" class="calibre7"><a id="_idTextAnchor067" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.122.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.123.1">The proxy pattern allows us to intercept calls to an object (the </span><strong class="source-inline"><span class="kobospan" id="kobo.124.1">implementation</span></strong><span class="kobospan" id="kobo.125.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.126.1">subject</span></strong><span class="kobospan" id="kobo.127.1">) and augment them, either</span><a id="_idIndexMarker064" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.128.1"> by manipulating the output or by adding </span><span><span class="kobospan" id="kobo.129.1">a side-effect.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.130.1">Our example of redaction is a good use case for it, but any other type of instrumentation is also a good use case. </span><span class="kobospan" id="kobo.130.2">The instrumentation could be concerned with measuring something about a function/field access (e.g. </span><span class="kobospan" id="kobo.130.3">the time it takes) or ensuring access to a property triggers a certain effect. </span><span class="kobospan" id="kobo.130.4">For example, the </span><strong class="bold"><span class="kobospan" id="kobo.131.1">reactivity</span></strong><span class="kobospan" id="kobo.132.1"> system of Vue.js and Alpine.js is based on proxies, where a JavaScript Proxy object is used to wrap the reactive data objects. </span><span class="kobospan" id="kobo.132.2">This allows the library (Vue or Alpine) to detect when properties are changed and</span><a id="_idIndexMarker065" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.133.1"> run things such as watchers, effects, </span><span><span class="kobospan" id="kobo.134.1">and re</span><a id="_idTextAnchor068" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.135.1">-renders.</span></span></p>
<h2 id="_idParaDest-38" class="calibre7"><a id="_idTextAnchor069" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.136.1">Improving the proxy pattern in JavaScript with the Proxy and Reflect global objects</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.137.1">Back to our example, what happens when</span><a id="_idIndexMarker066" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.138.1"> we need to redact </span><span><span class="kobospan" id="kobo.139.1">more functions?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.140.1">Let’s take an </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">Implementation</span></strong><span class="kobospan" id="kobo.142.1"> class with three methods (</span><strong class="source-inline"><span class="kobospan" id="kobo.143.1">someFn</span></strong><span class="kobospan" id="kobo.144.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.145.1">sensitiveFn</span></strong><span class="kobospan" id="kobo.146.1">, </span><span><span class="kobospan" id="kobo.147.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.148.1">otherSensitiveFn</span></strong></span><span><span class="kobospan" id="kobo.149.1">):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.150.1">
class Implementation {
  someFn() {
    return 'sensitive-some-output';
  }
  sensitiveFn() {
    return 'sensitive-output';
  }
  otherSensitiveFn() {
    return 'sensitive-other-output';
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.151.1">A naïve implementation of an extended proxy looks as follows, where each method calls the implementation’s method and then replaces </span><strong class="source-inline"><span class="kobospan" id="kobo.152.1">sensitive</span></strong><span class="kobospan" id="kobo.153.1"> in </span><span><span class="kobospan" id="kobo.154.1">its output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.155.1">
class RedactionProxyNaive {
  constructor() {
    this.impl = new Implementation();
  }
  someFn() {
    return this.impl.someFn().replace
      ('sensitive', '[REDACTED]');
  }
  sensitiveFn() {
    return this.impl.sensitiveFn().replace('sensitive',
      '[REDACTED]');
  }
  otherSensitiveFn() {
    return this.impl.otherSensitiveFn().
</span><span class="kobospan1" id="kobo.155.2">      replace('sensitive', '[REDACTED]');
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.156.1">This implementation of the </span><strong class="source-inline"><span class="kobospan" id="kobo.157.1">Proxy</span></strong><span class="kobospan" id="kobo.158.1"> works, as we </span><a id="_idIndexMarker067" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.159.1">can ensure with the </span><span><span class="kobospan" id="kobo.160.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.161.1">
console.assert(
  !new RedactionProxyNaive().someFn().includes('sensitive')
    &amp;&amp;
    !new RedactionProxyNaive().sensitiveFn().includes
      ('sensitive') &amp;&amp;
    !new RedactionProxyNaive().otherSensitiveFn().includes
      ('sensitive'),
  'naive proxy redacts correctly'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.162.1">One improvement we can make here is to extract a </span><strong class="source-inline"><span class="kobospan" id="kobo.163.1">#redact</span></strong><span class="kobospan" id="kobo.164.1"> private method to handle the replacement </span><a id="_idIndexMarker068" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.165.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.166.1">sensitive</span></strong></span><span><span class="kobospan" id="kobo.167.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.168.1">
class RedactionProxyNaiveRefactored {
  constructor() {
    this.impl = new Implementation();
  }
  #redact(str) {
    return str.replace('sensitive', '[REDACTED]');
  }
  someFn() {
    return this.#redact(this.impl.someFn());
  }
  sensitiveFn() {
    return this.#redact(this.impl.sensitiveFn());
  }
  otherSensitiveFn() {
    return this.#redact(this.impl.otherSensitiveFn());
  }
}
console.assert(
  !new RedactionProxyNaiveRefactored().someFn().includes
    ('sensitive') &amp;&amp;
    !new RedactionProxyNaiveRefactored().sensitiveFn().
</span><span class="kobospan1" id="kobo.168.2">      includes('sensitive') &amp;&amp;
    !new RedactionProxyNaiveRefactored()
      .otherSensitiveFn()
      .includes('sensitive'),
  'refactored naive proxy redacts correctly'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.169.1">The downside of this approach is that every method on the </span><strong class="source-inline"><span class="kobospan" id="kobo.170.1">Implementation</span></strong><span class="kobospan" id="kobo.171.1"> object (the subject) will require a </span><a id="_idIndexMarker069" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.172.1">change to our </span><span><span class="kobospan" id="kobo.173.1">Proxy implementation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.174.1">Fortunately, JavaScript has a built-in class to programmatically manage these situations. </span><span class="kobospan" id="kobo.174.2">The JavaScript class is aptly </span><span><span class="kobospan" id="kobo.175.1">called </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.176.1">Proxy</span></strong></span><span><span class="kobospan" id="kobo.177.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.178.1">Let’s take the following plain JavaScript object (this also works for class instances) with both fields </span><span><span class="kobospan" id="kobo.179.1">and functions:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.180.1">
const obj = {
  someFn() {
    return 'sensitive-some-output';
  },
  sensitiveFn() {
    return 'sensitive-output';
  },
  otherSensitiveFn() {
    return 'sensitive-other-output';
  },
  field: 'sensitive-data',
  sensitiveField: 'redact-everything',
};</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.181.1">We want to be able to completely redact (i.e., keep none of the original output) those fields that contain </span><strong class="source-inline"><span class="kobospan" id="kobo.182.1">sensitive</span></strong><span class="kobospan" id="kobo.183.1"> in the field or method name. </span><span class="kobospan" id="kobo.183.2">We also want to have a value redaction functionality when the output contains the string </span><strong class="source-inline"><span class="kobospan" id="kobo.184.1">sensitive</span></strong><span class="kobospan" id="kobo.185.1">, where we replace </span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">sensitive</span></strong> <span><span class="kobospan" id="kobo.187.1">with </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.188.1">[REDACTED]</span></strong></span><span><span class="kobospan" id="kobo.189.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.190.1">To achieve this, we define a Proxy that will wrap our </span><strong class="source-inline"><span class="kobospan" id="kobo.191.1">obj</span></strong><span class="kobospan" id="kobo.192.1"> object. </span><span class="kobospan" id="kobo.192.2">We instantiate the Proxy with a “get trap,” which allows us to intercept all property accesses (which includes </span><span><span class="kobospan" id="kobo.193.1">function access).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.194.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.195.1">get</span></strong><span class="kobospan" id="kobo.196.1"> function receives a </span><strong class="source-inline"><span class="kobospan" id="kobo.197.1">target</span></strong><span class="kobospan" id="kobo.198.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">property</span></strong><span class="kobospan" id="kobo.200.1">. </span><span class="kobospan" id="kobo.200.2">The target is the object being wrapped (</span><strong class="source-inline"><span class="kobospan" id="kobo.201.1">obj</span></strong><span class="kobospan" id="kobo.202.1">), </span><strong class="source-inline"><span class="kobospan" id="kobo.203.1">property</span></strong><span class="kobospan" id="kobo.204.1"> is the property </span><span><span class="kobospan" id="kobo.205.1">being accessed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">Based on whether </span><strong class="source-inline"><span class="kobospan" id="kobo.207.1">target[property]</span></strong><span class="kobospan" id="kobo.208.1"> is a function or not, we’ll replace it with a wrapper function that will collect all the arguments, call </span><strong class="source-inline"><span class="kobospan" id="kobo.209.1">target[property]</span></strong><span class="kobospan" id="kobo.210.1"> with those arguments, intercept the</span><a id="_idIndexMarker070" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.211.1"> output, and replace </span><strong class="source-inline"><span class="kobospan" id="kobo.212.1">sensitive</span></strong><span class="kobospan" id="kobo.213.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">[REDACTED]</span></strong><span class="kobospan" id="kobo.215.1">. </span><span class="kobospan" id="kobo.215.2">We also return </span><strong class="source-inline"><span class="kobospan" id="kobo.216.1">[REDACTED]</span></strong><span class="kobospan" id="kobo.217.1"> if the property name includes </span><strong class="source-inline"><span class="kobospan" id="kobo.218.1">sensitive</span></strong><span class="kobospan" id="kobo.219.1"> (in our case, </span><span><span class="kobospan" id="kobo.220.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">sensitiveFn</span></strong></span><span><span class="kobospan" id="kobo.222.1">).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.223.1">In cases where </span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">target[property]</span></strong><span class="kobospan" id="kobo.225.1"> is not a function, we’ll do a full redaction if the property name includes </span><strong class="source-inline"><span class="kobospan" id="kobo.226.1">sensitive</span></strong><span class="kobospan" id="kobo.227.1"> and also replace </span><strong class="source-inline"><span class="kobospan" id="kobo.228.1">sensitive</span></strong><span class="kobospan" id="kobo.229.1"> in the output for all </span><span><span class="kobospan" id="kobo.230.1">other properties:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.231.1">
const redactedObjProxy = new Proxy(obj, {
  get(target, property, _receiver) {
    if (target[property] instanceof Function) {
      return (...args) =&gt; {
        if (property.includes('sensitive')) {
          return '[REDACTED]';
        }
        const output = target[property](...args);
        if (typeof output === 'string') {
          return output.replace('sensitive', '[REDACTED]');
        }
        return output;
      };
    }
    if (property.includes('sensitive')) {
      return '[REDACTED]';
    }
    return target[property].replace('sensitive',
      '[REDACTED]');
  },
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.232.1">The following code ensures our Proxy implementation works as expected. </span><strong class="source-inline"><span class="kobospan" id="kobo.233.1">sensitive</span></strong><span class="kobospan" id="kobo.234.1"> is not present in any of the function </span><a id="_idIndexMarker071" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.235.1">output or in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.236.1">field</span></strong></span><span><span class="kobospan" id="kobo.237.1"> value:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.238.1">
console.assert(
  !redactedObjProxy.someFn().includes('sensitive') &amp;&amp;
    !redactedObjProxy.sensitiveFn().includes('sensitive') &amp;&amp;
    !redactedObjProxy.otherSensitiveFn().includes
      ('sensitive'),
  'JavaScript Proxy redacts correctly for all functions'
);
console.assert(
  !redactedObjProxy.field.includes('sensitive'),
  'JavaScript Proxy redacts field values by value
    correctly'
);
console.assert(
  redactedObjProxy.sensitiveField === '[REDACTED]',
  'JavaScript Proxy redacts field values by property name
    correctly'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.239.1">One of the key benefits is the simplicity of the setup; all the redaction logic is contained in the </span><strong class="source-inline"><span class="kobospan" id="kobo.240.1">get</span></strong><span class="kobospan" id="kobo.241.1"> function, which keeps </span><span><span class="kobospan" id="kobo.242.1">it localized.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.243.1">As an effect of the co-located </span><a id="_idIndexMarker072" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.244.1">logic, we’ve been able to add redaction by property name in addition to </span><span><span class="kobospan" id="kobo.245.1">redacting values.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.246.1">There are still some slight issues with our current Proxy-based approach since we’re losing the </span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">this</span></strong><span class="kobospan" id="kobo.248.1"> context on functions. </span><span class="kobospan" id="kobo.248.2">We call </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">target[property](...args)</span></strong><span class="kobospan" id="kobo.250.1">, which is fine as long as our object is not accessing </span><strong class="source-inline"><span class="kobospan" id="kobo.251.1">this</span></strong><span class="kobospan" id="kobo.252.1">. </span><span class="kobospan" id="kobo.252.2">We’ll further refactor our implementation to make further extension easier, as well as leveraging the </span><strong class="source-inline"><span class="kobospan" id="kobo.253.1">Reflect</span></strong><span class="kobospan" id="kobo.254.1"> global built-in object to simplify </span><span><span class="kobospan" id="kobo.255.1">our code.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.256.1">Reflect</span></strong><span class="kobospan" id="kobo.257.1"> provides functions with the same name as the </span><strong class="source-inline"><span class="kobospan" id="kobo.258.1">Proxy</span></strong><span class="kobospan" id="kobo.259.1"> trap with the same arguments; for example, </span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">Reflect.get(target, </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.261.1">property, receiver)</span></strong></span><span><span class="kobospan" id="kobo.262.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.263.1">We’ll extract a </span><strong class="source-inline"><span class="kobospan" id="kobo.264.1">redact</span></strong><span class="kobospan" id="kobo.265.1"> function, which takes a </span><strong class="source-inline"><span class="kobospan" id="kobo.266.1">propertyName</span></strong><span class="kobospan" id="kobo.267.1"> and a </span><strong class="source-inline"><span class="kobospan" id="kobo.268.1">redactionValue</span></strong><span class="kobospan" id="kobo.269.1">. </span><span class="kobospan" id="kobo.269.2">It will keep our redaction logic even more in sync by abstracting it to a </span><span><span class="kobospan" id="kobo.270.1">separate function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.271.1">
const redact = (propertyName, redactionValue) =&gt; {
  if (propertyName.includes('sensitive')) {
    return '[REDACTED]';
  }
  if (typeof redactionValue === 'string') {
    return redactionValue.replace('sensitive','[REDACTED]'
    );
  }
  // Could implement redaction of objects/Arrays and so on
  return redactionValue;
};</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.272.1">We can then use </span><strong class="source-inline"><span class="kobospan" id="kobo.273.1">redact</span></strong><span class="kobospan" id="kobo.274.1"> where necessary, use </span><strong class="source-inline"><span class="kobospan" id="kobo.275.1">Reflect.get()</span></strong><span class="kobospan" id="kobo.276.1"> as a shortcut to </span><strong class="source-inline"><span class="kobospan" id="kobo.277.1">target[property]</span></strong><span class="kobospan" id="kobo.278.1">, and</span><a id="_idIndexMarker073" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.279.1"> use </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">Reflect.apply</span></strong><span class="kobospan" id="kobo.281.1"> to maintain the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">this</span></strong></span><span><span class="kobospan" id="kobo.283.1"> context:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.284.1">
const redactedObjProxyImproved = new Proxy(obj, {
  get(target, property, receiver) {
    const targetPropertyValue = Reflect.get(target,
      property, receiver);
    if (targetPropertyValue instanceof Function) {
      return (...args) =&gt; {
        const output = Reflect.apply(
          targetPropertyValue,
          this === receiver ? </span><span class="kobospan1" id="kobo.284.2">this : target,
          args
        );
        return redact(property, output);
      };
    }
    return redact(property, targetPropertyValue);
  },
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.285.1">Our redaction still functions the same over values, function outputs, and property and </span><span><span class="kobospan" id="kobo.286.1">function names:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.287.1">
console.assert(
  !redactedObjProxyImproved.someFn().includes
    ('sensitive') &amp;&amp;
    !redactedObjProxyImproved.sensitiveFn().includes
      ('sensitive') &amp;&amp;
    !redactedObjProxyImproved.otherSensitiveFn().includes
      ('sensitive'),
  'JavaScript Proxy with Reflect redacts correctly for all
    functions'
);
console.assert(
  !redactedObjProxyImproved.field.includes('sensitive'),
  'JavaScript Proxy with Reflect redacts field values
    correctly'
);
console.assert(
  redactedObjProxyImproved.sensitiveField === '[REDACTED]',
  'JavaScript Proxy with Reflect redacts field values
    correctly'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.288.1">Now that we’ve delved</span><a id="_idIndexMarker074" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.289.1"> into how to implement the proxy pattern, we’ll contrast it with the decorator pattern and which JavaScript tools we can us</span><a id="_idTextAnchor070" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.290.1">e to </span><span><span class="kobospan" id="kobo.291.1">implement it.</span></span></p>
<h1 id="_idParaDest-39" class="calibre5"><a id="_idTextAnchor071" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.292.1">Decorator in JavaScript</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.293.1">The decorator pattern is similar to </span><a id="_idIndexMarker075" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.294.1">the proxy pattern in that it’s about “wrapping” an </span><a id="_idIndexMarker076" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.295.1">object. </span><span class="kobospan" id="kobo.295.2">However, the decorator pattern is about adding functionality to an object at runtime. </span><span class="kobospan" id="kobo.295.3">Different decorators can be applied to an object to add different fu</span><a id="_idTextAnchor072" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.296.1">nctionalities </span><span><span class="kobospan" id="kobo.297.1">to it.</span></span></p>
<h2 id="_idParaDest-40" class="calibre7"><a id="_idTextAnchor073" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.298.1">Implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.299.1">Given the following </span><strong class="source-inline"><span class="kobospan" id="kobo.300.1">HttpClient</span></strong><span class="kobospan" id="kobo.301.1"> class based on the </span><strong class="source-inline"><span class="kobospan" id="kobo.302.1">fetch</span></strong><span class="kobospan" id="kobo.303.1"> API, we want to instrument the requests </span><a id="_idIndexMarker077" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.304.1">made through this client. </span><strong class="source-inline"><span class="kobospan" id="kobo.305.1">HttpClient</span></strong><span class="kobospan" id="kobo.306.1"> implements </span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">getJson</span></strong><span class="kobospan" id="kobo.308.1"> and returns JSON output if the </span><strong class="source-inline"><span class="kobospan" id="kobo.309.1">fetch</span></strong> <span><span class="kobospan" id="kobo.310.1">request succeeds:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.311.1">
class HttpClient {
  async getJson(url) {
    const response = await fetch(url);
    if (response.ok) {
      return response.json();
    }
    throw new Error(`Error loading ${url}`);
  }
}</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.312.1">InstrumentedHttpClient</span></strong><span class="kobospan" id="kobo.313.1">, which is a decorator, might look like the following, where we expose the same </span><strong class="source-inline"><span class="kobospan" id="kobo.314.1">getJson</span></strong><span class="kobospan" id="kobo.315.1"> method but have the added </span><strong class="source-inline"><span class="kobospan" id="kobo.316.1">requestTimings</span></strong><span class="kobospan" id="kobo.317.1"> field on </span><span><span class="kobospan" id="kobo.318.1">the instance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.319.1">When </span><strong class="source-inline"><span class="kobospan" id="kobo.320.1">getJson</span></strong><span class="kobospan" id="kobo.321.1"> is called, we track the start and end time of the </span><strong class="source-inline"><span class="kobospan" id="kobo.322.1">HttpClient#getJson</span></strong><span class="kobospan" id="kobo.323.1"> method call and add it to the </span><span><span class="kobospan" id="kobo.324.1">instance’s </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.325.1">requestTimings</span></strong></span><span><span class="kobospan" id="kobo.326.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.327.1">
class InstrumentedHttpClient {
  constructor(client) {
    this.client = client;
    this.requestTimings = {};
  }
  async getJson(url) {
    const start = performance.now();
    const output = await this.client.getJson(url);
    const end = performance.now();
    if (!Array.isArray(this.requestTimings[url])) {
      this.requestTimings[url] = [];
    }
    this.requestTimings[url].push(end - start);
    return output;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.328.1">We can</span><a id="_idIndexMarker078" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.329.1"> ensure that the </span><strong class="source-inline"><span class="kobospan" id="kobo.330.1">InstrumentedHttpClient</span></strong><span class="kobospan" id="kobo.331.1"> works as described with the </span><span><span class="kobospan" id="kobo.332.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.333.1">
const httpClient = new HttpClient();
const instrumentedClient = new InstrumentedHttpClient
  (httpClient);
await instrumentedClient.getJson
  ('https://ifconfig.io/all.json');
console.assert(
  Object.keys(instrumentedClient.requestTimings).length &gt;0,
  'Tracks request timings'
);
await instrumentedClient.getJson
  ('https://ifconfig.io/all.json');
console.assert(
  instrumentedClient.requestTimings
    ['https://ifconfig.io/all.json'].length === 2,
  'Trac</span><a id="_idTextAnchor074" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.334.1">ks per URL timings'
);</span></pre> <h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor075" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.335.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.336.1">The decorator pattern, much like the proxy pattern, can be used to instrument or intercept operations on </span><span><span class="kobospan" id="kobo.337.1">a “subject”.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.338.1">One key difference is that the decorator is about adding “new members” to the class, not just maintaining the interface one to </span><a id="_idIndexMarker079" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.339.1">one. </span><span class="kobospan" id="kobo.339.2">That’s why it’s normal for us to save an additional </span><strong class="source-inline"><span class="kobospan" id="kobo.340.1">requestTimings</span></strong><span class="kobospan" id="kobo.341.1"> field and access it from the “decorated” </span><span><span class="kobospan" id="kobo.342.1">class, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.343.1">InstrumentedHttpClient</span></strong></span><span><span class="kobospan" id="kobo.344.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.345.1">This means that multiple decorators can “stack” on top of each other. </span><span class="kobospan" id="kobo.345.2">For example, we can have our </span><strong class="source-inline"><span class="kobospan" id="kobo.346.1">InstrumentedHttpClient</span></strong><span class="kobospan" id="kobo.347.1">, which has </span><strong class="source-inline"><span class="kobospan" id="kobo.348.1">requestTimings</span></strong><span class="kobospan" id="kobo.349.1">, and then create another decorator class that does something useful with the timing information. </span><span class="kobospan" id="kobo.349.2">An example here is sending a “client-time” heuristic header that allows the server to stop processing a request once a certain amount time of time has passed since it knows the client will have aborted </span><a id="_idTextAnchor076" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.350.1">the connection </span><span><span class="kobospan" id="kobo.351.1">by then.</span></span></p>
<h2 id="_idParaDest-42" class="calibre7"><a id="_idTextAnchor077" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.352.1">Improvements/limitations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.353.1">Due to JavaScript’s first-class support for</span><a id="_idIndexMarker080" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.354.1"> functions, we can use functions as the basis for decoration instead </span><span><span class="kobospan" id="kobo.355.1">of classes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.356.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">getJson</span></strong><span class="kobospan" id="kobo.358.1"> function could look as follows, with similar logic to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">HttpClient.getJson</span></strong></span><span><span class="kobospan" id="kobo.360.1"> method:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.361.1">
async function getJson(url) {
  const response = await fetch(url);
  if (response.ok) {
    return response.json();
  }
  throw new Error(`Error loading ${url}`);
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.362.1">We can then create an </span><strong class="source-inline"><span class="kobospan" id="kobo.363.1">addTiming</span></strong><span class="kobospan" id="kobo.364.1"> method that stores the request times in an </span><strong class="source-inline"><span class="kobospan" id="kobo.365.1">allOperationTimings</span></strong> <span><strong class="source-inline"><span class="kobospan" id="kobo.366.1">Map</span></strong></span><span><span class="kobospan" id="kobo.367.1"> instance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.368.1">We’re using both aspects of first-class functions here – we’re passing a function as a parameter (</span><strong class="source-inline"><span class="kobospan" id="kobo.369.1">getJson</span></strong><span class="kobospan" id="kobo.370.1">) and </span><a id="_idIndexMarker081" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.371.1">returning </span><span><span class="kobospan" id="kobo.372.1">a function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.373.1">
const allOperationTimings = new Map();
function addTiming(getJson) {
  return async (url) =&gt; {
    const start = performance.now();
    const output = await getJson(url);
    const end = performance.now();
    const previousOperationTimings =
       allOperationTimings.get(url) || [];
    allOperationTimings.set(url,
      previousOperationTimings.concat(end - start));
    return output;
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.374.1">Using our decorator function is done </span><span><span class="kobospan" id="kobo.375.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.376.1">
const getJsonWithTiming = addTiming(getJson);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.377.1">We can then invoke our instrumented function and check that it adds timings to our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.378.1">allOperationTimings</span></strong></span><span> </span><span><strong class="source-inline"><span class="kobospan" id="kobo.379.1">Map</span></strong></span><span><span class="kobospan" id="kobo.380.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.381.1">
await getJsonWithTiming('https://ifconfig.io/all.json');
await getJsonWithTiming('https://ifconfig.io/all.json');
console.assert(
  allOperationTimings.size === 1,
  'operation timings tracks by url'
);
console.assert(
  allOperationTimings.get('https://ifconfig.io/all.json').
</span><span class="kobospan1" id="kobo.381.2">    length === 2,
  'operation timings tracks number of calls by url'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.382.1">One thing you might’ve noticed is that our </span><strong class="source-inline"><span class="kobospan" id="kobo.383.1">addTiming</span></strong> <em class="italic"><span class="kobospan" id="kobo.384.1">is</span></em><span class="kobospan" id="kobo.385.1"> still aware of the </span><strong class="source-inline"><span class="kobospan" id="kobo.386.1">getJson</span></strong><span class="kobospan" id="kobo.387.1"> interface (it knows to pass a URL parameter and that </span><strong class="source-inline"><span class="kobospan" id="kobo.388.1">getJson</span></strong><span class="kobospan" id="kobo.389.1"> returns a Promise object). </span><span class="kobospan" id="kobo.389.2">We’ll leave it as an exercise for the reader to implement, but it would be possible to turn </span><strong class="source-inline"><span class="kobospan" id="kobo.390.1">addTiming</span></strong><span class="kobospan" id="kobo.391.1"> into</span><a id="_idIndexMarker082" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.392.1"> a function that can instrument the operation time of </span><em class="italic"><span class="kobospan" id="kobo.393.1">any</span></em><span class="kobospan" id="kobo.394.1"> JavaScript function; the tricky part is to find a good key for our </span><span><span class="kobospan" id="kobo.395.1">operations map.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.396.1">In the next part of the chapter, we’ll look</span><a id="_idTextAnchor078" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.397.1"> at the </span><span><span class="kobospan" id="kobo.398.1">flyweight pattern.</span></span></p>
<h1 id="_idParaDest-43" class="calibre5"><a id="_idTextAnchor079" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.399.1">Flyweight in JavaScript</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.400.1">The flyweight pattern is where the subset of object properties that have the same value are stored in shared “</span><span><span class="kobospan" id="kobo.401.1">flyweight” objects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.402.1">The flyweight pattern is useful </span><a id="_idIndexMarker083" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.403.1">when generating large quantities of objects that share a</span><a id="_idTextAnchor080" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.404.1"> subset of the </span><span><span class="kobospan" id="kobo.405.1">same values.</span></span></p>
<h2 id="_idParaDest-44" class="calibre7"><a id="_idTextAnchor081" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.406.1">Implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.407.1">One concept from domain-driven </span><a id="_idIndexMarker084" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.408.1">design by Eric Evans is “value objects”. </span><span class="kobospan" id="kobo.408.2">These value objects have the property that their contents matter more than their identity. </span><span class="kobospan" id="kobo.408.3">Let’s take the example of a value object being a “coin” where, for the purposes of payment, two 50-cent coins </span><span><span class="kobospan" id="kobo.409.1">are interchangeable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.410.1">Value objects are interchangeable and immutable (a 50-cent coin can’t become a 10-cent coin). </span><span class="kobospan" id="kobo.410.2">These types of objects are therefore a great fit for the </span><span><span class="kobospan" id="kobo.411.1">Flyweight pattern.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.412.1">Not all properties of a “coin” are “value”-driven, for example, certain coins are made from certain materials and coins tend to be issued in a certain year. </span><span class="kobospan" id="kobo.412.2">These two properties (material and year of issue) might be interesting to collectors and in this respect, real-world coins are not only value objects as two 1993 coins might be interesting in different ways in the context of a </span><span><span class="kobospan" id="kobo.413.1">coin collection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.414.1">We therefore model our </span><strong class="source-inline"><span class="kobospan" id="kobo.415.1">Wallet</span></strong><span class="kobospan" id="kobo.416.1"> as containing </span><a id="_idIndexMarker085" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.417.1">a list of coins and our </span><strong class="source-inline"><span class="kobospan" id="kobo.418.1">Coin</span></strong><span class="kobospan" id="kobo.419.1"> as containing an amount (in cents or other “minor currency”), a currency, a year of issue, and a list </span><span><span class="kobospan" id="kobo.420.1">of materials.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer009">
<span class="kobospan" id="kobo.421.1"><img alt="Figure 2.1: Class diagram where a Wallet has associated coins and methods to operate over them" src="image/B19109_02_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.422.1">Figure 2.1: Class diagram where a Wallet has associated coins and methods to operate over them</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.423.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.424.1">CoinFlyweight</span></strong><span class="kobospan" id="kobo.425.1"> will be our “value object” and contain the </span><strong class="source-inline"><span class="kobospan" id="kobo.426.1">amount</span></strong><span class="kobospan" id="kobo.427.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.428.1">currency</span></strong><span class="kobospan" id="kobo.429.1">, </span><span><span class="kobospan" id="kobo.430.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.431.1">
class CoinFlyweight {
  /**
   * @param {Number} amount – amount in minor currency
   * @param {String} currency
   */
  constructor(amount, currency) {
    this.amount = amount;
    this.currency = currency;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.432.1">The key benefit of the flyweight pattern is that we can reuse our flyweight objects. </span><span class="kobospan" id="kobo.432.2">In order to do so, we need to control the instantiation of the flyweights with a factory (as covered in </span><a href="B19109_01.xhtml#_idTextAnchor018" class="pcalibre1 calibre6 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.433.1">Chapter 1</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.434.1">, Working with Creational Design Patterns</span></em><span class="kobospan" id="kobo.435.1">, The factory pattern in JavaScript section). </span><span class="kobospan" id="kobo.435.2">We therefore define </span><strong class="source-inline"><span class="kobospan" id="kobo.436.1">CoinFlyweightFactory</span></strong><span class="kobospan" id="kobo.437.1"> with a static </span><strong class="source-inline"><span class="kobospan" id="kobo.438.1">get</span></strong><span class="kobospan" id="kobo.439.1"> method that takes the flyweight’s initialization parameters but only instantiates a new </span><strong class="source-inline"><span class="kobospan" id="kobo.440.1">CoinFlyweight</span></strong><span class="kobospan" id="kobo.441.1"> if one with the right amount and currency is not </span><a id="_idIndexMarker086" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.442.1">already present in memory. </span><span class="kobospan" id="kobo.442.2">It also provides a </span><strong class="source-inline"><span class="kobospan" id="kobo.443.1">getCount</span></strong><span class="kobospan" id="kobo.444.1"> method to return the amount of flyweights </span><span><span class="kobospan" id="kobo.445.1">currently instantiated:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.446.1">
class CoinFlyweightFactory {
  static flyweights = {};
  static get(amount, currency) {
    const flyWeightKey = `${amount}-${currency}`;
    if (this.flyweights[flyWeightKey]) {
      return this.flyweights[flyWeightKey];
    }
    const instance = new CoinFlyweight(amount, currency);
    this.flyweights[flyWeightKey] = instance;
    return instance;
  }
  static getCount() {
    return Object.keys(this.flyweights).length;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.447.1">Another opportunity to use the Flyweight pattern is with materials. </span><span class="kobospan" id="kobo.447.2">We can similarly create a </span><strong class="source-inline"><span class="kobospan" id="kobo.448.1">MaterialFlyweight</span></strong><span class="kobospan" id="kobo.449.1"> and reuse its values via </span><span><span class="kobospan" id="kobo.450.1">a </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.451.1">MaterialFlyweightFactory</span></strong></span><span><span class="kobospan" id="kobo.452.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.453.1">
class MaterialFlyweight {
  constructor(materialName) {
    this.name = materialName;
  }
}
class MaterialFlyweightFactory {
  static flyweights = {};
  static get(materialName) {
    if (this.flyweights[materialName]) {
      return this.flyweights[materialName];
    }
    const instance = new MaterialFlyweight(materialName);
    this.flyweights[materialName] = instance;
    return instance;
  }
  static getCount() {
    return Object.keys(this.flyweights).length;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.454.1">Finally, we can implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.455.1">Coin</span></strong><span class="kobospan" id="kobo.456.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.457.1">Wallet</span></strong><span class="kobospan" id="kobo.458.1"> classes. </span><span class="kobospan" id="kobo.458.2">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">Coin</span></strong><span class="kobospan" id="kobo.460.1"> instance has a </span><strong class="source-inline"><span class="kobospan" id="kobo.461.1">flyweight</span></strong><span class="kobospan" id="kobo.462.1"> field, which is</span><a id="_idIndexMarker087" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.463.1"> populated using the </span><strong class="source-inline"><span class="kobospan" id="kobo.464.1">CoinFlyweightFactory</span></strong><span class="kobospan" id="kobo.465.1">. </span><span class="kobospan" id="kobo.465.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.466.1">Coin#materials</span></strong><span class="kobospan" id="kobo.467.1"> field is populated with a regular array but the array’s contents are of </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">MaterialFlyweight</span></strong><span class="kobospan" id="kobo.469.1">, loaded using </span><span><span class="kobospan" id="kobo.470.1">the </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">MaterialFlyweightFactory</span></strong></span><span><span class="kobospan" id="kobo.472.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.473.1">
class Coin {
  constructor(amount, currency, yearOfIssue, materials) {
    this.flyweight = CoinFlyweightFactory.get
      (amount, currency);
    this.yearOfIssue = yearOfIssue;
    this.materials = materials.map((material) =&gt;
      MaterialFlyweightFactory.get(material)
    );
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.474.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">Wallet</span></strong><span class="kobospan" id="kobo.476.1"> is a plain JavaScript object. </span><span class="kobospan" id="kobo.476.2">Its </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">add </span></strong><span class="kobospan" id="kobo.478.1">method creates a new </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">Coin</span></strong><span class="kobospan" id="kobo.480.1"> instance and pushes it into the </span><a id="_idIndexMarker088" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.481.1">Wallet’s </span><strong class="source-inline"><span class="kobospan" id="kobo.482.1">coins</span></strong><span class="kobospan" id="kobo.483.1"> field. </span><strong class="source-inline"><span class="kobospan" id="kobo.484.1">getTotalValueForCurrency</span></strong><span class="kobospan" id="kobo.485.1"> sums the coin’s values for a </span><span><span class="kobospan" id="kobo.486.1">given currency:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.487.1">
class Wallet {
  constructor() {
    this.coins = [];
  }
  add(amount, currency, yearOfIssue, materials) {
    const coin = new Coin(amount, currency, yearOfIssue,
      materials);
    this.coins.push(coin);
  }
  getCount() {
    return this.coins.length;
  }
  getTotalValueForCurrency(currency) {
    return this.coins
      .filter((coin) =&gt; coin.flyweight.currency ===
        currency)
      .reduce((acc, curr) =&gt; acc + curr.flyweight.amount, 0);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.488.1">The wallet can be used as </span><a id="_idIndexMarker089" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.489.1">follows, adding GBP and USD of </span><span><span class="kobospan" id="kobo.490.1">different denominations:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.491.1">
const wallet = new Wallet();
wallet.add(100, 'GBP', '2023', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2022', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2021', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2021', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(200, 'GBP', '2021', ['nickel-brass',
  'cupro-nickel']);
wallet.add(100, 'USD', '1990', ['copper', 'nickel']);
wallet.add(5, 'USD', '1990', ['copper', 'nickel']);
wallet.add(1, 'USD', '2010', ['copper', 'zinc']);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.492.1">Note that while the wallet instance contains eight coins, we’ve created six </span><strong class="source-inline"><span class="kobospan" id="kobo.493.1">CoinFlyweight</span></strong><span class="kobospan" id="kobo.494.1"> and five </span><span><strong class="source-inline"><span class="kobospan" id="kobo.495.1">MaterialFlyweight</span></strong></span><span><span class="kobospan" id="kobo.496.1"> instances:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.497.1">
console.assert(
  wallet.getCount() === 8,
  'wallet.add adds coin instances are created once given
    the same cache key'
);
console.assert(
  CoinFlyweightFactory.getCount() === 5,
  'CoinFlyweights are created once given the same
    cache key'
);
console.assert(
  MaterialFlyweightFactory.getCount() === 6,
  'MaterialFlyweights are created once given the same
     cache key'
);
console.assert(
  wallet.getTotalValueForCurrency('GBP') === 600,
  'Summing GBP works'
);
console.assert(
  wallet.getTotalValueForCurrency('USD') =</span><a id="_idTextAnchor082" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.498.1">== 106,
  'Summing USD works'
);</span></pre> <h2 id="_idParaDest-45" class="calibre7"><a id="_idTextAnchor083" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.499.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.500.1">The flyweight pattern is </span><a id="_idIndexMarker090" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.501.1">a normalization technique</span><a id="_idIndexMarker091" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.502.1"> that reduces the memory footprint at the cost of cognitive overhead when accessing and running computations over objects using this pattern. </span><span class="kobospan" id="kobo.502.2">Flyweight can be leveraged as a performance optimization when handling large numbers </span><span><span class="kobospan" id="kobo.503.1">of objects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.504.1">It’s </span><em class="italic"><span class="kobospan" id="kobo.505.1">very</span></em><span class="kobospan" id="kobo.506.1"> well suited to modeling</span><a id="_idIndexMarker092" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.507.1"> value objects as we’ve shown in the previous section. </span><span class="kobospan" id="kobo.507.2">The only drawback was the </span><strong class="source-inline"><span class="kobospan" id="kobo.508.1">getTotalValueForCurrency</span></strong><span class="kobospan" id="kobo.509.1">, where we had to read </span><strong class="source-inline"><span class="kobospan" id="kobo.510.1">coin.flyweight.</span><a id="_idTextAnchor084" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.511.1">currency</span></strong> <span><span class="kobospan" id="kobo.512.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.513.1">coin.flyweight.amount</span></strong></span><span><span class="kobospan" id="kobo.514.1">.</span></span></p>
<h2 id="_idParaDest-46" class="calibre7"><a id="_idTextAnchor085" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.515.1">Improvements/limitations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.516.1">There are a few improvements we can </span><a id="_idIndexMarker093" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.517.1">make to our flyweight wallet/coin setup. </span><span class="kobospan" id="kobo.517.2">A few of the improvements center on the “factories”. </span><span class="kobospan" id="kobo.517.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.518.1">flyweights</span></strong><span class="kobospan" id="kobo.519.1"> shouldn’t really be accessed from outside of the </span><strong class="source-inline"><span class="kobospan" id="kobo.520.1">get</span></strong><span class="kobospan" id="kobo.521.1"> function, so we can make it a private field using </span><strong class="source-inline"><span class="kobospan" id="kobo.522.1">#flyweights</span></strong><span class="kobospan" id="kobo.523.1">. </span><span class="kobospan" id="kobo.523.2">We can also leverage the </span><strong class="source-inline"><span class="kobospan" id="kobo.524.1">Map</span></strong><span class="kobospan" id="kobo.525.1"> object, still with the same cache key, although </span><strong class="source-inline"><span class="kobospan" id="kobo.526.1">Map</span></strong><span class="kobospan" id="kobo.527.1"> has greater flexibility in terms of what keys can be used and a different property access interface (</span><strong class="source-inline"><span class="kobospan" id="kobo.528.1">.get(key)</span></strong><span class="kobospan" id="kobo.529.1"> instead of </span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">[key]</span></strong><span class="kobospan" id="kobo.531.1"> access). </span><span class="kobospan" id="kobo.531.2">Using a </span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">Map</span></strong><span class="kobospan" id="kobo.533.1"> means we need to use </span><strong class="source-inline"><span class="kobospan" id="kobo.534.1">this.#flyweights.size</span></strong> <span><span class="kobospan" id="kobo.535.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">getCount</span></strong></span><span><span class="kobospan" id="kobo.537.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.538.1">
class CoinFlyweightFactory {
  static #flyweights = new Map();
  static get(amount, currency) {
    const flyWeightKey = `${amount}-${currency}`;
    if (this.#flyweights.get(flyWeightKey)) {
      return this.#flyweights.get(flyWeightKey);
    }
    const instance = new CoinFlyweight(amount, currency);
    this.#flyweights.set(flyWeightKey, instance);
    return instance;
  }
  static getCount() {
    return this.#flyweights.size;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.539.1">Another change we’ll make is in light of the fact that there were not any material gains by making </span><strong class="source-inline"><span class="kobospan" id="kobo.540.1">materials</span></strong><span class="kobospan" id="kobo.541.1"> a flyweight, so we’ll revert it to storing the list of strings per </span><span><strong class="source-inline"><span class="kobospan" id="kobo.542.1">Coin</span></strong></span><span><span class="kobospan" id="kobo.543.1"> instance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.544.1">Again, we want to make </span><strong class="source-inline"><span class="kobospan" id="kobo.545.1">#flyweight</span></strong><span class="kobospan" id="kobo.546.1"> private, this will change the interface of </span><strong class="source-inline"><span class="kobospan" id="kobo.547.1">Coin</span></strong><span class="kobospan" id="kobo.548.1"> since consumers will not be able to access </span><strong class="source-inline"><span class="kobospan" id="kobo.549.1">coin.#flyweight</span></strong><span class="kobospan" id="kobo.550.1"> (it’s a </span><span><span class="kobospan" id="kobo.551.1">private field).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.552.1">What we’ll do is tackle the mismatch of having to read </span><strong class="source-inline"><span class="kobospan" id="kobo.553.1">coin.flyweight.amount</span></strong><span class="kobospan" id="kobo.554.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.555.1">coin.flyweight.currency</span></strong><span class="kobospan" id="kobo.556.1">. </span><span class="kobospan" id="kobo.556.2">We’ll supply two getters, </span><strong class="source-inline"><span class="kobospan" id="kobo.557.1">get amount()</span></strong><span class="kobospan" id="kobo.558.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">get currency()</span></strong><span class="kobospan" id="kobo.560.1">, which will </span><a id="_idIndexMarker094" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.561.1">return </span><strong class="source-inline"><span class="kobospan" id="kobo.562.1">this.#flyweight.amount</span></strong><span class="kobospan" id="kobo.563.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.564.1">this.#flyweight.currency</span></strong></span><span><span class="kobospan" id="kobo.565.1"> respectively:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.566.1">
class Coin {
  #flyweight;
  constructor(amount, currency, yearOfIssue, materials) {
    this.#flyweight = CoinFlyweightFactory.get
      (amount, currency);
    this.yearOfIssue = yearOfIssue;
    this.materials = materials;
  }
  get amount() {
    return this.#flyweight.amount;
  }
  get currency() {
    return this.#flyweight.currency;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.567.1">As mentioned, the interface of </span><strong class="source-inline"><span class="kobospan" id="kobo.568.1">Coin</span></strong><span class="kobospan" id="kobo.569.1"> doesn’t have a </span><strong class="source-inline"><span class="kobospan" id="kobo.570.1">flyweight</span></strong><span class="kobospan" id="kobo.571.1"> property so </span><strong class="source-inline"><span class="kobospan" id="kobo.572.1">getTotalValueForCurrency</span></strong><span class="kobospan" id="kobo.573.1"> will read from </span><strong class="source-inline"><span class="kobospan" id="kobo.574.1">Coin#currency</span></strong><span class="kobospan" id="kobo.575.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.576.1">Coin#amount</span></strong><span class="kobospan" id="kobo.577.1">. </span><span class="kobospan" id="kobo.577.2">As far as </span><strong class="source-inline"><span class="kobospan" id="kobo.578.1">Wallet</span></strong><span class="kobospan" id="kobo.579.1"> is concerned, </span><strong class="source-inline"><span class="kobospan" id="kobo.580.1">currency</span></strong><span class="kobospan" id="kobo.581.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.582.1">amount</span></strong><span class="kobospan" id="kobo.583.1"> are fields on the </span><strong class="source-inline"><span class="kobospan" id="kobo.584.1">Coin</span></strong><span class="kobospan" id="kobo.585.1"> instance, although</span><a id="_idIndexMarker095" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.586.1">they’re getters:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.587.1">
class Wallet {
  constructor() {
    this.coins = [];
  }
  add(amount, currency, yearOfIssue, materials) {
    const coin = new Coin(amount, currency, yearOfIssue,
      materials);
    this.coins.push(coin);
  }
  getCount() {
    return this.coins.length;
  }
  getTotalValueForCurrency(currency) {
    return this.coins
      .filter((coin) =&gt; coin.currency === currency)
      .reduce((acc, curr) =&gt; acc + curr.amount, 0);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.588.1">We can check that our new </span><strong class="source-inline"><span class="kobospan" id="kobo.589.1">Wallet</span></strong><span class="kobospan" id="kobo.590.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.591.1">Coin</span></strong><span class="kobospan" id="kobo.592.1"> implementations work as expected by using the same tests as in our earlier iteration of </span><span><span class="kobospan" id="kobo.593.1">the code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.594.1">
const wallet = new Wallet();
wallet.add(100, 'GBP', '2023', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2022', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2021', ['nickel-brass',
  'nickel-plated alloy']);
wallet.add(100, 'GBP', '2021', ['nickel-brass',
  'nickel-plated alloy']);
Wallet.add(200, 'GBP', '2021', ['nickel-brass',
  'cupro-nickel']);
wallet.add(100, 'USD', '1990', ['copper', 'nickel']);
wallet.add(5, 'USD', '1990', ['copper', 'nickel']);
wallet.add(1, 'USD', '2010', ['copper', 'zinc']);
console.assert(
  wallet.getCount() === 8,
  'wallet.add adds coin instances are created once
    given the same cache key'
);
console.assert(
  CoinFlyweightFactory.getCount() === 5,
  'CoinFlyweights are created once given the same
   cache key'
);
console.assert(
  wallet.getTotalValueForCurrency('GBP') === 600,
  'Summing GBP works'
);
console.assert(
  wallet.getTotalValueForCurrency('USD') === 106,
  'Summing USD works'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.595.1">We’ve seen how the </span><a id="_idIndexMarker096" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.596.1">flyweight pattern can be used to optimize memory usage by using shared </span><span><span class="kobospan" id="kobo.597.1">value objects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.598.1">In the next part of the chapter, we’ll look at the last structural design pattern covered in this b</span><a id="_idTextAnchor086" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.599.1">ook, the adapter pattern </span><span><span class="kobospan" id="kobo.600.1">in JavaScript.</span></span></p>
<h1 id="_idParaDest-47" class="calibre5"><a id="_idTextAnchor087" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.601.1">Adapter in JavaScript</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.602.1">The adapter pattern, similar to the other </span><a id="_idIndexMarker097" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.603.1">structural design patterns, focuses </span><span><span class="kobospan" id="kobo.604.1">on interfaces.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.605.1">In the adapter pattern’s case, it involves being able to use a new implementation without changing the consumer or the implementation’s interface. </span><span class="kobospan" id="kobo.605.2">The “adapter” takes the new implementation and “adapts” the interface to match what the </span><span><span class="kobospan" id="kobo.606.1">consumer expects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.607.1">We’re not changing the implementation </span><em class="italic"><span class="kobospan" id="kobo.608.1">or</span></em><span class="kobospan" id="kobo.609.1"> the consumer; rather, we’re building an adapter to wrap the implementation and plug it in</span><a id="_idTextAnchor088" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.610.1">to the consumer without </span><span><span class="kobospan" id="kobo.611.1">changing either.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.612.1">Implementation</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.613.1">Let’s start with a simple in-memory </span><a id="_idIndexMarker098" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.614.1">database that uses a naive </span><strong class="source-inline"><span class="kobospan" id="kobo.615.1">IdGenerator</span></strong><span class="kobospan" id="kobo.616.1"> to generate keys for the database entries by encoding the object as </span><span><span class="kobospan" id="kobo.617.1">a string.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.618.1">Database</span></strong><span class="kobospan" id="kobo.619.1"> has a </span><strong class="source-inline"><span class="kobospan" id="kobo.620.1">createEntry</span></strong><span class="kobospan" id="kobo.621.1"> method that stores given data using the </span><strong class="source-inline"><span class="kobospan" id="kobo.622.1">IdGenerator</span></strong><span class="kobospan" id="kobo.623.1"> to generate a key. </span><strong class="source-inline"><span class="kobospan" id="kobo.624.1">Database</span></strong><span class="kobospan" id="kobo.625.1"> also has a </span><strong class="source-inline"><span class="kobospan" id="kobo.626.1">get</span></strong><span class="kobospan" id="kobo.627.1"> method to recall entries </span><span><span class="kobospan" id="kobo.628.1">by ID:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.629.1">
class IdGenerator {
  get(entry) {
    return JSON.stringify(entry);
  }
}
class Database {
  constructor(idGenerator) {
    this.idGenerator = idGenerator;
    this.entries = {};
  }
  createEntry(entryData) {
    const id = this.idGenerator.get(entryData);
    this.entries[id] = entryData;
    return id;
  }
  get(id) {
    return this.entries[id];
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.630.1">By composing </span><strong class="source-inline"><span class="kobospan" id="kobo.631.1">Database</span></strong><span class="kobospan" id="kobo.632.1"> with an </span><strong class="source-inline"><span class="kobospan" id="kobo.633.1">IdGenerator</span></strong><span class="kobospan" id="kobo.634.1"> instance, we get a key-value lookup database instance with</span><a id="_idIndexMarker099" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.635.1"> the key equal to the JSON representation of </span><span><span class="kobospan" id="kobo.636.1">the value:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.637.1">
const naiveIdDatabase = new Database(new IdGenerator());
naiveIdDatabase.createEntry({
  name: 'pear',
});
console.assert(
  naiveIdDatabase.get('{"name":"pear"}').name === 'pear',
  'stringIdDatabase recalls entries by stringified entry'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.638.1">Now, the naive ID generation that encodes the whole entry value in the key is not ideal. </span><span class="kobospan" id="kobo.638.2">An alternative is to use a UUID. </span><span class="kobospan" id="kobo.638.3">Here’s a </span><strong class="source-inline"><span class="kobospan" id="kobo.639.1">UuidFactory</span></strong><span class="kobospan" id="kobo.640.1"> using the </span><strong class="source-inline"><span class="kobospan" id="kobo.641.1">uuid</span></strong><span class="kobospan" id="kobo.642.1"> npm module. </span><span class="kobospan" id="kobo.642.2">The key operation it exposes </span><span><span class="kobospan" id="kobo.643.1">is </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.644.1">generateUuid</span></strong></span><span><span class="kobospan" id="kobo.645.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.646.1">
import { v4 as uuidv4 } from 'uuid';
class UuidFactory {
  generateUuid() {
    return uuidv4();
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.647.1">To use the </span><strong class="source-inline"><span class="kobospan" id="kobo.648.1">UuidFactory</span></strong><span class="kobospan" id="kobo.649.1"> with our </span><strong class="source-inline"><span class="kobospan" id="kobo.650.1">Database</span></strong><span class="kobospan" id="kobo.651.1">, we would need a </span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">get</span></strong><span class="kobospan" id="kobo.653.1"> method instead of a </span><strong class="source-inline"><span class="kobospan" id="kobo.654.1">generateUuid</span></strong><span class="kobospan" id="kobo.655.1"> method. </span><span class="kobospan" id="kobo.655.2">This is </span><a id="_idIndexMarker100" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.656.1">where our adapter comes in – we can wrap the </span><strong class="source-inline"><span class="kobospan" id="kobo.657.1">UuidFactory</span></strong><span class="kobospan" id="kobo.658.1"> in a class that exposes </span><strong class="source-inline"><span class="kobospan" id="kobo.659.1">get(entry)</span></strong><span class="kobospan" id="kobo.660.1"> but calls </span><strong class="source-inline"><span class="kobospan" id="kobo.661.1">generateUuid</span></strong><span class="kobospan" id="kobo.662.1"> on the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.663.1">UuidFactor</span></strong></span><span><span class="kobospan" id="kobo.664.1"> instance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.665.1">
class UuidIdGeneratorAdapter {
  constructor() {
    this.uuidFactory = new UuidFactory();
  }
  get(_entry) {
    return this.uuidFactory.generateUuid();
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.666.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.667.1">UuidIdGeneratorAdapter</span></strong><span class="kobospan" id="kobo.668.1"> can then be passed as the </span><strong class="source-inline"><span class="kobospan" id="kobo.669.1">idGenerator</span></strong><span class="kobospan" id="kobo.670.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.671.1">Database</span></strong><span class="kobospan" id="kobo.672.1">. </span><span class="kobospan" id="kobo.672.2">It all works as expected, where</span><a id="_idIndexMarker101" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.673.1"> the entry IDs for the database </span><span><span class="kobospan" id="kobo.674.1">are UUIDs:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.675.1">
const uuidIdDatabase = new Database(new UuidIdGeneratorAdapter());
const uuidEntryId = uuidIdDatabase.createEntry({
  name: 'pear',
});
console.assert(
  uuidIdDatabase.get(uuidEntryId).name === 'pear',
  'uuidIdDatabase recalls entries by uuid'
);
import { validate as isUuid } from 'uuid';
console.assert(isUuid(uuidEntryId), 'uuidIdDatabase generated uuid ids');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.676.1">Another example that makes use of the fact that the </span><strong class="source-inline"><span class="kobospan" id="kobo.677.1">entry</span></strong><span class="kobospan" id="kobo.678.1"> is being passed to </span><strong class="source-inline"><span class="kobospan" id="kobo.679.1">idGenerator.get()</span></strong><span class="kobospan" id="kobo.680.1"> is to generate prefixed auto-incrementing IDs based on the </span><strong class="source-inline"><span class="kobospan" id="kobo.681.1">entry</span></strong><span class="kobospan" id="kobo.682.1"> contents. </span><span class="kobospan" id="kobo.682.2">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.683.1">name</span></strong><span class="kobospan" id="kobo.684.1"> will be used as the prefix. </span><span class="kobospan" id="kobo.684.2">We have a </span><strong class="source-inline"><span class="kobospan" id="kobo.685.1">Counter</span></strong><span class="kobospan" id="kobo.686.1"> class that implements </span><strong class="source-inline"><span class="kobospan" id="kobo.687.1">getAndIncrement(prefix)</span></strong><span class="kobospan" id="kobo.688.1">, which generates incrementing IDs given a prefix (or </span><span><span class="kobospan" id="kobo.689.1">no prefix):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.690.1">
class Counter {
  constructor(startValue = 1) {
    this.startValue = startValue;
    this.nextId = startValue;
    this.nextIdByPrefix = {};
  }
  getAndIncrement(prefix) {
    if (prefix) {
      if (!this.nextIdByPrefix[prefix]) {
        this.nextIdByPrefix[prefix] = this.startValue;
      }
      const nextId = this.nextIdByPrefix[prefix]++;
      return `${prefix}:${nextId}`;
    }
    return String(this.nextId++);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.691.1">Again, </span><strong class="source-inline"><span class="kobospan" id="kobo.692.1">getAndIncrement(prefix)</span></strong><span class="kobospan" id="kobo.693.1"> doesn’t match the </span><strong class="source-inline"><span class="kobospan" id="kobo.694.1">IdGenerator</span></strong><span class="kobospan" id="kobo.695.1"> interface (no </span><strong class="source-inline"><span class="kobospan" id="kobo.696.1">get</span></strong><span class="kobospan" id="kobo.697.1"> method). </span><span class="kobospan" id="kobo.697.2">We can </span><a id="_idIndexMarker102" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.698.1">wrap </span><strong class="source-inline"><span class="kobospan" id="kobo.699.1">Counter</span></strong><span class="kobospan" id="kobo.700.1"> in a </span><strong class="source-inline"><span class="kobospan" id="kobo.701.1">PrefixedAutoIncrementIdGeneratorAdapter</span></strong><span class="kobospan" id="kobo.702.1"> to expose an </span><strong class="source-inline"><span class="kobospan" id="kobo.703.1">IdGenerator</span></strong><span class="kobospan" id="kobo.704.1"> interface but using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.705.1">Counter</span></strong></span><span><span class="kobospan" id="kobo.706.1"> implementation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.707.1">
class PrefixedAutoIncrementIdGeneratorAdapter {
  constructor() {
    this.counter = new Counter();
  }
  get(entry) {
    return this.counter.getAndIncrement(entry.name);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.708.1">We can ensure the prefixing logic works as expected for the </span><strong class="source-inline"><span class="kobospan" id="kobo.709.1">Database</span></strong><span class="kobospan" id="kobo.710.1"> since it creates entries keyed by prefixed </span><span><span class="kobospan" id="kobo.711.1">auto-incrementing IDs:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.712.1">
const prefixAutoIncrementDatabase = new Database(
  new PrefixedAutoIncrementIdGeneratorAdapter()
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.713.1">We can check that the case </span><a id="_idIndexMarker103" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.714.1">where no </span><strong class="source-inline"><span class="kobospan" id="kobo.715.1">name</span></strong><span class="kobospan" id="kobo.716.1"> field is set works </span><span><span class="kobospan" id="kobo.717.1">as expected:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.718.1">
const noPrefixIncrementingEntryId1 =
  prefixAutoIncrementDatabase.createEntry({
  type: 'no-prefix',
});
const noPrefixIncrementingEntryId2 =
  prefixAutoIncrementDatabase.createEntry({
  type: 'no-prefix',
});
console.assert(
  noPrefixIncrementingEntryId1 === '1' &amp;&amp;
    noPrefixIncrementingEntryId2 === '2',
  'prefixAutoIncrementDatabase generates autoincrementing
    ids with no prefix if no name property is set'
);
console.assert(
  prefixAutoIncrementDatabase.get
    (noPrefixIncrementingEntryId1).type ===
    'no-prefix' &amp;&amp;
    prefixAutoIncrementDatabase.get
      (noPrefixIncrementingEntryId2).type ===
      'no-prefix',
  'prefixAutoIncrementDatabase recalls entries by
     autoincrementing id'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.719.1">And the scenarios where a </span><a id="_idIndexMarker104" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.720.1">prefix is available also functions correctly per the </span><span><span class="kobospan" id="kobo.721.1">following example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.722.1">
const prefixIncrementingEntryIdPear1 =
  prefixAutoIncrementDatabase.createEntry({
  name: 'pear',
});
const prefixIncrementingEntryIdPear2 =
  prefixAutoIncrementDatabase.createEntry({
  name: 'pear',
});
const prefixIncrementingEntryIdApple1 =
  prefixAutoIncrementDatabase.createEntry(
  {
    name: 'apple',
  }
);
console.assert(
  prefixIncrementingEntryIdPear1 === 'pear:1' &amp;&amp;
    prefixIncrementingEntryIdPear2 === 'pear:2' &amp;&amp;
    prefixIncrementingEntryIdApple1 === 'apple:1',
  'prefixAutoIncrementDatabase generates prefixed
    autoincrementing ids'
);
console.assert(
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdPear1).name ===
    'pear',
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdPear2).name ===
    'pear',
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdApple1).name ===
    'apple',
  'prefixAutoIncrementD</span><a id="_idTextAnchor089" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.723.1">atabase recalls entries by prefixed
    id'
);</span></pre> <h2 id="_idParaDest-48" class="calibre7"><a id="_idTextAnchor090" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.724.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.725.1">The adapter pattern is useful when </span><a id="_idIndexMarker105" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.726.1">you need to use two classes that weren’t specifically designed to work together. </span><span class="kobospan" id="kobo.726.2">Consider, for example, a third-party library or module that exposes a function (such as the </span><strong class="source-inline"><span class="kobospan" id="kobo.727.1">uuid</span></strong><span class="kobospan" id="kobo.728.1"> module or even </span><strong class="source-inline"><span class="kobospan" id="kobo.729.1">UuidFactory</span></strong><span class="kobospan" id="kobo.730.1"> from our scenario). </span><span class="kobospan" id="kobo.730.2">We want to abstract the implementation behind an interface, in our case the interface of </span><strong class="source-inline"><span class="kobospan" id="kobo.731.1">IdGenerator</span></strong><span class="kobospan" id="kobo.732.1">, which is just a </span><strong class="source-inline"><span class="kobospan" id="kobo.733.1">get</span></strong><span class="kobospan" id="kobo.734.1"> method, so that any implementation can </span><span><span class="kobospan" id="kobo.735.1">be used.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.736.1">Our example showcased the value of the adapter pattern. </span><span class="kobospan" id="kobo.736.2">We were able to create very differently behaving databases without changing </span><strong class="source-inline"><span class="kobospan" id="kobo.737.1">UuidFactory</span></strong><span class="kobospan" id="kobo.738.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.739.1">Counter</span></strong><span class="kobospan" id="kobo.740.1">, or </span><strong class="source-inline"><span class="kobospan" id="kobo.741.1">Database</span></strong><span class="kobospan" id="kobo.742.1"> for that matter. </span><span class="kobospan" id="kobo.742.2">This is very important when having to connect two third-party modules or modules which are self-contained and shouldn’t </span><span><span class="kobospan" id="kobo.743.1">be changed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.744.1">Using the adapter pattern therefore</span><a id="_idIndexMarker106" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.745.1"> means that we can avoid changing difficult-to-understand </span><a id="_idTextAnchor091" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.746.1">code while delivering the </span><span><span class="kobospan" id="kobo.747.1">required functionality.</span></span></p>
<h2 id="_idParaDest-49" class="calibre7"><a id="_idTextAnchor092" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.748.1">Improvements/limitations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.749.1">Similarly, to the </span><em class="italic"><span class="kobospan" id="kobo.750.1">Decorator in JavaScript - Improvements/limitations</span></em><span class="kobospan" id="kobo.751.1"> section, one of the JavaScript features that can help </span><a id="_idIndexMarker107" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.752.1">when implementing structural design patterns is the first-class support </span><span><span class="kobospan" id="kobo.753.1">for functions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.754.1">Instead of an </span><strong class="source-inline"><span class="kobospan" id="kobo.755.1">IdGenerator</span></strong><span class="kobospan" id="kobo.756.1"> class, we can have a </span><strong class="source-inline"><span class="kobospan" id="kobo.757.1">defaultIdGenerator</span></strong><span class="kobospan" id="kobo.758.1"> function that takes an entry and returns </span><span><span class="kobospan" id="kobo.759.1">a string:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.760.1">
function defaultIdGenerator(entry) {
  return JSON.stringify(entry);
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.761.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.762.1">Database</span></strong><span class="kobospan" id="kobo.763.1"> class would now look something as follows, where </span><strong class="source-inline"><span class="kobospan" id="kobo.764.1">this.idGenerator(entryData)</span></strong><span class="kobospan" id="kobo.765.1"> is </span><span><span class="kobospan" id="kobo.766.1">called directly:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.767.1">
class Database {
  constructor(idGenerator) {
    this.idGenerator = idGenerator;
    this.entries = {};
  }
  createEntry(entryData) {
    const id = this.idGenerator(entryData);
    this.entries[id] = entryData;
    return id;
  }
  get(id) {
    return this.entries[id];
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.768.1">We can validate that the naive</span><a id="_idIndexMarker108" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.769.1"> implementation still works by serializing whatever is passed to it </span><span><span class="kobospan" id="kobo.770.1">as JSON:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.771.1">
const naiveIdDatabase = new Database(defaultIdGenerator);
naiveIdDatabase.createEntry({
  name: 'pear',
});
console.assert(
  naiveIdDatabase.get('{"name":"pear"}').name === 'pear',
  'stringIdDatabase recalls entries by stringified entry'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.772.1">This approach shines when we need to plug in the UUID and </span><span><span class="kobospan" id="kobo.773.1">prefix generators.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.774.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.775.1">uuidGenerator</span></strong><span class="kobospan" id="kobo.776.1"> function can call </span><strong class="source-inline"><span class="kobospan" id="kobo.777.1">uuidv4()</span></strong><span class="kobospan" id="kobo.778.1">. </span><span class="kobospan" id="kobo.778.2">We can validate that </span><strong class="source-inline"><span class="kobospan" id="kobo.779.1">uuidIdDatabase</span></strong><span class="kobospan" id="kobo.780.1"> uses UUIDs to key and recall </span><span><span class="kobospan" id="kobo.781.1">the entries:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.782.1">
function uuidGenerator() {
  return uuidv4();
}
const uuidIdDatabase = new Database(uuidGenerator);
const uuidEntryId = uuidIdDatabase.createEntry({
  name: 'pear',
});
console.assert(
  uuidIdDatabase.get(uuidEntryId).name === 'pear',
  'uuidIdDatabase recalls entries by uuid'
);
console.assert(isUuid(uuidEntryId), 'uuidIdDatabase
  generated uuid ids');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.783.1">Finally, a </span><strong class="source-inline"><span class="kobospan" id="kobo.784.1">prefixAutoIncrementIdGenerator</span></strong><span class="kobospan" id="kobo.785.1"> would look as follows. </span><span class="kobospan" id="kobo.785.2">We’re using module-scoped variables, which is </span><a id="_idIndexMarker109" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.786.1">another feature </span><span><span class="kobospan" id="kobo.787.1">of JavaScript:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.788.1">
const startValue = 1;
let nextId = startValue;
let nextIdByPrefix = {};
function prefixAutoIncrementIdGenerator(entry) {
  const prefix = entry.name;
  if (prefix) {
    if (!nextIdByPrefix[prefix]) {
      nextIdByPrefix[prefix] = startValue;
    }
    const nextId = nextIdByPrefix[prefix]++;
    return `${prefix}:${nextId}`;
  }
  return String(nextId++);
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.789.1">This code would be in a different module than its consumer, so it would be </span><strong class="source-inline"><span class="kobospan" id="kobo.790.1">export function prefixAutoIncrementIdGenerator</span></strong><span class="kobospan" id="kobo.791.1"> and its consumer would import </span><strong class="source-inline"><span class="kobospan" id="kobo.792.1">{prefixAutoIncrementIdGenerator}</span></strong> <span><span class="kobospan" id="kobo.793.1">from </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.794.1">'./path-to-module.js'</span></strong></span><span><span class="kobospan" id="kobo.795.1">.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.796.1">prefixAutoIncrementIdGenerator</span></strong><span class="kobospan" id="kobo.797.1"> functions like the </span><strong class="source-inline"><span class="kobospan" id="kobo.798.1">PrefixedAutoIncrementIdGeneratorAdapter</span></strong><span class="kobospan" id="kobo.799.1"> class did, generating auto-incrementing IDs and</span><a id="_idIndexMarker110" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.800.1"> prefixing them where possible </span><span><span class="kobospan" id="kobo.801.1">by </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.802.1">entry.name</span></strong></span><span><span class="kobospan" id="kobo.803.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.804.1">
const prefixAutoIncrementDatabase = new Database(
  prefixAutoIncrementIdGenerator
);
const noPrefixIncrementingEntryId1 =
  prefixAutoIncrementDatabase.createEntry({
  type: 'no-prefix',
});
const noPrefixIncrementingEntryId2 =
  prefixAutoIncrementDatabase.createEntry({
  type: 'no-prefix',
});
console.assert(
  noPrefixIncrementingEntryId1 === '1' &amp;&amp;
    noPrefixIncrementingEntryId2 === '2',
  'prefixAutoIncrementDatabase generates autoincrementing
     ids with no prefix if no name property is set'
);
console.assert(
  prefixAutoIncrementDatabase.get
    (noPrefixIncrementingEntryId1).type ===
    'no-prefix' &amp;&amp;
    prefixAutoIncrementDatabase.get
      (noPrefixIncrementingEntryId2).type ===
      'no-prefix',
  'prefixAutoIncrementDatabase recalls entries by
    autoincrementing id'
);
const prefixIncrementingEntryIdPear1 =
  prefixAutoIncrementDatabase.createEntry({
  name: 'pear',
});
const prefixIncrementingEntryIdPear2 =
  prefixAutoIncrementDatabase.createEntry({
  name: 'pear',
});
const prefixIncrementingEntryIdApple1 =
  prefixAutoIncrementDatabase.createEntry(
  {
    name: 'apple',
  }
);
console.assert(
  prefixIncrementingEntryIdPear1 === 'pear:1' &amp;&amp;
    prefixIncrementingEntryIdPear2 === 'pear:2' &amp;&amp;
    prefixIncrementingEntryIdApple1 === 'apple:1',
  'prefixAutoIncrementDatabase generates prefixed
    autoincrementing ids'
);
console.assert(
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdPear1).name ===
    'pear',
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdPear2).name ===
    'pear',
  prefixAutoIncrementDatabase.get
    (prefixIncrementingEntryIdApple1).name ===
    'apple',
  'prefixAutoIncrementDatabase recalls entries by prefixed
    id'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.805.1">In this final section of the</span><a id="_idIndexMarker111" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.806.1"> chapter, we covered the adapter pattern and how to use it when the consu</span><a id="_idTextAnchor093" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.807.1">mer expects a class but also a function </span><span><span class="kobospan" id="kobo.808.1">in JavaScript.</span></span></p>
<h1 id="_idParaDest-50" class="calibre5"><a id="_idTextAnchor094" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.809.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.810.1">In this chapter, we’ve looked at how structural design patterns enable the extension of functionality without needing to rework interfaces </span><span><span class="kobospan" id="kobo.811.1">in JavaScript.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.812.1">The proxy design pattern is useful when we want to intercept calls to an object without changing </span><span><span class="kobospan" id="kobo.813.1">the interface.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.814.1">By contrast, the decorator design pattern concerns itself with dynamically adding functionality through new </span><span><span class="kobospan" id="kobo.815.1">instance members.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.816.1">The flyweight pattern can be used effectively for managing large numbers of objects, which is especially useful for value objects. </span><span class="kobospan" id="kobo.816.2">There are workarounds in JavaScript for some of the ergonomic drawbacks </span><span><span class="kobospan" id="kobo.817.1">of it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.818.1">The adapter pattern allows us to integrate multiple classes, modules, or functions with different opinions and interfaces without modifying them. </span><span class="kobospan" id="kobo.818.2">The shape of the adapter is dictated by the existing modules and classes that we’re attempting to </span><span><span class="kobospan" id="kobo.819.1">connect together.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.820.1">Now that we know how to organize relationships between different objects and classes with structural design patterns, in the next chapter, we’ll cover how to use behavioral design patterns to organize communication </span><span><span class="kobospan" id="kobo.821.1">between objects.</span></span></p>
</div>
</body></html>