- en: Programming with Types and Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at type-driven development using ReasonML,
    but what are types exactly? And how do they interact with other parts of your
    program? How do they help you on a regular basis, and what does it look like to
    use a strong static type system with type inference?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an editor workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types and values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable values and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static versus dynamic typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type erasure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type errors and inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the most from this chapter, we will set up a comfortable edit-compile
    workflow. We recommend placing two windows side-by-side in your editor. VSCode
    supports this functionality with the View | Split Editor command. On one side,
    load a Reason source file; on the other side, load the JavaScript output file
    (once it is initially compiled). Then in a terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command starts a build in *watch mode,* which automatically recompiles
    any parts of a project that are affected whenever you change any source code.
    In fact, watch mode is smart enough to also remove an outdated JavaScript output
    file whenever its corresponding Reason source file is deleted. The editor will
    also auto-reload the compiled JavaScript file whenever you save a Reason source
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In VSCode, you can also open a terminal session directly below the files using
    the View | Integrated Terminal command and run `bsb -w` to get a single integrated
    view of your entire workflow. This way, when there are compile errors, you won't
    have to switch windows to see them. Of course, you may prefer to work with two
    monitors and keep the terminal and compiler running on another screen so you don't
    have to switch windows—that's feasible, too.
  prefs: []
  type: TYPE_NORMAL
- en: Types and values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set the stage for the rest of the book with a discussion of types and
    values. At its core, a type is a set of values. Think of the type `bool`, which
    is what Reason calls the normal Boolean type. A `bool` value can be one of two
    different things: `true` or `false`. We say that these values *inhabit* (live
    in) the type. Anything else is an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This raises an interesting question: *what does it mean to say? Anything else
    is an error'' in this context? In fact, why should we care about types at all?*'
  prefs: []
  type: TYPE_NORMAL
- en: To answer these questions, let's think about what should happen if we try to
    do the operation `"Bob" / 5`. What does it mean to divide the string `Bob` by
    the number `5`?
  prefs: []
  type: TYPE_NORMAL
- en: If you can't think of a good answer, well neither can anyone else. It's kind
    of a meaningless question. It's like asking, *how does the color green taste?* (Although
    this may be a meaningful question for synesthetic people.)
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, this is the simplest answer to why we care about types – to avoid having
    to deal with meaningless questions. To rule out meaningless operations, we simply
    make them type errors in the programs that execute the code. In other words, we
    get our compilers and interpreters to slot all our values into distinct types,
    or errors if any operations can't be meaningfully performed for the given types
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: Static types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two possible times when type errors can happen: at compile time and
    at runtime. This is the crucial difference between static and dynamic type systems:
    static type systems are so called because they *statically analyze* programs and
    try to find type errors, while dynamic type systems are so called because they
    throw type errors dynamically, while they run the program.'
  prefs: []
  type: TYPE_NORMAL
- en: A dynamic type system will definitely find all the type errors in your program,
    provided it actually runs all the execution paths in it. Any paths that remain
    unexecuted may contain hidden type errors.
  prefs: []
  type: TYPE_NORMAL
- en: A static type system will try to find as many errors as possible without running
    your program. Normally, this is not a guarantee that you will catch all type errors
    before runtime. Some errors may slip through the **typechecker** and still hit
    you at runtime. Plus, a type system may make it difficult to express a program
    that you know is correct because it thinks it's not. You will want to pay close
    attention when this happens, though, as either the typechecker is correct, or
    your design will benefit from expressing the program in a different, accepted,
    way.
  prefs: []
  type: TYPE_NORMAL
- en: What do you gain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With regard to the caveats mentioned earlier, what do static type systems actually
    give you?
  prefs: []
  type: TYPE_NORMAL
- en: A good type system catches almost all type errors for you before runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It accepts all or almost all programs that do not contain type errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to catch type errors before runtime is a very nice ability to have.
    It will help you to avoid possible downtime, expenses, lost business, and so on.
    Note that we mentioned a *good* type system. We should try to aim for the best
    type system we can get at our disposal. Since, Reason is OCaml, it automatically
    gets OCaml's powerful, safe, and expressive type system.
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s develop a mental model for what happens in a program with types and
    values. At its core, a program is made up of a series of type and value definitions.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're defining `person` and `company` `types`, and then allocating a person
    (`bob`) and a company he works for (`acmeCo`).
  prefs: []
  type: TYPE_NORMAL
- en: Without worrying too much about the syntax (we will introduce this in [Chapter
    4](ba37505a-f222-4238-a13c-259160ca582d.xhtml), *Group Values Together in Types*),
    let's think about how the programming environment sees this program.
  prefs: []
  type: TYPE_NORMAL
- en: In a statically typed programming language, the typechecker and runtime environment
    together make up the *static* and *dynamic environments.* These are areas where
    type definitions are stored while typechecking takes place, and where value definitions
    are stored during program execution (runtime). We can think of these as two distinct
    areas that are only relevant during the distinct phases of compilation and runtime.
    After compilation, all type information is wiped out (*type erasure*), but during
    runtime the dynamic environment becomes active in memory (that is, the stack and
    the heap).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the static and dynamic environments look for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Static Environment** | **Dynamic Environment** |'
  prefs: []
  type: TYPE_TB
- en: '| `type person;` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `type company;` (refers to  **`person`**) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `let bob;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `let acmeCo;` (refers to `bob`) |'
  prefs: []
  type: TYPE_TB
- en: Example of static and dynamic environments (evaluated top to bottom)
  prefs: []
  type: TYPE_NORMAL
- en: In each of the static and dynamic environments, each definition is allowed to
    refer to definitions that came before it. This is a crucial abstraction technique
    – it's how we build larger programs out of smaller ones at both the type and value
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no references between the static and dynamic environments – values
    don''t exist at compile time and types don''t exist at runtime. This may come
    a surprise as we do mix them in one place: the source code.'
  prefs: []
  type: TYPE_NORMAL
- en: Among other things, this strict separation balances the needs of safety and
    efficiency. Note that this is in sharp contrast to dynamic typing, where types
    exist at runtime as well, and must be checked before every operation.
  prefs: []
  type: TYPE_NORMAL
- en: Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to understand how values work in Reason. We've seen that they
    come into play at runtime and live in memory but it's also important to know that,
    by default, all values are immutable –effectively, constants. There are a couple
    of exceptions, which we will cover, but generally we will work in a style where
    we don't try to change values, and instead just create new values out of old ones.
    This is a style that is well-supported by Reason and is a foundation of functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a syntax for binding values to names, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax slots the value on the right-hand side into the shape described
    in the left-hand side, as long as their shapes match. The general name for this
    concept is *pattern matching*, and we will see it a lot in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, the patterns (to the left of `=`) we''ve seen have been just simple
    names, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding pattern has allowed us to capture the entire value in the name
    and reuse it later. The way it works is that Reason checks that the value (`1`)
    can fit inside the pattern (`x`). In this simple case, there is nothing about
    the pattern that prevents the value from fitting inside. We call this an *irrefutable
    pattern.* In further chapters, we will see examples of *refutable* patterns and
    how they behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wherever you see the keyword `let`, you should understand that it may be allocating
    memory, if:'
  prefs: []
  type: TYPE_NORMAL
- en: The bound value is a literal (for example, `"Bob"`), or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bound value is the result of a function or operator call, and the function
    or operator call allocates a new value in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other cases are mainly of bindings to existing values or bindings to function
    calls that don't allocate.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we won't be worrying too much about allocation and memory use,
    but we will look at a couple of techniques of how to reduce them when necessary,
    which can come in handy when trying to boost performance.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping and shadowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we define values, they exist (in the dynamic environment) in a scope,
    in which all previously defined names are available but only until the end of
    the scope. Scopes are nested inside each other, starting with the *top level*
    scope (the definitions at the file level), and nested scopes inside braces (`{...}`).
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x` and `y` are in the top level scope, where `y` can access `x` by name
    because `x` is defined before `y`; `z` can access both for the same reason. However,
    note the definition of `result` in the nested scope introduced by the braces.
    The name `result` is only available from the point it is defined up until the
    closing brace; outside of that scope, referring to `result` will result in a compile
    error (specifically, a *name error,* which we will talk about later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Reason puts all definitions in certain scopes, we can define the same
    name more than once in the same scope or in a nested scope. This is called **shadowing**
    because the new definition hides the old one until the new one goes out of scope.
    Of course, if the old and new names go out of scope together (that is, they''re
    in the same scope), the old name is effectively hidden forever. The following
    codeblock is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now take a look at the output JavaScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice how Bob's age is `34` in his `greeting `– the `age` in the `greeting`
    scope shadows `age` in the top level scope. However, as soon as that scope ends
    (with the closing brace), the original `age` becomes visible again and is used
    in Jim's `greeting2`.
  prefs: []
  type: TYPE_NORMAL
- en: However, the second `name` binding (`"Jim"`) permanently shadows the first one
    because they are both in the top level scope. In fact, since the first `name`
    and the inner `age` will never be visible again, the BuckleScript compiler doesn't
    even bother to output them, instead directly inlining their values.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding type erasure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To concretely grasp the effect of static/dynamic separation, let''s look at
    type erasure, which is something that happens when we compile the preceding code
    to JavaScript. The following is the output with all redundant comments removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned earlier, BuckleScript compiles Reason record types into JavaScript
    arrays with the corresponding number of elements. BuckleScript, in fact, performs
    quite a number of optimizations for you. Some of these come from its underlying
    OCaml compiler technology, which has been developed since the 1990s, but other
    things are quite unique in the world of language-to-JavaScript compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that BuckleScript has wiped out both the type definitions and has output
    only the minimum number of values it actually needs for runtime. The important
    thing to understand here is that all the output values follow the laws introduced
    by their corresponding types; for example, the `Bob` value, of type `person`,
    can only be an array with two elements (a number and a string, corresponding to
    the two fields in the person record), and the `acmeCo` value can only be an array
    with three elements of the correct types. Anything else is impossible – with a
    mathematical degree of certainty – even in output JavaScript code, because code
    that doesn't pass the typing rules (that is, doesn't typecheck) would not even
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned earlier that the compiler will raise errors if it cannot make sense
    of a piece of code it comes across. There are a few different kinds of compiler
    errors, and they are as follows
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stale interface errors (which we'll cover in the next chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler bugs (these are rare but shouldn't be discounted)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two most common types of error that we will deal with are syntax errors
    and type errors. Name errors are fairly simple to avoid: always start type names
    with a lowercase letter and ensure that the names you refer to in your code were
    defined before you refer to them. (Reason supports *cyclic references* but not
    *forward references*;we''ll cover cyclic references later on.)'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Syntax errors are a basic kind of error and happen when the compiler literally
    can''t make sense of the source code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you spot the error in the preceding code? If you compare it with the `person`
    definition in `src/Ch02/Ch02_Demo.re`, you should be able to. In any case, the
    compiler will tell you (usually fairly accurately) where to look. The only problem
    is you''ll have to learn to sift through the compiler output to find the exact
    error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Syntax errors start with the text `File "/path/to/file", line L, characters
    C1-C2:` (where `L`, `C1`, and `C2` are the actual line and character numbers).
    The error message, `<UNKNOWN SYNTAX ERROR>`, is not too helpful, but the line
    and character positions pinpoint the location pretty well. Confusingly, there
    is also another error message starting in the same way, but this time with `line
    1 and characters 0-0: Error while running external preprocessor`. This is Reason''s
    way of redundantly saying it couldn''t understand the code, and is hopefully going
    away soon!'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the error points at the 23rd and 24th characters, where you
    see a semicolon and space; if you compare that with the correct version of the
    code, you see that it should be a comma and space.
  prefs: []
  type: TYPE_NORMAL
- en: When you're starting out with Reason, you should expect to see more of these
    syntax errors, and to spend some time working through exactly why they're happening.
    As you learn the syntax, you can expect to be able to tell just by looking at
    it that a piece of code doesn't contain the correct syntax. The correct syntax
    is available in Reason's excellent reference documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Type errors and inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other main kind of compiler error you will see is a **type error***.* A
    type error is an error that arises when a type (or a value of a type) is used
    in a way that's not allowed by the type definition.
  prefs: []
  type: TYPE_NORMAL
- en: These are more interesting errors because you're likely to come across them
    for the rest of your programming career, during which you should expect to continue
    seeing large productivity and code quality benefits from type errors forcing better
    design thinking and bug reduction.
  prefs: []
  type: TYPE_NORMAL
- en: Type errors are also heavily tied into Reason's type inference engine, which
    through a process of elimination works out exactly what the types should be for
    every piece of the code. Let's look at a few simple type errors and the code that
    will trigger them. We will also explain the type inference rules that led to the
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s try the division problem we posted earlier (the bold parts are
    colored red in Reason''s error message):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the process of elimination by which Reason arrives at type errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns types to the smallest possible parts of the expression, one by one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tries to fit all the types together like puzzle pieces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they fit, pass typechecker
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If they don't fit, raise a type error
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the type inference and checking process (read from
    left to right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c41a6ac-1481-438b-a8d9-99c671a73adf.png)'
  prefs: []
  type: TYPE_IMG
- en: The type error arises from the fact that `"Bob"` is a string (anything inside
    double-quotes is inferred to be a string), whereas the division operator `(/)`
    by definition requires two `int` variables as input. However, Reason can still
    infer `result` to be an `int` because it knows the division operator outputs an
    `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try a slightly more interesting type error, from not creating a
    record correctly, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the typechecking process for a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42cc87e5-0431-42a1-ab82-e368904ca238.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the type error arises because one of the components of the record does
    not have the correct type. You can compare the code in the error message with
    the source code to exact
  prefs: []
  type: TYPE_NORMAL
- en: You may be curious to know why the division type error was reported the way
    it was, when it may have been more natural to work from left to right and produce
    an error like string does not support division by ints. This is because the typechecker
    works on the *abstract syntax tree* of the program – that is, an internal representation
    of the program itself after it has been parsed (and verified as free of syntax
    errors). The AST is structured, as you might have guessed, as a tree, and in the
    tree, operations and function calls are the parent nodes of their arguments. So,
    the operations are assigned types first and then their arguments. Hence you see
    `"Bob"` as the thing that caused the type mismatch, instead of `(/)`.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, though, typechecking could go in either direction – from the
    root of the AST to its leaf nodes or the other way round as normal. You may often
    hear the process of fitting the types together referred to as **unification**,
    which means the same thing. If instead of `"Bob"` , the first operand had been,
    for example, `10` (of type `int`), Reason would have been able to unify their
    types (`int` and `int`) and thus pass typechecking.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground, including setting up an editorial
    workflow, learning about types and values, static and dynamic typing, Reason's
    separation between compile time and runtime and its type erasure, syntax, and
    type errors, as well as inference and unification.
  prefs: []
  type: TYPE_NORMAL
- en: In future chapters, we will build on this chapter and introduce many more static
    typing techniques and the potential type errors that we may see from using them.
  prefs: []
  type: TYPE_NORMAL
