- en: Creating Components and Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to the second part of this book and congratulations for coming here!
    Now that you know the basic principles and techniques of programming in JavaScript,
    it''s time to go deeper and know much better about some advantages offered by
    the wonderful framework that is Aurelia. Our starting point in this chapter will
    be to understand what is a component and how we can manage its life cycle through
    events that are taking place in our application. Then, we will explore the dependencies
    injection, a well-known design pattern used by most popular frameworks such as
    Java EE, Spring, and Aurelia! Our main focus will be to explain how we can manage
    our DOM and dynamically display the data on the screen, configure routes to access
    certain functionalities in our application, and, of course, apply everything learned
    in our FIFA World Cup application. This chapter will cover a lot of very useful
    concepts, some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component's life cycle/events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aurelia router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Lego components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern frontend JavaScript frameworks provide some sort of support for
    component-based development. This is an incredibly important step in the direction
    of development for the web. Components provide a way to write small parts with
    a consistent API that can easily be orchestrated as part of a larger screen, application,
    or system. Imagine each component as a Lego piece—you can use it wherever you
    want and it will keep the same shape and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: A component can be an HTML part, a JavaScript piece of code, a service, and
    so on. Any reusable part should be interpreted as a component.
  prefs: []
  type: TYPE_NORMAL
- en: A little puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s practice a little how to think and abstract one application into a few
    components. Here''s some web template with some sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c5b48a6-3104-4d9c-bf72-3d6f4ef7a209.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, it's time to think.
  prefs: []
  type: TYPE_NORMAL
- en: How many sections are similar?
  prefs: []
  type: TYPE_NORMAL
- en: Buttons are very similar; just the text/color can change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu options can be a reusable single component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Main page sections are the same; just the content changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header can be decoupled from the application main section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Which sections do you think can be reused across application pages, take a
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: Main page sections can be used as a container for other options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The buttons can be shared across all the application sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last, but not the least, do you think you need to refresh the entire page when
    you submit or just some sections?
  prefs: []
  type: TYPE_NORMAL
- en: A better option can be to refresh only what really needs to be refreshed. Each
    section can independently manage their data and the way it's retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all these answers depend on the business rules of the application,
    but the principles are always the same. If you find some section of your application
    that can be reused, reloaded, managed, and maintained independently of other sections,
    you should decouple it into a single component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have defined what parts of your application will be a component, it''s
    time to organize. You must identify which components will be used just for some
    page in particular (maybe an Item component for a shopping cart page), how many
    of them will be shared across the entire application (a common table to be used
    into many reports of your application) and finally, organize them by separated
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e1fbeed-1565-415e-8367-1a8cac8ca853.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's create one folder per component; you should keep in mind that if
    some component will be *parent* of another component, the *child* folder should
    be created inside the parent, to specify ownership. Remember always that as a
    programmer, your main goal is to make your code readable and understandable to
    other developers—that's a good quality measure!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/383cf5cc-e2e5-4d1b-af94-55706141dcb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we now have our folder structure created for our components.
    An Aurelia component is basically composed of two files: the HTML template, called
    **view**, is rendered into the DOM. The `.js` file, called **view model**, is
    written in ES Next, and it defines the behavior and provides data for the view.
    The templating engine, along with **dependency injection** (**DI**), that we will
    explain in detail in the following sections, is responsible for creating and enforcing
    a predictable life cycle for the component. Once the component is instantiated,
    Aurelia’s data binding links the two pieces together, allowing changes in your
    view model to be reflected in the view and vice versa. This separation of concerns
    allows us to work/collaborate with designers and improve our product quality.
    Let''s create one component as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should remember some good practices about naming your components:'
  prefs: []
  type: TYPE_NORMAL
- en: Use dashes for naming your components. For example, `<my-component>` and `<my-other-component>`
    are valid name syntax, while `<my_component>` , `<myComponent>` and `<my_other_component>`
    are not. You must keep this notation, because the HTML parser will differentiate
    between custom and regular elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't register an already existing tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom elements are not self-closing. Only native HTML attributes allows this
    feature. Ensure that you write a closing tag (`<my-component></my-component>`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our first component is created, hard coded, and works. Wait a second… how does
    the `.html` template know that my `.js` file is correct for retrieving data? Aurelia
    works under one premise: convention over configuration. What does that mean? If
    we use the same name for both files, the framework automatically will map that
    JavaScript file managing the `.html` template, we do not write any configuration
    code (different from other frameworks). Now, it’s time to integrate it into our
    main page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to import the filename with the `<require>` tag. For other reasons,
    this tag will be in the top section of the page. Then, we just call the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Launch your application, and you will see your component in action. In this
    case, we just defined one single property to be rendered from the `.js` file to
    our template. This is a very basic example, so don’t worry, the action is coming!
  prefs: []
  type: TYPE_NORMAL
- en: Learning how DI works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is based on the Inversion of control pattern. Let’s explain that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we create a web application without Aurelia. You will have to
    manually implement something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Load/instantiate a view model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load/instantiate a view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the view to the view model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the view to the DOM
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle click on a link by user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the URL hash, determine which view model to load/instantiate, check whether
    the current view can be deactivated, and more
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rinse and repeat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, and many more times.  Without Aurelia, you are implementing the logic
    that controls the application life cycle instead of your application business
    logic and features.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create one using Aurelia. You won't work on any configuration code
    at the application level because the framework does that job for you. Instead,
    you focus on writing the views, view models, behaviors, and routes that embody
    your application's custom logic and appearance. Aurelia inverts the control, handling
    the application life cycle while allowing you to define your own features and
    behavior of the application. How? Through life cycle hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle hooks are optional methods you attach to view models. Aurelia's router
    and the templating engine will invoke these methods at the appropriate time, allowing
    you to control specific life cycle steps.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore all these methods deeper in the following sections; at the moment,
    we will focus only on **Inversion of Control** (**IoC**) and DI features.
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia uses the IoC pattern to reduce the work required to build applications.
    You can specify and control them however you want using overridable conventions
    and hooks when the application starts/ends.
  prefs: []
  type: TYPE_NORMAL
- en: DI uses the same pattern for resolving dependencies. A dependency is an object
    that can be used, or more specifically, a service. Using this pattern, you made
    that service a part of the state of the client object, because you are passing
    that entire service rather than allowing the client to build or find the service.
  prefs: []
  type: TYPE_NORMAL
- en: DI needs an injector. This injector is responsible to provide and construct
    the service object and define that inside the client's state. The client is not
    allowed to directly call the injector code. It only waits until all its dependencies
    are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two modules are the key enablers for the DI pattern''s application in Aurelia:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dependency**-**injection**: An extensible and very lightweight DI container
    for JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**metadata**: Provides a consistent way of accessing type, annotation, and
    origin metadata across a number of languages and formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate how the DI works, let''s define a typical view model class with
    some external services injected. The code should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's analyze that code. How is this view model created at runtime?
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia takes care of the creation order of each element, but how does it work?
    Well, first of all, Aurelia uses the DI container to instantiate all view models.
    As we said earlier, the client object doesn’t instantiate or locate their own
    dependencies. They rely on Aurelia to supply the dependencies as constructor arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How are these dependencies discovered?
  prefs: []
  type: TYPE_NORMAL
- en: In an object oriented language (such as Java), the DI container can identify
    each dependency by its type. In the case of Aurelia, the dependencies, implementations
    are determined using the constructor arguments order list. In JavaScript, we can
    store a variety of information about our components or application as metadata.
    We don't have the chance to define a type-based constructor to define our objects.
    To deal with this situation, we must embed this information on the class itself,
    as *metadata*.
  prefs: []
  type: TYPE_NORMAL
- en: We can use decorators to add a customized constructor signature to our classes,
    based on types to be consumed by the Aurelia's DI container. This is exactly what
    the annotation `@inject` (`CustomerService`) performs in the view model file.
    If you are a TypeScript user, you can use the `emitDecoratorMetadata` flag, used
    for the same purpose of adding a constructor info to our classes. Just add the
    `@autoInject()` decorator to your class; in this case, the constructor parameter
    types are not needed.
  prefs: []
  type: TYPE_NORMAL
- en: View models written in this way are easy to test and modularize. You can split
    a big class into small components and inject them to achieve the goal. Remember
    that large classes are hard to maintain and are very vulnerable to rely on the
    anti-pattern *spaghetti code*.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency resolution is a recursive process. Let's explain that—our customer
    view model has a dependency on the `CustomerService` file. When the DI container
    instantiates the `CustomerComponent` class, it first needs to retrieve the `CustomerService`
    instance or instantiate one if it doesn't already exist in the container. The
    `CustomerService` may have dependencies of its own, which the DI container will
    recursively resolve until the full dependency chain has been identified.
  prefs: []
  type: TYPE_NORMAL
- en: You can have as many injected dependencies as you need. Simply ensure that the
    inject decorator and the constructor match one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you are not using Babel or TypeScript decorator support, you can provide
    the inject metadata using a static method in your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Static methods and properties are supported. The inject decorator simply sets
    the static property automatically. Why use it? Just to make our syntax more elegant
    and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a component's life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we said earlier, Aurelia provides very complete life cycle event methods
    to customize and improve the behavior of our application. Here''s a list with
    these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore each method presented in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`constructor()`**: This is the first method that is called. It''s used to
    set all view model dependencies and values required for its instantiation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `constructor` method can be used for instantiating and initializing attributes
    to your component, and they should not necessarily be declared previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can initialize variables using class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`created(owningView, myView)`: Next, the `created` method is called. At this
    point, the view has been created and belongs to the view model; they are connected
    to the controller. This callback will receive the view declared inside of the
    `(owningView)` component. If the component itself has a view, it is passed as
    second parameter, `(myView)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind(bindingContext, overrideContext)`: At this point, the binding has started.
    If the view model has the `bind()` callback overridden, it will be called at this
    time. The first argument represents the binding context of the component. The
    second parameter is used for adding additional contextual properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '`attached()`: The `attached` callback is executed once the component is ready
    for use. It means instantiated and has its properties set and computed correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is perfect for retrieving data or set properties if you are using
    injected service methods. You can configure different ways to load your data,
    show loading alerts for the user, and increase the user experience. Let''s see
    a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can define fallback alerts or methods to ensure that we are
    handling errors correctly (just if needed).
  prefs: []
  type: TYPE_NORMAL
- en: '`detached()`: Called when the component will be removed from the DOM. Different
    from the previous methods, this method is not executed when the application starts.'
  prefs: []
  type: TYPE_NORMAL
- en: The same as the previous example, we can define this method to restore the data
    to a previous state, delete local storage data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`unbind()`: Called when the component is unbound.'
  prefs: []
  type: TYPE_NORMAL
- en: You should remember that each of these life cycle callbacks is optional. Just
    override what you really need. The execution order is the same as the list order
    mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Managing events with Aurelia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We were explaining how to override and catch determined events and methods in
    the component life cycle, but what if we want to write our own methods and execute
    them when the user clicks on some button or moves the mouse for one section? We
    will start to *delegate* events.
  prefs: []
  type: TYPE_NORMAL
- en: The event delegation concept is a useful concept where the event handler is
    attached to one single element instead of multiple elements on the DOM. What implies
    that? Memory efficiency. It drastically reduces the number of event subscriptions
    by leveraging the *bubbling* characteristic of most DOM events.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we have the trigger concept. Similar, but not equal. You
    should use trigger binding when you need to subscribe to events that do not bubble
    (blur, focus, load, and unload).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to disable a button, input, or another element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The element's content is made up of other elements (reusable component)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In code words, it can be explained like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In your view model, you should have the method implemented with the correct
    number of params, so each time the `<select>` element changes, the event will
    be delegated to your custom function to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s `trigger` the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are using `trigger` binding to catch a not bubbling event.
  prefs: []
  type: TYPE_NORMAL
- en: In your daily work, maybe `delegate` and `trigger` could be enough for managing
    events, but there are some situations where you will need to know a little more
    advanced features to deal with it. Imagine that you are integrating a third-party
    plugin and need to interact with this content. Normally, `trigger` or `delegate`
    should do the work, but this won't be the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But why? Remember that you are dealing with a third-party plugin, so this will
    manage its events independently of the `container` component. That being said,
    the inner plugin will call `event.stopPropagation()` on any click events.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what can we do in that case? Don''t worry, you have another option—the `capture`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, the method will be executed correctly. Again, the most important question,
    why? It's because with the `capture` command, the `onClickPluginContainer()` event
    is guaranteed to happen irrespective of whether `event.stopPropagation()` is called
    or not inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Now, at this point, maybe you are wondering "So...what command should I use?
    Which of these is better?" The answer is simple—it depends on what you need. We
    recommend that you use `delegate`, because you will improve your application performance.
    Then, use `trigger` only if the event requires this, and finally, use `capture`
    if you will deal with third-party plugins or elements that you can't control,
    but remember that this last one is not commonly used and is not how you should
    normally work with browser events.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more info about delegate and trigger in the official docs: [https://aurelia.io/docs/binding/delegate-vs-trigger/](https://aurelia.io/docs/binding/delegate-vs-trigger/)
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aurelia has its own data binding system. Let's explain that with an example.
  prefs: []
  type: TYPE_NORMAL
- en: You know that you need to define a view and a view model file for each Aurelia
    component. Binding is the process that reflects the view model data into the view,
    and vice versa. As we said earlier, one of Aurelia's most beautiful features is
    double-binding framework, so you won't have to worry about updating the data on
    the view or view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aurelia supports HTML and SVG attributes to JavaScript expressions. The binding
    attribute declaration is composed of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attribute`: Refers to the HTML/SVG attribute we will apply to the binding.
    For example, one input tag could have defined the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`value` and `id` will be the attributes we could refer.'
  prefs: []
  type: TYPE_NORMAL
- en: '`command`: Here, you will use one of Aurelia''s binding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**one**-**time**: Flows data to one direction, from view model to view, just
    once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**to**-**view **/ **one**-**way**: Flows data in one direction, from view model
    to view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**from**-**view:** Flows data in one direction, from view to view model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**two**-**way**: Default behavior, flows data from view model to view and vice
    versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bind**: Automatically chooses the binding mode. It uses two-way binding for
    form controls and to-view binding for almost everything else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s use the same input element defined earlier as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first `input` element uses the `from-view` command to bind anything the
    user writes in the `input` element, but this value cannot be changed and reflected
    from the `view-model` into the `view`. The `id` attribute uses the `two-way` binding,
    so this `id` can be updated in the view layer and reflected in the view model.
    The second binds the `value` attribute just once, then any update to this value
    will be ignored. In the case of the `id` attribute, it is generated by the `view-model`
    file, and any modification from `view` won't be reflected on `view-model`.
  prefs: []
  type: TYPE_NORMAL
- en: '`expression`: The last part. Commonly a JavaScript expression used to reflect
    `view-model` attributes, computed properties, and so on. Again, let''s use the
    same `input` element for example purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `value` attribute just reflects the **`modelValue`** property into the view.
    The `id` attribute is performing an operation to attach a random number generated
    in the view model into one predefined property and use it as a single value to
    bind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same way that as event managing part, there could be some situations that
    you will need to use a little more advanced features to get the expected results.
    Commonly, you may deal with situations where you have `@bindable` properties while
    developing custom elements/attributes. These properties expect a reference to
    a function, so just use the `call` binding command to declare and pass a function
    to the bindable property. The `call` command is superior to the `bind` command
    for this use case, because it will execute the function in the correct context,
    ensuring that this is what you expect it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`go` is the `@bindable` attribute, and `doSomething()` is your `view-model`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more feature you can add to your application is string interpolation. These
    expressions enable interpolating the result of an expression with text. The best
    way to demonstrate this capability is with an example. Here are two `span` elements
    with data-bound `textcontent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we know the basic concepts about Aurelia's binding engine. Now,
    let's use this great feature in more advanced ways to improve our application!
  prefs: []
  type: TYPE_NORMAL
- en: We have explored in Chapter 2, *Styling the User Interface*, some ways to add
    CSS to our application and make it look great. However, in your daily work, you
    can find some common situation that will make you 'mix' some features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one:'
  prefs: []
  type: TYPE_NORMAL
- en: You are writing a dashboard page and depending on user status (active, inactive),
    the Submit button should look colorful or just disabled with a different shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can bind an element''s `class` attribute using string interpolation or
    with `.bind/.one-time`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using ternary operations, you can say to your view which class should be rendered
    into the view. Let''s analyze the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isActive` refers to a boolean property defined in view model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?` is the ternary operator. If the condition is `true`, the first argument
    will be used, in this case, the `''btn-active''` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:` represents the `else` element of the condition. If it''s evaluated to false,
    the second argument after the `:` will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aurelia allows you to use external JavaScript libraries. It supports, on its
    binding system, only adding or removing the specified classes in the binding expression.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, classes added by other code (for example, `classList.add(...)`)
    are not removed. This behavior implies a small cost, noticeable only in benchmarks
    or some critical situations like iteration of large lists. Replace the default
    behavior by binding directly to the element's `className` property using `class-name.bind="...."`,
    or `class-name.one-time="..."` can be a better option; so much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to classes, you can bind style attributes directly into the DOM. Remember
    that defining styles directly into the element is not wrong, but using classes,
    you can add more standardization to your elements and make this easy to maintain.
    Like other HTML attributes, you can use `style.bind` to retrieve `style` definitions
    from your `view-model`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s define one array of styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `view` file, we just need to bind the predefined properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use string interpolation too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you need to add compatibility with Internet Explorer and Edge,
    this syntax will be illegal. In those cases, you must use the `css` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Binding computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes it is desirable to return a dynamically computed value (post-processed
    value) when accessing a property, or you may want to reflect the status of an
    internal variable without requiring the use of explicit method calls. In JavaScript,
    this can be accomplished with the use of a getter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s no trick here, you just need to bind the `fullName` property. The
    binding system will analyze the property and how we are referring to a function;
    it will process the required info before rendering the computed value. This is
    also called **dirty checking**; it will be constantly observing if some property
    changes its value, and if it has some repercussions on the computed element, it
    will be re-evaluated and reprocessed. Sounds like a multiple execution of the
    same method? Yes, your getter function will be called so many times, approximately
    once every 120 milliseconds. That''s not an issue, but if we have a lot of computed
    properties or if our getter functions are a little complex, you should consider
    indicating to the binding systems which properties you want to observe; at this
    point, dirty checking is avoided. This is where the `@computedFrom` decorator
    comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`@computedFrom` will tell the binding system which properties need to be observed.
    When those expressions change, the binding system will reevaluate the property
    (execute the getter). This eliminates the need for dirty checking and can improve
    performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Value converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we explained before coming across this topic, user interface elements in
    Aurelia are composed of two files: view and view model pairs. The view is written
    in pure HTML and is rendered into the DOM. The view model is written in JavaScript
    and provides data and behavior to the view. Aurelia links the two files together,
    as one single element using its powerful data binding engine, allowing changes
    in your view model to be reflected in the view and vice versa. Sometimes the data
    showed by your view model is not in a good or understandable format for displaying
    in the UI. Dealing with date and numeric values are the most common scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our view should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will give us the current date and some random number; well, that''s
    what we are expecting and that''s okay, but let''s see how this data is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That's definitely not friendly for user reading. A cool solution to this problem
    can be to compute the formatted values and expose them as properties of the `view-model`
    file. This is a valid approach, but remember that we are overloading our model
    with extra properties and methods; it can be a little messy in the future, especially
    when you need to keep the formatted values in sync when the original property
    value change. Fortunately, Aurelia has a feature to help us deal with these situations.
  prefs: []
  type: TYPE_NORMAL
- en: The most common option will be to create value converters to translate the model
    data into a readable format for the view. All okay at this point, but what happens
    if it is the view that needs to convert the value for sending it into a format
    acceptable for the `view-model`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Aurelia value converters are quite similar to other value converters of another
    languages, such as XAML. The nice thing is that Aurelia comes with some notable
    improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Aurelia `ValueConverter` interface uses two methods: `toView` and `fromView`.
    These methods define the direction the data is flowing in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aurelia value converter methods can accept multiple parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aurelia allows you to use multiple value converters in one single property,
    just using pipes (`|`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example to convert our date property into a more friendly
    readable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `view-model` file won''t change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our `view-model` file will look quite different at this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With this value converter, we''ll see this value on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This looks much better. Again, it's time to ask the more important question—why?
    Let's examine what we did. First, we created our value converter class called
    `DateFormatValueConverter` and implemented the `toView` method. Aurelia will execute
    this method and apply to the model values before displaying the data on screen.
    For converting purposes, we are using MomentJS. Next, we've updated the `view`
    file and added `<require>` tags to import our value converter class into the view
    that will use it.
  prefs: []
  type: TYPE_NORMAL
- en: When the framework processes the resource, it examines the class's metadata
    to determine the resource type (custom element, custom attribute, value converter,
    and such). Metadata isn't required, and in fact, our value converters didn't expose
    any. If you are curious, you must note something—we used the `ValueConverter`
    postfix to name our converter class. Again, why? It's because you must remember
    that one of the Aurelia bases is convention over configuration. In this way, the
    name ending with `ValueConverter` will be assumed to be one value converter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will show you a little more advanced example. Let''s apply some changes
    to our class converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `view-model` file is still the same. Now, our template file will change
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use the same value converter class to render data in different formats,
    according to our view demands.
  prefs: []
  type: TYPE_NORMAL
- en: Without any doubt, we have covered some of the most important features of Aurelia's
    binding behavior, but, for sure, there are more methods and commands that we will
    see in practice. For the moment, we are ready to pass to another important concept—routing.
  prefs: []
  type: TYPE_NORMAL
- en: Routing and resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Routing is one of the most important parts of a web application. We already
    have our application deployed in `http://localhost:9000`, but it''s time to start
    defining names and addresses for our resources. First, we need to define what
    a resource is. Conceptually, a resource is every related data belonging to one
    single object or element. For example, a person resource can have fields such
    as name, address, birthday, and more. So, expanding this, a resource can be a
    list of persons too. We will talk deeply about how your resources should be named,
    organized, and called, but at this moment, you just need to know the basics. In
    a web application, every resource has its own address. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an address book with some contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:9000/` is the server URL, the base of all resources, the
    father path. Generally related to the home/welcome page, or first you define the
    user''s view. The page has a button to see all our contacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://locahost:9000/persons` is a URL related to the person list resource.
    Here, we will show a list of persons of our address book. You are able to pick
    one to see its contact details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://locahost:9000/persons/p001` will refer to the person with the `p001`
    ID. Here, we will be able to see its details. If you give this URL to another
    user, they should be able to see the same data as you, because this URL belongs
    to one single contact—the `p001`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://locahost:9000/persons?search=p001` is a little different. Imagine that
    our contact list is composed of more than 500 people. Don''t you think it could
    be easier for the user search them by ID, name, or the most generic parameter?
    Here, we are using a query-param to express our search criteria; of course, we''re
    still working with our friend `p001`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's configure our application to be ready for routing.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have already created some components in our application. If
    not, don't worry, we will have enough time to practice that in the last part of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add some code to our `app.js` file. Remember that this file should
    be located in the base `src` folder of our application, since now it will represent
    our base route for all the applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the properties and methods used to define our routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configureRouter(config, router)` is a reserved method that the framework will
    evaluate in the base `view-model` when the application starts. The parameters
    are referencing to the `Router`, `RouterConfiguration` from `aurelia-router` package.
    If they are not provided, the framework will inject them automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.router = router` is a reference to the router element, just to allow
    us to access this from the view layer (`app.html`), allowing us to build navigation
    menus dynamically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.title` refers to our application title displayed in the browser window.
    Technically, it''s applied to the `<title>` element in the `<head>` of the HTML
    document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.map()` adds route(s) to the router. Although only `route`, `name`,
    `moduleId`, `href`, and `nav` were shown earlier, there are other properties that
    can be included in a `route`. The interface name for a `route` is `RouteConfig`.
    You can also use `config.mapRoute()` to add a single `route`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route` is the pattern to match against the incoming URL fragments. It can
    be a string or array of strings. The `route` can contain parameterized routes
    or wildcards as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s analyze the routes we''ve created:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first `route` element, the first flag, `route`, is making reference to
    the base path (`''`) and the `home` path. If we directly access `http//:localhost:9000/`
    or `http//:localhost:9000/home`, the application will display the same page. The
    `name` flag is the URL identifier to call directly from one link or `href` element.
    Finally, we need to reference which file we are referencing with the `route`;
    in this case, the component is located in `home/index` and will be represented
    inside the `moduleId` flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second URL is referencing to the `users` resource, but it has some variations.
    The `nav` flag can be a Boolean or number property. When set to true, the route
    will be included in the router's navigation model. When specified as a number,
    the value will be used in sorting the routes; this makes it easier to create a
    dynamic menu or similar elements. Finally, the `title` flag will show the page
    title appended to the page title in the browser window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third is a little different. We can see a weird param in the middle of the
    route, the `:id`. This means that this part of the URL signature will be dynamic,
    do you remember our person `p001`? The `:id` parameter will be used to represent
    the `p001` code and make the URL unique for this resource. Also, in the `view-model`
    file, we will be able to consume that parameter and retrieve some data related
    to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we are seeing `'files/*path'`. Wildcard routes are used to match the
    *rest* of a path. The `href` flag is a conditionally optional property. If it
    is not defined, `route` is used. If `route` has segments, `href` is required as
    in the case of files, because the router does not know how to fill out the parameterized
    portions of the pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be some situations where you will need some extra features to deal
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, case-sensitive routes; Aurelia has that problem solved too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `caseSensitive` flag will be used in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another situation, very common, can be the unknown routes; Aurelia has a nice
    way to deal with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `config.mapUnknownRoutes()` method will make a reference to the `''not-found''`
    component module. Another way is representing it as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Other common scenario could be redirected routes. This is very simple—you just
    need to add the `redirect` flag and specify the reference to the module you want
    to show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we know how to configure the routing at the `view-model` level,
    but what about the view? Don't worry, this will be our next topic.
  prefs: []
  type: TYPE_NORMAL
- en: All this configuration was performed in the `app.js` file, so now we need to
    go to our `app.html` file. You must consider some things before adding the routing
    property to your template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commonly, most web applications use a base layout. This can be composed by
    the header, a lateral menu, and the view content. That being said, the only element
    that should be refreshed and reloaded with the router is the view content; the
    header and the menu will always be the same for the entire application, so we
    need to define our router element inside that container; let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<router-view></router-view>` is the HTML flag that Aurelia router will
    use to render the components we''ve configured as routes. Graphically, the representation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96e2aed5-5449-4d52-9a56-1b09c80c7171.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, everything is okay. However, this is a very basic approach; let's
    explore some advanced way to make our layout more flexible and configurable. We
    know that the `router-view` element defined in HTML is always associated with
    one or more views referenced in a router configuration method defined in its parent
    view's view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a layout on the `router-view` HTML element, we use the following
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout-view`: Specifies the layout view to use through the filename (with
    path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-model`: Specifies the model parameter to pass to the activate function
    of view model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-view-model`: Specifies the `moduleId` to use with the layout view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To explain that, we will implement a custom layout page totally decoupled from
    our `app.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are referencing a file called `layout.html`. This file will contain our
    basic layout distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, note the `<slot>` tag. This is a mechanism to associate parts of the
    layout to part of some view referencing its name; in this case, let''s create
    a `home` component with custom layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Any content outside of the slot declared won''t be rendered. We just have one
    more task to do—configure the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We just need to declare the route and reference it to the home module. The layout
    will *read* the slot tags defined inside and will render to the main template.
    In this way we can customize the layout according to the route we are accessing
    the application, one use case could have custom menu options while displaying
    some routes.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing we need to cover to have our router ready for work—the
    fallback route. Imagine that your application is based on roles. If the user is
    not allowed to access some resource, he should be redirected to the previous location.
    What if there's no previous location? The fallback route comes to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let the code show the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now you know the most important characteristics about Aurelia router and how
    to configure it to improve your application. We are almost ready to start creating
    components to our FIFA WC App. In the last chapter, we learned about testing,
    TDD, and debugging. Now, it's time to apply the learned concepts and test our
    components. Let's code!
  prefs: []
  type: TYPE_NORMAL
- en: Testing our components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is one of the most important steps when you develop software applications.
    At this point, we are ready to start creating components, defining binding behaviors,
    and configuring our routes. All is okay, but how do we ensure that our components
    work as expected? We need to test each component before marking it as complete
    and ready for QA/Production environment.
  prefs: []
  type: TYPE_NORMAL
- en: With Aurelia's component tester, you'll be able to test your component in an
    isolated way, like on a mini Aurelia application. What to do when testing a component?
    Evaluate the expected data, and assert a response to data binding and behavior
    through the life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to install the `aurelia-testing` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This library is based on Jasmine, the popular BDD JavaScript testing framework
    that provides the test structure and assertions. If you generated your application
    with the Aurelia CLI, Jasmine should be included.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can start writing your first unit test. We are going to
    start with a simple component that returns the customer name.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define our `View` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `ViewModel` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Our component should work. Let''s verify that. We need to create our test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that looks fine; it should pass. What are we doing?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the `StageComponent` from `aurelia-testing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StageComponent` just creates a new instance of the `ComponentTester` class,
    which does all the work. Next, the `StageComponent` factory will stage the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `StageComponent` has one property—`withResources()`—and it allows you to
    start off the staging with a fluent API. The class method `withResources` is very
    useful to specify which resource or resources you will use and register. If you
    need more than one single resource, just use an array of string to register all
    of them. Then, `inView` method allows us to provide the HTML code we need to run.
    This is a standard view where you can define properties and other stuff just like
    in our application's real components. Finally, `boundTo` method provides a test
    `viewModel` with the predefined data configured in `inView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first part, the staging is performed by Jasmine''s `beforeEach()` method
    in order to reuse the same setup in case we have multiple tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we enter the test itself, the `create()` method. Create will kick everything
    off and bootstrap the mini Aurelia application (it''s receiving the `bootstrap`
    component imported from the `aurelia-bootstrapper` library imported earlier);
    this method will configure the test using `standardConfiguration`, register provided
    resources as global resources, start the application, and, finally, render your
    component so that you can assert the expected behavior. In this case, we want
    to ensure that our `custName` property gets rendered correctly in the HTML by
    selecting the div tag via its class name. We use `document.querySelector(''.custName'')`
    to get the element value and assert that its `innerHTML` is `Diego`. Next, we
    call Jasmine''s `done` function to tell Jasmine that the test is complete. Calling
    done is needed since the create method is asynchronous and returns a `Promise`.
    If the test raises some error, the `catch()` method will be triggered and will
    print the error log in console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we call `dispose` on our `ComponentTester` instance. This will clean
    up the DOM so that our next test starts out with a clean document.
  prefs: []
  type: TYPE_NORMAL
- en: Our first test is complete and guess what...it passed! That was a very basic
    example, but we've learned the basic parts of a component test and how we can
    include it in our application. Now, let's explore more advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Testing component life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to ensure that our data is retrieved as expected, and the same way,
    we need to assert that our component behavior is going well too. To do this, we
    can tell the component we created that we will manually handle the life cycle
    methods; you will find the code very self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The imported libraries still being the same, the `create()` method of our component
    element will bootstrap the application and provide us with an easy way to check
    for our life cycle method responses; just ensure that you call them in the order
    they are executed.
  prefs: []
  type: TYPE_NORMAL
- en: What about components depending on external services? Don't worry, you just
    need to add some extra lines to the test code and create a class "mocking" the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our Mock class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we are declaring our mock service as a global variable. This will
    be used for injecting it into Aurelia's container context; this way, the component
    won't detect any difference between the real service class and our mocked service.
    Another thing you should pay attention to is that at the `beforeEach()` method
    level, we are declaring the `firstName` property as `undefined`; this is just
    to make it reusable and customizable for each test depending on their own needs.
    Remember that this method is executed independently for each unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if I need to define a more complex view, evaluating containers for my
    component? Easy, you are allowed to use template literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What do you think? It's easy right? That's good! Now, we are completely ready
    for the best part of this chapter; let's put everything in practice!
  prefs: []
  type: TYPE_NORMAL
- en: Time to practice!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to start coding! At this point, we have our application created and
    running, preconfigured to use SASS as CSS preprocessor, and integrated with the
    Aurelia Materialize library to follow good design practices of Material Design.
    Now we need to define our layout. It will be very basic at this time and across
    the application growing, our developed components can be improved and refactorized.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to access our root folder application; once inside, we just
    need to type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we open our favorite browser''s window, which should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d6fae7e-14d3-4fc2-bc15-f9306dc51a56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create our main layout. Inside the `src` folder, we will create
    a folder named layout. Inside this folder, to subfolders: header and menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./src > layout > header >`: Here, we will create an HTML file for view and
    JS file for view-model. Both files are called `app-header`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./src > layout > menu >`: Same way as the header, both files will be called
    `app-menu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our folder structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94e94a9e-a44f-428e-b91c-b49a49001190.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we''ll create the `app-header` component. Let''s open the HTML file
    and create our `navbar` header. It''s at this point that we will see the Aurelia
    Materialize features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`<md-navbar>` tag refers to the `navbar` element of Aurelia Materialize. This
    is very helpful because the components are already created; we just need to call
    them and start defining how we want to show to our user. We won''t create any
    CSS class at this point. Inside our `nav-bar`, we are creating two navigation
    options just to see how it looks on the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our first component created, it''s time to integrate it with our main
    page, `app.html`. First, we need to call the created component using the `<require>`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we just need to call the created component by its filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now just reload your browser''s window and... an error is raised! What to do
    in that case? What happened? Our best friend, the console, will tell us the truth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s pay attention to the last parts of each line. First, the error occurred
    when the Aurelia bootstrapper was importing and configuring our created component.
    The last message tells us the error cause: `undefined` `target`.'
  prefs: []
  type: TYPE_NORMAL
- en: Think for a few minutes, what could have happened? We know you have enough knowledge
    to tell us what the error was.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ready? If you note, our recently created `view-model` file for `app-header.js`
    is completely empty. So we have the view, but that view is not pointing to anything,
    and the `target is undefined`! To solve this error, we just need to declare the
    component name and export it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s reload our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fecd523-4b09-4e83-8131-e9c7ac4b3426.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome, right? Relax, this is just the beginning. Now it's time to create our
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our chosen Materialize component is the fixed `sidenav`. However, to integrate
    this into our application, we will merge some of the techniques and concepts learned
    until now. First, let''s code our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, using the `<require>` tag, we will import it into our `app.html`
    file. If we just call the `sidenav` menu, we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d28c18-8032-4bcf-84f5-bb225c6b3d78.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we don't want to hide our main application content! It's time to
    start using CSS to make the `app-menu` play for our team.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add some container order to our app.html page. It should be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We are just involving our main content, in this case, the message property,
    into one container that fills the entire screen no matter the resolution.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application, we'll still be seeing the same result. We need to
    apply some custom CSS modifications to our sidenav component. It's time to start
    using SASS!
  prefs: []
  type: TYPE_NORMAL
- en: We have SASS on our dependencies path, and it's ready for use in our application,
    but let's add some modifications just to make our files distribution a little
    more understandable for us.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `aurelia_project` folder and open the task called `process-css.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember the Gulp task automation from the previous chapters, you''ll
    find the code very familiar. We just need to add one single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Why this line? We want to see the generated CSS file into our project and import
    it from our `index.html` file. Again, why? It's because using this file directly
    into your browser, your style modifications and debugging will be easier in case
    you need to modify or maintain the style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Then, let's create our `styles` folder. This should be located directly in our
    `src` folder. Could it be located in a different location? Sure, but we recommend
    that you first check your `aurelia.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you search the `cssProcessor` task, you will find this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The source property is indicating the level at which our scss files will be
    located, and guess where they are by default? Yes, the `src/*whatever*/*.scss`
    location. You can modify it, but for our current purpose, we don't need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside our folder, let''s create our first .`scss` file called `_mainlayout.scss`.
    Remember that the `_` prefix is to indicate that this style sheet will be used
    as part of another style sheet. We just need to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We are just telling our `header` and application main body to stay 300 px right
    from our app menu. Now, it''s time to reload our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9859fcc-dab2-481a-9ff5-7bca8e890f81.png)'
  prefs: []
  type: TYPE_IMG
- en: Our base layout is done! Guess what? Yeah, its time to add routing!
  prefs: []
  type: TYPE_NORMAL
- en: Let's decouple the welcome message of the `app.js` file. Create a home component
    to render a custom message; we called it `app-home`. Now, instead of the `<h2>`
    tag in your `app.html` file, put the `<router-view>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the app `view-model` file, delete the `constructor` method; we won''t use
    it this time. Then, just add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's reload our browser. Pay attention to the window title; it now reflects
    our application name!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af791f7f-7765-4879-92f0-8d25501a93ec.png)'
  prefs: []
  type: TYPE_IMG
- en: For practice purposes, we are done by this time! If you note, we're mixing a
    lot of concerns in just some basic approaches to our application. Now, let's add
    the extra value to our code. Do you remember our hard-coded menu options? Don't
    you think it should be dynamic? Yes, we are talking about adding dynamic binding
    to our practice! What are you waiting for, open your `app-menu` view and `view-model`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an array of string in the `view-model` layer. We will use the
    same options used in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the magic. The `repeat` command will do the dirty work for us. Okay,
    we know that we didn''t mention it before; do you remember when we said we''ll
    review a lot of new concerns when implementing a real application? This is one
    of those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: That was very easy. Now we are really done. Our FIFA WC 2018 App is ready to
    start writing our business services and components! One more thing is pending
    and that's the tests part. We won't cover it in practice, because in the next
    chapter, we will find some more complex components created for our application,
    and we will be nice to apply testing to real-life components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your knowledge about Aurelia at this moment is just amazing! We wanted to cover
    every aspect regarding component creation and how you can abstract your business
    scenario into one digital application. You learned that each component is part
    of an everything, is reusable, and allows you to separate your application concerns.
    Since a component is an isolated piece of your application, it manages his own
    life cycle; Aurelia allows us to have complete control and configure events such
    as data loading or some custom behavior when the components is destroyed. Another
    very interesting thing is that we can create our own events, and we can trigger
    them from the view layer.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you must remember that one component can inherit from other components,
    and they all have properties. Remember that Aurelia is a double-way binding framework,
    so all these properties are synchronized between the view and view model files.
    We also learned how to implement value-converters and some other binding behavior
    to improve our application performance and reduce the amount of code, making our
    application more lightweight and maintainable. Once our components are created
    and we have our application scenarios, it's time to link all of them through dynamic
    routing, defining user workflows and passing dynamic properties to each template.
    Last but never least, we went through how to test our application components,
    ensuring their functionality and life cycle behavior.
  prefs: []
  type: TYPE_NORMAL
- en: You can start creating components and exploring the Aurelia Materialize's library
    to customize your application. In subsequent chapters, you will find our app very
    advanced, but don't worry, there won't be anything we haven't explained. Keep
    practicing!
  prefs: []
  type: TYPE_NORMAL
