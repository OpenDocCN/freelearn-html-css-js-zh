- en: Creating Components and Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件和模板
- en: 'Welcome to the second part of this book and congratulations for coming here!
    Now that you know the basic principles and techniques of programming in JavaScript,
    it''s time to go deeper and know much better about some advantages offered by
    the wonderful framework that is Aurelia. Our starting point in this chapter will
    be to understand what is a component and how we can manage its life cycle through
    events that are taking place in our application. Then, we will explore the dependencies
    injection, a well-known design pattern used by most popular frameworks such as
    Java EE, Spring, and Aurelia! Our main focus will be to explain how we can manage
    our DOM and dynamically display the data on the screen, configure routes to access
    certain functionalities in our application, and, of course, apply everything learned
    in our FIFA World Cup application. This chapter will cover a lot of very useful
    concepts, some of them are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到这本书的第二部分，并祝贺您来到这里！现在您已经了解了JavaScript编程的基本原则和技术，是时候深入了解了Aurelia这个奇妙框架提供的优势。本章的起点将是理解什么是组件以及我们如何通过应用程序中发生的事件来管理其生命周期。然后，我们将探讨依赖注入，这是一种由大多数流行框架（如Java
    EE、Spring和Aurelia）使用的知名设计模式！我们的主要重点是解释我们如何管理我们的DOM并动态地在屏幕上显示数据，配置路由以访问应用程序中的某些功能，当然，当然，在我们的FIFA世界杯应用程序中应用所学的所有内容。本章将涵盖许多非常有用的概念，其中一些是：
- en: Creating components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组件
- en: Dependency Injection pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: Component's life cycle/events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的生命周期/事件
- en: Data binding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Aurelia router
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia路由器
- en: Testing components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试组件
- en: Let's start!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Lego components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乐高组件
- en: Most modern frontend JavaScript frameworks provide some sort of support for
    component-based development. This is an incredibly important step in the direction
    of development for the web. Components provide a way to write small parts with
    a consistent API that can easily be orchestrated as part of a larger screen, application,
    or system. Imagine each component as a Lego piece—you can use it wherever you
    want and it will keep the same shape and behavior.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代前端JavaScript框架都提供了一些对基于组件的开发的支持。这是网络开发方向上一个极其重要的步骤。组件提供了一种编写小型部分的方法，这些部分具有一致的API，可以轻松地作为更大屏幕、应用程序或系统的一部分进行编排。想象一下每个组件就像一个乐高积木——你可以在任何地方使用它，并且它将保持相同的形状和行为。
- en: A component can be an HTML part, a JavaScript piece of code, a service, and
    so on. Any reusable part should be interpreted as a component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以是一个HTML部分，一段JavaScript代码，一个服务，等等。任何可重用的部分都应该被视为一个组件。
- en: A little puzzle
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个小难题
- en: 'Let''s practice a little how to think and abstract one application into a few
    components. Here''s some web template with some sections:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习一下如何思考，并将一个应用程序抽象成几个组件。以下是一些带有一些部分的网页模板：
- en: '![](img/4c5b48a6-3104-4d9c-bf72-3d6f4ef7a209.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c5b48a6-3104-4d9c-bf72-3d6f4ef7a209.png)'
- en: Now, it's time to think.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候思考了。
- en: How many sections are similar?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少部分是相似的？
- en: Buttons are very similar; just the text/color can change
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮非常相似；只是文本/颜色可以改变
- en: Menu options can be a reusable single component
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单选项可以是一个可重用的单个组件
- en: Main page sections are the same; just the content changes
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页部分是相同的；只是内容不同
- en: The header can be decoupled from the application main section
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题可以与应用程序的主要部分解耦
- en: 'Which sections do you think can be reused across application pages, take a
    look:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为哪些部分可以在应用程序页面之间重用，看看：
- en: Main page sections can be used as a container for other options
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页部分可以用作其他选项的容器
- en: The buttons can be shared across all the application sections
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮可以在所有应用程序部分之间共享
- en: Last, but not the least, do you think you need to refresh the entire page when
    you submit or just some sections?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，当你提交时，你认为你需要刷新整个页面，还是只是某些部分？
- en: A better option can be to refresh only what really needs to be refreshed. Each
    section can independently manage their data and the way it's retrieved.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择可能是只刷新真正需要刷新的部分。每个部分可以独立管理它们的数据及其检索方式。
- en: Of course, all these answers depend on the business rules of the application,
    but the principles are always the same. If you find some section of your application
    that can be reused, reloaded, managed, and maintained independently of other sections,
    you should decouple it into a single component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些答案都取决于应用程序的业务规则，但原则始终相同。如果您发现应用程序中的一些部分可以独立于其他部分重用、重新加载、管理和维护，您应该将其解耦为单个组件。
- en: 'Once you have defined what parts of your application will be a component, it''s
    time to organize. You must identify which components will be used just for some
    page in particular (maybe an Item component for a shopping cart page), how many
    of them will be shared across the entire application (a common table to be used
    into many reports of your application) and finally, organize them by separated
    groups:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了你的应用程序哪些部分将是组件，就是组织的时候了。你必须确定哪些组件将仅用于特定页面（可能是一个购物车页面的Item组件），有多少个将在整个应用程序中共享（一个在许多应用程序报告中使用的通用表格），最后，将它们按分离的组组织：
- en: '![](img/8e1fbeed-1565-415e-8367-1a8cac8ca853.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e1fbeed-1565-415e-8367-1a8cac8ca853.png)'
- en: Now, let's create one folder per component; you should keep in mind that if
    some component will be *parent* of another component, the *child* folder should
    be created inside the parent, to specify ownership. Remember always that as a
    programmer, your main goal is to make your code readable and understandable to
    other developers—that's a good quality measure!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为每个组件创建一个文件夹；你应该记住，如果一个组件将是另一个组件的*父组件*，那么*子组件*文件夹应该创建在父组件内部，以指定所有权。始终记住，作为一个程序员，你的主要目标是让你的代码对其他开发者来说易于阅读和理解——这是一个好的质量指标！
- en: '![](img/383cf5cc-e2e5-4d1b-af94-55706141dcb4.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/383cf5cc-e2e5-4d1b-af94-55706141dcb4.png)'
- en: 'At this point, we now have our folder structure created for our components.
    An Aurelia component is basically composed of two files: the HTML template, called
    **view**, is rendered into the DOM. The `.js` file, called **view model**, is
    written in ES Next, and it defines the behavior and provides data for the view.
    The templating engine, along with **dependency injection** (**DI**), that we will
    explain in detail in the following sections, is responsible for creating and enforcing
    a predictable life cycle for the component. Once the component is instantiated,
    Aurelia’s data binding links the two pieces together, allowing changes in your
    view model to be reflected in the view and vice versa. This separation of concerns
    allows us to work/collaborate with designers and improve our product quality.
    Let''s create one component as an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为我们的组件创建了文件夹结构。Aurelia组件基本上由两个文件组成：HTML模板，称为**视图**，渲染到DOM中。`.js`文件，称为**视图模型**，使用ES
    Next编写，并定义了行为并提供视图所需的数据。模板引擎，以及我们在以下章节中将详细解释的**依赖注入**（**DI**），负责创建和强制组件的可预测生命周期。一旦组件被实例化，Aurelia的数据绑定将这两部分连接起来，允许视图模型中的更改反映在视图中，反之亦然。这种关注点的分离使我们能够与设计师合作并提高我们的产品质量。让我们以一个组件为例来创建一个组件：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should remember some good practices about naming your components:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住一些关于命名组件的良好实践：
- en: Use dashes for naming your components. For example, `<my-component>` and `<my-other-component>`
    are valid name syntax, while `<my_component>` , `<myComponent>` and `<my_other_component>`
    are not. You must keep this notation, because the HTML parser will differentiate
    between custom and regular elements.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用破折号来命名你的组件。例如，`<my-component>`和`<my-other-component>`是有效的名称语法，而`<my_component>`、`<myComponent>`和`<my_other_component>`则不是。你必须保持这种表示法，因为HTML解析器会在自定义元素和常规元素之间进行区分。
- en: You can't register an already existing tag.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能注册一个已经存在的标签。
- en: Custom elements are not self-closing. Only native HTML attributes allows this
    feature. Ensure that you write a closing tag (`<my-component></my-component>`).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素不是自闭合的。只有原生的HTML属性允许这个特性。确保你写上闭合标签（`<my-component></my-component>`）。
- en: 'Our first component is created, hard coded, and works. Wait a second… how does
    the `.html` template know that my `.js` file is correct for retrieving data? Aurelia
    works under one premise: convention over configuration. What does that mean? If
    we use the same name for both files, the framework automatically will map that
    JavaScript file managing the `.html` template, we do not write any configuration
    code (different from other frameworks). Now, it’s time to integrate it into our
    main page.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个组件已经创建，硬编码，并且可以正常工作。等等…`.html`模板是如何知道我的`.js`文件是正确的，用于检索数据的呢？Aurelia遵循一个原则：约定优于配置。这意味着什么？如果我们为两个文件使用相同的名称，框架会自动将管理`.html`模板的JavaScript文件映射过来，我们不需要编写任何配置代码（与其他框架不同）。现在，是时候将其集成到我们的主页面上了。
- en: 'We just need to import the filename with the `<require>` tag. For other reasons,
    this tag will be in the top section of the page. Then, we just call the component:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要用`<require>`标签导入文件名。出于其他原因，这个标签将位于页面的顶部部分。然后，我们只需调用组件：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Launch your application, and you will see your component in action. In this
    case, we just defined one single property to be rendered from the `.js` file to
    our template. This is a very basic example, so don’t worry, the action is coming!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的应用程序，你将看到你的组件正在运行。在这种情况下，我们只定义了一个从`.js`文件渲染到模板的单个属性。这是一个非常基本的例子，所以不要担心，动作即将到来！
- en: Learning how DI works
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习DI的工作原理
- en: DI is based on the Inversion of control pattern. Let’s explain that.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: DI基于控制反转模式。让我们来解释一下。
- en: 'Imagine that we create a web application without Aurelia. You will have to
    manually implement something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们创建一个没有Aurelia的Web应用程序。你将不得不手动实现类似的东西：
- en: Load/instantiate a view model
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载/实例化一个视图模型
- en: Load/instantiate a view
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载/实例化一个视图
- en: Bind the view to the view model
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图绑定到视图模型
- en: Append the view to the DOM
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图添加到DOM中
- en: Handle click on a link by user.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理用户点击链接。
- en: Parse the URL hash, determine which view model to load/instantiate, check whether
    the current view can be deactivated, and more
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析URL散列，确定要加载/实例化的视图模型，检查当前视图是否可以停用，等等
- en: Rinse and repeat
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复使用
- en: Again, and many more times.  Without Aurelia, you are implementing the logic
    that controls the application life cycle instead of your application business
    logic and features.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，并且很多次。如果没有Aurelia，你将实现控制应用程序生命周期的逻辑，而不是你的应用程序业务逻辑和功能。
- en: Now, let's create one using Aurelia. You won't work on any configuration code
    at the application level because the framework does that job for you. Instead,
    you focus on writing the views, view models, behaviors, and routes that embody
    your application's custom logic and appearance. Aurelia inverts the control, handling
    the application life cycle while allowing you to define your own features and
    behavior of the application. How? Through life cycle hooks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Aurelia创建一个。你不会在应用程序级别上编写任何配置代码，因为框架会为你完成这项工作。相反，你将专注于编写视图、视图模型、行为和路由，这些将体现你应用程序的定制逻辑和外观。Aurelia反转了控制，处理应用程序生命周期，同时允许你定义自己的应用程序功能和行为。如何？通过生命周期钩子。
- en: Life cycle hooks are optional methods you attach to view models. Aurelia's router
    and the templating engine will invoke these methods at the appropriate time, allowing
    you to control specific life cycle steps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子是附加到视图模型上的可选方法。Aurelia的路由器和模板引擎将在适当的时间调用这些方法，允许你控制特定的生命周期步骤。
- en: We will explore all these methods deeper in the following sections; at the moment,
    we will focus only on **Inversion of Control** (**IoC**) and DI features.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中深入探讨所有这些方法；目前，我们只关注**控制反转**（**IoC**）和DI功能。
- en: Aurelia uses the IoC pattern to reduce the work required to build applications.
    You can specify and control them however you want using overridable conventions
    and hooks when the application starts/ends.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia使用IoC模式来减少构建应用程序所需的工作。你可以在应用程序启动/结束时使用可覆盖的约定和钩子来指定和控制它们。
- en: DI uses the same pattern for resolving dependencies. A dependency is an object
    that can be used, or more specifically, a service. Using this pattern, you made
    that service a part of the state of the client object, because you are passing
    that entire service rather than allowing the client to build or find the service.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: DI使用相同的模式来解决依赖项。依赖项是一个可以使用的对象，或者更具体地说，是一个服务。使用这种模式，你使该服务成为客户端对象状态的一部分，因为你传递了整个服务，而不是允许客户端构建或找到服务。
- en: DI needs an injector. This injector is responsible to provide and construct
    the service object and define that inside the client's state. The client is not
    allowed to directly call the injector code. It only waits until all its dependencies
    are satisfied.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: DI需要一个注入器。这个注入器负责提供和构建服务对象，并在客户端的状态中定义它。客户端不允许直接调用注入器的代码。它只等待所有依赖项都得到满足。
- en: 'Two modules are the key enablers for the DI pattern''s application in Aurelia:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模块是Aurelia中DI模式应用的关键推动者：
- en: '**dependency**-**injection**: An extensible and very lightweight DI container
    for JavaScript'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**：一个可扩展且非常轻量级的JavaScript DI容器'
- en: '**metadata**: Provides a consistent way of accessing type, annotation, and
    origin metadata across a number of languages and formats'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据**：提供了一种在多种语言和格式中访问类型、注释和来源元数据的一致方式'
- en: 'To illustrate how the DI works, let''s define a typical view model class with
    some external services injected. The code should be something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明DI是如何工作的，让我们定义一个典型的带有一些外部服务注入的视图模型类。代码应该像这样：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's analyze that code. How is this view model created at runtime?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析一下代码。这个视图模型是如何在运行时创建的？
- en: Aurelia takes care of the creation order of each element, but how does it work?
    Well, first of all, Aurelia uses the DI container to instantiate all view models.
    As we said earlier, the client object doesn’t instantiate or locate their own
    dependencies. They rely on Aurelia to supply the dependencies as constructor arguments.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia负责每个元素的创建顺序，但它是如何工作的呢？首先，Aurelia使用DI容器来实例化所有视图模型。正如我们之前所说的，客户端对象不会实例化或定位自己的依赖项。它们依赖于Aurelia作为构造函数参数提供依赖项。
- en: How are these dependencies discovered?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖是如何被发现的？
- en: In an object oriented language (such as Java), the DI container can identify
    each dependency by its type. In the case of Aurelia, the dependencies, implementations
    are determined using the constructor arguments order list. In JavaScript, we can
    store a variety of information about our components or application as metadata.
    We don't have the chance to define a type-based constructor to define our objects.
    To deal with this situation, we must embed this information on the class itself,
    as *metadata*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言（如Java）中，DI容器可以通过类型识别每个依赖项。在Aurelia的情况下，依赖项的实现是通过构造函数参数顺序列表确定的。在JavaScript中，我们可以将有关我们的组件或应用程序的各种信息作为元数据存储。我们没有机会定义基于类型的构造函数来定义我们的对象。为了处理这种情况，我们必须将此信息嵌入到类本身上，作为*元数据*。
- en: We can use decorators to add a customized constructor signature to our classes,
    based on types to be consumed by the Aurelia's DI container. This is exactly what
    the annotation `@inject` (`CustomerService`) performs in the view model file.
    If you are a TypeScript user, you can use the `emitDecoratorMetadata` flag, used
    for the same purpose of adding a constructor info to our classes. Just add the
    `@autoInject()` decorator to your class; in this case, the constructor parameter
    types are not needed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用装饰器为我们的类添加一个定制的构造函数签名，基于将被Aurelia的DI容器消费的类型。这正是注解`@inject`（`CustomerService`）在视图模型文件中所执行的操作。如果你是TypeScript用户，你可以使用`emitDecoratorMetadata`标志，它用于添加构造函数信息到我们的类中。只需将`@autoInject()`装饰器添加到你的类中；在这种情况下，构造函数参数类型是不需要的。
- en: View models written in this way are easy to test and modularize. You can split
    a big class into small components and inject them to achieve the goal. Remember
    that large classes are hard to maintain and are very vulnerable to rely on the
    anti-pattern *spaghetti code*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写的视图模型易于测试和模块化。你可以将一个大类拆分成小组件，并将它们注入以实现目标。记住，大类的维护很困难，并且很容易依赖于反模式*意大利面代码*。
- en: Dependency resolution is a recursive process. Let's explain that—our customer
    view model has a dependency on the `CustomerService` file. When the DI container
    instantiates the `CustomerComponent` class, it first needs to retrieve the `CustomerService`
    instance or instantiate one if it doesn't already exist in the container. The
    `CustomerService` may have dependencies of its own, which the DI container will
    recursively resolve until the full dependency chain has been identified.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项解析是一个递归过程。让我们解释一下——我们的客户视图模型依赖于`CustomerService`文件。当DI容器实例化`CustomerComponent`类时，它首先需要检索`CustomerService`实例或如果容器中不存在，则实例化一个。`CustomerService`可能有自己的依赖项，DI容器将递归解析直到完整的依赖链被识别。
- en: You can have as many injected dependencies as you need. Simply ensure that the
    inject decorator and the constructor match one another.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拥有你需要的任何数量的注入依赖项。只需确保注入装饰器和构造函数相互匹配。
- en: 'In case you are not using Babel or TypeScript decorator support, you can provide
    the inject metadata using a static method in your class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用Babel或TypeScript装饰器支持，你可以通过类中的静态方法提供注入元数据：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Static methods and properties are supported. The inject decorator simply sets
    the static property automatically. Why use it? Just to make our syntax more elegant
    and understandable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 支持静态方法和属性。注入装饰器只是自动设置静态属性。为什么使用它？只是为了使我们的语法更加优雅和易于理解。
- en: Managing a component's life cycle
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理组件的生命周期
- en: 'As we said earlier, Aurelia provides very complete life cycle event methods
    to customize and improve the behavior of our application. Here''s a list with
    these methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，Aurelia提供了非常完整的生命周期事件方法来定制和改进我们应用程序的行为。以下是一个包含这些方法的列表：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s explore each method presented in the script:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索脚本中呈现的每个方法：
- en: '**`constructor()`**: This is the first method that is called. It''s used to
    set all view model dependencies and values required for its instantiation.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**`constructor()`**: 这是第一个被调用的方法。它用于设置所有视图模型依赖项和其实例化所需的所有值。'
- en: 'The `constructor` method can be used for instantiating and initializing attributes
    to your component, and they should not necessarily be declared previously:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor` 方法可以用来实例化和初始化组件的属性，它们不一定需要预先声明：'
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, you can initialize variables using class methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你也可以使用类方法来初始化变量：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`created(owningView, myView)`: Next, the `created` method is called. At this
    point, the view has been created and belongs to the view model; they are connected
    to the controller. This callback will receive the view declared inside of the
    `(owningView)` component. If the component itself has a view, it is passed as
    second parameter, `(myView)`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`created(owningView, myView)`: 接下来，会调用 `created` 方法。在这个时候，视图已经被创建，属于视图模型；它们与控制器相连。这个回调将接收
    `(owningView)` 组件内部声明的视图。如果组件本身有视图，它将作为第二个参数传递，`(myView)`。'
- en: '`bind(bindingContext, overrideContext)`: At this point, the binding has started.
    If the view model has the `bind()` callback overridden, it will be called at this
    time. The first argument represents the binding context of the component. The
    second parameter is used for adding additional contextual properties.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind(bindingContext, overrideContext)`: 在此时，绑定已经开始。如果视图模型有覆盖的 `bind()` 回调，它将在此时被调用。第一个参数代表组件的绑定上下文。第二个参数用于添加额外的上下文属性。'
- en: '`attached()`: The `attached` callback is executed once the component is ready
    for use. It means instantiated and has its properties set and computed correctly.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`attached()`: 当组件准备好使用时执行 `attached` 回调。这意味着它已经被实例化，并且其属性已经正确设置和计算。'
- en: 'This method is perfect for retrieving data or set properties if you are using
    injected service methods. You can configure different ways to load your data,
    show loading alerts for the user, and increase the user experience. Let''s see
    a quick example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用注入的服务方法，这个方法非常适合检索数据或设置属性。你可以配置不同的方式来加载数据，为用户显示加载警报，并提高用户体验。让我们看一个快速示例：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we can define fallback alerts or methods to ensure that we are
    handling errors correctly (just if needed).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们可以定义回退警报或方法来确保我们正确地处理错误（如果需要的话）。
- en: '`detached()`: Called when the component will be removed from the DOM. Different
    from the previous methods, this method is not executed when the application starts.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`detached()`: 当组件将从 DOM 中移除时调用。与前面的方法不同，此方法在应用程序启动时不会执行。'
- en: The same as the previous example, we can define this method to restore the data
    to a previous state, delete local storage data, and so on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们可以定义这个方法来恢复数据到之前的状态，删除本地存储数据等。
- en: '`unbind()`: Called when the component is unbound.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`unbind()`: 当组件被解绑时调用。'
- en: You should remember that each of these life cycle callbacks is optional. Just
    override what you really need. The execution order is the same as the list order
    mentioned earlier.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住，这些生命周期回调函数都是可选的。只需覆盖你真正需要的部分。执行顺序与前面提到的列表顺序相同。
- en: Managing events with Aurelia
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Aurelia 管理事件
- en: We were explaining how to override and catch determined events and methods in
    the component life cycle, but what if we want to write our own methods and execute
    them when the user clicks on some button or moves the mouse for one section? We
    will start to *delegate* events.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前解释了如何在组件生命周期中覆盖和捕获确定的事件和方法，但如果我们想在用户点击某个按钮或移动鼠标到一个部分时执行我们自己的方法，该怎么办？我们将开始
    *委托* 事件。
- en: The event delegation concept is a useful concept where the event handler is
    attached to one single element instead of multiple elements on the DOM. What implies
    that? Memory efficiency. It drastically reduces the number of event subscriptions
    by leveraging the *bubbling* characteristic of most DOM events.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事件委托的概念是一个有用的概念，其中事件处理器被附加到单个元素上，而不是 DOM 上的多个元素。这意味着什么？内存效率。它通过利用大多数 DOM 事件的
    *冒泡* 特性，极大地减少了事件订阅的数量。
- en: On the other hand, we have the trigger concept. Similar, but not equal. You
    should use trigger binding when you need to subscribe to events that do not bubble
    (blur, focus, load, and unload).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有触发概念。类似但不相同。当你需要订阅不冒泡的事件（如 blur、focus、load 和 unload）时，你应该使用触发绑定。
- en: 'Some examples are as listed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子如下所示：
- en: You need to disable a button, input, or another element
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要禁用一个按钮、输入或其他元素
- en: The element's content is made up of other elements (reusable component)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的内容由其他元素组成（可重用组件）
- en: 'In code words, it can be explained like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 用代码来说，可以这样解释：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In your view model, you should have the method implemented with the correct
    number of params, so each time the `<select>` element changes, the event will
    be delegated to your custom function to handle it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的视图模型中，你应该实现一个带有正确数量参数的方法，这样每次 `<select>` 元素发生变化时，事件就会被委托到你的自定义函数来处理它：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s `trigger` the same method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们`trigger`相同的方法：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that we are using `trigger` binding to catch a not bubbling event.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`trigger`绑定来捕获一个非冒泡事件。
- en: In your daily work, maybe `delegate` and `trigger` could be enough for managing
    events, but there are some situations where you will need to know a little more
    advanced features to deal with it. Imagine that you are integrating a third-party
    plugin and need to interact with this content. Normally, `trigger` or `delegate`
    should do the work, but this won't be the case.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日常工作中，可能`delegate`和`trigger`就足够用来管理事件，但有些情况下，你需要了解一些更高级的功能来处理它们。想象一下，你正在集成第三方插件并需要与之交互内容。通常，`trigger`或`delegate`应该可以完成工作，但情况并非如此。
- en: 'Let''s look at an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But why? Remember that you are dealing with a third-party plugin, so this will
    manage its events independently of the `container` component. That being said,
    the inner plugin will call `event.stopPropagation()` on any click events.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么？记住，你正在处理一个第三方插件，所以这将独立于`container`组件来管理其事件。也就是说，内部插件将在任何点击事件上调用`event.stopPropagation()`。
- en: 'So what can we do in that case? Don''t worry, you have another option—the `capture`
    command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那在这种情况下我们能做什么呢？别担心，你还有一个选择——`capture`命令：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, the method will be executed correctly. Again, the most important question,
    why? It's because with the `capture` command, the `onClickPluginContainer()` event
    is guaranteed to happen irrespective of whether `event.stopPropagation()` is called
    or not inside the container.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，方法将正确执行。再次强调，最重要的问题，为什么？这是因为有了`capture`命令，无论在容器内部是否调用`event.stopPropagation()`，`onClickPluginContainer()`事件都会发生。
- en: Now, at this point, maybe you are wondering "So...what command should I use?
    Which of these is better?" The answer is simple—it depends on what you need. We
    recommend that you use `delegate`, because you will improve your application performance.
    Then, use `trigger` only if the event requires this, and finally, use `capture`
    if you will deal with third-party plugins or elements that you can't control,
    but remember that this last one is not commonly used and is not how you should
    normally work with browser events.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个时候，你可能想知道“所以……我应该使用哪个命令？哪一个更好？”答案是简单的——这取决于你的需求。我们建议你使用`delegate`，因为这会提高你的应用程序性能。然后，只有在事件需要这样做的情况下才使用`trigger`，最后，如果你将处理第三方插件或你无法控制的元素，请使用`capture`，但请记住，这最后一个不是常用的，而且这不是你通常与浏览器事件一起工作的方式。
- en: You can find more info about delegate and trigger in the official docs: [https://aurelia.io/docs/binding/delegate-vs-trigger/](https://aurelia.io/docs/binding/delegate-vs-trigger/)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到更多关于委托和触发的信息：[https://aurelia.io/docs/binding/delegate-vs-trigger/](https://aurelia.io/docs/binding/delegate-vs-trigger/)
- en: Data binding
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Aurelia has its own data binding system. Let's explain that with an example.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia有自己的数据绑定系统。让我们用一个例子来解释这一点。
- en: You know that you need to define a view and a view model file for each Aurelia
    component. Binding is the process that reflects the view model data into the view,
    and vice versa. As we said earlier, one of Aurelia's most beautiful features is
    double-binding framework, so you won't have to worry about updating the data on
    the view or view model.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你需要为每个Aurelia组件定义一个视图和一个视图模型文件。绑定是将视图模型数据反映到视图中的过程，反之亦然。正如我们之前所说的，Aurelia最美丽的特性之一是双向绑定框架，所以你不必担心视图或视图模型上的数据更新。
- en: 'Aurelia supports HTML and SVG attributes to JavaScript expressions. The binding
    attribute declaration is composed of three parts:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia支持HTML和SVG属性到JavaScript表达式的绑定。绑定属性声明由三个部分组成：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s explain each one:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释每一个：
- en: '`attribute`: Refers to the HTML/SVG attribute we will apply to the binding.
    For example, one input tag could have defined the following attributes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`attribute`：指的是我们将应用到绑定的HTML/SVG属性。例如，一个输入标签可以定义以下属性：'
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`value` and `id` will be the attributes we could refer.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`和`id`将是我们可以引用的属性。'
- en: '`command`: Here, you will use one of Aurelia''s binding commands:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`command`：在这里，你将使用Aurelia的一个绑定命令：'
- en: '**one**-**time**: Flows data to one direction, from view model to view, just
    once.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性**：数据单向流动，从视图模型到视图，仅此一次。'
- en: '**to**-**view **/ **one**-**way**: Flows data in one direction, from view model
    to view.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**到视图**/**单向**：数据单向流动，从视图模型到视图。'
- en: '**from**-**view:** Flows data in one direction, from view to view model.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从视图到视图模型**：数据单向流动，从视图到视图模型。'
- en: '**two**-**way**: Default behavior, flows data from view model to view and vice
    versa.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向**：默认行为，数据从视图模型流向视图，反之亦然。'
- en: '**bind**: Automatically chooses the binding mode. It uses two-way binding for
    form controls and to-view binding for almost everything else.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定**：自动选择绑定模式。它为表单控件使用双向绑定，为几乎所有其他内容使用到视图绑定。'
- en: 'Let''s use the same input element defined earlier as an example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前定义的相同输入元素作为例子：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first `input` element uses the `from-view` command to bind anything the
    user writes in the `input` element, but this value cannot be changed and reflected
    from the `view-model` into the `view`. The `id` attribute uses the `two-way` binding,
    so this `id` can be updated in the view layer and reflected in the view model.
    The second binds the `value` attribute just once, then any update to this value
    will be ignored. In the case of the `id` attribute, it is generated by the `view-model`
    file, and any modification from `view` won't be reflected on `view-model`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`input`元素使用`from-view`命令绑定用户在`input`元素中输入的任何内容，但这个值不能更改，也不能从`view-model`反映到`view`中。`id`属性使用双向绑定，因此这个`id`可以在视图层更新，并在视图模型中反映。第二个只绑定一次`value`属性，然后任何对这个值的更新都将被忽略。在`id`属性的情况下，它是由`view-model`文件生成的，并且从`view`的任何修改都不会反映到`view-model`中。
- en: '`expression`: The last part. Commonly a JavaScript expression used to reflect
    `view-model` attributes, computed properties, and so on. Again, let''s use the
    same `input` element for example purposes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`expression`：最后一部分。通常是一个JavaScript表达式，用于反映`view-model`属性、计算属性等。再次，让我们使用相同的`input`元素作为例子：'
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `value` attribute just reflects the **`modelValue`** property into the view.
    The `id` attribute is performing an operation to attach a random number generated
    in the view model into one predefined property and use it as a single value to
    bind.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`属性只是将**`modelValue`**属性反映到视图中。`id`属性执行一个操作，将视图模型中生成的随机数附加到一个预定义属性中，并使用它作为单个值进行绑定。'
- en: 'The same way that as event managing part, there could be some situations that
    you will need to use a little more advanced features to get the expected results.
    Commonly, you may deal with situations where you have `@bindable` properties while
    developing custom elements/attributes. These properties expect a reference to
    a function, so just use the `call` binding command to declare and pass a function
    to the bindable property. The `call` command is superior to the `bind` command
    for this use case, because it will execute the function in the correct context,
    ensuring that this is what you expect it to be:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像事件管理部分，可能存在一些情况，你需要使用更高级的功能来获得预期的结果。通常，在开发自定义元素/属性时，你可能需要处理具有`@bindable`属性的情景。这些属性期望一个函数的引用，因此只需使用`call`绑定命令来声明并传递一个函数给`bindable`属性。对于这个用例，`call`命令比`bind`命令更优越，因为它会在正确的上下文中执行函数，确保它符合你的预期：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`go` is the `@bindable` attribute, and `doSomething()` is your `view-model`
    function.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`go`是`@bindable`属性，`doSomething()`是你的`view-model`函数。'
- en: 'One more feature you can add to your application is string interpolation. These
    expressions enable interpolating the result of an expression with text. The best
    way to demonstrate this capability is with an example. Here are two `span` elements
    with data-bound `textcontent`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你的应用程序添加的一个额外功能是字符串插值。这些表达式允许将表达式的结果与文本进行混合。展示这一功能最好的方式是举一个例子。这里有两个带有数据绑定`textcontent`的`span`元素：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, we know the basic concepts about Aurelia's binding engine. Now,
    let's use this great feature in more advanced ways to improve our application!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Aurelia绑定引擎的基本概念。现在，让我们以更高级的方式使用这个伟大的功能来改进我们的应用程序！
- en: We have explored in Chapter 2, *Styling the User Interface*, some ways to add
    CSS to our application and make it look great. However, in your daily work, you
    can find some common situation that will make you 'mix' some features.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章“美化用户界面”中，我们探讨了向我们的应用程序添加CSS的一些方法，使其看起来更出色。然而，在你的日常工作中，你可能会遇到一些常见情况，这会让你“混合”一些功能。
- en: 'Here''s one:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: You are writing a dashboard page and depending on user status (active, inactive),
    the Submit button should look colorful or just disabled with a different shape.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在编写一个仪表板页面，根据用户状态（活跃，非活跃），提交按钮应该看起来色彩丰富，或者只是禁用，具有不同的形状。
- en: 'You can bind an element''s `class` attribute using string interpolation or
    with `.bind/.one-time`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用字符串插值或`.bind/.one-time`来绑定元素的`class`属性：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using ternary operations, you can say to your view which class should be rendered
    into the view. Let''s analyze the first:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算，您可以告诉视图应该渲染哪个类。让我们分析第一个：
- en: '`isActive` refers to a boolean property defined in view model.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isActive`指的是在视图中定义的一个布尔属性。'
- en: '`?` is the ternary operator. If the condition is `true`, the first argument
    will be used, in this case, the `''btn-active''` class.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`是三元运算符。如果条件为`true`，则使用第一个参数，在这种情况下，是`''btn-active''`类。'
- en: '`:` represents the `else` element of the condition. If it''s evaluated to false,
    the second argument after the `:` will be used.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:`代表条件的`else`部分。如果它评估为`false`，则使用`:`后面的第二个参数。'
- en: Aurelia allows you to use external JavaScript libraries. It supports, on its
    binding system, only adding or removing the specified classes in the binding expression.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia允许您使用外部JavaScript库。在其绑定系统中，它只支持在绑定表达式中添加或删除指定的类。
- en: In this way, classes added by other code (for example, `classList.add(...)`)
    are not removed. This behavior implies a small cost, noticeable only in benchmarks
    or some critical situations like iteration of large lists. Replace the default
    behavior by binding directly to the element's `className` property using `class-name.bind="...."`,
    or `class-name.one-time="..."` can be a better option; so much faster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，其他代码添加的类（例如，`classList.add(...)`）不会被移除。这种行为意味着会有轻微的成本，只有在基准测试或一些关键情况（如大列表的迭代）中才能感觉到。可以通过直接绑定到元素的`className`属性来替换默认行为，使用`class-name.bind="...."`，或者使用`class-name.one-time="..."`可能是一个更好的选择；这样会更快。
- en: Similar to classes, you can bind style attributes directly into the DOM. Remember
    that defining styles directly into the element is not wrong, but using classes,
    you can add more standardization to your elements and make this easy to maintain.
    Like other HTML attributes, you can use `style.bind` to retrieve `style` definitions
    from your `view-model`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与类类似，您可以直接将样式属性绑定到DOM中。请记住，直接在元素中定义样式是正确的，但使用类，您可以给元素添加更多标准化，并使维护变得容易。像其他HTML属性一样，您可以使用`style.bind`从您的`view-model`中检索`style`定义。
- en: 'For example, let''s define one array of styles:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们定义一个样式数组：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, in the `view` file, we just need to bind the predefined properties:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`view`文件中，我们只需要绑定预定义的属性：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use string interpolation too:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用字符串插值：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, if you need to add compatibility with Internet Explorer and Edge,
    this syntax will be illegal. In those cases, you must use the `css` attribute:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您需要与Internet Explorer和Edge兼容，这种语法将是非法的。在这种情况下，您必须使用`css`属性：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Binding computed properties
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定计算属性
- en: 'Sometimes it is desirable to return a dynamically computed value (post-processed
    value) when accessing a property, or you may want to reflect the status of an
    internal variable without requiring the use of explicit method calls. In JavaScript,
    this can be accomplished with the use of a getter function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在访问属性时返回一个动态计算值（后处理值）是可取的，或者您可能希望反映内部变量的状态，而不需要使用显式的方法调用。在JavaScript中，这可以通过使用getter函数来实现：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There''s no trick here, you just need to bind the `fullName` property. The
    binding system will analyze the property and how we are referring to a function;
    it will process the required info before rendering the computed value. This is
    also called **dirty checking**; it will be constantly observing if some property
    changes its value, and if it has some repercussions on the computed element, it
    will be re-evaluated and reprocessed. Sounds like a multiple execution of the
    same method? Yes, your getter function will be called so many times, approximately
    once every 120 milliseconds. That''s not an issue, but if we have a lot of computed
    properties or if our getter functions are a little complex, you should consider
    indicating to the binding systems which properties you want to observe; at this
    point, dirty checking is avoided. This is where the `@computedFrom` decorator
    comes in:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有技巧，你只需要绑定`fullName`属性。绑定系统将分析属性以及我们如何引用一个函数；在渲染计算值之前，它将处理所需的信息。这也被称为**脏检查**；它将不断观察某些属性是否更改其值，如果它对计算元素有影响，它将被重新评估和重新处理。听起来像是同一方法的多次执行？是的，你的getter函数将被调用很多次，大约每120毫秒一次。这不是问题，但如果我们有大量的计算属性或如果我们的getter函数稍微复杂一些，你应该考虑向绑定系统指示你想要观察哪些属性；在这个时候，避免了脏检查。这就是`@computedFrom`装饰器发挥作用的地方：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`@computedFrom` will tell the binding system which properties need to be observed.
    When those expressions change, the binding system will reevaluate the property
    (execute the getter). This eliminates the need for dirty checking and can improve
    performance.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`@computedFrom`将告诉绑定系统哪些属性需要被观察。当这些表达式发生变化时，绑定系统将重新评估属性（执行getter）。这消除了脏检查的需要，并可以提高性能。'
- en: Value converters
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值转换器
- en: 'As we explained before coming across this topic, user interface elements in
    Aurelia are composed of two files: view and view model pairs. The view is written
    in pure HTML and is rendered into the DOM. The view model is written in JavaScript
    and provides data and behavior to the view. Aurelia links the two files together,
    as one single element using its powerful data binding engine, allowing changes
    in your view model to be reflected in the view and vice versa. Sometimes the data
    showed by your view model is not in a good or understandable format for displaying
    in the UI. Dealing with date and numeric values are the most common scenarios:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在接触这个主题之前所解释的，Aurelia中的用户界面元素由两个文件组成：视图和视图模型对。视图是用纯HTML编写的，并渲染到DOM中。视图模型是用JavaScript编写的，为视图提供数据和行为。Aurelia通过其强大的数据绑定引擎将这两个文件链接在一起，作为一个单一元素，允许视图模型中的更改反映在视图中，反之亦然。有时，视图模型显示的数据对于在UI中显示来说不是很好或难以理解。处理日期和数值是最常见的场景：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our view should look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图应该看起来像这样：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code will give us the current date and some random number; well, that''s
    what we are expecting and that''s okay, but let''s see how this data is displayed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将给我们当前的日期和一些随机数；嗯，这正是我们期望的，这也是可以接受的，但让我们看看这些数据是如何显示的：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That's definitely not friendly for user reading. A cool solution to this problem
    can be to compute the formatted values and expose them as properties of the `view-model`
    file. This is a valid approach, but remember that we are overloading our model
    with extra properties and methods; it can be a little messy in the future, especially
    when you need to keep the formatted values in sync when the original property
    value change. Fortunately, Aurelia has a feature to help us deal with these situations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于用户阅读来说肯定是不友好的。解决这个问题的酷解决方案可以是计算格式化的值并将它们作为`view-model`文件的属性公开。这是一个有效的方法，但请记住，我们正在给模型添加额外的属性和方法；这可能会在将来变得有些混乱，尤其是在需要保持格式化值与原始属性值同步时。幸运的是，Aurelia有一个功能可以帮助我们处理这些情况。
- en: The most common option will be to create value converters to translate the model
    data into a readable format for the view. All okay at this point, but what happens
    if it is the view that needs to convert the value for sending it into a format
    acceptable for the `view-model`?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的选项是创建值转换器，将模型数据转换为视图可读的格式。到目前为止一切正常，但如果需要视图转换值以发送到`view-model`可接受的格式呢？
- en: 'Aurelia value converters are quite similar to other value converters of another
    languages, such as XAML. The nice thing is that Aurelia comes with some notable
    improvements:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Aurelia值转换器与其他语言的值转换器相当相似，例如XAML。令人高兴的是，Aurelia带来了一些显著的改进：
- en: 'The Aurelia `ValueConverter` interface uses two methods: `toView` and `fromView`.
    These methods define the direction the data is flowing in.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia 的 `ValueConverter` 接口使用两个方法：`toView` 和 `fromView`。这些方法定义了数据流动的方向。
- en: Aurelia value converter methods can accept multiple parameters.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia 值转换器方法可以接受多个参数。
- en: Aurelia allows you to use multiple value converters in one single property,
    just using pipes (`|`).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aurelia 允许你在一个属性中使用多个值转换器，只需使用管道（`|`）即可。
- en: 'Let''s look at an example to convert our date property into a more friendly
    readable value:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看如何将我们的日期属性转换为更友好的可读值：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our `view-model` file won''t change:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `view-model` 文件不会改变：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, our `view-model` file will look quite different at this time:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的 `view-model` 文件在此时看起来会相当不同：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With this value converter, we''ll see this value on the screen:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个值转换器，我们将在屏幕上看到这个值：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This looks much better. Again, it's time to ask the more important question—why?
    Let's examine what we did. First, we created our value converter class called
    `DateFormatValueConverter` and implemented the `toView` method. Aurelia will execute
    this method and apply to the model values before displaying the data on screen.
    For converting purposes, we are using MomentJS. Next, we've updated the `view`
    file and added `<require>` tags to import our value converter class into the view
    that will use it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来好多了。再次，是时候提出更重要的问题——为什么？让我们检查我们做了什么。首先，我们创建了一个名为 `DateFormatValueConverter`
    的值转换器类并实现了 `toView` 方法。Aurelia 将执行此方法并将模型值应用于屏幕上的数据之前。在转换用途上，我们使用了 MomentJS。接下来，我们已更新了
    `view` 文件并添加了 `<require>` 标签以将我们的值转换器类导入将使用它的视图。
- en: When the framework processes the resource, it examines the class's metadata
    to determine the resource type (custom element, custom attribute, value converter,
    and such). Metadata isn't required, and in fact, our value converters didn't expose
    any. If you are curious, you must note something—we used the `ValueConverter`
    postfix to name our converter class. Again, why? It's because you must remember
    that one of the Aurelia bases is convention over configuration. In this way, the
    name ending with `ValueConverter` will be assumed to be one value converter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当框架处理资源时，它会检查类的元数据以确定资源类型（自定义元素、自定义属性、值转换器等）。元数据不是必需的，实际上，我们的值转换器没有暴露任何。如果你好奇，你必须注意一点——我们使用了
    `ValueConverter` 后缀来命名我们的转换器类。再次，为什么？这是因为你必须记住 Aurelia 的一个基础是约定优于配置。这样，以 `ValueConverter`
    结尾的名称将被假定为值转换器。
- en: 'Now we will show you a little more advanced example. Let''s apply some changes
    to our class converter:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示一个更高级的例子。让我们对我们的类转换器应用一些更改：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `view-model` file is still the same. Now, our template file will change
    again:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`view-model` 文件仍然是相同的。现在，我们的模板文件将再次发生变化：'
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we can use the same value converter class to render data in different formats,
    according to our view demands.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用相同的值转换器类以不同的格式渲染数据，以满足我们的视图需求。
- en: Without any doubt, we have covered some of the most important features of Aurelia's
    binding behavior, but, for sure, there are more methods and commands that we will
    see in practice. For the moment, we are ready to pass to another important concept—routing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，我们已经涵盖了 Aurelia 绑定行为的一些最重要的功能，但，当然，还有更多方法和命令我们将在实践中看到。目前，我们准备过渡到另一个重要概念——路由。
- en: Routing and resources
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和资源
- en: 'Routing is one of the most important parts of a web application. We already
    have our application deployed in `http://localhost:9000`, but it''s time to start
    defining names and addresses for our resources. First, we need to define what
    a resource is. Conceptually, a resource is every related data belonging to one
    single object or element. For example, a person resource can have fields such
    as name, address, birthday, and more. So, expanding this, a resource can be a
    list of persons too. We will talk deeply about how your resources should be named,
    organized, and called, but at this moment, you just need to know the basics. In
    a web application, every resource has its own address. Let''s look at an example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是网络应用程序最重要的部分之一。我们的应用程序已经部署在 `http://localhost:9000`，但现在是时候开始定义我们资源的名称和地址了。首先，我们需要定义什么是资源。从概念上讲，资源是单个对象或元素相关的所有相关数据。例如，一个人资源可以具有姓名、地址、生日等字段。因此，扩展这一点，资源也可以是一系列人员。我们将深入讨论你的资源应该如何命名、组织以及调用，但在此刻，你只需要知道基础知识。在网络应用程序中，每个资源都有自己的地址。让我们看一个例子：
- en: 'We have an address book with some contacts:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个带有一些联系人的地址簿：
- en: '`http://localhost:9000/` is the server URL, the base of all resources, the
    father path. Generally related to the home/welcome page, or first you define the
    user''s view. The page has a button to see all our contacts.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:9000/` 是服务器URL，所有资源的基路径。通常与主页/欢迎页面相关，或者你首先定义的用户视图。页面有一个按钮可以查看所有我们的联系信息。'
- en: '`http://locahost:9000/persons` is a URL related to the person list resource.
    Here, we will show a list of persons of our address book. You are able to pick
    one to see its contact details.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://locahost:9000/persons` 是与人员列表资源相关的URL。在这里，我们将展示我们的通讯录中的人员列表。你可以选择一个来查看其联系详情。'
- en: '`http://locahost:9000/persons/p001` will refer to the person with the `p001`
    ID. Here, we will be able to see its details. If you give this URL to another
    user, they should be able to see the same data as you, because this URL belongs
    to one single contact—the `p001`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://locahost:9000/persons/p001` 将指向具有 `p001` ID的人员。在这里，我们将能够看到其详情。如果你把这个URL给另一个用户，他们应该能够看到与你相同的数据，因为这个URL属于单一的联系——`p001`。'
- en: '`http://locahost:9000/persons?search=p001` is a little different. Imagine that
    our contact list is composed of more than 500 people. Don''t you think it could
    be easier for the user search them by ID, name, or the most generic parameter?
    Here, we are using a query-param to express our search criteria; of course, we''re
    still working with our friend `p001`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://locahost:9000/persons?search=p001` 略有不同。想象一下，我们的联系列表由超过500人组成。你不认为用户通过ID、姓名或最通用的参数来搜索他们会更方便吗？在这里，我们使用查询参数来表示我们的搜索条件；当然，我们仍在与我们的朋友
    `p001` 一起工作。'
- en: Now, let's configure our application to be ready for routing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置我们的应用程序，使其为路由准备就绪。
- en: At this point, we have already created some components in our application. If
    not, don't worry, we will have enough time to practice that in the last part of
    this chapter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在我们的应用程序中创建了一些组件。如果没有，不要担心，我们将在本章的最后部分有足够的时间来练习这一点。
- en: 'Now, let''s add some code to our `app.js` file. Remember that this file should
    be located in the base `src` folder of our application, since now it will represent
    our base route for all the applications:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向我们的 `app.js` 文件中添加一些代码。请记住，这个文件应该位于我们应用程序的基 `src` 文件夹中，因为现在它将代表我们所有应用程序的基本路由：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s analyze the properties and methods used to define our routes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析用于定义我们的路由的属性和方法：
- en: '`configureRouter(config, router)` is a reserved method that the framework will
    evaluate in the base `view-model` when the application starts. The parameters
    are referencing to the `Router`, `RouterConfiguration` from `aurelia-router` package.
    If they are not provided, the framework will inject them automatically.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configureRouter(config, router)` 是框架在应用启动时将在基本 `view-model` 中评估的保留方法。参数引用自
    `aurelia-router` 包中的 `Router` 和 `RouterConfiguration`。如果它们没有提供，框架将自动注入它们。'
- en: '`this.router = router` is a reference to the router element, just to allow
    us to access this from the view layer (`app.html`), allowing us to build navigation
    menus dynamically.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.router = router` 是对路由元素的引用，仅为了让我们能够从视图层（`app.html`）访问它，从而允许我们动态地构建导航菜单。'
- en: '`config.title` refers to our application title displayed in the browser window.
    Technically, it''s applied to the `<title>` element in the `<head>` of the HTML
    document.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.title` 指的是在浏览器窗口中显示的应用程序标题。技术上，它应用于HTML文档 `<head>` 中的 `<title>` 元素。'
- en: '`config.map()` adds route(s) to the router. Although only `route`, `name`,
    `moduleId`, `href`, and `nav` were shown earlier, there are other properties that
    can be included in a `route`. The interface name for a `route` is `RouteConfig`.
    You can also use `config.mapRoute()` to add a single `route`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.map()` 向路由器添加路由。尽管之前只展示了 `route`、`name`、`moduleId`、`href` 和 `nav`，但还可以在
    `route` 中包含其他属性。`route` 的接口名称为 `RouteConfig`。你也可以使用 `config.mapRoute()` 来添加单个
    `route`。'
- en: '`route` is the pattern to match against the incoming URL fragments. It can
    be a string or array of strings. The `route` can contain parameterized routes
    or wildcards as well.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route` 是与传入的URL片段匹配的模式。它可以是字符串或字符串数组。`route` 可以包含参数化路由或通配符。'
- en: 'Now, let''s analyze the routes we''ve created:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析我们创建的路由：
- en: In the first `route` element, the first flag, `route`, is making reference to
    the base path (`''`) and the `home` path. If we directly access `http//:localhost:9000/`
    or `http//:localhost:9000/home`, the application will display the same page. The
    `name` flag is the URL identifier to call directly from one link or `href` element.
    Finally, we need to reference which file we are referencing with the `route`;
    in this case, the component is located in `home/index` and will be represented
    inside the `moduleId` flag.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个 `route` 元素中，第一个标志 `route` 正在引用基本路径 (`''`) 和 `home` 路径。如果我们直接访问 `http//:localhost:9000/`
    或 `http//:localhost:9000/home`，应用程序将显示相同的页面。`name` 标志是URL标识符，可以直接从一个链接或 `href`
    元素中调用。最后，我们需要通过 `route` 引用我们引用的文件；在这种情况下，组件位于 `home/index`，并将通过 `moduleId` 标志表示。
- en: The second URL is referencing to the `users` resource, but it has some variations.
    The `nav` flag can be a Boolean or number property. When set to true, the route
    will be included in the router's navigation model. When specified as a number,
    the value will be used in sorting the routes; this makes it easier to create a
    dynamic menu or similar elements. Finally, the `title` flag will show the page
    title appended to the page title in the browser window.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个URL引用了 `users` 资源，但它有一些变化。`nav` 标志可以是布尔值或数字属性。当设置为 true 时，路由将被包含在路由器的导航模型中。当指定为数字时，该值将用于排序路由；这使得创建动态菜单或类似元素变得更容易。最后，`title`
    标志将显示附加到浏览器窗口页面标题中的页面标题。
- en: The third is a little different. We can see a weird param in the middle of the
    route, the `:id`. This means that this part of the URL signature will be dynamic,
    do you remember our person `p001`? The `:id` parameter will be used to represent
    the `p001` code and make the URL unique for this resource. Also, in the `view-model`
    file, we will be able to consume that parameter and retrieve some data related
    to it.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种情况略有不同。我们可以在路由中间看到一个奇怪的参数，即 `:id`。这意味着URL签名的一部分将是动态的，你还记得我们的人 `p001` 吗？`:id`
    参数将用于表示 `p001` 代码，并使该资源的URL独一无二。此外，在 `view-model` 文件中，我们将能够消费该参数并检索与其相关的数据。
- en: Lastly, we are seeing `'files/*path'`. Wildcard routes are used to match the
    *rest* of a path. The `href` flag is a conditionally optional property. If it
    is not defined, `route` is used. If `route` has segments, `href` is required as
    in the case of files, because the router does not know how to fill out the parameterized
    portions of the pattern.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们看到 `'files/*path'`。通配符路由用于匹配路径的其余部分。`href` 标志是一个条件性可选属性。如果没有定义，则使用 `route`。如果
    `route` 有段，则 `href` 是必需的，就像在文件的情况下一样，因为路由器不知道如何填充模式中参数化的部分。
- en: There can be some situations where you will need some extra features to deal
    with them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些情况，你需要一些额外的功能来处理它们。
- en: 'For example, case-sensitive routes; Aurelia has that problem solved too:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大小写敏感的路由；Aurelia 也解决了这个问题：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `caseSensitive` flag will be used in these cases.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下将使用 `caseSensitive` 标志。
- en: 'Another situation, very common, can be the unknown routes; Aurelia has a nice
    way to deal with it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常常见的情况是未知路由；Aurelia 有一种很好的处理方式：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `config.mapUnknownRoutes()` method will make a reference to the `''not-found''`
    component module. Another way is representing it as a function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.mapUnknownRoutes()` 方法将引用 `''not-found''` 组件模块。另一种方式是将其表示为一个函数：'
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Other common scenario could be redirected routes. This is very simple—you just
    need to add the `redirect` flag and specify the reference to the module you want
    to show:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见场景可能是重定向路由。这很简单——你只需要添加 `redirect` 标志并指定你想要显示的模块的引用：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: At this point, we know how to configure the routing at the `view-model` level,
    but what about the view? Don't worry, this will be our next topic.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何在 `view-model` 层面上配置路由，但视图呢？别担心，这将是我们的下一个主题。
- en: All this configuration was performed in the `app.js` file, so now we need to
    go to our `app.html` file. You must consider some things before adding the routing
    property to your template.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些配置都是在 `app.js` 文件中完成的，所以现在我们需要转到我们的 `app.html` 文件。在将路由属性添加到模板之前，你必须考虑一些事情。
- en: 'Commonly, most web applications use a base layout. This can be composed by
    the header, a lateral menu, and the view content. That being said, the only element
    that should be refreshed and reloaded with the router is the view content; the
    header and the menu will always be the same for the entire application, so we
    need to define our router element inside that container; let''s look at the code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数Web应用程序使用基本布局。这可以由页眉、侧边菜单和视图内容组成。也就是说，唯一需要由路由器刷新和重新加载的元素是视图内容；页眉和菜单在整个应用程序中始终相同，因此我们需要在容器内部定义我们的路由元素；让我们看看代码：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `<router-view></router-view>` is the HTML flag that Aurelia router will
    use to render the components we''ve configured as routes. Graphically, the representation
    is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`<router-view></router-view>`是Aurelia路由器将用来渲染我们配置为路由的组件的HTML标志。图形表示如下：'
- en: '![](img/96e2aed5-5449-4d52-9a56-1b09c80c7171.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96e2aed5-5449-4d52-9a56-1b09c80c7171.png)'
- en: At this point, everything is okay. However, this is a very basic approach; let's
    explore some advanced way to make our layout more flexible and configurable. We
    know that the `router-view` element defined in HTML is always associated with
    one or more views referenced in a router configuration method defined in its parent
    view's view model.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切正常。然而，这是一个非常基础的途径；让我们探索一些高级方法来使我们的布局更加灵活和可配置。我们知道在HTML中定义的`router-view`元素总是与其父视图的视图模型中定义的路由配置方法中引用的一个或多个视图相关联。
- en: 'To specify a layout on the `router-view` HTML element, we use the following
    attributes:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`router-view` HTML元素上指定布局，我们使用以下属性：
- en: '`layout-view`: Specifies the layout view to use through the filename (with
    path)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-view`：通过文件名（带路径）指定要使用的布局视图'
- en: '`layout-model`: Specifies the model parameter to pass to the activate function
    of view model'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-model`：指定传递给视图模型激活函数的模型参数'
- en: '`layout-view-model`: Specifies the `moduleId` to use with the layout view'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-view-model`：指定与布局视图一起使用的`moduleId`'
- en: 'To explain that, we will implement a custom layout page totally decoupled from
    our `app.html` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这一点，我们将实现一个完全与我们的`app.html`文件解耦的自定义布局页面：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are referencing a file called `layout.html`. This file will contain our
    basic layout distribution:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在引用一个名为`layout.html`的文件。这个文件将包含我们的基本布局分布：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Also, note the `<slot>` tag. This is a mechanism to associate parts of the
    layout to part of some view referencing its name; in this case, let''s create
    a `home` component with custom layout:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`<slot>`标签。这是一个将布局的一部分与引用其名称的视图的一部分关联的机制；在这种情况下，让我们创建一个具有自定义布局的`home`组件：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Any content outside of the slot declared won''t be rendered. We just have one
    more task to do—configure the router:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明的槽之外的内容将不会被渲染。我们只剩下一个任务要做——配置路由：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We just need to declare the route and reference it to the home module. The layout
    will *read* the slot tags defined inside and will render to the main template.
    In this way we can customize the layout according to the route we are accessing
    the application, one use case could have custom menu options while displaying
    some routes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要声明路由并将其引用到主模块。布局将*读取*定义在其中的槽标签，并将渲染到主模板中。这样我们就可以根据我们访问的应用程序的路由来定制布局，一个用例可能有自定义菜单选项，同时显示某些路由。
- en: There is one more thing we need to cover to have our router ready for work—the
    fallback route. Imagine that your application is based on roles. If the user is
    not allowed to access some resource, he should be redirected to the previous location.
    What if there's no previous location? The fallback route comes to the rescue!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的路由器准备好工作，我们还需要覆盖一个东西——回退路由。想象一下，如果你的应用程序基于角色，如果用户不允许访问某些资源，他们应该被重定向到上一个位置。如果没有上一个位置怎么办？回退路由就派上用场了！
- en: 'Let the code show the magic:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让代码展示它的魔力：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you know the most important characteristics about Aurelia router and how
    to configure it to improve your application. We are almost ready to start creating
    components to our FIFA WC App. In the last chapter, we learned about testing,
    TDD, and debugging. Now, it's time to apply the learned concepts and test our
    components. Let's code!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了关于Aurelia路由器及其如何配置以改进应用程序的最重要特性。我们几乎准备好开始创建我们的FIFA WC App组件了。在上一章中，我们学习了测试、TDD和调试。现在，是时候应用所学概念并测试我们的组件了。让我们编码！
- en: Testing our components
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的组件
- en: Testing is one of the most important steps when you develop software applications.
    At this point, we are ready to start creating components, defining binding behaviors,
    and configuring our routes. All is okay, but how do we ensure that our components
    work as expected? We need to test each component before marking it as complete
    and ready for QA/Production environment.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发软件应用程序时最重要的步骤之一。在这个阶段，我们准备好开始创建组件、定义绑定行为和配置我们的路由。一切正常，但我们如何确保我们的组件按预期工作？在标记组件为完成并准备好进行QA/生产环境之前，我们需要测试每个组件。
- en: With Aurelia's component tester, you'll be able to test your component in an
    isolated way, like on a mini Aurelia application. What to do when testing a component?
    Evaluate the expected data, and assert a response to data binding and behavior
    through the life cycle.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Aurelia的组件测试器，你将能够以隔离的方式测试你的组件，就像在一个迷你Aurelia应用程序中一样。在测试组件时应该做什么？评估预期数据，并通过生命周期断言数据绑定和行为。
- en: 'First of all, we need to install the `aurelia-testing` package:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`aurelia-testing`包：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This library is based on Jasmine, the popular BDD JavaScript testing framework
    that provides the test structure and assertions. If you generated your application
    with the Aurelia CLI, Jasmine should be included.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库基于流行的BDD JavaScript测试框架Jasmine，它提供了测试结构和断言。如果你使用Aurelia CLI生成了你的应用程序，Jasmine应该已经包含在内。
- en: Once installed, you can start writing your first unit test. We are going to
    start with a simple component that returns the customer name.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以开始编写你的第一个单元测试。我们将从一个简单的组件开始，该组件返回客户名称。
- en: 'First, let''s define our `View` template:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的`View`模板：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And in the `ViewModel` file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`文件中：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Our component should work. Let''s verify that. We need to create our test file:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件应该可以工作。让我们验证一下。我们需要创建我们的测试文件：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Okay, that looks fine; it should pass. What are we doing?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，看起来没问题；它应该会通过。我们在做什么？
- en: 'First, we import the `StageComponent` from `aurelia-testing`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`aurelia-testing`导入`StageComponent`：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `StageComponent` just creates a new instance of the `ComponentTester` class,
    which does all the work. Next, the `StageComponent` factory will stage the component:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageComponent`只是创建了一个新的`ComponentTester`类的实例，该类执行所有工作。接下来，`StageComponent`工厂将设置组件：'
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `StageComponent` has one property—`withResources()`—and it allows you to
    start off the staging with a fluent API. The class method `withResources` is very
    useful to specify which resource or resources you will use and register. If you
    need more than one single resource, just use an array of string to register all
    of them. Then, `inView` method allows us to provide the HTML code we need to run.
    This is a standard view where you can define properties and other stuff just like
    in our application's real components. Finally, `boundTo` method provides a test
    `viewModel` with the predefined data configured in `inView`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`StageComponent`有一个属性—`withResources()`—它允许你使用流畅的API开始设置。类方法`withResources`非常有用，可以指定你将使用和注册哪些资源。如果你需要多个单一资源，只需使用一个字符串数组来注册所有这些资源。然后，`inView`方法允许我们提供我们需要运行的HTML代码。这是一个标准视图，你可以定义属性和其他内容，就像在我们的应用程序的真实组件中一样。最后，`boundTo`方法提供了一个测试`viewModel`，其中包含了在`inView`中配置的预定义数据。'
- en: 'In this first part, the staging is performed by Jasmine''s `beforeEach()` method
    in order to reuse the same setup in case we have multiple tests:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一部分，设置是通过Jasmine的`beforeEach()`方法执行的，以便在存在多个测试的情况下重用相同的设置：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we enter the test itself, the `create()` method. Create will kick everything
    off and bootstrap the mini Aurelia application (it''s receiving the `bootstrap`
    component imported from the `aurelia-bootstrapper` library imported earlier);
    this method will configure the test using `standardConfiguration`, register provided
    resources as global resources, start the application, and, finally, render your
    component so that you can assert the expected behavior. In this case, we want
    to ensure that our `custName` property gets rendered correctly in the HTML by
    selecting the div tag via its class name. We use `document.querySelector(''.custName'')`
    to get the element value and assert that its `innerHTML` is `Diego`. Next, we
    call Jasmine''s `done` function to tell Jasmine that the test is complete. Calling
    done is needed since the create method is asynchronous and returns a `Promise`.
    If the test raises some error, the `catch()` method will be triggered and will
    print the error log in console:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入测试本身，即`create()`方法。`create()`方法将启动一切，并引导迷你Aurelia应用程序（它接收从之前导入的`aurelia-bootstrapper`库中导入的`bootstrap`组件）；这个方法将使用`standardConfiguration`配置测试，将提供的资源注册为全局资源，启动应用程序，并最终渲染你的组件，这样你就可以断言预期的行为。在这种情况下，我们想要确保我们的`custName`属性在HTML中正确渲染，通过选择具有其类名的div标签。我们使用`document.querySelector('.custName')`来获取元素值并断言其`innerHTML`是`Diego`。接下来，我们调用Jasmine的`done`函数来告诉Jasmine测试已完成。调用`done`是必要的，因为`create`方法异步返回一个`Promise`。如果测试引发某些错误，`catch()`方法将被触发，并在控制台打印错误日志：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, we call `dispose` on our `ComponentTester` instance. This will clean
    up the DOM so that our next test starts out with a clean document.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在我们的`ComponentTester`实例上调用`dispose`。这将清理DOM，以便我们的下一个测试从一个干净的文档开始。
- en: Our first test is complete and guess what...it passed! That was a very basic
    example, but we've learned the basic parts of a component test and how we can
    include it in our application. Now, let's explore more advanced features.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项测试已经完成，猜猜看……它通过了！这是一个非常基础的例子，但我们已经学会了组件测试的基本部分以及如何将其包含在我们的应用程序中。现在，让我们探索更多高级功能。
- en: Testing component life cycle
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件生命周期
- en: 'We need to ensure that our data is retrieved as expected, and the same way,
    we need to assert that our component behavior is going well too. To do this, we
    can tell the component we created that we will manually handle the life cycle
    methods; you will find the code very self-explanatory:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们的数据按预期检索，同样，我们还需要断言我们的组件行为也进行得很好。为此，我们可以告诉创建的组件我们将手动处理生命周期方法；你会发现代码非常直观：
- en: '[PRE54]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The imported libraries still being the same, the `create()` method of our component
    element will bootstrap the application and provide us with an easy way to check
    for our life cycle method responses; just ensure that you call them in the order
    they are executed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的库仍然是相同的，我们组件元素的`create()`方法将启动应用程序，并为我们提供一个简单的方式来检查我们的生命周期方法响应；只需确保你按照它们执行的顺序调用它们。
- en: What about components depending on external services? Don't worry, you just
    need to add some extra lines to the test code and create a class "mocking" the
    service.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 那些依赖于外部服务的组件怎么办？别担心，你只需要在测试代码中添加一些额外的行，并创建一个模拟服务的类。
- en: 'First, our Mock class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的Mock类：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our test class will look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自测类将看起来像这样：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: First of all, we are declaring our mock service as a global variable. This will
    be used for injecting it into Aurelia's container context; this way, the component
    won't detect any difference between the real service class and our mocked service.
    Another thing you should pay attention to is that at the `beforeEach()` method
    level, we are declaring the `firstName` property as `undefined`; this is just
    to make it reusable and customizable for each test depending on their own needs.
    Remember that this method is executed independently for each unit test.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的mock服务为一个全局变量。这将用于将其注入到Aurelia的容器上下文中；这样，组件就不会检测到真实服务类和我们的模拟服务之间的任何差异。还有一点你应该注意，在`beforeEach()`方法级别，我们将`firstName`属性声明为`undefined`；这只是为了使其可重用和可定制，以便根据每个测试的自身需求进行。记住，这个方法会为每个单元测试独立执行。
- en: 'What if I need to define a more complex view, evaluating containers for my
    component? Easy, you are allowed to use template literals:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我需要定义一个更复杂的视图，评估我的组件的容器呢？很简单，你可以使用模板字面量：
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What do you think? It's easy right? That's good! Now, we are completely ready
    for the best part of this chapter; let's put everything in practice!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得怎么样？很简单，对吧？那很好！现在，我们已经完全准备好进入本章的精华部分；让我们将一切付诸实践！
- en: Time to practice!
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候练习了！
- en: It's time to start coding! At this point, we have our application created and
    running, preconfigured to use SASS as CSS preprocessor, and integrated with the
    Aurelia Materialize library to follow good design practices of Material Design.
    Now we need to define our layout. It will be very basic at this time and across
    the application growing, our developed components can be improved and refactorized.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始编码了！在这个时候，我们的应用程序已经创建并运行，预先配置为使用SASS作为CSS预处理器，并与Aurelia Materialize库集成，以遵循Material
    Design的良好设计实践。现在我们需要定义我们的布局。在此时，它将非常基础，并且随着应用程序的增长，我们开发的组件可以被改进和重构。
- en: 'First, we need to access our root folder application; once inside, we just
    need to type the following command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要访问我们的根文件夹应用程序；一旦进入，我们只需输入以下命令：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we open our favorite browser''s window, which should look something like
    this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打开我们最喜欢的浏览器窗口，它应该看起来像这样：
- en: '![](img/2d6fae7e-14d3-4fc2-bc15-f9306dc51a56.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d6fae7e-14d3-4fc2-bc15-f9306dc51a56.png)'
- en: 'Now, let''s create our main layout. Inside the `src` folder, we will create
    a folder named layout. Inside this folder, to subfolders: header and menu:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的主布局。在`src`文件夹内，我们将创建一个名为layout的文件夹。在这个文件夹内，我们将创建两个子文件夹：header和menu：
- en: '`./src > layout > header >`: Here, we will create an HTML file for view and
    JS file for view-model. Both files are called `app-header`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./src > layout > header >`：在这里，我们将创建一个用于视图的HTML文件和一个用于视图模型的JS文件。这两个文件都叫做`app-header`'
- en: '`./src > layout > menu >`: Same way as the header, both files will be called
    `app-menu`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./src > layout > menu >`：与头部相同，这两个文件都将被命名为`app-menu`'
- en: 'Our folder structure should look like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文件夹结构应该看起来像这样：
- en: '![](img/94e94a9e-a44f-428e-b91c-b49a49001190.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94e94a9e-a44f-428e-b91c-b49a49001190.png)'
- en: 'First, we''ll create the `app-header` component. Let''s open the HTML file
    and create our `navbar` header. It''s at this point that we will see the Aurelia
    Materialize features:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建`app-header`组件。让我们打开HTML文件并创建我们的`navbar`头部。就在这一点上，我们将看到Aurelia Materialize的功能：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`<md-navbar>` tag refers to the `navbar` element of Aurelia Materialize. This
    is very helpful because the components are already created; we just need to call
    them and start defining how we want to show to our user. We won''t create any
    CSS class at this point. Inside our `nav-bar`, we are creating two navigation
    options just to see how it looks on the browser.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`<md-navbar>`标签指的是Aurelia Materialize的`navbar`元素。这非常有帮助，因为组件已经创建好了；我们只需要调用它们，并开始定义我们希望向用户展示的方式。我们在此处不会创建任何CSS类。在我们的`nav-bar`中，我们正在创建两个导航选项，只是为了看看在浏览器上的样子。'
- en: 'With our first component created, it''s time to integrate it with our main
    page, `app.html`. First, we need to call the created component using the `<require>`
    tag:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个组件创建完成后，是时候将其与主页面`app.html`进行整合了。首先，我们需要使用`<require>`标签调用创建的组件：
- en: '[PRE60]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we just need to call the created component by its filename:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要通过其文件名调用创建的组件：
- en: '[PRE61]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now just reload your browser''s window and... an error is raised! What to do
    in that case? What happened? Our best friend, the console, will tell us the truth:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需重新加载浏览器窗口，...就出现了一个错误！在这种情况下该怎么办？发生了什么？我们的好朋友，控制台，会告诉我们真相：
- en: '[PRE62]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s pay attention to the last parts of each line. First, the error occurred
    when the Aurelia bootstrapper was importing and configuring our created component.
    The last message tells us the error cause: `undefined` `target`.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注每行的最后部分。首先，错误发生在Aurelia引导程序导入和配置我们创建的组件时。最后一条消息告诉我们错误的原因：`undefined` `target`。
- en: Think for a few minutes, what could have happened? We know you have enough knowledge
    to tell us what the error was.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑几分钟，可能会发生什么？我们知道你有足够的知识来告诉我们错误是什么。
- en: 'Ready? If you note, our recently created `view-model` file for `app-header.js`
    is completely empty. So we have the view, but that view is not pointing to anything,
    and the `target is undefined`! To solve this error, we just need to declare the
    component name and export it:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？如果你注意的话，我们最近创建的`app-header.js`的`view-model`文件是完全空的。所以我们有视图，但这个视图没有指向任何东西，`target`是未定义的！为了解决这个错误，我们只需要声明组件名称并导出它：
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, let''s reload our browser:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新加载我们的浏览器：
- en: '![](img/8fecd523-4b09-4e83-8131-e9c7ac4b3426.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fecd523-4b09-4e83-8131-e9c7ac4b3426.png)'
- en: Awesome, right? Relax, this is just the beginning. Now it's time to create our
    menu.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，对吧？放松，这只是开始。现在，是时候创建我们的菜单了。
- en: 'Our chosen Materialize component is the fixed `sidenav`. However, to integrate
    this into our application, we will merge some of the techniques and concepts learned
    until now. First, let''s code our component:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的Materialize组件是固定的`sidenav`。然而，为了将其集成到我们的应用程序中，我们将合并到目前为止学到的某些技术和概念。首先，让我们编写我们的组件：
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Similarly, using the `<require>` tag, we will import it into our `app.html`
    file. If we just call the `sidenav` menu, we will get the following result:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用`<require>`标签，我们将将其导入到我们的`app.html`文件中。如果我们只是调用`sidenav`菜单，我们将得到以下结果：
- en: '![](img/79d28c18-8032-4bcf-84f5-bb225c6b3d78.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79d28c18-8032-4bcf-84f5-bb225c6b3d78.png)'
- en: Of course, we don't want to hide our main application content! It's time to
    start using CSS to make the `app-menu` play for our team.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想隐藏我们的主要应用程序内容！是时候开始使用CSS来让`app-menu`为我们的团队服务了。
- en: 'First, let''s add some container order to our app.html page. It should be something
    like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的`app.html`页面上添加一些容器顺序。它应该是这样的：
- en: '[PRE65]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We are just involving our main content, in this case, the message property,
    into one container that fills the entire screen no matter the resolution.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将主要的内容，在这种情况下，消息属性，放入一个填充整个屏幕的容器中，无论分辨率如何。
- en: If we run the application, we'll still be seeing the same result. We need to
    apply some custom CSS modifications to our sidenav component. It's time to start
    using SASS!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们仍然会看到相同的结果。我们需要对我们的`sidenav`组件应用一些自定义CSS修改。是时候开始使用SASS了！
- en: We have SASS on our dependencies path, and it's ready for use in our application,
    but let's add some modifications just to make our files distribution a little
    more understandable for us.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在依赖路径上有了SASS，并且它已经准备好在我们的应用程序中使用，但让我们添加一些修改，以便使我们的文件分布对我们来说更容易理解。
- en: Go to the `aurelia_project` folder and open the task called `process-css.js`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`aurelia_project`文件夹，打开名为`process-css.js`的任务。
- en: 'If you remember the Gulp task automation from the previous chapters, you''ll
    find the code very familiar. We just need to add one single line:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得上一章中的Gulp任务自动化，您会发现代码非常熟悉。我们只需要添加一行：
- en: '[PRE66]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Why this line? We want to see the generated CSS file into our project and import
    it from our `index.html` file. Again, why? It's because using this file directly
    into your browser, your style modifications and debugging will be easier in case
    you need to modify or maintain the style sheets.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这一行？我们想看到生成的CSS文件在我们的项目中，并从我们的`index.html`文件中导入它。再次问为什么？因为它直接在浏览器中使用此文件，如果需要修改或维护样式表，您的样式修改和调试将更容易。
- en: Then, let's create our `styles` folder. This should be located directly in our
    `src` folder. Could it be located in a different location? Sure, but we recommend
    that you first check your `aurelia.json` file.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建我们的`styles`文件夹。这个文件夹应该直接位于我们的`src`文件夹中。它是否可以位于不同的位置？当然，但我们建议您首先检查您的`aurelia.json`文件。
- en: 'If you search the `cssProcessor` task, you will find this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您搜索`cssProcessor`任务，您将找到这个：
- en: '[PRE67]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The source property is indicating the level at which our scss files will be
    located, and guess where they are by default? Yes, the `src/*whatever*/*.scss`
    location. You can modify it, but for our current purpose, we don't need to.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 源属性指示我们的scss文件将位于哪个级别，并且默认情况下它们在哪里？是的，`src/*whatever*/*.scss`位置。您可以修改它，但就我们当前的目的而言，我们不需要。
- en: 'Then, inside our folder, let''s create our first .`scss` file called `_mainlayout.scss`.
    Remember that the `_` prefix is to indicate that this style sheet will be used
    as part of another style sheet. We just need to add the following code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的文件夹内，让我们创建我们的第一个名为`_mainlayout.scss`的`.scss`文件。记住，`_`前缀是为了指示这个样式表将作为另一个样式表的一部分使用。我们只需要添加以下代码：
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We are just telling our `header` and application main body to stay 300 px right
    from our app menu. Now, it''s time to reload our browser:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是告诉我们的`header`和应用程序主体保持距离我们的应用程序菜单300像素。现在，是时候重新加载我们的浏览器了：
- en: '![](img/a9859fcc-dab2-481a-9ff5-7bca8e890f81.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9859fcc-dab2-481a-9ff5-7bca8e890f81.png)'
- en: Our base layout is done! Guess what? Yeah, its time to add routing!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础布局完成了！猜猜看？是的，是时候添加路由了！
- en: Let's decouple the welcome message of the `app.js` file. Create a home component
    to render a custom message; we called it `app-home`. Now, instead of the `<h2>`
    tag in your `app.html` file, put the `<router-view>` tag.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`app.js`文件的欢迎信息解耦。创建一个主页组件来渲染自定义消息；我们称之为`app-home`。现在，在您的`app.html`文件中的`<h2>`标签处，放置`<router-view>`标签。
- en: 'In the app `view-model` file, delete the `constructor` method; we won''t use
    it this time. Then, just add the following code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用`view-model`文件中，删除`constructor`方法；这次我们不会使用它。然后，只需添加以下代码：
- en: '[PRE69]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, let's reload our browser. Pay attention to the window title; it now reflects
    our application name!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新加载我们的浏览器。注意窗口标题；现在它反映了我们的应用名称！
- en: '![](img/af791f7f-7765-4879-92f0-8d25501a93ec.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af791f7f-7765-4879-92f0-8d25501a93ec.png)'
- en: For practice purposes, we are done by this time! If you note, we're mixing a
    lot of concerns in just some basic approaches to our application. Now, let's add
    the extra value to our code. Do you remember our hard-coded menu options? Don't
    you think it should be dynamic? Yes, we are talking about adding dynamic binding
    to our practice! What are you waiting for, open your `app-menu` view and `view-model`!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习目的，我们现在就完成了！如果你注意到了，我们正在将许多关注点混合在我们的应用的一些基本方法中。现在，让我们给我们的代码添加额外的价值。你还记得我们硬编码的菜单选项吗？你不认为它应该是动态的吗？是的，我们正在讨论为我们的练习添加动态绑定！你在等什么，打开你的`app-menu`视图和`view-model`！
- en: 'Let''s create an array of string in the `view-model` layer. We will use the
    same options used in the image:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`view-model`层创建一个字符串数组。我们将使用在图片中使用的相同选项：
- en: '[PRE70]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, the magic. The `repeat` command will do the dirty work for us. Okay,
    we know that we didn''t mention it before; do you remember when we said we''ll
    review a lot of new concerns when implementing a real application? This is one
    of those:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是魔法时刻。`repeat`命令将为我们做脏活。好吧，我们知道我们之前没有提到它；你还记得我们说在实现真实应用时我们将回顾许多新关注点吗？这是其中之一：
- en: '[PRE71]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: That was very easy. Now we are really done. Our FIFA WC 2018 App is ready to
    start writing our business services and components! One more thing is pending
    and that's the tests part. We won't cover it in practice, because in the next
    chapter, we will find some more complex components created for our application,
    and we will be nice to apply testing to real-life components.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。现在我们真的完成了。我们的FIFA WC 2018应用已经准备好开始编写我们的业务服务和组件了！还有一件事悬而未决，那就是测试部分。我们不会在练习中涵盖它，因为在下一章中，我们将找到为我们的应用创建的一些更复杂的组件，并且我们将很高兴将测试应用到实际组件上。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Your knowledge about Aurelia at this moment is just amazing! We wanted to cover
    every aspect regarding component creation and how you can abstract your business
    scenario into one digital application. You learned that each component is part
    of an everything, is reusable, and allows you to separate your application concerns.
    Since a component is an isolated piece of your application, it manages his own
    life cycle; Aurelia allows us to have complete control and configure events such
    as data loading or some custom behavior when the components is destroyed. Another
    very interesting thing is that we can create our own events, and we can trigger
    them from the view layer.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你对Aurelia的了解现在真是令人惊叹！我们想要涵盖与组件创建和如何将你的业务场景抽象为一个数字应用相关的各个方面。你了解到每个组件都是整体的一部分，是可重用的，并允许你分离你的应用关注点。由于组件是你的应用的一个独立部分，它管理自己的生命周期；Aurelia允许我们完全控制并配置事件，例如数据加载或组件销毁时的某些自定义行为。另一个非常有趣的事情是我们可以创建我们自己的事件，并且我们可以从视图层触发它们。
- en: Also, you must remember that one component can inherit from other components,
    and they all have properties. Remember that Aurelia is a double-way binding framework,
    so all these properties are synchronized between the view and view model files.
    We also learned how to implement value-converters and some other binding behavior
    to improve our application performance and reduce the amount of code, making our
    application more lightweight and maintainable. Once our components are created
    and we have our application scenarios, it's time to link all of them through dynamic
    routing, defining user workflows and passing dynamic properties to each template.
    Last but never least, we went through how to test our application components,
    ensuring their functionality and life cycle behavior.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你必须记住一个组件可以继承自其他组件，并且它们都有属性。记住Aurelia是一个双向绑定框架，所以所有这些属性都在视图和视图模型文件之间同步。我们还学习了如何实现值转换器和一些其他绑定行为来提高我们的应用性能并减少代码量，使我们的应用更轻量级和易于维护。一旦我们的组件创建完成，并且我们有我们的应用场景，就是时候通过动态路由将它们全部链接起来，定义用户工作流程并将动态属性传递给每个模板。最后但同样重要的是，我们了解了如何测试我们的应用组件，确保它们的功能性和生命周期行为。
- en: You can start creating components and exploring the Aurelia Materialize's library
    to customize your application. In subsequent chapters, you will find our app very
    advanced, but don't worry, there won't be anything we haven't explained. Keep
    practicing!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以开始创建组件并探索Aurelia Materialize的库来定制您的应用程序。在随后的章节中，您会发现我们的应用程序非常先进，但请放心，我们不会解释我们没有解释过的内容。继续练习！
