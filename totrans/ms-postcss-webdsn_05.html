<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Managing Colors, Images, and Fonts"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Managing Colors, Images, and Fonts</h1></div></div></div><p>A website isn't a great website without some form of color, imagery, or fonts—a mix of these will add interest, express content more clearly where words might be insufficient, and generally help maintain visitor engagement.</p><p>Users of existing preprocessors will of course be familiar with libraries such as the Compass authoring framework for SASS from <a class="ulink" href="http://www.compass-style.org">http://www.compass-style.org</a>; what if we could produce similar effects, but much faster, and without the need for dependencies? No problem, with PostCSS, we can pick and choose which plugins are needed for our site, and begin to build up a processor that suits our needs. We will cover a number of topics throughout this chapter, which will include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of plugins available to handle colors, images, and fonts</li><li class="listitem" style="list-style-type: disc">Creating image sprites using existing preprocessors</li><li class="listitem" style="list-style-type: disc">Adding SVG support using existing preprocessors</li><li class="listitem" style="list-style-type: disc">Transitioning to using PostCSS plugins</li><li class="listitem" style="list-style-type: disc">Manipulating colors and color palettes using PostCSS plugins</li></ul></div><p>Let's make a start…!</p><div class="section" title="Adding color, fonts, and media to sites"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Adding color, fonts, and media to sites</h1></div></div></div><p>
<span class="emphasis"><em>A picture paints a thousand words…</em></span>
</p><p>Originally <a id="id211" class="indexterm"/>created in the 1920s, this phrase is so apt in the world of digital <a id="id212" class="indexterm"/>content—writing a hundred words doesn't have the same <a id="id213" class="indexterm"/>appeal if we can replace it with a single image and still <a id="id214" class="indexterm"/>convey the same meaning!</p><p>A part of any developer <a id="id215" class="indexterm"/>or designer's work will be to source the right images or fonts, or <a id="id216" class="indexterm"/>choose the right colors, and include them on the site they are building so they can be referenced at the appropriate point. We'll explore some of the plugins and tricks we can use to modify colors, but for now, let's take a look at some of the plugins available for manipulating images and fonts within a site.</p><div class="section" title="Maintaining asset links"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Maintaining asset links</h2></div></div></div><p>When sourcing media <a id="id217" class="indexterm"/>for a site, the usual process will be to create a folder for fonts, another for images, and so on, if any part of the process is likely to fail, then it is likely to be with applying incorrect links in our code. The risk of this happening will of course increase if we have a particularly complex folder structure!</p><p>Instead, we can take an alternative approach: why not get PostCSS (or a plugin) to do the work for us?</p><p>We can use the <code class="literal">postcss-assets</code> plugin for this purpose; if we specify a name, it will look in the files relative to the source file, then file paths specified in the loadPaths configuration option, and finally search in the URL specified in the basePath config path. The beauty of this is that we can simply reference the image name, and provided PostCSS finds an image with the same name in one of these preassigned locations, then it will substitute in the appropriate path for us at compilation.</p><p>If a link needs to change, then no problem, we can either add a new one in, or modify the existing one; CSS styles will be updated at the next compilation. Let's put this into practice, using the <code class="literal">postcss-assets</code> plugin, in a simple demo.</p></div><div class="section" title="Automating links to assets"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Automating links to assets</h2></div></div></div><p>Remember the <a id="id218" class="indexterm"/>moody landscape image from <a class="link" href="ch04.html" title="Chapter 4. Building Media Queries">Chapter 4</a>, <span class="emphasis"><em>Building Media Queries</em></span>?</p><p>In our first example, we're <a id="id219" class="indexterm"/>going to rework this demo, but this time use the <code class="literal">postcss-assets</code> plugin (available from <a class="ulink" href="https://github.com/borodean/postcss-assets">https://github.com/borodean/postcss-assets</a>) to automate the insertion of links for all of our assets. We'll focus on images and fonts, but this can equally apply to media such as videos as well.</p><p>Here's a screenshot to remind ourselves of that image:</p><div class="mediaobject"><img src="graphics/BO5194_05_01.jpg" alt="Automating links to assets"/></div><p>Let's make a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go ahead and <a id="id220" class="indexterm"/>download a copy of the <code class="literal">Tuturial19</code> folder from the code download that accompanies this book, save this at the root of our project area. This contains a partially reworked version of the demo from <a class="link" href="ch04.html" title="Chapter 4. Building Media Queries">Chapter 4</a>, <span class="emphasis"><em>Building Media Queries</em></span>.</li><li class="listitem">Next, go ahead and <a id="id221" class="indexterm"/>remove any copies of <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> from the root of our project area—we'll start this chapter with fresh copies from our code download.</li><li class="listitem">We now need to install the <code class="literal">postcss-assets</code> plugin, so fire up a Node.js command prompt session, enter this command, and then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-assets --save-dev</strong></span>
</pre></div><p>Don't close it, we will use it again shortly!</p></li><li class="listitem">We need to extract copies of the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from the code download—go ahead and save them to the root of our project area.<p>The sharp-eyed amongst you will note we are not installing any other plugins—we're using ones that we have already installed in earlier exercises; the <code class="literal">package.json</code> file will include references to these and the <code class="literal">postcss-assets</code> file.</p></li><li class="listitem">In the <code class="literal">Tutorial19</code> folder, look for and copy the <code class="literal">styles – pre-compile.css</code> file to the <code class="literal">src</code> folder in our project area; rename it to <code class="literal">styles.css</code>.</li><li class="listitem">Revert back to the Node.js command prompt window, then enter gulp at the prompt and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should have a <code class="literal">maps</code> folder and two CSS stylesheets (one full version, one minified)—if we copy these back to the <code class="literal">css</code> folder in the <code class="literal">Tutorial19</code> folder, then run the demo, we should see a familiar image of a landscape with early mist, as shown at the start of this demo.</li></ol></div><p>Okay, the image is <a id="id222" class="indexterm"/>displayed, along with the text in Roboto font, but how does it <a id="id223" class="indexterm"/>all work? It's worth taking a few moments to explore the code; setting it up correctly will help save you a lot of time!</p><p>Most of what is in the gulp file you will recognize from earlier demos—we've included the same linting, renaming, and source map creations as before. In addition to the new assets task (to handle our asset links), we've removed the <code class="literal">autoprefixer</code> task; we're not calling anything that requires vendor prefixes, so there is no need to use it.</p><p>The key process in the gulp file centers on this code—this creates, and substitutes in, the correct asset links. We start with the options configuration object—the <code class="literal">loadPaths</code> take care of the asset locations, and <code class="literal">relativeTo</code> tells the plugin to set relative links in relation to the <code class="literal">dest/</code> folder. In this case, <code class="literal">loadPaths</code> defines specific folders to use; we use <code class="literal">relativeTo</code> to make these paths relative:</p><div class="informalexample"><pre class="programlisting">var options = {
  loadPaths: ['img/', 'fonts/'],
  relativeTo: 'dest/'
};</pre></div><p>The <code class="literal">dest/</code> folder is used in our creation process—in reality, this would be the location of our CSS style sheets on the production server. This next simple task simply calls the <code class="literal">postcss-assets</code> plugin, and processes each style sheet found in the <code class="literal">src</code> folder:</p><div class="informalexample"><pre class="programlisting">gulp.task('assets', function() {
  return gulp.src('src/*.css')
    .pipe(postcss([ assets(options) ]))
    .pipe(gulp.dest('dest/'));
});</pre></div><p>We then simply call the task, if we were to call gulp from a command prompt, then it will run all of these tasks:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>gulp.task('default', ['assets', 'lint-styles', 'rename', 'sourcemap']);</strong></span>
</pre></div><p>All in all, a very simple but highly effective tool, it removes the need to insert any links manually, provided we've included them within the configuration object.</p><p>Alright…let's move on: we've covered a simple method to ensure we always have the right links for font or <a id="id224" class="indexterm"/>image files. There is still an element of manual work required though—do we really need to include all of the lines added for our custom font?</p><p>Well, we could always just use a font hosted on Google, but that destroys the point of using PostCSS! Instead, we <a id="id225" class="indexterm"/>can simply use the custom font name in our style sheet, but get PostCSS to add in the custom font-face declaration automatically at compilation. Intrigued? Let's take a look at how, as part of our next exercise.</p></div></div></div>
<div class="section" title="Managing fonts with PostCSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Managing fonts with PostCSS</h1></div></div></div><p>In our <a id="id226" class="indexterm"/>previous demo, we explored a means to automatically add links using PostCSS—it shortcuts the need to worry about providing the right locations for files. The trouble is, when used with custom fonts, it still requires too much work (yes, I know, we humans are inherently lazy!). There is a better alternative:</p><p>Enter the <code class="literal">postcss-fontpath</code> plugin, available from <a class="ulink" href="https://github.com/seaneking/postcss-fontpath">https://github.com/seaneking/postcss-fontpath</a>; this is a simple plugin that requires limited information about our <a id="id227" class="indexterm"/>custom font, and in return will produce the full font-face declaration at the compilation stage.</p><p>So, rather than talk about it, why don't we put it to use? Let's revisit the responsive image demo we covered in the previous demo, and alter our style sheet to use the fontpath plugin to handle our custom font:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by extracting a copy of the <code class="literal">Tutorial20</code> folder from the code download that accompanies this book, and save the folder to the root of our project area.</li><li class="listitem">Next, take a copy of <code class="literal">package.json</code> and <code class="literal">gulpfile.js</code> files from the <code class="literal">Tutorial20</code> folder, and replace the existing versions that are at the root of our project area.</li><li class="listitem">Go ahead and fire up a Node.js command prompt, and change the working folder to that of our project area.</li><li class="listitem">At the command prompt, enter this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-fontpath --save-dev</strong></span>
</pre></div><p>Although we've installed the plugin explicitly, we can easily install it using just <code class="literal">npm install</code>; the presence of the <code class="literal">package.json</code> file in the folder will tell NPM what to install (in this case the missing <code class="literal">postcss-fontpath</code> plugin). Keep the session open, we will use it again shortly.</p></li><li class="listitem">Take a copy of <code class="literal">styles – pre-compile.css</code> from the <code class="literal">css – completed version</code> folder, and save this as <code class="literal">styles.css</code> into the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">Revert back to <a id="id228" class="indexterm"/>the Node.js command prompt window, then enter <code class="literal">gulp</code> at the prompt, and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should see the, by now, familiar style sheets and source map appear in the <code class="literal">dest</code> folder; copy these to the <code class="literal">css</code> folder within the <code class="literal">Tutorial20</code> folder.</li></ol></div><p>At this point, we should now have <a id="id229" class="indexterm"/>a working demo; we won't see anything intrinsically different, but know that at compilation, PostCSS has automatically added the right font-face declarations for our font.</p><p>The beauty about this plugin is in its simplicity—it needs no more than the addition of a simple command in the main task:</p><div class="informalexample"><pre class="programlisting">gulp.task('fonts', function () {
  return gulp.src('src/*.css').pipe(
    postcss([ fontpath() ])
  ).pipe(
    gulp.dest('dest/')
  );
});</pre></div><p>There is no need to have to specify any additional configuration elements or rules, the plugin does exactly what it says on the tin, so to speak! Although we've not achieved anything ground-breaking with this example, it does serve to illustrate some key points about using PostCSS:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">PostCSS works best when plugins concentrate on a single task and don't try to achieve everything under the sun in one go. Adhering to the single responsibility principle means we can reduce duplication, make the plugin more robust, and avoid instances where changes can end up breaking functionality elsewhere in our processor! This plugin is perfect—it just provides a font-face declaration for the specified font, and nothing else.</li><li class="listitem" style="list-style-type: disc">Sometimes, when choosing the right plugin in PostCSS, there will be occasions when we choose something that later turns out not to work as expected. A case in point is the <code class="literal">postcss-font-magician</code> plugin (available from <a class="ulink" href="https://github.com/jonathantneal/postcss-font-magician">https://github.com/jonathantneal/postcss-font-magician</a>); it has the right idea of providing font-face declarations, but tries to provide them for Google-hosted fonts, locally hosted fonts, Bootstrap, and so on. <div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Unfortunately, the net result is that at the time of writing, not all of the functionality appears to work as expected, so it is at this point where we have to look for alternatives.</p></div></div></li></ul></div><p>If you would like to explore more, then the <code class="literal">postcss.parts</code> directory (at <a class="ulink" href="http://www.postcss.parts">http://www.postcss.parts</a>) has more options available; two that might be of interest are the <code class="literal">Assets Rebase</code> plugin (from <a class="ulink" href="https://github.com/devex-web-frontend/postcss-assets-rebase">https://github.com/devex-web-frontend/postcss-assets-rebase</a>), and the PostCSS <code class="literal">Font Pack</code> plugin, from <a class="ulink" href="https://github.com/jedmao/postcss-font-pack">https://github.com/jedmao/postcss-font-pack</a>. We will cover the latter plugin in more detail in <a class="link" href="ch08.html" title="Chapter 8. Creating PostCSS Plugins">Chapter 8</a>, <span class="emphasis"><em>Creating PostCSS Plugins</em></span>.</p><p>Okay, so we have <a id="id230" class="indexterm"/>our text in place: it does look a little boring, doesn't it? Well, we can fix that by adding images. So, how exactly can PostCSS help us, I hear <a id="id231" class="indexterm"/>you ask?</p><p>It can help in a number of ways—instead of using plain colors, we can begin to mix some together, for example. Or how about using image sprites? A pain to create manually, right? Not with PostCSS. I'll bet you've seen some of the image filters you can use on images (such as sepia or tint), but found that they don't work in every browser right?</p><p>These are just some of the ways that PostCSS can help us, and we will cover all of these and more throughout this chapter. Let's make a start though on working with images: our first demo will cover the creation of image sprites. We'll start with a quick recap of the SASS process, before switching to using PostCSS.</p></div>
<div class="section" title="Creating image sprites"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Creating image sprites</h1></div></div></div><p>Let's start with <a id="id232" class="indexterm"/>something easy: I'm sure that at some point you will either have used or created image sprites, right? If you're a SASS developer, no doubt you will have availed yourself of the sprite mixins from Compass, and used an app such as <span class="strong"><strong>Koala</strong></span> to compile, or compiled directly from the command line.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>A copy of the relevant files for creating sprites using Compass can be found in the code download that accompanies this book, in the <code class="literal">Tutorial21A</code> folder.</p></div></div><p>The process is relatively straightforward, but you still have to set up a <code class="literal">Compass</code> project, install a GUI application (if you're using one), and so on, which is a real pain! We could use an online application such <a id="id233" class="indexterm"/>as <span class="strong"><strong>SpritePad</strong></span> (<a class="ulink" href="http://spritepad.wearekiss.com/">http://spritepad.wearekiss.com/</a>) instead, but again that's a manual process, and it's prone to error. Instead, we can easily use PostCSS to help us here —over and above the normal <a id="id234" class="indexterm"/>variables that we declare at the top of any gulp file, there is very little required in order to produce basic image sprites. Let's take a look at creating one now, using the <code class="literal">p</code>
<code class="literal">ostcss-sprites</code> plugin.</p><div class="section" title="Demo – creating a credit card icon bar"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Demo – creating a credit card icon bar</h2></div></div></div><p>How many <a id="id235" class="indexterm"/>times have you bought something from an e-commerce site? If you've bought as much as I have online, then no doubt you will have seen shopping carts with assorted payment card icons. These may be small, but they are nevertheless key to our site—after all, how can we tell if using a particular credit card might fail, if the online retailer doesn't accept Mastercard, for example? Seems obvious, but it's not always easy to tell.</p><p>Leaving that aside, it is a cinch to create an image sprite with PostCSS; gone is the dependency on SASS: in <a id="id236" class="indexterm"/>its place we can use the <code class="literal">postcss-sprites</code> plugin (available from <a class="ulink" href="https://github.com/2createStudio/postcss-sprites">https://github.com/2createStudio/postcss-sprites</a>) to produce our composite image. Let's dive in and take a look.</p><p>For this demo, we will <a id="id237" class="indexterm"/>use the credit card icons available at <a class="ulink" href="http://findicons.com/pack/2102/credit_card_debit_card">http://findicons.com/pack/2102/credit_card_debit_card</a>; please feel free to substitute if you would like to use different icons.</p><p>All of the code for this tutorial can be found in the <code class="literal">Tutorial21B</code> folder, in the code download—we will start afresh by installing the <code class="literal">postcss-sprites</code> plugin:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go ahead and fire up a Node.js command prompt, and change the working folder to that of our project area.</li><li class="listitem">At the command prompt, enter the command shown in this screenshot, then press <span class="emphasis"><em>Enter</em></span>, once Node has confirmed successful installation, and minimize the window, as we will return to it later in this exercise:<div class="mediaobject"><img src="graphics/BO5194_05_02.jpg" alt="Demo – creating a credit card icon bar"/></div></li><li class="listitem">Go ahead and fire up your text editor, then add the following lines—these represent four credit card icons we would typically add to any online e-commerce site:<div class="informalexample"><pre class="programlisting">.amex { background: #fff url(img/amex.png) no-repeat 0 0; }
.cirrus { background: url(img/cirrus.png) no-repeat 0 0; }

.delta { background: url(img/delta.png) no-repeat 0 0; }
.solo { background: url(img/solo.png) no-repeat 0 0; }</pre></div></li><li class="listitem">Save the file as <code class="literal">style.css</code>, and store it in the <code class="literal">src</code> folder of our project area.</li><li class="listitem">In the same folder, create a folder called <code class="literal">img</code> at the root of our project area; extract copies of the icons stored in the code download that accompanies this book, and save them to the <code class="literal">img</code> folder.</li><li class="listitem">From the <a id="id238" class="indexterm"/>code download that accompanies this book, go ahead and extract a copy of <code class="literal">gulpfile.js</code>, and save this to the root of our project area.</li><li class="listitem">Revert back to the Node.js window, then at the prompt, enter <code class="literal">gulp</code> and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">Our code will now be compiled, if all is well, we should see something akin to this when viewing the <code class="literal">style.css</code> file within the <code class="literal">dest</code> folder:<div class="informalexample"><pre class="programlisting">.amex { background-image: url(../img/sprite.png); background-position: 0 0; background-color: #fff; }
.cirrus { background-image: url(../img/sprite.png); background-position: -102px 0; }
.delta { background-image: url(../img/sprite.png); background-position: 0 -64px; }
.solo { background-image: url(../img/sprite.png); background-position: -102px -64px; }</pre></div></li></ol></div><p>At this stage, we can then copy the code to our website, along with image—instead of using four separate icons (which each require separate calls to the server), we can cache the single icon. This will result in faster response times with fewer calls to our server. The compiled style sheet can be found in the <code class="literal">dest</code> folder, with the composite image one level up, in the <code class="literal">img</code> folder:</p><div class="mediaobject"><img src="graphics/BO5194_05_03.jpg" alt="Demo – creating a credit card icon bar"/></div><p>Even though this is a simple process, it's worth noting a key point with how our gulp file has been configured—the use of a configuration object for the <code class="literal">sprites</code> plugin:</p><div class="informalexample"><pre class="programlisting">var opts = {
  stylesheetPath: 'dest/',
  spritePath    : 'img/sprite.png',
  path          : 'src/img/'
};</pre></div><p>It's not a process we've <a id="id239" class="indexterm"/>used to date, but it does not mean that it is any less useful—it simply boils down to a matter of personal preference and readability. It does make it easier to read the calls for each plugin we assign; in this instance, we're only using one, but you can imagine what it will be like with multiple plugins in use:</p><div class="informalexample"><pre class="programlisting">gulp.task('autoprefixer', function() {
  return gulp.src('src/*.css')
    .pipe(postcss([ sprites(opts) ]))
    .pipe(gulp.dest('dest/'));
});</pre></div><p>Okay, let's change tack and take a look at a different side to using images with PostCSS: using SVG format images. Standard images don't always scale well, particularly when used in a responsive environment; sometimes we might use retina images instead, but an alternative to consider is the use of SVG images.</p></div></div>
<div class="section" title="Working with SVG in PostCSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Working with SVG in PostCSS</h1></div></div></div><p>The rapidly <a id="id240" class="indexterm"/>increasing use of mobile devices makes creating responsive content a must; the traditional route is using something akin to <code class="literal">max-width: 100%</code> to control the size of an element on screen.</p><p>A better alternative is to use SVG—this maintains quality, even when resized; standard image formats will become pixelated if resized to an excessive size. For those of you who have previously used SASS, then there isn't any in-built support for SVG as such; the most we can hope to achieve is efficient nesting within our style sheet.</p><p>An example of what we might use can be found in the <code class="literal">sass</code> folder within the <code class="literal">Tutorial22</code> folder in the code download that accompanies this book.</p><p>If we're a regular user of SVG images within SASS, then it is likely we would use a library such as <code class="literal">sass-svg</code>, from <a class="ulink" href="https://github.com/davidkpiano/sass-svg">https://github.com/davidkpiano/sass-svg</a>. Moving away from SASS to <a id="id241" class="indexterm"/>PostCSS is easy; the PostCSS ecosystem has a number of plugins we can use to manipulate images. Let's take a look at how, using the <code class="literal">postcss-svg</code> plugin.</p><div class="section" title="Altering icon images using PostCSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Altering icon images using PostCSS</h2></div></div></div><p>We'll use the <a id="id242" class="indexterm"/>
<code class="literal">postcss-svg</code> plugin (from <a class="ulink" href="https://github.com/Pavliko/postcss-svg">https://github.com/Pavliko/postcss-svg</a>), to manipulate some icons from the <code class="literal">Evil Icon</code> package (available from <a class="ulink" href="https://github.com/outpunk/gulp-evil-icons">https://github.com/outpunk/gulp-evil-icons</a>), as part of the next demo:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll begin by extracting a copy of the <code class="literal">Tutorial22</code> folder from the code download that accompanies this book. Save it to the root of our project area.</li><li class="listitem">From within the <code class="literal">Tutorial22</code> folder, extract copies of the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files, and use them to replace any that are currently stored at the root of our project area.</li><li class="listitem">Go ahead and extract a copy of <code class="literal">style – pre-compile.css</code> from the same folder; save this as <code class="literal">style.css</code> within the <code class="literal">src</code> folder. Do the same for the <code class="literal">index.html</code> file as well.</li><li class="listitem">In a break to previous demos, we need an additional <code class="literal">css</code> folder—go ahead and create one within the <code class="literal">dest</code> folder.</li><li class="listitem">Next, fire up a Node.js command prompt, and change the working folder to that of our project area.</li><li class="listitem">We need to install the <code class="literal">postcss-svg</code> plugin, so at the command prompt, enter this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-svg --save-dev</strong></span>
</pre></div></li><li class="listitem">Once completed, enter <code class="literal">gulp</code> at the command prompt, then press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should see the usual two style sheets appear in the <code class="literal">/dest/css</code> folder, along with a source <code class="literal">map</code> folder. The HTML markup file will appear in the <code class="literal">dest</code> folder.<p>If you don't see the source map or minified versions appear, then rerun <code class="literal">gulp</code>—sometimes these files will only appear if a compiled <code class="literal">style.css</code> file is present.</p></li><li class="listitem">Copy the contents of the <code class="literal">dest</code> folder to the <code class="literal">css</code> folder within the<code class="literal"> Tutorial22</code> folder—if all is well, we should see these icons appear when previewing the results in a browser:<div class="mediaobject"><img src="graphics/BO5194_05_04.jpg" alt="Altering icon images using PostCSS"/></div></li></ol></div><p>Although this is a <a id="id243" class="indexterm"/>simple demo, we've covered some useful tips and tricks within; it's worth taking some time to explore how the demo was put together in more detail.</p></div><div class="section" title="Exploring the results in more detail"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Exploring the results in more detail</h2></div></div></div><p>There are several <a id="id244" class="indexterm"/>key elements to this exercise that are worthy of attention, the use of a CDN link and Node to provide the style sheet and icons for Evil Icons, the compiled HTML file and the references to use within our custom style sheet. We will cover all of these, but first let's explore the gulp file in more detail.</p><p>We begin with these two lines:</p><div class="informalexample"><pre class="programlisting">var evilIcons = require("gulp-evil-icons");
var postcssSVG = require('postcss-svg')</pre></div><p>You should not be surprised to see the latter, but the former is present as the <code class="literal">Evil Icons</code> library can be installed using the <code class="literal">gulp-evil-icons</code> package. There are a number of different options available for installing, but as we're already using Gulp, it makes sense to continue using the task runner.</p><p>Next, we spread our work over two tasks—the first compiles the HTML code to assign the relevant icon image to our <code class="literal">&lt;icon&gt;</code> statements within our markup:</p><div class="informalexample"><pre class="programlisting">gulp.task('icons', function () {
  return gulp.src('src/index.html')
.pipe(evilIcons())
    .pipe(gulp.dest('dest/'));
});</pre></div><p>To change the colors requires the use of the <code class="literal">postcss-svg</code> plugin, here referenced by <code class="literal">postcssSVG</code>:</p><div class="informalexample"><pre class="programlisting">gulp.task('changecolor', ['icons'], function() {
  gulp.src('src/style.css')
  .pipe(postcss([ postcssSVG() ]))
    .pipe(gulp.dest('dest/'));
});</pre></div><p>We of course had to update our default task, if we simply call <code class="literal">gulp</code> at the command line, then it will know to run all of these tasks in turn:</p><div class="informalexample"><pre class="programlisting">gulp.task('default', ['icons', 'changecolor', 'lint-styles' , 'rename', 'sourcemap' ]);</pre></div><p>The last step also applies a similar update to our watch facility:</p><div class="informalexample"><pre class="programlisting">var watcher = gulp.watch('src/*.*', ['default', 'icons', 'changecolor', 'lint-styles', 'rename', 'sourcemap']);</pre></div><p>If we then take a look within the HTML markup, we can see a link to the <code class="literal">Evil Icons</code> library that was installed using Node.js:</p><div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" href="../node_modules/gulp-evil-icons/node_modules/evil-icons/assets/evil-icons.css"&gt;</pre></div><p>We then put our <a id="id245" class="indexterm"/>customizations into a separate style sheet:</p><div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" type="text/css" href="css/style.css"&gt;</pre></div><p>These look something like this:</p><div class="mediaobject"><img src="graphics/BO5194_05_05.jpg" alt="Exploring the results in more detail"/></div><p>At this stage, the CSS styles may look simple, but the HTML markup is anything but; the <code class="literal">postcss-svg</code> plugin has added an in-line version of our icons to the HTML markup, with the appropriate edits made from our custom style sheet:</p><div class="mediaobject"><img src="graphics/BO5194_05_06.jpg" alt="Exploring the results in more detail"/></div><p>Sometimes, it is easy to wonder <a id="id246" class="indexterm"/>if using SVG is worth the extra markup, the main benefit being that if it is added in-line, then we reduce the number of calls to external resources; any content that requires altering can be done, without sacrificing the quality of our images.</p></div><div class="section" title="Considering alternative options"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Considering alternative options</h2></div></div></div><p>We concentrated on <a id="id247" class="indexterm"/>using the <code class="literal">postcss-svg</code> plugin throughout our exercise, as a start to manipulating SVG images within the PostCSS system; there are some more options available, which may be of interest:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-write-svg</code>: This plugin (available at <a class="ulink" href="https://github.com/jonathantneal/postcss-write-svg">https://github.com/jonathantneal/postcss-write-svg</a>) allows us to write inline <a id="id248" class="indexterm"/>SVGs in CSS.</li><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-inline-svg</code>: Another plugin (from <a class="ulink" href="https://github.com/TrySound/postcss-inline-svg">https://github.com/TrySound/postcss-inline-svg</a>), which in-lines SVG images and <a id="id249" class="indexterm"/>allows us to customize their styles.</li><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-svgo</code>: This <a id="id250" class="indexterm"/>plugin (available at <a class="ulink" href="https://github.com/ben-eb/postcss-svgo">https://github.com/ben-eb/postcss-svgo</a>) processes inline SVG using the SVG Optimizer Tool for Node.</li></ul></div><p>If you have a need to provide a fall-back position for SVG files, then you can try the <code class="literal">postcss-svg-fallback</code> <a id="id251" class="indexterm"/>plugin, available from <a class="ulink" href="https://github.com/justim/postcss-svg-fallback">https://github.com/justim/postcss-svg-fallback</a>— we will use this plugin later, in <a class="link" href="ch08.html" title="Chapter 8. Creating PostCSS Plugins">Chapter 8</a>, <span class="emphasis"><em>Creating PostCSS Plugins</em></span>.</p><p>Okay, let's change tack: <a id="id252" class="indexterm"/>using SVG images can be a little heavy handed if all we need is a straightforward format for displaying images, right? Well, we could use standard formats, or one which has superior quality while maintaining smaller sizes. I'm talking about the lesser-known WebP format from Google—let's dig in and find out more about this format, and why it deserves more attention.</p></div></div>
<div class="section" title="Adding support for WebP images"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Adding support for WebP images</h1></div></div></div><p>Manipulating SVG <a id="id253" class="indexterm"/>images is an acquired art, and in some instances, it will clearly be overkill for what we need to achieve.</p><p>Instead, for those occasions where we need the detail in our images, we might normally use the JPEG format, or potentially PNG as an alternative. There's nothing wrong with either, but, it's old hat, and I do like to push the boundaries of what is possible! In addition, the JPEG image format is lossy and does not support alpha channels; PNG images are lossless, but suffer from larger file sizes for more complex images. If all we did was simply insert images onto a page, then PostCSS wouldn't be helpful here; instead, how about considering a different format altogether?</p><p>Enter Google's <span class="strong"><strong>WebP</strong></span>. You'd be forgiven for thinking "Web…what?", as it isn't a common format! Part of this can be attributed to the lack of take-up; the only browsers to support it natively are Chrome, Android, and Opera. That doesn't mean to say it should be discounted. The format can offer some significant space savings over standard image formats such as JPEG or PNG, while maintaining superior quality. We can even get PostCSS to do most of the work for us, to boot! Let's explore the nuts and bolts of this in more detail, with a simple demo.</p><div class="section" title="Switching WebP images in and out"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Switching WebP images in and out</h2></div></div></div><p>Image switching <a id="id254" class="indexterm"/>is nothing new, we covered one aspect back in <a class="link" href="ch04.html" title="Chapter 4. Building Media Queries">Chapter 4</a>, <span class="emphasis"><em>Building Media Queries</em></span>, when we used PostCSS to switch-in hi-res images when supported in the browser.</p><p>We can use a similar technique, but this time with image formats, Google's WebP format was designed as a replacement for the myriad of other image formats available for the web. In an ideal world, we would use the new <code class="literal">&lt;picture&gt;</code> tag to take care of switching images automatically:</p><div class="informalexample"><pre class="programlisting">&lt;picture&gt;
  &lt;source srcset="../img/landscape.webp" type="image/webp"&gt;
  &lt;img src="../img/landscape.jpg" alt="The Oslo Opera House"&gt;
&lt;/picture&gt;</pre></div><p>It's not supported in all browsers, so instead, we can use a mix of PostCSS and Modernizr to apply the same effect. The <a id="id255" class="indexterm"/>plugin we need for this task is the <code class="literal">webpcss</code> plugin (available from <a class="ulink" href="https://github.com/lexich/webpcss">https://github.com/lexich/webpcss</a>)—we will need to run <code class="literal">npm install gulp-webp --save-dev</code> in a Node.js command prompt session to install the plugin. Let's dive in and take a look at it in more detail.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>For best results, I would recommend using Chrome throughout these two demos, support can be added for Windows and other browsers, by visiting <a class="ulink" href="https://developers.google.com/speed/webp/">https://developers.google.com/speed/webp/</a>.</p></div></div></div><div class="section" title="Viewing the differences in file sizes"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Viewing the differences in file sizes</h2></div></div></div><p>Before we get <a id="id256" class="indexterm"/>stuck into using PostCSS, let's take a moment to perform a quick test. The files for this tutorial are in the <code class="literal">Tutorial 23</code> folder:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the code download that accompanies this book, go ahead and extract a copy of <code class="literal">landscape – original version.jpg</code>, and rename it as <code class="literal">landscape.jpg</code>. The size should be around 11.5 MB in size.</li><li class="listitem">Save the image to the root of our project area—we also need a copy of <code class="literal">cwebp.exe</code>, so go ahead and extract that to our project area as well.</li><li class="listitem">Fire up a command prompt session, change the working folder to our project area, enter <code class="literal">gulp</code>, and then press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should see the results of our conversion, and the new WebP-format image appear in our project area:<div class="mediaobject"><img src="graphics/BO5194_05_07.jpg" alt="Viewing the differences in file sizes"/></div></li><li class="listitem">Try performing the same process with a PNG format image; here are the results of a <a id="id257" class="indexterm"/>similar test I performed, with a PNG version of our landscape image:<div class="mediaobject"><img src="graphics/BO5194_05_08.jpg" alt="Viewing the differences in file sizes"/></div></li></ol></div><p>In both cases, the image sizes reduced significantly, the JPEG version dropped from around 12.5 MB to just over 7 MB; the PNG format shrunk from an enormous 25 MB to around the same size!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>To learn more about using the <a id="id258" class="indexterm"/>WebP format, take a look at the documentation on the Google Developers site at <a class="ulink" href="https://developers.google.com/speed/webp/">https://developers.google.com/speed/webp/</a>.</p></div></div><p>Okay, time for another demo! Let's now make use of PostCSS to create our styles for both standard JPEG format, and WebP equivalents:</p><div class="mediaobject"><img src="graphics/BO5194_05_09.jpg" alt="Viewing the differences in file sizes"/></div><p>For this demo, we'll <a id="id259" class="indexterm"/>use the <code class="literal">gulp-webpcss</code> plugin, available from <a class="ulink" href="https://github.com/lexich/webpcss">https://github.com/lexich/webpcss</a>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go ahead <a id="id260" class="indexterm"/>and download a copy of the <code class="literal">Tuturial23</code> folder from the code download that accompanies this book, save this at the root of our project area.</li><li class="listitem">Next, go ahead and remove any copies of <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> from the root of our project area; we need to replace them with copies from the <code class="literal">Tutorial23</code> folder.</li><li class="listitem">With these files in place, we still need to install the plugins, in a Node.js command prompt window, change the working folder to our project, then run these commands, pressing <span class="emphasis"><em>Enter</em></span> after each:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install --save-dev gulp-webp </strong></span>
<span class="strong"><strong>npm install --save-dev gulp-webpcss </strong></span>
</pre></div><p>Note the order of the parameters in these commands, if they are written in a different order, they will not install.</p></li><li class="listitem">Copy the <code class="literal">style – pre-compile.css</code> file from the <code class="literal">Tutorial23</code> folder to the <code class="literal">src</code> folder at the root of our project area, then rename it as <code class="literal">style.css</code>.</li><li class="listitem">Fire up a Node.js command prompt, change the working folder to our project area, then enter <code class="literal">gulp</code> at the prompt and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should see the code shown in this screenshot when viewing the contents of <a id="id261" class="indexterm"/>the compiled file; the converted image will also appear in the <code class="literal">img</code> folder:<div class="mediaobject"><img src="graphics/BO5194_05_10.jpg" alt="Viewing the differences in file sizes"/></div></li><li class="listitem">Copy the contents of the <code class="literal">img</code> folder into the <code class="literal">img</code> folder within the <code class="literal">Tutorial23</code> folder.</li><li class="listitem">Copy the <code class="literal">style.css</code> file from the <code class="literal">dest</code> folder into the <code class="literal">css</code> folder within the <code class="literal">Tutorial23</code> folder.</li><li class="listitem">Go ahead and run <code class="literal">index.html</code> in a browser, if all is well, we should see something akin to the screenshot at the start of this exercise.</li></ol></div><p>If we run the same <code class="literal">index.html</code> in Google Chrome or Firefox, at first we should not see any difference—we'll only see the difference when viewing the compiled source within the Developer Toolbar in Chrome:</p><div class="mediaobject"><img src="graphics/BO5194_05_11.jpg" alt="Viewing the differences in file sizes"/></div><p>The real benefit, though, is in the <code class="literal">img</code> folder within our project area, the original JPEG image we use is 222 KB; however, the WebP is a fraction of this size: it weighs in at just 82 KB. See what I mean about the saving in space?</p><p>Okay, onwards we go: time to focus on another area of site building, which is manipulating colors. Colors play a key role within any site, as they make up a part of the message to the end user; let's dive in and take a look at some of the options available when using PostCSS.</p></div></div>
<div class="section" title="Manipulating colors and color palettes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Manipulating colors and color palettes</h1></div></div></div><p>A challenge that any <a id="id262" class="indexterm"/>developer or designer will face is which color should be <a id="id263" class="indexterm"/>used on a site—a nice shade of red, or how about sea blue, for example? It doesn't matter whether they are responsible for choosing the shade to use, or if they have to pick the right RGB or HEX color to use.</p><p>Irrespective of where responsibilities lie, we still have to choose a color, and there is a good chance we won't be choosing one that comes from the default 256-color palette, but one that is likely to be a lighter or darker shade, or perhaps a mix of two colors:</p><div class="mediaobject"><img src="graphics/BO5194_05_12.jpg" alt="Manipulating colors and color palettes"/></div><p>Anyone used to working with SASS will already be aware of functions such as <code class="literal">lighten()</code>, <code class="literal">darken()</code> or <code class="literal">saturate()</code>—the great thing about PostCSS is that we can replicate similar functionality for those who want to move away from the dependency of SASS.</p><p>To see how easy it is to use, we're going to combine the power of two plugins for PostCSS—<code class="literal">postcss-color-palette</code> (available at <a class="ulink" href="https://github.com/zaim/postcss-color-palette">https://github.com/zaim/postcss-color-palette</a>), and <code class="literal">postcss-color-mix</code> (from <a class="ulink" href="https://github.com/iamstarkov/postcss-color-mix">https://github.com/iamstarkov/postcss-color-mix</a>). The former allows us to choose one or more colors from any of three palettes, while <code class="literal">postcss-color-mix</code> will mix specific colors to make a new color. There are reasons for using these plugins, which will become clear; for now, let's get stuck in and watch these plugins in action.</p><div class="section" title="Displaying and mixing colors using palettes"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Displaying and mixing colors using palettes</h2></div></div></div><p>In this <a id="id264" class="indexterm"/>exercise, we're going to take a look at mixing colors; <code class="literal">postcss-color-palette</code> allows us to choose multiple colors by name (and not by number!), then <a id="id265" class="indexterm"/>converts them to HEX equivalent values. We can then either create gradient-type effects, or simply mix the colors together (using <code class="literal">postcss-color-mix</code>) to produce a new color.</p><p>Let's make a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by extracting a copy of the <code class="literal">Tutorial24</code> folder from the code download that accompanies this book; save the folder to the root of our project area.</li><li class="listitem">From the <code class="literal">Tutorial24</code> folder, copy the <code class="literal">package.json</code> and <code class="literal">gulpfile.js</code> files to the root of our project area.</li><li class="listitem">We also need our stylesheet, for this, go ahead and copy the <code class="literal">style – pre-compile.css</code> file from the same folder and drop this into the <code class="literal">src</code> folder in our project area. Rename it as <code class="literal">style.css</code>.</li><li class="listitem">At this point we <a id="id266" class="indexterm"/>need to install the plugin, for this, so go <a id="id267" class="indexterm"/>ahead and fire up a Node.js command prompt session, then change the working folder to our project area.</li><li class="listitem">At the prompt, enter the command shown in this screenshot, then press <span class="emphasis"><em>Enter</em></span>, if all is well, we should see confirmation that the plugin has installed correctly:<div class="mediaobject"><img src="graphics/BO5194_05_13.jpg" alt="Displaying and mixing colors using palettes"/></div></li><li class="listitem">Repeat step 5, but this time, run the command shown in this screenshot:<div class="mediaobject"><img src="graphics/BO5194_05_14.jpg" alt="Displaying and mixing colors using palettes"/></div></li><li class="listitem">At the prompt, enter <code class="literal">gulp</code>, then press <span class="emphasis"><em>Enter</em></span>—PostCSS will go away and compile the style sheet, and drop the compiled results into the <code class="literal">dest</code> folder.</li><li class="listitem">Copy the contents of the <code class="literal">dest</code> folder (which will be the uncompressed and minified style <a id="id268" class="indexterm"/>sheets, along with a source map file) to the <code class="literal">css</code> folder within the <code class="literal">Tutorial24</code> folder.</li><li class="listitem">Try previewing <a id="id269" class="indexterm"/><code class="literal">index.html</code> at the root of our <code class="literal">Tutorial24</code> folder; if all is well, we should see our mixed colors, as shown in this screenshot:<div class="mediaobject"><img src="graphics/BO5194_05_15.jpg" alt="Displaying and mixing colors using palettes"/></div></li></ol></div><p>Okay, the colors I've chosen clearly aren't going to win any style awards any time soon, but they help serve a purpose: it is very easy to use proper color names, if preferred, while still allowing PostCSS to compile them into valid HEX values. That aside, let's take a moment to consider the code we've used in this demo—it does raise a few key points, which we should cover, when using these plugins.</p></div><div class="section" title="Dissecting our demo in more detail"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Dissecting our demo in more detail</h2></div></div></div><p>The demo we've <a id="id270" class="indexterm"/>created follows similar principles to most other demos we've built so far; we begin with declaring variables to store instances of our plugins, thus:</p><div class="informalexample"><pre class="programlisting">var palette = require('postcss-color-palette');
var colormix = require('postcss-color-mix')</pre></div><p>The magic then happens in this task, within our <code class="literal">gulp</code> file:</p><div class="informalexample"><pre class="programlisting">gulp.task('palette', function () {
  return gulp.src('src/*.css')
  .pipe(postcss([ autoprefixer, palette({ palette: 'mrmrs' }), colormix() ]))
  .pipe(gulp.dest('dest/'));
});</pre></div><p>Notice that we've specified a palette to use, the <code class="literal">mrmrs</code> option is the default, but we can equally use <code class="literal">material</code> or <code class="literal">flatui</code> as alternatives. All three reference the <code class="literal">webcolors</code> plugin from <a class="ulink" href="https://github.com/zaim/webcolors/">https://github.com/zaim/webcolors/</a>; this package could be expanded to include other palettes if desired.</p><p>With the links to our two plugins in place, and the task set up, we can then begin to specify rules within our style sheet, which will use the plugins. We've created three, and all three use the <code class="literal">postcss-color-palette</code> to determine what the HEX value should be for each color; the third and <a id="id271" class="indexterm"/>final mixes the two colors together once HEX values have been assigned:</p><div class="informalexample"><pre class="programlisting">#box0 { background: linear-gradient(aqua, blue 50%, purple); }

#box1 { background: linear-gradient(to right, orange, red, yellow); }

#box2 { background: mix(teal, navy, 80%); }</pre></div><p>Getting the mix of the color right for the third rule isn't easy, the key to a successful mix is to avoid using colors that are in the same spectrum; the closer they are, the less impact the mix will have!</p><p>If you want a quick way to gauge how well colors have mixed, then try <a class="ulink" href="http://jackiebalzer.com/color">http://jackiebalzer.com/color</a>—this demo has a <code class="literal">mix()</code> option in it, which will compile them in the browser and avoid the need to run the compilation process manually.</p><p>We've covered some of the plugins that are likely to be more popular; there are more available via the <code class="literal">PostCSS.parts</code> directory, which may be of interest:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">colorguard</code>: Helps maintain a consistent color palette</li><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-ase-colors</code>: Replaces color names with values read from an ASE palette file; this is perfect if you happen to be a user of Adobe PhotoShop, InDesign, or Illustrator</li><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-shades-of-gray</code>: Helps keep grayscale colors consistent to a gray palette</li><li class="listitem" style="list-style-type: disc"><code class="literal">postcss-color-pantone</code>: Transforms Pantone color to RGB.</li></ul></div><p>In the meantime, let's move on: we've explored using palettes to select our colors, before mixing them to create new ones. This is just scratching the surface of what is possible; how about creating different <span class="emphasis"><em>shades</em></span> of colors, using functions such as <code class="literal">darken()</code>, <code class="literal">tint()</code> or <code class="literal">lightness()</code>? Such functions already exist in most preprocessors, such as SASS; let's explore how we can achieve the same results using PostCSS plugins.</p></div></div>
<div class="section" title="Creating color functions with PostCSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Creating color functions with PostCSS</h1></div></div></div><p>In our journey <a id="id272" class="indexterm"/>through manipulating colors using PostCSS, we've so far seen how to define colors using palettes—this may work in some instances, but there will be occasions when we need to specify a color that doesn't feature in a palette.</p><p>We can always try to specify the value manually, but what happens if we need to alter it? Do we try to find every instance of it, and risk the possibility of missing an instance?</p><p>The answer is no. Instead, we can use the <code class="literal">postcss-color-function</code> plugin to create our colors dynamically; we can then assign the resulting value to a variable if we find ourselves frequently using this <a id="id273" class="indexterm"/>color. We can use this route to produce some nice shades of colors, so let's get stuck in and explore using this plugin in more detail.</p><div class="section" title="Adjusting colors using functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Adjusting colors using functions</h2></div></div></div><p>A useful facility within <a id="id274" class="indexterm"/>most CSS preprocessors is the ability to create new colors dynamically, we can do this either by adjusting a color channel, or applying a filter effect to the color, such as making it darker:</p><div class="mediaobject"><img src="graphics/BO5194_05_16.jpg" alt="Adjusting colors using functions"/></div><p>The benefit of this is simple, it allows us to reduce the number of base colors we assign by default; the remaining colors can be created automatically. If we need to change one of our base colors, then any colors created dynamically should still work.</p><p>Thankfully, we can achieve the same effects within PostCSS, to do this, we need to make use of the <code class="literal">postcss-color-function</code> plugin, available from <a class="ulink" href="https://github.com/postcss/postcss-color-function">https://github.com/postcss/postcss-color-function</a>. We'll also be using the <code class="literal">css-color-converter</code> plugin, to help manage conversion between different color formats.</p><p>Let's explore this in more detail with a simple demo:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by extracting a copy of the <code class="literal">Tutorial25</code> folder from within the code download that accompanies this book—go ahead and save this to our project area.</li><li class="listitem">If the project area already has a <code class="literal">package.json</code> and/or a <code class="literal">gulpfile.js</code> present, then remove them; replace them with the files from within the <code class="literal">Tutorial25</code> folder.</li><li class="listitem">Although we have the right configuration files in place, we still need to install the plugin—go ahead and fire up a Node.js command prompt session, then change the working folder to our project area.</li><li class="listitem">At the prompt, enter these commands, pressing <span class="emphasis"><em>Enter</em></span> after each:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-color-function --save-dev</strong></span>
<span class="strong"><strong>npm install css-color-converter --save-dev</strong></span>
</pre></div></li><li class="listitem">At this point, we can now go ahead and compile our style sheet—look for <code class="literal">styles – pre-compile.css</code> from within the <code class="literal">css – completed version</code> subfolder, and save it to the <code class="literal">src</code> folder within our project area as <code class="literal">style.css</code>.</li><li class="listitem">Switch to the <a id="id275" class="indexterm"/>Node.js command prompt from earlier, then enter <code class="literal">gulp</code> at the prompt and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should see the by now compiled style sheets appear (both uncompressed and minified), along with the source map in the <code class="literal">dest</code> folder. Copy the contents of this folder to the <code class="literal">css</code> folder within the <code class="literal">Tutorial25</code> folder.</li></ol></div><p>Try previewing the results within a browser, if the compilation was successful, we should see four boxes with different shades of red appear, as shown at the start of this exercise. The question is though, we've seen the results appear, but how does PostCSS know to create these colors?</p></div><div class="section" title="Dissecting our demo"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Dissecting our demo</h2></div></div></div><p>It's a good question, the <a id="id276" class="indexterm"/>conversion process is very simple; the trick to it, though, lies not within compiling, but working out how to achieve the color! Odd as it may seem, choosing the color isn't as easy as it looks; let me explain more:</p><p>The compilation process is, like other PostCSS plugins, very easy to configure—we begin of course with creating a variable that defines the <code class="literal">color-function</code> plugin:</p><div class="informalexample"><pre class="programlisting">var colorfunction = require('postcss-color-function');</pre></div><p>Next up, we add a reference to our principal gulp task, here we've used both <code class="literal">autoprefixer</code> and the <code class="literal">color-function</code> plugin together, but the former isn't strictly needed, as we're not adding any vendor prefixes:</p><div class="informalexample"><pre class="programlisting">gulp.task('autoprefixer', function() {
  return gulp.src('src/*.css')
    .pipe(postcss([  autoprefixer, colorfunction() ]))
    .pipe(gulp.dest('dest/'));
});</pre></div><p>The real magic, though, is in the colors we assign within our style sheet—our first box is a control, with a standard red color:</p><div class="informalexample"><pre class="programlisting">#box0 { background-color: #ff0000; }</pre></div><p>Next up, we're adding a <code class="literal">tint</code> of <code class="literal">60%</code> to <code class="literal">box1</code>, which has the effect of turning it a light pink:</p><div class="informalexample"><pre class="programlisting">#box1 { background-color: color(red tint(60%)); }</pre></div><p>
<code class="literal">Box2</code> goes the other way, even though we've used a lightness filter (where you might expect a similar result as <code class="literal">box1</code>), the negative number makes it a brown-red color:</p><div class="informalexample"><pre class="programlisting">#box2 { background-color: color(red lightness(-20%)); }</pre></div><p>The final box, <code class="literal">box3</code>, continues the brown theme from <code class="literal">box2</code>, but makes it lighter. Note though, that in the comment, this shade is what would be produced if we had applied a sepia tone:</p><div class="informalexample"><pre class="programlisting">#box3 { background-color: sepia(red, 0.7);}</pre></div><p>The question is, how would <a id="id277" class="indexterm"/>we know that this is indeed a sepia filter being applied?</p><p>At face value, it looks like we've selected red, then altered each channel by a specific amount to get the final result.</p><p>A drawback of using this plugin is that it doesn't have functions to support all of the equivalent CSS3 filters available today; it does mean we have to be resourceful, and calculate what the color should be directly. We will be able to change that in the next demo—there will be occasions when we need to create our own custom filters; a good example is sepia. It does mean more work upfront, but it allows us to then call a <code class="literal">sepia()</code> function by name, rather than approximate the final result.</p><p>If you struggle to find what a color should be once a filter is applied, take a look at <a class="ulink" href="http://jackiebalzer.com/color">http://jackiebalzer.com/color</a>; this is a great site that allows us to choose a color and see what the results are when filters are applied. It is written for SASS, but the end result will be identical for PostCSS. A site such as ColorHexa.com (<a class="ulink" href="http://www.colorhexa.com">http://www.colorhexa.com</a>) is a good help too, we can use it to verify what color values should be when a filter has been applied.</p><p>On we go. We discovered during our exercise that the <code class="literal">postcss-color-function</code> plugin doesn't cover all of the CSS3 filters that we can use in CSS; for the <code class="literal">sepia</code> example, we had to assign a calculated color value, rather than applying a filter effect. Let's fix that now. With a bit of upfront rework to our demo, we can create our own custom functions. It means that if, for example, we want a sepia effect, then we can call <code class="literal">sepia()</code>, rather than calculate what the final color should be!</p></div><div class="section" title="Creating colors with PostCSS filters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Creating colors with PostCSS filters</h2></div></div></div><p>In our <a id="id278" class="indexterm"/>previous demo, we took a look at programmatically changing colors—this is a function that has been present in most CSS processors (such as SASS or Less) for some time.</p><p>There may be occasions <a id="id279" class="indexterm"/>where we require a finer degree of control over changing colors, and that simply using existing functions provided by the <code class="literal">postcss-color-function</code> plugin isn't sufficient, or that the desired filter isn't available. If we're feeling inclined, we can create our own color functions; for this, we can use the <code class="literal">postcss-functions</code> plugin, available from <a class="ulink" href="https://github.com/andyjansson/postcss-functions">https://github.com/andyjansson/postcss-functions</a>, to expose the use of JavaScript functions in our task file.</p><p>It's worth noting, though, that if a CSS3 filter doesn't exist, then most can be created using a combination of different calculations (such as the <code class="literal">sepia</code> example from the previous demo). This may technically work okay, but it is easier to simply reference a sepia filter by name, rather than work out that <code class="literal">#box3</code> has a sepia effect applied!</p><p>I feel a demo coming on, so without further ado, here's a screenshot of what we're going to create:</p><div class="mediaobject"><img src="graphics/BO5194_05_17.jpg" alt="Creating colors with PostCSS filters"/></div><p>In short, we're using a standard shade of red (<code class="literal">#ff0000</code>, just to be clear!), and calculating various shades using a tint, darken, or sepia filter.</p><p>Let's take a look at how to create these colors in more detail:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by extracting a copy of the <code class="literal">Tutorial26</code> folder from the code download that accompanies this book; save it to the root of our project area.</li><li class="listitem">Next, go ahead and remove any copies of <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> from the root of our project area.</li><li class="listitem">From the <code class="literal">Tutorial26</code> folder, copy both <code class="literal">package.json</code> and <code class="literal">gulpfile.js</code> to the root of our project area.</li><li class="listitem">With these files in place, we still need to install the plugins. In a Node.js command prompt window, change the working folder to our project, then enter these commands, and press <span class="emphasis"><em>Enter</em></span> after each:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-functions --save-dev</strong></span>
<span class="strong"><strong>npm install css-color-converter --save-dev</strong></span>
</pre></div></li><li class="listitem">From the <code class="literal">Tutorial26</code> folder, copy <code class="literal">style – pre-compile.css</code> to the <code class="literal">src</code> folder in the project area; rename it to <code class="literal">style.css</code>.</li><li class="listitem">Revert back to the Node.js command prompt window, then at the prompt, enter <code class="literal">gulp</code> and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">If all is well, we should see a source map and two compiled style sheets appear in the <code class="literal">dest</code> folder; copy these to the <code class="literal">css</code> folder within the <code class="literal">Tutorial26</code> folder.</li><li class="listitem">Try running <a id="id280" class="indexterm"/>the demo in a browser. If all is well, we should see four boxes appear, with various shades of red, as shown at the start of this exercise.</li></ol></div><p>If we take a look at the <a id="id281" class="indexterm"/>contents of the <code class="literal">gulp</code> task file in more detail, it will look larger than previous exercises; it might look like we're doing more, but in reality, a lot of it we've already seen before, in earlier demos. Let's take a look at it in more detail.</p><div class="section" title="Exploring our demo in more detail"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec01"/>Exploring our demo in more detail</h3></div></div></div><p>If we open up our <a id="id282" class="indexterm"/>gulp task file, we can see it contains a number of functions, along with tasks that we've used in previous demos, such as <code class="literal">lint-styles</code>. The key in this demo is the three color functions, along with the main part of the <code class="literal">autoprefixer</code> task.</p><p>Let's start with the <code class="literal">color</code> functions, using <code class="literal">darkenColor</code> as our example:</p><div class="informalexample"><pre class="programlisting">function darkenColor (value, frac) {
  var darken = 1 - parseFloat(frac);
  var rgba = color(value).toRgbaArray();
  var r = rgba[0] * darken;
  var g = rgba[1] * darken;
  var b = rgba[2] * darken;
  return color([r,g,b]).toHexString();
}</pre></div><p>We begin by extracting the decimal value, then subtracting it (as <code class="literal">frac</code>) from <code class="literal">1</code>. This gives us our adjust value, or the value by how much we will darken our colors. Next up, we convert the color used (in this case, red) to a valid RGBA value, and split it into the RGBA array. We then multiply each array value from <code class="literal">rgba</code> by the darken value, and reform it as a valid color, before converting it to a HEX value.</p><p>Once each function has been created, we can then reference it from our gulp task, as shown:</p><div class="informalexample"><pre class="programlisting">gulp.task('autoprefixer', function() {
  return gulp.src('src/*.css')
  .pipe(postcss([  autoprefixer, functions({
    functions: {
      tint: tintColor,
      darken: darkenColor,
      sepia: sepiaColor
    }
  })
  ]))
  .pipe(gulp.dest('dest/'));
});</pre></div><p>All of the functions use a similar process, but the main calculations that use the values from the <code class="literal">rgba[]</code> array, such as adding a tint (<code class="literal">tintColor</code>), or working in a sepia effect (<code class="literal">sepiaColor</code>), will be different.</p><p>The question you may ask <a id="id283" class="indexterm"/>though, is where do we get the calculations from? Well, there are plenty of sources available on the Internet, such as this link on Stack Overflow: <a class="ulink" href="http://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade">http://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade</a>. Another alternative that may be worth a look is on Chris Coyier's CSS Tricks site, at <a class="ulink" href="https://css-tricks.com/snippets/javascript/lighten-darken-color/">https://css-tricks.com/snippets/javascript/lighten-darken-color/</a>. In reality though, the best site I've seen so far is in the CamanJS library, at <a class="ulink" href="http://www.camanjs.com">http://www.camanjs.com</a>; the examples in this demo are based on the functions available from this library at <a class="ulink" href="http://camanjs.com/docs/filters.html">http://camanjs.com/docs/filters.html</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>A useful little tip, if you want to check what color values should be displayed for a particular tint or shade, is to check out <a class="ulink" href="http://highintegritydesign.com/tools/tinter-shader/">http://highintegritydesign.com/tools/tinter-shader/</a>.</p></div></div></div><div class="section" title="Comparing with CSS3 filters"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Comparing with CSS3 filters</h3></div></div></div><p>A key question we <a id="id284" class="indexterm"/>must ask at this stage is "why should we go through the effort of creating individual functions, when we could easily use a library such as CamanJS?"</p><p>Well, there are some key <a id="id285" class="indexterm"/>reasons for taking the route that we used in our demo:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CamanJS is a great library, and produces some wonderful effects, but it is an external dependency; we run the risk that development may be discontinued in the future, which might have an impact on our code.</li><li class="listitem" style="list-style-type: disc">Using PostCSS means that we can remove the dependency on external libraries, we are in control over which effects should be included, and which are surplus to requirements. If we use a library such as <code class="literal">CamanJS</code>, then we may be forced to include lots of extra baggage that unnecessarily inflates our code.</li><li class="listitem" style="list-style-type: disc">Not every browser will support standard CSS3 filters—using PostCSS gives us an opportunity to design our own filters that can apply similar effects.</li><li class="listitem" style="list-style-type: disc">We can always use existing processors, such as SASS, but again we have a dependency on an external library; using PostCSS means we can still apply the same principles, but without the dependency.</li></ul></div><p>The key here, though, is <a id="id286" class="indexterm"/>that filter support in browsers is very good, save <a id="id287" class="indexterm"/>for IE—we should always consider using CSS3 filters first, but can look to create an IE-specific style sheet that allows us to use our own versions from within PostCSS.</p></div></div><div class="section" title="Adding Instagram effects to your images"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec54"/>Adding Instagram effects to your images</h2></div></div></div><p>Creating filters with <a id="id288" class="indexterm"/>PostCSS shouldn't be all boring though, we <a id="id289" class="indexterm"/>can absolutely have some fun with filters! A quick and easy way to apply some additional style to an image is through the use of Instagram filters—thankfully there is a pre-built plugin we can use for this purpose.</p><p>Enter the <code class="literal">Instagram</code> plugin, available from <a class="ulink" href="https://github.com/azat-io/postcss-instagram">https://github.com/azat-io/postcss-instagram</a>. Let's get stuck in and create a simple demo:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll begin, as always, by extracting a copy of the <code class="literal">Tutorial27</code> folder from the code download that accompanies this book—save this to the project area.</li><li class="listitem">Next, extract copies of <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code>, replace any that are stored at the root of our project area, with these new copies.</li><li class="listitem">We now need to install the <code class="literal">postcss-instagram</code> plugin, so go ahead and fire up a Node.js command prompt session, then change the working folder to our project area.</li><li class="listitem">At the prompt, go ahead and enter this command, then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-instagram --save-dev</strong></span>
</pre></div></li><li class="listitem">Copy the <code class="literal">style – pre-compile.css</code> file to the <code class="literal">src</code> folder at the root of our project area, then rename it as <code class="literal">style.css</code>.</li><li class="listitem">Once the plugin is installed, enter <code class="literal">gulp</code> at the prompt, then press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">PostCSS will go away and compile our code, if all is well, we should see the usual files appear in the <code class="literal">dest</code> folder; copy these to the <code class="literal">css</code> folder within the <code class="literal">Tutorial27</code> folder.</li></ol></div><p>At this point, if we try to preview the results in a browser, we should see something akin to this screenshot:</p><div class="mediaobject"><img src="graphics/BO5194_05_18.jpg" alt="Adding Instagram effects to your images"/></div><p>The key to this is <a id="id290" class="indexterm"/>in the main CSS style sheet, we can apply the <a id="id291" class="indexterm"/>required filter using nothing more than this within the rule:</p><div class="mediaobject"><img src="graphics/BO5194_05_19.jpg" alt="Adding Instagram effects to your images"/></div><p>This applies the <code class="literal">1977</code> filter (one of the filters available with the plugin). If we take a look at the compiled code, we can see that the plugin has added some additional rules; one to take care of creating the filter, and two to take care of positioning the filter on top of the image.</p><p>If we take a look at the compiled code, we can see the changes made by the plugin:</p><div class="mediaobject"><img src="graphics/BO5194_05_20.jpg" alt="Adding Instagram effects to your images"/></div><p>If you really want to get into the depths, then it's worth taking a look at the source code for this plugin, at <a class="ulink" href="https://github.com/azat-io/postcss-instagram/blob/master/index.js">https://github.com/azat-io/postcss-instagram/blob/master/index.js</a>. It is fairly complex, but if you look carefully, you can see signs of the filter <a id="id292" class="indexterm"/>code that is used to <a id="id293" class="indexterm"/>apply the effect to our images.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Summary</h1></div></div></div><p>Manipulating images and color can either be very rewarding, or somewhat daunting, depending on how simple or complicated we make our processes! Fortunately, PostCSS can help automate a fair degree of our processes, so let's take a moment to consider what we've covered throughout this chapter.</p><p>We kicked off with a look at adding media assets, and using PostCSS to automatically update asset links, this helps remove any risk that we inadvertently use the wrong link!</p><p>We then moved on to manipulating images, we started with a look at creating image sprites, first using SASS, before transitioning to using PostCSS. Next up came a more in-depth look at altering images, where we used the <code class="literal">Evil Icons</code> SVG library and set up PostCSS to alter the color of each icon at compilation. We then moved on to learn about how we can switch in the WebP image format; while most people might use standard format images, we learned how easy it is to switch-in WebP images, when using a supported browser.</p><p>Moving on, we then turned our attention to manipulating colors through the use of specific palettes, we covered how you can use PostCSS to compile in human-readable color names, and then mix or manipulate them within our style sheet. We then amped things up a little, with a look at using PostCSS to apply specific color filters, to alter color levels in a chosen color. We then explored some of the disadvantages of using standard plugins, and why we might need to create our own custom filters, that can be applied during compilation of our code. We then rounded out the chapter with a quick look at using some fun Instagram filters, where we can easily see how multiple filters are put together to manipulate images within our site.</p><p>Wow, we've certainly covered a lot of content! But our journey doesn't stop there: in the next chapter, we'll take a look at creating grids, which we can then use to construct layouts within our projects.</p></div></body></html>