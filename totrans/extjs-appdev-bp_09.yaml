- en: Chapter 9. A Shopping Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll design one last application from start to finish. Rather
    than continuing to introduce new ideas or techniques to visualize and construct
    an application architecture, we'll double up on the work we've done so far. We'll
    incorporate routes, view models, and events in order to consolidate everything
    that's been discussed, and we'll create design documentation to inform the application's
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: In each chapter of this book so far, I've tried to stress that there's no "one
    true way" to application architecture. Every application is different; there is
    plenty of room for interpretation. At the beginning of the book, we discussed
    the MVC and MVVM design patterns and what an architect must find is their own
    pattern (a way of working that feels natural). More than this, a pattern is something
    that emerges because of a regularity in our work, that is, repeating the same
    thing again and again. While different architects will have different ways of
    working and can use different methods in different ways, in the practical chapters,
    we've completed there is a logical development path that it's easy to fall into.
  prefs: []
  type: TYPE_NORMAL
- en: '"Falling into the pit of success" is a phrase used to describe a methodology
    that works well without users having to try hard to follow it. That''s what we''ve
    been working towards. Showing you the choices Ext JS provides, not only giving
    you options, but also trying to illustrate why they''re good options to use. By
    now, you should have a picture of the design of an Ext JS application and the
    features you can use to fulfill this design.'
  prefs: []
  type: TYPE_NORMAL
- en: In this final practical chapter, we'll once again see how, despite having a
    choice in how to implement this application, we'll end up selecting a a path that's
    similar to the one we took before, a path that feels logical and that makes development
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: About the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application we''ll build is designed to shop on a tablet-sized screen.
    We''ll be taking advantage of the burgeoning "craft beer" scene and creating an
    application that allows customers to select from categorized beers in the store.
    Here''s the full feature list:'
  prefs: []
  type: TYPE_NORMAL
- en: Login and register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product list with sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch-friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, the standard set of features you''d see on a straightforward
    e-commerce website. The final product looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About the app](img/5308OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a simple interface that provides large tappable areas for tablet users.
    There are more screens in this application than any other we''ve worked on so
    far, so let''s sketch these out and see what the full app will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About the app](img/5308OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have the wireframe of the first screen that the user sees when opening
    the site. As you can see, it maps out the features and layout, as shown in the
    previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: This mockup mentions all of the main features of the application. Note that,
    unlike in our earlier e-mail application, the user doesn't have to log in to start
    browsing. This only happens when they want to place an order.
  prefs: []
  type: TYPE_NORMAL
- en: The categories of beer are listed on the left-hand side in alphabetical order;
    the user can scroll through the list when it extends past the bottom of their
    screen. In the main part of the screen, the beers in the selected category are
    listed with the sort order determined by a combo box above the list. Each beer
    on sale is represented by its name, an image, and its price.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the top-right corner of the screen, we have the "login" and "cart
    buttons" that will change to reflect the application state and are both clickable,
    revealing further windows.
  prefs: []
  type: TYPE_NORMAL
- en: The product window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This next screen shows the product detail page when the user selects a product
    to view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The product window](img/5308OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screen fleshes out more of our requirements and the way they'll be implemented.
    When the user clicks on a product from the list, a modal window pops up showing
    more information about the product in question, such as a discount message showing
    price reduction, a full description, the brewery that made the beer, and a tagline
    that sells beer to the customer. This is all accompanied by a larger image of
    the product as well as buttons to add the beer to the shopping cart and to close
    the product window.
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the top-right corner of the main app screen, we can see a shopping cart
    icon and a label that changes to reflect the number of items in the cart. When
    the user clicks on the icon or label, the cart window is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The shopping cart](img/5308OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This modal window contains a list of products in the cart and the quantity of
    each item. The user can adjust the quantities of each item here as well by clicking
    on or tapping the plus or minus icons. The other key feature of this window is
    the **Order Now** button, which processes the current cart into an order.
  prefs: []
  type: TYPE_NORMAL
- en: If the user hasn't already logged in, clicking on this button will show the
    login and registration screen, which we'll look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Login and registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Login** and **Register** options are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Login and registration](img/5308OT_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The login and registration forms are shown side-by-side because they're simple
    enough to fit in the same window. The fields will have validation in order to
    ensure e-mails are correctly formatted and required fields are completed. When
    the registration or login process is completed, the **Login** icon on the main
    screen will be replaced by the user's e-mail address; clicking on this link will
    show an account screen.
  prefs: []
  type: TYPE_NORMAL
- en: User account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The user account page allows the user to edit their details and view their
    past orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User account](img/5308OT_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The text fields on the left-hand side allow the user to amend their address
    and user credentials, and the pane on the right-hand side is a list of previous
    orders, showing the items that were ordered, the date, and the total amount.
  prefs: []
  type: TYPE_NORMAL
- en: Design overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at all of the main application views in turn; for simplicity, we've
    excluded an actual payment process to avoid integrating with a third-party service.
    When the user proceeds with an order, it will immediately be processed and added
    as a past order in their account.
  prefs: []
  type: TYPE_NORMAL
- en: One great thing about Ext JS 5 is that it adds support for touch devices and
    includes a touch-friendly theme. This should make it super simple to achieve our
    goal of presenting this app to tablet users; however, we'll include some theming
    tweaks to create a custom look and improve the experience for users on tablet
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Ext JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we now know that Ext JS can help with the creation of a touch-friendly
    interface, does our design suggest any other ideas that Ext JS might not be able
    to cope with? Remember that the design phase is an exploration of what works for
    the user and what is possible with the technology at hand. Let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: The scrolling product category list can be a `Ext.grid.Panel` class with most
    features, such as headers, disabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scrolling product list can be an `Ext.view.View` class (also known as a
    DataView), as we need to include custom HTML for each product to display an image
    and other details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product list sorting will be achieved via a combo box containing the sort criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than this, we just need modal windows (which Ext JS supports), another
    grid for the shopping cart, a few form fields for the login and registration.
    We're pretty much there.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we'll use routing to provide the ability to bookmark categories
    or products, which allows the user to share links. We'll also use view models
    and events to wire everything together. The data will again be drawn from a server-side
    API, so let's look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: The data layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The shopping application needs to be supplied with the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of products, filtered by category and sorted by the selected criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details of a single product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes things pretty straightforward. So, in a moment, we'll break down
    exactly what sort of data responses we'll see when we make a server request.
  prefs: []
  type: TYPE_NORMAL
- en: Before this, you might notice that we're skipping over the part of the application
    that will integrate with the server-side. The key reason for this is that it will
    add complexity to our example application without adding much more value; we want
    to highlight the decisions that we made in order to piece together this application
    and do it in a concise and understandable way. While there are many features we
    can add to this application and indeed our previous examples, we want to make
    sure that the really important aspects of building an application can shine through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the data that we''d like our backend to supply. Firstly,
    retrieving a list of categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It accepts no parameters and returns a JSON array containing the ID and name
    of each available category. To see the products in a category, we talk to the
    products API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It returns an array of objects, each containing the properties needed to render
    a product list item. The array can be filtered by passing a sort query parameter
    with a JSON array of fields to sort against, and we fetch only the category of
    products we need by passing a `filter` query parameter with a JSON array. This
    array contains one object to filter the `categoryId` property. This JSON filter
    and sort approach is one we've used in the past and it fits well with the way
    Ext JS works on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the request for the details of a single product as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It does not accept any query parameters per se. Instead, the ID is passed as
    part of the URL path, as it's more often seen in a RESTful API. The full JSON
    response is omitted for brevity, but it returns the full set of fields required
    to populate the product window.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gathered this information, we can start to think about how it
    will shape our data classes.
  prefs: []
  type: TYPE_NORMAL
- en: Information contemplation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the API we''ve just described, we have two main models and their associated
    stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These will have accompanying stores that do nothing more than wrap their model.
    In addition to the classes that interact with the API, we''ll have a couple more
    to deal with some other moving parts in the application. Firstly, we''ll look
    at the various items in the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An alternative to this design will be to hold only `productId` and `quantity`
    and look up the product details from the product store at render time. However,
    the method we've chosen makes the resulting code simpler and it also allows you
    to store data such as the price at the time the user adds it to the cart. This
    can be handy in complex or busy sites if the product price changes after the user
    adds it to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we have a model to hold an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be used to represent a shopping cart that has been converted to an
    order. While this class will be consumed by a simple wrapper store, `CartItem`
    will have a store that does a little bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `addProduct` method can be passed to a product model that is to be added
    to the cart. It adds a bit of logic to detect whether a matching product already
    exists in the cart; if it does, it increments the quantity rather than creating
    a new cart item.
  prefs: []
  type: TYPE_NORMAL
- en: The `toOrder` method converts the cart and all its items to an `Order` model,
    which can then be saved to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The API for this project is simple, but we'll also use models and stores to
    organize our data and application state in memory, favoring the `Ext.data` classes
    over standard JavaScript objects in order to leverage their powerful features.
    With the data design pretty much complete, we can move on to see how this data
    will interact with the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Component interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Ext JS 4, we have the MVC pattern to build and clean well-structured applications.
    Looking back at our past few practical chapters, though, it seems difficult to
    imagine going back to MVC from the MVVM architecture that Ext JS gives us because,
    in each example, we've used view models to great effect to provide a logical way
    for data to flow through our application.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing about these examples is how little code we write in many
    situations. Analyzing the application requirements and spiking a few tricky areas
    leads to writing a small amount of configuration of UI, controllers, view models,
    and so on. Ext JS automatically builds the plumbing through which our data can
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: It's another example of why application architecture is so important, particularly
    when combined with a strong understanding of the tools at hand. It would be very
    easy for a naïve developer to jump in and start writing code to manually handle
    movement of data from an API through to the user interface using `Ext.Ajax` rather
    than models and proxies and manually loading data into components. However, by
    taking a patient and methodical approach, we can build a conceptual overview of
    the application that easily slots into the framework provided by Ext JS. By thinking
    about things upfront, we're making our lives much simpler for later use.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, let's think about the controllers and views we'll need in this
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's the purpose of a controller? As you learned in [Chapter 2](ch02.html
    "Chapter 2. MVC and MVVM"), *MVC and MVVM*, it's to act as the glue between other
    parts of the application, and in the majority of cases, this is manifested in
    code that handles events. From UI clicks to routing events, the controller consumes
    them and passes off the real work to another class.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does this mean for the way we think about architecture? It means that
    any action or event in the application will likely need an associated controller.
    If these actions can be bundled into a distinct grouping, then this could be an
    indication they warrant their own controller. With this in mind, let''s look at
    our shopping application again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![In control](img/5308OT_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What elements of the page could raise an event? A click on a category in the
    blue left-hand pane, so alongside the category list view, we''ll have a category
    view controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on a product in the product list is an action we need to handle, so
    we''ll have a product list view and a product view controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, the two icons at the top-right corner of the window need to trigger
    UI changes, so they need a view controller. Do we want a "header" controller to
    handle the events from the cart and account icons or can we use a "main" controller?
    It''s one of these things that can boil down to a matter of preference; here,
    we''ll use the main controller just to keep the number of classes from getting
    out of hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's look back at our other UI wireframes. There are three remaining UI components
    and they're all modal windows. Firstly, the product detail window (interactions
    with this will be handled by the product controller that we've already identified).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the shopping cart window, which will be paired with a controller that
    handles the user''s interactions with the various buttons on the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the account window with its account view controller to handle login
    and registration is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's a final place that will raise events that our application will need
    to handle. The requirements for this project stipulate that we implement routing
    to allow product pages to be shared via e-mail or social media. To meet this need,
    we'll have a controller specify the routes' definitions and matching handlers.
    The exact controller to take this role will depend on the nature of the route
    definitions, for example, if it's a route related to products, then the product
    controller will handle it. You can see a few of these route handling methods dotted
    around the controller designs in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping actions and events in this way will often make the choice of which
    controllers to build an easy one, particularly when used in association with wireframes
    that allow you to look at the corresponding UI views.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of view models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve discussed view models and application architecture using the word "flow"
    several times. As the user manipulates various parts of the user interface, data
    flows through controllers and view models to represent the current state of the
    application. Rather than writing out a list of all of the junctions through which
    data can flow in this application, let''s try and picture it instead as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The simplicity of view models](img/5308OT_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interactions between the cart store on the main view model and its dependents
  prefs: []
  type: TYPE_NORMAL
- en: Being able to conceptualize your application at this level is a good sign that
    it is well-understood and well-conceived. In larger applications, it will be hard
    to visualize every part of the application in this way, so it will often be broken
    into multiple smaller visualizations. Either way, building a top-level mapping
    of data and user flow is a fantastic way to confirm the logic and simplicity of
    a design.
  prefs: []
  type: TYPE_NORMAL
- en: Code, code, and more code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to get our hands dirty and put fingers to keyboards. As always,
    we generated a new base application using Sencha Cmd and will use the resulting
    "main" view as a starting point for our user interface. First though, let''s flesh
    out the data layer that we designed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used a base model in previous chapters because it gives us a good way
    of centralizing proxy configuration. The models that inherit from it are all straightforward,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Looking back at our design, these models exactly follow the specification we
    laid out. All we've really done is add the Ext JS implementation on top of the
    original field definitions.
  prefs: []
  type: TYPE_NORMAL
- en: What's in store?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we know, stores are often just wrappers to give us a few more helpful methods
    to work with a collection of models. Looking back at our design documents, this
    is the case for three of the stores in this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All very straightforward. The cart store is a bit more interesting, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Many of the stores we've built in past chapters have been used to store information
    that has been fetched from the server. Here, we're using the store as an in-memory
    representation of the shopping cart itself; we're adding a couple of custom methods
    to help with this function.
  prefs: []
  type: TYPE_NORMAL
- en: The `addProduct` method will add the specified product to the store by converting
    it to a `CartItem` model. If a product with the same ID already exists as an item
    in the cart, it will have its quantity increased by one rather than being duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: The `toOrder` method converts the whole cart to an `Order` model, which is used
    later in the application to show past orders in the user's account.
  prefs: []
  type: TYPE_NORMAL
- en: These methods are interesting because they demonstrate a place where we're not
    writing glue code or code that handles events. It's the code that deals with the
    really interesting parts of an application, sometimes called "business logic".
    One of the benefits of developing a strong architecture with strong development
    practices is that you will have less boilerplate code and more time to work on
    the business logic that's important to your client.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](ch11.html "Chapter 11. Application Testing"), *Application Testing*,
    we'll look at ways to isolate this business logic and create automated tests that
    give you confidence in your code base.
  prefs: []
  type: TYPE_NORMAL
- en: That's our data layer in place, so we can move on to building the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interface in your face
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Ext JS application created with Sencha Cmd will set up the main view as
    a viewport filling the entire browser window. We''ll use this view and adapt it
    to our needs, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we are! Our first view component, the panel that will contain everything
    else in the application. The `header` config is set to a custom `xtype` that we'll
    build later. The items in the panel are configured to use a border layout and
    consist of the category list and the product list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one oddity here: adding windows to a panel within the `initComponent`
    method. This provides two benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The main view controller can refer to the windows using `lookupReference`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The windows will have access to the main view model via the view model inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a simple approach that solves an obvious sounding issue, that is, where
    do I create my windows? It doesn't feel "right" to put them in the `items` config
    with the product and category list, although we certainly can without any ill
    effect. Another common solution is to instantiate the window in the view controller
    itself, but as the window then isn't a child of the main view, this leads to issue
    with the view model inheritance. Creating the windows in the `initComponent` method
    feels like a natural way to bypass this problem.
  prefs: []
  type: TYPE_NORMAL
- en: One step ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We decided earlier that the main view controller will also handle events from
    the header, so let''s look at the header view next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our custom header component inherits from `Ext.panel.Header` and implements
    an `hbox` layout. The two items contained within are also custom classes, one
    for the cart icon and one for the account icon. These are configured to bind to
    `currentUser` and `cartCount` respectively, which are values in the main view
    model that we'll look at later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cart icon is called `MiniCart` and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `header` component, we specified that the `data` config for `MiniCart`
    should be an object with a `count` value. This `count` value will be bound to
    a `cartCount` value in the view model. In turn, we now use this `count` value
    in the template, which allows you to have an icon that updates with the count
    of items in the cart.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of other things to note here. We're using the `FontAwesome`
    icon set to add a bit of graphical flair to the cart; you can see it being used
    in a `span` tag in the `tpl` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FontAwesome` can be found at [http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second point to note is that this class inherits from `Alcohology.ux.ClickContainer`.
    What''s this? Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A normal container doesn't have a `click` event, so this `ClickContainer` hooks
    into the underlying element that allows you to handle user interaction with the
    container. This is handy if you don't need button styling and would like a bare-bones
    clickable component.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This feature can also be implemented as a mixin rather than a base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The account indicator also extends `ClickContainer` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our favorite trick of binding to a custom configuration option is again used
    here with a little twist. If the value of a user being bound is `null`, that is,
    if the user has yet to log in, we use the default value of the `data` config to
    set a label on this component. If they have logged in, we set the label to their
    e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the `tpl` configuration that we're using `FontAwesome` again.
    It's also the place we use the label that has a default value of `login`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to the code that handles the user's interactions with these components.
  prefs: []
  type: TYPE_NORMAL
- en: Under the main control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main controller is not only the place that handles user clicks and taps,
    but the place that defines some relevant routes. It even handles a custom event.
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a very handy technique demonstrated here: the `click` handlers for
    `account-indicator` and `minicart` both simply redirect to their relevant routes.
    This means that we can put the logic to show the account and cart windows in `onAccountRoute`
    and `onCartRoute` route handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: The other piece of functionality implemented in this view controller is the
    listener on the controller domain. It listens for any controller firing the `loginrequired`
    event and handles it with the `onLoginRequired` method. Within `onLoginRequired`,
    we pop up a brief note to the user via the `Ext.toast` feature and simply redirect
    them to the `login/registration` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'This enables any controller or view controller to request the user to log in
    without having to be explicitly aware of the implementation of the account system.
    Let''s take a look at the view model for the main viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This top-level view model provides the stores for past orders and the shopping
    cart as well as a property giving us the number of items in the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the default in Ext JS, we have to manually listen to the `datachanged`
    event on the cart store in order to get a "live" count of items because a change
    in the size of the store won't trigger a databind.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered the "main" view and associated classes, so let's move on to the
    view that will list product categories.
  prefs: []
  type: TYPE_NORMAL
- en: Categorically speaking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to use a simplified grid to build this view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've hidden the `grid` headers and used the `flex` configuration option to
    tell the single column to fill all of the available space. This gives us the functionality
    we need for a simple scrolling list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list''s store is then bound to the `categories` that''s defined on the
    category view model that we''ll look at shortly. First, let''s take a look at
    the categories view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This really couldn''t be much simpler; just catch the `itemclick` event, grab
    the ID of the selected category, and pass it off to the routing system so that
    another controller can take care of it. The final part of the category puzzle
    is the view model and it''s even more straightforward, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the MVVM pattern in action, each of the three classes shown here are
    doing its own thing and nothing more. The view class is describing the presentation,
    the view model provides the data behind this presentation, and the view controller
    deals with user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Product placement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the code for the list of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The top toolbar for the product list contains a combo box with an inline store
    containing available sort options. Note that we include the property to sort against
    and the direction of the sort so that we can pass these straight through to the
    server later.
  prefs: []
  type: TYPE_NORMAL
- en: There's a case to be made for this combo to be extracted into a separate class
    or the store to be set up on the view model; it might make this class a bit clearer.
    On the other hand, the proliferation of files and classes for their own sake will
    make things less clear too, so we'll keep it inline.
  prefs: []
  type: TYPE_NORMAL
- en: The real work in this class is performed by the `dataview` bound to a products
    store on the view model. Note how again that we're creating a window in the constructor
    of this class too, which will enable it to use the same view controller as the
    product list `dataview`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for this window (it''s the one that shows details of a product):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There's a neat little trick used in this class. The window is split into two
    using a column layout and filled with a number of components that have their `data`
    config bound to the `currentProduct` on the view model. By using the `tpl` config
    on these components to set up an HTML template, each pane in the window can pull
    properties from the `currentProduct` and they'll be incorporated in the template.
    This gives us a hybrid approach that leverages the Ext JS column layout and standard
    HTML/CSS for customization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `bbar` for this window, we use the `glyph` property to set `FontAwesome`
    icons on the buttons using the `unicode` character code of the icon in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view controller that works with the product list and detail has a couple
    of interesting features as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After wiring up event listeners and routes, we have the `onSortSelect` method
    that handles the user's selection of a `sort` option. We pick out the values we
    need and send them to the view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The routing handles on this view controller: `onCategoryRoute` and `onProductRoute`
    deal with the selection of a category (which shows a list of products) and the
    selection of a product (which shows a single product), and do so using a technique
    (which is new to us).'
  prefs: []
  type: TYPE_NORMAL
- en: By using the `linkTo` method, we tell Ext JS to load the record with the specified
    ID if it's not already loaded it before. By doing this, we save the manual labor
    of loading the record ourselves. It's a neat shortcut that lets us set `currentProduct`
    and `currentCategory` on the view model with minimal code.
  prefs: []
  type: TYPE_NORMAL
- en: The `onProductClick` and `onProductClose` methods use `redirectTo` and hand
    off the real behavior to the relevant routes. The `onAddToCart` method grabs the
    cart store from the view model and uses the `addProduct` method that we created
    back in our data layer to push the current product into the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the product view model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `links` configuration sets up the initial category to be loaded; Ext JS
    will do this automatically and anything that's been bound to it will be able to
    make use of it as soon as the load is complete. No manual intervention here is
    required; just wire up the configuration and go.
  prefs: []
  type: TYPE_NORMAL
- en: The `data` object contains the default values for product sorting and you can
    see that these are used by the `products` store and sent off to the server thanks
    to `remoteSort`. The product store is used to power the list of products in a
    category, and to this end it has a filter that's bound to the ID of `currentCategory`.
    This gets sent along with the sort options as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Categories and products are taken care of. It's time to move on to the shopping
    cart UI.
  prefs: []
  type: TYPE_NORMAL
- en: A basket case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cart itself is a grid showing the products in the cart and the quantity
    of each. It''s enclosed in a window with a couple of action buttons at the bottom
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Within the grid, we have used the `cellediting` plugin that allows the user
    to tap the quantity column and use the plus or minus icons that Ext JS provides
    on the touch-friendly theme to adjust the item quantity. When the quantity is
    edited and the `edit` event fires on the grid, we immediately commit the change
    to the cart store, which is bound to the grid from the parent view model.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no specific view model for this view. Instead, as we instantiated
    this window within the constructor of the main view, it'll inherit the main view
    model. This means that we can share the cart store with multiple components by
    having it high up in the view model hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the cart view controller, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We wire up event handlers for the window's buttons by using `itemId`, which
    we defined in the view as the selector. The `onCartClose` method is straightforward,
    but the `onOrderNow` one is a little more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'It first determines if the user is logged in by checking whether `currentUser`
    on the view model is `null`. If the user is not logged in, a `loginrequired` event
    will be fired; if you remember, we handled this earlier in the main view controller.
    If the user is logged in, we perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `toOrder` method from the cart store to get an `Order` model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove all the items from the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the new `Order` model to the orders store on the view model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show a toast notification to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide the cart window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this results in the cart being moved to an order. In a comprehensive
    e-commerce application, this is the bit that will be replaced by credit card capturing
    and payment processing, but we've taken the simple approach here, that is, composing
    various calls to other classes to perform the action we need.
  prefs: []
  type: TYPE_NORMAL
- en: As previously discussed, the cart view doesn't have its own view model because
    it inherits from its parent, so we'll now move on to the final view in the application;
    the account window.
  prefs: []
  type: TYPE_NORMAL
- en: The account window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The account view is a window that contains several subcomponents (such as login,
    register, and past orders). Let''s take a look at the lengthy, but straightforward
    code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We've got two panels here, both set to use a `column` layout. One contains the
    login and registration forms and is shown when the user is logged out. Another
    shows the registration form repurposed as a way to let the user edit their profile
    details and the past orders. The second panel is only shown when the user is logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: The hiding and showing of components in the account window is accomplished by
    binding the `hidden` config to `currentUser` at the top-level main view model.
    Ext JS converts the user object to a "truthy" value, that is, either true or false.
    This is used to set the component's visibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `login` component, which is just an `Ext.FormPanel` with
    the relevant fields along with a little bit of explanatory text, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the `register` component, another form containing the fields
    that a user must complete in order to sign up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The final piece of the account user interface is the past orders component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use DataView with `itemTpl` configured to output all of the orders
    as well as loop through the items within this order. As none of the past orders
    are clickable, there's no detail view for orders to click on to. Therefore, we
    need to specify a fake `itemSelector`. Binding this component's store to the orders
    store on the view model was performed in the containing account window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a simple view controller to handle interactions with the account
    window, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is standard stuff in `onAccountClose`, but in `onLoginRegister`, we perform
    a very naïve login action in which the `currentUser` gets set to an object with
    the e-mail address that the user entered for login or registration. As previously
    discussed, we're bypassing a full authentication system for simplicity, but this
    demonstrates the general idea, that is, perform an action that ends up with a
    user being set on the inherited view model. Once again, you'll see that we don't
    have a separate account view model as everything's passed up and down to the one
    that's defined on the main view.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter's been a whistle-stop tour through a set of features and ideas
    that we should already be familiar with. It was a consolidation of the work we've
    done over the past few chapters and a demonstration of how to build an application
    with multiple views, but with a low level of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be moving on from full applications and looking at
    performance and debugging considerations involved in an Ext JS project. How can
    we design our applications to help developers when issues arise? How can we try
    and make sure our application feels responsive to end users? We'll also be looking
    at these questions in-depth in the next chapter.
  prefs: []
  type: TYPE_NORMAL
