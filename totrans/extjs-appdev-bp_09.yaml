- en: Chapter 9. A Shopping Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 购物应用
- en: In this chapter, we'll design one last application from start to finish. Rather
    than continuing to introduce new ideas or techniques to visualize and construct
    an application architecture, we'll double up on the work we've done so far. We'll
    incorporate routes, view models, and events in order to consolidate everything
    that's been discussed, and we'll create design documentation to inform the application's
    structure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头到尾设计最后一个应用。而不是继续介绍新的想法或技术来可视化和构建应用架构，我们将加倍努力完成我们迄今为止所做的工作。我们将结合路由、视图模型和事件，以巩固所讨论的一切，并创建设计文档来告知应用的结构。
- en: In each chapter of this book so far, I've tried to stress that there's no "one
    true way" to application architecture. Every application is different; there is
    plenty of room for interpretation. At the beginning of the book, we discussed
    the MVC and MVVM design patterns and what an architect must find is their own
    pattern (a way of working that feels natural). More than this, a pattern is something
    that emerges because of a regularity in our work, that is, repeating the same
    thing again and again. While different architects will have different ways of
    working and can use different methods in different ways, in the practical chapters,
    we've completed there is a logical development path that it's easy to fall into.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书到目前为止的每一章中，我都试图强调，没有“唯一正确”的应用架构方法。每个应用都是不同的；有足够的空间进行解释。在本书的开头，我们讨论了MVC和MVVM设计模式，以及架构师必须找到自己的模式（一种感觉自然的工作方式）。更重要的是，模式是由于我们工作中的规律性而产生的，也就是说，重复做同样的事情。虽然不同的架构师会有不同的工作方式，并且可以在不同的方式中使用不同的方法，但在实际章节中，我们已经完成了一个逻辑的发展路径，这是很容易陷入的。
- en: '"Falling into the pit of success" is a phrase used to describe a methodology
    that works well without users having to try hard to follow it. That''s what we''ve
    been working towards. Showing you the choices Ext JS provides, not only giving
    you options, but also trying to illustrate why they''re good options to use. By
    now, you should have a picture of the design of an Ext JS application and the
    features you can use to fulfill this design.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “成功陷阱”这个短语用来描述一种用户无需努力就能顺利遵循的方法。这正是我们一直在努力的方向。向您展示Ext JS提供的选项，不仅给您提供选择，还试图说明为什么它们是好的选择。到现在为止，您应该对Ext
    JS应用的设计和您可以使用来满足这种设计的功能有一个清晰的了解。
- en: In this final practical chapter, we'll once again see how, despite having a
    choice in how to implement this application, we'll end up selecting a a path that's
    similar to the one we took before, a path that feels logical and that makes development
    easy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的实践章节中，我们再次看到，尽管我们有选择如何实现这个应用，但最终我们会选择一条与之前相似的路径，一条感觉合理且使开发变得容易的路径。
- en: About the app
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于应用
- en: 'The application we''ll build is designed to shop on a tablet-sized screen.
    We''ll be taking advantage of the burgeoning "craft beer" scene and creating an
    application that allows customers to select from categorized beers in the store.
    Here''s the full feature list:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用是为平板电脑大小的屏幕设计的。我们将利用蓬勃发展的“手工啤酒”场景，创建一个允许客户从商店的分类啤酒中选择的应用。以下是完整的功能列表：
- en: Login and register
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和注册
- en: Category list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类列表
- en: Product list with sorting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带排序的产品列表
- en: Shopping cart
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: Touch-friendly
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便于触摸
- en: 'In other words, the standard set of features you''d see on a straightforward
    e-commerce website. The final product looks like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这是在直接电子商务网站上可以看到的标准功能集。最终产品看起来是这样的：
- en: '![About the app](img/5308OT_09_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![关于应用](img/5308OT_09_01.jpg)'
- en: 'We have a simple interface that provides large tappable areas for tablet users.
    There are more screens in this application than any other we''ve worked on so
    far, so let''s sketch these out and see what the full app will look like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的界面，为平板电脑用户提供了大型的可触摸区域。在这个应用中，比我们迄今为止工作的任何其他应用都有更多的屏幕，所以让我们勾勒出这些屏幕，看看完整的应用将是什么样子：
- en: '![About the app](img/5308OT_09_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![关于应用](img/5308OT_09_02.jpg)'
- en: Here, we have the wireframe of the first screen that the user sees when opening
    the site. As you can see, it maps out the features and layout, as shown in the
    previous screenshot.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有用户打开网站时看到的第一个屏幕的线框图。正如您所看到的，它映射出了功能和布局，如前一个屏幕截图所示。
- en: This mockup mentions all of the main features of the application. Note that,
    unlike in our earlier e-mail application, the user doesn't have to log in to start
    browsing. This only happens when they want to place an order.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此原型提到了应用程序的所有主要功能。请注意，与我们的早期电子邮件应用程序不同，用户不需要登录即可开始浏览。只有在他们想要下单时才会发生这种情况。
- en: The categories of beer are listed on the left-hand side in alphabetical order;
    the user can scroll through the list when it extends past the bottom of their
    screen. In the main part of the screen, the beers in the selected category are
    listed with the sort order determined by a combo box above the list. Each beer
    on sale is represented by its name, an image, and its price.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 啤酒类别按字母顺序列在左侧；当列表超出屏幕底部时，用户可以滚动浏览列表。在屏幕的主要部分，所选类别的啤酒按列表上方的组合框确定的排序顺序列出。每款在售啤酒都由其名称、图片和价格表示。
- en: Finally, at the top-right corner of the screen, we have the "login" and "cart
    buttons" that will change to reflect the application state and are both clickable,
    revealing further windows.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在屏幕的右上角，我们有“登录”和“购物车按钮”，它们将根据应用程序状态进行更改，并且都是可点击的，可以揭示更多窗口。
- en: The product window
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品窗口
- en: 'This next screen shows the product detail page when the user selects a product
    to view:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕显示了用户选择查看产品时的产品详情页面：
- en: '![The product window](img/5308OT_09_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![产品窗口](img/5308OT_09_03.jpg)'
- en: This screen fleshes out more of our requirements and the way they'll be implemented.
    When the user clicks on a product from the list, a modal window pops up showing
    more information about the product in question, such as a discount message showing
    price reduction, a full description, the brewery that made the beer, and a tagline
    that sells beer to the customer. This is all accompanied by a larger image of
    the product as well as buttons to add the beer to the shopping cart and to close
    the product window.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕详细说明了我们的需求和它们将如何实现。当用户点击列表中的产品时，会弹出一个模态窗口，显示有关该产品的更多信息，例如显示价格折扣的优惠信息、完整描述、生产啤酒的酿酒厂以及一句吸引顾客的标语。所有这些信息都伴随着产品的大幅图片，以及将啤酒添加到购物车和关闭产品窗口的按钮。
- en: The shopping cart
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车
- en: 'At the top-right corner of the main app screen, we can see a shopping cart
    icon and a label that changes to reflect the number of items in the cart. When
    the user clicks on the icon or label, the cart window is shown:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在主应用程序屏幕的右上角，我们可以看到一个购物车图标和一个标签，标签会根据购物车中的项目数量进行更改。当用户点击图标或标签时，将显示购物车窗口。
- en: '![The shopping cart](img/5308OT_09_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![购物车](img/5308OT_09_04.jpg)'
- en: This modal window contains a list of products in the cart and the quantity of
    each item. The user can adjust the quantities of each item here as well by clicking
    on or tapping the plus or minus icons. The other key feature of this window is
    the **Order Now** button, which processes the current cart into an order.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此模态窗口包含购物车中的产品列表以及每个项目的数量。用户可以通过点击加号或减号图标来调整每个项目的数量。此窗口的另一个关键功能是**立即下单**按钮，它将当前购物车处理成订单。
- en: If the user hasn't already logged in, clicking on this button will show the
    login and registration screen, which we'll look at next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未登录，点击此按钮将显示登录和注册屏幕，我们将在下一节中讨论。
- en: Login and registration
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录和注册
- en: 'The **Login** and **Register** options are shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**登录**和**注册**选项：
- en: '![Login and registration](img/5308OT_09_05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![登录和注册](img/5308OT_09_05.jpg)'
- en: The login and registration forms are shown side-by-side because they're simple
    enough to fit in the same window. The fields will have validation in order to
    ensure e-mails are correctly formatted and required fields are completed. When
    the registration or login process is completed, the **Login** icon on the main
    screen will be replaced by the user's e-mail address; clicking on this link will
    show an account screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 登录和注册表单并排显示，因为它们足够简单，可以放在同一个窗口中。字段将进行验证，以确保电子邮件格式正确且必填字段已填写。当完成注册或登录过程后，主屏幕上的**登录**图标将被用户的电子邮件地址替换；点击此链接将显示账户屏幕。
- en: User account
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户账户
- en: 'The user account page allows the user to edit their details and view their
    past orders:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户账户页面允许用户编辑他们的详细信息并查看他们的历史订单：
- en: '![User account](img/5308OT_09_06.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![用户账户](img/5308OT_09_06.jpg)'
- en: The text fields on the left-hand side allow the user to amend their address
    and user credentials, and the pane on the right-hand side is a list of previous
    orders, showing the items that were ordered, the date, and the total amount.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的文本字段允许用户修改他们的地址和用户凭据，右侧的面板是历史订单列表，显示已订购的项目、日期和总金额。
- en: Design overview
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计概述
- en: We've looked at all of the main application views in turn; for simplicity, we've
    excluded an actual payment process to avoid integrating with a third-party service.
    When the user proceeds with an order, it will immediately be processed and added
    as a past order in their account.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经逐一查看所有主要的应用程序视图；为了简单起见，我们排除了实际的支付过程，以避免与第三方服务集成。当用户继续订单时，它将立即被处理并添加到他们的账户中的历史订单中。
- en: One great thing about Ext JS 5 is that it adds support for touch devices and
    includes a touch-friendly theme. This should make it super simple to achieve our
    goal of presenting this app to tablet users; however, we'll include some theming
    tweaks to create a custom look and improve the experience for users on tablet
    devices.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5的一个非常好的特点是它增加了对触摸设备的支持，并包含了一个触摸友好的主题。这应该会使向平板用户展示此应用的目标变得非常简单；然而，我们将包括一些主题调整以创建自定义外观并改善平板设备用户的体验。
- en: Back to Ext JS
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到Ext JS
- en: 'While we now know that Ext JS can help with the creation of a touch-friendly
    interface, does our design suggest any other ideas that Ext JS might not be able
    to cope with? Remember that the design phase is an exploration of what works for
    the user and what is possible with the technology at hand. Let''s break it down:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在知道Ext JS可以帮助创建触摸友好的界面，但我们的设计是否提出了Ext JS可能无法应对的其他想法？记住，设计阶段是对用户适用性和现有技术可能性的探索。让我们来分析一下：
- en: The scrolling product category list can be a `Ext.grid.Panel` class with most
    features, such as headers, disabled
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动产品分类列表可以是具有大多数功能的`Ext.grid.Panel`类，例如标题、禁用
- en: The scrolling product list can be an `Ext.view.View` class (also known as a
    DataView), as we need to include custom HTML for each product to display an image
    and other details
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动产品列表可以是`Ext.view.View`类（也称为DataView），因为我们需要为每个产品包含自定义HTML来显示图片和其他详细信息
- en: Product list sorting will be achieved via a combo box containing the sort criteria
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品列表排序将通过包含排序标准的组合框来实现
- en: Other than this, we just need modal windows (which Ext JS supports), another
    grid for the shopping cart, a few form fields for the login and registration.
    We're pretty much there.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，我们只需要模态窗口（Ext JS支持），另一个用于购物车的网格，以及几个用于登录和注册的表单字段。我们基本上已经完成了。
- en: In addition to this, we'll use routing to provide the ability to bookmark categories
    or products, which allows the user to share links. We'll also use view models
    and events to wire everything together. The data will again be drawn from a server-side
    API, so let's look at this next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用路由来提供对分类或产品的书签功能，这使用户能够分享链接。我们还将使用视图模型和事件来连接一切。数据将再次从服务器端API中获取，所以让我们看看下一个。
- en: The data layer
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层
- en: 'The shopping application needs to be supplied with the following data:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 购物应用需要提供以下数据：
- en: A list of categories
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类列表
- en: A list of products, filtered by category and sorted by the selected criteria
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按分类过滤并按选定标准排序的产品列表
- en: Details of a single product
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个产品的详细信息
- en: This makes things pretty straightforward. So, in a moment, we'll break down
    exactly what sort of data responses we'll see when we make a server request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得事情非常直接。所以，在接下来的一段时间里，我们将具体说明当我们发起服务器请求时将看到什么样的数据响应。
- en: Before this, you might notice that we're skipping over the part of the application
    that will integrate with the server-side. The key reason for this is that it will
    add complexity to our example application without adding much more value; we want
    to highlight the decisions that we made in order to piece together this application
    and do it in a concise and understandable way. While there are many features we
    can add to this application and indeed our previous examples, we want to make
    sure that the really important aspects of building an application can shine through.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，你可能注意到我们正在跳过将与应用程序服务器端集成的部分。这样做的主要原因是它将增加我们示例应用的复杂性，而不会增加太多价值；我们希望突出我们为了拼凑这个应用所做的决策，并以简洁易懂的方式呈现。虽然我们可以向这个应用和我们的前一个示例添加许多功能，但我们想确保构建应用程序的重要方面能够得到突出。
- en: 'Let''s go back to the data that we''d like our backend to supply. Firstly,
    retrieving a list of categories:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们希望我们的后端提供的数据。首先，检索类别列表：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It accepts no parameters and returns a JSON array containing the ID and name
    of each available category. To see the products in a category, we talk to the
    products API:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它不接受任何参数，并返回一个包含每个可用类别的 ID 和名称的 JSON 数组。要查看某个类别的产品，我们与产品 API 进行通信：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It returns an array of objects, each containing the properties needed to render
    a product list item. The array can be filtered by passing a sort query parameter
    with a JSON array of fields to sort against, and we fetch only the category of
    products we need by passing a `filter` query parameter with a JSON array. This
    array contains one object to filter the `categoryId` property. This JSON filter
    and sort approach is one we've used in the past and it fits well with the way
    Ext JS works on the client side.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个对象数组，每个对象都包含渲染产品列表项所需的属性。可以通过传递一个包含排序字段的 JSON 数组的排序查询参数来过滤数组，并且我们通过传递一个包含
    JSON 数组的 `filter` 查询参数来获取所需的商品类别。此数组包含一个对象，用于过滤 `categoryId` 属性。这种 JSON 过滤和排序方法是我们过去使用过的，并且与
    Ext JS 在客户端的工作方式很好地匹配。
- en: Finally, we have the request for the details of a single product as follows.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有以下单个产品详情的请求。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It does not accept any query parameters per se. Instead, the ID is passed as
    part of the URL path, as it's more often seen in a RESTful API. The full JSON
    response is omitted for brevity, but it returns the full set of fields required
    to populate the product window.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它本身不接受任何查询参数。相反，ID 作为 URL 路径的一部分传递，这在 RESTful API 中更为常见。为了简洁，省略了完整的 JSON 响应，但它返回填充产品窗口所需的全套字段。
- en: Now that we've gathered this information, we can start to think about how it
    will shape our data classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了这些信息，我们可以开始思考它将如何塑造我们的数据类。
- en: Information contemplation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息沉思
- en: 'Based on the API we''ve just described, we have two main models and their associated
    stores:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚刚描述的 API，我们有两个主要模型及其关联的存储：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These will have accompanying stores that do nothing more than wrap their model.
    In addition to the classes that interact with the API, we''ll have a couple more
    to deal with some other moving parts in the application. Firstly, we''ll look
    at the various items in the cart:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将会有伴随的存储，它们除了包装它们的模型之外不做任何事情。除了与 API 交互的类之外，我们还将有其他几个类来处理应用程序中的其他动态部分。首先，我们将查看购物车中的各种项目：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An alternative to this design will be to hold only `productId` and `quantity`
    and look up the product details from the product store at render time. However,
    the method we've chosen makes the resulting code simpler and it also allows you
    to store data such as the price at the time the user adds it to the cart. This
    can be handy in complex or busy sites if the product price changes after the user
    adds it to the cart.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计的替代方案是只保留 `productId` 和 `quantity`，并在渲染时从产品存储中查找产品详情。然而，我们选择的方法使生成的代码更简单，并且它还允许您存储用户将其添加到购物车时的数据，如价格。如果产品价格在用户将其添加到购物车后发生变化，这在复杂或繁忙的网站上可能会很有用。
- en: 'Secondly, we have a model to hold an order:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们有一个模型来保存订单：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will be used to represent a shopping cart that has been converted to an
    order. While this class will be consumed by a simple wrapper store, `CartItem`
    will have a store that does a little bit more:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于表示已转换为订单的购物车。虽然这个类将由一个简单的包装存储器消费，但 `CartItem` 将有一个执行更多操作的存储器：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `addProduct` method can be passed to a product model that is to be added
    to the cart. It adds a bit of logic to detect whether a matching product already
    exists in the cart; if it does, it increments the quantity rather than creating
    a new cart item.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`addProduct` 方法可以传递给要添加到购物车的产品模型。它添加了一些逻辑来检测是否已存在匹配的产品在购物车中；如果存在，则增加数量而不是创建新的购物车项。'
- en: The `toOrder` method converts the cart and all its items to an `Order` model,
    which can then be saved to the server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`toOrder` 方法将购物车及其所有项目转换为 `Order` 模型，然后可以将其保存到服务器。'
- en: The API for this project is simple, but we'll also use models and stores to
    organize our data and application state in memory, favoring the `Ext.data` classes
    over standard JavaScript objects in order to leverage their powerful features.
    With the data design pretty much complete, we can move on to see how this data
    will interact with the rest of the application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的API很简单，但我们也将使用模型和存储来组织我们的数据和应用程序状态，优先使用`Ext.data`类而不是标准JavaScript对象，以便利用它们强大的功能。随着数据设计基本完成，我们可以继续看看这些数据将如何与应用程序的其余部分交互。
- en: Component interaction
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件交互
- en: In Ext JS 4, we have the MVC pattern to build and clean well-structured applications.
    Looking back at our past few practical chapters, though, it seems difficult to
    imagine going back to MVC from the MVVM architecture that Ext JS gives us because,
    in each example, we've used view models to great effect to provide a logical way
    for data to flow through our application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS 4中，我们有MVC模式来构建和清理结构良好的应用程序。然而，回顾我们过去的几个实践章节，似乎很难想象从Ext JS提供的MVVM架构回到MVC。因为在每个例子中，我们都有效地使用了视图模型来提供数据通过我们应用程序的逻辑流动方式。
- en: The interesting thing about these examples is how little code we write in many
    situations. Analyzing the application requirements and spiking a few tricky areas
    leads to writing a small amount of configuration of UI, controllers, view models,
    and so on. Ext JS automatically builds the plumbing through which our data can
    flow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子有趣的地方在于，在许多情况下我们写的代码很少。分析应用程序需求并解决一些棘手区域会导致编写少量UI、控制器、视图模型等的配置。Ext JS自动构建了数据流动的管道。
- en: It's another example of why application architecture is so important, particularly
    when combined with a strong understanding of the tools at hand. It would be very
    easy for a naïve developer to jump in and start writing code to manually handle
    movement of data from an API through to the user interface using `Ext.Ajax` rather
    than models and proxies and manually loading data into components. However, by
    taking a patient and methodical approach, we can build a conceptual overview of
    the application that easily slots into the framework provided by Ext JS. By thinking
    about things upfront, we're making our lives much simpler for later use.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个说明为什么应用程序架构如此重要的例子，尤其是当它与对现有工具的深入了解相结合时。一个天真的开发者可能会轻易地跳进来，开始编写代码来手动处理数据从API通过到用户界面的移动，使用`Ext.Ajax`而不是模型和代理，并手动将数据加载到组件中。然而，通过采取耐心和有条理的方法，我们可以构建一个概念性的应用程序概述，它可以轻松地适应Ext
    JS提供的框架。通过提前思考，我们使后续使用变得更加简单。
- en: To this end, let's think about the controllers and views we'll need in this
    application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，让我们思考一下在这个应用程序中我们需要哪些控制器和视图。
- en: In control
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: In control
- en: What's the purpose of a controller? As you learned in [Chapter 2](ch02.html
    "Chapter 2. MVC and MVVM"), *MVC and MVVM*, it's to act as the glue between other
    parts of the application, and in the majority of cases, this is manifested in
    code that handles events. From UI clicks to routing events, the controller consumes
    them and passes off the real work to another class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的目的是什么？正如你在[第二章](ch02.html "第二章。MVC和MVVM")“MVC和MVVM”中学到的，它是作为应用程序其他部分之间的粘合剂，在大多数情况下，这体现在处理事件的代码中。从UI点击到路由事件，控制器消耗它们并将实际工作传递给另一个类。
- en: 'What does this mean for the way we think about architecture? It means that
    any action or event in the application will likely need an associated controller.
    If these actions can be bundled into a distinct grouping, then this could be an
    indication they warrant their own controller. With this in mind, let''s look at
    our shopping application again:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们思考架构的方式意味着什么？这意味着应用程序中的任何动作或事件都可能需要一个相关的控制器。如果这些动作可以捆绑成一个独立的分组，那么这可能表明它们需要自己的控制器。考虑到这一点，让我们再次看看我们的购物应用程序：
- en: '![In control](img/5308OT_09_07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![In control](img/5308OT_09_07.jpg)'
- en: 'What elements of the page could raise an event? A click on a category in the
    blue left-hand pane, so alongside the category list view, we''ll have a category
    view controller as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上的哪些元素可能会引发事件？在蓝色左侧面板中点击一个类别，因此除了类别列表视图外，我们还将有一个如下所示的类别视图控制器：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Clicking on a product in the product list is an action we need to handle, so
    we''ll have a product list view and a product view controller as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品列表中点击一个产品是我们需要处理的一个动作，因此我们将有一个产品列表视图和一个产品视图控制器，如下所示：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next up, the two icons at the top-right corner of the window need to trigger
    UI changes, so they need a view controller. Do we want a "header" controller to
    handle the events from the cart and account icons or can we use a "main" controller?
    It''s one of these things that can boil down to a matter of preference; here,
    we''ll use the main controller just to keep the number of classes from getting
    out of hand:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，窗口右上角的两个图标需要触发UI更改，因此它们需要一个视图控制器。我们想要一个“标题”控制器来处理购物车和账户图标的事件，还是可以使用一个“主要”控制器？这通常是取决于个人偏好的问题；在这里，我们将使用主要控制器，以保持类数量的可控：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's look back at our other UI wireframes. There are three remaining UI components
    and they're all modal windows. Firstly, the product detail window (interactions
    with this will be handled by the product controller that we've already identified).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的其他UI线框图。还有三个剩余的UI组件，它们都是模态窗口。首先，是产品详情窗口（与此交互将由我们已确定的产品控制器处理）。
- en: 'Next is the shopping cart window, which will be paired with a controller that
    handles the user''s interactions with the various buttons on the cart:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是购物车窗口，它将与一个控制器配对，该控制器处理用户与购物车中各种按钮的交互：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the account window with its account view controller to handle login
    and registration is shown in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码显示了带有账户视图控制器以处理登录和注册的账户窗口：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's a final place that will raise events that our application will need
    to handle. The requirements for this project stipulate that we implement routing
    to allow product pages to be shared via e-mail or social media. To meet this need,
    we'll have a controller specify the routes' definitions and matching handlers.
    The exact controller to take this role will depend on the nature of the route
    definitions, for example, if it's a route related to products, then the product
    controller will handle it. You can see a few of these route handling methods dotted
    around the controller designs in the preceding section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个地方会引发事件，我们的应用程序需要处理。这个项目的需求规定，我们需要实现路由，以便通过电子邮件或社交媒体共享产品页面。为了满足这一需求，我们将有一个控制器指定路由的定义和匹配处理程序。具体承担这一角色的控制器将取决于路由定义的性质，例如，如果它与产品相关，则产品控制器将处理它。您可以在上一节中控制器设计中看到一些这些路由处理方法。
- en: Grouping actions and events in this way will often make the choice of which
    controllers to build an easy one, particularly when used in association with wireframes
    that allow you to look at the corresponding UI views.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式对动作和事件进行分组通常会使得选择要构建哪些控制器变得容易，尤其是在与允许您查看相应UI视图的线框图一起使用时。
- en: The simplicity of view models
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型的简洁性
- en: 'We''ve discussed view models and application architecture using the word "flow"
    several times. As the user manipulates various parts of the user interface, data
    flows through controllers and view models to represent the current state of the
    application. Rather than writing out a list of all of the junctions through which
    data can flow in this application, let''s try and picture it instead as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用“流程”这个词来讨论视图模型和应用程序架构。当用户操作用户界面的各个部分时，数据通过控制器和视图模型流动，以表示应用程序的当前状态。与其列出在这个应用程序中数据可以流动的所有节点，不如让我们尝试以下方式来想象它：
- en: '![The simplicity of view models](img/5308OT_09_08.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![视图模型的简洁性](img/5308OT_09_08.jpg)'
- en: Interactions between the cart store on the main view model and its dependents
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 主视图模型与它的依赖项之间的交互
- en: Being able to conceptualize your application at this level is a good sign that
    it is well-understood and well-conceived. In larger applications, it will be hard
    to visualize every part of the application in this way, so it will often be broken
    into multiple smaller visualizations. Either way, building a top-level mapping
    of data and user flow is a fantastic way to confirm the logic and simplicity of
    a design.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在这个层面上概念化您的应用程序是一个好兆头，表明它被充分理解和构思。在更大的应用程序中，很难以这种方式可视化应用程序的每个部分，因此它通常会被分解成多个较小的可视化。无论如何，构建数据流和用户流的顶层映射是确认设计逻辑和简洁性的绝佳方式。
- en: Code, code, and more code
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码，代码，还有更多的代码
- en: 'It''s time to get our hands dirty and put fingers to keyboards. As always,
    we generated a new base application using Sencha Cmd and will use the resulting
    "main" view as a starting point for our user interface. First though, let''s flesh
    out the data layer that we designed earlier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手实践，把手指放在键盘上了。一如既往地，我们使用Sencha Cmd生成了一个新基础应用程序，并将生成的“main”视图作为用户界面的起点。不过，首先让我们完善之前设计的底层数据结构：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ve used a base model in previous chapters because it gives us a good way
    of centralizing proxy configuration. The models that inherit from it are all straightforward,
    as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中使用了基础模型，因为它为我们提供了一个很好的集中配置代理的方法。从它继承的模型都是直接的，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Looking back at our design, these models exactly follow the specification we
    laid out. All we've really done is add the Ext JS implementation on top of the
    original field definitions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的设计，这些模型完全符合我们之前制定的规范。我们真正做的只是在上面的原始字段定义之上添加了Ext JS实现。
- en: What's in store?
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车中有什么？
- en: 'As we know, stores are often just wrappers to give us a few more helpful methods
    to work with a collection of models. Looking back at our design documents, this
    is the case for three of the stores in this application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，存储库通常只是包装器，为我们提供一些更多有用的方法来处理模型集合。回顾我们的设计文档，这种情况适用于本应用中的三个存储库：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All very straightforward. The cart store is a bit more interesting, as shown
    in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都非常直接。购物车存储库稍微有趣一些，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Many of the stores we've built in past chapters have been used to store information
    that has been fetched from the server. Here, we're using the store as an in-memory
    representation of the shopping cart itself; we're adding a couple of custom methods
    to help with this function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去章节中我们构建的许多存储库都用于存储从服务器获取的信息。在这里，我们将存储用作购物车本身的内存表示；我们添加了一些自定义方法来帮助实现这一功能。
- en: The `addProduct` method will add the specified product to the store by converting
    it to a `CartItem` model. If a product with the same ID already exists as an item
    in the cart, it will have its quantity increased by one rather than being duplicated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`addProduct`方法将通过将其转换为`CartItem`模型来将指定的产品添加到存储库中。如果购物车中已经存在具有相同ID的产品，则其数量将增加一个，而不是重复添加。'
- en: The `toOrder` method converts the whole cart to an `Order` model, which is used
    later in the application to show past orders in the user's account.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`toOrder`方法将整个购物车转换为`Order`模型，该模型在应用程序的后续部分用于显示用户账户中的历史订单。'
- en: These methods are interesting because they demonstrate a place where we're not
    writing glue code or code that handles events. It's the code that deals with the
    really interesting parts of an application, sometimes called "business logic".
    One of the benefits of developing a strong architecture with strong development
    practices is that you will have less boilerplate code and more time to work on
    the business logic that's important to your client.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法很有趣，因为它们展示了我们不是在编写胶水代码或处理事件的代码的地方。这是处理应用程序真正有趣部分的代码，有时也称为“业务逻辑”。开发强大架构和强大开发实践的一个好处是，你将拥有更少的样板代码，并有更多时间专注于对客户重要的业务逻辑。
- en: In [Chapter 11](ch11.html "Chapter 11. Application Testing"), *Application Testing*,
    we'll look at ways to isolate this business logic and create automated tests that
    give you confidence in your code base.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.html "第11章。应用测试")“应用测试”中，我们将探讨隔离这种业务逻辑并创建自动化测试的方法，这些测试将使你对代码库充满信心。
- en: That's our data layer in place, so we can move on to building the user interface.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据层已经就绪，因此我们可以继续构建用户界面。
- en: Interface in your face
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面前的接口
- en: 'An Ext JS application created with Sencha Cmd will set up the main view as
    a viewport filling the entire browser window. We''ll use this view and adapt it
    to our needs, as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sencha Cmd创建的Ext JS应用程序将设置主视图为填充整个浏览器窗口的视口。我们将使用这个视图并根据以下代码对其进行调整以满足我们的需求：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we are! Our first view component, the panel that will contain everything
    else in the application. The `header` config is set to a custom `xtype` that we'll
    build later. The items in the panel are configured to use a border layout and
    consist of the category list and the product list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了这里！我们的第一个视图组件，将包含应用程序中所有其他内容的面板。`header`配置设置为稍后我们将构建的自定义`xtype`。面板中的项目配置为使用边框布局，并包括类别列表和产品列表。
- en: 'There is one oddity here: adding windows to a panel within the `initComponent`
    method. This provides two benefits:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个奇怪的地方：在 `initComponent` 方法中向面板添加窗口。这提供了两个好处：
- en: The main view controller can refer to the windows using `lookupReference`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主视图控制器可以使用 `lookupReference` 来引用窗口
- en: The windows will have access to the main view model via the view model inheritance
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口将通过视图模型继承访问主视图模型
- en: This is a simple approach that solves an obvious sounding issue, that is, where
    do I create my windows? It doesn't feel "right" to put them in the `items` config
    with the product and category list, although we certainly can without any ill
    effect. Another common solution is to instantiate the window in the view controller
    itself, but as the window then isn't a child of the main view, this leads to issue
    with the view model inheritance. Creating the windows in the `initComponent` method
    feels like a natural way to bypass this problem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的解决方案，解决了听起来很明显的难题，那就是我在哪里创建我的窗口？把它们放在 `items` 配置中的产品和类别列表中感觉“不对劲”，尽管我们当然可以这样做而没有任何不良影响。另一个常见的解决方案是在视图控制器本身中实例化窗口，但这样窗口就不是主视图的子项了，这会导致视图模型继承的问题。在
    `initComponent` 方法中创建窗口感觉是绕过这个问题的自然方式。
- en: One step ahead
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比别人早一步
- en: 'We decided earlier that the main view controller will also handle events from
    the header, so let''s look at the header view next:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前决定主视图控制器也将处理来自头部的事件，所以让我们看看下一个头部视图：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our custom header component inherits from `Ext.panel.Header` and implements
    an `hbox` layout. The two items contained within are also custom classes, one
    for the cart icon and one for the account icon. These are configured to bind to
    `currentUser` and `cartCount` respectively, which are values in the main view
    model that we'll look at later.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制头部组件继承自 `Ext.panel.Header` 并实现了 `hbox` 布局。其中包含的两个项目也是自定义类，一个用于购物车图标，另一个用于账户图标。这些配置绑定到
    `currentUser` 和 `cartCount`，它们是主视图模型中的值，我们稍后会查看。
- en: 'The cart icon is called `MiniCart` and it looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车图标称为 `MiniCart`，其外观如下：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `header` component, we specified that the `data` config for `MiniCart`
    should be an object with a `count` value. This `count` value will be bound to
    a `cartCount` value in the view model. In turn, we now use this `count` value
    in the template, which allows you to have an icon that updates with the count
    of items in the cart.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `header` 组件中，我们指定了 `MiniCart` 的 `data` 配置应该是一个具有 `count` 值的对象。这个 `count` 值将绑定到视图模型中的
    `cartCount` 值。反过来，我们现在使用这个 `count` 值在模板中，这使得你可以拥有一个随着购物车中项目数量更新图标。
- en: There are a couple of other things to note here. We're using the `FontAwesome`
    icon set to add a bit of graphical flair to the cart; you can see it being used
    in a `span` tag in the `tpl` configuration.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有其他几件事情需要注意。我们使用 `FontAwesome` 图标集为购物车添加一些图形风格；你可以在 `tpl` 配置中的 `span` 标签中看到它的使用。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`FontAwesome` can be found at [http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`FontAwesome` 可以在 [http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/)
    找到。'
- en: 'The second point to note is that this class inherits from `Alcohology.ux.ClickContainer`.
    What''s this? Take a look at the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的点是这个类继承自 `Alcohology.ux.ClickContainer`。这是什么？看看以下代码：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A normal container doesn't have a `click` event, so this `ClickContainer` hooks
    into the underlying element that allows you to handle user interaction with the
    container. This is handy if you don't need button styling and would like a bare-bones
    clickable component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的容器没有 `click` 事件，所以这个 `ClickContainer` 钩子到允许你处理与容器用户交互的底层元素。如果你不需要按钮样式而想有一个简单的可点击组件，这很有用。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This feature can also be implemented as a mixin rather than a base class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能也可以作为一个混合类而不是基类来实现。
- en: 'The account indicator also extends `ClickContainer` as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 账户指示器也扩展了 `ClickContainer`，如下所示：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our favorite trick of binding to a custom configuration option is again used
    here with a little twist. If the value of a user being bound is `null`, that is,
    if the user has yet to log in, we use the default value of the `data` config to
    set a label on this component. If they have logged in, we set the label to their
    e-mail address.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用绑定到自定义配置选项的技巧，这里有一些变化。如果绑定的用户值为 `null`，即用户尚未登录，我们使用 `data` 配置的默认值为此组件设置一个标签。如果他们已经登录，我们将标签设置为他们的电子邮件地址。
- en: You can see in the `tpl` configuration that we're using `FontAwesome` again.
    It's also the place we use the label that has a default value of `login`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`tpl`配置中看到我们再次使用了`FontAwesome`。这也是我们使用默认值为`login`的标签的地方。
- en: Let's get back to the code that handles the user's interactions with these components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到处理用户与这些组件交互的代码。
- en: Under the main control
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主控制下
- en: 'The main controller is not only the place that handles user clicks and taps,
    but the place that defines some relevant routes. It even handles a custom event.
    Let''s take a look:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 主要控制器不仅处理用户点击和触摸，还定义了一些相关路由的地方。它甚至处理自定义事件。让我们看看：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There''s a very handy technique demonstrated here: the `click` handlers for
    `account-indicator` and `minicart` both simply redirect to their relevant routes.
    This means that we can put the logic to show the account and cart windows in `onAccountRoute`
    and `onCartRoute` route handlers.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个非常实用的技术：`account-indicator`和`minicart`的`click`处理程序都简单地重定向到它们的相关路由。这意味着我们可以将显示账户和购物车窗口的逻辑放在`onAccountRoute`和`onCartRoute`路由处理程序中。
- en: The other piece of functionality implemented in this view controller is the
    listener on the controller domain. It listens for any controller firing the `loginrequired`
    event and handles it with the `onLoginRequired` method. Within `onLoginRequired`,
    we pop up a brief note to the user via the `Ext.toast` feature and simply redirect
    them to the `login/registration` page.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图控制器中实现的其他功能是监听控制器域。它监听任何触发`loginrequired`事件的控制器，并使用`onLoginRequired`方法处理它。在`onLoginRequired`中，我们通过`Ext.toast`功能向用户弹出简短的通知，并简单地将他们重定向到`login/registration`页面。
- en: 'This enables any controller or view controller to request the user to log in
    without having to be explicitly aware of the implementation of the account system.
    Let''s take a look at the view model for the main viewport:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得任何控制器或视图控制器都可以请求用户登录，而无需明确了解账户系统的实现。让我们看看主视口的视图模型：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This top-level view model provides the stores for past orders and the shopping
    cart as well as a property giving us the number of items in the shopping cart.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶级视图模型提供了过去订单和购物车的存储，以及一个属性，它给出了购物车中项目的数量。
- en: Due to the default in Ext JS, we have to manually listen to the `datachanged`
    event on the cart store in order to get a "live" count of items because a change
    in the size of the store won't trigger a databind.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ext JS的默认设置，我们必须手动监听购物车存储上的`datachanged`事件，以便获取项目的“实时”计数，因为存储大小的变化不会触发数据绑定。
- en: We've covered the "main" view and associated classes, so let's move on to the
    view that will list product categories.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了“主”视图及其相关类，接下来让我们转向将列出产品类别的视图。
- en: Categorically speaking
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按类别划分
- en: 'We''re going to use a simplified grid to build this view:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简化的网格来构建这个视图：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've hidden the `grid` headers and used the `flex` configuration option to
    tell the single column to fill all of the available space. This gives us the functionality
    we need for a simple scrolling list.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经隐藏了`grid`标题，并使用`flex`配置选项来告诉单列填充所有可用空间。这为我们提供了一个简单的滚动列表所需的功能。
- en: 'The list''s store is then bound to the `categories` that''s defined on the
    category view model that we''ll look at shortly. First, let''s take a look at
    the categories view controller:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的存储绑定到我们在稍后将要查看的类别视图模型中定义的`categories`。首先，让我们看看类别视图控制器：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This really couldn''t be much simpler; just catch the `itemclick` event, grab
    the ID of the selected category, and pass it off to the routing system so that
    another controller can take care of it. The final part of the category puzzle
    is the view model and it''s even more straightforward, as shown in the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不能再简单了；只需捕获`itemclick`事件，获取所选类别的ID，并将其传递给路由系统，以便另一个控制器来处理。类别难题的最后一部分是视图模型，它甚至更加直接，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the MVVM pattern in action, each of the three classes shown here are
    doing its own thing and nothing more. The view class is describing the presentation,
    the view model provides the data behind this presentation, and the view controller
    deals with user interaction.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是MVVM模式的作用，这里显示的三个类都在做自己的事情，没有其他。视图类描述了展示，视图模型提供了这个展示背后的数据，而视图控制器处理用户交互。
- en: Product placement
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品定位
- en: 'Here''s the code for the list of products:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是产品列表的代码：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The top toolbar for the product list contains a combo box with an inline store
    containing available sort options. Note that we include the property to sort against
    and the direction of the sort so that we can pass these straight through to the
    server later.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 产品列表的顶部工具栏包含一个组合框，其中包含一个内联存储，包含可用的排序选项。注意，我们包括了排序所针对的属性和排序的方向，这样我们就可以在稍后直接将这些属性传递到服务器。
- en: There's a case to be made for this combo to be extracted into a separate class
    or the store to be set up on the view model; it might make this class a bit clearer.
    On the other hand, the proliferation of files and classes for their own sake will
    make things less clear too, so we'll keep it inline.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个论点认为这个组合应该提取到一个单独的类中，或者存储应该在视图模型上设置；这可能会使这个类更清晰。另一方面，仅仅是为了文件和类的繁衍也会使事情变得不那么清晰，所以我们将它保持内联。
- en: The real work in this class is performed by the `dataview` bound to a products
    store on the view model. Note how again that we're creating a window in the constructor
    of this class too, which will enable it to use the same view controller as the
    product list `dataview`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，真正的作业是由绑定到视图模型上的产品存储的 `dataview` 执行的。注意，我们在这个类的构造函数中再次创建了一个窗口，这将使它能够使用与产品列表
    `dataview` 相同的视图控制器。
- en: 'Here''s the code for this window (it''s the one that shows details of a product):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个窗口的代码（它显示产品的详细信息）：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's a neat little trick used in this class. The window is split into two
    using a column layout and filled with a number of components that have their `data`
    config bound to the `currentProduct` on the view model. By using the `tpl` config
    on these components to set up an HTML template, each pane in the window can pull
    properties from the `currentProduct` and they'll be incorporated in the template.
    This gives us a hybrid approach that leverages the Ext JS column layout and standard
    HTML/CSS for customization.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中有一个巧妙的小技巧。窗口通过列布局分成两部分，并填充了若干个组件，这些组件的 `data` 配置绑定到了视图模型上的 `currentProduct`。通过在这些组件上使用
    `tpl` 配置来设置 HTML 模板，窗口中的每个面板都可以从 `currentProduct` 中拉取属性，并将它们纳入模板中。这为我们提供了一种混合方法，它利用了
    Ext JS 的列布局和标准的 HTML/CSS 进行定制。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In `bbar` for this window, we use the `glyph` property to set `FontAwesome`
    icons on the buttons using the `unicode` character code of the icon in question.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口的 `bbar` 中，我们使用 `glyph` 属性通过图标的相关 `unicode` 字符代码在按钮上设置 `FontAwesome` 图标。
- en: 'The view controller that works with the product list and detail has a couple
    of interesting features as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与产品列表和详情一起工作的视图控制器有几个有趣的功能如下：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After wiring up event listeners and routes, we have the `onSortSelect` method
    that handles the user's selection of a `sort` option. We pick out the values we
    need and send them to the view model.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接事件监听器和路由之后，我们有了 `onSortSelect` 方法，它处理用户对 `sort` 选项的选择。我们挑选出需要的值并将它们发送到视图模型。
- en: 'The routing handles on this view controller: `onCategoryRoute` and `onProductRoute`
    deal with the selection of a category (which shows a list of products) and the
    selection of a product (which shows a single product), and do so using a technique
    (which is new to us).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图控制器处理的路由：`onCategoryRoute` 和 `onProductRoute` 处理类别的选择（显示产品列表）和产品的选择（显示单个产品），并且使用了一种（对我们来说是新的）技术。
- en: By using the `linkTo` method, we tell Ext JS to load the record with the specified
    ID if it's not already loaded it before. By doing this, we save the manual labor
    of loading the record ourselves. It's a neat shortcut that lets us set `currentProduct`
    and `currentCategory` on the view model with minimal code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `linkTo` 方法，我们告诉 Ext JS 如果指定的记录尚未加载，则加载该记录。通过这样做，我们节省了手动加载记录的劳动。这是一个方便的快捷方式，让我们能够用最少的代码在视图模型上设置
    `currentProduct` 和 `currentCategory`。
- en: The `onProductClick` and `onProductClose` methods use `redirectTo` and hand
    off the real behavior to the relevant routes. The `onAddToCart` method grabs the
    cart store from the view model and uses the `addProduct` method that we created
    back in our data layer to push the current product into the cart.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`onProductClick` 和 `onProductClose` 方法使用 `redirectTo` 将实际行为传递给相关的路由。`onAddToCart`
    方法从视图模型中获取购物车存储，并使用我们在数据层中创建的 `addProduct` 方法将当前产品推入购物车。'
- en: 'Finally, we have the product view model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有产品视图模型：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `links` configuration sets up the initial category to be loaded; Ext JS
    will do this automatically and anything that's been bound to it will be able to
    make use of it as soon as the load is complete. No manual intervention here is
    required; just wire up the configuration and go.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`links`配置设置了要加载的初始类别；Ext JS将自动完成此操作，并且任何绑定到它的东西都可以在加载完成后立即使用它。这里不需要手动干预；只需连接配置并继续即可。'
- en: The `data` object contains the default values for product sorting and you can
    see that these are used by the `products` store and sent off to the server thanks
    to `remoteSort`. The product store is used to power the list of products in a
    category, and to this end it has a filter that's bound to the ID of `currentCategory`.
    This gets sent along with the sort options as JSON.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`对象包含产品排序的默认值，您可以看到这些值被`products`存储使用，并通过`remoteSort`发送到服务器。产品存储用于为类别中的产品列表提供动力，为此它有一个绑定到`currentCategory`
    ID的过滤器。这将作为JSON与排序选项一起发送。'
- en: Categories and products are taken care of. It's time to move on to the shopping
    cart UI.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 类别和产品已经处理好了。现在是时候转向购物车UI了。
- en: A basket case
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个篮子案例
- en: 'The cart itself is a grid showing the products in the cart and the quantity
    of each. It''s enclosed in a window with a couple of action buttons at the bottom
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车本身是一个网格，显示购物车中的产品和每个产品的数量。它被包含在一个窗口中，底部有几个操作按钮，如下所示：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Within the grid, we have used the `cellediting` plugin that allows the user
    to tap the quantity column and use the plus or minus icons that Ext JS provides
    on the touch-friendly theme to adjust the item quantity. When the quantity is
    edited and the `edit` event fires on the grid, we immediately commit the change
    to the cart store, which is bound to the grid from the parent view model.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格中，我们使用了`cellediting`插件，允许用户轻触数量列并使用Ext JS在触摸友好主题中提供的加号和减号图标来调整项目数量。当数量被编辑并且网格上的`edit`事件被触发时，我们立即将更改提交到购物车存储，该存储与父视图模型绑定。
- en: Note that there is no specific view model for this view. Instead, as we instantiated
    this window within the constructor of the main view, it'll inherit the main view
    model. This means that we can share the cart store with multiple components by
    having it high up in the view model hierarchy.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个视图没有特定的视图模型。相反，由于我们在主视图的构造函数中实例化了此窗口，它将继承主视图模型。这意味着我们可以通过在视图模型层次结构中将其放置得更高来与多个组件共享购物车存储。
- en: 'Let''s move on to the cart view controller, as shown in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到购物车视图控制器，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We wire up event handlers for the window's buttons by using `itemId`, which
    we defined in the view as the selector. The `onCartClose` method is straightforward,
    but the `onOrderNow` one is a little more interesting.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用在视图中定义的选择器`itemId`来为窗口的按钮连接事件处理器。`onCartClose`方法很简单，但`onOrderNow`方法则更有趣。
- en: 'It first determines if the user is logged in by checking whether `currentUser`
    on the view model is `null`. If the user is not logged in, a `loginrequired` event
    will be fired; if you remember, we handled this earlier in the main view controller.
    If the user is logged in, we perform the following actions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先通过检查视图模型上的`currentUser`是否为`null`来确定用户是否已登录。如果用户未登录，将触发`loginrequired`事件；如果您还记得，我们之前在主视图控制器中处理了这个问题。如果用户已登录，我们将执行以下操作：
- en: Call the `toOrder` method from the cart store to get an `Order` model
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从购物车存储调用`toOrder`方法以获取`Order`模型
- en: Remove all the items from the cart
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从购物车中移除所有项目
- en: Add the new `Order` model to the orders store on the view model
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的`Order`模型添加到视图模型上的订单存储
- en: Show a toast notification to the user
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户显示一个吐司通知
- en: Hide the cart window
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏购物车窗口
- en: All of this results in the cart being moved to an order. In a comprehensive
    e-commerce application, this is the bit that will be replaced by credit card capturing
    and payment processing, but we've taken the simple approach here, that is, composing
    various calls to other classes to perform the action we need.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些最终导致购物车被移动到一个订单。在一个全面的电子商务应用中，这部分将由信用卡捕获和支付处理所取代，但在这里我们采取了简单的方法，即通过调用其他类的方法来执行我们需要的操作。
- en: As previously discussed, the cart view doesn't have its own view model because
    it inherits from its parent, so we'll now move on to the final view in the application;
    the account window.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，购物车视图没有自己的视图模型，因为它继承自父视图，所以我们现在将转向应用中的最后一个视图；账户窗口。
- en: The account window
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 账户窗口
- en: 'The account view is a window that contains several subcomponents (such as login,
    register, and past orders). Let''s take a look at the lengthy, but straightforward
    code for it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 账户视图是一个包含多个子组件（如登录、注册和过往订单）的窗口。让我们看看它的冗长但直接的代码：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We've got two panels here, both set to use a `column` layout. One contains the
    login and registration forms and is shown when the user is logged out. Another
    shows the registration form repurposed as a way to let the user edit their profile
    details and the past orders. The second panel is only shown when the user is logged
    in.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个面板，都设置为使用`column`布局。一个包含登录和注册表单，当用户注销时显示。另一个显示注册表单，作为让用户编辑其个人资料详情和过往订单的方式。第二个面板仅在用户登录时显示。
- en: The hiding and showing of components in the account window is accomplished by
    binding the `hidden` config to `currentUser` at the top-level main view model.
    Ext JS converts the user object to a "truthy" value, that is, either true or false.
    This is used to set the component's visibility.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在账户窗口中隐藏和显示组件是通过将`hidden`配置绑定到顶级主视图模型中的`currentUser`来实现的。Ext JS将用户对象转换为“真值”，即true或false。这用于设置组件的可见性。
- en: 'Next, we have the `login` component, which is just an `Ext.FormPanel` with
    the relevant fields along with a little bit of explanatory text, as shown in the
    following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`login`组件，它只是一个带有相关字段和一些解释性文本的`Ext.FormPanel`，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we have the `register` component, another form containing the fields
    that a user must complete in order to sign up:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个`register`组件，另一个包含用户必须完成以注册的字段的表单：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The final piece of the account user interface is the past orders component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 账户用户界面的最后一部分是过往订单组件：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we use DataView with `itemTpl` configured to output all of the orders
    as well as loop through the items within this order. As none of the past orders
    are clickable, there's no detail view for orders to click on to. Therefore, we
    need to specify a fake `itemSelector`. Binding this component's store to the orders
    store on the view model was performed in the containing account window.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用配置了`itemTpl`的数据视图来输出所有订单以及遍历此订单内的项目。由于过往订单均不可点击，因此没有可点击的订单详情视图。因此，我们需要指定一个假的`itemSelector`。在包含的账户窗口中将此组件的存储绑定到视图模型上的订单存储。
- en: 'Finally, we have a simple view controller to handle interactions with the account
    window, as shown in the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个简单的视图控制器来处理与账户窗口的交互，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is standard stuff in `onAccountClose`, but in `onLoginRegister`, we perform
    a very naïve login action in which the `currentUser` gets set to an object with
    the e-mail address that the user entered for login or registration. As previously
    discussed, we're bypassing a full authentication system for simplicity, but this
    demonstrates the general idea, that is, perform an action that ends up with a
    user being set on the inherited view model. Once again, you'll see that we don't
    have a separate account view model as everything's passed up and down to the one
    that's defined on the main view.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onAccountClose`中，这是标准操作，但在`onLoginRegister`中，我们执行了一个非常简单的登录操作，其中`currentUser`被设置为用户为登录或注册输入的电子邮件地址的对象。如前所述，我们为了简单起见绕过了完整的认证系统，但这演示了基本思想，即执行一个最终将用户设置在继承的视图模型上的操作。再次强调，您将看到我们没有单独的账户视图模型，因为所有内容都是向上和向下传递到主视图上定义的那个。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter's been a whistle-stop tour through a set of features and ideas
    that we should already be familiar with. It was a consolidation of the work we've
    done over the past few chapters and a demonstration of how to build an application
    with multiple views, but with a low level of complexity.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了我们应已熟悉的特性和想法。这是过去几章工作的总结，以及如何以低复杂度构建具有多个视图的应用程序的演示。
- en: In the next chapter, we'll be moving on from full applications and looking at
    performance and debugging considerations involved in an Ext JS project. How can
    we design our applications to help developers when issues arise? How can we try
    and make sure our application feels responsive to end users? We'll also be looking
    at these questions in-depth in the next chapter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从完整的应用程序转向查看Ext JS项目中涉及的性能和调试考虑。我们如何设计我们的应用程序以帮助开发者解决问题？我们如何尝试确保我们的应用程序对最终用户来说感觉响应迅速？我们将在下一章深入探讨这些问题。
