<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Assembling Chains</h1></div></div></div><p>So far, the examples we've looked at in this book used Lo-Dash functions independently of one another. That's not to say they're not working together; it's just that they could be cleaner, or more condensed. We would call the function to compute a value, store that value, call another function to compute a new value using the stored value as an argument, and repeat the same process. This is exhausting but can be easily remedied.</p><p>The idea is to streamline this functionality into a chain of calls. This approach follows the concept of applicative programming, whereby we have a starting collection and at each stage in the chain, that collection is transformed. It's like an assembly line where the resulting product is a value that you need in a given context.</p><p>Lo-Dash enables this mode of programming through the wrapper concept—a constructor function used to wrap primitive values that enable chained function calls. In this chapter, we'll see how we can use this approach to simplify complex code and even produce reusable components.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating Lo-Dash wrappers</li><li class="listitem" style="list-style-type: disc">Building filters</li><li class="listitem" style="list-style-type: disc">Testing truth conditions</li><li class="listitem" style="list-style-type: disc">Counting items</li><li class="listitem" style="list-style-type: disc">Transformations</li><li class="listitem" style="list-style-type: disc">Intermediary results</li><li class="listitem" style="list-style-type: disc">Keys and values</li><li class="listitem" style="list-style-type: disc">Returning chains</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Creating Lo-Dash wrappers</h1></div></div></div><p>In this section, we'll introduce the <a id="id310" class="indexterm"/>concept of wrapping values. Then we'll use the wrapper to chain function calls. We'll also look at how call chains are terminated.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Chained calls</h2></div></div></div><p>Chaining function <a id="id311" class="indexterm"/>calls together is a pattern of applicative programming, where a<a id="id312" class="indexterm"/> collection is transformed into something different. This newly transformed collection is then passed to the next call in the chain, and so on. This is where the term applicative comes from; you're applying functions to every item in a collection. Since this process is repeated over and over, it's easy to package chained calls into a reusable component. It's a pipeline that's adding, removing, or modifying values along each step of the way, producing a result at the end.</p><p>Another way, perhaps, is a more practical view of chains, which is just a simpler way to make function calls. jQuery popularized this notion. When reading jQuery code, you'll find that there are a lot of chained calls, and yet the code is readable. Often, chains can be built as a single statement, as shown in the following code:</p><div><pre class="programlisting">$('body')
    .children()
    .first()
    .is('h1');
// → true</pre></div><p>This jQuery chain consists of four calls, expressed as a single statement. The first call is to the jQuery constructor, which wraps the specified DOM elements. Next, we call <code class="literal">children()</code> to get the child elements. The <code class="literal">first()</code> function returns the first child element. The chain is terminated with a call to <code class="literal">is()</code>, which returns a simple Boolean value, not a jQuery object.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Take note of the code formatting here. If you're going to compose chains of functionality, it is important to keep your code readable. The main convention that I would recommend to follow is to indent chained calls on the next line. This way, you don't have statements that span an obnoxious number of columns, and you can tell at a glance that this chunk of code is a chain of function calls.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Wrapping values</h2></div></div></div><p>Wrapping<a id="id313" class="indexterm"/> values in Lo-Dash works<a id="id314" class="indexterm"/> pretty much the same as with jQuery. There's a wrapper call that constructs the jQuery/Lo-Dash object. Each <strong>chainable</strong> call<a id="id315" class="indexterm"/> returns a wrapper object. There's a terminating call that returns a primitive type. There are some obvious differences too, with regard to how jQuery and Lo-Dash wrap values. For instance, you can't pass a CSS selector string to the Lo-Dash wrapper function and expect it to wrap DOM elements. Nor would you want it to—Lo-Dash is a low-level utility library, whereas jQuery works at a fundamentally higher level of abstraction.</p><p>That's not the whole story of how wrapping values and applying function call chains work. There are subtle nuances and edge cases around every corner, all of which we'll address over the course of the chapter. But for now, let's get into the code:</p><div><pre class="programlisting">_(['a', 'b', 'c'])
    .at([1, 2])
    .value();
// → [ "b", "c" ]</pre></div><p>Here is our <a id="id316" class="indexterm"/>hello-world <a id="id317" class="indexterm"/>chain. The <code class="literal">_</code> object we've been using throughout the book to access the Lo-Dash API is also a constructor function. It takes a JavaScript primitive as an argument. This is the value that's wrapped and passed to the first function call in the chain. Here, we're calling the <code class="literal">at()</code> function, saying that we want the items at indices <code class="literal">1</code> and <code class="literal">2</code>. The call to <code class="literal">value()</code> gets us the result we're after.</p><p>The preceding code obviously doesn't warrant using a wrapper—there's only one function call. The point, however, isn't conciseness but rather the basic anatomy of a call chain. As we get to more elaborate examples throughout the chapter, we'll see how chains substantially reduce the amount of code written. Here are two more Lo-Dash wrapper constructors:</p><div><pre class="programlisting">_({a: 'b', c: 'd'})
    .contains('b');
// → true

_('abcd')
    .contains('b');
// → true</pre></div><p>The first wrapper uses a plain object as its primitive value. The second wrapper uses a string. The chain is terminated immediately in both cases because we're calling <code class="literal">contains()</code>, which itself returns a primitive Boolean value. Again, we didn't have to write the preceding code using wrappers and call chains. It's better that you don't if you're calling only one function, since you'd only be confusing other readers of your code otherwise. The point of the preceding code is to illustrate that we can wrap both plain objects and strings and treat them as collections.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Explicit and implicit chaining</h2></div></div></div><p>Once we have a Lo-Dash wrapper <a id="id318" class="indexterm"/>instance, we can start making chained function calls. However, not all of these functions are chainable. <strong>Non-chainable</strong> functions<a id="id319" class="indexterm"/> return primitive values such as Booleans or<a id="id320" class="indexterm"/> numbers. This is what is referred to as <a id="id321" class="indexterm"/>implicit chaining. It's implicit because functions that would return a collection actually return a Lo-Dash wrapper instance. Other functions don't have collections as return values. Calls to these functions will terminate the chain.</p><p>On the other hand, there's<a id="id322" class="indexterm"/> explicit chaining—this will keep the chain alive until it's explicitly terminated by calling <code class="literal">value()</code>. For example, if your chain is explicit, calling <code class="literal">contains()</code> will return a wrapper, instead of a Boolean as it normally would. The following are examples of implicit and explicit chaining:</p><div><pre class="programlisting">_([3,2,1])
    .sort()
    .first();
// → 1

_.chain([3,2,1])
    .sort()
    .first()
    .isNumber()
    .value();
// → true</pre></div><p>The first chain uses the default Lo-Dash chaining configuration. The <code class="literal">first()</code> function grabs the first item in an array and returns it. Since this item could be anything (in this case, it's a number), the <code class="literal">first()</code> function isn't chainable. We don't need to make an explicit call to <code class="literal">value()</code> since functions that aren't chainable return <a id="id323" class="indexterm"/>
<strong>unwrapped</strong> values. The second chain, however, uses explicit chaining. This is done by constructing the Lo-Dash wrapper instance with the <code class="literal">chain()</code> function. The resulting wrapper is the same in every way, except that we need to make an explicit call to <code class="literal">value()</code> to unwrap the value. With explicit chaining, every function is chainable. For example, the call to <code class="literal">first()</code> now returns a wrapper instance instead of a number. This is also done by <code class="literal">isNumber()</code>.</p><p>The main reason you would want to use explicit chains like this is to avoid temporary variables and additional statements after the chain is complete. In the explicit chain in the preceding code, for instance, we just need to know whether the first item in the sorted collection is a number or not. There's no need to store the first item in a new variable if we can get exactly what we're after from the chain.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Building filters</h1></div></div></div><p>A powerful use of chained function <a id="id324" class="indexterm"/>calls is building filters that successively filter out unwanted items from a larger collection. Let's say that you already have a piece of code that's using the <code class="literal">filter()</code> function<a id="id325" class="indexterm"/> on a collection. But now you need to alter that filtering operation, perhaps by adding additional constraints. Rather than messing around with the existing <code class="literal">filter()</code> code that you know works, you can build a filter chain.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Multiple filter() calls</h2></div></div></div><p>The simplest approach to assembling<a id="id326" class="indexterm"/> filter chains is to join together multiple calls to the <code class="literal">filter()</code> function. Here's an example of what that might look like:</p><div><pre class="programlisting">var collection = [
    { name: 'Ellen', age: 20, enabled: true },
    { name: 'Heidi', age: 24, enabled: false },
    { name: 'Roy', age: 21, enabled: true },
    { name: 'Garry', age: 23, enabled: false }
];

_(collection)
    .filter('enabled')
    .filter(function(item) {
        return item.age &gt;= 21;
    })
   .value();
// → [ { name: "Roy", age: 21, enabled: true } ]</pre></div><p>The first call to <code class="literal">filter()</code>uses the pluck-style shorthand on the <code class="literal">enabled</code> property, which filters out items with false values for this property. The next call to <code class="literal">filter()</code> uses a callback function that filters out items where the <code class="literal">age</code> property value is less than <code class="literal">21</code>. We're left with a single item, which is unwrapped by calling <code class="literal">value()</code>.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>So what's the point of two or more calls to <code class="literal">filter()</code> when we could just modify the callback function? Wouldn't that mean less code and faster execution? The real advantage is in reading and modifying this code. Do we want to see what happens when we remove the enabled filter? Just comment out the line. Readability and maintainability should almost always trump attempts to squeeze performance out of complicated callback functions. Of course, there are exceptions to this, but don't invent performance issues for the sake of it.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Combining filter() with where()</h2></div></div></div><p>The <code class="literal">where()</code> function is an <a id="id327" class="indexterm"/>expressive means to filter a<a id="id328" class="indexterm"/> collection using logical <code class="literal">and</code> conditions. Rather than trying to express all of your query constraints in a single <code class="literal">filter()</code> callback function, why not utilize the <code class="literal">where()</code> notation where it makes sense? Let's see this in action:</p><div><pre class="programlisting">var collection = [
    { name: 'Janice', age: 38, gender: 'f' },
    { name: 'Joey', age: 20, gender: 'm' },
    { name: 'Lauren', gender: 'f' },
    { name: 'Drew', gender: 'm' }
];

_(collection)
    .where({ gender: 'f' })
    .filter(_.flow(_.property('age'), _.isFinite))
    .value();
// → [ { name: "Janice", age: 38, gender: "f" } ]</pre></div><p>This filter will include all female items and is a good candidate for the <code class="literal">where()</code> function. Next, we'd like to make sure that all items have an <code class="literal">age</code> property whose value is a finite number. We do this by composing a callback function that's passed to <code class="literal">filter()</code>. We're utilizing a couple of shortcuts here instead of defining our own inline callback function. The <code class="literal">flow()</code> function will construct a function for us, letting the result flow to each function argument we give it. We use the <code class="literal">property()</code> function to build a function that gets us the <code class="literal">age</code> property for each item, and gets passed to the <code class="literal">isFinite()</code> function. There are a couple of items in our collection that don't have <code class="literal">age</code> properties. These undefined values don't pass the test and are filtered out.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>The ordering of chained filter functions can be important. For example, it's wise to filter broadly first. That way, your collection shrinks in size faster as it flows through the pipeline, which means less work for other functions. Where this matters isn't immediately apparent, but as your code matures, you'll start to notice ordering tweaks. The nice thing about chained structures in your code is that order changes are trivial.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Dropping and taking collection items</h2></div></div></div><p>Lo-Dash has tools that let us <a id="id329" class="indexterm"/>filter collections from either the beginning or the end of a <a id="id330" class="indexterm"/>collection. These tools are especially useful in the context of function call chains, since using them usually depends on a prior transformation of the collection. For example, consider the sort order in the following code:</p><div><pre class="programlisting">var collection = [
    { first: 'Dewey', last: 'Mills' },
    { first: 'Charlene', last: 'Larson' },
    { first: 'Myra', last: 'Gray' },
    { first: 'Tasha', last: 'Malone' }
];

_(collection)
    .sortBy('first')
    .dropWhile(function(item) {
        return _.first(item.first) &lt; 'F';
    })
    .value();
// → 
// [
//   { first: "Myra", last: "Gray" },
//   { first: "Tasha", last: "Malone" }
// ]</pre></div><p>The first call in this <a id="id331" class="indexterm"/>chain sorts the collection by the <code class="literal">first</code> property <a id="id332" class="indexterm"/>using the <code class="literal">sortBy()</code> function. Now that the collection is sorted, we can call <code class="literal">dropWhile()</code>. Starting from the left-hand side, this function drops items from the collection until the callback returns <code class="literal">true</code>. Our particular callback gets the first character of the name string, and if it is less than <code class="literal">F</code>, we drop it. This leaves us with a collection that only has first names starting with <code class="literal">F</code> and above.</p><p>In addition to dropping items from the left-hand side of the collection, we can drop items from the right-hand side. Alternatively,  we can combine the two approaches using a chain, as shown in the following code:</p><div><pre class="programlisting">var name = '  Donnie Woods   ',
    emptyString = _.partial(_.isEqual, ' ');

_(name)
    .toArray()
    .dropWhile(emptyString)
    .dropRightWhile(emptyString)
    .join('');
// → "Donnie Woods"</pre></div><p>Here, we're wrapping a string value instead of an array, emulating the functionality of <code class="literal">String.trim()</code>. So the first task for our chain is to use <code class="literal">toArray()</code> to split the string into individual characters. The drop functions expect an array. Next, we use the <code class="literal">dropWhile()</code> function and pass it our <code class="literal">emptyString()</code> callback function. This will drop characters from the string until it finds an actual character. It then uses <code class="literal">dropRightWhile()</code> to perform the same task but from the opposite side of the array, moving in the opposite <a id="id333" class="indexterm"/>direction. Lastly, we join the array back together as a<a id="id334" class="indexterm"/> string, minus the empty characters that have been dropped from either end.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>Yes, you can get the same result using a regular expression and condensed code. Regular expressions are great, but they're not for everyone, and they only work with strings. Weigh your options before going in either direction.</p></div></div><p>We can perform the inverse of dropping items from either end of an array. We can take items, thus dropping everything else. For example:</p><div><pre class="programlisting">var collection = [
    { name: 'Jeannie', grade: 'B+' },
    { name: 'Jeffrey', grade: 'C' },
    { name: 'Carrie', grade: 'A-' },
    { name: 'James', grade: 'A' }
];

_(collection)
    .sortBy('grade')
    .takeWhile(function(item) {
        return _.first(item.grade) === 'A';
    })
    .value();
// → 
// [
//   { name: "James", grade: "A" },
//   { name: "Carrie", grade: "A-" }
// ]</pre></div><p>We're only interested in items with <code class="literal">A</code> grades. The callback function we're using with <code class="literal">takeWhile()</code> returns <code class="literal">true</code> for items that have an <code class="literal">A</code>. Of course, this only works because the first step in the chain was to sort the array by the <code class="literal">grade</code> property. Had we not done that first, we would end up missing the items we're looking for.</p><p>Items can also be taken from the collection in the opposite direction. That is, instead of moving from left to right, we move from right to left. This is ideal when ordering is important and you don't want to perform additional steps to take what you need from the collection. This ordering is shown in the following code:</p><div><pre class="programlisting">var collection = _.sample(_.range(1, 21), 10),
    total = 5,
    min = 10;

_(collection)
    .sortBy()
    .takeRightWhile(function(item, index, array) {
        return item &gt;= min &amp;&amp;
            array.length - index &lt;= total;
    })
    .value();
// → [ 13, 14, 15, 17, 20 ]</pre></div><p>The collection used<a id="id335" class="indexterm"/> here is a random sampling of 10 integers. The first <a id="id336" class="indexterm"/>call in our chain is to <code class="literal">sortBy()</code>, which simply sorts the array with no arguments supplied. This is in ascending order and we want the top five items. We could have reversed the sort order, but instead, we're skipping that step and jumping right into the <code class="literal">takeRightWhile()</code> function. The callback used here will return numbers as long as the number is larger than <code class="literal">min</code> and as long as we haven't exceeded the total.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Rejecting items</h2></div></div></div><p>Rejecting works much in the <a id="id337" class="indexterm"/>same way as filtering does. In the case of filtering, you know what <a id="id338" class="indexterm"/>you want. In the case of rejecting, you know what you don't want. These rejection operations can be chained together to build complex queries, as shown in the following code:</p><div><pre class="programlisting">var object = {
    first: 'Conrad',
    last: 'Casey',
    age: 37,
    enabled: true
};

_(object)
    .reject(_.isBoolean)
    .reject(_.isString)
    .first()
    .toFixed(2);
// → "37.00"</pre></div><p>Here we're chaining together two <code class="literal">reject()</code> calls. The wrapped value is an object and we're only after those property values that aren't Booleans or strings. These functions—<code class="literal">isBoolean()</code> and <code class="literal">isString()</code>—already exist as a part of the Lo-Dash API, and we can just pass them directly to <code class="literal">reject()</code>. There's no need to write our own callback functions here.</p><p>We can use the <code class="literal">result()</code> function to help us reject collection items in a chain. The <code class="literal">result()</code> function works in the same way, whether the specified property value is a function or a non-callable<a id="id339" class="indexterm"/> value. Here's an illustration of the differences in calling <code class="literal">reject()</code> using<a id="id340" class="indexterm"/> <code class="literal">result()</code> or just a property name:</p><div><pre class="programlisting">function User(name, disabled) {
    this.name = name;
    this.disabled = disabled;
}

User.prototype.enabled = function() {
    return !this.disabled;
};

var collection = [
        new User('Phil', true),
        new User('Wilson', false),
        new User('Kathey', true),
        new User('Nina', false)
    ],
    enabled = _.flow(_.identity,
        _.partialRight(_.result, 'enabled'));

_(collection)
    .reject('disabled')
    .value();
// →
// [
//   { name: "Wilson", disabled: false },
//   { name: "Nina", disabled: false }
// ]

_(collection)
    .reject(_.negate(enabled))
    .value();
// →
// [
//   { name: "Wilson", disabled: false },
//   { name: "Nina", disabled: false }
// ]</pre></div><p>The <code class="literal">User</code> instances have a <code class="literal">disabled</code> property, and the <code class="literal">enabled()</code> method returns <code class="literal">true</code> if <code class="literal">disabled</code> is false. The <code class="literal">collection</code> variable holds an array of these <code class="literal">User</code> instances. The <code class="literal">enabled()</code> function is something we construct ourselves. We'll use it as a callback with <code class="literal">reject()</code>. This function uses <code class="literal">result()</code> to get the <code class="literal">enabled()</code> value from each item in the collection. The <code class="literal">identity()</code> function is used here as a trick to get <code class="literal">partialRight()</code> to work as a callback for <code class="literal">reject()</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Using initial() and rest()</h2></div></div></div><p>The <code class="literal">initial()</code> function<a id="id341" class="indexterm"/> takes everything but the last element—this can be combined with<a id="id342" class="indexterm"/> chained operations in interesting ways. For example, let's say we have a simple string we need to clean up:</p><div><pre class="programlisting">var string = 'abc\n';

_(string)
    .slice()
    .initial()
    .join('');
// → "abc"</pre></div><p>If we know the string is always <a id="id343" class="indexterm"/>going to end with something we don't care about, this is an easy way to drop that off. The same code works with arrays too; we're not limiting ourselves to strings. For example, the <code class="literal">slice()</code> function<a id="id344" class="indexterm"/> is a part of the chain and it makes the chain work with strings. If we passed an array, <code class="literal">slice()</code> wouldn't have any impact—the same code would still work. However, we might want to remove it later on, along with the <code class="literal">join()</code> call. Given the way our chain code is formatted, this is simple to do.</p><p>The inverse of <code class="literal">initial()</code> is <code class="literal">rest()</code>—it takes everything in the array but the first item. Just like the case in which we don't care about the last item, there could be cases where we don't care about the first item. An illustration of using <code class="literal">rest()</code> is as follows:</p><div><pre class="programlisting">var collection = [
    { name: 'init', task: _.noop },
    { name: 'sort', task: _.random },
    { name: 'search', task: _.random }
];

_(collection)
    .rest()
    .invoke('task')
    .value();
// → [ 1, 1 ]</pre></div><p>This collection has objects with <code class="literal">task()</code> methods. The collection is ordered, so the first task is always going to be the <code class="literal">init</code> task, which we don't care about because it's a <code class="literal">noop()</code> function. We test this by chaining <code class="literal">invoke()</code> to the <code class="literal">rest()</code> function, which if all goes well, we should end up with an array of random numbers, and no undefined values.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Testing truth conditions</h1></div></div></div><p>Beyond simply<a id="id345" class="indexterm"/> filtering collections, you often need to test a condition of a collection. This could include filtering a collection, and then answering a simple yes/no about the results. In those cases where you need to check a truth condition of a collection, it's often easier to perform the test at the end of a chain. There's usually no need to write several statements and allocate several variables along the way.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Testing if a collection contains an item</h2></div></div></div><p>Perhaps, the most <a id="id346" class="indexterm"/>straightforward test we can perform is whether or not a collection contains an item we're looking for. The <code class="literal">contains()</code> function<a id="id347" class="indexterm"/> is handy in cases like these because it is easy to attach to the end of a chain that's performing some other operations beforehand. One use of <code class="literal">contains()</code> is shown in the following example:</p><div><pre class="programlisting">var string = 'abc123',
    array = [ 'a', 'b', 'c', 1, 2, 3 ];

_(string)
    .filter(_.isString)
    .contains('c');
// → true

_(array)
    .filter(_.isString)
    .contains('c');
// → true</pre></div><p>There are two collections in the code—a string and an array. Both chains that follow are identical, aside from wrapping different values. However, both return <code class="literal">true</code> in this case, since the string has <code class="literal">c</code> and so does the array.</p><p>It's always good practice to use functions such as <code class="literal">contains()</code> if all you care about is testing for the item's existence. These functions will stop looping early, or short-circuit, if a value is found, saving valuable CPU cycles.</p><p>Often, you don't have the exact value. Instead you have query constraints but you're still only interested in whether they're satisfied, and not the data itself. This can be accomplished using the <code class="literal">find()</code> and <code class="literal">filter()</code> methods:</p><div><pre class="programlisting">var string = 'Dana Porter',
    array = [
        { name: 'Luis', gender: 'm' },
        { name: 'Rhonda', gender: 'f' },
        { name: 'Kirk', gender: 'm' },
        { name: 'Emily', gender: 'f' }
    ];

_(string)
    .chain()
    .filter(function(item) {
        return item.toUpperCase() === 'A';
    })
    .size()
    .isEqual(2)
    .value();
// → true

!!(_(array)
    .find(function(item) {
        return _.first(item.name).toUpperCase() === 'R' &amp;&amp;
            item.gender === 'f';
    }));
// → true</pre></div><p>The first chain in this<a id="id348" class="indexterm"/> code is for a string value. Notice how we've used <code class="literal">chain()</code> here to enable explicit chaining—meaning we'll have to explicitly call <code class="literal">value()</code> at the end to unwrap the result. The <code class="literal">filter()</code> call here returns items that match <code class="literal">A</code>. We do this so that we can count how many of them there are in the chain. In this case, the string passes the test because there are two <code class="literal">A</code> characters. The downside is that we're looking for an exact number—<code class="literal">2</code>. The <code class="literal">filter()</code> function will keep filtering away long after we've found two items.</p><p>The second chain uses a wrapped array. Here we're transforming the result of calling <code class="literal">find()</code> into a Boolean value. Here we're able to use more elaborate query conditions.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Everything or anything is true</h2></div></div></div><p>Our final look at checking <a id="id349" class="indexterm"/>truth conditions in this chapter involves validating either one item at least or the collection in its entirety. That is, a collection might be considered valid if one or more items pass the test we give it. Or perhaps the requirements are more stringent and every item in the collection must pass the test in order to be considered valid. Let's see how these tests can be used in chains:</p><div><pre class="programlisting">var collection = [
    1414728000000,
    1383192000000,
    1351656000000,
    1320033600000
];

_(collection)
    .map(function(item) {
        return new Date(item);
    })
    .every(function(item) {
        return item.getMonth() === 9 &amp;&amp; item.getDate() === 31;
     });
// → true</pre></div><p>This collection contains timestamp numbers, and so the first call in the chain is to <code class="literal">map()</code>, transforming each collection item into a <code class="literal">Date</code> instance. Now that every item is a date, we can use <code class="literal">every()</code> to validate that in this collection, every day is Halloween.</p><p>Now let's look at using the <code class="literal">some()</code> function to terminate a chain. This will validate that at least one item passes the test and will stop looping as soon as one is found:</p><div><pre class="programlisting">var collection = [
    { name: 'Danielle', age: 34, skill: 'Backbone' },
    { name: 'Sammy', age: 19, skill: 'Ember' },
    { name: 'Donna', age: 41, skill: 'Angular' },
    { name: 'George', age: 17, skill: 'Marionette' }
];

_(collection)
    .reject({ skill: 'Ember' })
    .reject({ skill: 'Angular' })
    .some(function(item) {
        return item.age &gt;= 25;
    });
// → true</pre></div><p>You can see that after<a id="id350" class="indexterm"/> rejecting <code class="literal">Ember</code> and <code class="literal">Angular</code> enthusiasts, we make sure that there's at least one <code class="literal">Backbone</code> or <code class="literal">Marionette</code> programmer who is at least <code class="literal">25</code> years old.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Counting items</h1></div></div></div><p>A variation on the <a id="id351" class="indexterm"/>previous topic—<em>Testing truth conditions</em>—is counting items in a collection after their values have moved through a processing chain. For example, we might need to know how many items in a collection meet the given criteria. We can get that number using a call chain.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Using length and size()</h2></div></div></div><p>The <code class="literal">size()</code> function<a id="id352" class="indexterm"/> is handy because we can call it directly on a Lo-Dash wrapper. This is the <a id="id353" class="indexterm"/>preferred way to count the resulting items<a id="id354" class="indexterm"/> in our collection<a id="id355" class="indexterm"/> after our chain runs:</p><div><pre class="programlisting">var object = { first: 'Charlotte', last: 'Hall' },
    array = _.range(10);

_(object)
    .omit('first')
    .size();
// → 1

_(array)
    .drop(5)
    .size();
// → 5</pre></div><p>Here, we have <code class="literal">array</code> and <code class="literal">object</code>. The first chain uses the <code class="literal">size()</code> function to count the number of properties after omitting the <code class="literal">first</code> property. The second chain wraps the array and, after dropping <code class="literal">5</code> items, counts what's left.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>We can use the <code class="literal">length</code> property, but we have to call <code class="literal">value()</code> first. Using <code class="literal">size()</code> is just a shortcut.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Grouping using countBy()</h2></div></div></div><p>We can also<a id="id356" class="indexterm"/> count more than one item. That is, given a collection, we <a id="id357" class="indexterm"/>can divide it into groups and then count the number of items in each group. Using chains, we can write some fairly sophisticated code:</p><div><pre class="programlisting">var collection = [
    { name: 'Pamela', gender: 'f' },
    { name: 'Vanessa', gender: 'f' },
    { name: 'Gina', gender: 'f' },
    { name: 'Dennis', gender: 'm' }
];

_(collection)
    .countBy('gender')
    .pairs()
    .sortBy(1)
    .reverse()
    .pluck(0)
    .value();
// → [ "f", "m" ]</pre></div><p>This chain kicks off by grouping the collection by the <code class="literal">gender</code> property. Next, we use the <code class="literal">pairs()</code> function to get an array of arrays. We do this so that we can sort the groups by the number of items in them. With the collection sorted, we can pluck the values we're interested in. In this <a id="id358" class="indexterm"/>case, the <code class="literal">f</code> gender is first since that group has a <a id="id359" class="indexterm"/>higher count.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>The preceding code uses two interesting tricks. Firstly, we're passing a numerical index to the <code class="literal">sortBy()</code> function. Since keys are accessed in the same way as indices, this works as expected. Secondly, we're passing a numerical index to the <code class="literal">pluck()</code> function and this works for the same reason as the <code class="literal">sortBy()</code> function.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Reducing collections</h2></div></div></div><p>Our final approach to counting items <a id="id360" class="indexterm"/>in chaining operations is to reduce the collection. This is useful when you want to reduce the entire collection to a sum computed using more involved functions that are applied to each item. Collections can be reduced with the following code:</p><div><pre class="programlisting">var collection = [
    { name: 'Chad', skills: [ 'backbone', 'lodash' ] },
    { name: 'Simon', skills: [ 'html', 'css', 'less' ] },
    { name: 'Katie', skills: [ 'grunt', 'underscore' ] },
    { name: 'Jennifer', skills: [ 'css', 'grunt', 'less' ] }
];

_(collection)
    .pluck('skills')
    .reduce(function(result, item) {
        return _.size(item) &gt; 2 &amp;&amp;
            _.contains(item, 'grunt') &amp;&amp;
            result + 1;
    }, 0);
// → 1</pre></div><p>Here, we're plucking the <code class="literal">skills</code> property from each item in the collection. We're interested in knowing two things about the <code class="literal">skills</code> value: does it contain the string <code class="literal">grunt</code>? And does it have more than <code class="literal">2</code> items? If these criteria are met, then we increment the reduced sum value that's returned by the <code class="literal">reduce()</code> call.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Transformations</h1></div></div></div><p>Now it's time for us to look at transformations<a id="id361" class="indexterm"/> that happen to data as it passes through the processing pipelines we construct. What's interesting about Lo-Dash and how it transforms data in chains is that the original collection isn't modified—a new one is constructed. This reduces side effects and is fundamental to the immutability concept in other functional programming languages.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Building groups, unions, and unique values</h2></div></div></div><p>Some of the most <a id="id362" class="indexterm"/>powerful transformation tools found in Lo-Dash can <a id="id363" class="indexterm"/>be used out of the box with very little effort. These include <a id="id364" class="indexterm"/>grouping collection items by a specific value<a id="id365" class="indexterm"/> they contain, joining arrays together while retaining only unique values, and removing any duplicates from arrays. For example:</p><div><pre class="programlisting">var collection = [
    { name: 'Rudolph', age: 24 },
    { name: 'Charles', age: 43 },
    { name: 'Rodney', age: 37 },
    { name: 'Marie', age: 28 }
];
    
_(collection)
    .map(function(item) {
        var experience = 'seasoned veteran';
        if (item.age &lt; 30) {
            experience = 'noob';
        } else if (item.age &lt; 40) {
            experience = 'geek cred';
        }
        return _.extend({
            experience: experience
        }, item);
    })
    .groupBy('experience')
    .map(function(item, key) {
        return key +
            ' (' + _.pluck(item, 'name').join(', ') + ')';
    })
    .value();
// →
// [
//   "noob (Rudolph, Marie)",
//   "seasoned veteran (Charles)",
//   "geek cred (Rodney)"
// ]</pre></div><p>This chain wraps a collection of plain objects, and the first call in the chain maps the <code class="literal">item</code> object to an extended version of it. We're calculating a string version of their <code class="literal">experience</code> property and assigning that to a new property. Next, we use the <code class="literal">groupBy()</code> function to group the collection by this new <code class="literal">experience</code> property. The last step in this chain is to use <code class="literal">map()</code> again to generate a string representation of the various experience groups.</p><p>Using <code class="literal">union()</code> to join arrays together can come in handy if you've already got a wrapped array and you need to ensure it has certain values, but also ensure that those values aren't duplicated. The application of <code class="literal">union()</code> is shown in the following example:</p><div><pre class="programlisting">var collection = _.sample(_.range(1, 101), 10);

_(collection)
    .union([ 25, 50, 75])
    .sortBy()
    .value();
// → [ 1, 3, 21, 25, 27, 37, 40, 50, 57, 73, 75, 94 ]</pre></div><p>You can see that our<a id="id366" class="indexterm"/> wrapped array, a sampling of 10 random numbers, is<a id="id367" class="indexterm"/> joined with another array using the <code class="literal">union()</code> function. We<a id="id368" class="indexterm"/> then return the sorted result. If you examine the output, you'll notice it'll always have <code class="literal">25</code>, <code class="literal">50</code>, and <code class="literal">75</code>. You'll also notice that these numbers are never duplicated.</p><p>Finally, if you have a collection of values and you just need the duplicates removed, the <code class="literal">uniq()</code> function allows you to do that as a step in your chained processing:</p><div><pre class="programlisting">function name(item) {
    return item.first + ' ' + item.last;
}

var collection = [
    { first: 'Renee', last: 'Morris' },
    { first: 'Casey', last: 'Wise' },
    { first: 'Virginia', last: 'Grant' },
    { first: 'Toni', last: 'Morris' }
];

_(collection)
    .uniq('last')
    .sortBy('last')
    .value();
// →
// [
//   { first: "Virginia", last: "Grant" },
//   { first: "Renee", last: "Morris" },
//   { first: "Casey", last: "Wise" }
// ]

_(collection)
    .uniq(name)
    .sortBy(name)
    .value();
// →
// [
//   { first: "Casey", last: "Wise" },
//   { first: "Renee", last: "Morris" },
//   { first: "Toni", last: "Morris" },
//   { first: "Virginia", last: "Grant" }
// ]

_(collection)
    .map(name)
    .uniq()
    .sortBy()
    .value();
// →
// [
//   "Casey Wise",
//   "Renee Morris",
//   "Toni Morris",
//   "Virginia Grant"
// ]</pre></div><p>We're seeing three<a id="id369" class="indexterm"/> different approaches to extracting the unique values <a id="id370" class="indexterm"/>from the wrapped collection. The first uses the <a id="id371" class="indexterm"/>pluck-style shorthand to filter out duplicates. Since we passed it the string <code class="literal">last</code>, it'll look for unique values in this property. The second approach passes in a callback function, which joins together the <code class="literal">first</code> and the <code class="literal">last</code> name properties. Note that this same function is used by the <code class="literal">sortBy()</code> call in the same chain. The last approach doesn't pass any arguments to <code class="literal">uniq()</code> because the first step in the chain maps our array of objects to an array of strings.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Plucking values</h2></div></div></div><p>Often, within your <a id="id372" class="indexterm"/>chains of functionality, you'll realize that you don't need the entirety of every object in your collection. This can make what you're doing later on in the chain much simpler. To pluck values, the following code can be used:</p><div><pre class="programlisting">var collection = [
    { gender: 'f', dob: new Date(1984, 3, 8) },
    { gender: 'm', dob: new Date(1983, 7, 16) },
    { gender: 'f', dob: new Date(1987, 2, 4) },
    { gender: 'm', dob: new Date(1988, 5, 2) }
];

_(collection)
    .where({ gender: 'm' })
    .pluck('dob')
    .map(function(item) {
        return item.toLocaleString();
    })
    .value();
// → [ "8/16/1983, 12:00:00 AM", "6/2/1988, 12:00:00 AM" ]</pre></div><p>Here, we're plucking<a id="id373" class="indexterm"/> the <code class="literal">dob</code> property values and this simplifies the <code class="literal">map()</code> handler that follows in the chain. Instead of having to look up the <code class="literal">dob</code> property, the item itself is the <code class="literal">dob</code> property value.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Creating arrays using without()</h2></div></div></div><p>If we need a new <a id="id374" class="indexterm"/>array constructed and there are certain <a id="id375" class="indexterm"/>values we know should not be present as<a id="id376" class="indexterm"/> items, we can use the <code class="literal">without()</code> function. This is typically the first action in a chain, since it creates a new array, but it's not always the first. Let's see an example of this:</p><div><pre class="programlisting">var collection = _.range(1, 11);

return _(collection)
    .without(5, _.first(collection), _.last(collection))
    .reverse()
    .value();
// → [ 9, 8, 7, 6, 4, 3, 2 ]</pre></div><p>The wrapped collection in this code includes the numbers <code class="literal">1</code> through <code class="literal">10</code>. The first call in our chain copies the items out of this array and places them in a new array, aside from the argument values passed to the <code class="literal">without()</code> function. These are not included in the new array.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Finding the min and max values</h2></div></div></div><p>With every collection, there's a<a id="id377" class="indexterm"/> minimum and a maximum value. Finding these<a id="id378" class="indexterm"/> values with Lo-Dash is easy; you just have to use the<a id="id379" class="indexterm"/> respective <code class="literal">min()</code> and<a id="id380" class="indexterm"/> <code class="literal">max()</code> functions. But what if you need to adjust the range for which you're seeking out the minimum values? Let's use the following code to perform this task:</p><div><pre class="programlisting">var collection = [
    { name: 'Daisy', wins: 10 },
    { name: 'Norman', wins: 12 },
    { name: 'Kim', wins: 8 },
    { name: 'Colin', wins: 4 }
];

_(collection)
    .reject(function(item) {
        return item.wins &lt; 5
    })
    .min('wins');
// → { name: "Kim", wins: 8 }</pre></div><p>In this example, we're not concerned with items that have a <code class="literal">win</code> count of less than <code class="literal">5</code>. So we know that the absolute minimum returned by this code will have <code class="literal">5</code> wins or more. After the invalid <code class="literal">win</code> counts have been rejected, we use the pluck style shorthand to find the minimum value based on the <code class="literal">wins</code> property.</p><p>The <code class="literal">max()</code> function can be used as a chain operation in a similar fashion:</p><div><pre class="programlisting">var collection = [
    { name: 'Kerry', balance: 500, credit: 344 },
    { name: 'Franklin', balance: 0, credit: 554 },
    { name: 'Lillie', balance: 1098, credit: 50 },
    { name: 'Clyde', balance: 473, credit: -900 }
];

_(collection)
    .filter('balance')
    .filter('credit')
    .max(function(item) {
        return item.balance + item.credit;
    });
// → { name: "Lillie", balance: 1098, credit: 50 }</pre></div><p>This collection has objects with the <code class="literal">balance</code> and <code class="literal">credit</code> properties. The first two chain operations use the <code class="literal">filter()</code> function to remove objects where either of these fields is false. The <code class="literal">max()</code> function then closes the chain. This time, we're using a callback function that allows us to map the values we want to compare in order to figure out the maximum value.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Finding the index</h2></div></div></div><p>Finding the index of a given<a id="id381" class="indexterm"/> element has its uses, and we can apply the <code class="literal">index()</code> function<a id="id382" class="indexterm"/> as a step in a call chain:</p><div><pre class="programlisting">function rank(coll, name) {
    return _(coll)
        .sortBy('score')
        .reverse()
        .pluck('name')
        .indexOf(name) + 1;
}

var collection = [
    { name: 'Ruby', score: 43 },
    { name: 'Robert', score: 59 },
    { name: 'Lindsey', score: 38 },
    { name: 'Marty', score: 55 }
];

rank(collection, 'Ruby');
// → 3

rank(collection, 'Marty');
// → 2</pre></div><p>The <code class="literal">rank()</code> function<a id="id383" class="indexterm"/> in this code accepts a <code class="literal">collection</code> argument and a <code class="literal">name</code> string. The function wraps the collection and uses a call chain to figure out the rank of the passed-in name, based on the <code class="literal">score</code> property. The first step is to sort the collection and then to reverse it so that it's in descending order based on the <code class="literal">score</code> property value. Next, we pluck the names from the collection, using the <code class="literal">pluck()</code> function, which maintains the sort order we just created. Now we can use <code class="literal">indexOf()</code> to figure out the rank of the given user.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Using difference() and xor()</h2></div></div></div><p>The last section of the <a id="id384" class="indexterm"/>transformations topic is<a id="id385" class="indexterm"/> using the <code class="literal">difference()</code> and the<a id="id386" class="indexterm"/> <code class="literal">xor()</code> functions to <a id="id387" class="indexterm"/>merge together the contents of two arrays. Both work similarly but with subtle differences that are worth noting and paying attention to. These functions are useful at the start of chains where you have to make sure that the wrapped array has only the necessary values. For example, let's say your array of numbers shouldn't have any odd values. Then we can use the following code for this condition:</p><div><pre class="programlisting">var collection = _.range(1, 51),
    odds = _.filter(_.range(1, 101), function(item) {
        return item % 2;
    });

_(collection)
    .difference(odds)
    .takeRight(10)
    .reverse()
    .value();
// → [ 32, 34, 36, 38, 40, 42, 44, 46, 48, 50 ]</pre></div><p>Our collection in this<a id="id388" class="indexterm"/> code consists of <code class="literal">50</code> numbers and the <code class="literal">odds</code> <a id="id389" class="indexterm"/>array contains odd numbers from <code class="literal">1</code> to <code class="literal">100</code>. Our<a id="id390" class="indexterm"/> chain starts off by calling the <code class="literal">difference()</code> function, passing<a id="id391" class="indexterm"/> in the <code class="literal">odds</code> array as an argument. Next, we take the top 10 items from the resulting array and sort them. The thing to notice about the result is that there are no values above 50 present. We've removed all odd numbers below 50, since that is the difference between the wrapped array and the array that was supplied as an argument. In other words, it's not a symmetrical difference. For that, we would use the <code class="literal">xor()</code> function in our chain:</p><div><pre class="programlisting">var collection = _.range(1, 26),
    evens = _.reject(_.range(1, 51), function(item) {
        return item % 2;
    });

_(collection)
    .xor(evens)
    .reverse()
    .value();
// → 
// [ 50, 48, 46, 44, 42, 40, 38, 36, 34, 32, 30, 28, 26,
//   25, 23, 21, 19, 17, 15, 13, 11, 9, 7, 5, 3, 1 ]</pre></div><p>This time, our collection is an array of numbers from <code class="literal">1</code> to <code class="literal">25</code> and the <code class="literal">evens</code> array holds even numbers from <code class="literal">2</code> to <code class="literal">50</code>. We're using the <code class="literal">xor()</code> function in our chain to join the collection with the <code class="literal">evens</code> array. The difference between this and the <code class="literal">difference()</code> function is that it'll include all the values in the <code class="literal">evens</code> array that go beyond <code class="literal">25</code>, since <code class="literal">xor()</code> will compute the symmetrical difference.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Intermediary results</h1></div></div></div><p>There are times when we don't want to wait<a id="id392" class="indexterm"/> until the call chain is terminated to have access to values computed at any given step along the way. Think about cases where the intermediate value produced by a function in the chain should be used by another function later in the chain. On other occasions, we need to completely override the value returned by the chain.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec82"/>Tapping into chains</h2></div></div></div><p>We can use the <code class="literal">tap()</code> function<a id="id393" class="indexterm"/> to inject our own callback function into the chain. This is different<a id="id394" class="indexterm"/> from the callbacks that we'd supply to other Lo-Dash functions. It doesn't alter the value as it flows through the chain of function calls. Instead, think of <code class="literal">tap()</code> as a way of intercepting values as they flow through the chain, and possibly reacting to them in some way. Let's see an example of this function:</p><div><pre class="programlisting">var collection = [
        { name: 'Stuart', age: 41 },
        { name: 'Leah', age: 26 },
        { name: 'Priscilla', age: 37 },
        { name: 'Perry', age: 31 }
    ],
    min,
    max;

_(collection)
    .filter(function(item) {
        return item.age &gt;= 30;
    })
    .tap(function(coll) {
        min = _.min(coll, 'age'),
        max = _.max(coll, 'age')
    })
    .reject(function(item) {
        return item.age === max.age;
    })
    .value();
// min → { name: "Perry", age: 31 }
// max → { name: "Stuart", age: 41 }
// → 
// [
//   { name: "Priscilla", age: 37 },
//   { name: "Perry", age: 31 }
// ]</pre></div><p>This code wraps our collection and filters out items younger than 30. Next, we use a <code class="literal">tap()</code> callback to set up our <code class="literal">min</code> and <code class="literal">max</code> variables. Note the scope of these variables; they're defined outside the chain, and are thus accessible to any future callbacks in the chain. And that's what we're doing here—we're rejecting any items where the <code class="literal">age</code> property equals the <code class="literal">max</code> age found. Note that the <code class="literal">max</code> value could turn out differently had we not computed it after the first<a id="id395" class="indexterm"/> filter<a id="id396" class="indexterm"/> in the chain.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>The only downside to this approach is that our chain is no longer a tightly encapsulated unit that can be moved around in our code. However, the trade-off is that we can elegantly compute the values needed for our chain on the fly. Something to keep in mind anyway, different programming styles may lean closer to one direction than others.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec83"/>Injecting values</h2></div></div></div><p>The other approach to<a id="id397" class="indexterm"/> manipulating what chains return at runtime is by using the <code class="literal">thru()</code> function. It behaves just like <code class="literal">tap()</code> but whatever is returned by this function becomes the new value:</p><div><pre class="programlisting">var collection = _.range(1, _.random(11)),
    result;
    
result = _(collection)
     .thru(function(coll) {
         return _.size(coll) &gt; 5 ? coll : [];
     })
     .reverse()
     .value();

_.isEmpty(result) ? 'No Results' : result.join(',');
// → "No Results"</pre></div><p>This chain is kicked off using the <code class="literal">thru()</code> function callback to validate the minimum size of the collection. If it is less than <code class="literal">5</code>, we don't even have to bother—we just return an empty array. It's important that we return something that'll work with the remaining chained functions, and an empty array fits the bill nicely. We're simply using <code class="literal">thru()</code> to state that any length less than <code class="literal">5</code> should have the same meaning as an empty array. This function is actually an ideal place in which to inject these nuanced business rules that often surface well after code is written.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Keys and values</h1></div></div></div><p>Now it's time to turn our attention to object keys and values and how they can be used in function call chains. Often, these involve wrapping a plain object in a Lo-Dash instance and then using <a id="id398" class="indexterm"/>the <code class="literal">keys()</code> or<a id="id399" class="indexterm"/> <code class="literal">values()</code> functions to bootstrap the processing. There are also times when you have a collection of objects and you want to work with certain property values only. For this purpose, there are the <code class="literal">pick()</code> and <code class="literal">omit()</code> functions that can be exercised in chains.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec84"/>Filtered keys and values</h2></div></div></div><p>We can use the result of a filtered array of object keys at a later point in the chain. This comes in handy when we're not exactly sure which keys are available and we only have a best guess. Let's try filtering by keys and values:</p><div><pre class="programlisting">var object = {
    firstName: 'Jerald',
    lastName: 'Wolfe',
    age: 49
};

_(object)
    .keys()
    .filter(function(item) {
        return (/name$/i).test(item);
    })
    .thru(function(items) {
        return _.at(object, items);
    })
    .value();
// → [ "Jerald", "Wolfe" ]</pre></div><p>The object we're wrapping has two property names that end in <code class="literal">name</code>. So we use the <code class="literal">keys()</code> function as the first step in the chain to grab all keys, and then we filter out the ones that don't end in <code class="literal">name</code>. Next, we use the <code class="literal">thru()</code> function to return the object property values that correspond to our key filter results. Similar actions can take place with object property values, especially when there's not much need to use keys. Let's look at an example of this:</p><div><pre class="programlisting">var object = {
    first: 'Connie',
    last: 'Vargas',
    dob: new Date(1984, 08, 11)
};

_(object)
    .values()
    .filter(_.isDate)
    .map(function(item) {
        return item.toLocaleString();
    })
    .value();
// → [ "9/11/1984, 12:00:00 AM" ]</pre></div><p>This chain grabs the<a id="id400" class="indexterm"/> property values of the wrapped object and filters out anything that's not a<a id="id401" class="indexterm"/> date. Then the <code class="literal">Date</code> objects found get mapped to an array of strings.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec85"/>Omitting and picking properties</h2></div></div></div><p>Picking certain object properties<a id="id402" class="indexterm"/> to use, as well as those to omit, has its uses in chains, especially<a id="id403" class="indexterm"/> when the wrapped value is a plain object and based on some criteria, there are certain properties we don't care to use. For example, we might have a collection that we want to transform into an indexed object, but along the way, we need to pick or omit values that should or shouldn't be there, respectively, as shown in the following example:</p><div><pre class="programlisting">var collection = [
    { first: 'Tracey', last: 'Doyle', age: 40 },
    { first: 'Toby', last: 'Wright', age: 49 },
    { first: 'Leonard', last: 'Hunt', age: 32 },
    { first: 'Brooke', last: 'Briggs', age: 32 }
];
                
_(collection)
    .indexBy('last')
    .pick(function(value) {
        return value.age &gt;= 35;
    })
    .transform(function(result, item, key) {
        result[key] = _.omit(item, 'last');
    })
    .value();
// → 
// {
//   Doyle: { first: "Tracey", age: 40 },
//   Wright: { first: "Toby", age: 49 }
// }</pre></div><p>This code indexes the array of objects by the <code class="literal">last</code> property value. The next step in the chain is to pick only items that have an <code class="literal">age</code> greater than <code class="literal">34</code>. Finally, since each item is indexed by the last name, we don't need the <code class="literal">last</code> property any more, so the <code class="literal">transform()</code> function uses <code class="literal">omit()</code> to get rid of it for each item, which is the last step in the chain.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Returning wrappers</h1></div></div></div><p>Wrappers and the function<a id="id404" class="indexterm"/> call chains that follow don't exist randomly throughout our code. The next chapter covers this topic in more depth, so consider this as a teaser. So far, we've only looked at chains as they're constructed and executed in the same statement. However, if we're going through all the trouble of designing a call chain that serves a general purpose, wouldn't it be good not to keep assembling that chain? Let's design the chain with the following code:</p><div><pre class="programlisting">function best(coll, prop, count) {
    return _(coll)
        .sortBy(prop)
        .takeRight(count);
}
                
var collection = [
    { name: 'Mathew', score: 92 },
    { name: 'Michele', score: 89 },
    { name: 'Joe', score: 74 },
    { name: 'Laurie', score: 83 }
];

var bestScore = best(collection, 'score', 2);

bestScore.value();
// → 
// [
//   { name: "Michele", score": 89 },
//   { name: "Mathew", score: 92 }
// ]

bestScore.reverse().value();
// → 
// [
//   { name: "Michele", score: 89 },
//   { name: "Mathew", score: 92 }
// ]

bestScore.pluck('name').value();
// → [ "Michele", "Mathew" ]</pre></div><p>The <code class="literal">best()</code> function defined here returns a Lo-Dash wrapper instance. Notice that inside <code class="literal">best()</code>, we're actually chaining together function calls but none of them are actually called, which means that the return value of <code class="literal">best()</code> is a wrapper. This is illustrated by the <code class="literal">bestScrore</code> variable, which holds a wrapper instance. This wrapper can be called again and again without the need to reconstruct the function call chain. Nevertheless, if we need to tweak the chain slightly, we <a id="id405" class="indexterm"/>can build on it. We're doing this with <code class="literal">bestScore</code> by calling <code class="literal">reverse()</code> and <code class="literal">pluck()</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Summary</h1></div></div></div><p>This chapter introduced the concept of wrapped values and the function call chains applied to them. This versatile programming model, fundamental to Lo-Dash, assists in building complex chunks of functionality using compact and legible code. Chained calls aren't unique to Lo-Dash—they're popular in many other libraries, perhaps mostly so in jQuery.</p><p>Applications are faced with the tough job of filtering data—lots of data and lots of hard constraints. Instead of creating messy code with lots of temporary variables, we addressed several ways to construct complex filters using chains. After that, we looked at testing truth conditions using chains. These are like filters, except they don't return collection results but only truth statements expressed as Boolean values. We also looked at how to count items after they've moved through a function call chain.</p><p>Another fundamental practice we learned was transforming collections into alternative, more usable representations that better fit a given context. Like filtering, transforming collections is often better done using chains as it reduces the amount of code you have to write.</p><p>We closed the chapter with a look at how your functions can return wrappers that aren't necessarily executed immediately. This is the next step we take in building reusable Lo-Dash components, in the next chapter.</p></div></body></html>