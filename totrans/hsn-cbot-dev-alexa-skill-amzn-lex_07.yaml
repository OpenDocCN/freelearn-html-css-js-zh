- en: Publishing Your Chatbot to Facebook, Slack, Twilio, and HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned how to build a range of chatbots using Amazon Lex, but currently,
    no one else can access them. In this chapter, we're going to learn how we can
    deploy our chatbots onto Facebook, Slack, and Twilio. We'll also learn how to
    integrate Lex with our own frontend and also create an HTTP endpoint, allowing
    more flexible integrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Lex chatbots to Facebook Messenger, Slack, and Twilio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP endpoint to allow more flexible integrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a frontend for our chatbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating a Lambda function to power our HTTP endpoint,
    and we'll be creating and deploying it using the local development setup that
    we created in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting
    Started with AWS and Amazon CLI*.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be using Facebook and Slack, so you need to have an account. If you
    don't already, you can create accounts for free.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code and data required for this chapter can be found at [bit.ly/chatbot-ch7](http://bit.ly/chatbot-ch7).
  prefs: []
  type: TYPE_NORMAL
- en: Integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having built a chatbot, you want users to be able to find it and use it. A lot
    of your users will already have Facebook or Slack, and they'll definitely have
    a mobile number. Being able to use our chatbots through these existing communication
    methods makes it a lot easier and more natural for our users.
  prefs: []
  type: TYPE_NORMAL
- en: To allow chatbots onto their systems, Facebook, Slack, and Twilio have created
    integration methods. This allows messages that are sent through each of those
    platforms to reach our chatbot, making our chatbot appear to be part of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Lex makes it very easy for us to integrate with Facebook, Slack, Twilio,
    and Kik, hiding a lot of complex data formatting behind the scenes. To access
    the integrations that Lex has, click on the Channels tab, and you'll have the
    choice to configure Facebook, Kik, Slack, or Twilio SMS.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook Messenger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Facebook Messenger had 1.3 billion monthly users as of April 2018, and that
    number has been growing month on month. This is a huge user base that we can tap
    into.
  prefs: []
  type: TYPE_NORMAL
- en: As well as the massive user base, there's another great feature for chatbot
    developers. When you create a Facebook page for a company, organization, or anything
    else, it has a Messenger account. This is so that users can message the company,
    but this means that every company on Facebook could benefit from having a chatbot.
    That's a massive target market.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access these channels, we can click on Channels in the Lex editor. We can
    start by selecting Facebook as the channel and then giving this channel a name
    and description. Next, we can select the alias that we want to deploy. Make sure
    that you''ve published your chatbot to an alias and then we can select one of
    them in the dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a493bdc1-c852-4758-b444-ac10612aefc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Channels in Lex console
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we can do right now is choose a Verify Token. This is a string
    that we will use later to help connect Facebook to our Lex chatbot. This can be
    any string of letters and numbers you like.
  prefs: []
  type: TYPE_NORMAL
- en: The Page Access Token and App Secret Key are two values that we'll get once
    we've created a Facebook app, so we'll do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and connecting a Facebook Messenger app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To integrate a chatbot into Facebook Messenger, we need to first create a Facebook
    app. To get started, go to [https://developers.facebook.com/](https://developers.facebook.com/)
    and click Log In. If this is your first Facebook app, then you'll need to link
    this developer account to your personal account. Once you've logged in, you can
    create your first app. Click My Apps and then select Create New App. This will
    open a popup where we can name the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This app name won''t be displayed to users; it is only ever seen by Facebook
    page admins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b1cac0c-7c25-4273-bcd6-ebae052f7fe0.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating your Facebook app
  prefs: []
  type: TYPE_NORMAL
- en: Facebook apps can be used to do a huge range of things, but we're wanting to
    build a Messenger chatbot, so we need to click Set Up under Messenger.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be on a page titled Messenger Platform, and, on the left, you
    should see Messenger under PRODUCTS. The first thing we need to do is to create
    a token so that Lex can get access to this app. To generate the token, we can
    go to the Token Generation section and click the Select a Page dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45a5d082-1aec-4c57-91e7-680af185a5d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Generating your page token
  prefs: []
  type: TYPE_NORMAL
- en: If you're not an admin on any Facebook pages, then you're going to have to create
    one. On Facebook itself, you can quickly and easily make a page for the fake shop
    or just a page for yourself as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: When you select the page, a token will be generated. This can be copied and
    pasted into the Page Access Token field in our Lex channel configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to get is the App Secret key, which we can find in our
    app page under Settings | Basic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/827b2000-acba-4c28-b41c-2695c319a152.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting app credentials
  prefs: []
  type: TYPE_NORMAL
- en: With all of the details of the channel now done, we can click Activate, and
    we'll be given a new Callback URL. Copy this URL and go back to our Facebook app
    screen. Go back to the Messenger config Messenger | Settings in the left-hand
    menu, and scroll down to Webhooks. Webhooks are how Facebook is going to send
    messages through to our Lex chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Setup Webhooks to open a popup where we can paste the URL we got from
    Lex as the Callback URL and then the Verify Token that we specified in the setup
    of the Lex channel. We also need to subscribe to *messages*, *messaging_postbacks*,
    and messaging_optins. These options are selecting which types of messages Facebook
    will send to Lex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2b1c735-f2d1-476d-8d88-986fc66cb6e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Facebook Webhook options
  prefs: []
  type: TYPE_NORMAL
- en: Clicking Verify and Save will send a request to Lex and will expect the correct
    verify token to be sent back. Normally, you would have to set up that endpoint,
    but Lex handles all of this.
  prefs: []
  type: TYPE_NORMAL
- en: The last Webhook setup that we need to do is to select the page we can subscribe
    to. In the Webhooks section, there's a Select a Page dropdown, which you need
    to set and then click Subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: Now the chatbot should be on your page, but it'll only be accessible by yourself
    and other people who you've added to the app. Adding more people to test or work
    on the app can be done in the Roles menu on the left.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can test out your chatbot by going to your Facebook page
    and sending it a message. Lex should receive the message and send the correct
    response as it did in the Lex console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can set your new app live, you need to ask Facebook to allow you
    to do page messaging. This is done by scrolling to the bottom of the Messenger
    settings page and adding pages_messaging to the submission. At this point, you
    will probably be asked to complete a few more things such as adding an app icon
    and setting a privacy policy URL and category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b5ed283-93f4-42c4-9b25-772d8464e696.png)'
  prefs: []
  type: TYPE_IMG
- en: Submission requirements
  prefs: []
  type: TYPE_NORMAL
- en: Once you've completed these, you can submit your app for review. You'll be asked
    to provide example commands and their automated responses. Make sure that you've
    tested the commands before submitting as it can take up to a week to get an app
    verified, so getting it right the first time is key.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook has recently updated its policies so that to activate your chatbot
    you need to have an approved Facebook business account. This involves registering
    your business details and providing a few pieces of evidence.
  prefs: []
  type: TYPE_NORMAL
- en: Once your app and the connected business account are verified, you get the joy
    of switching it from OFF to ON and allowing everyone to start messaging your chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: Slack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slack is a messaging platform massively popular with software developers and
    tech companies, and it fully supports chatbots.
  prefs: []
  type: TYPE_NORMAL
- en: As we did with Facebook, we need to choose a Channel Name and Alias, and you
    can provide a Channel Description if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and connecting a Slack app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start setting up our Slack app, we need to log in to the Slack API ([https://api.slack.com/](https://api.slack.com/)).
    Once we''re logged in, we can create a new app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb593330-99b7-47a8-9ea3-5b3f3dc20330.png)'
  prefs: []
  type: TYPE_IMG
- en: Create Slack app
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can set up the features for the app, which for us is configuring the
    bots feature. We need to give our app a **Display name** and a **Default username***,*
    and sett the Always On toggle to *On*. This means that the bot will always appear
    to be online.
  prefs: []
  type: TYPE_NORMAL
- en: With this set up, we can now go to Basic Information in the left-hand menu,
    where we can get the Client ID, Client Secret, and Verification Token, which we
    can paste into our Lex channel configuration.
  prefs: []
  type: TYPE_NORMAL
- en: When you Activate the Lex channel, you should get a Postback URL and OAuth URL.
    The Postback URL is the URL that listens for messages from Slack and the OAuth
    URL is used to authenticate your bot.
  prefs: []
  type: TYPE_NORMAL
- en: With the OAuth URL, we can go back to [api.Slack.com](https://api.slack.com/)
    and navigate into our app. From here, we can navigate to OAuth & Permissions in
    the left-hand menu and click Add New Redirect URL. We can now paste the OAuth
    URL that we got from Lex.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to set the scope of permissions that this app will get. In the
    Scopes section, we can add permissions by selecting from the Select Permission
    Scopes dropdown. We need to add Send messages as ... (chat:write:bot) and Access
    information about your workspace (team: read) and then save the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/735fac30-f6ba-4c42-a3e3-14d58a900c66.png)'
  prefs: []
  type: TYPE_IMG
- en: Slack permissions
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to allow Lex to interact with our Slack app by clicking on
    Interactive Components in the left-hand menu and turning **Interactivity** on.
    We can then set the Request URL to the Postback URL that we got from a Lex activation.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to enable Event Subscriptions, which can be found in the menu
    on the left. Turn it On, and paste our Postback URL as the Request URL, and click
    Add Workspace Event. Scroll down until you see message.im, and add it, before
    saving changes.
  prefs: []
  type: TYPE_NORMAL
- en: To install our app onto your Slack channel, we need to go to Manage Distribution
    and click Add to Slack. You should be redirected to your Slack team, and you should
    see our chatbot in the Direct Messages. If you don't see it, you can search for
    it using the **+** icon.
  prefs: []
  type: TYPE_NORMAL
- en: You can now send messages to the chatbot through Slack and you should receive
    the same responses as we got when we tested in the Lex console.
  prefs: []
  type: TYPE_NORMAL
- en: Twilio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Twilio** is a platform that allows you to use SMS, calls, and video calls
    to interact with users. We''re going to be using it to allow users to interact
    with our bot over SMS text messages.'
  prefs: []
  type: TYPE_NORMAL
- en: As we did with the two previous integrations, we can give the channel a *name*
    and *choose an alias*. The Account SID and Authentication Token need to be got
    from Twilio, so that's what we'll do now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and connecting Twilio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we need to go to [www.twilio.com](https://www.twilio.com/) and
    sign up or log in. Once you've signed in, go to Settings in the left-hand menu
    and, under API Credentials, you will see ACCOUNT SID and AUTH TOKEN. These can
    be copied and pasted into the Lex channel setup, and then we can click Activate.
    Copy the Endpoint URL that is generated and go back to the Twilio console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the console, we need to go to Programmable SMS and we start by getting a
    number from which we can text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c68e942d-c728-48cf-9a34-9b4f467de72c.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting a number
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be given a random phone number, and we can either Choose this Number
    or Search for a different number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ebbf1a3-4d66-47a3-9dda-d4b0e6890601.png)'
  prefs: []
  type: TYPE_IMG
- en: Choosing a number
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a phone number to use, we can select Messaging Services from
    the menu on the left. We can then add a service for our Lex chatbot. This service
    will allow us to receive text messages and pass them through to our Lex chatbot
    before replying with the Lex response. Give the service a name and make sure to
    set the use case to Chat Bot/Interactive 2-Way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06a66916-8dcd-4972-b6e4-6afc64c8ca7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new service
  prefs: []
  type: TYPE_NORMAL
- en: You should be sent to the Numbers sub-menu, where we can Add an Existing Number
    to this service. This selects the number that our chatbot will use. Select the
    number that we chose earlier and add this to the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the number set on the service, we can go to Configure to add the Endpoint
    URL that we get from Lex. We want to be able to receive inbound messages, so click
    the PROCESS INBOUND MESSAGES tickbox and paste our URL in the REQUEST URL box.
    Save this service, and we have just one thing left to do to: get our SMS chatbot
    working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/509cf560-3306-438e-ac96-c495e6a0abc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Inbound settings
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is to allow our Twilio to send SMS messages to
    numbers in our region. Inside the Messaging Services, go to Settings and then
    Geo Permissions. This is a list of all of the country locations that are available;
    we need to activate our regions to allow us to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Search for your country and activate it by ticking the checkbox. You can activate
    as many regions as you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now test out your chatbot by sending a text to the number you chose
    for this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c37f30cf-bc0e-491f-bf4a-91f48da36eef.png)'
  prefs: []
  type: TYPE_IMG
- en: Texting chatbot
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get rid of the Sent from your Twilio trial account message, then
    you'll need to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's great that Lex makes it so easy to integrate our chatbot into Facebook,
    Slack, and Twilio, but we might also want to have our chatbot integrate into other
    services that don't have built-in integrations. For this, we can create an API
    endpoint for sending messages to our Lex chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: With AWS, we are lucky that they let you create an API with Lambdas and API
    Gateway. This means that we don't need to run a server, which means less work
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating a new folder in our Lambdas repository called `lex-shopping-api`
    with an `index.js` file inside. In this file, we can start by exporting a handler
    that checks that the event was a `POST` request and calls `sendToLex` to generate
    a reply. This reply then gets passed to `done` which formats the data, so it can
    be returned to API Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create the `sendToLex` function. The first thing that this function
    needs to do is to map the event body into the format that Lex requires. We''ll
    create this `mapMessageToLex` function later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This message now needs to be sent to Lex. Amazon has made this easy by creating
    the Lex runtime, which allows you to send messages to your Lex chatbots. To access
    the Lex runtime, we need to install the `aws-sdk` by running `npm init` and `npm
    install --save aws-sdk` inside our `lex-shopping-api` folder. We can then require
    it in and create a new instance of the Lex runtime class by adding this code at
    the top of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To post a message to Lex, we need to call `lexruntime.postText()`, passing
    in the `messageForLex` and a handler callback. We can wrap the whole thing in
    a `new Promise` to allow us to control the `async` flow better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now `await` the `lexPromise` using our error handler to get either the
    response or an error. If there is an error, then we can return that error, and
    if we get a response, we can set the `res` to be an object containing the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These returned values will flow all the way back to populate the reply variable
    in our handler. This gets passed to `done`, so we now need to create that function.
    API Gateway expects to get a response in a specific format so this function is
    returning that format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last function that we need to create is `mapMessageToLex`. Lex runtime
    requires that it gets an object with `botAlias`, `botName`, `inputText`, `userId`,
    and `sessionAttributes` so we map the message into this format. If you want to
    create an API for a different bot, then all you need to do is to change the `botName`
    and `botAlias`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test that this Lambda works properly, we can run some tests on it. The only
    values that need to be passed into this Lambda are the `body` and `httpMethod`.
    Because the `body` is a string, we need to escape the quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this test should result in this response, which is in the format that
    API Gateway expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Connecting API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Gateway is a service that allows us to create URLs that can accept all of
    the normal API request methods. Start by going to the API Gateway service in AWS
    and clicking Get Started.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating our first API, we should select New API and then we can give
    this API a name and Description, and click Create API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/543102dc-9a66-4fb1-a561-902c6608f28b.png)'
  prefs: []
  type: TYPE_IMG
- en: New API
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be on the configuration page for your API, but there are currently
    no endpoints created. Click on the Actions dropdown and select Create Resource.
    Doing this allows you to have the APIs for all of your Lex chatbots on a similar
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ecb5089-fd69-4916-a4ff-941828ff82a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a resource
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the resource `shopping-bot` and click Create Resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48f70655-e9d9-4596-8749-3d44cb4f9cb7.png)'
  prefs: []
  type: TYPE_IMG
- en: New resource
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a resource created, we can attach a method to it. In our Lambda,
    we check that the `httpMethod` is `POST` so we need to create a `POST` method.
    Click on our `shopping-bot` resource and click Actions | Create Method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d8ee865-703f-43cb-830f-5a4cd035e4bd.png)'
  prefs: []
  type: TYPE_IMG
- en: New method
  prefs: []
  type: TYPE_NORMAL
- en: This will open the method setup window, and there are a lot of ways to configure
    your method, but we're going to call our API Lambda. Make sure the integration
    type is Lambda Function and that Use Lambda Proxy integration is ticked. This
    makes sure that all of the request data is proxied through to the Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing in the method setup is to select our `lex-shopping-api` as the
    Lambda function and to Save the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd0b461b-c40d-4e95-9a06-5899d47a191a.png)'
  prefs: []
  type: TYPE_IMG
- en: Method setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add **cross-origin resource sharing** (**CORS**) to our
    API. This allows us to access our API from different internet browsers. This will
    be important when we build a frontend for this API in the next section. Select
    our shopping-bot resource, and then we can click Actions | Enable CORS. We can
    leave all of the settings as default and click Enable CORS and replace existing
    CORS headers, confirming that we want to replace existing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff23ddda-abcc-4207-9814-f6bcd707b262.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding CORS
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now test that our Lambda is being called properly by selecting the POST
    method and clicking on TEST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8150dd5-b5f9-4076-8f57-45010bf319ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Method TEST
  prefs: []
  type: TYPE_NORMAL
- en: 'In this screen, we can set query strings, headers, and the request body. We
    don''t need to send any query strings or headers, so we can scroll straight down
    to the request body section. As we should remember from the testing of the Lambda,
    all we need to pass through in the body is the `text` and a `sessionID`, so this
    is what we can put as the request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we hit Test, API Gateway will send our request through to our Lambda.
    Our Lambda will send it to our Lex chatbot and will send back the response. Our
    response body should come back like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Building the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing to do is to build our API. While on our API, we can select Actions
    | Deploy API. As this is the first time we are deploying this API, we need to
    create a new stage. Give your stage a name and description, and you can also add
    a deployment description before clicking Deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6327ffc6-b6fc-4071-9158-8db8908066b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a stage
  prefs: []
  type: TYPE_NORMAL
- en: When your API deploys, you'll be given a URL for it, which will be `https://{unique-code}.execute-api.eu-west-1.amazonaws.com/{stage-name}`.
    To access the endpoint that we made, we need to add `/shopping-bot` to the end.
    For example, `https://acffds-4fnf8x-se54fws-s34d.execute-api.eu-west-1.amazonaws.com/production/shopping-bot`.
    This now means you can use this API to integrate Lex into a wider range of systems.
  prefs: []
  type: TYPE_NORMAL
- en: Web user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having our own chatbot interface allows users to access it by going to a web
    page, but we can also integrate that into other websites, or even create mobile
    apps for our chatbot. We can use the API that we created to easily access the
    chatbot without making our AWS credentials public.
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, we need an HTML page to build upon. The three components that we
    need to start are a message area, a typing input box, and a send button. Create
    a folder with an `index.html` file inside and we can add this code to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple HTML file that has a CSS link in the header so we can style
    our page, the message area, input box and button, and two scripts. The first of
    these scripts imports `axios` so we can easily make requests, and the second is
    our own script.
  prefs: []
  type: TYPE_NORMAL
- en: As we've included the `style.css` and `script.js` files, we should create these
    files in our folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the functionality of this UI needs to be handled in this script file.
    When all of the HTML has loaded, we need to listen for the user clicking the Send
    button. When that happens, we need to get the text from the input box and write
    it as a sent message before sending it to our API. When our API replies, we can
    add the response as a received message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to make sure that the document has fully loaded. We can check
    if the document is ready, and if not, then we wait for the `DOMContentLoaded`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create the `start` function and set the API URL and session ID.
    We can use the `Math.random()` technique to make a random 16-digit number for
    the `sessionID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At the `start()` function, we also need to access the message area, text input
    box, and send button, using `document.querySelector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On to the `sendButton`, we can attach a listener for when the user clicks send.
    This will start by getting the value of the text input box. If there isn''t any
    text then we can return nothing from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is any text, then we can carry on to create a `sendElement` and add
    it to the message area. We need to make sure to add the classes of `sendMessage`
    and `message` to the element so we can style them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to send the message to our API. We can use `axios` as we imported
    it in the HTML file, passing through `text` and `sessionID` as the body. We need
    to make sure to copy the function from our Lambdas for error-handling here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is an error in the response, then we can set the message to an apology;
    otherwise, it will be the `response.data.message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to do is to add the received message to the message area so
    the user can see it. Don''t forget to add the `receivedMessage` and `message`
    classes for styling later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open the HTML document in a browser, now we should be able to type and
    send messages to our Lex chatbot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/539ba00f-2cb9-4ad3-ae2d-e9e360adf312.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic messaging
  prefs: []
  type: TYPE_NORMAL
- en: Styling the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve created an awesome web page that allows users to talk to a chatbot,
    but, currently, it looks awful. We can fix this by using our CSS file. While building
    the chat, we''ve been adding classes and IDs to the elements. This means we can
    set styles on those classes and ids to style our whole chat window. The first
    thing to do is to set the size of the message area. We can also add a light background
    and set the overflow to scroll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can style the messages. We add common styling to the `message` class
    such as the `padding`, `margin`, and `max-width`, while the alignment, `background`,
    and `border-radius` are defined on each type of message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last bit to style is the input textbox and send button. We can use `display:
    flex` on the container `div` and `flex-grow: 2` on the text input so that it stretches
    to fill the width left by the button. We can style the button up a bit with a
    different border and background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This results in a much nicer user experience than the plain text we had before.
    This is where you can spend some time customizing the look of your interface to
    be exactly how you want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even style this to match the brand colors of a company:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13e37d4f-a664-4340-88e3-91e03230cab3.png)'
  prefs: []
  type: TYPE_IMG
- en: Styled chat
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to create integrations that allow users to
    access our chatbots from Facebook Messenger, Slack, and Twilio.
  prefs: []
  type: TYPE_NORMAL
- en: We've also learned how to create an API to give us the ability to integrate
    our chatbots into other services that Amazon doesn't currently support. This API
    used a Lambda function to handle the requests sent through API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: We then used this API to create a frontend web page for our chatbot. We wrote
    a simple HTML document and then used a script to communicate with the API and
    add the messages to the page. The last thing we did was add styling to the page
    so that it looked like a real messaging platform.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we want to integrate our chatbots into other platforms and services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What services can you use to create an API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What two things do we need to add to an API before it will work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the last thing that we need to do to make our API public?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the three parts of our chatbot web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the first thing a loaded script file should do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
