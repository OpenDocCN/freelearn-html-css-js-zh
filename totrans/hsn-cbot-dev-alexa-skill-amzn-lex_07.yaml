- en: Publishing Your Chatbot to Facebook, Slack, Twilio, and HTTP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的聊天机器人发布到Facebook、Slack、Twilio和HTTP
- en: We've learned how to build a range of chatbots using Amazon Lex, but currently,
    no one else can access them. In this chapter, we're going to learn how we can
    deploy our chatbots onto Facebook, Slack, and Twilio. We'll also learn how to
    integrate Lex with our own frontend and also create an HTTP endpoint, allowing
    more flexible integrations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用Amazon Lex构建各种聊天机器人，但目前，其他人无法访问它们。在本章中，我们将学习如何将我们的聊天机器人部署到Facebook、Slack和Twilio。我们还将学习如何将Lex与我们的前端集成，并创建一个HTTP端点，以实现更灵活的集成。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Deploying Lex chatbots to Facebook Messenger, Slack, and Twilio
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Lex聊天机器人部署到Facebook Messenger、Slack和Twilio
- en: Creating an HTTP endpoint to allow more flexible integrations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个HTTP端点以实现更灵活的集成
- en: Building a frontend for our chatbot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的聊天机器人构建前端
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be creating a Lambda function to power our HTTP endpoint,
    and we'll be creating and deploying it using the local development setup that
    we created in [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting
    Started with AWS and Amazon CLI*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个Lambda函数来为我们的HTTP端点提供动力，并且我们将使用我们在[第2章](ac448944-0559-408e-a9c4-972933a03611.xhtml)，*使用AWS和Amazon
    CLI入门*中创建的本地开发环境来创建和部署它。
- en: We'll also be using Facebook and Slack, so you need to have an account. If you
    don't already, you can create accounts for free.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用Facebook和Slack，所以你需要有一个账户。如果你还没有，你可以免费创建账户。
- en: All of the code and data required for this chapter can be found at [bit.ly/chatbot-ch7](http://bit.ly/chatbot-ch7).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的所有代码和数据都可以在[bit.ly/chatbot-ch7](http://bit.ly/chatbot-ch7)找到。
- en: Integrations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成
- en: Having built a chatbot, you want users to be able to find it and use it. A lot
    of your users will already have Facebook or Slack, and they'll definitely have
    a mobile number. Being able to use our chatbots through these existing communication
    methods makes it a lot easier and more natural for our users.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了一个聊天机器人之后，你希望用户能够找到并使用它。许多用户已经拥有Facebook或Slack，并且他们肯定有一个手机号码。能够通过这些现有的通信方式使用我们的聊天机器人，使得用户使用起来更加容易和自然。
- en: To allow chatbots onto their systems, Facebook, Slack, and Twilio have created
    integration methods. This allows messages that are sent through each of those
    platforms to reach our chatbot, making our chatbot appear to be part of the system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许聊天机器人进入他们的系统，Facebook、Slack和Twilio创建了集成方法。这使得通过每个平台发送的消息都能到达我们的聊天机器人，使得我们的聊天机器人看起来像是系统的一部分。
- en: Amazon Lex makes it very easy for us to integrate with Facebook, Slack, Twilio,
    and Kik, hiding a lot of complex data formatting behind the scenes. To access
    the integrations that Lex has, click on the Channels tab, and you'll have the
    choice to configure Facebook, Kik, Slack, or Twilio SMS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Lex使得我们与Facebook、Slack、Twilio和Kik的集成变得非常容易，在幕后隐藏了很多复杂的数据格式化。要访问Lex的集成，请点击“渠道”标签，你将可以选择配置Facebook、Kik、Slack或Twilio
    SMS。
- en: Facebook Messenger
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facebook Messenger
- en: The Facebook Messenger had 1.3 billion monthly users as of April 2018, and that
    number has been growing month on month. This is a huge user base that we can tap
    into.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2018年4月，Facebook Messenger有13亿月活跃用户，并且这个数字每月都在增长。这是一个巨大的用户群，我们可以从中获取。
- en: As well as the massive user base, there's another great feature for chatbot
    developers. When you create a Facebook page for a company, organization, or anything
    else, it has a Messenger account. This is so that users can message the company,
    but this means that every company on Facebook could benefit from having a chatbot.
    That's a massive target market.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了庞大的用户群之外，还有另一个非常适合聊天机器人开发者的特性。当你为一家公司、组织或其他任何东西创建一个Facebook页面时，它都有一个Messenger账户。这是为了让用户能够给公司发消息，但这意味着Facebook上的每家公司都可以从拥有聊天机器人中受益。这是一个巨大的目标市场。
- en: 'To access these channels, we can click on Channels in the Lex editor. We can
    start by selecting Facebook as the channel and then giving this channel a name
    and description. Next, we can select the alias that we want to deploy. Make sure
    that you''ve published your chatbot to an alias and then we can select one of
    them in the dropdown:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这些渠道，我们可以在Lex编辑器中点击“渠道”。我们可以先选择Facebook作为渠道，然后为这个渠道命名并添加描述。接下来，我们可以选择我们想要部署的别名。确保你已经将聊天机器人发布到一个别名，然后我们可以在下拉菜单中选择其中一个：
- en: '![](img/a493bdc1-c852-4758-b444-ac10612aefc8.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a493bdc1-c852-4758-b444-ac10612aefc8.png)'
- en: Channels in Lex console
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Lex控制台中的渠道
- en: The last thing we can do right now is choose a Verify Token. This is a string
    that we will use later to help connect Facebook to our Lex chatbot. This can be
    any string of letters and numbers you like.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能做的最后一件事是选择一个验证令牌。这是一个字符串，我们稍后会用它来帮助将Facebook连接到我们的Lex聊天机器人。这可以是您喜欢的任何字母和数字的字符串。
- en: The Page Access Token and App Secret Key are two values that we'll get once
    we've created a Facebook app, so we'll do this next.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 页面访问令牌和应用密钥是在创建Facebook应用后我们将获得的两个值，所以我们将接下来做这件事。
- en: Creating and connecting a Facebook Messenger app
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并连接Facebook Messenger应用
- en: To integrate a chatbot into Facebook Messenger, we need to first create a Facebook
    app. To get started, go to [https://developers.facebook.com/](https://developers.facebook.com/)
    and click Log In. If this is your first Facebook app, then you'll need to link
    this developer account to your personal account. Once you've logged in, you can
    create your first app. Click My Apps and then select Create New App. This will
    open a popup where we can name the app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要将聊天机器人集成到Facebook Messenger中，我们首先需要创建一个Facebook应用。要开始，请访问[https://developers.facebook.com/](https://developers.facebook.com/)并点击“登录”。如果是您的第一个Facebook应用，那么您需要将此开发者账户链接到您的个人账户。登录后，您可以创建您的第一个应用。点击“我的应用”然后选择“创建新应用”。这将打开一个弹出窗口，我们可以命名该应用。
- en: 'This app name won''t be displayed to users; it is only ever seen by Facebook
    page admins:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用名称不会显示给用户；它仅由Facebook页面管理员看到：
- en: '![](img/1b1cac0c-7c25-4273-bcd6-ebae052f7fe0.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b1cac0c-7c25-4273-bcd6-ebae052f7fe0.png)'
- en: Creating your Facebook app
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建您的Facebook应用
- en: Facebook apps can be used to do a huge range of things, but we're wanting to
    build a Messenger chatbot, so we need to click Set Up under Messenger.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook应用可以用于执行大量任务，但我们想构建一个聊天机器人，因此我们需要在“Messenger”下点击“设置”。
- en: 'You should now be on a page titled Messenger Platform, and, on the left, you
    should see Messenger under PRODUCTS. The first thing we need to do is to create
    a token so that Lex can get access to this app. To generate the token, we can
    go to the Token Generation section and click the Select a Page dropdown:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在一个标题为“Messenger平台”的页面上，在左侧，您应该看到“Messenger”在“产品”下。我们首先需要做的是创建一个令牌，这样Lex就可以访问这个应用。要生成令牌，我们可以进入“令牌生成”部分并点击“选择页面”下拉菜单：
- en: '![](img/45a5d082-1aec-4c57-91e7-680af185a5d5.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45a5d082-1aec-4c57-91e7-680af185a5d5.png)'
- en: Generating your page token
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 生成您的页面令牌
- en: If you're not an admin on any Facebook pages, then you're going to have to create
    one. On Facebook itself, you can quickly and easily make a page for the fake shop
    or just a page for yourself as a developer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是任何Facebook页面的管理员，那么您将不得不创建一个。在Facebook本身，您可以快速轻松地创建一个用于假店铺的页面，或者只是创建一个作为开发者的个人页面。
- en: When you select the page, a token will be generated. This can be copied and
    pasted into the Page Access Token field in our Lex channel configuration.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择页面时，将生成一个令牌。这可以复制并粘贴到Lex通道配置中的“页面访问令牌”字段中。
- en: 'The last thing we need to get is the App Secret key, which we can find in our
    app page under Settings | Basic:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要获取的是应用密钥，我们可以在应用的“设置 | 基本设置”页面下找到：
- en: '![](img/827b2000-acba-4c28-b41c-2695c319a152.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/827b2000-acba-4c28-b41c-2695c319a152.png)'
- en: Getting app credentials
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 获取应用凭据
- en: With all of the details of the channel now done, we can click Activate, and
    we'll be given a new Callback URL. Copy this URL and go back to our Facebook app
    screen. Go back to the Messenger config Messenger | Settings in the left-hand
    menu, and scroll down to Webhooks. Webhooks are how Facebook is going to send
    messages through to our Lex chatbot.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通道的所有细节都已完成，我们可以点击“激活”，我们将获得一个新的回调URL。复制此URL并返回到我们的Facebook应用屏幕。返回到左侧菜单中的“Messenger配置
    | 设置”，然后滚动到“Webhooks”。Webhooks是Facebook将通过它发送消息到我们的Lex聊天机器人的方式。
- en: 'Click Setup Webhooks to open a popup where we can paste the URL we got from
    Lex as the Callback URL and then the Verify Token that we specified in the setup
    of the Lex channel. We also need to subscribe to *messages*, *messaging_postbacks*,
    and messaging_optins. These options are selecting which types of messages Facebook
    will send to Lex:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“设置Webhooks”以打开一个弹出窗口，我们可以将我们从Lex获得的URL粘贴为“回调URL”，然后是我们在Lex通道设置中指定的“验证令牌”。我们还需要订阅“消息”、“消息回调和”消息选择”。这些选项是选择Facebook将发送给Lex的消息类型：
- en: '![](img/c2b1c735-f2d1-476d-8d88-986fc66cb6e9.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2b1c735-f2d1-476d-8d88-986fc66cb6e9.png)'
- en: Facebook Webhook options
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook Webhook选项
- en: Clicking Verify and Save will send a request to Lex and will expect the correct
    verify token to be sent back. Normally, you would have to set up that endpoint,
    but Lex handles all of this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 点击验证和保存将会向 Lex 发送一个请求，并期望返回正确的验证令牌。通常，你将需要设置该端点，但 Lex 会处理所有这些。
- en: The last Webhook setup that we need to do is to select the page we can subscribe
    to. In the Webhooks section, there's a Select a Page dropdown, which you need
    to set and then click Subscribe.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要设置的 Webhook 是选择我们可以订阅的页面。在 Webhooks 部分中，有一个“选择页面”下拉菜单，你需要设置并点击订阅。
- en: Now the chatbot should be on your page, but it'll only be accessible by yourself
    and other people who you've added to the app. Adding more people to test or work
    on the app can be done in the Roles menu on the left.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，聊天机器人应该已经在你的页面上，但它只能由你自己和其他你添加到应用中的人访问。添加更多人进行测试或工作可以在左侧的“角色”菜单中完成。
- en: At this point, you can test out your chatbot by going to your Facebook page
    and sending it a message. Lex should receive the message and send the correct
    response as it did in the Lex console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以通过访问你的 Facebook 页面并发送消息来测试你的聊天机器人。Lex 应该会接收到消息，并发送正确的响应，就像它在 Lex 控制台中做的那样。
- en: 'Before you can set your new app live, you need to ask Facebook to allow you
    to do page messaging. This is done by scrolling to the bottom of the Messenger
    settings page and adding pages_messaging to the submission. At this point, you
    will probably be asked to complete a few more things such as adding an app icon
    and setting a privacy policy URL and category:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以设置你的新应用上线之前，你需要请求 Facebook 允许你进行页面消息发送。这需要在“消息者设置”页面底部滚动，并将 pages_messaging
    添加到提交中。此时，你可能会被要求完成一些额外的事情，例如添加应用图标、设置隐私政策 URL 和类别：
- en: '![](img/0b5ed283-93f4-42c4-9b25-772d8464e696.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b5ed283-93f4-42c4-9b25-772d8464e696.png)'
- en: Submission requirements
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提交要求
- en: Once you've completed these, you can submit your app for review. You'll be asked
    to provide example commands and their automated responses. Make sure that you've
    tested the commands before submitting as it can take up to a week to get an app
    verified, so getting it right the first time is key.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你可以提交你的应用以供审查。你将被要求提供示例命令及其自动响应。确保在提交之前测试过这些命令，因为验证一个应用可能需要长达一周的时间，所以第一次就做对是关键。
- en: Facebook has recently updated its policies so that to activate your chatbot
    you need to have an approved Facebook business account. This involves registering
    your business details and providing a few pieces of evidence.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 最近更新了其政策，现在要激活你的聊天机器人，你需要有一个经过批准的 Facebook 商业账户。这涉及到注册你的商业详情并提供一些证明材料。
- en: Once your app and the connected business account are verified, you get the joy
    of switching it from OFF to ON and allowing everyone to start messaging your chatbot.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用和连接的商业账户得到验证，你就可以从“关闭”切换到“开启”，并允许每个人开始向你的聊天机器人发送消息。
- en: Slack
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slack
- en: Slack is a messaging platform massively popular with software developers and
    tech companies, and it fully supports chatbots.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Slack 是一个在软件开发者和科技公司中非常受欢迎的即时通讯平台，并且完全支持聊天机器人。
- en: As we did with Facebook, we need to choose a Channel Name and Alias, and you
    can provide a Channel Description if you want to.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们处理 Facebook 一样，我们需要选择一个频道名称和别名，如果你愿意的话，还可以提供频道描述。
- en: Creating and connecting a Slack app
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和连接 Slack 应用
- en: 'To start setting up our Slack app, we need to log in to the Slack API ([https://api.slack.com/](https://api.slack.com/)).
    Once we''re logged in, we can create a new app:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始设置我们的 Slack 应用，我们需要登录到 Slack API ([https://api.slack.com/](https://api.slack.com/))。一旦我们登录，我们就可以创建一个新的应用：
- en: '![](img/cb593330-99b7-47a8-9ea3-5b3f3dc20330.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb593330-99b7-47a8-9ea3-5b3f3dc20330.png)'
- en: Create Slack app
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Slack 应用
- en: Next, we can set up the features for the app, which for us is configuring the
    bots feature. We need to give our app a **Display name** and a **Default username***,*
    and sett the Always On toggle to *On*. This means that the bot will always appear
    to be online.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以设置应用的功能，对我们来说就是配置聊天机器人功能。我们需要为我们的应用提供一个**显示名称**和**默认用户名**，并将“始终开启”切换设置为**开启**。这意味着聊天机器人将始终显示为在线状态。
- en: With this set up, we can now go to Basic Information in the left-hand menu,
    where we can get the Client ID, Client Secret, and Verification Token, which we
    can paste into our Lex channel configuration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好之后，我们现在可以进入左侧菜单中的“基本信息”，在那里我们可以获取客户端 ID、客户端密钥和验证令牌，我们可以将这些粘贴到我们的 Lex 频道配置中。
- en: When you Activate the Lex channel, you should get a Postback URL and OAuth URL.
    The Postback URL is the URL that listens for messages from Slack and the OAuth
    URL is used to authenticate your bot.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您激活Lex频道时，您应该会得到一个Postback URL和OAuth URL。Postback URL是监听来自Slack的消息的URL，OAuth
    URL用于验证您的聊天机器人。
- en: With the OAuth URL, we can go back to [api.Slack.com](https://api.slack.com/)
    and navigate into our app. From here, we can navigate to OAuth & Permissions in
    the left-hand menu and click Add New Redirect URL. We can now paste the OAuth
    URL that we got from Lex.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OAuth URL，我们可以回到[api.Slack.com](https://api.slack.com/)，并导航到我们的应用。从这里，我们可以导航到左侧菜单中的OAuth
    & Permissions，并点击添加新的重定向URL。现在我们可以粘贴从Lex获取的OAuth URL：
- en: 'We also need to set the scope of permissions that this app will get. In the
    Scopes section, we can add permissions by selecting from the Select Permission
    Scopes dropdown. We need to add Send messages as ... (chat:write:bot) and Access
    information about your workspace (team: read) and then save the changes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还需要设置此应用将获得的权限范围。在Scopes部分，我们可以通过选择“选择权限范围”下拉菜单来添加权限。我们需要添加“发送消息作为...”（chat:write:bot）和“访问有关您工作空间的信息”（team:
    read），然后保存更改：'
- en: '![](img/735fac30-f6ba-4c42-a3e3-14d58a900c66.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/735fac30-f6ba-4c42-a3e3-14d58a900c66.png)'
- en: Slack permissions
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Slack权限
- en: The next step is to allow Lex to interact with our Slack app by clicking on
    Interactive Components in the left-hand menu and turning **Interactivity** on.
    We can then set the Request URL to the Postback URL that we got from a Lex activation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是允许Lex通过点击左侧菜单中的“交互组件”并开启**交互性**来与我们的Slack应用交互。然后我们可以设置请求URL为我们从Lex激活中获得的Postback
    URL。
- en: The last step is to enable Event Subscriptions, which can be found in the menu
    on the left. Turn it On, and paste our Postback URL as the Request URL, and click
    Add Workspace Event. Scroll down until you see message.im, and add it, before
    saving changes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是启用事件订阅，它可以在左侧菜单中找到。开启它，并将我们的Postback URL作为请求URL粘贴，然后点击添加工作空间事件。向下滚动直到您看到message.im，并添加它，然后保存更改。
- en: To install our app onto your Slack channel, we need to go to Manage Distribution
    and click Add to Slack. You should be redirected to your Slack team, and you should
    see our chatbot in the Direct Messages. If you don't see it, you can search for
    it using the **+** icon.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的应用安装到您的Slack频道，我们需要进入“管理分发”并点击“添加到Slack”。您应该会被重定向到您的Slack团队，并且应该在我们的直接消息中看到我们的聊天机器人。如果您看不到它，您可以使用**+**图标搜索它。
- en: You can now send messages to the chatbot through Slack and you should receive
    the same responses as we got when we tested in the Lex console.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过Slack向聊天机器人发送消息，并且应该收到我们在Lex控制台中测试时得到的相同响应。
- en: Twilio
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twilio
- en: '**Twilio** is a platform that allows you to use SMS, calls, and video calls
    to interact with users. We''re going to be using it to allow users to interact
    with our bot over SMS text messages.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Twilio**是一个平台，允许您使用短信、电话和视频通话与用户互动。我们将使用它来允许用户通过短信文本消息与我们的聊天机器人互动。'
- en: As we did with the two previous integrations, we can give the channel a *name*
    and *choose an alias*. The Account SID and Authentication Token need to be got
    from Twilio, so that's what we'll do now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们处理前两个集成一样，我们可以给频道起一个*名称*并*选择一个别名*。Account SID和Authentication Token需要从Twilio获取，所以我们现在就要这么做。
- en: Creating and connecting Twilio
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和连接Twilio
- en: To get started, we need to go to [www.twilio.com](https://www.twilio.com/) and
    sign up or log in. Once you've signed in, go to Settings in the left-hand menu
    and, under API Credentials, you will see ACCOUNT SID and AUTH TOKEN. These can
    be copied and pasted into the Lex channel setup, and then we can click Activate.
    Copy the Endpoint URL that is generated and go back to the Twilio console.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要访问[www.twilio.com](https://www.twilio.com/)并注册或登录。登录后，在左侧菜单中进入设置，在API凭证下，您将看到ACCOUNT
    SID和AUTH TOKEN。这些可以复制并粘贴到Lex频道设置中，然后我们可以点击激活。复制生成的端点URL，然后返回到Twilio控制台。
- en: 'In the console, we need to go to Programmable SMS and we start by getting a
    number from which we can text:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，我们需要进入可编程短信，并开始获取一个可以发送短信的号码：
- en: '![](img/c68e942d-c728-48cf-9a34-9b4f467de72c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c68e942d-c728-48cf-9a34-9b4f467de72c.png)'
- en: Getting a number
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 获取号码
- en: 'We''ll be given a random phone number, and we can either Choose this Number
    or Search for a different number:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得一个随机电话号码，我们可以选择这个号码或者搜索一个不同的号码：
- en: '![](img/5ebbf1a3-4d66-47a3-9dda-d4b0e6890601.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ebbf1a3-4d66-47a3-9dda-d4b0e6890601.png)'
- en: Choosing a number
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 选择号码
- en: 'Now that we have a phone number to use, we can select Messaging Services from
    the menu on the left. We can then add a service for our Lex chatbot. This service
    will allow us to receive text messages and pass them through to our Lex chatbot
    before replying with the Lex response. Give the service a name and make sure to
    set the use case to Chat Bot/Interactive 2-Way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以使用的电话号码，我们可以从左侧菜单中选择消息服务。然后我们可以为我们的Lex聊天机器人添加一个服务。这个服务将允许我们接收文本消息，并在回复Lex响应之前将它们传递给我们的Lex聊天机器人。给这个服务起一个名字，并确保将用例设置为聊天机器人/交互式双向：
- en: '![](img/06a66916-8dcd-4972-b6e4-6afc64c8ca7c.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06a66916-8dcd-4972-b6e4-6afc64c8ca7c.png)'
- en: Creating a new service
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新服务
- en: You should be sent to the Numbers sub-menu, where we can Add an Existing Number
    to this service. This selects the number that our chatbot will use. Select the
    number that we chose earlier and add this to the service.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该被发送到“号码”子菜单，在那里我们可以向此服务添加一个现有号码。这选择了我们的聊天机器人将使用的号码。选择我们之前选择的号码，并将其添加到服务中。
- en: 'With the number set on the service, we can go to Configure to add the Endpoint
    URL that we get from Lex. We want to be able to receive inbound messages, so click
    the PROCESS INBOUND MESSAGES tickbox and paste our URL in the REQUEST URL box.
    Save this service, and we have just one thing left to do to: get our SMS chatbot
    working:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务上设置了号码后，我们可以转到配置，添加我们从Lex获得的端点URL。我们希望能够接收传入的消息，因此点击“处理传入消息”复选框，并将我们的URL粘贴到“请求URL”框中。保存此服务，我们只剩下最后一件事要做：让我们的短信聊天机器人工作：
- en: '![](img/509cf560-3306-438e-ac96-c495e6a0abc1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/509cf560-3306-438e-ac96-c495e6a0abc1.png)'
- en: Inbound settings
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 传入设置
- en: The last thing we need to do is to allow our Twilio to send SMS messages to
    numbers in our region. Inside the Messaging Services, go to Settings and then
    Geo Permissions. This is a list of all of the country locations that are available;
    we need to activate our regions to allow us to test it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是允许我们的Twilio向我们所在地区的号码发送短信。在消息服务中，转到设置，然后是地理权限。这是一个所有可用的国家位置的列表；我们需要激活我们的地区，以便我们可以测试它。
- en: Search for your country and activate it by ticking the checkbox. You can activate
    as many regions as you like.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索你的国家，通过勾选复选框来激活它。你可以激活你喜欢的任何地区。
- en: 'You can now test out your chatbot by sending a text to the number you chose
    for this service:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过向为这项服务选择的号码发送文本来测试你的聊天机器人：
- en: '![](img/c37f30cf-bc0e-491f-bf4a-91f48da36eef.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c37f30cf-bc0e-491f-bf4a-91f48da36eef.png)'
- en: Texting chatbot
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 发送聊天机器人短信
- en: If you want to get rid of the Sent from your Twilio trial account message, then
    you'll need to upgrade.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要去掉来自Twilio试用账户的“发送自”消息，那么你需要升级。
- en: HTTP endpoint
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP端点
- en: It's great that Lex makes it so easy to integrate our chatbot into Facebook,
    Slack, and Twilio, but we might also want to have our chatbot integrate into other
    services that don't have built-in integrations. For this, we can create an API
    endpoint for sending messages to our Lex chatbot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Lex使得将我们的聊天机器人集成到Facebook、Slack和Twilio变得非常容易，这真是太好了，但我们可能还希望我们的聊天机器人能够集成到没有内置集成的其他服务中。为此，我们可以为向我们的Lex聊天机器人发送消息创建一个API端点。
- en: With AWS, we are lucky that they let you create an API with Lambdas and API
    Gateway. This means that we don't need to run a server, which means less work
    for us.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与AWS合作，我们很幸运，他们允许你使用Lambdas和API网关创建一个API。这意味着我们不需要运行服务器，这意味着我们工作量更少。
- en: Creating the Lambda
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Lambda
- en: 'We start by creating a new folder in our Lambdas repository called `lex-shopping-api`
    with an `index.js` file inside. In this file, we can start by exporting a handler
    that checks that the event was a `POST` request and calls `sendToLex` to generate
    a reply. This reply then gets passed to `done` which formats the data, so it can
    be returned to API Gateway:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在我们的Lambdas仓库中创建一个名为`lex-shopping-api`的新文件夹，并在其中创建一个`index.js`文件。在这个文件中，我们可以首先导出一个处理程序，该处理程序检查事件是否为`POST`请求，并调用`sendToLex`来生成回复。然后，这个回复被传递到`done`，它格式化数据，以便可以返回给API网关：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We now need to create the `sendToLex` function. The first thing that this function
    needs to do is to map the event body into the format that Lex requires. We''ll
    create this `mapMessageToLex` function later:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建`sendToLex`函数。这个函数首先需要做的事情是将事件体映射到Lex所需的格式。我们将在稍后创建这个`mapMessageToLex`函数：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This message now needs to be sent to Lex. Amazon has made this easy by creating
    the Lex runtime, which allows you to send messages to your Lex chatbots. To access
    the Lex runtime, we need to install the `aws-sdk` by running `npm init` and `npm
    install --save aws-sdk` inside our `lex-shopping-api` folder. We can then require
    it in and create a new instance of the Lex runtime class by adding this code at
    the top of our file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息现在需要发送到Lex。亚马逊通过创建Lex运行时使其变得简单，该运行时允许您向Lex聊天机器人发送消息。要访问Lex运行时，我们需要在`lex-shopping-api`文件夹中运行`npm
    init`和`npm install --save aws-sdk`来安装`aws-sdk`。然后我们可以在文件顶部添加此代码来引入它并创建Lex运行时类的新实例：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To post a message to Lex, we need to call `lexruntime.postText()`, passing
    in the `messageForLex` and a handler callback. We can wrap the whole thing in
    a `new Promise` to allow us to control the `async` flow better:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要向Lex发送消息，我们需要调用`lexruntime.postText()`，传递`messageForLex`和处理程序回调。我们可以将整个操作包裹在一个`new
    Promise`中，以更好地控制`async`流程：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now `await` the `lexPromise` using our error handler to get either the
    response or an error. If there is an error, then we can return that error, and
    if we get a response, we can set the `res` to be an object containing the message:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用错误处理程序`await` `lexPromise`以获取响应或错误。如果有错误，则可以返回该错误；如果收到响应，则可以将`res`设置为包含消息的对象：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These returned values will flow all the way back to populate the reply variable
    in our handler. This gets passed to `done`, so we now need to create that function.
    API Gateway expects to get a response in a specific format so this function is
    returning that format:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些返回值将一路返回以填充我们处理程序中的回复变量。这被传递给`done`，因此我们现在需要创建这个函数。API网关期望以特定的格式获取响应，因此这个函数返回该格式：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last function that we need to create is `mapMessageToLex`. Lex runtime
    requires that it gets an object with `botAlias`, `botName`, `inputText`, `userId`,
    and `sessionAttributes` so we map the message into this format. If you want to
    create an API for a different bot, then all you need to do is to change the `botName`
    and `botAlias`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个函数是`mapMessageToLex`。Lex运行时要求它得到一个包含`botAlias`、`botName`、`inputText`、`userId`和`sessionAttributes`的对象，因此我们将消息映射到这个格式。如果您想为不同的机器人创建API，那么您只需要更改`botName`和`botAlias`：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Testing
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'To test that this Lambda works properly, we can run some tests on it. The only
    values that need to be passed into this Lambda are the `body` and `httpMethod`.
    Because the `body` is a string, we need to escape the quotation marks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个Lambda是否正常工作，我们可以在其上运行一些测试。需要传递给这个Lambda的唯一值是`body`和`httpMethod`。因为`body`是一个字符串，所以我们需要转义引号：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running this test should result in this response, which is in the format that
    API Gateway expects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试应该得到API网关期望的这种格式的响应：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Connecting API Gateway
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接API网关
- en: API Gateway is a service that allows us to create URLs that can accept all of
    the normal API request methods. Start by going to the API Gateway service in AWS
    and clicking Get Started.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: API网关是一项服务，允许我们创建可以接受所有正常API请求方法的URL。首先，前往AWS中的API网关服务并点击开始。
- en: 'When creating our first API, we should select New API and then we can give
    this API a name and Description, and click Create API:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的第一个API时，我们应该选择新建API，然后我们可以为此API命名和描述，然后点击创建API：
- en: '![](img/543102dc-9a66-4fb1-a561-902c6608f28b.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/543102dc-9a66-4fb1-a561-902c6608f28b.png)'
- en: New API
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新API
- en: 'You should now be on the configuration page for your API, but there are currently
    no endpoints created. Click on the Actions dropdown and select Create Resource.
    Doing this allows you to have the APIs for all of your Lex chatbots on a similar
    URL:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该处于API的配置页面，但目前还没有创建任何端点。点击操作下拉菜单并选择创建资源。这样做允许您将所有Lex聊天机器人的API放在类似的URL上：
- en: '![](img/2ecb5089-fd69-4916-a4ff-941828ff82a7.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ecb5089-fd69-4916-a4ff-941828ff82a7.png)'
- en: Creating a resource
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源
- en: 'Name the resource `shopping-bot` and click Create Resource:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将资源命名为`shopping-bot`并点击创建资源：
- en: '![](img/48f70655-e9d9-4596-8749-3d44cb4f9cb7.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48f70655-e9d9-4596-8749-3d44cb4f9cb7.png)'
- en: New resource
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 新资源
- en: 'Now that we have a resource created, we can attach a method to it. In our Lambda,
    we check that the `httpMethod` is `POST` so we need to create a `POST` method.
    Click on our `shopping-bot` resource and click Actions | Create Method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个资源，我们可以向其附加一个方法。在我们的Lambda中，我们检查`httpMethod`是否为`POST`，因此我们需要创建一个`POST`方法。点击我们的`shopping-bot`资源，然后点击操作
    | 创建方法：
- en: '![](img/5d8ee865-703f-43cb-830f-5a4cd035e4bd.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d8ee865-703f-43cb-830f-5a4cd035e4bd.png)'
- en: New method
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法
- en: This will open the method setup window, and there are a lot of ways to configure
    your method, but we're going to call our API Lambda. Make sure the integration
    type is Lambda Function and that Use Lambda Proxy integration is ticked. This
    makes sure that all of the request data is proxied through to the Lambda.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开方法设置窗口，有很多人配置方法的方式，但我们将调用我们的API Lambda。确保集成类型是Lambda Function，并且已勾选Use Lambda
    Proxy integration。这确保了所有请求数据都通过代理转发到Lambda。
- en: 'The next thing in the method setup is to select our `lex-shopping-api` as the
    Lambda function and to Save the method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法设置中的下一件事是选择我们的`lex-shopping-api`作为Lambda函数，并保存方法：
- en: '![](img/fd0b461b-c40d-4e95-9a06-5899d47a191a.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd0b461b-c40d-4e95-9a06-5899d47a191a.png)'
- en: Method setup
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 方法设置
- en: 'Finally, we need to add **cross-origin resource sharing** (**CORS**) to our
    API. This allows us to access our API from different internet browsers. This will
    be important when we build a frontend for this API in the next section. Select
    our shopping-bot resource, and then we can click Actions | Enable CORS. We can
    leave all of the settings as default and click Enable CORS and replace existing
    CORS headers, confirming that we want to replace existing values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的API中添加**跨源资源共享**（**CORS**）。这允许我们从不同的互联网浏览器访问我们的API。在下一节构建此API的前端时，这将非常重要。选择我们的shopping-bot资源，然后我们可以点击Actions
    | Enable CORS。我们可以保留所有设置默认，并点击Enable CORS，替换现有的CORS头部，确认我们想要替换现有值：
- en: '![](img/ff23ddda-abcc-4207-9814-f6bcd707b262.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff23ddda-abcc-4207-9814-f6bcd707b262.png)'
- en: Adding CORS
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 添加CORS
- en: Testing
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'We can now test that our Lambda is being called properly by selecting the POST
    method and clicking on TEST:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过选择POST方法并点击TEST来测试我们的Lambda是否被正确调用：
- en: '![](img/b8150dd5-b5f9-4076-8f57-45010bf319ba.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8150dd5-b5f9-4076-8f57-45010bf319ba.png)'
- en: Method TEST
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 方法TEST
- en: 'In this screen, we can set query strings, headers, and the request body. We
    don''t need to send any query strings or headers, so we can scroll straight down
    to the request body section. As we should remember from the testing of the Lambda,
    all we need to pass through in the body is the `text` and a `sessionID`, so this
    is what we can put as the request body:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，我们可以设置查询字符串、头部和请求体。我们不需要发送任何查询字符串或头部，因此我们可以直接滚动到请求体部分。正如我们应该从Lambda的测试中记住的那样，我们只需要在体中传递`text`和`sessionID`，所以这就是我们可以作为请求体放入的内容：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we hit Test, API Gateway will send our request through to our Lambda.
    Our Lambda will send it to our Lex chatbot and will send back the response. Our
    response body should come back like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击Test时，API Gateway会将我们的请求发送到我们的Lambda。我们的Lambda会将它发送到我们的Lex聊天机器人，并将响应发送回来。我们的响应体应该返回如下：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Building the API
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API
- en: 'The last thing to do is to build our API. While on our API, we can select Actions
    | Deploy API. As this is the first time we are deploying this API, we need to
    create a new stage. Give your stage a name and description, and you can also add
    a deployment description before clicking Deploy:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是构建我们的API。在我们处于API上时，我们可以选择Actions | Deploy API。由于这是我们第一次部署此API，我们需要创建一个新的阶段。给你的阶段起一个名字和描述，你还可以在点击Deploy之前添加一个部署描述：
- en: '![](img/6327ffc6-b6fc-4071-9158-8db8908066b1.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6327ffc6-b6fc-4071-9158-8db8908066b1.png)'
- en: Creating a stage
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个阶段
- en: When your API deploys, you'll be given a URL for it, which will be `https://{unique-code}.execute-api.eu-west-1.amazonaws.com/{stage-name}`.
    To access the endpoint that we made, we need to add `/shopping-bot` to the end.
    For example, `https://acffds-4fnf8x-se54fws-s34d.execute-api.eu-west-1.amazonaws.com/production/shopping-bot`.
    This now means you can use this API to integrate Lex into a wider range of systems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的API部署时，你会得到一个用于它的URL，它将是`https://{unique-code}.execute-api.eu-west-1.amazonaws.com/{stage-name}`。为了访问我们制作的端点，我们需要在末尾添加`/shopping-bot`。例如，`https://acffds-4fnf8x-se54fws-s34d.execute-api.eu-west-1.amazonaws.com/production/shopping-bot`。这意味着你现在可以使用这个API将Lex集成到更广泛的系统中。
- en: Web user interface
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页用户界面
- en: Having our own chatbot interface allows users to access it by going to a web
    page, but we can also integrate that into other websites, or even create mobile
    apps for our chatbot. We can use the API that we created to easily access the
    chatbot without making our AWS credentials public.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有自己的聊天机器人界面允许用户通过访问网页来访问它，但我们也可以将其集成到其他网站中，甚至为我们的聊天机器人创建移动应用。我们可以使用我们创建的API来轻松访问聊天机器人，而无需公开我们的AWS凭证。
- en: HTML
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML
- en: 'To start, we need an HTML page to build upon. The three components that we
    need to start are a message area, a typing input box, and a send button. Create
    a folder with an `index.html` file inside and we can add this code to that file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个HTML页面来构建。我们需要开始的是三个组件：一个消息区域、一个输入框和一个发送按钮。创建一个包含`index.html`文件的文件夹，并将此代码添加到该文件中：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a simple HTML file that has a CSS link in the header so we can style
    our page, the message area, input box and button, and two scripts. The first of
    these scripts imports `axios` so we can easily make requests, and the second is
    our own script.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的HTML文件，在标题中有一个CSS链接，这样我们就可以样式化我们的页面、消息区域、输入框和按钮，以及两个脚本。其中第一个脚本导入`axios`，这样我们就可以轻松地发出请求，第二个是我们的脚本。
- en: As we've included the `style.css` and `script.js` files, we should create these
    files in our folder.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经包含了`style.css`和`script.js`文件，我们应该在我们的文件夹中创建这些文件。
- en: Creating our script
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的脚本
- en: All of the functionality of this UI needs to be handled in this script file.
    When all of the HTML has loaded, we need to listen for the user clicking the Send
    button. When that happens, we need to get the text from the input box and write
    it as a sent message before sending it to our API. When our API replies, we can
    add the response as a received message.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI的所有功能都需要在这个脚本文件中处理。当所有HTML加载完成后，我们需要监听用户点击发送按钮。当发生这种情况时，我们需要从输入框获取文本并将其作为已发送消息写入，然后再将其发送到我们的API。当我们的API回复时，我们可以将响应作为接收到的消息添加。
- en: 'To start, we need to make sure that the document has fully loaded. We can check
    if the document is ready, and if not, then we wait for the `DOMContentLoaded`
    event:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保文档已完全加载。我们可以检查文档是否已准备好，如果没有，则等待`DOMContentLoaded`事件：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now create the `start` function and set the API URL and session ID.
    We can use the `Math.random()` technique to make a random 16-digit number for
    the `sessionID`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`start`函数并设置API URL和会话ID。我们可以使用`Math.random()`技术生成一个随机的16位数字作为`sessionID`：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the `start()` function, we also need to access the message area, text input
    box, and send button, using `document.querySelector`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start()`函数中，我们还需要使用`document.querySelector`访问消息区域、文本输入框和发送按钮：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On to the `sendButton`, we can attach a listener for when the user clicks send.
    This will start by getting the value of the text input box. If there isn''t any
    text then we can return nothing from the function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`sendButton`，我们可以为用户点击发送时附加一个监听器。这将首先获取文本输入框的值。如果没有文本，则可以从函数中返回空值：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If there is any text, then we can carry on to create a `sendElement` and add
    it to the message area. We need to make sure to add the classes of `sendMessage`
    and `message` to the element so we can style them later:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有文本，则我们可以继续创建一个`sendElement`并将其添加到消息区域。我们需要确保为元素添加`sendMessage`和`message`类，以便我们稍后进行样式化：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we have to send the message to our API. We can use `axios` as we imported
    it in the HTML file, passing through `text` and `sessionID` as the body. We need
    to make sure to copy the function from our Lambdas for error-handling here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将消息发送到我们的API。我们可以使用在HTML文件中导入的`axios`，通过`text`和`sessionID`作为正文传递。我们需要确保从我们的Lambdas函数中复制函数以进行错误处理：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If there is an error in the response, then we can set the message to an apology;
    otherwise, it will be the `response.data.message`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应中存在错误，则可以将消息设置为道歉；否则，它将是`response.data.message`：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last thing to do is to add the received message to the message area so
    the user can see it. Don''t forget to add the `receivedMessage` and `message`
    classes for styling later:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是将接收到的消息添加到消息区域，以便用户可以看到它。别忘了添加`receivedMessage`和`message`类以便稍后进行样式化：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we open the HTML document in a browser, now we should be able to type and
    send messages to our Lex chatbot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开HTML文档，现在我们应该能够输入并发送消息到我们的Lex聊天机器人：
- en: '![](img/539ba00f-2cb9-4ad3-ae2d-e9e360adf312.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/539ba00f-2cb9-4ad3-ae2d-e9e360adf312.png)'
- en: Basic messaging
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 基本消息功能
- en: Styling the frontend
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端样式化
- en: 'We''ve created an awesome web page that allows users to talk to a chatbot,
    but, currently, it looks awful. We can fix this by using our CSS file. While building
    the chat, we''ve been adding classes and IDs to the elements. This means we can
    set styles on those classes and ids to style our whole chat window. The first
    thing to do is to set the size of the message area. We can also add a light background
    and set the overflow to scroll:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个很棒的网页，允许用户与聊天机器人交谈，但，目前，它看起来很糟糕。我们可以通过使用我们的CSS文件来修复这个问题。在构建聊天时，我们一直在向元素添加类和ID。这意味着我们可以设置这些类和ID的样式来美化整个聊天窗口。首先要做的是设置消息区域的大小。我们还可以添加一个浅色背景并将溢出设置为滚动：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we can style the messages. We add common styling to the `message` class
    such as the `padding`, `margin`, and `max-width`, while the alignment, `background`,
    and `border-radius` are defined on each type of message:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以美化消息。我们向`message`类添加了常见的样式，如`padding`、`margin`和`max-width`，而`alignment`、`background`和`border-radius`则在每个消息类型中定义：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last bit to style is the input textbox and send button. We can use `display:
    flex` on the container `div` and `flex-grow: 2` on the text input so that it stretches
    to fill the width left by the button. We can style the button up a bit with a
    different border and background:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '最后要美化的部分是输入文本框和发送按钮。我们可以在容器`div`上使用`display: flex`，并在文本输入上使用`flex-grow: 2`，使其填充按钮留下的宽度。我们可以通过不同的边框和背景来美化按钮：'
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This results in a much nicer user experience than the plain text we had before.
    This is where you can spend some time customizing the look of your interface to
    be exactly how you want it to be.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们之前使用的纯文本提供了更好的用户体验。这就是你可以花时间定制你的界面外观，使其完全符合你想要的样子。
- en: 'You can even style this to match the brand colors of a company:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以将此样式调整为与公司的品牌颜色相匹配：
- en: '![](img/13e37d4f-a664-4340-88e3-91e03230cab3.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13e37d4f-a664-4340-88e3-91e03230cab3.png)'
- en: Styled chat
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 美化后的聊天
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned how to create integrations that allow users to
    access our chatbots from Facebook Messenger, Slack, and Twilio.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何创建集成，使用户能够从Facebook Messenger、Slack和Twilio访问我们的聊天机器人。
- en: We've also learned how to create an API to give us the ability to integrate
    our chatbots into other services that Amazon doesn't currently support. This API
    used a Lambda function to handle the requests sent through API Gateway.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何创建一个API，以便将我们的聊天机器人集成到亚马逊目前不支持的其他服务中。这个API使用Lambda函数来处理通过API Gateway发送的请求。
- en: We then used this API to create a frontend web page for our chatbot. We wrote
    a simple HTML document and then used a script to communicate with the API and
    add the messages to the page. The last thing we did was add styling to the page
    so that it looked like a real messaging platform.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这个API为我们的聊天机器人创建了一个前端网页。我们编写了一个简单的HTML文档，然后使用脚本与API通信并将消息添加到页面中。我们最后做的事情是为页面添加样式，使其看起来像真正的消息平台。
- en: Questions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we want to integrate our chatbots into other platforms and services?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要将聊天机器人集成到其他平台和服务中？
- en: What services can you use to create an API?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用哪些服务来创建一个API？
- en: What two things do we need to add to an API before it will work?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在API工作之前，我们需要添加哪两个东西？
- en: What is the last thing that we need to do to make our API public?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的API公开，我们需要最后做什么？
- en: Name the three parts of our chatbot web page.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请命名我们聊天机器人网页的三个部分。
- en: What is the first thing a loaded script file should do?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载的脚本文件应该首先做什么？
