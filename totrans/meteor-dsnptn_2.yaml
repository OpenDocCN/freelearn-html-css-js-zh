- en: Chapter 2. Publish and Subscribe Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is by far the most important chapter in this book. The way we control
    our publishers and subscribers is going to define how quickly our application
    responds in production. Publishers and subscribers are the link between our database
    and the client. The server uses publishers to publish information to the client,
    while the client requests information from the publishers by subscribing to them.
    This is all managed via the `Meteor.publish` and `Meteor.subscribe` functions.
    We should be able to produce the data that the client wants to see with two objectives
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduce stress from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send only the information that the client needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will teach you the different patterns that you can use to attain
    these objectives for every template that you build. Here is an overview of the
    topics we will cover to understand these patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Template-level subscriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing with relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation publishers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External API publishers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template-level subscriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern attaches the `Meteor.subscribe` functions to templates. The key
    advantage of subscribing from the template is the ability to isolate the template
    and know that it still works when it is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Many Meteor developers attach their subscription methods to their routes. This
    means that the template will only render with the correct data at that particular
    route.
  prefs: []
  type: TYPE_NORMAL
- en: With this pattern, we will be able to reuse templates anywhere without worrying
    about data.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up products for the online shop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by setting up a `Products` collection in MongoDB for our `online_shop`
    project. In [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started
    with Meteor"), *Getting Started with Meteor* we learned that we need to place
    this definition under the `/globals/lib/collections` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that we are adding `@` at the beginning of the `Products`
    variable. This compiles into `this.Products`. In CoffeeScript for Meteor, we do
    this to define a globally scoped variable. This means that the `Products` variable
    now exists in every CoffeeScript file that we will create.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add a permission file as well so that we can modify the collection
    from the console. The `allow`/`deny` functions are rules that add a layer of security
    to the collections. If an `allow` rule returns `true` for a given action, it will
    allow the change to pass. For now, we are going to set all the rules to allow
    everything. We will address permissions when we look at roles in [Chapter 4](part0035_split_000.html#page
    "Chapter 4. Application Patterns"), *Application Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Meteor.startup` function to make sure that we have set up `Products`
    as a collection before we set the `allow`/`deny` rules. Now that we have a collection,
    let''s make the landing page to show us a list of products. Let''s build the **view**
    first in the `/products/client` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This view is just a placeholder. We always need to create the template object
    before we can actually begin working with the publishers and subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Building the publisher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's construct a simple publisher for our view using the `Meteor.publish` function.
    This publisher will send only 10 documents to the subscribed clients. We'll discuss
    pagination in [Chapter 4](part0035_split_000.html#page "Chapter 4. Application
    Patterns"), *Application Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing to the publisher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is where the magic begins. We are going to use the `Template.<template>.onCreated`
    function to subscribe to our publisher. The `onCreated` function runs whenever
    an instance of the template is created in the DOM. So, if we place a `Meteor.subscribe`
    function within this function, this will automatically resubscribe whenever the
    template is used. Let''s give it a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We only need to change the first line of the code. This is done so that we can
    attach multiple functions to the `onCreated` template hook without overwriting
    any other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Database relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our collections will always be related in one way or another to other collections
    in our database. This topic is going to examine the three different types of relationships
    you should be thinking about when you are designing your database.
  prefs: []
  type: TYPE_NORMAL
- en: The shape that our database will take ultimately defines what our publishers
    are going to look like. If your data is all mashed up in just one or two different
    collections, you will very quickly find yourself struggling to filter data. If
    your data is spread too far between collections, the code will become difficult
    to maintain in the long run. So what is the solution to this problem?
  prefs: []
  type: TYPE_NORMAL
- en: The solution to database relationships is to understand how the data is going
    to be used in the client, how often it is going to be modified, and how large
    the set can be.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build out the rest of our collections to get a notion of what good relationships
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: One to one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A one to one database relationship describes how one MongoDB document in a collection
    will be linked to only one other MongoDB document in another collection. You can
    think of this as a JavaScript object inside another object.
  prefs: []
  type: TYPE_NORMAL
- en: In Meteor, you should create a one to one relationship for a subset of fields
    that you will use sparingly, that will have unique interfaces, or that you will
    use without necessarily requiring access to the product. With this relationship,
    it is going to be very easy to build an image uploader and a collage of images
    showing only `master_image`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a collection that will handle our products'' images: `ProductImages`.
    We are going to assume that our frontend is going to have multiple types of images,
    each one being presented in a different part of the interface that we are building:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductImages` collection is going to contain a field named `product`.
    This field establishes our relationship by saving the unique `_id` field from
    the `Products` collection. This means that every time we want to publish a product
    with `ProductImages`, we need to query the database as well by searching for `Product_id`
    within `ProductImages`. So a helper would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One to many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A one to many database relationship describes how one MongoDB document in one
    collection will be linked to many MongoDB documents in another collection. You
    can think of this as an array of JavaScript objects that exists under a particular
    field but the data is so complex that you need to separate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create an `Orders` collection. This collection is going to function
    as a cart. While your first instinct may be to create a `Carts` collection, you
    will quickly find that you are duplicating the order information (one for the
    cart and one for the order, once it is placed). We can easily identify whether
    an order is new or not by adding a `status` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's not forget to add permissions for the collection as well. We need to do
    this every time we create a new collection to secure the collection from hackers
    and ensure that the client can modify the collection accordingly. We will cover
    more on this in the *Security* section of [Chapter 4](part0035_split_000.html#page
    "Chapter 4. Application Patterns"), *Application Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Something is wrong with this, the products are not defined in the collection!
    We intentionally created an order summary collection that is going to have a one
    to many relationship with order details. We do not know how extensive the order
    actually might be. If we include a field that holds an array of products, this
    list will not only be difficult to manage, but also could potentially become large
    enough that it will crash the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the details of our order in a separate collection called `OrderDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now we can say one `Order` has many `OrderDetails`. In this scenario,
    each document in the `OrderDetails` collection represents a single product and
    the details about that product within the order. We have added the `order` field
    to identify to which specific order the details (or in this case, the products)
    belong to.
  prefs: []
  type: TYPE_NORMAL
- en: This is excellent design. By separating the details from the order, we are capable
    of controlling exactly which data the server sends down to the client. Remember,
    the goal here is to send the least amount of data possible to the client so that
    the site loads quickly and stress on the server is reduced. Managing inserts and
    updates as well becomes easier. As we do not need to deal with indexing a details
    array, we can simply use IDs to find and manipulate data. Now when the shop admin
    subscribes to the `Orders` collection, we can do this in such a way that the server
    only sends the data the admin needs to see the orders. Clicking on an order would
    then lead to subscribing to only that orders' details.
  prefs: []
  type: TYPE_NORMAL
- en: Many to many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A many to many database relationship describes how many MongoDB documents in
    one collection will be linked to many MongoDB documents in another collection.
    You can think of this as a table where you repeat information and only change
    the information of one field for every row so that you can filter the information
    by that row.
  prefs: []
  type: TYPE_NORMAL
- en: These types of relationships require a **mapping table**. In the case of MongoDB,
    a mapping table is a separate collection. A mapping table is the part that repeats
    information in every row without actually duplicating entries; it simply makes
    pairs between each collection ID.
  prefs: []
  type: TYPE_NORMAL
- en: In the example that we are going to program, we want to create a many to many
    relationship between products and tags because a product can have many tags and
    a tag can have many products. The mapping table in this case is going to save
    each ID pair. So if a product has two tags, there will be two entries in the mapping
    table with the same product ID but each with a different tag ID. If a tag is a
    part of two products, then the mapping table will have two entries with the same
    tag ID but each one with a different product ID.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that these types of relationships are often overlooked
    because of their complexity. If for some reason you find yourself trying to match
    two collections with arrays from each collection, you are definitely attempting
    a "many to many" relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain this relationship, we are going to create a `Tags` collection for
    our products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that in this type of relationship the `Tags` collection has
    nothing to associate to a product, but if it did, it would have to be an array
    of products to which the tag belongs to. To establish the relationship, we will
    create the mapping table, that is, the `ProductsTags` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This collection allows us to have any combination of relations between `Products`
    and `Tags`. Suppose we want to see all the products related to one tag. In this
    case, we will first query the mapping table for that tag and then query the tags
    using the result.
  prefs: []
  type: TYPE_NORMAL
- en: Beware! Many to many relationships can be difficult to spot. If you are stuck
    at any point during your database design process, do not forget to consider this
    possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing with relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We understand how our collections are related, but how can we make it easy to
    publish data with these relationships?
  prefs: []
  type: TYPE_NORMAL
- en: In Meteor, it can be problematic to publish relationships because of reactivity
    and the way publishers work. You would expect that by simply making two queries
    to two related collections and returning an array will publish a perfectly reactive
    collection. This is not the case. A `Meteor.publish` function does not rerun when
    dependencies change. This means that if a relationship is broken, the related
    document will remain published, or worse if a new relationship is made by another
    client, the related data will not publish.
  prefs: []
  type: TYPE_NORMAL
- en: To take care of database relationships and reactivity in Meteor, we use the
    `lepozepo:publish-with-relations` package. This package automatically takes care
    of subscribing to new data in the most efficient way possible when relationships
    are broken. If you are familiar with MySQL, this package makes JOINs a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing products with images (one to one)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be working with the `/products` directory, this module will be our
    landing page. First, let''s set up a route for our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `FlowRouter.route` function to define the path of our landing
    page and the `FlowLayout.render` function to define which layout template to use.
    You will notice that the `FlowLayout.render` function is taking in two parameters:
    the first one defines which layout template to render, and the second one defines
    where to render within that layout template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can work on the publisher. The goal is to publish 10 products paired
    with only their `master_image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `mappings` key of the object that we are passing through the `@relations`
    function. All the objects inside the array must have at least a `collection` key.
    Optionally, they can take `key` and `foreign_key`. In this case, we use `key`
    to express that the `_id` field in the `Products` collection is equal to the string
    of the `product` field in the `ProductImages` collection. This is the most efficient
    way to publish data. The package will automatically make sure that all changes
    to the collections are reflected in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Meteor.publish` function has one peculiarity: when data changes, the cursor
    will react accordingly, but the function holding the cursor will not. The impact
    of this is obvious when it comes to creating relationships. Let''s look at what
    our code would look like without using a package to handle our relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, suppose that for some reason the order of the `Products` collection
    changes. This will make `products_cursor` change reactively as you would expect
    on the client, but because there were no changes to the `ProductImages` collection
    and `Meteor.publish` does not rerun when there is a change in one of its dependencies,
    the images of the newly published products will not be published reactively!
  prefs: []
  type: TYPE_NORMAL
- en: Publishing orders with details (one to many)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will work on our `Orders` and `OrderDetails` collections. Let''s set
    up our template, route, and subscriber for the function that creates orders. We
    can name this module as `cart` and store it under the `orders` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `order` variable is going to get our order `_id` by using the
    `Session` variables. We do this because the `Session` variables are reactive;
    if for some reason the value changes, this makes sure that the subscriber reruns.
    The subscriber reruns because the variable is defined within the `@autorun` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we are passing an object as an argument to the `@subscribe` function
    so that the publisher knows what order we are talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to publish three different collections to have all the information
    that our cart needs: `Orders`, `OrderDetails`, and `Products`. This publisher
    can follow the same logic that we found in the first publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This publisher is predefining defaults for the function by passing `ops={}`
    within the parameters (another useful shortcut that CoffeeScript provides). After
    making sure that `ops.order` exists and is not a blank string, we establish our
    relationships. We need to make sure that the status of `Order` has the `"new"`
    value for security, so we hardcode it in the `filter` key.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in this case, we are making use of `foreign_key`. This indicates
    that the `OrderDetails` collection has a `product` field that contains a string
    equal to the `_id` field of the `Products` collection.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we are going to limit `OrderDetails` to `25`.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a tag with products (many to many)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We definitely want to be able to filter our products via tags. We can follow
    the same pattern from the previous topic. Let's modify our `products` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our subscriber needs to reactively change to an array of tags _ids.
    We can use a `Session` variable for now to set an array of tag _ids so that we
    can easily modify this directly from the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We use underscore''s `_.extend` function to make sure that the `filter` variable
    has a `tags` key, if `tags` exist. Now our publisher is going to get a bit more
    complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While the code may seem long, the logic is easy to understand. First, we filtered
    our `Tags` collection by using the `tags` array that we had defined in our subscriber.
    Then we chained the relations using a combination of `key` and `foreign_key`.
    The function that the mapping table (`ProductsTags`) serves is clear in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Key, foreign key, options, and filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core concepts to understand from the `lepozepo:publish-with-relations` package
    are simply the options provided within the `@relations` function.
  prefs: []
  type: TYPE_NORMAL
- en: Both `key` and `foreign_key` default to the `_id` field. The `key` always makes
    reference to a field within the collection while the `foreign_key` always makes
    reference to a field of the parent collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `options` and `filter` options are equivalent to the second and first arguments
    (respectively) of a Meteor - MongoDB query: `Products.find(filter,options)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many packages that work similar to `lepozepo:publish-with-relations`,
    and we are not exploring them in this book, but they are certainly worth keeping
    an eye on: `reywood:publish-composite`, `lepozepo:reactive-publish`, and `cottz:publish-relations`.
    I have found the last package to be the best of the bunch because it is simple
    to use and forces the developer to create smarter database relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation publishers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes our database has a considerable amount of information that we want
    to synthesize. Some developers choose to publish all the information to the client
    and have the client synthesize it. This, as we have learned so far, can have a
    negative impact on performance. Other developers might use `Meteor.method` to
    return the synthesized data. This is definitely better for the client, but it
    will take a toll on our server if the computation is large.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to handle a problem like this is to use MongoDB''s aggregation
    framework to take the hard work of the calculation to our database, and then we
    can pair the results with the `Meteor.publish` special functions: `@added`, `@changed`,
    and `@removed`.'
  prefs: []
  type: TYPE_NORMAL
- en: The aggregation framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB's aggregation framework uses the concept of a pipeline to process data.
    A pipeline is, basically, a series of steps that Mongo is going to follow to produce
    the data you need.
  prefs: []
  type: TYPE_NORMAL
- en: We have installed support for the aggregation framework by adding `meteorhacks:aggregate`.
    This gives us access to all of the framework's server-side commands. The most
    common commands that you will end up using are `$match`, `$group`, and `$project`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a publisher for our `dashboard` module and start by building the
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to build a collection that exists only on the client. Our server
    will communicate with this collection manually. We specifically place this collection
    on the client side because we do not want the server to record data onto the database.
    We can append the collection to the (`/dashboard/client/dashboard.coffee`) client
    controller file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As this collection is client-side, we have differentiated it with an underscore
    at the beginning of the name. This, of course, is not required, but it helps prevent
    duplicate collection names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to publish the sum of the total and subtotal for the `"pending"`
    orders. The steps for our pipeline are simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Filter the collection to show orders with status equal to `"pending"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sum the totals of every filtered order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To use the aggregation framework, you use the `.aggregate` function that is
    attached to the collection object; `Orders`, in this case. This function only
    takes an array as a parameter—this is because the array is the ordered set of
    steps that the framework is going to follow. Each step is represented by an object
    within the array and always begins with an operator.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have decided to use `$match` to filter the orders to find the pending
    orders, and then we have used `$group` to accumulate the values of `total` and
    `subtotal`. Notice that the `$group` expression has a mandatory `_id` key. This
    key defines how we want to group the collection. By setting the `_id` key to `null`,
    we are stating that we want all the documents in the collection grouped into one
    single object.
  prefs: []
  type: TYPE_NORMAL
- en: '`$sum` is an accumulator operator. When you use an operator like this, you
    can access a document property by using the money sign (`$`) followed by the name
    of the field within a string. Also, you can access objects within objects using
    the dot notation (`"$discount.amount"`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of `totals` is an array containing a single object with the keys:
    `total`, `subtotal`, and `discount`.'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Publishing the results is much easier than it seems. We only need to use the
    `@added` function that is bound to `Meteor.publish`. The `@added` function, basically,
    informs the subscriber that data has been added to the published set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines make sure that the `totals` array exists, and if it does
    not, then we publish the first object within the array to our `_dashboard` collection.
    The `@added` function has three required parameters. The first parameter is the
    name of the collection, the second is the `_id` of the document, and the third
    is the document.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that these kinds of publishers are not reactive, which means that we
    do not need to add a `@changed` or `@removed` function. We can take this a step
    further though. Instead of creating a collection for every module that needs an
    aggregation publisher, we can create one master collection that manages all our
    aggregation publishers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we remove our `_dashboard` collection and create a new `Aggregate` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to modify our publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can now access our values by calling the following function on
    our client-side console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It's important to understand that as soon as we leave the route, the subscriber
    will be stopped and the `aggregate` collection will be cleared. This default behavior
    gives this collection a lot of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Why is using the aggregation framework with a publisher more effective than
    with `Meteor.method`? The Meteor methods are designed to trigger critical functions
    within our server and respond with a simple message. On the other hand, publishers
    are designed to control data sets. You will very quickly find that publishers
    are easier to control and optimize than methods.
  prefs: []
  type: TYPE_NORMAL
- en: External API publishers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These types of publishers should be avoided. They are great to get raw data
    from external services such as **Stripe** or **Square**, but they tend to be little
    bit slower because this involves actively communicating with another server. When
    we are integrating with other servers, we should always build a separate synchronization
    server. We will talk about APIs in another chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Still, this publishing pattern can be useful in edge cases, so it is important
    to know that this option exists.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP is a protocol for collaborative systems; it is the protocol that allows
    users to connect to web pages. The HTTP protocol can be used to access data from
    other servers from our own server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use Meteor''s integrated HTTP `Request` module to communicate
    with Stripe''s servers. We chose to integrate with Stripe because it is a payment
    processor that is easy to integrate and more reliable than most other payment
    processors in the market. We have added this package when we ran `meteor add http`.
    This module has all the functions that you would expect: `.get`, `.post`, `.put`,
    and `.del`. For this topic, we are only going to cover the `.get` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to get data from Stripe. Start by creating a free account in Stripe.
    After you have created your account, go to your dashboard and set it to `"test"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a payment by clicking on **+ Create Payment**. Use the following
    data for the payment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amount**: `10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Card Number**: `4242 4242 4242 4242`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our test environment, we do not need to add CVC, and Stripe automatically
    sets the expiration date to a year from today.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Account Settings** and copy your test secret key. We are going to
    use this to authorize our request.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by creating a new publisher under `/dashboard_pub.coffee`; we
    are only going to get the last three charges—we will modify this later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `@unblock` function that we are using here has been made available via the
    `meteorhacks:unblock` package. It works the same way as the `@unblock` function
    does in `Meteor.methods`; this makes sure that the publisher does not block the
    server while it is waiting for information from Stripe to arrive. Unblocking the
    aggregation publishers is crucial! If we do not unblock the publisher, then we
    risk the client becoming unresponsive when the user navigates away from the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking yourself: can''t we just make the HTTP request on the client
    and not worry about blocking the server? No, we cannot. If you were to run this
    function on the client, you would have to expose your secret key, and this is
    a major security flaw.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HTTP.get` function has three important fields: the URL, the `options`
    object, and the callback function. The URL is the address that Stripe provides
    in their API documentation—in this case, we have used the `/charges` URL and passed
    a parameter `limit` to get the last three sales. The options object is used to
    pass all the information that the request needs. In this case, we will use the
    `headers` key to set our `Authorization` header. There are several keys that the
    options object can take; you can find these at [docs.meteor.com](http://docs.meteor.com).
    Our callback function receives the result from the request. As with most functions
    in Meteor, it returns two arguments; the first one is an error object that is
    undefined if there is no error, while the second one is the actual result.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the data that we are looking for is contained within `result.data.data`
    as an array. We can then easily publish the data with our `@added` function. Notice
    that we are binding both the callback and the `_.each` function, so we can have
    access to `@added`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s subscribe to our new publisher to see our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Try running `Aggregate.find().fetch()` in your console to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to isolate subscribers from templates using
    template hooks. Also, we learned how to optimize the structure of our database
    depending on how we are going to use it. When it comes to publishers, we learned
    how to return every possible data structure without breaking reactivity. We covered
    aggregation publishers and learned how to synthesize data before we publish it,
    without hurting the performance of the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover a handful of frontend techniques that will
    help us to keep our code flexible and our frontend looking great.
  prefs: []
  type: TYPE_NORMAL
