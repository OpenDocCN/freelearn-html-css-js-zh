- en: Chapter 10. Enterprise Grade Modular Design, AMD, CommonJS, and ES6 Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter of the book, we are going to mainly focus on re-factoring
    some of our application modules so we can have a more robust way of loading and
    managing them.
  prefs: []
  type: TYPE_NORMAL
- en: The title of this chapter mentions Enterprise Grade, but in fact we can use
    the principles discussed here for applications of any size and type. In the next
    sections, I'll introduce you to various approaches for creating and loading modules
    in JavaScript and talk about the environments that each approach might be better
    suited for. You'll also see how we can manage our module dependencies in a more
    structured manner.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this chapter is meant to be only an introduction to such techniques,
    but hopefully it will make you curious enough to research them further.
  prefs: []
  type: TYPE_NORMAL
- en: I believe after seeing their benefits, you'll consider these modular design
    implementations in your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics that we will cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Why we need a better setup for loading our modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD module format and how to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for creating AMD modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CommonJS module format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 6 modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting index.html file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you recall, in [Chapter 8](ch08.html "Chapter 8. Application Implementation
    – Putting It All Together"), *Application Implementation – Putting It All Together*,
    I mentioned that we were using quite a few `<script>` tags in our `index.html`
    file to load our application's modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To refresh your memory, here is what we had:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting index.html file](img/B04910_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While this implementation worked, it was not very scalable, since for each module
    file we needed to add a `<script>` tag to our page. Also, by looking at the list
    of files being loaded, we could not determine how each module or component was
    dependent on another piece (or pieces) of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had to create another `<script>` tag at the bottom of the page as well,
    which took care of booting-up the application, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting index.html file](img/B04910_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It would be nice if we could eliminate the need for having all the `<script>`
    tags and our boot-up sequence in `index.html`. Also, it would be very useful to
    implement a mechanism which could indicate and mange our modules' dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we are going to achieve all that very soon!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts how the new approach will clean up our `index.html`
    file and provide us with a more robust script-loading capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting index.html file](img/B04910_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the page has been shortened considerably and there is only
    one JavaScript file that is loaded in `index.html` now. This file is `require.js`,
    with its data-main attribute set to `js/config`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Loading this script is all we need to do in order to load all of our modules
    and components, and to start up the application.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a look at how this magic has taken place shortly, but before doing
    so, we need to talk about **AMD** modules.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Asynchronous Module Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous Module Definition** (**AMD**) format for creating modules in
    JavaScript, is targeted for use in browsers. This format proposes a particular
    way for defining modules so that modules and their dependencies can be loaded
    into the browser asynchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two key methods that you need to use when creating and consuming AMD
    modules, these are `define` and `require` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that we create a module using the global `define` method and then
    we can import that module in other parts of the code (other modules) using the
    global `require` method.
  prefs: []
  type: TYPE_NORMAL
- en: Defining modules using AMD format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is how a module can be defined in AMD format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are passing three arguments to the global `define`
    method, which has been provided to us by an AMD-compatible module loader.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument, `moduleOneId`, is an optional parameter which assigns an
    ID to the module. Most of the time, we do not use this argument and other than
    some edge cases or when a non-AMD concatenation tool is being used to bundle our
    code, we leave it empty.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to `define` function is an array of dependencies, which
    tells the AMD module loader what modules (files) need to be loaded before executing
    the callback function. Of course, the third argument passed to `define` method
    is the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are returning an object from this callback function. This object
    is the module that we are defining. In AMD format, the callback function can also
    return constructors and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Importing AMD modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the module that we have defined in the preceding code, we can import
    it by using the global `require` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are asking the AMD module loader to load the dependency `moduleOneId`
    before executing the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we could also use the path to our dependency instead of using the
    related ID. For instance, we could write the preceding code snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: AMD format provides great flexibility in defining and loading our modules. It
    also eliminates the need for creating global variables to define the modules.
    AMD-compatible script loaders also often provide the capability to lazy-load our
    modules, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: There are many web development tools (libraries) that support AMD format, but
    the most popular ones are `RequireJS` and `curl.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In our application in this chapter, we will be using `RequireJS` to create our
    AMD modules and load their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an in-depth discussion on JavaScript modules and their related formats,
    I encourage you to visit a great post by *Addy Osmani* at [https://addyosmani.com/writing-modular-js/](https://addyosmani.com/writing-modular-js/).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RequireJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, one of the most popular AMD module loaders for the
    browsers is **RequireJS**. In this section, we will learn how to create and load
    modules using this tool.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run RequireJS on the server side using its related optimizer, `r.js`.
    The optimizer can package all of our AMD modules into one file and then the browser
    will only have to make one request to the server to load all the necessary modules.
    In this scenario, AMD format is used to manage dependencies among modules when
    they are being bundled on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you are using a server build setup for your client files,
    you may want to consider using `almond.js` for packaging your AMD modules. This
    is a much smaller library, but does not have the dynamic loading capabilities
    of RequireJS. For more information regarding `almond.js`, visit the following
    URL: [https://github.com/requirejs/almond/](https://github.com/requirejs/almond/).'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are not using a build system for our project, I will only cover using
    `RequireJS` for the browsers in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading RequireJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can download this library from the following location: [http://requirejs.org/docs/download.html#requirejs](http://requirejs.org/docs/download.html#requirejs).'
  prefs: []
  type: TYPE_NORMAL
- en: You can simple copy the minimized version of the tool and save it in your selected
    file location.
  prefs: []
  type: TYPE_NORMAL
- en: A test project for creating and loading AMD modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help you become more familiar with RequireJS, I have included an additional
    project called **requireJsLearning** in the source code related to this chapter.
    I encourage you to download this project and follow along as we continue our talk
    regarding AMD and RequireJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `requireJsLearning` project, I have saved the RequireJS library (`require.js`)
    in the `libs` folder, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A test project for creating and loading AMD modules](img/B04910_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's create some simple modules in this project and see how we can use RequireJS
    to load and manage them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple AMD module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We start by creating a simple AMD module in `person.js` file, under `modules`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the global `define` method that RequireJS
    has provided for us and passing two parameters to it. The first parameter is an
    array with two values. The first value in this array is a path to another module,
    which is a dependency for our `person` module.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are using the name of the file but without the `.js` extension.
    This is because RequireJS assumes the extension to be `.js` by default.
  prefs: []
  type: TYPE_NORMAL
- en: The second value in our dependency array is **jQuery**. We are not specifying
    a path for jQuery here, as it is being used as a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**jQuery and AMD format**'
  prefs: []
  type: TYPE_NORMAL
- en: As of version 1.7, jQuery supports AMD format. However, for it to be loaded
    properly as an AMD module, we can only place it in the same location as our `config.js`
    file. Since we would like to have all of our third-party libraries under `libs`
    folder in our project, we need to do a little bit of configuration. We will talk
    about this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter passed to `define` method is the callback function that
    gets executed after our `person` module's dependencies are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding code shows, this callback function receives two parameters,
    which are matched one-to-one to the dependency list defined for the `person` module.
  prefs: []
  type: TYPE_NORMAL
- en: We also return an object from this callback function which is our `person` module
    that can be consumed by other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming our person AMD module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `person` module is created as an AMD module, we can consume it as a dependency
    in other modules by only specifying its path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at how our `main` module (in `main.js`) requires and uses `person`
    module, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax should be a lot more familiar to you now. We are telling
    RequireJS (using `require` method) to load all the dependencies listed in the
    dependency array (the first argument to `require` method) and then pass them as
    arguments to the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: RequireJS in turn, will make asynchronous calls to the server (one call per
    module) to download all of the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Loading dependencies of dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Notice that our `main` module has listed `person` module as a dependency. However,
    `person` module itself has also listed `stuff` module as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, there is a dependency chain that needs to be resolved. When RequireJS
    looks for the dependency list of `main` module and sees `person` as a dependency,
    it then looks to see if `person` has any dependencies itself. If so, it will load
    those dependencies first. After that `person` module is loaded and passed to `main`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of this chain as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Load `stuff` module | pass it to `person` module | load `person` module | then
    pass `person` module to `main` module.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simplified view of how RequireJS manages dependencies and loads
    modules in the correct order, based on the dependency list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A small but important point**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding explanation, I mentioned the order of how modules get loaded
    based on the dependency list. The fact is that these modules can be physically
    loaded in a different order, but the important point to keep in mind is that all
    of the modules listed in the dependency list are loaded and the code in them is
    executed *before* the `callback` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and consuming non-AMD modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also need a way to load non-AMD modules or non-modular files in our projects,
    and RequireJS provides hooks to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: It also has many plugins which enable us to load CSS and text files, as well
    as providing many other capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In our **requireJsLearning** project, we have three modules (files) which are
    not using AMD module format. These are `person2`, `person3`, and `person4`. In
    order for RequireJS to load such modules and make them available for usage by
    other modules, we need to provide some configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at `config.js` file in our project, you see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are passing a configuration object to `require.config` method of RequireJS.
    The first property of this object defines `main` as a dependency (`deps: [''main'']`).
    Remember that `main` module is the module that boots up our application, but in
    `index.html` file, we told RequireJS to load `config.js` using `data-main` attribute,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When RequireJS loads `config.js` file, the configuration object is passed to
    `require.config` method. Then, RequireJS figures out that it needs to load `main.js`
    (by looking at the `deps: [''main'']` property on this object). Of course, in
    turn, by looking at the dependency list of `main` module, RequireJS loads all
    the dependencies for `main` module as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting paths in the config object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next property set in the configuration object passed to `require.config`
    method is `paths` property. This property itself is an object and it''s where
    we define the paths to our dependencies. For instance, see the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we tell RequireJS that, when it needs to load `person2`, it can find it
    in the `modules/person2.js` file. Remember that we do not provide the file extension
    for the file in this property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating shims for non-AMD modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next property that we define in object passed to `require.config` method
    is `shim` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`shim` property is an object too and is used to provide configuration settings
    for non-AMD modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, see how we are configuring `person3` module in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We tell RequireJS that, when you want to load `person3` module as a dependency,
    first you need to load `person4` (using `deps` property), and then let the consuming
    modules declare this module as a dependency using the keyword `person3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider how `stuff` module declares and consumes `person3` as a dependency
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can load and consume non-AMD modules asynchronously, thanks
    to RequireJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that everything is working as it should and all the dependencies
    are resolved properly, we can load `index.html` in the browser. We should then
    see the following messages in the debugger tools console (I''m using Chrome browser):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating shims for non-AMD modules](img/B04910_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I encourage you to have a look at the code related to this project (`requireJsLearning`)
    and use it to see how you can create, load, and consume modules using RequireJS.
  prefs: []
  type: TYPE_NORMAL
- en: For more in-depth information regarding this great library and the many different
    options that it provides, please visit [http://requirejs.org/](http://requirejs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: I hope this was a good introduction to AMD module format and RequireJS. Let's
    now use what we have learned from this section and re-factor our main application
    to load our modules the AMD way.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Images Inc. application to use AMD format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To leverage the functionality that RequireJS provides for us, we are going to
    take two different approaches here. First, we are going to convert all of the
    submodules in the Core module into AMD modules.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we are going to load all of our other files in the application, including
    our application's components, as non-AMD modules. These two approaches will provide
    us with a practical exercise to put our knowledge of RequireJS and AMD modules
    to good use.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Core submodules into AMD modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to look at `ImagesInc_Core.LoggingHandler` submodule
    and see how we can convert it into an AMD module. All the other submodules in
    the application can also be converted to AMD modules, following the same approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider how `ImagesInc_Core.LoggingHandler` submodule is implemented in our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We were using an IIFE to return an object as a property on `ImagesInc_Core`
    global object (which is our MainCore module). This returned object is the interface
    to the code inside of our IIFE namespace.
  prefs: []
  type: TYPE_NORMAL
- en: To convert this submodule to an AMD module, we simply need to transfer the code
    which was originally inside the IIFE to `define` method provided to us by RequireJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are still returning an object from the callback function and
    we are also assigning it to `LoggingHandler` property of `ImagesInc_Core` object.
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows us to easily convert our non-AMD submodules into AMD modules,
    with very little modification. This is mostly because, from the beginning, our
    architecture was designed to be a modular-based architecture. Now, thanks to RequireJS,
    we are able to load our submodule files asynchronously, without the need to add
    them as `<script>` tags to our `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Loading our non-AMD modules using RequireJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to load the rest of the files in our application, including MainCore,
    as non-AMD modules.
  prefs: []
  type: TYPE_NORMAL
- en: You may decide later on that you would like to convert these modules into AMD
    modules as well. I encourage you to do so, as it will be a valuable exercise.
    However, my goal here is to show you how AMD and non-AMD modules can work together
    in harmony, without much trouble at all.
  prefs: []
  type: TYPE_NORMAL
- en: As explained previously, to load non-AMD modules using RequireJS, we need to
    define them in `shim` property of our application's `config` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we load `config.js` file in our `index.html`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`config.js` file in turn will cause the loading of our `main.js` file (as it
    has been defined as a dependency for `config.js` file), which does the bootstrapping
    of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: It is time for us to have a closer look at our application's `config.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our application's config.js file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our application's `config.js` file consists of three main properties; `deps`
    property, which defines the dependencies of `config` file; `paths` property, which
    maps all of our dependencies to their physical file locations, and `shim` property,
    which is used to define the non-AMD modules in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at `config` file, in the code snippet below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I think by now you are quite familiar with the types of configuration items
    that we set for our application in this file. Based on this configuration, RequireJS
    can now load our modules and files, asynchronously and in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation allows us to have a well-organized, maintainable, and scalable
    solution to loading our modules, without the need to list them all in our `index.html`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Booting up our application using RequireJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `main` module is the module responsible for booting up our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet and see how this module is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have listed all of our application's dependencies in an array.
    Then, we have used `require` method to load them all and pass them to the callback
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this callback function, we execute the code necessary to get the application
    started up.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the **Network** tab of your browser''s debugger tool (I use
    Chrome), you will see how RequireJS has loaded the necessary modules and files
    for our application, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Booting up our application using RequireJS](img/B04910_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, modular architecture can help us greatly to manage our application
    pieces and their related dependencies with ease. I recommend that you spend some
    time exploring how to leverage the full functionality of AMD modules in your own
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with AMD format, CommonJS (also known as CJS) is another format which defines
    JavaScript modules as objects that can be made available to any dependent code.
    CJS modules can only define objects, as opposed to AMD modules, which can define
    constructors and functions too.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike AMD format, which takes a browser-first approach, CommonJS takes a server-first
    approach. It also covers a broader set of concerns which are server-related, such
    as io, file system, and alike.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers (I'm one of them) use AMD format for browser-targeted modules
    and CommonJS for server-side targeted modules. However, you could use CJS format
    for browser modules as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the tools that support CJS for the browsers are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**curl.js**: [http://github.com/unscriptable/curl](http://github.com/unscriptable/curl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SproutCore**: [http://sproutcore.com](http://sproutcore.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a look at a simple example to see how we can implement a CJS format
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CommonJS module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that we have a file called `moduleOne.js`. From inside this file, we
    can export a CJS module like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `exports` is a global variable and contains the object which the module
    is making available to other modules that wish to consume it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, imagine that we have another module in `moduleTwo.js` file,
    which resides in the same directory as `moduleOne.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`moduleTwo` can import `moduleOne` and consume it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this module we use CJS `require` method to import the first
    module (`someFunc`), and then we can use it as `firstModule.someFunc()`.
  prefs: []
  type: TYPE_NORMAL
- en: In `moduleTwo.js`, we are also exporting another module called `someApp`, which
    can be consumed by other modules in the application. Note that in the preceding
    example, we are in fact exporting more than one module from the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that there is no `define` method to wrap our modules and return
    an object from the callback function, as opposed to what we saw in AMD format.
  prefs: []
  type: TYPE_NORMAL
- en: CJS syntax is similar to how ECMAScript 6 defines modules, and we will have
    a look at that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information regarding CJS modules, please refer to the following resource
    online: [http://www.commonjs.org/](http://www.commonjs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6 modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the new version of JavaScript, **ECMAScript 6** (also known as **ES6**),
    native modules have been introduced. The following points are some of the most
    important aspects of these modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Module code always automatically runs in strict mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables that are created in the top level of a module are not added to the
    global scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module must export anything that should be available to the outside code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module can import bindings (things that are exported from other modules)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main idea behind modules in ES6 is to give you complete control over what
    is accessible to the outside code from inside the module, as well as when the
    code inside of the module is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at a simple example of an ES6 module.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an ES6 module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can define an ES6 module either inside of a `.js` file, or inside a `<script>`
    tag in our`.html` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet, from an imaginary `simpleModule.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding module, we have defined three functions as well as a module
    variable. Note that while the variable `name` is not inside of a function, its
    scope is still limited to the module. This means that no external code to the
    module can access it.
  prefs: []
  type: TYPE_NORMAL
- en: We have also used the keyword `export` to make two of our functions available
    to the potential consumers of the module. As you can see, we can use `export`
    either on the function declaration, as in the case of `sayHello` function, or
    as a reference, in the case of `sayBye` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a module as an embedded module in an `.html` file, we can use the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have specified `type` of the script to be `module`, which causes
    the browser to treat the code inside the `<script>` tag as an ES6 module.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming an ES6 module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the external code to an ES6 module needs to have access to what has been
    exposed by the module, binding needs to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider how we can get access to the two functions that were exposed by our
    first module, `simpleModule`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As shown, we need to use the keyword `import` to create binding between the
    external code to the module and the functions that the module exports.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that since `sayName` was not exported by the module, we have no
    access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Module loading sequence in the browsers for ES6 modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 modules in the browsers are always loaded as soon as the browsers encounter
    the following tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: However, the code in the module is not executed until the document has been
    completely parsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules are also executed in the order in which they appear. This means that
    in our preceding examples, if we had listed our modules as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code in `simpleModule.js` would be executed before the code for our embedded
    module would.
  prefs: []
  type: TYPE_NORMAL
- en: Since a module can also have its own dependencies, which it defines using the
    `import` statements (bindings), each module is parsed completely before its code
    is executed. This is so the dependencies can be resolved correctly.
  prefs: []
  type: TYPE_NORMAL
- en: This means, if the browser encounters an import statement in an already downloaded
    module, it will download the dependency first before executing the code in that
    module. This ensures that all the modules and their dependencies are loaded before
    any code-execution in the modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot more to ES6 modules than what we have covered here, as this
    was meant to be a very brief introduction. I encourage you to research the subject
    further on your own. There are many good resources online which you can refer
    to and I highly recommend the following sites for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://leanpub.com/understandinges6](https://leanpub.com/understandinges6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://hacks.mozilla.org/2015/08/es6-in-depth-modules/](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import](https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Final note regarding our Images Inc. application**'
  prefs: []
  type: TYPE_NORMAL
- en: It is always a good idea to revisit and improve the quality of the code in our
    applications. As such, I have made some small modifications to the code-base related
    to this chapter. The latest project's code is a little more polished and linted.
    Also, I have made improvements to the visual responsiveness of the application
    in the browsers by making some changes to the related CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are always things that can be improved further in any project
    and this application is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, I hope the application will provide a good starting point for your
    future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this was the last phase in the implementation of our application, in this
    chapter we discussed how we can improve the dependency management and loading
    of our modules in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: By re-factoring our application's code, we converted our Core submodules to
    AMD modules and then used RequireJS to load all of our JavaScript files asynchronously
    from the server.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how we can use RequireJS, which is mainly a script-loading library, to
    load our AMD and non-AMD modules.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered different formats for defining modules in JavaScript and talked
    about AMD, CommonJS, and ES6 modules. Since this book is focused on using JavaScript
    in the browsers, we spent more time getting to know AMD modules, as they are better
    suited for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In our overview of CommonJS and ES6 modules, we noted the similarities between
    the two formats and saw how ES6 modules can be used in our code.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have found this book informative and a good introduction to modular
    programming with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As always, there is a lot more to learn for all of us and I wish you great success
    in your future endeavors.
  prefs: []
  type: TYPE_NORMAL
