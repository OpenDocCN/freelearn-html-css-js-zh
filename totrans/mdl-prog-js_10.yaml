- en: Chapter 10. Enterprise Grade Modular Design, AMD, CommonJS, and ES6 Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。企业级模块化设计，AMD，CommonJS和ES6模块
- en: In this last chapter of the book, we are going to mainly focus on re-factoring
    some of our application modules so we can have a more robust way of loading and
    managing them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们将主要关注重构一些应用模块，以便我们能够以更稳健的方式加载和管理它们。
- en: The title of this chapter mentions Enterprise Grade, but in fact we can use
    the principles discussed here for applications of any size and type. In the next
    sections, I'll introduce you to various approaches for creating and loading modules
    in JavaScript and talk about the environments that each approach might be better
    suited for. You'll also see how we can manage our module dependencies in a more
    structured manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的标题提到了企业级，但实际上我们可以使用这里讨论的原则来应用于任何大小和类型的应用。在接下来的几节中，我将向您介绍创建和加载模块的各种方法，并讨论每种方法可能更适合的环境。您还将看到我们如何以更结构化的方式管理模块依赖。
- en: Keep in mind that this chapter is meant to be only an introduction to such techniques,
    but hopefully it will make you curious enough to research them further.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，本章仅作为此类技术的介绍，但希望它能激发您进一步研究的兴趣。
- en: I believe after seeing their benefits, you'll consider these modular design
    implementations in your future projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信在看到它们的益处后，您会在未来的项目中考虑这些模块化设计实现。
- en: 'Some of the topics that we will cover in this chapter are:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的一些主题包括：
- en: Why we need a better setup for loading our modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要更好的模块加载设置
- en: AMD module format and how to use it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMD模块格式及其使用方法
- en: Tools for creating AMD modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 AMD 模块的工具
- en: CommonJS module format
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS模块格式
- en: ECMAScript 6 modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 6模块
- en: Revisiting index.html file
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视index.html文件
- en: If you recall, in [Chapter 8](ch08.html "Chapter 8. Application Implementation
    – Putting It All Together"), *Application Implementation – Putting It All Together*,
    I mentioned that we were using quite a few `<script>` tags in our `index.html`
    file to load our application's modules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在[第8章](ch08.html "第8章。应用实现 - 整合一切")中，我提到我们在`index.html`文件中使用了相当多的`<script>`标签来加载我们的应用模块。
- en: 'To refresh your memory, here is what we had:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新您的记忆，以下是我们之前的情况：
- en: '![Revisiting index.html file](img/B04910_10_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视index.html文件](img/B04910_10_01.jpg)'
- en: While this implementation worked, it was not very scalable, since for each module
    file we needed to add a `<script>` tag to our page. Also, by looking at the list
    of files being loaded, we could not determine how each module or component was
    dependent on another piece (or pieces) of the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个实现是有效的，但它并不非常可扩展，因为对于每个模块文件，我们都需要在我们的页面上添加一个`<script>`标签。此外，通过查看正在加载的文件列表，我们无法确定每个模块或组件如何依赖于应用的其他部分（或多个部分）。
- en: 'We had to create another `<script>` tag at the bottom of the page as well,
    which took care of booting-up the application, as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在页面底部创建另一个`<script>`标签，以便启动应用，如下所示：
- en: '![Revisiting index.html file](img/B04910_10_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视index.html文件](img/B04910_10_02.jpg)'
- en: It would be nice if we could eliminate the need for having all the `<script>`
    tags and our boot-up sequence in `index.html`. Also, it would be very useful to
    implement a mechanism which could indicate and mange our modules' dependencies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能消除在`index.html`中需要所有`<script>`标签和启动序列的需求，那就太好了。此外，实现一个能够指示和管理我们模块依赖的机制将非常有用。
- en: Well, we are going to achieve all that very soon!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们很快就会实现所有这些。
- en: 'The following screenshot depicts how the new approach will clean up our `index.html`
    file and provide us with a more robust script-loading capability:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了新方法将如何清理我们的`index.html`文件，并为我们提供更稳健的脚本加载能力：
- en: '![Revisiting index.html file](img/B04910_10_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视index.html文件](img/B04910_10_03.jpg)'
- en: 'As you can see, the page has been shortened considerably and there is only
    one JavaScript file that is loaded in `index.html` now. This file is `require.js`,
    with its data-main attribute set to `js/config`, as shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，页面已经大大缩短，现在在`index.html`中只加载了一个JavaScript文件。这个文件是`require.js`，其`data-main`属性设置为`js/config`，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Loading this script is all we need to do in order to load all of our modules
    and components, and to start up the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 只需加载此脚本，我们就可以加载所有模块和组件，并启动应用。
- en: We will have a look at how this magic has taken place shortly, but before doing
    so, we need to talk about **AMD** modules.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快查看这个魔法是如何发生的，但在这样做之前，我们需要谈谈**AMD**模块。
- en: Introducing Asynchronous Module Definition
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍异步模块定义
- en: '**Asynchronous Module Definition** (**AMD**) format for creating modules in
    JavaScript, is targeted for use in browsers. This format proposes a particular
    way for defining modules so that modules and their dependencies can be loaded
    into the browser asynchronously.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步模块定义**（**AMD**）格式是针对在浏览器中使用JavaScript创建模块的。这个格式提出了一种特定的模块定义方式，以便模块及其依赖项可以异步加载到浏览器中。'
- en: There are two key methods that you need to use when creating and consuming AMD
    modules, these are `define` and `require` methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建和消费AMD模块时，你需要使用两个关键方法，这些是`define`和`require`方法。
- en: The idea is that we create a module using the global `define` method and then
    we can import that module in other parts of the code (other modules) using the
    global `require` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是我们使用全局的`define`方法创建一个模块，然后我们可以使用全局的`require`方法在其他代码部分（其他模块）中导入该模块。
- en: Defining modules using AMD format
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AMD格式定义模块
- en: 'Here is how a module can be defined in AMD format:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在AMD格式中定义模块的示例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we are passing three arguments to the global `define`
    method, which has been provided to us by an AMD-compatible module loader.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向全局的`define`方法传递了三个参数，这个方法是由AMD兼容的模块加载器提供的。
- en: The first argument, `moduleOneId`, is an optional parameter which assigns an
    ID to the module. Most of the time, we do not use this argument and other than
    some edge cases or when a non-AMD concatenation tool is being used to bundle our
    code, we leave it empty.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`moduleOneId`是一个可选参数，它为模块分配一个ID。大多数情况下，我们不使用这个参数，除了某些边缘情况或当使用非AMD的代码打包工具时，我们将其留空。
- en: The second argument to `define` function is an array of dependencies, which
    tells the AMD module loader what modules (files) need to be loaded before executing
    the callback function. Of course, the third argument passed to `define` method
    is the callback function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`define`函数的第二个参数是一个依赖项数组，它告诉AMD模块加载器在执行回调函数之前需要加载哪些模块（文件）。当然，传递给`define`方法的第三个参数是回调函数。'
- en: Notice that we are returning an object from this callback function. This object
    is the module that we are defining. In AMD format, the callback function can also
    return constructors and functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们从这个回调函数中返回一个对象。这个对象是我们正在定义的模块。在AMD格式中，回调函数也可以返回构造函数和函数。
- en: Importing AMD modules
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入AMD模块
- en: To use the module that we have defined in the preceding code, we can import
    it by using the global `require` function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面代码中定义的模块，我们可以通过使用全局的`require`函数来导入它。
- en: 'Consider the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are asking the AMD module loader to load the dependency `moduleOneId`
    before executing the callback function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们要求AMD模块加载器在执行回调函数之前加载依赖项`moduleOneId`。
- en: 'Note that we could also use the path to our dependency instead of using the
    related ID. For instance, we could write the preceding code snippet as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以使用依赖项的路径而不是使用相关的ID。例如，我们可以将前面的代码片段写成如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: AMD format provides great flexibility in defining and loading our modules. It
    also eliminates the need for creating global variables to define the modules.
    AMD-compatible script loaders also often provide the capability to lazy-load our
    modules, if needed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: AMD格式在定义和加载我们的模块方面提供了极大的灵活性。它还消除了创建全局变量来定义模块的需求。如果需要，AMD兼容的脚本加载器通常还提供懒加载我们的模块的能力。
- en: There are many web development tools (libraries) that support AMD format, but
    the most popular ones are `RequireJS` and `curl.js`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多支持AMD格式的Web开发工具（库），但最受欢迎的是`RequireJS`和`curl.js`。
- en: In our application in this chapter, we will be using `RequireJS` to create our
    AMD modules and load their dependencies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的应用程序中，我们将使用`RequireJS`创建我们的AMD模块并加载它们的依赖项。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an in-depth discussion on JavaScript modules and their related formats,
    I encourage you to visit a great post by *Addy Osmani* at [https://addyosmani.com/writing-modular-js/](https://addyosmani.com/writing-modular-js/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript模块及其相关格式的深入讨论，我鼓励您访问Addy Osmani在[https://addyosmani.com/writing-modular-js/](https://addyosmani.com/writing-modular-js/)上的一篇优秀的文章。
- en: Introducing RequireJS
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍RequireJS
- en: As mentioned previously, one of the most popular AMD module loaders for the
    browsers is **RequireJS**. In this section, we will learn how to create and load
    modules using this tool.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，浏览器中最受欢迎的 AMD 模块加载器之一是 **RequireJS**。在本节中，我们将学习如何使用这个工具创建和加载模块。
- en: You can also run RequireJS on the server side using its related optimizer, `r.js`.
    The optimizer can package all of our AMD modules into one file and then the browser
    will only have to make one request to the server to load all the necessary modules.
    In this scenario, AMD format is used to manage dependencies among modules when
    they are being bundled on the server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用其相关优化器 `r.js` 在服务器端运行 RequireJS。优化器可以将所有我们的 AMD 模块打包到一个文件中，然后浏览器只需向服务器发出一个请求即可加载所有必要的模块。在这种情况下，当模块在服务器上打包时，使用
    AMD 格式来管理模块之间的依赖关系。
- en: 'Alternatively, if you are using a server build setup for your client files,
    you may want to consider using `almond.js` for packaging your AMD modules. This
    is a much smaller library, but does not have the dynamic loading capabilities
    of RequireJS. For more information regarding `almond.js`, visit the following
    URL: [https://github.com/requirejs/almond/](https://github.com/requirejs/almond/).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您正在使用服务器构建设置来处理客户端文件，您可能希望考虑使用 `almond.js` 来打包您的 AMD 模块。这是一个更小的库，但它没有 RequireJS
    的动态加载功能。有关 `almond.js` 的更多信息，请访问以下网址：[https://github.com/requirejs/almond/](https://github.com/requirejs/almond/)。
- en: Since we are not using a build system for our project, I will only cover using
    `RequireJS` for the browsers in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们项目中没有使用构建系统，因此在本章中，我将仅介绍如何使用 `RequireJS` 为浏览器服务。
- en: Downloading RequireJS
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载 RequireJS
- en: 'We can download this library from the following location: [http://requirejs.org/docs/download.html#requirejs](http://requirejs.org/docs/download.html#requirejs).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下位置下载这个库：[http://requirejs.org/docs/download.html#requirejs](http://requirejs.org/docs/download.html#requirejs)。
- en: You can simple copy the minimized version of the tool and save it in your selected
    file location.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接复制工具的压缩版本，并将其保存到您选择的文件位置。
- en: A test project for creating and loading AMD modules
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和加载 AMD 模块的测试项目
- en: To help you become more familiar with RequireJS, I have included an additional
    project called **requireJsLearning** in the source code related to this chapter.
    I encourage you to download this project and follow along as we continue our talk
    regarding AMD and RequireJS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更熟悉 RequireJS，我在本章相关的源代码中包含了一个名为 **requireJsLearning** 的附加项目。我鼓励您下载这个项目，并随着我们继续讨论
    AMD 和 RequireJS 而跟随操作。
- en: 'In `requireJsLearning` project, I have saved the RequireJS library (`require.js`)
    in the `libs` folder, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `requireJsLearning` 项目中，我已经将 RequireJS 库（`require.js`）保存在 `libs` 文件夹中，如下所示：
- en: '![A test project for creating and loading AMD modules](img/B04910_10_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![创建和加载 AMD 模块的测试项目](img/B04910_10_04.jpg)'
- en: Let's create some simple modules in this project and see how we can use RequireJS
    to load and manage them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中创建一些简单的模块，并看看我们如何使用 RequireJS 加载和管理它们。
- en: Creating a simple AMD module
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的 AMD 模块
- en: We start by creating a simple AMD module in `person.js` file, under `modules`
    folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 `modules` 文件夹下的 `person.js` 文件中创建一个简单的 AMD 模块。
- en: 'Consider the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we are using the global `define` method that RequireJS
    has provided for us and passing two parameters to it. The first parameter is an
    array with two values. The first value in this array is a path to another module,
    which is a dependency for our `person` module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 RequireJS 为我们提供的全局 `define` 方法，并向它传递了两个参数。第一个参数是一个包含两个值的数组。这个数组中的第一个值是另一个模块的路径，它是我们的
    `person` 模块的依赖项。
- en: Notice that we are using the name of the file but without the `.js` extension.
    This is because RequireJS assumes the extension to be `.js` by default.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的是文件名，但没有 `.js` 扩展名。这是因为 RequireJS 默认假设扩展名为 `.js`。
- en: The second value in our dependency array is **jQuery**. We are not specifying
    a path for jQuery here, as it is being used as a global variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖数组中的第二个值是 **jQuery**。在这里我们没有指定 jQuery 的路径，因为它被用作全局变量。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**jQuery and AMD format**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery 和 AMD 格式**'
- en: As of version 1.7, jQuery supports AMD format. However, for it to be loaded
    properly as an AMD module, we can only place it in the same location as our `config.js`
    file. Since we would like to have all of our third-party libraries under `libs`
    folder in our project, we need to do a little bit of configuration. We will talk
    about this shortly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 1.7 版本，jQuery 支持AMD格式。但是，为了正确地将其作为AMD模块加载，我们只能将其放置在与我们的 `config.js` 文件相同的位置。由于我们希望将所有第三方库放在我们项目的
    `libs` 文件夹下，我们需要进行一些配置。我们很快就会谈到这一点。
- en: The second parameter passed to `define` method is the callback function that
    gets executed after our `person` module's dependencies are loaded.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `define` 方法的第二个参数是在我们的 `person` 模块的依赖项加载后执行的回调函数。
- en: As the preceding code shows, this callback function receives two parameters,
    which are matched one-to-one to the dependency list defined for the `person` module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，这个回调函数接收两个参数，它们与为 `person` 模块定义的依赖列表一一对应。
- en: We also return an object from this callback function which is our `person` module
    that can be consumed by other modules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从这个回调函数中返回一个对象，即我们的 `person` 模块，它可以被其他模块消费。
- en: Consuming our person AMD module
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费我们的 person AMD 模块
- en: Since `person` module is created as an AMD module, we can consume it as a dependency
    in other modules by only specifying its path.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `person` 模块被创建为 AMD 模块，我们可以在其他模块中仅指定其路径作为依赖项来消费它。
- en: 'Have a look at how our `main` module (in `main.js`) requires and uses `person`
    module, as shown in the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的 `main` 模块（在 `main.js` 中）如何要求和使用 `person` 模块，如下所示：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding syntax should be a lot more familiar to you now. We are telling
    RequireJS (using `require` method) to load all the dependencies listed in the
    dependency array (the first argument to `require` method) and then pass them as
    arguments to the callback function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该对前面的语法更加熟悉了。我们正在告诉 RequireJS（使用 `require` 方法）加载依赖数组（`require` 方法的第一个参数）中列出的所有依赖项，然后将它们作为参数传递给回调函数。
- en: RequireJS in turn, will make asynchronous calls to the server (one call per
    module) to download all of the dependencies.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS 将依次对服务器进行异步调用（每个模块一个调用）以下载所有依赖项。
- en: Loading dependencies of dependencies
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载依赖项的依赖项
- en: 'Notice that our `main` module has listed `person` module as a dependency. However,
    `person` module itself has also listed `stuff` module as a dependency:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的 `main` 模块已将 `person` 模块列为依赖项。然而，`person` 模块本身也将 `stuff` 模块列为依赖项：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Therefore, there is a dependency chain that needs to be resolved. When RequireJS
    looks for the dependency list of `main` module and sees `person` as a dependency,
    it then looks to see if `person` has any dependencies itself. If so, it will load
    those dependencies first. After that `person` module is loaded and passed to `main`
    module.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存在一个需要解决的依赖链。当 RequireJS 查找 `main` 模块的依赖列表并看到 `person` 作为依赖项时，它会进一步查看 `person`
    是否有自身的依赖项。如果有，它将首先加载这些依赖项。之后，`person` 模块被加载并传递给 `main` 模块。
- en: 'We can think of this chain as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样思考这个链：
- en: Load `stuff` module | pass it to `person` module | load `person` module | then
    pass `person` module to `main` module.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 `stuff` 模块 | 将其传递给 `person` 模块 | 加载 `person` 模块 | 然后将 `person` 模块传递给 `main`
    模块。
- en: This is a very simplified view of how RequireJS manages dependencies and loads
    modules in the correct order, based on the dependency list.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 RequireJS 如何根据依赖列表管理依赖项并按正确顺序加载模块的非常简化的看法。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A small but important point**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个微小但重要的点**'
- en: In the preceding explanation, I mentioned the order of how modules get loaded
    based on the dependency list. The fact is that these modules can be physically
    loaded in a different order, but the important point to keep in mind is that all
    of the modules listed in the dependency list are loaded and the code in them is
    executed *before* the `callback` function is called.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的解释中，我提到了根据依赖列表的顺序加载模块。事实上，这些模块可以以不同的物理顺序加载，但需要记住的重要一点是，依赖列表中列出的所有模块都会被加载，并且它们中的代码会在调用
    `callback` 函数之前执行。
- en: Loading and consuming non-AMD modules
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载和消费非AMD模块
- en: We also need a way to load non-AMD modules or non-modular files in our projects,
    and RequireJS provides hooks to do just that.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来加载项目中非AMD模块或非模块文件，RequireJS 提供了钩子来完成这项工作。
- en: It also has many plugins which enable us to load CSS and text files, as well
    as providing many other capabilities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有许多插件，使我们能够加载CSS和文本文件，并提供许多其他功能。
- en: In our **requireJsLearning** project, we have three modules (files) which are
    not using AMD module format. These are `person2`, `person3`, and `person4`. In
    order for RequireJS to load such modules and make them available for usage by
    other modules, we need to provide some configuration settings.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 **requireJsLearning** 项目中，有三个模块（文件）没有使用 AMD 模块格式。这些是 `person2`、`person3`
    和 `person4`。为了让 RequireJS 加载这样的模块并使它们可供其他模块使用，我们需要提供一些配置设置。
- en: 'If you look at `config.js` file in our project, you see the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看我们项目中的 `config.js` 文件，你会看到以下代码：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we are passing a configuration object to `require.config` method of RequireJS.
    The first property of this object defines `main` as a dependency (`deps: [''main'']`).
    Remember that `main` module is the module that boots up our application, but in
    `index.html` file, we told RequireJS to load `config.js` using `data-main` attribute,
    as shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，我们正在将一个配置对象传递给 RequireJS 的 `require.config` 方法。这个对象的第一属性将 `main` 定义为一个依赖项（`deps:
    [''main'']`）。记住，`main` 模块是启动我们应用程序的模块，但在 `index.html` 文件中，我们告诉 RequireJS 使用 `data-main`
    属性加载 `config.js`，如下所示：'
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When RequireJS loads `config.js` file, the configuration object is passed to
    `require.config` method. Then, RequireJS figures out that it needs to load `main.js`
    (by looking at the `deps: [''main'']` property on this object). Of course, in
    turn, by looking at the dependency list of `main` module, RequireJS loads all
    the dependencies for `main` module as well.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '当 RequireJS 加载 `config.js` 文件时，配置对象被传递给 `require.config` 方法。然后，RequireJS 确定它需要加载
    `main.js`（通过查看此对象上的 `deps: [''main'']` 属性）。当然，反过来，通过查看 `main` 模块的依赖项列表，RequireJS
    也会加载 `main` 模块的所有依赖项。'
- en: Setting paths in the config object
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在配置对象中设置路径
- en: 'The next property set in the configuration object passed to `require.config`
    method is `paths` property. This property itself is an object and it''s where
    we define the paths to our dependencies. For instance, see the following snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递给 `require.config` 方法的配置对象中设置的下一个属性是 `paths` 属性。这个属性本身是一个对象，我们在这里定义了依赖项的路径。例如，请看以下片段：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we tell RequireJS that, when it needs to load `person2`, it can find it
    in the `modules/person2.js` file. Remember that we do not provide the file extension
    for the file in this property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 RequireJS，当它需要加载 `person2` 时，可以在 `modules/person2.js` 文件中找到它。记住，在这个属性中，我们不需要提供文件的扩展名。
- en: Creating shims for non-AMD modules
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为非 AMD 模块创建 shims
- en: The next property that we define in object passed to `require.config` method
    is `shim` property.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递给 `require.config` 方法的对象中，我们定义的下一个属性是 `shim` 属性。
- en: '`shim` property is an object too and is used to provide configuration settings
    for non-AMD modules.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`shim` 属性也是一个对象，用于为非 AMD 模块提供配置设置。'
- en: 'For instance, see how we are configuring `person3` module in the following
    code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请看以下代码片段中我们如何配置 `person3` 模块：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We tell RequireJS that, when you want to load `person3` module as a dependency,
    first you need to load `person4` (using `deps` property), and then let the consuming
    modules declare this module as a dependency using the keyword `person3`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉 RequireJS，当你想将 `person3` 模块作为依赖项加载时，首先需要加载 `person4`（使用 `deps` 属性），然后让消费模块使用关键字
    `person3` 声明此模块作为依赖项。
- en: 'Consider how `stuff` module declares and consumes `person3` as a dependency
    in the following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段中 `stuff` 模块如何声明和消费 `person3` 作为依赖项：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this way, we can load and consume non-AMD modules asynchronously, thanks
    to RequireJS.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以异步加载和消费非 AMD 模块，这要归功于 RequireJS。
- en: 'To confirm that everything is working as it should and all the dependencies
    are resolved properly, we can load `index.html` in the browser. We should then
    see the following messages in the debugger tools console (I''m using Chrome browser):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认一切按预期工作并且所有依赖项都已正确解决，我们可以在浏览器中加载 `index.html`。然后，我们应该在调试工具控制台看到以下消息（我使用的是
    Chrome 浏览器）：
- en: '![Creating shims for non-AMD modules](img/B04910_10_05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![为非 AMD 模块创建 shims](img/B04910_10_05.jpg)'
- en: I encourage you to have a look at the code related to this project (`requireJsLearning`)
    and use it to see how you can create, load, and consume modules using RequireJS.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你查看与此项目相关的代码（`requireJsLearning`）并使用它来了解如何使用 RequireJS 创建、加载和消费模块。
- en: For more in-depth information regarding this great library and the many different
    options that it provides, please visit [http://requirejs.org/](http://requirejs.org/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个优秀的库以及它提供的许多不同选项的更深入信息，请访问 [http://requirejs.org/](http://requirejs.org/)。
- en: I hope this was a good introduction to AMD module format and RequireJS. Let's
    now use what we have learned from this section and re-factor our main application
    to load our modules the AMD way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这已经是一个关于AMD模块格式和RequireJS的良好介绍了。现在，让我们利用本节学到的知识，重构我们的主应用程序，以AMD方式加载我们的模块。
- en: Refactoring Images Inc. application to use AMD format
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构Images Inc.应用程序以使用AMD格式
- en: To leverage the functionality that RequireJS provides for us, we are going to
    take two different approaches here. First, we are going to convert all of the
    submodules in the Core module into AMD modules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用RequireJS为我们提供的功能，我们将采取两种不同的方法。首先，我们将把Core模块中的所有子模块都转换为AMD模块。
- en: Second, we are going to load all of our other files in the application, including
    our application's components, as non-AMD modules. These two approaches will provide
    us with a practical exercise to put our knowledge of RequireJS and AMD modules
    to good use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们将把应用程序中的所有其他文件，包括应用程序的组件，作为非AMD模块加载。这两种方法将为我们提供一个实际练习，以将我们对RequireJS和AMD模块的知识付诸实践。
- en: Modifying Core submodules into AMD modules
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将核心子模块修改为AMD模块
- en: In this section, we are going to look at `ImagesInc_Core.LoggingHandler` submodule
    and see how we can convert it into an AMD module. All the other submodules in
    the application can also be converted to AMD modules, following the same approach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看`ImagesInc_Core.LoggingHandler`子模块，并了解我们如何将其转换为AMD模块。应用程序中的所有其他子模块也可以按照相同的方法转换为AMD模块。
- en: 'Consider how `ImagesInc_Core.LoggingHandler` submodule is implemented in our
    application:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在我们的应用程序中如何实现`ImagesInc_Core.LoggingHandler`子模块：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We were using an IIFE to return an object as a property on `ImagesInc_Core`
    global object (which is our MainCore module). This returned object is the interface
    to the code inside of our IIFE namespace.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用IIFE（立即执行函数表达式）来返回一个对象，作为`ImagesInc_Core`全局对象（即我们的MainCore模块）的一个属性。这个返回的对象是我们IIFE命名空间内代码的接口。
- en: To convert this submodule to an AMD module, we simply need to transfer the code
    which was originally inside the IIFE to `define` method provided to us by RequireJS.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此子模块转换为AMD模块，我们只需将原本在IIFE内部的代码转移到由RequireJS提供的`define`方法中。
- en: 'Consider the following code snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we are still returning an object from the callback function and
    we are also assigning it to `LoggingHandler` property of `ImagesInc_Core` object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然从回调函数中返回一个对象，并且也将它分配给`ImagesInc_Core`对象的`LoggingHandler`属性。
- en: This approach allows us to easily convert our non-AMD submodules into AMD modules,
    with very little modification. This is mostly because, from the beginning, our
    architecture was designed to be a modular-based architecture. Now, thanks to RequireJS,
    we are able to load our submodule files asynchronously, without the need to add
    them as `<script>` tags to our `index.html` file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使我们能够轻松地将我们的非AMD子模块转换为AMD模块，改动非常小。这主要是因为，从一开始，我们的架构就被设计为基于模块的架构。现在，多亏了RequireJS，我们能够异步加载我们的子模块文件，而无需将它们作为`<script>`标签添加到我们的`index.html`文件中。
- en: Loading our non-AMD modules using RequireJS
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用RequireJS加载我们的非AMD模块
- en: We are going to load the rest of the files in our application, including MainCore,
    as non-AMD modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载应用程序中的其余文件，包括MainCore，作为非AMD模块。
- en: You may decide later on that you would like to convert these modules into AMD
    modules as well. I encourage you to do so, as it will be a valuable exercise.
    However, my goal here is to show you how AMD and non-AMD modules can work together
    in harmony, without much trouble at all.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能后来决定，你希望将这些模块也转换为AMD模块。我鼓励你这样做，因为这将是一个有价值的练习。然而，我的目标在这里是向你展示AMD和非AMD模块可以如何和谐地一起工作，而不会遇到太多麻烦。
- en: As explained previously, to load non-AMD modules using RequireJS, we need to
    define them in `shim` property of our application's `config` file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了使用RequireJS加载非AMD模块，我们需要在应用程序的`config`文件的`shim`属性中定义它们。
- en: 'Remember that we load `config.js` file in our `index.html`, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在`index.html`中加载`config.js`文件，如下所示：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`config.js` file in turn will cause the loading of our `main.js` file (as it
    has been defined as a dependency for `config.js` file), which does the bootstrapping
    of our application.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.js`文件反过来将导致加载我们的`main.js`文件（因为它已被定义为`config.js`文件的依赖项），这完成了我们应用程序的引导。'
- en: It is time for us to have a closer look at our application's `config.js` file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候更仔细地查看我们应用程序的`config.js`文件了。
- en: Setting up our application's config.js file
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置应用程序的`config.js`文件
- en: Our application's `config.js` file consists of three main properties; `deps`
    property, which defines the dependencies of `config` file; `paths` property, which
    maps all of our dependencies to their physical file locations, and `shim` property,
    which is used to define the non-AMD modules in our application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的`config.js`文件由三个主要属性组成；`deps`属性，它定义了`config`文件的依赖项；`paths`属性，它将所有依赖项映射到它们的物理文件位置，以及`shim`属性，它用于定义我们应用程序中的非AMD模块。
- en: 'Have a look at `config` file, in the code snippet below:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的代码片段中的`config`文件：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I think by now you are quite familiar with the types of configuration items
    that we set for our application in this file. Based on this configuration, RequireJS
    can now load our modules and files, asynchronously and in the correct order.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我想现在你已经非常熟悉我们在文件中为应用程序设置的配置项类型了。基于这个配置，RequireJS现在可以异步且按正确顺序加载我们的模块和文件。
- en: This implementation allows us to have a well-organized, maintainable, and scalable
    solution to loading our modules, without the need to list them all in our `index.html`
    file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现使我们能够有一个组织良好、易于维护和可扩展的解决方案来加载我们的模块，而无需在`index.html`文件中列出所有模块。
- en: Booting up our application using RequireJS
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用RequireJS启动我们的应用程序
- en: Our `main` module is the module responsible for booting up our application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`模块是负责启动我们应用程序的模块。
- en: 'Have a look at the following code snippet and see how this module is implemented:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段，看看这个模块是如何实现的：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we have listed all of our application's dependencies in an array.
    Then, we have used `require` method to load them all and pass them to the callback
    function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经将我们应用程序的所有依赖项列在一个数组中。然后，我们使用了`require`方法来加载它们，并将它们传递给回调函数。
- en: Inside this callback function, we execute the code necessary to get the application
    started up.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调函数内部，我们执行启动应用程序所需的代码。
- en: 'If you look at the **Network** tab of your browser''s debugger tool (I use
    Chrome), you will see how RequireJS has loaded the necessary modules and files
    for our application, as shown in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看浏览器调试工具的**网络**标签页（我使用Chrome），你会看到RequireJS如何加载我们应用程序所需的模块和文件，如下面的截图所示：
- en: '![Booting up our application using RequireJS](img/B04910_10_06.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![使用RequireJS启动我们的应用程序](img/B04910_10_06.jpg)'
- en: As you can see, modular architecture can help us greatly to manage our application
    pieces and their related dependencies with ease. I recommend that you spend some
    time exploring how to leverage the full functionality of AMD modules in your own
    applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模块化架构可以帮助我们轻松地管理我们的应用程序组件及其相关依赖项。我建议你花些时间探索如何在你的应用程序中利用AMD模块的完整功能。
- en: CommonJS
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS
- en: As with AMD format, CommonJS (also known as CJS) is another format which defines
    JavaScript modules as objects that can be made available to any dependent code.
    CJS modules can only define objects, as opposed to AMD modules, which can define
    constructors and functions too.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与AMD格式一样，CommonJS（也称为CJS）是另一种定义JavaScript模块的格式，这些模块可以作为对象提供给任何依赖代码。与可以定义构造函数和函数的AMD模块不同，CJS模块只能定义对象。
- en: Unlike AMD format, which takes a browser-first approach, CommonJS takes a server-first
    approach. It also covers a broader set of concerns which are server-related, such
    as io, file system, and alike.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与采用浏览器优先方法的AMD格式不同，CommonJS采用服务器优先方法。它还涵盖了更广泛的与服务器相关的问题，例如io、文件系统等。
- en: Many developers (I'm one of them) use AMD format for browser-targeted modules
    and CommonJS for server-side targeted modules. However, you could use CJS format
    for browser modules as well.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者（我也是其中之一）使用AMD格式针对浏览器模块，使用CommonJS针对服务器端模块。然而，你也可以为浏览器模块使用CJS格式。
- en: 'Some of the tools that support CJS for the browsers are:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 支持CJS在浏览器中的某些工具包括：
- en: '**curl.js**: [http://github.com/unscriptable/curl](http://github.com/unscriptable/curl)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**curl.js**: [http://github.com/unscriptable/curl](http://github.com/unscriptable/curl)'
- en: '**SproutCore**: [http://sproutcore.com](http://sproutcore.com)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SproutCore**: [http://sproutcore.com](http://sproutcore.com)'
- en: Let's have a look at a simple example to see how we can implement a CJS format
    module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，看看我们如何实现一个CJS格式的模块。
- en: Implementing a CommonJS module
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个CommonJS模块
- en: 'Imagine that we have a file called `moduleOne.js`. From inside this file, we
    can export a CJS module like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`moduleOne.js`的文件。在这个文件内部，我们可以这样导出一个CJS模块：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `exports` is a global variable and contains the object which the module
    is making available to other modules that wish to consume it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`exports`是一个全局变量，包含模块提供给希望消费它的其他模块的对象。
- en: On the other hand, imagine that we have another module in `moduleTwo.js` file,
    which resides in the same directory as `moduleOne.js`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，想象一下我们还有一个模块位于`moduleTwo.js`文件中，它与`moduleOne.js`位于同一目录下。
- en: '`moduleTwo` can import `moduleOne` and consume it like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`moduleTwo`可以导入`moduleOne`并按如下方式消费它：'
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, in this module we use CJS `require` method to import the first
    module (`someFunc`), and then we can use it as `firstModule.someFunc()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在这个模块中，我们使用 CJS 的`require`方法导入第一个模块（`someFunc`），然后我们可以使用它作为`firstModule.someFunc()`。
- en: In `moduleTwo.js`, we are also exporting another module called `someApp`, which
    can be consumed by other modules in the application. Note that in the preceding
    example, we are in fact exporting more than one module from the same file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`moduleTwo.js`中，我们还导出另一个名为`someApp`的模块，该模块可以被应用程序中的其他模块消费。请注意，在前面的例子中，我们实际上是从同一个文件导出了多个模块。
- en: Notice also that there is no `define` method to wrap our modules and return
    an object from the callback function, as opposed to what we saw in AMD format.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 AMD 格式中看到的不同，我们没有使用`define`方法来包装我们的模块，并从回调函数返回一个对象。
- en: CJS syntax is similar to how ECMAScript 6 defines modules, and we will have
    a look at that in the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: CJS 语法与 ECMAScript 6 定义模块的方式相似，我们将在下一节中探讨这一点。
- en: 'For more information regarding CJS modules, please refer to the following resource
    online: [http://www.commonjs.org/](http://www.commonjs.org/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 CJS 模块的更多信息，请参考以下在线资源：[http://www.commonjs.org/](http://www.commonjs.org/)。
- en: ECMAScript 6 modules
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 6 模块
- en: 'In the new version of JavaScript, **ECMAScript 6** (also known as **ES6**),
    native modules have been introduced. The following points are some of the most
    important aspects of these modules:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 的新版本中，**ECMAScript 6**（也称为**ES6**）引入了原生模块。以下是一些这些模块最重要的方面：
- en: Module code always automatically runs in strict mode
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块代码总是自动在严格模式下运行
- en: Variables that are created in the top level of a module are not added to the
    global scope
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块顶层创建的变量不会被添加到全局作用域
- en: A module must export anything that should be available to the outside code
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块必须导出任何应该对外部代码可用的东西
- en: A module can import bindings (things that are exported from other modules)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块可以导入绑定（从其他模块导出的东西）
- en: The main idea behind modules in ES6 is to give you complete control over what
    is accessible to the outside code from inside the module, as well as when the
    code inside of the module is executed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 中模块的主要思想是让你完全控制模块内部对外部代码的访问权限，以及模块内部代码的执行时机。
- en: Let's have a look at a simple example of an ES6 module.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 ES6 模块的例子。
- en: Defining an ES6 module
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个 ES6 模块
- en: We can define an ES6 module either inside of a `.js` file, or inside a `<script>`
    tag in our`.html` page.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个 ES6 模块，要么在`.js`文件内部，要么在我们的`.html`页面中的`<script>`标签内部。
- en: 'Consider the following code snippet, from an imaginary `simpleModule.js` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，来自一个假想的`simpleModule.js`文件：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding module, we have defined three functions as well as a module
    variable. Note that while the variable `name` is not inside of a function, its
    scope is still limited to the module. This means that no external code to the
    module can access it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模块中，我们定义了三个函数以及一个模块变量。请注意，虽然变量`name`不在函数内部，但其作用域仍然局限于模块。这意味着模块外部代码无法访问它。
- en: We have also used the keyword `export` to make two of our functions available
    to the potential consumers of the module. As you can see, we can use `export`
    either on the function declaration, as in the case of `sayHello` function, or
    as a reference, in the case of `sayBye` function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了关键字`export`使我们的两个函数对模块的潜在消费者可用。正如你所见，我们可以在函数声明中使用`export`，就像`sayHello`函数的情况，或者作为引用，就像`sayBye`函数的情况。
- en: 'To create a module as an embedded module in an `.html` file, we can use the
    following syntax:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个嵌入到`.html`文件中的模块，我们可以使用以下语法：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that we have specified `type` of the script to be `module`, which causes
    the browser to treat the code inside the `<script>` tag as an ES6 module.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已经指定了脚本的`type`为`module`，这导致浏览器将`<script>`标签内的代码视为 ES6 模块。
- en: Consuming an ES6 module
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费一个 ES6 模块
- en: When the external code to an ES6 module needs to have access to what has been
    exposed by the module, binding needs to be used.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当ES6模块的外部代码需要访问模块暴露的内容时，需要使用绑定。
- en: 'Consider how we can get access to the two functions that were exposed by our
    first module, `simpleModule`, as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们如何获取第一个模块`simpleModule`所暴露的两个函数的访问权限，如下所示：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As shown, we need to use the keyword `import` to create binding between the
    external code to the module and the functions that the module exports.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们需要使用关键字`import`在模块的外部代码和模块导出的函数之间创建绑定。
- en: Also, notice that since `sayName` was not exported by the module, we have no
    access to it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，由于`sayName`没有被模块导出，我们无法访问它。
- en: Module loading sequence in the browsers for ES6 modules
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器中ES6模块的加载顺序
- en: 'ES6 modules in the browsers are always loaded as soon as the browsers encounter
    the following tag:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器遇到以下标签时，浏览器中的ES6模块总是立即加载：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: However, the code in the module is not executed until the document has been
    completely parsed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模块中的代码在文档完全解析之前不会执行。
- en: 'Modules are also executed in the order in which they appear. This means that
    in our preceding examples, if we had listed our modules as:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也是按照它们出现的顺序执行的。这意味着在我们的先前的例子中，如果我们按以下顺序列出我们的模块：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code in `simpleModule.js` would be executed before the code for our embedded
    module would.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`simpleModule.js`中的代码会在我们嵌入模块的代码之前执行。
- en: Since a module can also have its own dependencies, which it defines using the
    `import` statements (bindings), each module is parsed completely before its code
    is executed. This is so the dependencies can be resolved correctly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块也可以有自己的依赖项，它使用`import`语句（绑定）来定义，因此每个模块在执行其代码之前都会被完全解析。这是为了正确解决依赖项。
- en: This means, if the browser encounters an import statement in an already downloaded
    module, it will download the dependency first before executing the code in that
    module. This ensures that all the modules and their dependencies are loaded before
    any code-execution in the modules.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果浏览器在已下载的模块中遇到一个导入语句，它将首先下载依赖项，然后再执行该模块中的代码。这确保了在模块中的任何代码执行之前，所有模块及其依赖项都已加载。
- en: 'There is a lot more to ES6 modules than what we have covered here, as this
    was meant to be a very brief introduction. I encourage you to research the subject
    further on your own. There are many good resources online which you can refer
    to and I highly recommend the following sites for more information:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块的内容远不止我们在这里所涵盖的，因为这只是一个非常简短的介绍。我鼓励你自己进一步研究这个主题。网上有很多好的资源可以参考，我强烈推荐以下网站获取更多信息：
- en: '[https://leanpub.com/understandinges6](https://leanpub.com/understandinges6)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://leanpub.com/understandinges6](https://leanpub.com/understandinges6)'
- en: '[https://hacks.mozilla.org/2015/08/es6-in-depth-modules/](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://hacks.mozilla.org/2015/08/es6-in-depth-modules/](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/)'
- en: '[https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import](https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import](https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import)'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Final note regarding our Images Inc. application**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于我们的Images Inc.应用程序的最终注意事项**'
- en: It is always a good idea to revisit and improve the quality of the code in our
    applications. As such, I have made some small modifications to the code-base related
    to this chapter. The latest project's code is a little more polished and linted.
    Also, I have made improvements to the visual responsiveness of the application
    in the browsers by making some changes to the related CSS files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 总是回顾并提高我们应用程序代码的质量是一个好主意。因此，我对与本章相关的代码库进行了一些小的修改。最新项目的代码更加精致和经过代码检查。此外，我还通过修改相关的CSS文件，提高了应用程序在浏览器中的视觉响应性。
- en: However, there are always things that can be improved further in any project
    and this application is no exception.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何项目中总有可以进一步改进的地方，这个应用程序也不例外。
- en: Nonetheless, I hope the application will provide a good starting point for your
    future projects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我希望这个应用程序将为你的未来项目提供一个良好的起点。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As this was the last phase in the implementation of our application, in this
    chapter we discussed how we can improve the dependency management and loading
    of our modules in the browser.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们应用程序实现的最后一个阶段，在这一章中，我们讨论了如何在浏览器中改进我们模块的依赖管理和加载。
- en: By re-factoring our application's code, we converted our Core submodules to
    AMD modules and then used RequireJS to load all of our JavaScript files asynchronously
    from the server.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构我们应用程序的代码，我们将我们的 Core 子模块转换为 AMD 模块，然后使用 RequireJS 从服务器异步加载所有 JavaScript
    文件。
- en: We saw how we can use RequireJS, which is mainly a script-loading library, to
    load our AMD and non-AMD modules.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用 RequireJS，这是一个主要的脚本加载库，来加载我们的 AMD 和非 AMD 模块。
- en: We also covered different formats for defining modules in JavaScript and talked
    about AMD, CommonJS, and ES6 modules. Since this book is focused on using JavaScript
    in the browsers, we spent more time getting to know AMD modules, as they are better
    suited for this purpose.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了在 JavaScript 中定义模块的不同格式，并讨论了 AMD、CommonJS 和 ES6 模块。由于这本书主要关注在浏览器中使用 JavaScript，我们花了更多的时间来了解
    AMD 模块，因为它们更适合这个目的。
- en: In our overview of CommonJS and ES6 modules, we noted the similarities between
    the two formats and saw how ES6 modules can be used in our code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们概述 CommonJS 和 ES6 模块时，我们指出了这两种格式之间的相似性，并看到了 ES6 模块如何在我们的代码中使用。
- en: I hope you have found this book informative and a good introduction to modular
    programming with JavaScript.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你觉得这本书信息丰富，并且是学习使用 JavaScript 进行模块化编程的良好入门。
- en: As always, there is a lot more to learn for all of us and I wish you great success
    in your future endeavors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们还有很多东西要学习，我祝愿你在未来的努力中取得巨大成功。
