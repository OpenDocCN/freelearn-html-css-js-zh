<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Creating Animated Visuals</h1></div></div></div><p>We are now going to look at using D3.js transitions to represent changes in the information underlying a visual. We will start with examples for examining several concepts involved in using D3.js to animate the properties of visual elements from one state to another.</p><p>By the end of this chapter, we will extend the bubble visualization from <a class="link" href="ch06.html" title="Chapter 6. Creating Scatter and Bubble Plots">Chapter 6</a>, <em>Creating Scatter and Bubble Plots</em>, to demonstrate how we can animate our bubbles as we move through multiple years of data. This will demonstrate the construction of a relatively complex animation through which a user can easily deduce trends in the information.</p><p>In this chapter, we will cover the following topics through examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Animating using transitions</li><li class="listitem" style="list-style-type: disc">Animating the fill color of a rectangle</li><li class="listitem" style="list-style-type: disc">Animating multiple properties simultaneously</li><li class="listitem" style="list-style-type: disc">Delaying an animation</li><li class="listitem" style="list-style-type: disc">Creating chained transitions</li><li class="listitem" style="list-style-type: disc">Handling the start and end events of transitions</li><li class="listitem" style="list-style-type: disc">Changing the content and size of text using tweening</li><li class="listitem" style="list-style-type: disc">Using timers to schedule the steps of an animation</li><li class="listitem" style="list-style-type: disc">Adding a fifth dimension to a bubble chart through animation: time</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec35"/>Introduction to animation</h1></div></div></div><p>D3.js provides extensive<a id="id300" class="indexterm"/> capabilities for animating your visualizations. Through<a id="id301" class="indexterm"/> the use of animation, we can provide the viewer with a means to understanding how data changes over time.</p><p>Animation in D3.js is all about changing the properties of the visual objects over time. When these properties are changed, the DOM is updated and the visual is modified to represent the new state.</p><p>To animate properties, D3.js<a id="id302" class="indexterm"/> provides the following capabilities that we will examine:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Transitions</li><li class="listitem" style="list-style-type: disc">Interpolators and tweenings</li><li class="listitem" style="list-style-type: disc">Easings</li><li class="listitem" style="list-style-type: disc">Timers</li></ul></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec40"/>Animating using transitions</h2></div></div></div><p>D3.js animations are implemented <a id="id303" class="indexterm"/>via the concept of <strong>transitions</strong>. Transitions provide instructions and information to D3.js for changing one or more visual attribute<a id="id304" class="indexterm"/> values over a specific duration of time.</p><p>When D3.js<a id="id305" class="indexterm"/> starts a transition on a visual, it calculates the initial style and ending style for the element that is being transitioned. These are often referred to as the start and <a id="id306" class="indexterm"/>end <strong>keyframes</strong>. Each keyframe is a set of styles and other properties that you can specify as part of the animation. D3.js will then animate those properties from the start values to the end values.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec13"/>Animating the fill color of a rectangle</h3></div></div></div><p>To demonstrate<a id="id307" class="indexterm"/> a transition in action, we will start with an example and animate the color of a rectangle from one color to another. The code for this example is available <a id="id308" class="indexterm"/>at the following link:</p><div><div><h3 class="title"><a id="note89"/>Note</h3><p>bl.ock (7.1): <a class="ulink" href="http://goo.gl/oNJOQ9">http://goo.gl/oNJOQ9</a>
</p></div></div><p>In this example, we start by creating the following SVG rectangle and setting its initial <code class="literal">fill</code> to <code class="literal">red</code>, followed by transitioning the fill color to <code class="literal">blue</code> over a period of five seconds.</p><p>When running the example, you will see a single rectangle that changes from red to blue over a period of five seconds. During that time, it smoothly animates through intermediate colors such as purple, as seen in the following image:</p><div><img src="img/B04230_07_01.jpg" alt="Animating the fill color of a rectangle"/></div><p>The primary part of this code that does the animation is the following; it starts by creating the rectangle and setting its initial color to red:</p><div><pre class="programlisting">svg.append('rect')
    .attr({
        x: '10px',
        y: '10px',
        width: 80,
        height: 80,
        fill: 'red'
    })
    .transition()
    .duration(5000)
    .attr({ fill: 'blue' });</pre></div><p>The call to <code class="literal">.transition()</code> informs D3.js that we we want to transition one or more properties of the <code class="literal">rect</code> element that are made to the attributes of the rect element using calls to .style() or .attr().</p><p>The call to <code class="literal">.transition()</code> instructs D3.js to track any changes that are made to the attributes of the <a id="id309" class="indexterm"/>SVG element using calls to <code class="literal">.style()</code> or <code class="literal">.attr()</code>.</p><p>In this case, we specify that the <code class="literal">fill</code> of the rectangle should be <code class="literal">blue</code> at the end of the transition. D3.js uses this to calculate the starting and ending keyframes, which tracks the fill on the rectangle should change from red to blue in this case.</p><p>When the rendering of these elements begins, D3.js also starts the animation and smoothly changes the fill property over the specified period.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec14"/>Animating multiple properties simultaneously</h3></div></div></div><p>Multiple<a id="id310" class="indexterm"/> properties can be animated on an object during a transition. To accomplish this, all that is required is to set multiple attributes after the call to <code class="literal">.transition()</code>.</p><p>As an example, the following code animates the position of the rectangle and its size over the five-second <a id="id311" class="indexterm"/>period:</p><div><div><h3 class="title"><a id="note90"/>Note</h3><p>bl.ock (7.2): <a class="ulink" href="http://goo.gl/2qG0EV">http://goo.gl/2qG0EV</a>
</p></div></div><p>The code <a id="id312" class="indexterm"/>extends the previous example by animating not only the fill, but also by changing the position to move the rectangle along a diagonal, and modifying the size to make the rectangle half the width and height at the end of the transition:</p><div><pre class="programlisting">svg.append('rect')
    .attr({
        x: 10,
        y: 10,
        width: 80,
        height: 80,
        fill: 'red'
    })
    .transition()
    .duration(5000)
    .attr({
        x: 460,
        y: 150,
        width: 40,
        height: 40,
        fill: 'blue'
    });</pre></div><p>The resulting animation looks like the following image, where the rectangle moves along the path of the arrows, while changing both, color and size:</p><div><img src="img/B04230_07_02.jpg" alt="Animating multiple properties simultaneously"/></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec15"/>Delaying a transition</h3></div></div></div><p>If you do not want an animation to start instantaneously, you can use a delay. A delay defers the start of the transition for the specified period of time.</p><p>The following<a id="id313" class="indexterm"/> example defers the start of the transition for one second, then runs the transition for four seconds, completing the transition in an overall time of five seconds.</p><div><div><h3 class="title"><a id="note91"/>Note</h3><p>bl.ock (7.3): <a class="ulink" href="http://goo.gl/Vyd6Pd">http://goo.gl/Vyd6Pd</a>
</p></div></div><p>The code for the preceding example is the same as the previous one except for the following lines:</p><div><pre class="programlisting">.transition()
.delay(1000)
.duration(4000)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec16"/>Creating chained transitions</h3></div></div></div><p>A single transition changes the properties between only one set of keyframes. However, it is possible to <a id="id314" class="indexterm"/>chain transitions together for providing multiple sequences of animations. The following example demonstrates the chaining of two transitions (and also <a id="id315" class="indexterm"/>a delay at the start).</p><div><div><h3 class="title"><a id="note92"/>Note</h3><p>bl.ock (7.4): <a class="ulink" href="http://goo.gl/IfYJmY">http://goo.gl/IfYJmY</a>
</p></div></div><p>The first transition is executed for two seconds and animates the size, color, and position of the rectangle to the middle of the SVG area. The second transition then moves the rectangle to the upper-right corner for another two seconds while still continuing to change its color and size. The total execution time remains five seconds:</p><div><pre class="programlisting">svg.append('rect')
    .attr({
        x: 10,
        'y': 10,
        width: 80,
        height: 80,
        fill: 'red'
    })
    .transition()
    .delay(1000)
    .duration(2000)
    .attr({
        x: 240,
        y: 80,
        width: 60,
        height: 60,
        fill: 'purple'
    })
    .transition()
    .duration(2000)
    .attr({
        width: 40,
        height: 40,
        x: 460,
        y: 10,
        fill: 'blue'
    });</pre></div><div><img src="img/B04230_07_03.jpg" alt="Creating chained transitions"/></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec17"/>Handling the start and end events of transitions</h3></div></div></div><p>It is possible to<a id="id316" class="indexterm"/> handle the start and end events of a transition using the <code class="literal">.each()</code> function. This is useful for ensuring that the starting or ending style is exactly<a id="id317" class="indexterm"/> what you desire at the start or end of the transition. This can be an issue when interpolators (covered in the next section) are at and exact expected value, where the start values are not known until the animation is running, or there are browser-specific issues that need to be addressed.</p><div><div><h3 class="title"><a id="note93"/>Note</h3><p>An example of a browser issue is that of transparent colors being represented by <code class="literal">rgba(0,0,0,0)</code>. This is black but completely transparent. However, an animation using this will always start with fully opaque black. The start event can be used to patch up the color at the start of the animation.</p></div></div><p>The following example demonstrates hooking on to the start event of the first transition and the end event of the <a id="id318" class="indexterm"/>second transition by modifying the previous example:</p><div><div><h3 class="title"><a id="note94"/>Note</h3><p>bl.ock (7.5): <a class="ulink" href="http://goo.gl/746hLo">http://goo.gl/746hLo</a>
</p></div></div><p>There are two<a id="id319" class="indexterm"/> fundamental changes in this example. The hooking on to the start event of the first transition changes the color of the rectangle to green. This causes the rectangle to flash from red to green just after the delay finishes:</p><div><pre class="programlisting">.each('start', function() {
    d3.select(this).attr({ fill: 'green' });
})</pre></div><p>The following <a id="id320" class="indexterm"/>code shows the second change, which reforms the rectangle<a id="id321" class="indexterm"/> to yellow at the end of the second animation:</p><div><pre class="programlisting">.each('end', function() {
    d3.select(this).attr({ fill: 'yellow' });
});</pre></div><p>Note that when using the <code class="literal">.each()</code> function, the function that is called loses the context of the selection, and does not know the current item. We can get that back using the call to <code class="literal">d3.select(this)</code>, which will return the current datum that the functions are being applied to.</p><div><div><h3 class="title"><a id="note95"/>Note</h3><p>In my experience, I have found that the setting of attributes before and after transitions must use a consistent notation. If you use <code class="literal">.style()</code> prior to the transition, and then <code class="literal">.attr()</code> later, even on the same attribute, the transition will not work for that attribute. So, if you use <code class="literal">.style()</code> before <code class="literal">.transition()</code>, make sure to use <code class="literal">.style()</code> after (and vice versa for <code class="literal">.attr()</code>).</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec41"/>Changing the content and size of text using tweening</h2></div></div></div><p>
<strong>Tweening</strong> provides a <a id="id322" class="indexterm"/>means of telling D3.js the way to calculate property values during transitions without D3.js tracking the keyframes. Keyframes can be a performance issue when animating a<a id="id323" class="indexterm"/> large quantity of items, so tweening can help out in such situations.</p><p>Tweening gives us the <a id="id324" class="indexterm"/>opportunity to connect in<a id="id325" class="indexterm"/> our own <strong>interpolator</strong> for providing values at each step during an animation. An interpolator is a function that is passed a single value between 0.0 and 1.0, which represents the current percentage of the transition completed. The implementation of the interpolator then uses this value to calculate the value at that point in time.</p><p>We will look at two examples of tweening. The first example, available at the following link, animates the value of a text item from 0 to 10 over a period of ten seconds:</p><div><div><h3 class="title"><a id="note96"/>Note</h3><p>bl.ock (7.6): <a class="ulink" href="http://goo.gl/SlWBdp">http://goo.gl/SlWBdp</a>
</p></div></div><p>This is actually something<a id="id326" class="indexterm"/> that cannot be done using attribute animation. We must call the <code class="literal">.text()</code> function of the DOM element to set the text, so we cannot use that technique to animate the change in content. We have to use tweening. The following snippet from the example creates the tween that sets the text content during the animation:</p><div><pre class="programlisting">svg.append('text')
    .attr({ x: 10, y: 50 })
    .transition()
    .duration(10000)
    .tween("mytween", function () {
        return function(t) {
            this.textContent = d3.interpolateRound(0, 10)(t);
        }
    });</pre></div><p>The first parameter to <code class="literal">.tween()</code> is simply a name for this tween. The second parameter is a factory<a id="id327" class="indexterm"/> function which returns another function to D3.js that will be called at each step during the transition, passing it the current percentage of transition completed.</p><p>The factory function is called once for each datum at the start of the animation. The function it returns<a id="id328" class="indexterm"/> is called repeatedly, and uses the <code class="literal">d3.interpolateRound()</code> function to return rounded numbers between 0 and 10 based upon the value <a id="id329" class="indexterm"/>of <code class="literal">t</code>.</p><p>There are a number of<a id="id330" class="indexterm"/> interpolation functions provided by D3.js, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateNumber</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateRound</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateString</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateRgb</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateHsl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateLab</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateHcl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateArray</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateObject</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateTransform</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.interpolateZoom</code></li></ul></div><p>D3.js also has a function <code class="literal">d3.interpolate(a, b)</code>, which returns the appropriate interpolation function from the previous list based upon the type of the end value <code class="literal">b</code>, using the following algorithm:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If <code class="literal">b</code> is a color, <code class="literal">interpolateRgb</code> is used</li><li class="listitem" style="list-style-type: disc">If <code class="literal">b</code> is a string, <code class="literal">interpolateString</code> is used</li><li class="listitem" style="list-style-type: disc">If <code class="literal">b</code> is an array, <code class="literal">interpolateArray</code> is used</li><li class="listitem" style="list-style-type: disc">If <code class="literal">b</code> is an object and not coercible to a number, <code class="literal">interpolateObject</code> is used</li><li class="listitem" style="list-style-type: disc">Otherwise, <code class="literal">interpolateNumber</code> is used</li></ul></div><p>For a demonstration of<a id="id331" class="indexterm"/> <code class="literal">d3.interpolate()</code> and some of the underlying smarts, open the following example:</p><div><div><h3 class="title"><a id="note97"/>Note</h3><p>bl.ock (7.7): <a class="ulink" href="http://goo.gl/792lpH">http://goo.gl/792lpH</a>
</p></div></div><p>This example uses the <code class="literal">.styleTween()</code> function to change the font property of the style for the piece of text, increasing<a id="id332" class="indexterm"/> the size of the font from 12 px to 36<a id="id333" class="indexterm"/> px over five seconds.</p><div><img src="img/B04230_07_04.jpg" alt="Changing the content and size of text using tweening"/></div><div><pre class="programlisting">svg.append("text")
    .attr({ x: 10, y: 50 })
    .text('Watch my size change')
    .transition()
    .duration(5000)
    .styleTween('font', function() {
        return d3.interpolate('12px Helvetica', '36px Helvetica');
    });</pre></div><p>The <code class="literal">.styleTween()</code> function operates in a way similar to <code class="literal">.tween()</code> except that the first parameter<a id="id334" class="indexterm"/> specifies the name of the property that will be set to the value which is returned by the interpolation function provided by the factory method. There is also a <code class="literal">.attrTween()</code> function that does the same but on an attribute instead of a style.</p><p>The function <code class="literal">d3.interpolate()</code> is smart enough to determine that it should use <code class="literal">d3.interpolateString()</code>, and to identify that the two strings represent a font size and name besides performing the appropriate interpolation.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec42"/>Timers</h2></div></div></div><p>D3.js manages<a id="id335" class="indexterm"/> transitions using timers that internally schedule the code to be run at a specific time. These timers are also exposed for your use.</p><p>A timer can be created using <code class="literal">d3.timer(yourFunction, [delay], [mark])</code>, which takes a function to be called, a delay, and a starting time. This starting time is referred to as the <strong>mark</strong>, and it has <a id="id336" class="indexterm"/>a default value of <code class="literal">Date.now</code>.</p><p>D3.js timers are not <a id="id337" class="indexterm"/>executed at regular intervals—they are not periodic timers. Timers start execution at the time specified by <code class="literal">mark + delay</code>. The function will then be called as frequently as possible by D3.js, until the function it calls returns <code class="literal">true</code>.</p><p>The use of <code class="literal">mark</code> and <code class="literal">delay</code> can allow very specific declaration of time for starting execution. As an example, the following command schedules an event four hours prior to September 1, 2015:</p><div><pre class="programlisting">d3.timer(notify, -4 * 1000 * 60 * 60, +new Date(2015, 09, 01));</pre></div><p>To implement a one-shot timer, simply return <code class="literal">true</code> from the first call of the function.</p><p>As a final note on<a id="id338" class="indexterm"/> timers, if you want to use a timer to alert you on a regular basis, it is often better to use the JavaScript built-in function <code class="literal">setInterval()</code>. We will examine using a timer on a periodic basis in the following section.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Adding a fifth dimension to a bubble plot – time</h1></div></div></div><p>Now let's apply everything we have learned about animation to some real data. We are going to revisit our bubble <a id="id339" class="indexterm"/>plot visualization from <a class="link" href="ch06.html" title="Chapter 6. Creating Scatter and Bubble Plots">Chapter 6</a>, C<em>reating Scatter and Bubble Plots</em>, expanding the set of data from a single year (2013) to all the available years (1960 through 2013). We will modify the rendering of the visual to periodically update and animate the bubbles into new position and sizes based upon<a id="id340" class="indexterm"/> the change in the values of the data.</p><p>The <a id="id341" class="indexterm"/>expanded data set is available at <a class="ulink" href="https://goo.gl/rC5WS0">https://goo.gl/rC5WS0</a>. The fundamental difference is the inclusion of a year column, and data covering 54 years.</p><p>The code for and the demo of the<a id="id342" class="indexterm"/> example is available at the following link:</p><div><div><h3 class="title"><a id="note98"/>Note</h3><p>bl.ock (7.7): <a class="ulink" href="http://goo.gl/iYCNbG">http://goo.gl/iYCNbG</a>
</p></div></div><p>When you run this, you will see a smooth animation of the data over the years. It is obviously impossible to show this effectively in a static medium such as a book. But for demonstration, I have provided screenshots of the visualization at the start of each decade, except for 2010, which is substituted with the year 2013:</p><div><img src="img/B04230_07_05.jpg" alt="Adding a fifth dimension to a bubble plot – time"/></div><p>As the years advance, there is a strong tendency for all the countries towards an increased lifespan as well as decrease in fertility. This happens at a different pace for different countries. But it gives you a really good sense that something is going on that is causing this effect. Deciphering<a id="id343" class="indexterm"/> the plot is further made easier due to the addition of this extra dimension of time to the bubble plot.</p><p>Now let's examine<a id="id344" class="indexterm"/> how this is implemented in the example. A good portion of the code is identical to that of the example from <a class="link" href="ch06.html" title="Chapter 6. Creating Scatter and Bubble Plots">Chapter 6</a>, <em>Creating Scatter and Bubble Plots</em>, which it is based upon. The loading and cleansing of the data is slightly different due to a different URL and the need to process the <code class="literal">Year</code> column in the data:</p><div><pre class="programlisting">var url = "https://gist.githubusercontent.com/d3byex/8fcf43e446b1e4dd0146/raw/7a11679cb4a810061dee660be0d30b6a9fe69f26/lfp_all.csv";
d3.csv(url, function (error, rawData) {
    var data = rawData.map(function (d) {
        return {
            CountryCode: d.CountryCode,
            CountryName: d.CountryName,
            LifeExp: +d.LifeExp,
            FertRate: +d.FertRate,
            Population: +d.Population,
            Region: d.Region,
            Year: d.Year
        };
    });</pre></div><p>We will be rendering each year of data one at a time. As a part of this, we will need to extract only the data for each specific year. There are a number of ways that we can go about this. D3.js provides a very powerful function to do this for us: <code class="literal">d3.nest()</code>. This function pivots the <code class="literal">Year</code> column into the index of an associative array:</p><div><pre class="programlisting">var nested = d3.nest()
    .key(function (d) { return d.Year; })
    .sortKeys(d3.ascending)
    .map(data);</pre></div><p>We can then access all the data for a particular year using array semantics such as <code class="literal">nested[1975]</code>, which will <a id="id345" class="indexterm"/>give us the data (only the rows) for just 1975.</p><div><div><h3 class="title"><a id="note99"/>Note</h3><p>For more info<a id="id346" class="indexterm"/> on <code class="literal">d3.nest()</code>, see <a class="ulink" href="https://github.com/mbostock/d3/wiki/Arrays#-nest">https://github.com/mbostock/d3/wiki/Arrays#-nest</a>.</p></div></div><p>The code is then identical through the creation of the axes. The next new piece of code is to add a text label on the graph to show the year that the data represents. This is positioned in the<a id="id347" class="indexterm"/> lower-left corner of the area where the bubbles will be rendered:</p><div><pre class="programlisting">var yearLabel = svg.append('g')
    .append('text')
    .attr('transform', 'translate(40, 450)')
    .attr('font-size', '75');</pre></div><p>Then a group is created to contain the bubbles. The rendering function will select this group each time it is called:</p><div><pre class="programlisting">var bubblesHolder = svg.append('g');</pre></div><p>This marks the beginning of the code that renders and animates the bubbles. It starts by declaring the interval for which each year should be drawn (10 times per second):</p><div><pre class="programlisting">var interval = 100;</pre></div><p>Since the bubbles must be repeatedly rendered, we create a function that can be called to render the bubbles for just a specified year:</p><div><pre class="programlisting">function render(year) {
    var dataForYear = nested[year];

    var bubbles = bubblesHolder
        .selectAll("circle")
        .data(dataForYear, function (datum) { 
             return datum.CountryCode; 
        });

    bubbles.enter()
        .append("circle")
        .each(setItemAttributes);

    bubbles
        .transition()
        .duration(interval)
        .each(setItemAttributes);

    bubbles.exit().remove();

    yearLabel.text(year);
};</pre></div><p>This function first extracts the rows for the specific year, and then binds the data to the circles in the <code class="literal">bubblesHolder</code> group. The call to <code class="literal">.data()</code> also specifies that <code class="literal">CountryCode</code> will be used as the key. This is very important, because as we move from year to year, D3.js <a id="id348" class="indexterm"/>will use this to map the existing bubbles to the new data, making decisions based on this<a id="id349" class="indexterm"/> the key on which to enter-update-exit the circles.</p><p>The next statement executes the enter function creating new circles and calling a function to set the various attributes of the circles:</p><div><pre class="programlisting">function setItemAttributes(d) {
    d3.select(this).attr({
        cx: xScale(d.LifeExp),
        cy: yScale(d.FertRate),
        r: popScale(d.Population),
        style: "fill:" + regionColorMap(d.Region) + ";" +
            "fill-opacity:0.5;" +
            "stroke:" + regionColorMap(d.Region) + ";"
    });
};</pre></div><p>We use a function, as this is also used by the code to update. Finally, there is a case where occasionally a country disappears from the data, so we will remove any bubbles in the scenario.</p><p>The final thing we need to do is perform the time animation. This is done by iterating through each year at the specified interval. To do this, we need to know the start and ending year, which we can obtain with the following:</p><div><pre class="programlisting">var minYear = d3.min(data, function (d) { return d.Year; });
var maxYear = d3.max(data, function (d) { return d.Year; });</pre></div><p>This follows with setting a variable for the current year and rendering that year:</p><div><pre class="programlisting">var currentYear = minYear;
render(currentYear);</pre></div><p>Now we create a function to be called by a timer. This function returns another function which increments the year, and if the year is less than the max year, calls render again, and then schedules another timer instance to run at an interval of milliseconds. This pattern effectively<a id="id350" class="indexterm"/> uses a series of D3.js timers for implementing the periodic timer:</p><div><pre class="programlisting">var callback = function () {
    return function () {
        currentYear++;
        console.log(currentYear);
        if (currentYear &lt;= maxYear) {
            render(currentYear);
            d3.timer(callback(), interval);
        }
        return true;
    }
}</pre></div><div><div><h3 class="title"><a id="note100"/>Note</h3><p>Note that this<a id="id351" class="indexterm"/> code returns <code class="literal">true</code> every time it is called. This makes it a one-shot timer. But before returning <code class="literal">true</code>, if we need to render another year, we start another timer.</p></div></div><p>The last thing to be done is to start the timer for the first time:</p><div><pre class="programlisting">d3.timer(callback(), interval);</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter, you learned the fundamentals of animation in D3.js, and by the end of the chapter, applied these simple concepts to make what appears to be a very complex data visualization.</p><p>We started with examples of transitions, using them to animate attributes from one state to another across an interval of time, and chaining animations together. Next we looked at handling animation without keyframes using tweening. We also took a quick look at interpolation.</p><p>We finished by examining timers, and then applied all the concepts of the chapter to progressively render a large set of data, giving the viewer of the visualization a sense of how data changes by animating time.</p><p>In the next chapter, we will examine changing the visuals when the user interacts with the application, learning concepts such as the dragging and filtering of data based upon interactive events.</p></div></body></html>