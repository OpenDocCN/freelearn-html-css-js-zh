- en: Chapter 15. AngularJS – Google's In-Demand Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章。AngularJS – 谷歌的热门框架
- en: Angular is an application framework that helps you create web applications.
    It builds off of HTML and JavaScript to make the creation of dynamic applications
    easier. Angular extends and is a superset of JavaScript at the same time. You
    can use plain old JavaScript and Angular to build your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一个应用程序框架，它帮助您创建 Web 应用程序。它基于 HTML 和 JavaScript，使动态应用程序的创建更加容易。Angular
    扩展了 JavaScript，同时也是一个超集。您可以使用纯 JavaScript 和 Angular 来构建您的应用程序。
- en: This creates a double-edged sword. On the positive side, it is much easier to
    build dynamic user interfaces and keep your code maintainable and testable. On
    the other side, you must learn the overall concept of how an Angular application
    is built, which Angular piece goes where. This is very different to any other
    JavaScript application you may have built.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这把双刃剑。在积极的一面，构建动态用户界面并保持代码可维护和可测试要容易得多。在另一方面，你必须学习 Angular 应用程序构建的整体概念，即 Angular
    的哪个部分在哪里。这与您可能构建的任何其他 JavaScript 应用程序都大不相同。
- en: If all you have ever built is user interfaces with **jQuery**, **BackBone**,
    or plain old JavaScript, then much of Angular will seem new and different.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前只使用过 **jQuery**、**BackBone** 或纯 JavaScript 来构建用户界面，那么 Angular 的许多内容都会显得新颖且不同。
- en: We will try to cover Angular in a hierarchical way. We will start at the top
    with containers that hold other parts and objects and end functions that can be
    used across many objects. We will also touch upon testing, as it is a core part
    of how Angular is built.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以分层的方式尝试涵盖 Angular。我们将从顶部开始，包括包含其他部分和对象的容器，以及可以在许多对象之间使用的函数，然后讨论测试，因为它是 Angular
    构建的核心部分。
- en: Let's not waste any more time and jump right to it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要浪费时间，直接进入正题。
- en: All of the examples assume that you have loaded Angular so that the `angular`
    object is available.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都假设您已经加载了 Angular，因此 `angular` 对象是可用的。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unsure on how to load Angular, visit the official Angular page at
    [https://angularjs.org/](https://angularjs.org/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定如何加载 Angular，请访问官方 Angular 页面 [https://angularjs.org/](https://angularjs.org/)。
- en: Modules (ngApp)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块（ngApp）
- en: This is the high-level container for all the other parts of your application.
    There are more functions than those listed here, but they will be described in
    the section they relate to. For example, you can use `module.controller` to create
    a controller, but this function will be under the controller section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有其他应用程序部分的顶层容器。这里列出的功能比这些更多，但它们将在相关部分中描述。例如，您可以使用 `module.controller` 创建一个控制器，但此函数将在控制器部分中。
- en: module
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: 'Modules are the first basic building block of an Angular application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是 Angular 应用程序的第一个基本构建块：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Parameters
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`moduleName`: This is a string that will identify the module. It should be
    unique.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleName`：这是一个字符串，将标识模块。它应该是唯一的。'
- en: '`dependencies(optional)`: This is an array of module names that this module
    is dependent on.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies(可选)`: 这是一个模块名称数组，该模块依赖于这些模块。'
- en: '`configFunction(optional)`: This is a function that will configure the module.
    See *config* section.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configFunction(可选)`: 这是一个将配置模块的函数。请参阅 *config* 部分。'
- en: Return value
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is an Angular module object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Angular 模块对象。
- en: Description
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This function will either create a new module or retrieve a module. This depends
    on whether we pass in an array of dependencies. If dependencies are omitted, then
    a module is retrieved. Conversely, if we include an array of modules to load (the
    array can also be empty), then a module will be created.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将创建一个新模块或检索一个模块。这取决于我们是否传递了一个依赖项数组。如果没有省略依赖项，则检索一个模块。相反，如果我们包含一个要加载的模块数组（该数组也可以为空），则将创建一个模块。
- en: When you have a group of objects that work together, it is a good idea to put
    them into a module. Do not worry about creating too many modules. A module should
    have one and only one clear function. Then, all the objects that it needs to accomplish
    that function would be packaged with it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一组协同工作的对象时，将它们放入一个模块是一个好主意。不要担心创建太多的模块。一个模块应该只有一个且只有一个明确的函数。然后，所有它需要完成该功能的对象都将与其打包在一起。
- en: 'Here are a few examples of creating modules:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些创建模块的示例：
- en: 'This creates a new module: `var firstModule = angular.module(''firstModule'',
    []);`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将创建一个新模块：`var firstModule = angular.module('firstModule', []);`
- en: 'This retrieves a module named `firstModule`: `var firstModule = angular.module(''firstModule'');`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将检索名为 `firstModule` 的模块：`var firstModule = angular.module('firstModule');`
- en: 'This creates a module that relies on `firstModule`: `var secondModule = angular.module(''secondModule'',
    [''firstModule'']);`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这创建了一个依赖于 `firstModule` 的模块：`var secondModule = angular.module('secondModule',
    ['firstModule']);`
- en: config
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: config
- en: 'This allows you to configure providers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您配置提供者：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Parameters
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: The `configFunction` function is the function that will be executed.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configFunction` 函数是将会被执行的函数。'
- en: Return value
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is an Angular module object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Angular 模块对象。
- en: Description
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This is the function that should be used to configure providers. We will cover
    providers later in this chapter, but there are a few examples in this section.
    This allows for providers to be created before the module actually executes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于配置提供者的函数。我们将在本章后面介绍提供者，但本节中也有一些示例。这允许在模块实际执行之前创建提供者。
- en: The providers will be injected into this function when called. For example,
    you can use `$provide` or `$routeProvider` and they will be available. If you
    want to use a custom provider, it would have to be created before `config`. The
    custom object will need `provider` appended to the name for it to be available
    in `config`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此函数时，提供者将被注入到该函数中。例如，您可以使用 `$provide` 或 `$routeProvider`，它们将可用。如果您想使用自定义提供者，它必须在
    `config` 之前创建。自定义对象需要在其名称后附加 `provider` 以在 `config` 中可用。
- en: 'Here are a couple of examples using providers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用提供者的示例：
- en: 'This example uses `$provide`. The provider will be available later as `firstProvider`:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个示例使用了 `$provide`。提供者将在之后作为 `firstProvider` 可用：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This example creates a provider first. It is injected as `firstProvider` in
    `config` and used later:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个示例首先创建了一个提供者。它在 `config` 中作为 `firstProvider` 注入，并在之后使用：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: run
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: run
- en: 'This function is executed after config:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在配置之后执行：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Parameters
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: The `runFunction` function is the function that will be executed.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runFunction` 函数是将会被执行的函数。'
- en: Return value
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is an Angular module object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Angular 模块对象。
- en: Description
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: The `run()` function gets executed after `config`. At this point, all modules
    will be loaded. It is the first function called after the module is initialized
    after `config`. What you do in this function will depend on the module.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 函数在 `config` 之后执行。此时，所有模块都将被加载。这是在 `config` 之后初始化模块后第一个被调用的函数。您在这个函数中做的事情将取决于模块。'
- en: 'Here is an example that sets a scope variable. The variable will be available
    in the module in later functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个设置作用域变量的示例。该变量将在模块的后续函数中可用：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Routing (ngRoute)
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由（ngRoute）
- en: The `ngRoute` module is a module that will allow you to configure routing in
    your application. Routing is listening for changes to the location and then automatically
    responding to those changes with a new controller and template. It uses `ngView`,
    `$routeProvider`, and `$route`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngRoute` 模块是一个允许您在应用程序中配置路由的模块。路由正在监听位置的变化，然后自动对新控制器和模板做出响应。它使用 `ngView`、`$routeProvider`
    和 `$route`。'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Your module will need to depend on `ngRoute` to use these directives and services.
    We will also need to include the Angular route JavaScript in our HTML.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您的模块需要依赖于 `ngRoute` 来使用这些指令和服务。我们还需要在我们的 HTML 中包含 Angular 路由 JavaScript。
- en: ngView
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ngView
- en: 'This works with the `$route` service as a spot for content:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `$route` 服务一起作为内容的位置：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Parameters
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`onload(Angular expression)`: This evaluates on load.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onload(Angular 表达式)`: 在加载时进行评估。'
- en: '`autoscroll(Angular expression)`: Whether or not `$anchorScroll` is used with
    this `ngView`. By default, it is disabled. Otherwise, it will evaluate whether
    the expression is true or not.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoscroll(Angular 表达式)`: 是否使用 `$anchorScroll` 与此 `ngView`。默认情况下，它是禁用的。否则，它将评估表达式是否为真。'
- en: Return value
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is a directive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个指令。
- en: Description
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: When routing, you will need to mark a part of your application where dynamic
    content can be loaded. This is what `ngView` does. When a route is matched, it
    will load the new content where `ngView` is. An example will be provided for all
    of `ngRoute` at the end of the section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由时，您需要标记应用程序中可以加载动态内容的部分。这就是 `ngView` 所做的。当匹配到路由时，它将在 `ngView` 的位置加载新内容。本节末尾将提供一个
    `ngRoute` 的示例。
- en: $routeProvider
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $routeProvider
- en: 'This is a provider that lets you configure routes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个允许您配置路由的提供者：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Parameters
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`path(string)`: This is what the location will be matched against. It can contain
    named groups by using a colon (`:group`), can include a star to match multiple
    parts (`:group*`), and can be optional (`:group?`).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path(string)`: 这是位置将与之匹配的内容。它可以使用冒号（`:group`）包含命名组，可以包含星号以匹配多个部分（`:group*`），也可以是可选的（`:group?`）。'
- en: '`route(object)`: This object tells Angular what to do when the route matches.
    The object can have these properties (not an inclusive list):'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route(object)`: 这个对象告诉Angular当路由匹配时应该做什么。该对象可以具有以下属性（非详尽列表）：'
- en: '`controller`'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller`'
- en: '`template`'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`'
- en: '`templateUrl`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateUrl`'
- en: '`resolve`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolve`'
- en: Return value
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns `$routeProvider`, so it is chainable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`$routeProvider`，因此它是可链式的。
- en: Description
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This is the provider that can be used to configure all of the routes. It can
    be injected into `module.config`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以用来配置所有路由的提供者。它可以注入到`module.config`中。
- en: $route
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$route`'
- en: This is the actual service that provides which route definition has been matched.
    This is an object that can be injected directly into a controller.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提供匹配路由定义的实际服务。这是一个可以直接注入到控制器中的对象。
- en: Properties
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: '`current(object)`: This object has the current variables based on the route
    that was matched. This will include `$route`, `loadedTemplateUrl`, `locals`, `params`,
    and `scope`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current(object)`: 这个对象包含基于匹配的路由的当前变量。这将包括`$route`、`loadedTemplateUrl`、`locals`、`params`和`scope`。'
- en: '`routes(object)`: This has all the routes configured.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes(object)`: 这包含所有配置的路由。'
- en: Events
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'These events can be listened for the `$route` object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以监听这些事件的`$route`对象：
- en: '`$routeChangeStart`: This event is fired before the actual route change'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$routeChangeStart`: 在实际路由更改之前触发此事件'
- en: '`$routeChangeSuccess`: This event is fired after a route has been resolved'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$routeChangeSuccess`: 在路由解析后触发此事件'
- en: '`$routeChangeError`: This event is fired if any of the route promises are rejected'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$routeChangeError`: 如果任何路由承诺被拒绝，则触发此事件'
- en: Description
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This is a service that can be injected into each controller. The controller
    can then look at the properties to get information about the route that was matched.
    The routing matching will happen without your intervention and then you can update
    your controller's scope when the route is loaded.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以注入到每个控制器中的服务。控制器可以查看属性以获取有关匹配路由的信息。路由匹配将在你的干预下发生，然后你可以在路由加载时更新控制器的作用域。
- en: $routeParams
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$routeParams`'
- en: This is a service that will return the parameters of the loaded route. This
    will only give you parameters after a route has resolved, so you may need to use
    `$route.current.params`. This can be injected into a controller.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将返回已加载路由参数的服务。这只会在你解析了路由后提供参数，因此你可能需要使用`$route.current.params`。这可以注入到控制器中。
- en: 'Here is an example using all of the directives and services in `ngRoute`. First,
    we have an HTML body tag. This will also include an inline template named `main.html`.
    This template will echo out the `$route` and `$routeParams` objects:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`ngRoute`中所有指令和服务的示例。首先，我们有一个HTML body标签。这还将包括一个名为`main.html`的内联模板。这个模板将输出`$route`和`$routeParams`对象：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the script that will execute this. First is the creation of the module,
    then the configuration of `$routeProvider` and, finally, the definition of a controller
    for the provider to use:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行此操作的脚本。首先是创建模块，然后是配置`$routeProvider`，最后是为提供者定义一个控制器：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Dependency injection
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Angular makes use of dependency injection everywhere. Dependency injection is
    when a function does not initialize the dependencies it needs. Instead, they are
    injected into the function as parameters. For example, when a module needs a route
    provider, it asks for one. The module does not care how or when the route provider
    was created; it just wants a reference.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在所有地方都使用了依赖注入。依赖注入是指一个函数不初始化它需要的依赖项。相反，它们作为参数注入到函数中。例如，当模块需要一个路由提供者时，它会请求一个。模块不关心路由提供者是如何或何时被创建的；它只需要一个引用。
- en: You actually use the injector in everything you do in Angular. Angular just
    does it for you. We will look at `$injector` and understand how it works but,
    most likely, you will not need to use these functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上在Angular的每一件事中都使用了注入器。Angular只是为你做了这件事。我们将查看`$injector`并了解它是如何工作的，但很可能会不需要使用这些函数。
- en: Dependency injection in Angular
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular中的依赖注入
- en: 'We will quickly cover the common ways that objects are injected into functions
    in Angular. Using a controller as an example, we will cover the two most common
    methods. Both of these are using Angular''s injection behind the scenes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速介绍在 Angular 中将对象注入函数的常见方法。以控制器为例，我们将介绍两种最常见的方法。这两种方法都是在 Angular 的背后使用注入：
- en: '**Defining the variables in a function**: You just have to pass the name of
    the object you need injected. Here is an example that uses `$scope` and a service:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在函数中定义变量**：你只需传递需要注入的对象的名称。以下是一个使用 `$scope` 和服务的示例：'
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Using an array to list the dependencies**: You can get the exact same result
    using an array. The elements of the array will be the objects you need as strings.
    Finally, you will just need to have a function as the last element in the array.
    The function can even rename the variable if needed. Here is the same example
    in the array format:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用数组来列出依赖项**：你可以使用数组得到相同的结果。数组的元素将是作为字符串需要的对象。最后，你只需要在数组中有一个函数作为最后一个元素。如果需要，函数甚至可以重命名变量。以下是以数组格式相同的示例：'
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only the array format is minification safe. The first function will not work
    once the source has been minified.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 只有数组格式是压缩安全的。一旦源代码被压缩，第一个函数将无法工作。
- en: injector
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入器
- en: 'Use this to get an Angular injector that you can invoke:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法来获取一个你可以调用的 Angular 注入器：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Parameters
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: The `modules(array)` array is a list of the modules you want to load. You must
    include `ng`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules(array)` 数组是你想要加载的模块列表。你必须包含 `ng`。'
- en: Return value
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns an injector object. See `$injector` section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个注入器对象。参见 `$injector` 部分。
- en: Description
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: You can create this object to use Angular's injector object. List out the references
    you want and then invoke your function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建这个对象来使用 Angular 的注入器对象。列出你想要的引用，然后调用你的函数。
- en: 'Here is an example that gets a reference to the `$http` service:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个获取 `$http` 服务引用的示例：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: $injector
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$injector`'
- en: 'You will very rarely ever need to create an injector in Angular. It will be
    provided for you. You can get a reference to the injector by injecting it or retrieving
    it from a current module. Here are examples for both:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，你几乎很少需要创建一个注入器。它将为你提供。你可以通过注入或从当前模块中检索来获取注入器的引用。以下两种方法的示例：
- en: 'You can get a reference from any element inside of the module:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从模块内的任何元素中获取引用：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can have it injected into a function. Here is an example using `config`:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将它注入到一个函数中。以下是一个使用 `config` 的示例：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Methods
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: '`annotation`: This returns an array of the objects that will be injected'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`annotation`: 这将返回一个将要注入的对象数组'
- en: '`get(name)`: This returns the service with its name'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(name)`: 这将返回具有其名称的服务'
- en: '`invoke(function)`: This will execute the function injecting the dependencies'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke(function)`: 这将执行函数并注入依赖项'
- en: '`has(name)`: This allows you to determine whether a service exists'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has(name)`: 这允许你确定一个服务是否存在'
- en: Description
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: Angular will do this automatically for you, but it is always good to have an
    idea of what is happening. This is especially true with something that works just
    like `$injector`. Each time a function executes with dependencies, Angular will
    invoke the function from the injector, sending the correct parameters if they
    have been created and registered.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 会自动为你做这件事，但了解正在发生的事情总是好的。这尤其适用于像 `$injector` 一样工作的东西。每次函数执行时，Angular
    都会从注入器中调用函数，如果它们已被创建并注册，则会发送正确的参数。
- en: Controllers
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers are one of the core units of any Angular application. Controllers
    are used to create a small part of a module that requires its own scope. Each
    module can have many controllers. Controllers should be small and focused on one
    task.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是任何 Angular 应用程序的核心单元之一。控制器用于创建一个需要自己作用域的模块的小部分。每个模块可以有多个控制器。控制器应该是小的，专注于一项任务。
- en: Each controller should really only worry about the data and any events that
    modify that data. This means a controller should not modify the DOM, change output
    or input, or share state with another controller. Each of these should use the
    Angular solution, directives or filters, and services, respectively.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器实际上应该只关注数据和任何修改该数据的事件。这意味着控制器不应该修改 DOM、更改输出或输入，或与其他控制器共享状态。每个都应该使用 Angular
    的解决方案，即指令、过滤器和服务，分别。
- en: 'Controllers are created from a module reference, so they are tied to modules.
    Here is an example of creating a simple controller:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是从模块引用创建的，因此它们与模块相关联。以下是一个创建简单控制器的示例：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This module can then be attached to a DOM element with `ngController`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用`ngController`将此模块附加到DOM元素：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ngController
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ngController
- en: This is a core part of how Angular maps to the model-view-controller pattern.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Angular映射到模型-视图-控制器模式的核心部分。
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Parameters
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-controller(expression)` attribute is a string that will tell Angular
    which controller is tied to this element.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-controller(expression)`属性是一个字符串，它将告诉Angular哪个控制器与这个元素相关联。'
- en: Description
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: A controller needs a part of the document to attach. This directive will bind
    the controller, with its scope, to this element.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器需要一个文档的部分来附加。此指令将绑定控制器及其作用域到该元素。
- en: If a controller has been defined in a route, then you should not add this directive
    to the page. The router will take care of binding to the correct element.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制器已在路由中定义，则不应将此指令添加到页面中。路由器将负责绑定到正确的元素。
- en: 'Here is an example of using `ngcontroller` to create an alias for the controller:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`ngcontroller`为控制器创建别名的示例：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: $scope
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$scope`'
- en: This is the most important part of a controller. This is the where you should
    place everything you are tracking for this controller. This includes any functions
    that modify the scope.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制器最重要的部分。这是你应该放置所有跟踪此控制器的位置的地点。这包括任何修改作用域的函数。
- en: The `$scope` controller is injected into the controller by declaring a dependency
    to it (see dependency injection). There are built-in functions and properties
    (see Scopes), but because it is just a JavaScript object, you can add your own
    functions and properties. These will map directly to the template in the controller.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`$scope`控制器通过声明对其的依赖关系（参见依赖注入）注入到控制器中。有一些内置的函数和属性（参见作用域），但由于它只是一个JavaScript对象，你可以添加自己的函数和属性。这些将直接映射到控制器中的模板。'
- en: 'Here is an example of a controller that defines one property, `hey`, and a
    function, `changeHey`. It is important to note that there are no references to
    DOM references at all in this function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个控制器示例，它定义了一个属性`hey`和一个函数`changeHey`。重要的是要注意，在这个函数中根本没有任何对DOM引用的引用：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the template with all the data binding in the HTML document:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是包含所有数据绑定的HTML文档的模板：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Angular will know what `hey` is in this element because it is scoped to just
    `SimpleController`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将知道在这个元素中`hey`是什么，因为它仅限于`SimpleController`的作用域。
- en: Data binding and templates
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定和模板
- en: A controller uses HTML as its templating language. You can bind a value from
    the controller's scope just by surrounding it in double brackets `({{ }})`. That
    is really all there is to it!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器使用HTML作为其模板语言。你只需在双括号`({{ }})`中包围它，就可以绑定控制器作用域中的值。这就是全部内容！
- en: For some elements such as `input`, `select`, and `textarea`, you cannot just
    add the value of a `scope` object to bind them. You will have to use the `ngModel`
    directive.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些元素，如`input`、`select`和`textarea`，你不能仅仅将`scope`对象的值添加到它们来绑定。你必须使用`ngModel`指令。
- en: The `$scope` section has a great example of binding scope values to the template.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`$scope`部分有一个绑定作用域值到模板的绝佳示例。'
- en: Event binding
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件绑定
- en: Angular uses directives to bind events. In the `$scope` section, the example
    uses `ngClick` to listen for the click event on a button.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用指令来绑定事件。在`$scope`部分，示例使用`ngClick`来监听按钮上的点击事件。
- en: See the *Directives*, *Event Binding* section for a list of the most used event
    directives.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*指令*、*事件绑定*部分，以获取最常用的事件指令列表。
- en: Scope
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: The `$scope` object that gets injected into controllers has some functionality.
    In addition to this, we will look at the hierarchies and digest cycle of scopes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注入到控制器中的`$scope`对象有一些功能。除了这些，我们还将查看作用域的层次结构和消化周期。
- en: Digest cycle
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消化周期
- en: This is an important concept to understand with scopes. The digest cycle, from
    a high level, is a cycle that checks to see whether any scope variables have been
    changed. If they have, it then executes a function. Take binding a scope variable
    to the template with `{{variable}}`. The digest cycle will now watch this variable
    and, anytime it changes, it will update the template. If the variable is bound
    anywhere else, it will be updated as well. This is how Angular "magically" makes
    values auto update.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是理解作用域的一个重要概念。从高层次来看，消化周期是一个检查是否有作用域变量被更改的周期。如果有，它将执行一个函数。例如，使用`{{variable}}`将作用域变量绑定到模板上。现在消化周期将监视这个变量，并且每次它更改时，它都会更新模板。如果变量在其他地方被绑定，它也会被更新。这就是Angular“神奇地”使值自动更新的方式。
- en: A few things to keep in mind is that not everything in the scope is watched.
    The easiest way to have it watched is to bind it. You can also manually watch
    values. Also, remember that performance issues can arise when you are watching
    many variables. The digest cycle goes through all the watchers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意，作用域中并不是所有内容都被监视。最简单的方法是绑定它。你也可以手动监视值。此外，记住，当你监视许多变量时，可能会出现性能问题。消化周期会遍历所有监视器。
- en: $digest
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $digest
- en: 'This is how you can start the digest cycle:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以启动消化周期的方法：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Description
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This will manually kick off the digest cycle for the scope. In most cases, this
    does not need to be called. For example, `$digest` does not need to be called
    after updating a value from a click event when handled through Angular. Angular
    will start the digest cycle for you. A good rule of thumb is that if you are changing
    or updating a value from an Angular event or directive in a controller, you would
    not need to call `$digest`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将手动启动作用域的消化周期。在大多数情况下，这不需要调用。例如，当通过 Angular 处理点击事件更新值时，不需要调用 `$digest`。Angular
    会为你启动消化周期。一个很好的经验法则是，如果你在控制器中从 Angular 事件或指令更改或更新值，你就不需要调用 `$digest`。
- en: One case where you may need to call it is when dealing with an asynchronous
    call in a custom directive.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要调用它的情况之一是处理自定义指令中的异步调用。
- en: $watch
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $watch
- en: 'This allows you to watch a value or computed value in the digest cycle:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在消化周期中监视值或计算值：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Parameters
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`watch(string or function)`: This is what you want to watch. A string will
    be evaluated as an expression. The function will have access to the scope through
    the first parameter. Using a function allows you to watch not only for values,
    but also calculated values of variables in the scope.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watch(string or function)`: 这是你要监视的内容。字符串将被评估为表达式。函数将可以通过第一个参数访问作用域。使用函数允许你监视作用域中的值，以及变量的计算值。'
- en: '`listener(function)`: This function will have the `function(newVal, oldVal,
    scope)` signature. This is the function that will execute when the value changes.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listener(function)`: 这个函数将具有 `function(newVal, oldVal, scope)` 签名。这是当值改变时将执行的函数。'
- en: Return value
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is a function to deregister the watch.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于注销监视器的函数。
- en: Description
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This is how to manually add a watch to the digest cycle. There are two main
    reasons to do this. The first is that you will need to run a custom function when
    a value changes. The other is that you will need to watch a combination or calculation
    of a value in `$scope`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是手动将监视器添加到消化周期的方法。主要有两个原因要做这件事。第一个是当值改变时，你需要运行一个自定义函数。另一个原因是你需要监视 `$scope`
    中值的组合或计算。
- en: 'Here is an example that has a watch for a string and a function. The basis
    of the example is from *Controllers*, *$scope* sections. The first watch listens
    for the `hey` variable in the scope. The other one watches to see whether the
    value of `hey` has three or more characters. It will only fire when this threshold
    has been crossed and not fire again until it is crossed in the opposite direction:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，它监视一个字符串和一个函数。这个例子的基础来自 *控制器*，*$scope* 部分。第一个监视器监听作用域中的 `hey` 变量。另一个监视器查看
    `hey` 的值是否有三个或更多字符。它只会在这个阈值被越过时触发，并且不会再次触发，直到它以相反方向越过：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: $apply
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $apply
- en: 'This is a way to manually start the digest cycle:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是手动启动消化周期的方法：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Parameters
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: The `func(function or string)` attribute is a string, it would be evaluated
    as an expression. If it is a function, the function would be executed.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func(function or string)` 属性是一个字符串，它将被评估为表达式。如果它是一个函数，该函数将被执行。'
- en: Return value
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is the return value of the function or expression.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数或表达式的返回值。
- en: Description
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This will manually kick off the digest cycle. Much like `$digest`, this should
    not be called for the most part, except for specific situations. The most common
    situation is when a scope value has been changed outside of Angular, for example,
    an asynchronous AJAX call that has a reference to a scope value. The update happens
    outside of the digest loop and Angular does not know as it did not use any Angular
    methods.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将手动启动消化周期。与 `$digest` 类似，在大多数情况下不应调用，除非是特定情况。最常见的情况是当作用域值在 Angular 之外被更改时，例如，一个异步
    AJAX 调用，它引用了一个作用域值。更新发生在消化循环之外，Angular 并不知道，因为它没有使用任何 Angular 方法。
- en: This leads to a best practice to always use Angular's services and functions.
    If you do so, you should never have to run `$apply`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个最佳实践，即始终使用Angular的服务和函数。如果你这样做，你就不需要运行`$apply`。
- en: Another best practice is to run your function inside `$apply`. Angular will
    catch any errors that are thrown and you can deal with them the Angular way.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是在`$apply`内部运行你的函数。Angular会捕获抛出的任何错误，你可以用Angular的方式处理它们。
- en: 'Here is an example that updates the scope inside `setTimeout` after 2 seconds.
    As the digest loop has finished, it will not see this change unless `$apply` is
    called:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，在2秒后更新`setTimeout`内部的范围。由于消化循环已经完成，除非调用`$apply`，否则它将看不到这个变化：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Hierarchies
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次结构
- en: Angular applications only have one root scope but many child scopes. When a
    variable is referenced, it will check the current scope it is in and then check
    the parent. This will happen all the way up to the root scope. This is very similar
    to how JavaScript objects work with the prototype property. You can find more
    about this in [Chapter 8](ch08.html "Chapter 8. JavaScript Implementations, Syntax
    Basics, and Variable Types"), *JavaScript Object-orientated Programming*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用只有一个根作用域，但有许多子作用域。当引用一个变量时，它会检查当前作用域，然后检查父作用域。这会一直发生到根作用域。这与JavaScript对象使用原型属性的方式非常相似。你可以在[第8章](ch08.html
    "第8章。JavaScript实现、语法基础和变量类型")*JavaScript面向对象编程*中了解更多关于这个内容。
- en: Services
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: The role services play in an Angular application is clear, but there can be
    confusion around the creation of services. This is because there are three very
    similar ways to create a service in Angular. We will look at each of these and
    why they should be used.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在Angular应用中的作用是明确的，但在服务的创建方面可能会有困惑。这是因为Angular中有三种非常相似的方式来创建服务。我们将逐一查看这些方法以及为什么应该使用它们。
- en: A service in Angular is an object that can be an authority on data (meaning
    it is the only source of some data). A great example is the route provider as
    it is the only object that provides route information. It is a singleton that
    all modules utilize, a way to keep data in sync between controllers, or all of
    these! A great example of a service that you will most likely need is `$http`.
    It makes AJAX requests for you. You can build a service that returns data from
    your API and you do not have to worry about creating AJAX calls in each and every
    controller.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的服务是一个对象，它可以是一个数据权威（意味着它是某些数据的唯一来源）。一个很好的例子是路由提供者，因为它是唯一提供路由信息的对象。它是一个单例，所有模块都使用它，一种在控制器之间保持数据同步的方法，或者所有这些！你可能需要的服务的绝佳例子是`$http`。它为你执行AJAX请求。你可以构建一个服务，从你的API返回数据，你不必担心在每个控制器中创建AJAX调用。
- en: Another example is the `$route` and `$routeParams` services. When you have a
    reference to the `$route` service, you can always find out what route has been
    matched. The `$routeParams` service will let you know the parameters.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是`$route`和`$routeParams`服务。当你有一个对`$route`服务的引用时，你总能找到已匹配的路由。`$routeParams`服务会告诉你参数。
- en: Services should be used anytime you have the need to write the same code more
    than once. You can pull it out and put it into a service. In addition to this,
    services should be created for any data that will be used by more than one controller.
    The controller can then ask the service for the data. This will keep this data
    the same across multiple controllers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在任何需要多次编写相同代码的情况下使用服务。你可以将其提取出来并放入一个服务中。除此之外，对于将被多个控制器使用的任何数据，都应该创建服务。控制器可以随后向服务请求数据。这将确保这些数据在多个控制器之间保持一致。
- en: All of the functions listed can be called from the module or off the `$provide`
    injectable object.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的所有函数都可以从模块或`$provide`可注入对象中调用。
- en: 'Factory, service, and provider will all rely on an HTML template of this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂、服务和提供者都将依赖于以下HTML模板：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Factory
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂
- en: 'This is the method to create factories:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建工厂的方法：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Parameters
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`name(string)`: This is the name that the service will be known by. This can
    be used for dependency injection.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name(string)`: 这是服务将被知晓的名称。这可以用于依赖注入。'
- en: '`getFunction(function or array)`: This is the function that will return the
    service. This can also be an array that lists the dependencies.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFunction(function or array)`: 这是将返回服务的函数。这也可以是一个列出依赖项的数组。'
- en: Return value
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is an Angular module object.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Angular模块对象。
- en: Description
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: The service factory is great when you need a singleton. No configuration other
    than what is done in the `factory()` function is done. The object will be the
    same each time it is injected.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工厂在需要单例时很棒。除了在`factory()`函数中完成的配置之外，没有其他配置。每次注入时对象都是相同的。
- en: 'Here is a simple example that will return the name of the service. The example
    also creates a dependency on `$http`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，它将返回服务的名称。该例子还创建了对`$http`的依赖：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Service
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: 'Services can be initialized with `new` keyword:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以用`new`关键字初始化：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Parameters
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`name(string)`: This is the name of the service'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name(string)`: 这是服务的名称'
- en: '`constructor(function or array)`: This will be the function that is called
    as the constructor'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor(function or array)`: 这将是作为构造函数调用的函数'
- en: Return value
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is an Angular module object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Angular模块对象。
- en: Description
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'The key distinction between a service and a factory is that it can be initialized
    with `new`. Here is an example that depends on `$http`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和工厂之间的关键区别在于它可以使用`new`初始化。以下是一个依赖于`$http`的例子：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the controller that will initialize the service:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是初始化服务的控制器：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Provider
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供者
- en: 'The function that provides the most control of the setup of a provider:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对服务设置最大控制的函数：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Parameters
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`name(string)`: This is the name of the provider'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name(string)`: 这是提供者的名称'
- en: '`provider(function or array)`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provider(function or array)`'
- en: Return value
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is an Angular module object.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Angular模块对象。
- en: Description
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'This is the final and most complex way to build a service. It must return an
    object with a `$get` method. You should use this when you must have this object
    ready for configuration. This is the only provider that can be injected during
    the configuration phase of application startup. The word "provider" will be appended
    to the name of this. For example, if you named your provider `my`, it will be
    injected using `myProvider`. Here is an example provider that has its name injected
    during configuration. First up is the provider definition:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建服务的最终和最复杂的方式。它必须返回一个包含`$get`方法的对象。当你必须为此对象配置时，你应该使用这个。这是唯一可以在应用程序启动配置阶段注入的提供者。单词“提供者”将附加到这个名称上。例如，如果你将你的提供者命名为`my`，它将使用`myProvider`注入。以下是一个在配置期间注入其名称的示例提供者。首先是提供者定义：
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next is the configuration. Notice how it is injected using `firstProvider`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是配置。注意它是如何使用`firstProvider`注入的：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, here is the controller:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是控制器：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Value
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值
- en: 'This sets a value in the module:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这在模块中设置一个值：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Parameters
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`name(string)`: This is the name of the value'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name(string)`: 这是值的名称'
- en: '`value(object)`: This can be anything'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value(object)`: 这可以是任何东西'
- en: Return value
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is an Angular module object.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Angular模块对象。
- en: Description
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: A value is something that is set and then can be injected later. Values can
    only be injected into a controller or service, not during configuration.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 值是设置后可以稍后注入的东西。值只能注入到控制器或服务中，不能在配置期间注入。
- en: 'Here is a simple example of value:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的值例子：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Constant
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: 'This creates a constant variable in a module:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这在模块中创建了一个常量变量：
- en: '[PRE39]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Parameters
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`name(string)`: This is the name of the value'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name(string)`: 这是值的名称'
- en: '`value(object)`: This can be anything'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value(object)`: 这可以是任何东西'
- en: Return value
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is an Angular module object.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Angular模块对象。
- en: Description
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This is very similar to value, except that this can be used in the `config`
    function and that the value cannot be decorated.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这与值非常相似，除了它可以在`config`函数中使用，并且值不能被装饰。
- en: 'Here is a simple example of constant:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的常量例子：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: $http
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $http
- en: 'This is the service used to make HTTP calls:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于进行HTTP调用的服务：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Parameters
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`config(object)`: This object has the following properties:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config(object)`: 此对象具有以下属性：'
- en: '`method(string)`: This is the HTTP method.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method(string)`: 这是HTTP方法。'
- en: '`url(string)`: This is the URL.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url(string)`: 这是URL。'
- en: '`params(string or object)`: This is the params for the request. An object will
    be mapped key to value for this.'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params(string or object)`: 这是请求的参数。一个对象将被映射为键值对。'
- en: '`data(string or object)`: This is the data to be sent in the request.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data(string or object)`: 这是请求中要发送的数据。'
- en: '`headers(object)`: This sets the headers for the request.'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers(object)`: 这设置了请求的头。'
- en: '`xsrfHeadername(string)`: This is the name of the header for XSRF.'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xsrfHeadername(string)`: 这是XSRF的头名称。'
- en: '`xsrfCookieName(string)`: This is the name of the cookie for XSRF.'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xsrfCookieName(string)`: 这是XSRF的cookie名称。'
- en: '`cache(Boolean)`: This is used to decide whether to cache data or not.'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache(Boolean)`：这用于决定是否缓存数据。'
- en: '`responseType(string)`: This is used to decide what the request type will be.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseType(string)`：这用于决定请求的类型。'
- en: Return value
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: A promise will be returned.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回一个承诺。
- en: Description
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: If you are familiar with jQuery's AJAX function, then you are familiar with
    this. This is Angular's way of making any `XMLHttpRequests`. For most things,
    you will use one of the convenience methods that make using `$http` easier.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉jQuery的AJAX函数，那么你对这个应该很熟悉。这是Angular实现任何`XMLHttpRequests`的方式。对于大多数事情，你将使用一些方便的方法，这些方法使得使用`$http`更加容易。
- en: Convenience methods
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方便方法
- en: 'You can use all of the HTTP methods as functions: `GET`, `POST`, `HEAD`, `PUT`,
    `DELETE`, and `PATCH`. We will just look at `GET`, `POST`, and `JSONP` closely.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用所有的HTTP方法作为函数：`GET`、`POST`、`HEAD`、`PUT`、`DELETE`和`PATCH`。我们只将详细查看`GET`、`POST`和`JSONP`。
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`GET`, `POST`, and `JSONP` will cover most, if not all, of many people''s needs
    for `$http`. If this does not, view the `$http` documentation at [https://docs.angularjs.org/api/ng/service/$http](https://docs.angularjs.org/api/ng/service/$http).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`、`POST`和`JSONP`将涵盖大多数人对于`$http`的需求，如果不是全部的话。如果这还不够，请查看`$http`的文档：[https://docs.angularjs.org/api/ng/service/$http](https://docs.angularjs.org/api/ng/service/$http)。'
- en: Each function will take the URL as the first parameter and a `config` object,
    which is the same `config` object that `$http()` gets.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都将URL作为第一个参数，以及一个`config`对象，这个`config`对象与`$http()`获取的是同一个。
- en: GET
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GET
- en: 'This is a `GET` request:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`GET`请求：
- en: '[PRE42]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Description
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'This executes a simple `GET` request. Here is an example of a factory that
    uses `$http.get`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这执行了一个简单的`GET`请求。以下是一个使用`$http.get`的工厂示例：
- en: 'Here is the factory:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是工厂：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This returns a promise that the controller can then use:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个承诺，控制器可以使用它：
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: POST
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST
- en: 'This is a `POST` request:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`POST`请求：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Description
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'This will make a `POST` request. Here is a factory that makes a `POST` and
    an example that uses localhost. Remember that you must be running a server that
    responds to `POST` requests for this to work:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发起一个`POST`请求。以下是一个创建`POST`请求的工厂和示例，使用localhost。请记住，你必须运行一个响应`POST`请求的服务器，这样它才能工作：
- en: '[PRE46]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: jsonp
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: jsonp
- en: When you have to make a cross origin request, you should use `JSONP`. This will
    allow you to use the data instead of the request being blocked based on security.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须发起跨源请求时，你应该使用`JSONP`。这将允许你使用数据，而不是根据安全原因阻止请求。
- en: Notable services
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显著的服务
- en: 'I will list out some useful services that can be injected, with a short blurb
    about each:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我将列出一些可以注入的有用服务，以及每个服务的简要说明：
- en: '`$anchorScroll`: This parameter allows you to scroll to the element in the
    hash'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$anchorScroll`：此参数允许你滚动到hash中的元素'
- en: '`$animate`: This parameter allows DOM manipulations'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$animate`：此参数允许DOM操作'
- en: '`$cacheFactory`: This allows caching'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$cacheFactory`：这允许缓存'
- en: '`$http`: See `$http`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$http`：见`$http`'
- en: '`$interval`: This uses Angular''s way to call `setInterval`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$interval`：这是使用Angular的方式调用`setInterval`'
- en: '`$location`: This gets the information about `window.location`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$location`：这获取`window.location`的信息'
- en: '`$rootScope`: This returns the root scope for the application'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$rootScope`：这返回应用程序的根作用域'
- en: '`$route`: See `Routing`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$route`：见`路由`'
- en: '`$q`: This allows promises to be added in our project'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$q`：这允许在我们的项目中添加承诺'
- en: '`$timeout`: This uses Angular''s way to call `setTimout`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$timeout`：这是使用Angular的方式调用`setTimout`'
- en: This is not a comprehensive list as Angular has many services and can create
    and include more. These are the ones that you will most likely use in your applications.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完整的列表，因为Angular有很多服务，并且可以创建和包含更多。这些是在你的应用程序中最可能使用的服务。
- en: Promises
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: In JavaScript, many actions are asynchronous. A great example of this is an
    AJAX request. When the request is sent, you do not know when or even if a request
    will be returned. This is where promises come in.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，许多操作都是异步的。一个很好的例子是AJAX请求。当请求发送时，你不知道何时或甚至是否会有请求返回。这就是承诺出现的地方。
- en: A promise is an object that will promise to run a function once an asynchronous
    event has happened. In our example, the event will be the request returning. This
    could be in a few milliseconds or longer, depending on the timeout setting.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是一个对象，它承诺在异步事件发生后运行一个函数。在我们的例子中，事件将是请求返回。这可能是在几毫秒或更长的时间内，这取决于超时设置。
- en: In addition to tracking successful events, promises can be rejected. This allows
    the object that was waiting for the response to do something different.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 除了跟踪成功的事件外，promises 还可以被拒绝。这允许等待响应的对象执行不同的操作。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Visit [https://promisesaplus.com/](https://promisesaplus.com/) for the complete
    specification for using promises in JavaScript. Promises or promise-like objects
    are applicable in almost any JavaScript that you may write.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://promisesaplus.com/](https://promisesaplus.com/) 获取使用 JavaScript
    中 promises 的完整规范。Promises 或类似 promises 的对象几乎适用于你编写的任何 JavaScript 代码。
- en: $q
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $q
- en: 'This is the service that implements promises:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现 promises 的服务：
- en: '[PRE47]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Return value
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a deferred object.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个延迟对象。
- en: Description
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This is the core of building and using promises. The first thing is to get a
    deferred object, which will have to resolve and reject functions. When the action
    is successful, call the `resolve` function; when it fails, call `reject`. Finally,
    return the promise with `defer.promise`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建和使用 promises 的核心。首先，你需要获取一个延迟对象，它将包含解析和拒绝函数。当操作成功时，调用 `resolve` 函数；当它失败时，调用
    `reject`。最后，使用 `defer.promise` 返回 promise。
- en: With the promise, you can call `then`, which takes two functions. The first
    will be called when `resolve` is called, and the second will be called when `reject`
    is called. The promise can be passed around and have `then` called multiple times.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 promise，你可以调用 `then`，它接受两个函数。第一个函数将在 `resolve` 被调用时执行，第二个函数将在 `reject` 被调用时执行。promise
    可以被传递并在多次调用 `then`。
- en: Anytime you are doing anything asynchronous, you should use promises. With Angular,
    you should use `$q` as it is tied in with rootscope.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你进行异步操作的时候，都应该使用 promises。使用 Angular 时，你应该使用 `$q`，因为它与 rootscope 相关联。
- en: 'Here is an example where a function will succeed when the number is even and
    fail when the number is odd. Then, it is executed twice, logging to the console,
    whether it succeeded or failed. Note that the function is created in the controller,
    but a utility function like this should be put a service into production:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，当数字为偶数时函数会成功，当数字为奇数时会失败。然后，它执行两次，在控制台记录成功或失败。注意，函数是在控制器中创建的，但像这样的实用函数应该被放入服务中生产：
- en: '[PRE48]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Expressions
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: Expressions are a feature of Angular. They are a subset of JavaScript commands
    in addition to some Angular function. Expressions are used in many places in Angular.
    For example, anytime you bind data, you can use an expression. This makes understanding
    expressions important.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是 Angular 的一个特性。它们是 JavaScript 命令的子集，除了一些 Angular 函数。表达式在 Angular 的许多地方被使用。例如，每次你绑定数据时，你都可以使用一个表达式。这使得理解表达式变得很重要。
- en: An expression will be evaluated to a value, to a true statement, to a function
    in scope, or to a variable in scope. This makes them powerful, but they do have
    some limitations.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式将被评估为一个值，一个真值，一个作用域中的函数，或一个作用域中的变量。这使得它们强大，但它们确实有一些限制。
- en: Expressions in JavaScript
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 中的表达式
- en: 'You can use some JavaScript, but not all JavaScript in an expression. Here
    are some of the things that you can and cannot do in JavaScript using expressions:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在表达式中使用一些 JavaScript，但不能使用所有的 JavaScript。以下是一些你可以在表达式中使用和在表达式中不能使用 JavaScript
    的事情：
- en: You can use a string, number, Boolean, array literal, or object literal
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用字符串、数字、布尔值、数组字面量或对象字面量
- en: You can use any operators, for example, `a + b`, `a && b`, or `a || b`
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用任何运算符，例如，`a + b`，`a && b` 或 `a || b`
- en: You can access properties on an object or look up values in an array
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以访问对象上的属性或在数组中查找值
- en: You can make function calls
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以调用函数
- en: You cannot use flow control statements in an expression, for example, an `if`
    statement
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在表达式中使用流程控制语句，例如，一个 `if` 语句
- en: Context
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文
- en: When an expression is evaluated in Angular, it will use the scope that it is
    in. This means that you can use any object or function that is accessible in the
    scope. One difference is that you will not get access to the global `window`.
    For example, you will not be able to use `window.alert` in an expression.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Angular 中评估表达式时，它将使用其所在的范围。这意味着你可以使用在范围内可访问的任何对象或函数。一个区别是，你将无法访问全局 `window`。例如，你无法在表达式中使用
    `window.alert`。
- en: Directives
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: Directives are what Angular uses to connect to the **Document Object** **Model**
    (**DOM**). This allows Angular to separate the concerns of what each part of the
    application should do. This means that a controller should never touch the DOM.
    A controller should only work through directives to change the DOM.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是Angular用来连接到**文档对象模型**（**DOM**）的。这允许Angular将应用程序每个部分应该做什么的关注点分开。这意味着控制器永远不应该直接操作DOM。控制器应该只通过指令来改变DOM。
- en: Normalization
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范化
- en: 'When using directives, Angular must parse the DOM and figure out what directives
    apply to it. This is done by normalizing all the elements and tags. Normalization
    will remove any ";" "," " -", or" _". It will also remove `x-` and `data-` from
    the beginning of any attributes. For example, when looking for `ngModel`, all
    of the following will match:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用指令时，Angular必须解析DOM并确定哪些指令适用于它。这是通过规范化所有元素和标签来完成的。规范化将删除任何";", "," " -", 或"
    _"。它还将从任何属性的起始位置删除`x-`和`data-`。例如，当查找`ngModel`时，以下所有内容都将匹配：
- en: '`x-ng:model`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x-ng:model`'
- en: '`data-ng_model`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-ng_model`'
- en: '`ng-model`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-model`'
- en: '`ng:model`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng:model`'
- en: Note
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are concerned with HTML 5 validation, then you should use the `data-`
    normalization.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关心HTML 5验证，那么你应该使用`data-`规范化。
- en: Scope
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: Scopes inside directives can become very confusing. We will look at a few examples
    of the different ways to use scope.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 指令内部的范围可能会变得非常复杂。我们将探讨几种使用范围的不同方法。
- en: 'First up is just inheriting the scope. This means that the directive will use
    whatever value the variable has in the controller''s scope. In this example, `test`
    will have to be set in the controller''s scope:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是继承作用域。这意味着指令将使用控制器作用域中变量的值。在这个例子中，`test`必须在控制器的作用域中设置：
- en: '[PRE49]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '@ binding'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@ 绑定'
- en: The next scope modification will be to isolate the scope. You can set the scope
    property of the returned Directive Definition Object (see the next section). What
    you use here will change how the scope is built. An `@` symbol will read in the
    value as a one-way bind into the scope. An `=` symbol will create a two-way bind.
    Each of these can have the name of the attribute used after them.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个作用域修改将是隔离作用域。你可以设置返回的指令定义对象（见下一节）的作用域属性。这里使用的将改变作用域的构建方式。一个`@`符号将按单向绑定读取值到作用域中。一个`=`符号将创建双向绑定。每个都可以使用它们后面的属性名。
- en: 'For example, to bind one way to the attribute scope-test, use: `@scopeTest`.
    Here is an example that does that:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将单向绑定绑定到属性`scope-test`，使用：`@scopeTest`。以下是一个示例：
- en: '[PRE50]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This can be used like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以像这样使用：
- en: '[PRE51]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: = binding
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: = 绑定
- en: 'Here is the example using `=`. The controller will need to have a variable
    in scope to pass to the directive. Here is the directive:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`=`的示例。控制器需要在作用域中有一个变量传递给指令。以下是该指令的示例：
- en: '[PRE52]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The directive is then used like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的使用方式如下：
- en: '[PRE53]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that the attribute used to connect the scope was called `test`. This
    is because we only used `=`, instead of `=nameOfVariable`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用于连接作用域的属性被称作`test`。这是因为我们只使用了`=`，而没有使用`=nameOfVariable`。
- en: '& binding'
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '& 绑定'
- en: This is the final way is to pass a function in. This is done with `&`. When
    creating a directive with isolated scope, you run into a problem with letting
    the controller know when to take an action. For example, when a button is clicked,
    the `& binding` allows the controller to pass in the reference to a function and
    have the directive execute it.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一种方式，即传递一个函数。这是通过`&`完成的。当创建具有隔离作用域的指令时，你会遇到一个问题，即让控制器知道何时采取行动。例如，当按钮被点击时，`&
    绑定`允许控制器传递一个函数的引用，并让指令执行它。
- en: 'Here is an example directive:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例指令：
- en: '[PRE54]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The template now has a button that will call `testAction` when clicked. The
    `testAction` parameter that will execute is passed in from the controller and
    lives in the directive's scope.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 模板现在有一个按钮，当点击时会调用`testAction`。将要执行的`testAction`参数是从控制器传递过来的，并且存在于指令的作用域中。
- en: 'Here is the DOM of this directive:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该指令的DOM结构：
- en: '[PRE55]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Another situation comes up where you will need to pass information from the
    directive to the controller, for example, the event object or a variable from
    the scope. Here is an example that shows how Angular makes the `$event` object
    available in functions.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是，你可能需要从指令传递信息到控制器，例如事件对象或作用域中的变量。以下是一个示例，展示了Angular如何使`$event`对象在函数中可用。
- en: 'Here is the directive:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该指令的示例：
- en: '[PRE56]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The key is the `link` property. This runs after compilation of the directive
    and is bound to the instance of the directive. This is important if you have a
    repeating directive. Next you listen for click using a jQuery-like API called
    JQLite. From here, we must call `$apply` because we are outside of Angular and
    it will not pick up any changes made here. Finally, we executed the expression
    that was passed in creating two variables, `$e` and `$fromDirective`, that will
    be available in the function in the controller.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是 `link` 属性。它在指令编译之后运行，并绑定到指令的实例。如果你有一个重复的指令，这一点很重要。接下来，你将使用类似 jQuery 的 API
    JQLite 监听点击事件。从这里，我们必须调用 `$apply`，因为我们不在 Angular 中，它将不会检测到这里的任何更改。最后，我们执行了传递的表达式，创建了两个变量
    `$e` 和 `$fromDirective`，它们将在控制器中的函数中可用。
- en: 'Here is what the directive will look like in the DOM:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是指令在 DOM 中的样子：
- en: '[PRE57]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The two variables, `$e` and `$fromDirective`, need to be called the same thing
    as you defined in the directive.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量，`$e` 和 `$fromDirective`，需要与你在指令中定义的名称相同。
- en: Modifying DOM
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 DOM
- en: Angular makes very clear separation of concerns. This helps prevent hard-to-trace
    bugs from appearing. One of the separations is that controllers should not modify
    the DOM. Where does one modify the DOM then? In directives.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 对关注点的分离非常明确。这有助于防止难以追踪的错误出现。其中一种分离是控制器不应该修改 DOM。那么在哪里修改 DOM 呢？在指令中。
- en: Directives are the only piece of your Angular application that should have any
    knowledge of what elements are in the DOM. When a DOM modification needs to be
    made, it should be the directive that does it.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是 Angular 应用程序中唯一应该知道 DOM 中元素的部分。当需要修改 DOM 时，应该由指令来完成。
- en: Angular includes a jQuery-like library called jQLite. It has many of jQuery's
    DOM manipulation functions. If you know jQuery, you already know jQLite.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 包含一个类似 jQuery 的库，称为 jQLite。它具有许多 jQuery 的 DOM 操作函数。如果你熟悉 jQuery，那么你也就熟悉
    jQLite。
- en: 'Here is a simple example of a directive that adds a `div` element when a button
    is clicked. The example uses jQLite''s `append` function:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的指令示例，当按钮被点击时添加一个 `div` 元素。该示例使用 jQLite 的 `append` 函数：
- en: '[PRE58]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Event binding
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件绑定
- en: In an Angular application, only directives should be listening for DOM events,
    for example, the click event. This makes it very clear where the handlers reside.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中，只有指令应该监听 DOM 事件，例如点击事件。这使得处理程序所在的位置非常清晰。
- en: 'Here is an example that binds to the click event of the element and logs to
    the console:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个绑定到元素点击事件并记录到控制台的示例：
- en: '[PRE59]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Additionally, directives can let a controller pass in a function and execute
    it when an event happens (see `=` binding). Finally, the directive can even pass
    parameters into the controller from the directive. A great example is the event
    object that is returned from the event (see `&` binding).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，指令还可以让控制器传递一个函数，并在事件发生时执行它（参见 `=` 绑定）。最后，指令甚至可以将参数从指令传递到控制器。一个很好的例子是事件对象，它是从事件返回的（参见
    `&` 绑定）。
- en: Directive definition object
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令定义对象
- en: The directive definition object is the object that tells Angular how to build
    a directive.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 指令定义对象是告诉 Angular 如何构建指令的对象。
- en: 'Here are the most used properties and a quick overview of what they do:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了最常用的属性及其快速概述：
- en: '`priority`: A directive with a higher priority will be compiled first. This
    defaults to `0`.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority`: 具有更高优先级的指令将被首先编译。默认值为 `0`。'
- en: '`scope`: See *Directives, Scope* section for a much more in depth overview.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`: 请参阅 *指令，作用域* 部分，以获取更深入的概述。'
- en: '`controller`: This can be confusing, but controller is used to share logic
    between directives. Another directive can share the code in the controller by
    using require and listing the name of the required directive. That directive''s
    controller will be injected into the `link` function. The function will have the
    following definition: `function($scope, $element, $attrs, $transclude)`.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller`: 这可能有些令人困惑，但控制器用于在指令之间共享逻辑。另一个指令可以通过使用 `require` 并列出所需指令的名称来共享控制器中的代码。那个指令的控制器将被注入到
    `link` 函数中。该函数将有以下定义：`function($scope, $element, $attrs, $transclude)`。'
- en: '`require`: A string of the directive that is required. Prepending `?` will
    make this optional, `^` will search the element and parents throwing an error
    if not found, and `?^` will search the element and parents, but is optional. The
    function instance will be shared across directives.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require`: 需要的指令的字符串。在前面加上 `?` 将使其成为可选的，`^` 将在元素及其父元素中搜索，如果没有找到则抛出错误，而 `?^`
    将在元素及其父元素中搜索，但它是可选的。函数实例将在指令之间共享。'
- en: '`restrict`: This will restrict the ways you can define the directive in the
    DOM. Here are the options, with `E` and `A` being the most commonly used ones:'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restrict`: 这将限制你可以在 DOM 中定义指令的方式。以下是选项，其中 `E` 和 `A` 是最常用的：'
- en: 'E: This stands for element'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'E: 这代表元素'
- en: 'A: This stands for attribute and default'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'A: 这代表属性和默认值'
- en: 'C: This stands for class'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'C: 这代表类'
- en: 'M: This stands for comment'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'M: 这代表注释'
- en: '`template`: HTML as a string or a function that returns a string that has the
    definition of `function(element, attrs)`.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`: 字符串形式的 HTML 或一个返回字符串的函数，该字符串包含 `function(element, attrs)` 的定义。'
- en: '`templateUrl`: Loads the template from this URL.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateUrl`: 从此 URL 加载模板。'
- en: '`link`: This is where any DOM manipulations or listeners are put. This function
    will have this definition: `function(scope, element, attrs, requiredController,
    transcludeFunction)`. If another directive is required, then its `controller`
    property would be the `requiredController` parameter.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`: 这是在放置任何 DOM 操作或监听器的地方。此函数将具有以下定义：`function(scope, element, attrs, requiredController,
    transcludeFunction)`。如果需要另一个指令，则其 `controller` 属性将是 `requiredController` 参数。'
- en: Controller vs link
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器 vs 链接
- en: When to use the `controller` or `link` function can be very confusing when building
    directives. You should view the `controller` function as the interface that another
    directive can use. When a directive is required by another directive, the controller
    return value is injected into the `link` function. This will be the fourth parameter.
    The object is then accessible from `link`. The `link` function is used for any
    DOM manipulations or listeners.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建指令时，何时使用 `controller` 或 `link` 函数可能会非常令人困惑。你应该将 `controller` 函数视为其他指令可以使用的接口。当一个指令需要另一个指令时，`controller`
    返回值将被注入到 `link` 函数中。这将作为第四个参数。然后可以从 `link` 中访问该对象。`link` 函数用于任何 DOM 操作或监听器。
- en: Key directives
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键指令
- en: Here are some of the most often used directives.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些最常用的指令。
- en: ngApp
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngApp
- en: 'This is the root of your Angular application:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的 Angular 应用程序的根：
- en: '[PRE60]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Parameters
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-app(string)` attribute is the name of the default module.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-app(string)` 属性是默认模块的名称。'
- en: Description
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This will set the root element of the application. This can be put on any element,
    including the root HTML element.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置应用程序的根元素。这可以放在任何元素上，包括根 HTML 元素。
- en: This will automatically bootstrap Angular loading the module that is defined
    in `ng-app`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动引导 Angular 加载在 `ng-app` 中定义的模块。
- en: ngModel
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngModel
- en: 'This binds data from the scope to elements:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这将数据从作用域绑定到元素上：
- en: '[PRE61]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Parameters
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: '`ng-model(string)`: This will be a variable in the scope'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-model(string)`: 这将在作用域中成为一个变量'
- en: '`ng-required(boolean)`: This sets this input as required'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-required(boolean)`: 这将此输入设置为必填'
- en: '`ng-minlength(int)`: This sets the minimum length'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-minlength(int)`: 这设置最小长度'
- en: '`ng-maxlength(int)`: This sets the maximum length'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-maxlength(int)`: 这设置最大长度'
- en: '`ng-pattern(string)`: This is the regular expression that the value must match'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pattern(string)`: 这是要匹配的值的正则表达式'
- en: '`ng-change(expression)`: This is the Angular expression that will execute on
    value change'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-change(expression)`: 这是在值变化时将执行的 Angular 表达式'
- en: '`ng-trim(boolean)`: This decides whether or not to trim the value'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-trim(boolean)`: 这决定是否要修剪值'
- en: Description
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is used to bind variables in the controller's scope to input elements (text,
    select, or textarea). This will be a two-way binding, so any changes in the variable
    will update all occurrences of it.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于将控制器的作用域中的变量绑定到输入元素（文本、选择或文本区域）。这将是一个双向绑定，因此变量的任何更改都将更新其所有实例。
- en: 'Here is a simple example with text input:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的文本输入示例：
- en: '[PRE62]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ngDisabled
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngDisabled
- en: 'This can disable an element:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以禁用元素：
- en: '[PRE63]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Parameters
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: If the `ng-disabled(expression)` attribute evaluates to true, the input will
    be disabled.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `ng-disabled(expression)` 属性评估为 true，则输入将被禁用。
- en: Description
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This allows you to disable an input easily through code. The expression can
    bind to a scope variable or just evaluate what is in the expression.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你通过代码轻松地禁用输入。表达式可以绑定到作用域变量或仅评估表达式中的内容。
- en: 'Here is a simple example that disables a text input:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的示例，它禁用了文本输入：
- en: '[PRE64]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ngChecked
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngChecked
- en: 'This can make an element checked:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使一个元素被选中：
- en: '[PRE65]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Parameters
  id: totrans-463
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-checked(expression)` attribute is the Angular expression that should
    evaluate to a JavaScript Boolean value.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-checked(expression)`属性是Angular表达式，它应该评估为JavaScript布尔值。'
- en: Description
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is the Angular way to check or uncheck a checkbox based on something in
    the controller.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Angular根据控制器中的某些内容检查或取消选中复选框的方式。
- en: 'Here is an example:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE66]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ngClass
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngClass
- en: 'This sets the class of an element:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了一个元素的类：
- en: '[PRE67]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Parameters
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-class(expression)` attribute can be a string, array, or an object map.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-class(expression)`属性可以是字符串、数组或对象映射。'
- en: Description
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: When the expression is a string or array, then the value of the string or the
    values of the array will be applied as classes to the element. These can be tied
    to variables in the scope, of course.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式是字符串或数组时，字符串的值或数组的值将作为类应用于元素。当然，这些可以绑定到作用域中的变量。
- en: 'Here is an example of using a string to set the class. Here is the style that
    will be applied:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用字符串设置类的示例。这里是将要应用的风格：
- en: '[PRE68]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is the code to apply it:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是应用它的代码：
- en: '[PRE69]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The class is tied to the value of the `classString` variable. The input is bound
    so that any change will update the class on `div`. Once you type in double, it
    will apply the style.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 类绑定到`classString`变量的值。输入绑定，以便任何更改都会更新`div`上的类。一旦你输入双倍，它就会应用这种风格。
- en: 'Here is an example using an object map. The object''s property name is the
    class that will be applied and the value must be `true`. Here is a similar example
    utilizing the same class:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用对象映射的示例。对象的属性名是要应用的类，值必须是`true`。这里是一个使用相同类的类似示例：
- en: '[PRE70]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You will notice that once you type anything into the input, the class will be
    applied. This is because a non-blank string will be `true`. You can use this to
    apply as many classes as needed using more properties.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，一旦你输入任何内容到输入框中，类就会被应用。这是因为非空字符串将是`true`。你可以使用这来应用所需的任何类，使用更多的属性。
- en: ngClassOdd and ngClassEvent
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngClassOdd 和 ngClassEvent
- en: 'These set the class of an odd or even element, respectively:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分别设置奇数或偶数元素的类：
- en: '[PRE71]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Parameters
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-class-odd` or `ng-class-even(expression)` attributes must evaluate to
    a string or an array of strings that will become the class(es) for the element.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-class-odd`或`ng-class-even(expression)`属性必须评估为字符串或字符串数组，这些字符串将成为元素的类。'
- en: Description
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: These two directives are related and can even be applied to the same element.
    If a repeated element is odd, then `ng-class-odd` will evaluate and the same is
    true for `ng-class-even`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令相关，甚至可以应用于同一个元素。如果一个重复的元素是奇数，那么`ng-class-odd`将会被评估，对于`ng-class-even`也是如此。
- en: 'Here is an example that will make every odd element twice the size and every
    even element half the size. Here are the styles:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，它将使每个奇数元素的大小加倍，每个偶数元素的大小减半。以下是样式：
- en: '[PRE72]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here are the elements. The `ul` attribute creates the data to be repeated,
    and each `span` parameter statically sets the class to either odd or even. You
    can use variables in scope as well:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是元素。`ul`属性创建要重复的数据，每个`span`参数静态地将类设置为奇数或偶数。你还可以使用作用域中的变量：
- en: '[PRE73]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ngRepeat
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngRepeat
- en: 'This is a template that can be repeated:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以重复的模板：
- en: '[PRE74]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Parameters
  id: totrans-498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-repeat(repeat_expression)` attribute is similar to an expression, but
    it has a few syntax differences. Go to the description for the full explanation.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-repeat(repeat_expression)`属性类似于表达式，但它有一些语法差异。请参阅描述以获取完整解释。'
- en: Description
  id: totrans-500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Many times you will have data that has a similar template, but changes for each
    row of data. This is where `ng-repeat` comes in. The `ng-repeat` function will
    repeat the HTML that you have for each item in the repeat expression.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你会有具有相似模板但每行数据都不同的数据。这就是`ng-repeat`发挥作用的地方。`ng-repeat`函数将重复重复表达式中的每个项目的HTML。
- en: 'The repeat expression is an expression that tells `ng-repeat` what items are
    going to be looped over. Here is a rundown of some expressions:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 重复表达式是一个表达式，它告诉`ng-repeat`将要循环哪些项目。以下是一些表达式的概述：
- en: '`item in collection`: This is the classic foreach statement. It will loop over
    each item in a collection (an array, for example). The `item` parameter will be
    available inside the template.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item in collection`：这是一个经典的foreach语句。它将遍历集合（例如数组）中的每个项目。`item`参数将在模板内部可用。'
- en: '`(key, value) in collection`: If your data is in an object and you want to
    be able to associate the name of the property to the value, then you will need
    to do use this.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(key, value) in collection`：如果你的数据在一个对象中，并且你想能够将属性的名称与值关联起来，那么你需要使用这个。'
- en: '`item in collection track by grouping`: This allows for grouping. The grouping
    will only give you one item for each unique value of grouping.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item in collection track by grouping`：这允许进行分组。分组将只为每个唯一的分组值提供一个项目。'
- en: '`repeat expression | filter`: You can filter any of these expressions to give
    you a subset of the data.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat expression | filter`：你可以过滤这些表达式中的任何一个，以得到数据的一个子集。'
- en: 'Here is an example using an unordered list. Here is the controller:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用无序列表的示例。以下是控制器：
- en: '[PRE75]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here is the HTML for the controller:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制器的 HTML：
- en: '[PRE76]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ngShow and ngHide
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngShow 和 ngHide
- en: 'These can show or hide elements, respectively:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以分别显示或隐藏元素：
- en: '[PRE77]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Parameters
  id: totrans-514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-show` or `ng-hide(expression)` attributes will be evaluated to `true`
    or `false`, and the element will either by shown or hidden.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-show` 或 `ng-hide(expression)` 属性将被评估为 `true` 或 `false`，元素将相应地显示或隐藏。'
- en: Description
  id: totrans-516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: These directives allow you to show or hide content based on the data in the
    scope.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令允许您根据作用域内的数据显示或隐藏内容。
- en: 'Here is an example that uses a counter to show or hide elements. You can use
    `ng-hide` and use the opposite logic. Here is the controller:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用计数器来显示或隐藏元素的示例。你可以使用 `ng-hide` 并使用相反的逻辑。以下是控制器：
- en: '[PRE78]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next is the HTML:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 HTML：
- en: '[PRE79]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: ngSwitch
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngSwitch
- en: 'This creates a switch statement:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个 `switch` 语句：
- en: '[PRE80]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Parameters
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: '`ng-switch(expression)`: This is an expression that returns a value. This value
    will be used when evaluating `ng-switch-when`.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-switch(expression)`：这是一个返回值的表达式。这个值将在评估 `ng-switch-when` 时使用。'
- en: '`ng-switch-when(expression)`: When the value matches this expression, then
    this element will be visible.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-switch-when(expression)`：当值匹配此表达式时，则此元素将可见。'
- en: '`ng-switch-default`: This element will show when `ng-switch-when` does not
    match.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-switch-default`：当 `ng-switch-when` 不匹配时，此元素将显示。'
- en: Description
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This directive works much like the JavaScript `switch` statement. Different
    cases are tested against, and the one that matches is used. If none of the cases
    match, then a default element is used.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令的工作方式与 JavaScript 的 `switch` 语句非常相似。不同的案例会被测试，并使用匹配的案例。如果没有案例匹配，则使用默认元素。
- en: 'Here is an example that jumps between even and odd. Here is the controller:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在偶数和奇数之间跳转的示例。以下是控制器：
- en: '[PRE81]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then comes the HTML:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 HTML：
- en: '[PRE82]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: ngClick
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngClick
- en: 'This is used to define the click handler:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于定义点击处理器：
- en: '[PRE83]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Parameters
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-click(expression)` attribute is what will be evaluated when the element
    is clicked. A function can be used, and the event object is available using the
    `function($event)` function definition. Any other variables in scope can be passed
    as well, for example, `$indexin` a repeater.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-click(expression)` 属性是在元素被点击时将被评估的内容。可以使用函数，并且可以使用 `function($event)` 函数定义来访问事件对象。还可以传递作用域中的任何其他变量，例如，在重复器中的
    `$indexin`。'
- en: Description
  id: totrans-540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This directive allows you to run JavaScript on the click of an element. Usually,
    this is used with a function that is in the scope.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令允许您在元素点击时运行 JavaScript。通常，这会与作用域中的函数一起使用。
- en: 'Here is an example that will increment a `scope` variable. First, here are
    the controller''s scope variables:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将增加 `scope` 变量的示例。首先，以下是控制器的 `scope` 变量：
- en: '[PRE84]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, this is the element with the `ng-click` directive. In this example, you
    do not use the event object, but it demonstrates how to get it to the controller
    function:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是带有 `ng-click` 指令的元素。在这个例子中，您没有使用事件对象，但它演示了如何将其传递到控制器函数中：
- en: '[PRE85]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ngDblclick
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngDblclick
- en: 'This is used to define the double-click handler:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于定义双击处理器：
- en: '[PRE86]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Parameters
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `ng-dblclick(expression)` function, a function can be used and the event
    object is available using the `function($event)` function definition. Any other
    variables in scope can be passed as well, for example, `$index` in a repeater.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-dblclick(expression)` 函数，可以使用函数，并且可以使用 `function($event)` 函数定义来访问事件对象。还可以传递作用域中的任何其他变量，例如，在重复器中的
    `$index`。'
- en: Description
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This directive is very similar to `ngClick`. When the element is double-clicked,
    the expression will be evaluated.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令与 `ngClick` 非常相似。当元素被双击时，表达式将被评估。
- en: 'This is an example of a div that will increment a counter when double-clicked.
    Here are the controller''s variables:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，当双击时将增加计数器的 `div`。以下是控制器的变量：
- en: '[PRE87]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here is the element and directive:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是元素和指令：
- en: '[PRE88]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: ngMousedown, ngMouseup, ngMouseover, ngMouseenter, and ngMouseleave
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngMousedown、ngMouseup、ngMouseover、ngMouseenter 和 ngMouseleave
- en: 'These are used to define the mouse event handlers:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令用于定义鼠标事件处理器：
- en: '[PRE89]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Parameters
  id: totrans-560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: In the `ng-mouse*(expression)` function, a statement or function can be used,
    and the event object is available using the `function($event)` function definition.
    Any other variables in the scope can be passed as well, for example, `$index`
    in a repeater.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ng-mouse*(expression)`函数中，可以使用语句或函数，并且可以通过`function($event)`函数定义使用事件对象。还可以传递作用域中的其他变量，例如，在重复器中的`$index`。
- en: Description
  id: totrans-562
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: These are grouped together as they are all related. When the mouse takes the
    action (down, up, over, enter, or leave), the expression will be evaluated.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令被分组在一起，因为它们都是相关的。当鼠标执行动作（按下、释放、悬停、进入或离开）时，表达式将被评估。
- en: 'This example is a little crazy, but it demonstrates how to use these events.
    Here is the relevant portion of the controller:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有点疯狂，但它演示了如何使用这些事件。这里是控制器中的相关部分：
- en: '[PRE90]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Here are the directives:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是指令列表：
- en: '[PRE91]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ngMousemove
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngMousemove
- en: 'This is used to define the mouse move handler:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于定义鼠标移动处理器：
- en: '[PRE92]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Parameters
  id: totrans-571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: In the `ng-mousemove(expression)` function, a statement or function can be used,
    and the event object is available using the `function($event)` function definition.
    Any other variables in the scope can be passed as well, for example, `$index`
    in a repeater.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ng-mousemove(expression)`函数中，可以使用语句或函数，并且可以通过`function($event)`函数定义使用事件对象。还可以传递作用域中的其他变量，例如，在重复器中的`$index`。
- en: Description
  id: totrans-573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This fires when the mouse moves. Unless the directive is on the entire page,
    the event will be limited to only the element it is applied to.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令在鼠标移动时触发。除非指令应用于整个页面，否则事件将仅限于应用到的元素。
- en: 'Here is an example that will display the mouse''s *x* and *y* coordinates.
    Here are the relevant scope variables:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，它将显示鼠标的*x*和*y*坐标。这里是相关的作用域变量：
- en: '[PRE93]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Then comes the directive:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是指令：
- en: '[PRE94]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: ngKeydown, ngKeyup, and ngKeypress
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngKeydown、ngKeyup 和 ngKeypress
- en: 'These are used to define the key press handlers:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令用于定义按键处理器：
- en: '[PRE95]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Parameters
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: In the `ng-key*(expression)` function, a statement or function can be used,
    and the event object is available using the `function($event)` function definition.
    Any other variables in the scope can be passed as well, for example, `$index`
    in a repeater.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ng-key*(expression)`函数中，可以使用语句或函数，并且可以通过`function($event)`函数定义使用事件对象。还可以传递作用域中的其他变量，例如，在重复器中的`$index`。
- en: Description
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: These will fire when the key is pressed or released.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令会在按键按下或释放时触发。
- en: 'Here is an example that will retrieve the key code from the key that was pressed
    down. Here are the relevant `scope` variables:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，它将检索按下的键的键码。这里是相关的`scope`变量：
- en: '[PRE96]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next comes the directive:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是指令：
- en: '[PRE97]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: ngSubmit
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngSubmit
- en: 'These are used to define the submit handler:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令用于定义提交处理器：
- en: '[PRE98]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Parameters
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: In the `ng-submit(expression)` function, a statement or function can be used,
    and the event object is available using the `function($event)` function definition.
    Any other variables in the scope can be passed as well, for example, `$index`
    in a repeater.
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ng-submit(expression)`函数中，可以使用语句或函数，并且可以通过`function($event)`函数定义使用事件对象。还可以传递作用域中的其他变量，例如，在重复器中的`$index`。
- en: Description
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This directive is used to capture the `submit` event of a form. If the form
    does not have an action attribute, then this will prevent the form from reloading
    the current page.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令用于捕获表单的`submit`事件。如果表单没有action属性，那么这将防止表单重新加载当前页面。
- en: 'Here is a simple example that logs the event object to console on `submit`.
    Here is the directive:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的示例，它将事件对象记录到`submit`时的控制台。这里是相关的指令：
- en: '[PRE99]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next comes the controller code:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是控制器代码：
- en: '[PRE100]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: ngFocus and ngBlur
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngFocus 和 ngBlur
- en: 'These are used to define the focus and blur handlers, respectively:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令分别用于定义焦点和失焦处理器：
- en: '[PRE101]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Parameters
  id: totrans-604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: In the `ng-focus(expression)` function, a statement or function can be used,
    and the event object is available using the `function($event)` function definition.
    Any other variables in the scope can be passed as well, for example, `$index`
    in a repeater.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ng-focus(expression)`函数中，可以使用语句或函数，并且可以通过`function($event)`函数定义使用事件对象。还可以传递作用域中的其他变量，例如，在重复器中的`$index`。
- en: Description
  id: totrans-606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'The `ngFocus` handler will fire when the element gains focus, and `ngBlur`
    will fire when it loses focus. Here is an example with a text input that logs
    the event to console:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素获得焦点时，`ngFocus` 处理程序将被触发，而当它失去焦点时，`ngBlur` 将被触发。以下是一个使用文本输入并将事件记录到控制台的示例：
- en: '[PRE102]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here is the controller code:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制器代码：
- en: '[PRE103]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: ngCopy, ngCut, and ngPaste
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngCopy、ngCut 和 ngPaste
- en: '[PRE104]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Parameters
  id: totrans-613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: '`ng-copy`, `ng-cut`, or `ng-paste(expression)`: A statement or function can
    be used, and the event object is available using the `function($event)` function
    definition. Any other variables in the scope can be passed as well, for example,
    `$index` in a repeater.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-copy`、`ng-cut` 或 `ng-paste(expression)`：可以使用语句或函数，并且可以使用 `function($event)`
    函数定义来访问事件对象。还可以将作用域中的其他变量传递，例如，在重复器中的 `$index`。'
- en: Description
  id: totrans-615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'These are the events that will be fired when text is either cut, copied, or
    pasted. Here is an example that uses all three:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在文本被剪切、复制或粘贴时将触发的事件。以下是一个使用所有三个事件的示例：
- en: '[PRE105]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Here is the controller code:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制器代码：
- en: '[PRE106]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Globals
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: This next group of functions can be executed from anywhere in Angular without
    having to inject them. They are mainly utility functions that allow you to do
    things easier or do things the Angular way.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这组函数可以在 Angular 的任何地方执行，而无需注入它们。它们主要是实用函数，允许你更容易地或以 Angular 方式做事。
- en: Extend
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展
- en: 'This provides a way to combine two objects:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种合并两个对象的方法：
- en: '[PRE107]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Parameters
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`srcObject(object)`: The object that extends will copy the properties from'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcObject(object)`: 将复制属性的对象'
- en: '`Destobject(object)`: The object that extends will copy the properties to'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destobject(object)`: 扩展对象将复制属性到的对象'
- en: Return value
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a reference of `destObject`.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 `destObject` 的引用。
- en: Description
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: In JavaScript, there is no in-built way to extend an object using another object.
    This function does just that.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，没有内置的方法可以使用另一个对象扩展对象。这个函数正是这样做的。
- en: 'Here is a simple example that will extend one object with the other''s property:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，它将扩展一个对象以包含另一个对象的属性：
- en: '[PRE108]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: noop
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: noop
- en: 'This is the no operation function:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这是无操作函数：
- en: '[PRE109]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Parameters
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: The `any` or `none` functions are used as these functions does nothing, you
    can pass in no parameters or as many as you want.
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any` 或 `none` 函数用作这些函数不执行任何操作，你可以传入零个或任意多个参数。'
- en: Return value
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This will return `undefined`.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 `undefined`。
- en: Description
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: It is useful to have a function do no operation (`noop`). A great example of
    this is when you have a function as a parameter that is optional. If it is not
    passed in, you can run `noop` instead.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个不执行任何操作（`noop`）的函数很有用。一个很好的例子是当你有一个作为参数的函数，它是可选的。如果没有传入，你可以运行 `noop`。
- en: 'This is a simple example that demonstrates the scenario explained earlier:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，演示了前面解释的场景：
- en: '[PRE110]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: isUndefined
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: isUndefined
- en: 'This checks to see whether something is undefined:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查某个东西是否未定义：
- en: '[PRE111]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Parameters
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: The `object(any type)` function can be any variable.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object(any type)` 函数可以是任何变量。'
- en: Return value
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a Boolean value.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个布尔值。
- en: Description
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This states whether or not the variable is defined.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示变量是否已定义。
- en: Copy
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: 'This makes a copy of an object:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个对象的副本：
- en: '[PRE112]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Parameters
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`srcObject(any type)`: This is the source object to be copied.'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srcObject(any type)`: 这是将要被复制的源对象。'
- en: '`destObject(same type as srcObject)`: This is optional. If it is supplied,
    it would be the destination of the copy operation.'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destObject(same type as srcObject)`: 这是可选的。如果提供，它将是复制操作的目的地。'
- en: Return value
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This function returns the copy of `srcObject`. If `destObject` is supplied,
    it would be returned.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回 `srcObject` 的副本。如果提供了 `destObject`，则返回它。
- en: Description
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: When you need to make a copy of an object instead of modifying the original
    object, use this function.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要复制一个对象而不是修改原始对象时，请使用此函数。
- en: Bind
  id: totrans-664
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: 'This binds a function to an object:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个函数绑定到一个对象上：
- en: '[PRE113]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Parameters
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: '`self(object)`: This will set `this` (the inner self-reference) in the function'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self(object)`: 这将在函数中设置 `this`（内部自我引用）'
- en: '`Function(function)`: This is the function that is being bound'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function(function)`: 这是正在绑定的函数'
- en: '`Args(any type)`: These are the arguments that will be bound to the function'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Args(any type)`: 这些是绑定到函数的参数'
- en: Return value
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This is the new bound function.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新绑定的函数。
- en: Description
  id: totrans-673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This creates a new bound function that will execute in the context of self.
    This allows you to define a function and then execute it many times in different
    contexts. This is further extended by binding arguments as well.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新的绑定函数，它将在 `self` 的上下文中执行。这允许你定义一个函数，然后在不同的上下文中多次执行它。通过绑定参数，这进一步扩展了。
- en: 'This is a contrived example, but demonstrates the principles. First is a function
    that depends on the context to execute. It will add the first parameter to `this`
    and multiply that result:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个虚构的例子，但演示了原理。首先是一个依赖于上下文来执行的函数。它将第一个参数添加到 `this` 中，并乘以该结果：
- en: '[PRE114]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Next, you will use `angular.bind` to create a new function:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用 `angular.bind` 来创建一个新的函数：
- en: '[PRE115]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This can be executed, and the return value will be 5 times the multiplier.
    In `newFunc`, `this` is `4`, and `toAdd` is `1`, so the inner parens will always
    be `5`. For example this will return `10`:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以执行，并且返回值将是乘数的 5 倍。在 `newFunc` 中，`this` 是 `4`，而 `toAdd` 是 `1`，所以内层括号总是 `5`。例如，这将返回
    `10`：
- en: '[PRE116]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Forms
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: Forms are a core part of sending data to a server in HTML. As a result of this,
    Angular has some extra features that work with forms.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是 HTML 中向服务器发送数据的核心部分。因此，Angular 有一些与表单一起工作的额外功能。
- en: ngModel
  id: totrans-683
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ngModel
- en: Each form input will need `ngModel` defined to store the value in the scope.
    See *Directives*, *ngModel* for more information.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表单输入都需要定义 `ngModel` 以在作用域中存储值。见 *指令*、*ngModel* 了解更多信息。
- en: 'Here is a simple form that binds two text inputs:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的表单，它绑定两个文本输入：
- en: '[PRE117]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: CSS classes
  id: totrans-687
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS 类
- en: 'Angular will automatically add CSS classes to the form and elements that you
    can then target with CSS. Here is the list of CSS classes and when they are applied:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 会自动将 CSS 类添加到表单和元素中，然后你可以使用 CSS 选择器来定位它们。以下是 CSS 类及其应用情况列表：
- en: '`ng-valid`: This denotes that the form or element is valid'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-valid`：表示表单或元素有效'
- en: '`ng-invalid`: This denotes that the form or element is invalid'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-invalid`：表示表单或元素无效'
- en: '`ng-pristine`: This denotes that the control has not been changed'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pristine`：表示控件尚未更改'
- en: '`ng-dirty`: This denotes that the control has been changed'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-dirty`：表示控件已被更改'
- en: Validation
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: Angular has features that make validation very easy. First, Angular will use
    any of the HTML 5 input types. These allow the browser to do some validation,
    but Angular will still track any errors.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 有一些特性使得验证变得非常简单。首先，Angular 会使用任何 HTML 5 输入类型。这允许浏览器执行一些验证，但 Angular
    仍然会跟踪任何错误。
- en: Next, you can use any of the built-in validation directives of `ngModel`. The
    list is `required`, `pattern`, `minLength`, `maxLength`, `min`, and `max`. See
    *Directives*, *ngModel* for more info about each. When an input fails validation,
    the value will not be passed into the bound scope variable.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用 `ngModel` 的任何内置验证指令。列表包括 `required`、`pattern`、`minLength`、`maxLength`、`min`
    和 `max`。见 *指令*、*ngModel* 了解每个指令的更多信息。当输入验证失败时，值将不会传递到绑定的作用域变量中。
- en: 'Here is an example that sets a minimum length on `firstName`:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个设置 `firstName` 最小长度的示例：
- en: '[PRE118]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: When a form is given a `name` attribute, it is bound to the scope as that name.
    When inputs are given names in a form, they are bound to that form. This allows
    you to use other directives with these values.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单有一个 `name` 属性时，它将绑定到该名称的作用域。当在表单中给输入赋名时，它们将绑定到该表单。这允许你使用其他指令与这些值一起使用。
- en: 'Here is an example that will show an error message when the text input does
    not meet the minimum length of 10:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，当文本输入未达到 10 个字符的最小长度时，将显示错误消息：
- en: '[PRE119]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The validation message will only show when the field is invalid.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 验证消息仅在字段无效时显示。
- en: The form will have `$dirty`, `$invalid`, `$pristine`, and `$valid` as properties
    that can be used in directives or in scope. The inputs will have the same properties
    and additionally an `$error` object that will have each of the failed validations
    as a property. In the preceding example, this means that `form.firstname.$error.minLength`
    will return `true` when the input has failed that validation and `false` when
    it is valid.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 表单将具有 `$dirty`、`$invalid`、`$pristine` 和 `$valid` 属性，可以在指令或作用域中使用。输入将具有相同的属性，并且还有一个
    `$error` 对象，它将每个失败的验证作为属性。在前面的例子中，这意味着当输入未通过该验证时，`form.firstname.$error.minLength`
    将返回 `true`，当它有效时返回 `false`。
- en: Custom validators
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义验证器
- en: When you need to create your own logic, you can build a custom validator. You
    will need to create a new directive, require `ngModel`, and pass the value through
    the `$parsers` object of the `ngModel` controller when it is passed into the `link`
    function. Then, use `$setValidity` based on whether or not the value passed validation.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要创建自己的逻辑时，你可以构建一个自定义验证器。你需要创建一个新的指令，引入 `ngModel`，并在将其传递到 `link` 函数时，通过 `ngModel`
    控制器的 `$parsers` 对象传递值。然后，根据传递的值是否通过验证使用 `$setValidity`。
- en: 'Here is an example of a custom validator where you cannot have the value of
    the input set to `josh`:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个自定义验证器的示例，其中输入的值不能设置为 `josh`：
- en: '[PRE120]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Testing
  id: totrans-707
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Testing should always be a major part of any development project. Angular has
    been built from the beginning to be testable. It has clear separation of concerns;
    for example, you do not need to build a full DOM to test a controller. Angular
    also uses dependency injection everywhere, which makes mocking up objects very
    easy.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该始终是任何开发项目的重要组成部分。Angular 从一开始就被设计为可测试的。它具有清晰的关注点分离；例如，你不需要构建完整的 DOM 来测试控制器。Angular
    还在所有地方使用依赖注入，这使得模拟对象变得非常容易。
- en: Unit testing with Jasmine and Karma
  id: totrans-709
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jasmine 和 Karma 进行单元测试
- en: '**Jasmine** and **Karma** are two tools that allow you to quickly and easily
    test your Angular code.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jasmine** 和 **Karma** 是两个允许你快速轻松地测试 Angular 代码的工具。'
- en: Jasmine
  id: totrans-711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jasmine
- en: This is the actual unit testing library that we will use. Jasmine is a behavior-driven
    testing framework and is really easy to write.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用的实际单元测试库。Jasmine 是一个行为驱动测试框架，编写起来非常简单。
- en: Karma
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Karma
- en: 'Karma is the test runner that will watch your files and automatically kick
    off your tests. It runs on Node.js, so you must have it installed. You can then
    install Karma with `npm`:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 是一个测试运行器，它将监视你的文件并在文件发生变化时自动启动测试。它运行在 Node.js 上，因此你必须安装它。然后，你可以使用 `npm`
    安装 Karma：
- en: '[PRE121]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Karma can watch your test files and rerun them whenever any of the files change.
    You can also debug tests in the browser if there are any issues. It is a great
    complement to Jasmine, and Google recommends both for testing.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 可以监视你的测试文件，并在任何文件发生变化时重新运行它们。如果存在任何问题，你还可以在浏览器中调试测试。它是 Jasmine 的绝佳补充，Google
    推荐两者都用于测试。
- en: ngMock
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ngMock
- en: The `ngMock` handler is used to help mock up your application when testing.
    When testing, you will not want to create an entire DOM to load just one module.
    This is where `ngMock` can create a controller instance for use, and we can then
    test it.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngMock` 处理器用于在测试时帮助模拟应用程序。在测试时，你不会想创建一个完整的 DOM 来加载单个模块。这就是 `ngMock` 可以创建一个控制器实例以供使用的地方，然后我们可以对其进行测试。'
- en: Module
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: 'This allows you to load a module:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你加载一个模块：
- en: '[PRE122]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Parameters
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `moduleName(string)` function take
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleName(string)` 函数执行'
- en: Description
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: You do not have a root element to put `ng-app` on, so `module` allows us to
    load a module to get access to its controllers, services, and directives. You
    should only use this function in tests after loading `ngMock`.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有根元素可以放置 `ng-app`，因此 `module` 允许我们加载一个模块以获取其控制器、服务和指令的访问权限。你应该只在加载 `ngMock`
    后在测试中使用此函数。
- en: Inject
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入
- en: 'This gets the Angular inject services:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 这获取 Angular 注入服务：
- en: '[PRE123]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Parameters
  id: totrans-729
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The `toBeInjected(function)` function works much like other injected functions.
    List out the objects to be injected, and they will be available in the function
    body.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toBeInjected(function)` 函数的工作方式与其他注入函数类似。列出要注入的对象，它们将在函数体中可用。'
- en: Description
  id: totrans-731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Use inject to get access to built-in Angular services, such as `$controller`
    and `$compile`, or use it to get access to a loading module's services.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注入来获取内置的 Angular 服务，例如 `$controller` 和 `$compile`，或者使用它来获取加载模块的服务。
- en: Inject can load dependencies if they are wrapped with underscores. For example,
    inject would load `$compile` if it is used as `_$compile_`. This is done because
    in a test, we will need to create a reference to the `$compile` service, and most
    likely, we would want to use `$compile` as the variable name. The underscores
    allow you to inject it and use the `$compile` variable.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 如果依赖项被下划线包裹，注入可以加载依赖项。例如，如果使用 `_$compile_`，注入将加载 `$compile`。这是因为在测试中，我们需要创建
    `$compile` 服务的引用，并且很可能会希望将 `$compile` 作为变量名。下划线允许你注入它并使用 `$compile` 变量。
- en: $httpBackend
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: $httpBackend
- en: 'This can create a mock response:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以创建一个模拟响应：
- en: '[PRE124]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Parameters
  id: totrans-737
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: '`requestType(string)`: This is the HTTP method of the request'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestType(string)`: 这是请求的 HTTP 方法'
- en: '`url(string)`: This is the URL of the request'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url(string)`: 这是请求的 URL'
- en: '`requestParameters(object)`: These are the parameters of the request'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestParameters(object)`：这些是请求的参数'
- en: '`headers(object)`: These are the headers for the request'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers(object)`：这些是请求的头信息'
- en: '`response(string, object)`: This is the response of the request'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response(string, object)`：这是请求的响应'
- en: Return value
  id: totrans-743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a handler that can call `respond`.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个可以调用`respond`的处理程序。
- en: Description
  id: totrans-745
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Making AJAX calls is a perfect example of something that should not be done
    in a unit test. There are too many things out of your control for unit testing.
    The `$httpBackend` handler is provided by `ngMock` so that you can create a mock
    response.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中执行AJAX调用是一个不应该做的事情的例子。对于单元测试来说，有太多您无法控制的事情。`$httpBackend`处理器由`ngMock`提供，以便您可以创建模拟响应。
- en: The handler must match the expected method and URL at the very least. You can
    also match the optional parameters and headers if you plan on making specific
    requests with them.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器至少必须匹配预期的方法和URL。如果您计划使用它们进行特定请求，还可以匹配可选参数和头信息。
- en: When the request is matched, you can send back a string or object as the response.
    This allows you to create a test that uses `$httpBackend`, as you know what the
    response is going to be.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求匹配时，您可以发送一个字符串或对象作为响应。这允许您创建一个使用`$httpBackend`的测试，因为您知道响应将会是什么。
- en: The difference between `expect` and `when` is that `expect` has to be called
    in the test, whereas `when` does not have that requirement.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect`和`when`之间的区别在于`expect`必须在测试中调用，而`when`没有这个要求。'
- en: Unit testing controllers
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试控制器
- en: 'Here is an example of a simple unit test for a controller. First, you must
    create a controller and then load it in our test:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个控制器简单单元测试的例子。首先，您必须创建一个控制器，然后在我们的测试中加载它：
- en: '[PRE125]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'You can now create the test. In the test, you must load the `firstModule` module,
    inject `$controller`, and create an instance of `SimpleController`. Here is the
    test:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以创建测试。在测试中，您必须加载`firstModule`模块，注入`$controller`，并创建`SimpleController`的实例。以下是测试代码：
- en: '[PRE126]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Unit testing directives
  id: totrans-755
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试指令
- en: 'This example will show you how to test a directive. First, create the directive:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将向您展示如何测试一个指令。首先，创建指令：
- en: '[PRE127]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, you will need to load the module, inject `$compiler` and `$rootscope`,
    compile the directive, and finally, start the digest loop at least once to bind
    any values:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要加载模块，注入`$compiler`和`$rootscope`，编译指令，并最终至少启动一次消化循环以绑定任何值：
- en: '[PRE128]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Unit testing services
  id: totrans-760
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试服务
- en: 'The final testing example will test a service. First, create a service:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试示例将测试一个服务。首先，创建服务：
- en: '[PRE129]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Next, you will have to load the module, inject `$httpBackend` and the service
    factory, create a response, and load the response. Notice the use of `$httpBackend.flush()`.
    This will send the response to any open requests:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要加载模块，注入`$httpBackend`和服务工厂，创建一个响应，并加载该响应。注意`$httpBackend.flush()`的使用。这将把响应发送到任何打开的请求：
- en: '[PRE130]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
