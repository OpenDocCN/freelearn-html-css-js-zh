- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Establishing the Development Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is an extremely versatile and powerful tool for developing, running,
    and sharing a working 3D rendered scene, the **Babylon.js Playground** (**PG**)
    also has a place in the development workflow of a traditional web application.
    Effective software development is effectively enabled by the removal of friction.
    Friction in this sense is anything that presents an obstacle between writing code
    and executing the results and can take almost any form, from the mundane to the
    obscure. As an example, say it takes an hour between the time a change is made
    in code to the time that changed code is running in the developer’s web browser.
    The developer will then be compelled to include as much as possible in every new
    build, which then makes it more difficult to understand the effects of any one
    change on the application’s behavior. Focus is diluted and progress is incremental
    and not in proportion to the effort required in these situations, which is why
    small tweaks to a development workflow can yield large gains. We’re going to examine
    one out of many potential **Babylon.js** development workflows during the course
    of this chapter, and by the end of it, you will have the tools to rapidly and
    efficiently build games that can evolve as rapidly as you can think of designs!
  prefs: []
  type: TYPE_NORMAL
- en: 'Everyone is going to have a different way of approaching the structure and
    process of development, and that’s OK. Each of these sections illustrates an aspect
    of the workflow that seeks to maximize developer efficiency and quality while
    minimizing tech debt and uncertainty:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crafting a Playground Snippet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning from the Playground to the Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing the Landing Page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The base set of requirements for running the BJS PG are detailed in [*Chapter
    2*](B17266_02_Final_AM.xhtml#_idTextAnchor030), *Ramping up on Babylon.js*, but
    in addition to those requirements, there are some additional development tools
    that we’re going to be using.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Although the examples and such are all based on a Windows-based developer experience,
    there are no Operating System requirements to follow along with this book. All
    of the tools discussed are available on multiple platforms and any differences
    in syntax or usage will be highlighted or called out where feasible.
  prefs: []
  type: TYPE_NORMAL
- en: The specific usages of each individual item will be covered during the accompanying
    chapter material, and it is assumed that you have some familiarity with the tools
    and/or usage. For information on setting up and configuring a given tool, please
    see the corresponding link to the tool’s documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio Code** is our IDE of choice, is available on all platforms,
    works wonderfully, and is free: [https://code.visualstudio.com](https://code.visualstudio.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js v14.15.4 (LTS)** or greater: [https://docs.npmjs.com/](https://docs.npmjs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node Package Manager (npm) CLI v6.x (LTS Release)** or greater, installed
    via a node version manager listed at [https://docs.npmjs.com/cli/v6/configuring-npm/install](https://docs.npmjs.com/cli/v6/configuring-npm/install)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git** SCM client. Also, to be able to submit **Pull Requests**, file **issues**,
    or participate in **Discussions**, a valid GitHub account is required: [https://github.com](https://github.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Note for TypeScript Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Should you prefer to do all your coding in **TypeScript** as opposed to straight-JavaScript,
    that’s great! Babylon.js itself is written in **TypeScript** and is fully supported
    for developing in BJS. Following along with the code in this book is possible,
    and any differences in syntax and structure aren’t always going to be explained
    or called out. That said, the code should be largely compatible between the two
    languages, keeping in mind the following two primary changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Playground snippets should use TypeScript mode. This has a slightly different
    template. Start at [https://www.babylonjs-playground.com/ts.xhtml#](https://www.babylonjs-playground.com/ts.xhtml#)
    and click `createScene` method is encapsulated as a `Playground`. Declare new
    classes and use them in the `createScene` method similar to how you would in regular
    JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When integrating classes written in the PG, it’s important to add the `export
    class Foo { //… }`). Since you will be using the **tsc** (**TypeScript Compiler**)
    to output JavaScript, there are times when you’ll need to **import** certain Babylon.js
    modules for their **side effects**. Please see [https://doc.babylonjs.com/divingDeeper/developWithBjs/npmSupport#typescript-support](https://doc.babylonjs.com/divingDeeper/developWithBjs/npmSupport#typescript-support)
    for more on how to configure **TypeScript** for use with Babylon.js
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effective software development relies on being able to confidently introduce
    changes to an application’s construction. Confidence in introducing, changing,
    or removing code comes from a) being able to run the code using the new changes,
    and b) through not being in a position where undoing changes imposes risks of
    its own. Let’s park that thought for a moment to back up and start from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Preparatory Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *a priori* assumption going into this step is that you have **G****it**,
    **VSCode**, **Node.js**, and **NPM** all set up and ready to go. A linting tool
    such as **ESLint** is also recommended. If you know what you’re doing, go ahead
    and get those tools set up and configured now. No rush, it’s just the rest of
    the book that’s waiting is all – this has been speculated to go faster if you
    work while humming *The Girl from Ipanema* to yourself. **VSCode** has a rich
    ecosystem of extensions that can make your life easier. Here is a list of some
    of the ones you’ll want to install (or their equivalents). Go to the **Extensions**
    panel in **VSCode**, then search for the appropriate item’s **Marketplace ID**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – List of useful VSCode extensions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B17866.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – List of useful VSCode extensions
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not quite there yet when it comes to knowing where and how to do this
    sort of thing, here’s what you can do. Ignore the elevator muzak, tie a bandana
    around your forehead, and dive straight into an 80s movie montage sequence. You
    will probably want to set a bookmark on this page first – the montage features
    a series of vignettes of you flipping to the *Further Reading* section at the
    end of this chapter, reading and following the links, culminating in a triumphantly
    successful installation… and then flipping back to your bookmark, ready to continue
    the journey.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize All the Things
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of unflashy tasks that go on here – things such as creating
    a new Git repository in GitHub and cloning it locally, which would take up too
    much space to go through in detail. Instead, here’s a rough checklist of what
    to expect to do as part of this step:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Git** repository. If created in **GitHub**, you may need to **clone**
    the repos locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `.gitignore` file to the repos – the only contents it really needs at
    this point are entries for the output `dist/` folder and for the `node_modules/`
    folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create some folders – `src`, `dist`, `public`, and `assets` – to hold the source
    code, the packed output, and game assets, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm init` to create a `package.json` for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install webpack and core Babylon.js libraries and dependencies as developer
    dependencies with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install additional Babylon.js modules that we’ll be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the package dependencies squared away, it’s time to add a few more foundational
    pieces to our nascent application.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts and ESLint Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At some point in the very near future, we’re going to want to be able to add
    some automation around our application’s build and deployment tasks. The key to
    making this as frictionless as possible is to leverage as much of the (and similar)
    application infrastructure as possible. Keeping it simple and focusing scripts
    on a single task will allow for easier automation in the future.
  prefs: []
  type: TYPE_NORMAL
- en: package.json Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three basic commands that we want to start out adding to our `package.json`
    file. These are simple scripts that will allow both local and production builds
    and linting of source. We’ll address dev versus production builds in an upcoming
    section, but for now, add these scripts to the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`: The webpack dev server and related packing processes for local development.
    Command: `npx webpack serve --mode development`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: Runs webpack in production configuration. Command: `npx webpack --mode
    production`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lint`: Makes sure our code doesn’t have any big “whoopsies!”. Command: `npx
    eslint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check your work for typos, and make sure that you save and commit both your
    `package.json` and your `package.lock.json` files. At this point, we’re still
    a couple of items short on our checklist to set up the application, so let’s get
    them knocked out so we can press forward on our journey!
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to simply reference and load the entire Babylon.js library
    into the application, it is incredibly inefficient to do so – because BJS does
    so much, there’s a lot to the libraries, meaning they’re quite large in size and
    complexity. Clients are forced to download the full bundle of JS before the application
    can become responsive to input, reducing a user’s perception of an application’s
    performance. One of the most modern and effective ways to reduce an application’s
    footprint is by leveraging a feature of **ES6** called **tree shaking**. The process
    of tree shaking results in code output that includes only dependencies that are
    actually used in the code, resulting in smaller, faster, and more efficient JavaScript
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s the downside? As you’ll see, every imported type must have its own `import`
    statement, but in addition, the full path of the type must be specified – not
    just the containing package. Still, the benefits can be substantial – as I commented
    in this pull request: [https://github.com/jelster/space-truckers/pull/15](https://github.com/jelster/space-truckers/pull/15).
    The start scene was reduced in size from 8.91 MB to 3.11 MB, a more than 50% reduction!'
  prefs: []
  type: TYPE_NORMAL
- en: Babylon.js has been around longer than ES6 modules have been supported, and
    the team has made a firm commitment to support backward compatibility in the engine.
    That’s why you’ll notice there are some places where compromises in that vein
    result in the need to import modules purely for side effects – the **MeshBuilder
    CreateXXXX** APIs are a prominent example of this. The BJS docs have more information
    located at [https://doc.babylonjs.com/divingDeeper/developWithBjs/treeShaking](https://doc.babylonjs.com/divingDeeper/developWithBjs/treeShaking)
    that can explain more about why and what modules behave in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The PG examples we’ve looked at previously haven’t required anything special
    in the way of building, but that’s because the PG is built towards a different
    goal than what we’re looking to accomplish. We’re building a complete application
    that needs to not be dependent on the same luxuries (such as a CDN for grabbing
    the Babylon.js libraries) as the PG. To do that, we will sacrifice the flexible
    but inefficient load-everything approach of the PG for the compactness and efficiency
    of a webpacked application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Configuration for ESLint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new file using VSCode to the root folder of your repository, named `.eslintignore`.
    This is a text file that we’ll use to exclude certain directories from being checked
    by the lint tool, improving responsiveness and reliability. We don’t want our
    `node_modules` directory to be checked since we’re not working on those libraries.
    Neither do we care about JavaScript that’s already been packaged and output –
    anything in our `dist/` folder. Add the following lines to the `.eslintignore`
    file you’ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save and close the file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add another new file to the root directory and name it `webpack.common.js`,
    then create another two named `webpack.dev.js` and `webpack.prod.js`. We’ll put
    the base webpack config in the `webpack.common.js` file and merge environment-specific
    config at script runtime using `webpack-merge`. At the same time, create a new
    empty file in `src` and name it `index.js` along with an empty `index.xhtml` in
    the `public/` directory. This will serve as a placeholder for future work while
    allowing us to test and validate our current config.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`dist/` folder. Other related assets may also be affected in ways ranging from
    generating correct URL paths to rendering markup templates into output directories
    and more. Check out the **Webpack** repos along with the docs at [https://github.com/webpack/webpack](https://github.com/webpack/webpack)
    to learn more about configuration and plugin options.'
  prefs: []
  type: TYPE_NORMAL
- en: Development versus Production Modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When running in a production build context, there are really only two things
    we need to happen. First, Webpack does its thing, bundling and packaging up all
    the `.js` scripts in the `src/` folder, outputting the results to the `dist/`
    folder. Second, a script reference to the application’s entry point – `index.js`
    – is injected into an `index.xhtml` file that is what gets served to web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Local development has a slightly different set of needs than a production build.
    We want to be able to make changes to our code and see the results of those changes
    as quickly as possible, which rules out the potentially lengthy process of re-bundling
    everything from scratch upon a change. Instead, the **webpack development server**
    is smart enough to both cache build output and selectively rebuild only what’s
    been changed. A **WebSocket** connection to the browser is used to automatically
    refresh the page when a new bundle is compiled, helping further to close any gaps
    in iteration. We also want to emit JavaScript **source maps** to aid in debugging
    as well as to specify content paths for non-bundled content served by our development
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Common Webpack Config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regardless of whether webpack is being run for development or production usage,
    we always want to make sure that our destination directory is cleaned of any old
    or potentially stale source files. We’ll use the `CleanWebpackPlugin` for that
    purpose, and the `HtmlWebpackPlugin` to inject the proper script references into
    our `index.xhtml` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the `webpack.common.js` file, let’s add some `import` statements and
    define the `module.exports` stub function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that unlike the rest of our application, our webpack configuration
    isn’t using `entry` object that designates the script that will serve to launch
    our application on the client; it will be injected into a `<script>` tag in the
    site’s default `index.xhtml` landing page.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: File and folder paths can be tricky to navigate when working in a cross-platform
    environment. The `__dirname` webpack-provided variable is a good way to avoid
    problems in the first place because it will correctly and consistently represent
    the equivalent of `fs.cwd()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `entry` item and potentially other config elements will need to know what
    base paths to use when reading and writing files, so we designate and compute
    that value. While we’re at it, we might as well add the output entry to our config.
    This object specifies where to emit the packed results, and to help identify it
    among potential other scripts we name it `babylonBundle.js`. Finally, we instantiate
    new instances of our `CleanWebpackPlugin` and `HtmlWebpackPlugin` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The order that plugins are added to the plugins array is important! Make sure
    that your `CleanWebpackPlugin` is always at the top of the plugin list so that
    it runs first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HtmlWebpackPlugin` is given the path to our publicly served HTML `index.xhtml`
    page and told to inject the proper script tags for the bundle into the document.
    Once that is done, we’ll test our config quickly before completing the common
    (and also the biggest) configuration setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By specifying an `assetModuleFilename` pattern, we are instructing `assets`
    subfolder with the original file name, extension, and any query string parameters.
    To test out our configuration, make sure you’ve saved everything and enter the
    following command in a terminal window (make sure your working directory is the
    same as the root of the repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes well, you should see a bunch of text in your command window,
    some green text, and no errors. That’s great, but there’s not much of anything
    going on so we can’t take a break quite yet – we’re very close to finishing this
    section!
  prefs: []
  type: TYPE_NORMAL
- en: Resolver and Loader Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of processing your source code, Webpack will compile a list of all the
    various **import** (or require for CommonJS modules) and invoke a processing pipeline
    that uses matching rules to select the appropriate logic to resolve the location
    for the request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is an area where **TypeScript** users will see significant differences
    between their implementations and this ES6 (-ish) one. **Raanan Weber** of the
    BJS team has made a TypeScript starter repository available at [https://github.com/RaananW/babylonjs-webpack-es6](https://github.com/RaananW/babylonjs-webpack-es6).
    The TypeScript Webpack code listed here is modeled to be as similar as possible
    to Raanan’s starter template to make transitioning between reading this text and
    your code easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the need to have to code for environmental differences in static asset
    URLs, we use `source-map-loader` helps to match symbols from runtime code with
    locations in the source code. Before that though, our config needs a `resolve`
    object that specifies an array of `extensions` to enable searching through. Add
    this as a property of the returned config, just below the `output` property. Here’s
    what that part of the config might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The list of `rules` in the `modules` property define what constitutes a separate
    module in the eyes of `test` to perform to see whether the given loader will handle
    the request. The long regular expression for the asset/resource module type is
    essentially a list of all the different file extensions that we want to be considered
    as assets, which are copied without further processing into the output directory.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack Development and Production Configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our `webpack.dev.js`, we’re going to make use of the `webpack-merge` add-on
    to webpack. This handy utility will merge two webpack config objects together,
    returning the combined result. Why is this handy? Because we’ll be able to have
    separate development and production configurations without needing to hardcode
    their names into the `webpack.common.js` or the `package.json` scripts. If we
    want to add another environment configuration, all we need to do is add the new
    webpack config file, merge our common config, and then point our `npx webpack
    --config` parameter at the appropriate file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are really only two things we need from our dev config that we don’t
    have in common. First, configuration for the web server launched with `npx webpack
    serve`. Second, we specify that we want our source maps to be sent inline with
    our scripts. The top-level mode of “development” ensures that various production-suited
    optimization paths are not taken by webpack. This is what our `webpack.dev.js`
    looks like when we’re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating `webpack.prod.js` is even simpler since we don’t need the dev server
    configuration, and it shares the same set of top-level `require` statements as
    our dev configuration. To reduce the size of our script packages, we will choose
    not to emit source maps, and other than setting the mode to **production**, that’s
    the only difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we shift our focus a bit, let’s get some markup into our `public/index.xhtml`
    file. We don’t need much right now, so let’s start with this simple markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough for us to check our progress by making sure all files have been
    saved before running `npm run start`. Success is indicated by the launching of
    your web browser and a console output similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Webpack output after successful bundle](img/Figure_3.02_B17866.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Webpack output after successful bundle
  prefs: []
  type: TYPE_NORMAL
- en: While the webpack development server is running, any changes you make to your
    source code will automatically refresh your browser. Leave the dev server running,
    because we’re going to start making use of it!
  prefs: []
  type: TYPE_NORMAL
- en: Crafting a PG Snippet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can use our PG code in our application, we’re going to need to do
    some light refactoring. A little bit of preparation can save a lot of time later!
    The things we’re going to change are select pieces of code that could vary between
    the PG and local environments, such as texture paths and URLs, along with some
    minor structural modifications. For your convenience, here’s a link to the refactored
    snippet. If you are just joining us here in the journey, use the link below. If
    you’ve been following along, substitute your own snippet URL for the following
    one. Start by opening your favorite browser and navigating to either your own
    snippet or to [https://playground.babylonjs.com/#0UYAPE#42](https://playground.babylonjs.com/%230UYAPE%2342).
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up the BABYLON Namespace Prefix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the things that you may have found annoying about coding in the PG is
    how in the PG it’s necessary to always prefix BJS types with the `BABYLON` namespace.
    This is not ideal, but we can get rid of the need for them by adding an alias
    to all the various types we’re using to the top of our snippet. The alias in our
    PG snippet will be defined as a `const` assembled from the various BJS types used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can then do a Find and Replace (*Ctrl + F* or *Command + F*) for the string
    `BABYLON.` (don’t forget the period!) and that will complete our work on this
    section. To preview where this is headed, when we move this into our VSCode environment,
    we’ll convert this to an `import` statement. Doing this refactoring after the
    fact, like we are in this case, isn’t ideal; in the future, we will start our
    snippets out with this construct and build it over time. That way, it won’t be
    nearly as much effort!
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Magic Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three separate textures (not including the procedural one) in use
    in our snippet, and we want to make it easier to change the specific URL or file
    path. We begin that by defining a set of `const` strings in the PG to contain
    the PG-specific paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then go into the `createStar` and `createPlanet` functions and replace
    the hardcoded paths with our constant expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve replaced all of the hardcoded string values, click **Save** and
    refresh the page to make sure the snippet still runs OK, paying attention to any
    missing textures, and fixing any missing references that may pop up. With these
    changes in place, it will be a smooth transition from running this in the PG to
    using it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from the PG to the Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PG is a rich, robust, and extensible way to quickly get started writing
    and running code, but our application has different needs from the PG that we
    will need to account for and fulfill. We want to make sure that our code is both
    easy to change and easy to understand, but fortunately, there are small steps
    we can take that will make a large difference later on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Engine Instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, the immediate question is this: how do we take our plucky snippet here
    and plug it into our application without turning it into an exercise in both masochism
    and self-discipline? The secret lies in preparation. When we built our PG snippet,
    we structured logic as atomically as possible into various discrete `index.js`
    that will take the place of the PG’s `engine` initialization. Add this to the
    file below the part where we created the `canvas` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty bog-standard Babylon.js `Engine` initialization. The `Engine`
    constructor has a number of interesting different parameters and configuration
    options that we’ll explore further on down the road. For now, we are mostly using
    the engine defaults except for enabling `createStartScene` in anticipation of
    its imminent arrival.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and Importing the StartScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file in your project’s `src` folder and name it `startscene.js`.
    Copy and paste everything from the PG snippet into this new file *except* the
    `createScene` function. A couple of minor modifications are all that’s needed
    thanks to the groundwork we previously laid down!
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `const` to `import`, also replacing the `=` with `from` `“@babylonjs/core”`
    as the name to source imports. The `StarfieldProceduralTexture` isn’t a part of
    the core BJS framework, so we’ll also need to pull that entry out of the import
    list and give it its own entry: `import { StarfieldProceduralTexture } from “@babylonjs/procedural-textures”;`.'
  prefs: []
  type: TYPE_NORMAL
- en: The final change is to replace our `const` texture paths with `import` statements
    pointing to the appropriate texture in our `/assets/textures` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t already have the three textures downloaded and in the asset directory,
    now would be a good time to do it. The URL prefix for textures is just [https://www.babylonjs-playground.com/textures/](https://www.babylonjs-playground.com/textures/),
    followed by the name of the texture with the extension, (e.g., `rock.png`). We
    want to be able to use consistent paths to refer to assets throughout the application,
    so we are using `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Why don’t we just use the online version of the resource instead of duplicating
    it locally? Good question. Later on in the book, we’ll cover how to make Space-Truckers
    into a **Progressive Web Application** (**PWA**), and how to make assets available
    for offline use.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `import` statements will be included in the build output. In addition,
    the asset is assigned a unique filename that helps bust aggressive caches when
    assets are modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Exporting and Importing the Start Scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One last item to add to our `startscene.js` and we’ll be ready to finish wiring
    it into the game! If we reflect back on the overall design of our snippet’s functions,
    we can readily see that the only “public” function need be the `createStartScene`
    function. Let’s make that function available to consumers by adding `export default`
    to the function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and switch back to your `index.js`. Since we’ve already added
    the invocation of the `createStartScene` and the following `import` to the top
    of the file’s import list: `import createStartScene from “./startscene”;`. Save
    the file and check that the **Webpack output** doesn’t contain any errors. When
    your browser refreshes, you should see a familiar scene being rendered. Go ahead
    and give yourself a pat on the back – you’ve completed pulling in our main application
    background scene! There’s something still missing, however, and that’s something
    for visitors to see when they first arrive at the web page but before they launch
    the game. It would be sort of rude to just take over a visitor’s browser and start
    downloading MBs of content without asking first, so we are going to put out a
    welcome mat in the form of the landing HTML page.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the Landing Page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although it is web-based and hosted by a web server, there is a critical principle
    at play for Space-Truckers: the game that we haven’t done much but hint at previously.
    That principle is that we want to, by all means necessary, avoid using the HTML
    DOM in the game. Now, to be fair, it’s not a total blanket ban on using HTML or
    CSS anywhere, just anywhere important. The reason for this is we want to give
    our future selves a gift that makes it seamless to target Space-Truckers to Babylon
    Native; code that uses the HTML DOM isn’t compatible with BJS Native. That said,
    there is still the need to do a little bit of HTML and CSS work to make the landing
    page a little bit more hospitable to visitors.'
  prefs: []
  type: TYPE_NORMAL
- en: The Concept (Art)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When Space-Truckers was just in the process of being conceived as an idea,
    early concept sketches were useful in helping to establish various different aspects
    of the look, feel, and setting of the game. The following figure depicts what
    we want our landing page to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – HTML landing page design'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B17866.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – HTML landing page design
  prefs: []
  type: TYPE_NORMAL
- en: When a user navigates to the Space-Truckers website, they’ll be presented with
    a centered image that functions in the same way that a book cover attempts to
    convey some sense of the book’s content. A Call-to-Action button to Launch the
    game sits prominently and visibly in the center of the viewport, enticing the
    visitor to click the button and play the game. Lastly, we have a small site footer
    with the standard privacy, support, repository, license, copyright notices, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will want to structure our markup such that it will display appropriately
    on-screen dimensions ranging from the high dpi (but small screen size) of a smartphone
    or tablet to the much larger but lower resolutions offered by large-screen TVs
    and display monitors. Aspect ratios are important too!
  prefs: []
  type: TYPE_NORMAL
- en: Sticking the Landing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all goes well, we’ll end up with something similar to this for our landing
    page. We’re not going to worry about fonts or background images right now as much
    as we want to get more of a sense of how we want to lay out and design various
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The Space-Truckers landing page. Behind the foreground content
    are the animated orbiting planets created in Chapter 2, Ramping up on Babylon.js'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B17866.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – The Space-Truckers landing page. Behind the foreground content
    are the animated orbiting planets created in Chapter 2, Ramping up on Babylon.js
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, there’s some HTML markup along with CSS styles that need to
    be added to the `/public/index.xhtml` page. There’s an additional small change
    we’ll need to make to the `index.js` file that will add a class of `background-canvas`
    to the newly created HTML Canvas that is appended to the document with `canvas.classList.add(“background-canvas”);`,
    so get that change out of the way and open up the `public/index.xhtml` file in
    VSCode. There’s enough that needs to be added that it would take up a prohibitive
    amount of page space, so at this point, you have a couple of options:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the homework assignment and build out the HTML/CSS to get to the preceding
    screenshot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grab the finished files (there will be two or so in total, in addition to the
    `index.js` change) from [https://github.com/jelster/space-truckers/tree/ch3-final](https://github.com/jelster/space-truckers/tree/ch3-final)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There isn’t any right or wrong answer; it’s whatever you will enjoy and learn
    from the most in the amount of time you have available that means the most and
    you’re the only one who can decide what that is! Each chapter in this book has
    an accompanying branch (and tag) in Git. The purpose of leaving the entire branch
    with its commit history in place is to give you the opportunity to see how the
    code evolves, commit by commit, while avoiding adding too much noise to the main
    branch’s commit history.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a whirlwind of Webpack, ES6 Imports, and CSS shenanigans, we’ve completed
    a key process that started with a simple PG snippet and finished with an animated
    landing page. Along the way, we set up our local development scripts so we can
    take advantage of modern JavaScript features such as tree-shaking to optimize
    our package bundle sizes, while still being able to quickly integrate and view
    changes into the application.
  prefs: []
  type: TYPE_NORMAL
- en: What’s next from here should be fairly obvious to anyone who has ever stood
    in front of a Big Red Button labeled “Launch”. It’s time to Push the Button, and
    make it do interesting things! Yes, we will be implementing our application’s
    Launch-time experience, which involves establishing some mechanics of state in
    the application. Don’t worry if you’re not through with this section yet, there’s
    more to be done!
  prefs: []
  type: TYPE_NORMAL
- en: Extended Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the person looking to make the launch page their own or who wants to dive
    deeper into the potential possibilities opened up by this chapter, here are some
    things you might consider doing:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a cool hover-in/out effect to the launch button so that when the cursor
    hovers over it, a color and/or animated effect is applied. Do the same for clicking
    the button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the landing page’s navigational structure with links to the GitHub repos,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the central hero area into an image carousel that can be populated with
    additional concept art, screenshots, gameplay videos, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use CSS to blend the canvas animation with the hero image in an interesting
    fashion. You can do different types of blending, such as difference, exclusion,
    screen, and so on, along with other cool transformations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
