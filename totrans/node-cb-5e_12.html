<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-376">
    <a id="_idTextAnchor388">
    </a>
    
     12
    
   </h1>
   <h1 id="_idParaDest-377">
    <a id="_idTextAnchor389">
    </a>
    
     Debugging Node.js
    
   </h1>
   <p>
    
     The asynchronous nature of JavaScript and Node.js can make the debugging process non-trivial.
    
    
     Unlike traditional synchronous code execution, the asynchronous behavior of Node.js introduces complexities that can challenge even experienced developers.
    
    
     However, over the past decade, Node.js has matured significantly as a technology.
    
    
     Along with this maturation, the debugging capabilities and facilities have improved in tandem, providing developers with more robust tools and methodologies to troubleshoot
    
    
     
      their applications.
     
    
   </p>
   <p>
    
     In this chapter, we will explore the various steps we can take to make our applications easier to debug.
    
    
     By implementing best practices and adopting a structured approach to coding, we can mitigate some of the inherent difficulties associated with asynchronous programming.
    
    
     We will also delve into the modern tools available for debugging Node.js applications, such as the built-in debugger, various third-party debugging tools, and advanced
    
    
     
      logging techniques.
     
    
   </p>
   <p>
    
     Additionally, we will cover how to leverage Node.js’s diagnostic reports feature, a powerful utility introduced in the latest versions of Node.js.
    
    
     This feature provides in-depth insights into the state of your application at the time of failure, making it easier to pinpoint the root causes of issues.
    
    
     By the end of this chapter, you will have a comprehensive understanding of the strategies and tools necessary to effectively debug Node.js applications, ensuring smoother development and more stable
    
    
     
      production environments.
     
    
   </p>
   <p>
    
     This chapter will cover
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Diagnosing issues with
     
     
      
       Chrome DevTools
      
     
    </li>
    <li>
     
      Logging
     
     
      
       with Node.js
      
     
    </li>
    <li>
     
      Enabling
     
     
      
       debug logs
      
     
    </li>
    <li>
     
      Enabling Node.js core
     
     
      
       debug logs
      
     
    </li>
    <li>
     
      Increasing stack
     
     
      
       trace size
      
     
    </li>
    <li>
     
      Creating
     
     
      
       diagnostic reports
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-378">
    <a id="_idTextAnchor390">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     For this chapter, you will require Node.js 22 to be installed and available in your terminal path.
    
    
     You can test which version of Node.js is installed and available in your path with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ node --version
v22.9.0</pre>
   <p>
    
     You’ll also need access to an editor and browser.
    
    
     For the
    
    <em class="italic">
     
      Diagnosing issues with Chrome DevTools
     
    </em>
    
     recipe, you will need to have Google Chrome installed, which you can download
    
    
     
      from
     
    
    <a href="https://www.google.com/chrome/">
     
      
       https://www.google.com/chrome/
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-379">
    <a id="_idTextAnchor391">
    </a>
    
     Diagnosing issues with Chrome DevTools
    
   </h1>
   <p>
    
     Node.js offers a powerful debugging utility through the
    
    <strong class="source-inline">
     
      --inspect
     
    </strong>
    
     process flag, enabling us to debug and profile our Node.js processes using the Chrome DevTools interface.
    
    
     This integration
    
    <a id="_idIndexMarker929">
    </a>
    
     is made possible by the Chrome DevTools Protocol, which facilitates communication between Node.js and Chrome DevTools.
    
    
     The
    
    <a id="_idIndexMarker930">
    </a>
    
     existence of this protocol allows for the creation of tools that seamlessly integrate with Chrome DevTools, providing a unified debugging experience across
    
    
     
      different environments.
     
    
   </p>
   <p>
    
     In this recipe, we will learn how to utilize Chrome DevTools to diagnose and resolve issues within a web application.
    
    
     We’ll cover how to set up the debugging environment, connect to a Node.js process, and navigate the various features of Chrome DevTools.
    
    
     This includes inspecting variables, setting breakpoints, and stepping through
    
    
     
      our code.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      node --debug
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      node --debug-brk
     
    </strong>
    
     are legacy Node.js flags that have been deprecated since Node.js v6.3.0.
    
    <strong class="source-inline">
     
      node --inspect
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      node --inspect-brk
     
    </strong>
    
     are the modern equivalents that should be used in place of these
    
    
     
      legacy flags.
     
    
   </p>
   <h2 id="_idParaDest-380">
    <a id="_idTextAnchor392">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In this recipe, we will debug a minimal web server built with Express.
    
    
     Let’s prepare this before we start
    
    
     
      the
     
    
    
     <a id="_idIndexMarker931">
     </a>
    
    
     
      recipe:
     
    
   </p>
   <ol>
    <li>
     
      First, let’s set up a directory and the files required for
     
     
      
       this recipe:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir debugging-with-chrome</strong>
<strong class="bold">$ cd debugging-with-chrome</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ npm install express</strong>
<strong class="bold">$ touch server.js random.js</strong></pre>
    </li>
    <li>
     
      Add the following
     
     <a id="_idIndexMarker932">
     </a>
     
      source code to
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      to create our
     
     
      
       web server:
      
     
     <pre class="source-code">
const express = require('express');
const app = express();
const random = require('./random');
app.get('/:number', (req, res) =&gt; {
  const number = req.params.number;
  res.send(random(number).toString());
});
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
    <li>
     
      Add the following source code to
     
     <strong class="source-inline">
      
       random.js
      
     </strong>
     
      .
     
     
      This will be a local module we interact with via
     
     
      
       our server:
      
     
     <pre class="source-code">
module.exports = (n) =&gt; {
  const randomNumber = Math.floor(Math.random() * n) + '1';
  return randomNumber;
};</pre>
    </li>
   </ol>
   <p>
    
     Now that we have an
    
    <a id="_idIndexMarker933">
    </a>
    
     application ready to debug, we can move on to the
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-381">
    <a id="_idTextAnchor393">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to
    
    <a id="_idIndexMarker934">
    </a>
    
     use Chrome DevTools (
    
    <a href="https://developer.chrome.com/docs/devtools">
     
      https://developer.chrome.com/docs/devtools
     
    </a>
    
     ) to debug a route in our application.
    
    
     We expect the application to respond with a random number between
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     and the number we specify in the route.
    
    
     For example,
    
    <strong class="source-inline">
     
      http://localhost:3000/10
     
    </strong>
    
     should return a random number between
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       10
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Start the program with
    
    <strong class="source-inline">
     
      $ node server.js
     
    </strong>
    
     and navigate to
    
    <strong class="source-inline">
     
      http://localhost:3000/10
     
    </strong>
    
     .
    
    
     Refresh the endpoint a few times and you should notice that the program will often respond with a number greater than
    
    <strong class="source-inline">
     
      10
     
    </strong>
    
     .
    
    
     This indicates that we have a bug in our program; so, let’s debug to try and understand why this error
    
    
     
      is occurring:
     
    
   </p>
   <ol>
    <li>
     
      First, we need to start our program with the debugger enabled.
     
     
      To do this, we need to pass the
     
     <strong class="source-inline">
      
       --inspect
      
     </strong>
     
      argument to our
     
     
      
       Node.js process:
      
     
     <pre class="source-code">
<strong class="bold">$ node --inspect server.js</strong>
<strong class="bold">Debugger listening on ws://127.0.0.1:9229/35fa7c65-62a5-48b4-8428-9a414ec28afe</strong>
<strong class="bold">For help, see: https://nodejs.org/en/docs/inspector</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      Instead of going directly to the link specified in the output, navigate to
     
     <strong class="source-inline">
      
       chrome://inspect/#devices
      
     </strong>
     
      in Google Chrome.
     
     
      Expect to see the
     
     
      
       following output:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.1 – Screenshot of the Google Chrome inspector Devices interface" src="img/Figure_12.1_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.1 – Screenshot of the Google Chrome inspector Devices interface
    
   </p>
   <ol>
    <li value="3">
     
      Observe that
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      is showing
     
     <a id="_idIndexMarker935">
     </a>
     
      up as
     
     <strong class="bold">
      
       Remote Target
      
     </strong>
     
      .
     
     
      Click the
     
     <strong class="bold">
      
       inspect
      
     </strong>
     
      link and the
     
     <a id="_idIndexMarker936">
     </a>
     
      Chrome DevTools window should open, as shown in the
     
     
      
       following figure:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.2 – Screenshot of the Chrome DevTools interface" src="img/Figure_12.2_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.2 – Screenshot of the Chrome DevTools interface
    
   </p>
   <ol>
    <li value="4">
     
      Click on
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      in the
     
     <a id="_idIndexMarker937">
     </a>
     
      bottom-right corner of the
     
     <a id="_idIndexMarker938">
     </a>
     
      window.
     
     
      This should ensure our
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file
     
     
      
       is open:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.3 – Screenshot of the Chrome DevTools interface depicting the server.js file" src="img/Figure_12.3_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.3 – Screenshot of the Chrome DevTools interface depicting the server.js file
    
   </p>
   <ol>
    <li value="5">
     
      Now, we can add
     
     <a id="_idIndexMarker939">
     </a>
     
      a breakpoint.
     
     
      Click the number
     
     <strong class="source-inline">
      
       7
      
     </strong>
     
      in the line-of-code column to the left of our code.
     
     
      A small red circle should appear next to the
     
     <a id="_idIndexMarker940">
     </a>
     
      number.
     
     
      If you click
     
     <strong class="bold">
      
       Show Debugger
      
     </strong>
     
      in the top-right corner, you should see the breakpoint listed in the
     
     <strong class="bold">
      
       Breakpoints
      
     </strong>
     
      pane.
     
     
      The Chrome DevTools interface should look like
     
     
      
       the following:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.4 – Screenshot of Chrome DevTools showing a breakpoint registered in the server.js file" src="img/Figure_12.4_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.4 – Screenshot of Chrome DevTools showing a breakpoint registered in the server.js file
    
   </p>
   <ol>
    <li value="6">
     
      Now, let’s open
     
     <a id="_idIndexMarker941">
     </a>
     
      a new regular browser window and navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000/10
      
     </strong>
     
      .
     
     
      The request will hang because it has hit the breakpoint we registered on
     
     
      <em class="italic">
       
        line 7
       
      </em>
     
     
      
       .
      
     
    </li>
    <li>
     
      Go back to Chrome
     
     <a id="_idIndexMarker942">
     </a>
     
      DevTools.
     
     
      You should notice that there is a tooltip stating
     
     <strong class="bold">
      
       Paused on breakpoint
      
     </strong>
     
      in the top-right corner of the interface.
     
     
      Also, to the right of the interface, you should see a
     
     <strong class="bold">
      
       Call Stack
      
     </strong>
     
      panel, which details the
     
     
      
       call frames:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.5 – Screenshot of the Chrome DevTools interface showing as Paused on breakpoint" src="img/Figure_12.5_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.5 – Screenshot of the Chrome DevTools interface showing as Paused on breakpoint
    
   </p>
   <ol>
    <li value="8">
     
      The debugger is waiting for us to act.
     
     
      We can choose to step in or out of the next instruction.
     
     
      Let’s step into
     
     <a id="_idIndexMarker943">
     </a>
     
      the function.
     
     
      To do this, click the icon of an arrow pointing down to
     
     <a id="_idIndexMarker944">
     </a>
     
      a circle (these icons are right above the
     
     <strong class="bold">
      
       Paused on breakpoint
      
     </strong>
     
      message).
     
     
      When you hover over each icon, a tooltip will appear describing the icon’s behavior.
     
     
      Once you have stepped in, you will see that we have moved into our
     
     
      <strong class="source-inline">
       
        random.js
       
      </strong>
     
     
      
       file:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.6 – Screenshot of the Chrome DevTools interface showing the random.js file" src="img/Figure_12.6_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.6 – Screenshot of the Chrome DevTools interface showing the random.js file
    
   </p>
   <ol>
    <li value="9">
     
      While we’re in
     
     <strong class="source-inline">
      
       random.js
      
     </strong>
     
      , we can hover over the values to check whether they are what we
     
     <a id="_idIndexMarker945">
     </a>
     
      expect them to be.
     
     
      We can see that
     
     <strong class="source-inline">
      
       n = 10
      
     </strong>
     
      ,
     
     
      
       as expected.
      
     
    </li>
    <li>
     
      Step over the
     
     <a id="_idIndexMarker946">
     </a>
     
      function (by clicking the semi-circular arrow with a dot underneath) and then inspect the value of
     
     <strong class="source-inline">
      
       randomNumber
      
     </strong>
     
      .
     
     
      In the screenshot, the random number generated is
     
     <strong class="source-inline">
      
       11
      
     </strong>
     
      , which is greater than
     
     <strong class="source-inline">
      
       10
      
     </strong>
     
      .
     
     
      This helps us determine that the error is in our
     
     <strong class="source-inline">
      
       randomNumber
      
     </strong>
     
      logic of the previous line.
     
     
      Now that we have identified the line the error is on, it is easier to locate the error.
     
     
      Observe that we are adding the string
     
     <strong class="source-inline">
      
       '1'
      
     </strong>
     
      rather than the
     
     
      
       number
      
     
     
      <strong class="source-inline">
       
        1
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.7 – Screenshot of the Chrome DevTools interface showing variable values on hover" src="img/Figure_12.7_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.7 – Screenshot of the Chrome DevTools interface showing variable values on hover
    
   </p>
   <p>
    
     We have learned how to
    
    <a id="_idIndexMarker947">
    </a>
    
     pause and step through code using
    
    <a id="_idIndexMarker948">
    </a>
    
     Chrome DevTools.
    
    
     We have also learned that we can inspect
    
    
     
      variable values.
     
    
   </p>
   <h2 id="_idParaDest-382">
    <a id="_idTextAnchor394">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The ability to debug Node.js applications is provided by the V8 JavaScript engine.
    
    
     When we pass the node process
    
    <a id="_idIndexMarker949">
    </a>
    
     the
    
    <strong class="source-inline">
     
      --inspect
     
    </strong>
    
     argument, the Node.js process starts to listen for a debugging
    
    <a id="_idIndexMarker950">
    </a>
    
     client.
    
    
     Specifically, it is the V8 inspector that opens a port that accepts WebSocket connections.
    
    
     The WebSocket connection allows the client and the V8 inspector
    
    
     
      to interact.
     
    
   </p>
   <p>
    
     At the top of the Chrome DevTools window, you will see a URI that starts with
    
    <strong class="source-inline">
     
      devtools://
     
    </strong>
    
     .
    
    
     This is a protocol that is recognized by the Google Chrome browser and instructs Google Chrome to open the Chrome DevTools
    
    
     
      user interface.
     
    
   </p>
   <p>
    
     In the recipe, we set a breakpoint in the Chrome DevTools window.
    
    
     When the line of code the breakpoint is registered on is encountered, the event loop (JavaScript thread) will be paused.
    
    
     The V8 inspector will then send a message to the client over the WebSocket connection.
    
    
     The message from the V8 inspector details the position and state of the program.
    
    
     The client can update its state based on the information
    
    
     
      it receives.
     
    
   </p>
   <p>
    
     Similarly, if the user chooses to step into a function, a command is sent to the V8 inspector to instruct it to temporarily resume the execution of the script, pausing it again afterward.
    
    
     As before, the V8 inspector sends a message back to the client detailing the new position
    
    
     
      and state.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Node.js also provides a flag that we can use to pause an application on start.
    
    
     This feature enables us to set up breakpoints before anything executes.
    
    
     It can also help when debugging an error that occurs during the setup phase of your application.
    
    
     This feature can be enabled with the
    
    <strong class="source-inline">
     
      --inspect-brk
     
    </strong>
    
     flag.
    
    
     The following is how we’d start
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     using the
    
    <strong class="source-inline">
     
      --inspect-brk
     
    </strong>
    
     flag:
    
    <strong class="source-inline">
     
      $ node --
     
    </strong>
    
     <strong class="source-inline">
      
       inspect-brk server.js
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-383">
    <a id="_idTextAnchor395">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Node.js provides a command-line inspector, which can be valuable when we do not have access to a graphical
    
    
     
      user interface.
     
    
   </p>
   <h3>
    
     Debugging with the command-line inspector
    
   </h3>
   <p>
    
     We can run the
    
    <a id="_idIndexMarker951">
    </a>
    
     application from the recipe using the command-line-based debugger with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ node inspect server.js</pre>
   <p>
    
     This command will enter us into debug mode and output the first three lines
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       server.js
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 12.8 – The terminal window depicting the Node.js inspector utility" src="img/Figure_12.8_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.8 – The terminal window depicting the Node.js inspector utility
    
   </p>
   <p>
    
     When using
    
    <strong class="source-inline">
     
      node inspect
     
    </strong>
    
     , the program pauses at the first line to allow you to set breakpoints and configure the debugger before any
    
    
     
      code executes.
     
    
   </p>
   <p>
    
     Debug mode provides a series of commands and functions that we can use to step through and debug our program.
    
    
     You can output the complete list of these commands by typing
    
    <strong class="source-inline">
     
      help
     
    </strong>
    
     and
    
    
     
      hitting
     
    
    
     <em class="italic">
      
       Enter
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     One of the functions is the
    
    <strong class="source-inline">
     
      list()
     
    </strong>
    
     function, which will list a specified number of the following lines.
    
    
     For example, we can type
    
    <strong class="source-inline">
     
      list(11)
     
    </strong>
    
     to output all twelve lines of
    
    
     
      our program:
     
    
   </p>
   <pre class="console">
debug&gt; list(11)
&gt; 1 const express = require('express');
  2 const app = express();
  3 const random = require('./random');
  4
  5 app.get('/:number', (req, res) =&gt; {
  6   const number = req.params.number;
  7   res.send(random(number).toString());
  8 });
  9
10 app.listen(3000, () =&gt; {
11   console.log('Server listening on port 3000');
12 });</pre>
   <p>
    
     We can use the
    
    <strong class="source-inline">
     
      setBreakpoint()
     
    </strong>
    
     function to set a breakpoint.
    
    
     We must supply this function with the line number on which we wish to set the breakpoint.
    
    
     There’s also a shorthand for this
    
    <a id="_idIndexMarker952">
    </a>
    
     
      function:
     
    
    
     <strong class="source-inline">
      
       sb()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Let’s set a breakpoint on
    
    <em class="italic">
     
      line 7
     
    </em>
    
     by typing
    
    <strong class="source-inline">
     
      setBreakpoint(7)
     
    </strong>
    
     
      or
     
    
    
     <strong class="source-inline">
      
       sb(7)
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
debug&gt; setBreakpoint(7)
  2 const app = express();
  3 const random = require('./random');
  4
  5 app.get('/:number', (req, res) =&gt; {
  6   const number = req.params.number;
&gt; 7   res.send(random(number).toString());
  8 });
  9
10 app.listen(3000, () =&gt; {
11   console.log('Server listening on port 3000');
12 });</pre>
   <p>
    
     The caret (
    
    <strong class="source-inline">
     
      &gt;
     
    </strong>
    
     ) indicates that a breakpoint has been set on
    
    
     <em class="italic">
      
       line 7
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     The program is
    
    <a id="_idIndexMarker953">
    </a>
    
     still paused.
    
    
     We can instruct the process to begin running by typing the continue command,
    
    <strong class="source-inline">
     
      cont
     
    </strong>
    
     .
    
    
     This also has a shorthand
    
    
     
      command,
     
    
    
     <strong class="source-inline">
      
       c
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
debug&gt; cont
&lt; Server listening on port 3000
&lt;</pre>
   <p>
    
     After entering the
    
    <strong class="source-inline">
     
      cont
     
    </strong>
    
     command, our program will start to run.
    
    
     Our breakpoint is within our request handler function.
    
    
     Let’s send a request using
    
    <strong class="source-inline">
     
      cURL
     
    </strong>
    
     in a new
    
    
     
      terminal window:
     
    
   </p>
   <pre class="console">
$ curl http://localhost:3000/10</pre>
   <p>
    
     The command will hang, as it has hit our breakpoint on
    
    <em class="italic">
     
      line 7
     
    </em>
    
     of
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     .
    
    
     If we go back to the debug session, we will see the debugger has detected that a breakpoint has
    
    
     
      been reached:
     
    
   </p>
   <pre class="console">
break in server.js:7
  5 app.get('/:number', (req, res) =&gt; {
  6   const number = req.params.number;
&gt; 7   res.send(random(number).toString());
  8 });
  9</pre>
   <p>
    
     Now, to step into the function, we type the
    
    
     <strong class="source-inline">
      
       step
      
     </strong>
    
    
     
      command:
     
    
   </p>
   <pre class="console">
debug&gt; step
break in random.js:2
  1 module.exports = (n) =&gt; {
&gt; 2   const randomNumber = Math.floor(Math.random() * n) + '1';
  3   return randomNumber;
  4 };</pre>
   <p>
    
     This goes into the
    
    <strong class="source-inline">
     
      random.js
     
    </strong>
    
     file.
    
    
     Note that the command-line debug utility provides an interface similar to Chrome DevTools, just without a graphical
    
    
     
      user interface.
     
    
   </p>
   <p>
    
     We can print out references
    
    <a id="_idIndexMarker954">
    </a>
    
     in the current scope using the
    
    <strong class="source-inline">
     
      exec
     
    </strong>
    
     command.
    
    
     Type
    
    <strong class="source-inline">
     
      exec n
     
    </strong>
    
     to output the value
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       n
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
debug&gt; exec n
'10'</pre>
   <p>
    
     Now, we can progress to the next line using the
    
    
     <strong class="source-inline">
      
       next
      
     </strong>
    
    
     
      command:
     
    
   </p>
   <pre class="console">
debug&gt; next
break in random.js:3
  1 module.exports = (n) =&gt; {
  2   const randomNumber = Math.floor(Math.random() * n) + '1';
&gt; 3   return randomNumber;
  4 };
  5</pre>
   <p>
    
     We can output the value of
    
    <strong class="source-inline">
     
      randomNumber
     
    </strong>
    
     , which will help us identify where the faulty
    
    
     
      logic is:
     
    
   </p>
   <pre class="console">
debug&gt; exec randomNumber
'71'</pre>
   <p>
    
     Now, step out using the
    
    <strong class="source-inline">
     
      out
     
    </strong>
    
     command.
    
    
     This will take us back to our
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     file, but now paused on the
    
    
     <strong class="source-inline">
      
       toString()
      
     </strong>
    
    
     
      method:
     
    
   </p>
   <pre class="console">
debug&gt; out
break in server.js:7
  5 app.get('/:number', (req, res) =&gt; {
  6   const number = req.params.number;
&gt; 7   res.send(random(number).toString());
  8 });
  9</pre>
   <p>
    
     When you reach a breakpoint or pause execution in a function and wish to skip the remainder of the function’s execution to return to the caller, you can use the
    
    <strong class="source-inline">
     
      out
     
    </strong>
    
     command.
    
    
     To exit the debugger, you can type
    
    <strong class="source-inline">
     
      .exit
     
    </strong>
    
     or enter
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     +
    
    
     <em class="italic">
      
       C
      
     </em>
    
    
     
      twice.
     
    
   </p>
   <p>
    
     We’ve now learned
    
    <a id="_idIndexMarker955">
    </a>
    
     how to step through our code and output reference values using the
    
    
     
      command-line debugger.
     
    
   </p>
   <h3>
    
     Debugging TypeScript
    
   </h3>
   <p>
    
     With TypeScript, the code that runs in the browser is compiled JavaScript, which can make debugging
    
    <a id="_idIndexMarker956">
    </a>
    
     difficult.
    
    
     Source maps solve this problem by mapping the compiled code back to your original TypeScript code, allowing you to debug more effectively with
    
    
     
      Chrome DevTools.
     
    
   </p>
   <p>
    
     Source maps are files that map your compiled JavaScript code back to the original TypeScript code.
    
    
     This allows you to debug the original TypeScript code directly in Chrome DevTools, making it easier to set breakpoints and understand errors.
    
    
     To enable source maps in TypeScript, you need to enable them in the
    
    
     <strong class="source-inline">
      
       tsconfig.json
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
  "compilerOptions": {
    "sourceMap": true,
    ...
  }</pre>
   <p>
    
     Setting
    
    <strong class="source-inline">
     
      sourceMap
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     instructs the TypeScript compiler to generate source maps for your compiled
    
    
     
      JavaScript files.
     
    
   </p>
   <p>
    
     Once you have enabled source maps and compiled your TypeScript code, you can use Chrome DevTools to take advantage of them.
    
    
     With source maps enabled, your original TypeScript files will be listed, and you can open these files and set breakpoints directly in the TypeScript code.
    
    
     When you hit a breakpoint or encounter an error, Chrome DevTools will show the corresponding line in your original
    
    
     
      TypeScript code.
     
    
   </p>
   <h2 id="_idParaDest-384">
    <a id="_idTextAnchor396">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Logging with Node.js
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Enabling debug logs
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-385">
    <a id="_idTextAnchor397">
    </a>
    
     Logging with Node.js
    
   </h1>
   <p>
    <strong class="bold">
     
      Logging
     
    </strong>
    
     is a crucial tool for understanding the
    
    <a id="_idIndexMarker957">
    </a>
    
     inner workings of an application.
    
    
     By strategically placing log statements throughout your code, you can gain valuable insights into the behavior and state of your application at various points in its execution.
    
    
     This is particularly useful when
    
    <a id="_idIndexMarker958">
    </a>
    
     diagnosing issues, as logs can provide a retrospective view of what was happening just before a crash or failure – helping you identify the root cause
    
    
     
      more efficiently.
     
    
   </p>
   <p>
    
     Beyond troubleshooting, logging serves multiple purposes.
    
    
     For instance, you can use logs to collect and analyze data about your application’s usage patterns.
    
    
     By logging every access to the endpoints of your web application, you can aggregate these logs to identify the most frequently visited endpoints.
    
    
     This information can help you optimize performance, improve user experience, and make informed decisions about future
    
    
     
      development priorities.
     
    
   </p>
   <p>
    
     In this recipe, we will delve into logging with
    
    <strong class="bold">
     
      Pino
     
    </strong>
    
     (
    
    <a href="https://www.npmjs.com/package/pino">
     
      https://www.npmjs.com/package/pino
     
    </a>
    
     ), a high-performance JSON-based logger that is both fast and lightweight.
    
    
     Pino is particularly well
    
    <a id="_idIndexMarker959">
    </a>
    
     suited for Node.js applications, offering a streamlined way to produce structured logs that are easy to parse and analyze.
    
    
     We will cover how to set up Pino, integrate it into your application, and use it to generate
    
    
     
      meaningful logs.
     
    
   </p>
   <h2 id="_idParaDest-386">
    <a id="_idTextAnchor398">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To demonstrate logging
    
    <a id="_idIndexMarker960">
    </a>
    
     with Pino, we’ll create a server
    
    
     
      with Express.js:
     
    
   </p>
   <ol>
    <li>
     
      First, create a new directory named
     
     <strong class="source-inline">
      
       logging-with-pino
      
     </strong>
     
      , initialize our project, and then install the
     
     
      <strong class="source-inline">
       
        express
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir logging-with-pino</strong>
<strong class="bold">$ cd logging-with-pino</strong>
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      We’ll create a few files that we’ll use to demonstrate some basic Pino
     
     
      
       logging features:
      
     
     <pre class="source-code">
<strong class="bold">$ touch log.js logToFile.js redactLog.js</strong></pre>
    </li>
   </ol>
   <p>
    
     We will look at how we can add Pino logging to our
    
    
     
      Express.js server.
     
    
   </p>
   <h2 id="_idParaDest-387">
    <a id="_idTextAnchor399">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will make
    
    <a id="_idIndexMarker961">
    </a>
    
     use of the
    
    <strong class="source-inline">
     
      logging-with-pino
     
    </strong>
    
     module to
    
    <a id="_idIndexMarker962">
    </a>
    
     demonstrate logging
    
    
     
      with Pino:
     
    
   </p>
   <ol>
    <li>
     
      First, start by installing the
     
     
      <strong class="source-inline">
       
        pino
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install pino</strong></pre>
    </li>
    <li>
     
      To start, we will add some basic logging to our
     
     <strong class="source-inline">
      
       log.js
      
     </strong>
     
      file to demonstrate the usage of Pino.
     
     
      In
     
     <strong class="source-inline">
      
       log.js
      
     </strong>
     
      , first import Pino and initialize
     
     
      
       the logger:
      
     
     <pre class="source-code">
const pino = require('pino');
const logger = pino();</pre>
    </li>
    <li>
     
      With Pino initialized, we can start logging messages.
     
     
      Pino supports many different log levels, including
     
     <strong class="source-inline">
      
       info
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       warn
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       error
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       debug
      
     </strong>
     
      .
     
     
      Let’s add one of each of these
     
     
      
       log messages:
      
     
     <pre class="source-code">
logger.info('This is an info message');
logger.warn('This is a warning message');
logger.error('This is an error message');
logger.debug('This is a debug message');</pre>
    </li>
    <li>
     
      Run this in
     
     
      
       your terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ node log.js</strong>
{"level":30,"time":1715650619079,"pid":11107,"hostname":"bgriggs-mac","msg":"This is an info message"}
{"level":40,"time":1715650619079,"pid":11107,"hostname":"bgriggs-mac","msg":"This is a warning message"}
{"level":50,"time":1715650619079,"pid":11107,"hostname":"bgriggs-mac","msg":"This is an error message"}</pre>
     <p class="list-inset">
      
       Observe that we only
      
      <a id="_idIndexMarker963">
      </a>
      
       see three of the four messages.
      
      
       This is
      
      <a id="_idIndexMarker964">
      </a>
      
       because Pino’s default log level is
      
      <strong class="source-inline">
       
        info
       
      </strong>
      
       .
      
      
       This means that messages logged with debug will not appear unless you change the log level to
      
      <strong class="source-inline">
       
        debug
       
      </strong>
      
       
        or
       
      
      
       <strong class="source-inline">
        
         lower
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      Let’s adjust the configuration of our Pino logger.
     
     
      We’ll set the log level to
     
     <strong class="source-inline">
      
       debug
      
     </strong>
     
      so that we can see
     
     
      
       all messages:
      
     
     <pre class="source-code">
const logger = pino({
  level: 'debug'
});</pre>
    </li>
    <li>
     
      Back in your terminal, rerun the
     
     
      <strong class="source-inline">
       
        log.js
       
      </strong>
     
     
      
       program:
      
     
     <pre class="source-code">
<strong class="bold">$ node log.js</strong>
{"level":30,"time":1715650992560,"pid":11344,"hostname":"bgriggs-mac","msg":"This is an info message"}
{"level":40,"time":1715650992561,"pid":11344,"hostname":"bgriggs-mac","msg":"This is a warning message"}
{"level":50,"time":1715650992561,"pid":11344,"hostname":"bgriggs-mac","msg":"This is an error message"}
{"level":20,"time":1715650992561,"pid":11344,"hostname":"bgriggs-mac","msg":"This is a debug message"}</pre>
    </li>
    <li>
     
      Let’s make the output look more readable.
     
     
      To do this, we can
     
     
      
       use
      
     
     
      <strong class="source-inline">
       
        pino-pretty
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ node log.js | npx pino-pretty</strong>
npm WARN exec The following package was not found and will be installed: pino-pretty@11.0.0
[02:57:10.042] INFO (11785): This is an info message
[02:57:10.042] WARN (11785): This is a warning message
[02:57:10.042] ERROR (11785): This is an error message
[02:57:10.042] DEBUG (11785): This is a debug message</pre>
    </li>
    <li>
     
      Next, let’s learn how to log to
     
     <a id="_idIndexMarker965">
     </a>
     
      a file with Pino.
     
     
      For this, we’ll work within
     
     <strong class="source-inline">
      
       logToFile.js
      
     </strong>
     
      .
     
     
      Add the
     
     <a id="_idIndexMarker966">
     </a>
     
      following to configure Pino to use a stream to write to a file named
     
     <strong class="source-inline">
      
       app.log
      
     </strong>
     
      .
     
     
      We’ll also add a single message so we can see the file is being
     
     
      
       written to:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const pino = require('pino');
const stream = fs.createWriteStream('app.log');
const logger = pino(stream);
logger.info('This is an info message');</pre>
    </li>
    <li>
     
      Back in your terminal, run the
     
     <strong class="source-inline">
      
       logToFile.js
      
     </strong>
     
      program, and once completed, you should be able to see the message that has been written to
     
     
      
       the file:
      
     
     <pre class="source-code">
<strong class="bold">$ node logToFile.js</strong>
<strong class="bold">$ cat app.log</strong>
{"level":30,"time":1715651351046,"pid":11554,"hostname":"bgriggs-mac","msg":"This is an info message"}</pre>
    </li>
    <li>
     
      Finally, let’s demonstrate Pino’s log redaction: Pino allows you to redact sensitive information from
     
     <a id="_idIndexMarker967">
     </a>
     
      your logs to protect sensitive data.
     
     
      You can specify the paths of the properties to redact.
     
     
      Add the following
     
     
      
       to
      
     
     
     
     
      <strong class="source-inline">
       
        r
       
      </strong>
     
     
      <strong class="source-inline">
       
        edactLog.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const pino = require('pino');
const logger = pino({
    redact: ['user.password', 'user.ip']
  });
  logger.info({
    user: {
        name: 'Jane Doe',
        password: 'secret',
        ip: '192.168.1.1'
    }
}, 'User login');</pre>
    </li>
    <li>
     
      Run the
     
     <strong class="source-inline">
      
       redactLog.js
      
     </strong>
     
      file.
     
     
      We
     
     <a id="_idIndexMarker968">
     </a>
     
      expect to see the password and IP values we
     
     
      
       specified redacted:
      
     
     <pre class="source-code">
<strong class="bold">$ node redactLog.js</strong>
{"level":30,"time":1715658998631,"pid":4583,"hostname":"Bethanys-MacBook-Pro.local","user":{"name":"Jane Doe","password":"[Redacted]","ip":"[Redacted]"},"msg":"User login"}</pre>
    </li>
   </ol>
   <p>
    
     We’ve now demonstrated some key features of
    
    
     
      Pino logging.
     
    
   </p>
   <h2 id="_idParaDest-388">
    <a id="_idTextAnchor400">
    </a>
    
     How it works…
    
   </h2>
   <p>
    <strong class="bold">
     
      Pino
     
    </strong>
    
     is a highly performant and
    
    <a id="_idIndexMarker969">
    </a>
    
     low-overhead logging library for Node.js, designed to be minimalistic and fast, making it suitable for high-throughput applications.
    
    
     It outputs logs in a JSON format by default, which facilitates easy parsing and compatibility with log processing systems.
    
    
     This structured format includes essential details, such as timestamps, log levels, and the
    
    
     
      message content.
     
    
   </p>
   <p>
    
     In the recipe, we began with the integration of the Pino module, which is accomplished by installing and then importing it into the application.
    
    
     Once Pino is integrated, a logger instance is instantiated.
    
    
     This instance serves as the central mechanism through which all logging activities are conducted.
    
    
     Using this logger, developers can generate logs at various severity levels.
    
    
     Each level allows the logger to categorize messages by their importance, aiding in the
    
    <a id="_idIndexMarker970">
    </a>
    
     quick identification and troubleshooting of issues based on their severity.
    
    
     The possible log levels are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        fatal
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        error
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        warn
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        info
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        debug
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        trace
       
      </strong>
     
    </li>
   </ul>
   <h2 id="_idParaDest-389">
    <a id="_idTextAnchor401">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Pino can be integrated into various web frameworks using middleware, enhancing logging capabilities with minimal effort.
    
    
     The
    
    <strong class="source-inline">
     
      express-pino-logger
     
    </strong>
    
     middleware, for example, adds a log object to every incoming request in an Express.js application.
    
    
     This log object is accessible via a property named
    
    <strong class="source-inline">
     
      log
     
    </strong>
    
     on the request object (
    
    <strong class="source-inline">
     
      req.log
     
    </strong>
    
     ).
    
    
     Each log object is unique per request and contains data about the request, including a
    
    
     
      unique identifier.
     
    
   </p>
   <p>
    
     The following example
    
    <a id="_idIndexMarker971">
    </a>
    
     demonstrates how Pino can be integrated into an Express.js application to provide
    
    
     
      JSON logging:
     
    
   </p>
   <pre class="source-code">
const express = require('express');
const pino = require('pino');
<strong class="bold">const expressPino = require('express-pino-logger');</strong>
const logger = pino();
const app = express();
<strong class="bold">app.use(expressPino({ logger }));</strong>
app.get('/', (req, res) =&gt; {
<strong class="bold">  req.log.info('Handling request');</strong>
  res.send('Hello World');
});
app.listen(3000, () =&gt; {
  logger.info('Server is running on port 3000');
});</pre>
   <p>
    
     In addition to Express.js, Pino can be integrated with other popular web frameworks through various middlewares
    
    <a id="_idIndexMarker972">
    </a>
    
     and plugins provided by the Pino
    
    
     
      GitHub organization:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       express-pino-logger
      
     </strong>
     
      : Express.js middleware for Pino, as used in the prior
     
     
      
       example (
      
     
     <a href="https://github.com/pinojs/express-pino-logger">
      
       
        https://github.com/pinojs/express-pino-logger
       
      
     </a>
     
      
       )
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       hapi-pino
      
     </strong>
     
      : A Hapi plugin for
     
     
      
       Pino (
      
     
     <a href="https://github.com/pinojs/hapi-pino">
      
       
        https://github.com/pinojs/hapi-pino
       
      
     </a>
     
      
       )
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       koa-pino
      
     </strong>
     
      : A Koa.js middleware for
     
     
      
       Pino (
      
     
     <a href="https://github.com/pinojs/koa-pino-logger">
      
       
        https://github.com/pinojs/koa-pino-logger
       
      
     </a>
     
      
       )
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       restify
      
     </strong>
     
      : A Restify middleware for
     
     
      
       Pino (
      
     
     <a href="https://github.com/pinojs/restify-pino-logger">
      
       
        https://github.com/pinojs/restify-pino-logger
       
      
     </a>
     
      
       )
      
     
    </li>
   </ul>
   <p>
    
     Furthermore, Pino’s logging capability is
    
    <a id="_idIndexMarker973">
    </a>
    
     built into the
    
    <strong class="bold">
     
      Fastify
     
    </strong>
    
     web framework, requiring only that logging be enabled with a
    
    
     
      simple configuration:
     
    
   </p>
   <pre class="source-code">
 const fastify = require('fastify')({
  logger: true,
});</pre>
   <h2 id="_idParaDest-390">
    <a id="_idTextAnchor402">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Consuming Node.js modules
      
     </em>
     
      recipe in
     
     <a href="B19212_05.xhtml#_idTextAnchor139">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
    </li>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Enabling debug logs
      
     </em>
     
      recipe
     
     <a id="_idIndexMarker974">
     </a>
     
      in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-391">
    <a id="_idTextAnchor403">
    </a>
    
     Enabling debug logs
    
   </h1>
   <p>
    <strong class="source-inline">
     
      debug
     
    </strong>
    
     is a popular library, used by many popular frameworks, including the Express.js web framework and the Mocha test framework.
    
    <strong class="source-inline">
     
      debug
     
    </strong>
    
     is a small JavaScript debugging utility based on the debugging
    
    <a id="_idIndexMarker975">
    </a>
    
     technique used in Node.js runtime itself.
    
    
     It offers a straightforward and flexible way to manage debug logs, allowing you to enable or disable debugging dynamically, without altering your application code.
    
    
     By using
    
    <strong class="source-inline">
     
      debug
     
    </strong>
    
     , you can selectively control logging for different parts of your application, making it easier to diagnose issues and understand
    
    
     
      application flow.
     
    
   </p>
   <p>
    
     In the recipe, we’ll discover how to enable debug logs on an
    
    
     
      Express.js application.
     
    
   </p>
   <h2 id="_idParaDest-392">
    <a id="_idTextAnchor404">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     We’ll create an Express.js web application that we can enable debug
    
    
     
      logs on:
     
    
   </p>
   <ol>
    <li>
     
      Create a new directory and initialize
     
     
      
       our project:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir express-debug-app</strong>
<strong class="bold">$ cd express-debug-app</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ npm install express</strong></pre>
    </li>
    <li>
     
      Now, we’ll create a single file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Add the following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const express = require('express');
const app = express();
app.get('/', (req, res) =&gt; res.send('Hello World!'));
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
   </ol>
   <p>
    
     Now that we have an
    
    <a id="_idIndexMarker976">
    </a>
    
     application, we’re ready to enable
    
    
     
      debug logs.
     
    
   </p>
   <h2 id="_idParaDest-393">
    <a id="_idTextAnchor405">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will be enabling debug logs on
    
    
     
      our application:
     
    
   </p>
   <ol>
    <li>
     
      To turn on debug logging, start your server with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ DEBUG=* node server.js</strong></pre>
    </li>
    <li>
     
      Expect to see the following color-coded output in your
     
     
      
       terminal window:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.9 – Screenshot of a terminal window depicting debug logs for the web server" src="img/Figure_12.9_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.9 – Screenshot of a terminal window depicting debug logs for the web server
    
   </p>
   <ol>
    <li value="3">
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      in your browser to send a request to our server.
     
     
      You
     
     <a id="_idIndexMarker977">
     </a>
     
      should see that the log messages describing your request have
     
     
      
       been output:
      
     
     <pre class="source-code">
<strong class="bold">  express:router dispatching GET / +1s</strong>
<strong class="bold">  express:router query  : / +1ms</strong>
<strong class="bold">  express:router expressInit  : / +0ms</strong></pre>
    </li>
    <li>
     
      Stop your server using
     
     <em class="italic">
      
       Ctrl
      
     </em>
     
      +
     
     
      <em class="italic">
       
        C
       
      </em>
     
     
      
       .
      
     
    </li>
    <li>
     
      Now, we can also filter which debug logs are output.
     
     
      We’ll filter it to just see the Express.js router actions.
     
     
      To do this, restart your server with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ DEBUG=express:router* node server.js</strong></pre>
    </li>
    <li>
     
      Expect to see the following output in your terminal window.
     
     
      Observe that only Express.js router actions
     
     
      
       are output:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.10 – Screenshot of a terminal window depicting filtered debug logs for the web server" src="img/Figure_12.10_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.10 – Screenshot of a terminal window depicting filtered debug logs for the web server
    
   </p>
   <ol>
    <li value="7">
     
      It’s possible to
     
     <a id="_idIndexMarker978">
     </a>
     
      instrument your code with the
     
     <strong class="source-inline">
      
       debug
      
     </strong>
     
      module.
     
     
      We can do that by extending our program.
     
     
      Start by copying the
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file used in the recipe to a new file and install the
     
     
      <strong class="source-inline">
       
        debug
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ cp server.js debug-server.js</strong>
<strong class="bold">$ npm install debug</strong></pre>
    </li>
    <li>
     
      Change
     
     <strong class="source-inline">
      
       debug-server.js
      
     </strong>
     
      to the following.
     
     
      We have imported the
     
     <strong class="source-inline">
      
       debug
      
     </strong>
     
      module on
     
     <em class="italic">
      
       line 3
      
     </em>
     
      , and added a
     
     <strong class="source-inline">
      
       debug
      
     </strong>
     
      call on
     
     
      <em class="italic">
       
        line 6
       
      </em>
     
     
      
       :
      
     
     <pre class="source-code">
const express = require('express');
const app = express();
const debug = require('debug')('my-server');
app.get('/', (req, res) =&gt; {
  debug('HTTP GET request to /');
  res.send('Hello World!');
});
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
    <li>
     
      Start your
     
     <a id="_idIndexMarker979">
     </a>
     
      application with the following command, and then navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      .
     
     
      Expect to see our
     
     <strong class="source-inline">
      
       HTTP GET request to /
      
     </strong>
     
      log message in your
     
     
      
       terminal window:
      
     
     <pre class="source-code">
<strong class="bold">$ DEBUG=my-server node debug-server.js</strong>
Server listening on port 3000
 my-server HTTP GET request to / +0ms</pre>
     <p class="list-inset">
      
       Note that our log message has
      
      <strong class="source-inline">
       
        my-server
       
      </strong>
      
       prepended to it.
      
      
       This is the namespace for our log messages, which we declared when we created our debug
      
      
       
        logging function.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     We’ve now learned how to enable debug logs on our application.
    
    
     We’ve also learned how to filter
    
    
     
      the logs.
     
    
   </p>
   <h2 id="_idParaDest-394">
    <a id="_idTextAnchor406">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We first prepend
    
    <strong class="source-inline">
     
      DEBUG=*
     
    </strong>
    
     to our start command.
    
    
     This syntax passes an environment variable named
    
    <strong class="source-inline">
     
      DEBUG
     
    </strong>
    
     to our Node.js process, which can be accessed from within the application
    
    
     
      via
     
    
    
     <strong class="source-inline">
      
       process.env.DEBUG
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We set the value to
    
    <strong class="source-inline">
     
      *
     
    </strong>
    
     , which enables all logs.
    
    
     Later, we filter out logs by setting
    
    <strong class="source-inline">
     
      DEBUG=express:router*
     
    </strong>
    
     .
    
    
     Internally, the
    
    <strong class="source-inline">
     
      debug
     
    </strong>
    
     module converts the values we set to
    
    
     
      regular expressions.
     
    
   </p>
   <p>
    
     Express.js uses the
    
    <strong class="source-inline">
     
      debug
     
    </strong>
    
     module internally to instrument
    
    
     
      its code.
     
    
   </p>
   <p>
    
     The default debug configuration is not suitable for logging in production.
    
    
     The default debug logs are intended to be human-readable, hence the color coding.
    
    
     When in production, you should pass your process the
    
    <strong class="source-inline">
     
      DEBUG_COLORS=no
     
    </strong>
    
     value to remove the ANSI codes that
    
    <a id="_idIndexMarker980">
    </a>
    
     implement the color coding.
    
    
     This will make the output more
    
    
     
      easily machine-readable.
     
    
   </p>
   <h2 id="_idParaDest-395">
    <a id="_idTextAnchor407">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Consuming Node.js modules
      
     </em>
     
      recipe in
     
     <a href="B19212_05.xhtml#_idTextAnchor139">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Logging with Node.js
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Enabling Node.js core debug logs
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-396">
    <a id="_idTextAnchor408">
    </a>
    
     Enabling Node.js core debug logs
    
   </h1>
   <p>
    
     When debugging
    
    <a id="_idIndexMarker981">
    </a>
    
     some problems in your applications, it can be useful to have insight into the internals of Node.js and how it handles the execution of your program.
    
    
     Node.js provides debug logs that we can enable to help us understand what is happening internally
    
    
     
      in Node.js.
     
    
   </p>
   <p>
    
     These core debug logs can be enabled via an environment variable named
    
    <strong class="source-inline">
     
      NODE_DEBUG
     
    </strong>
    
     .
    
    
     In the recipe, we’re going to set the
    
    <strong class="source-inline">
     
      NODE_DEBUG
     
    </strong>
    
     environment variable to allow us to log internal
    
    
     
      Node.js behaviors.
     
    
   </p>
   <h2 id="_idParaDest-397">
    <a id="_idTextAnchor409">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     We’ll need to create an application on which we can enable Node.js core
    
    
     
      debug logs:
     
    
   </p>
   <ol>
    <li>
     
      We’ll create a simple Express.js-based server with
     
     
      
       one route:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir core-debug-logs</strong>
<strong class="bold">$ cd core-debug-logs</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ npm install express</strong>
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const express = require('express');
const app = express();
app.get('/', (req, res) =&gt; {
  res.send('Hello World!');
});
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
  setInterval(() =&gt; {
    console.log('Server listening...');
  }, 3000);
});</pre>
    </li>
   </ol>
   <p>
    
     Now that we have an application ready, we can enable the core debug logs to allow us to see what is happening
    
    <a id="_idIndexMarker982">
    </a>
    
     at the Node.js
    
    
     
      runtime level.
     
    
   </p>
   <h2 id="_idParaDest-398">
    <a id="_idTextAnchor410">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will be enabling Node.js core debug logs on
    
    
     
      an application:
     
    
   </p>
   <ol>
    <li>
     
      We just need to set the
     
     <strong class="source-inline">
      
       NODE_DEBUG
      
     </strong>
     
      variable to the internal flag we wish to log.
     
     
      The internal flags align with specific subsystems of Node.js, such as timers or HTTP.
     
     
      To enable the “timer” core debug logs, start your server with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ NODE_DEBUG=timer node server.js</strong></pre>
    </li>
    <li>
     
      Observe the additional log output from our program.
     
     
      We can see additional information about our
     
     <strong class="source-inline">
      
       setInterval()
      
     </strong>
     
      function, which is executed every
     
     
      
       3,000 ms:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.11 – Screenshot of a terminal window depicting Node.js core timer debug messages" src="img/Figure_12.11_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.11 – Screenshot of a terminal window depicting Node.js core timer debug messages
    
   </p>
   <p class="list-inset">
    
     The preceding
    
    <strong class="source-inline">
     
      TIMER
     
    </strong>
    
     log statements are additional debug information that derives from
    
    <a id="_idIndexMarker983">
    </a>
    
     the internal implementation of timers in Node.js core, which can be found
    
    
     
      at
     
    
    <a href="https://github.com/nodejs/node/blob/master/lib/internal/timers.js">
     
      
       https://github.com/nodejs/node/blob/master/lib/internal/timers.js
      
     
    </a>
    
     
      .
     
    
   </p>
   <ol>
    <li value="3">
     
      We will now enable core debug logs for the
     
     <strong class="source-inline">
      
       http
      
     </strong>
     
      module.
     
     
      Restart your server with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ NODE_DEBUG=http node server.js</strong></pre>
    </li>
    <li>
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      in a browser.
     
     
      You should expect to see internal logs about your HTTP
     
     
      
       request output:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.12 – Screenshot of a terminal window depicting Node.js core HTTP debug messages" src="img/Figure_12.12_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.12 – Screenshot of a terminal window depicting Node.js core HTTP debug messages
    
   </p>
   <p>
    
     We’ve now learned
    
    <a id="_idIndexMarker984">
    </a>
    
     how to use the
    
    <strong class="source-inline">
     
      NODE_DEBUG
     
    </strong>
    
     environment variable to enable the logging of
    
    
     
      Node.js internals.
     
    
   </p>
   <h2 id="_idParaDest-399">
    <a id="_idTextAnchor411">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, we set the
    
    <strong class="source-inline">
     
      NODE_DEBUG
     
    </strong>
    
     environment variable to both the
    
    <strong class="source-inline">
     
      timer
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     subsystems.
    
    
     The
    
    <strong class="source-inline">
     
      NODE_DEBUG
     
    </strong>
    
     environment variable can be set to the following
    
    
     
      Node.js subsystems:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        child_process
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        cluster
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        esm
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        fs
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        http
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        https
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        http2
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        module
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        net
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        repl
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        source_map
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        stream
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        test_runner
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        timer
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        tls
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        worker
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     It is also possible to enable debug logs on multiple subsystems via the
    
    <strong class="source-inline">
     
      NODE_DEBUG
     
    </strong>
    
     environment variable.
    
    
     To enable multiple subsystem logs, you can pass them as a comma-separated list.
    
    
     For
    
    <a id="_idIndexMarker985">
    </a>
    
     example, to enable both the
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      timer
     
    </strong>
    
     subsystems, you’d supply the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ NODE_DEBUG=http,timer node server.js</pre>
   <p>
    
     The output of each log message includes the subsystem/namespace, followed by the
    
    <strong class="bold">
     
      process identifier
     
    </strong>
    
     (
    
    <strong class="bold">
     
      PID
     
    </strong>
    
     ), and then the
    
    <a id="_idIndexMarker986">
    </a>
    
     
      log message.
     
    
   </p>
   <p>
    
     In the recipe, we first enabled the “timer” core debug logs.
    
    
     In our program, we have a
    
    <strong class="source-inline">
     
      setInterval()
     
    </strong>
    
     function that prints the
    
    <strong class="bold">
     
      Server listening...
     
    </strong>
    
     message to
    
    <strong class="source-inline">
     
      stdout
     
    </strong>
    
     every 3,000 ms.
    
    
     The core debug logs provided insight into how our interval timer was
    
    
     
      created internally.
     
    
   </p>
   <p>
    
     Similarly, when we enabled the
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     core module debug logs, we could follow what was happening internally during HTTP requests.
    
    
     The
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     debug logs are fairly self-explanatory and human-readable in terms of how they describe the actions that are happening when our server
    
    <a id="_idIndexMarker987">
    </a>
    
     receives and responds to an
    
    
     
      HTTP request.
     
    
   </p>
   <p class="callout-heading">
    
     Extending NODE_DEBUG
    
   </p>
   <p class="callout">
    
     It is possible to make use of the Node.js core
    
    <strong class="source-inline">
     
      util.debuglog()
     
    </strong>
    
     method to instrument your own debug logs that you can enable via the
    
    <strong class="source-inline">
     
      NODE_DEBUG
     
    </strong>
    
     environment variable.
    
    
     However, this is
    
    <a id="_idIndexMarker988">
    </a>
    
     not generally recommended.
    
    
     It is preferable to use the third-party
    
    <strong class="source-inline">
     
      debug
     
    </strong>
    
     module, which is covered in the
    
    <em class="italic">
     
      Enabling debug logs
     
    </em>
    
     recipe in this chapter.
    
    
     The
    
    <strong class="source-inline">
     
      debug
     
    </strong>
    
     module provides additional logging features, including timestamps and color-coding, with
    
    
     
      minimal overhead.
     
    
   </p>
   <h2 id="_idParaDest-400">
    <a id="_idTextAnchor412">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Debugging Node.js with Chrome DevTools
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Logging with Node.js
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Enabling debug logs
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-401">
    <a id="_idTextAnchor413">
    </a>
    
     Increasing stack trace size
    
   </h1>
   <p>
    
     A
    
    <strong class="bold">
     
      stack trace
     
    </strong>
    
     , sometimes referred to as a
    
    <strong class="bold">
     
      stack backtrace
     
    </strong>
    
     , is defined as a list of stack frames.
    
    
     When your Node.js process hits an error, a
    
    <a id="_idIndexMarker989">
    </a>
    
     stack trace is shown detailing the function that experienced
    
    <a id="_idIndexMarker990">
    </a>
    
     the error, and the functions that it was called by.
    
    
     By default, Node.js’s V8 engine will return 10
    
    
     
      stack frames.
     
    
   </p>
   <p>
    
     When debugging some errors, it can be useful to have more than 10 stack frames.
    
    
     However, increasing the number of stack frames stored can come with a performance cost.
    
    
     Keeping track of additional stack frames will result in our applications consuming more memory.
    
    
     For more details, you can refer to this
    
    
     
      link:
     
    
    <a href="https://v8.dev/docs/stack-trace-api">
     
      
       https://v8.dev/docs/stack-trace-api
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     In the recipe, we’re going to increase the size of the
    
    
     
      stack trace.
     
    
   </p>
   <h2 id="_idParaDest-402">
    <a id="_idTextAnchor414">
    </a>
    
     Getting ready
    
   </h2>
   <ol>
    <li>
     
      First, we should create a directory for our application.
     
     
      We’ll be using the
     
     <strong class="source-inline">
      
       express
      
     </strong>
     
      module for our program, so we’ll also need to initialize our
     
     
      
       project directory:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir stack-trace-app</strong>
<strong class="bold">$ cd stack-trace-app</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ npm install express</strong></pre>
    </li>
    <li>
     
      We’ll need a few files for
     
     
      
       this recipe:
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js routes.js</strong></pre>
    </li>
    <li>
     
      Add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const express = require('express');
const routes = require('./routes');
const app = express();
app.use(routes);
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
    </li>
    <li>
     
      Then, add the
     
     <a id="_idIndexMarker991">
     </a>
     
      following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        routes.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const express = require('express');
const router = new express.Router();
router.get('/', (req, res) =&gt; {
  res.send(recursiveContent());
});
function recursiveContent (content, i = 10) {
  --i;
  if (i !== 0) {
    return recursiveContent(content, i);
  } else {
    return content.undefined_property;
  }
}
module.exports = router;</pre>
    </li>
   </ol>
   <p>
    
     The purpose of the
    
    <strong class="source-inline">
     
      recursiveContent()
     
    </strong>
    
     function is to force the creation of function calls, but in larger, more complex applications, it’s possible to exceed the stack frame
    
    
     
      limit naturally.
     
    
   </p>
   <p>
    
     Now that we have an
    
    <a id="_idIndexMarker992">
    </a>
    
     application that will exceed the default call stack limit, we can move on to the
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-403">
    <a id="_idTextAnchor415">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will learn how to enable additional stack frames using the
    
    <strong class="source-inline">
     
      --stack-trace-limit
     
    </strong>
    
     
      process flag:
     
    
   </p>
   <ol>
    <li>
     
      Start by running
     
     
      
       the server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      Now, in a browser, navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      .
     
     
      Alternatively, you could use
     
     <strong class="source-inline">
      
       cURL
      
     </strong>
     
      to send a request to
     
     
      
       the endpoint.
      
     
    </li>
    <li>
     
      Observe that we see the following stack trace
     
     
      
       output returned:
      
     
     <pre class="source-code">
TypeError: Cannot read properties of undefined (reading 'undefined_property')
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:13:20)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)</pre>
    </li>
    <li>
     
      We can now restart our application with the
     
     <strong class="source-inline">
      
       --stack-trace-limit
      
     </strong>
     
      flag.
     
     
      We’ll set this
     
     <a id="_idIndexMarker993">
     </a>
     
      
       to
      
     
     
      <strong class="source-inline">
       
        20
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ node --stack-trace-limit=20 server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      Now, navigate or send a request to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      again.
     
     
      Observe that we have more frames from the stack
     
     
      
       trace now:
      
     
     <pre class="source-code">
...
    at recursiveContent (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:11:12)
    at /Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/routes.js:5:12
    at Layer.handle [as handle_request] (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/layer.js:95:5)
    at next (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/route.js:149:13)
    at Route.dispatch (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/route.js:119:3)
    at Layer.handle [as handle_request] (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/layer.js:95:5)
    at /Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/index.js:284:15
    at Function.process_params (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/index.js:346:12)
    at next (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/index.js:280:10)
    at Function.handle (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/index.js:175:3)
    at router (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/node_modules/express/lib/router/index.js:47:12)</pre>
    </li>
    <li>
     
      By extending how many stack frames are returned, we can see that the
     
     <strong class="source-inline">
      
       recursiveContent()
      
     </strong>
     
      function is called in
     
     <strong class="source-inline">
      
       routes.js
      
     </strong>
     
      on
     
     <em class="italic">
      
       line 5
      
     </em>
     
      .
     
     
      This helps us realize that the reason our program is failing is because we did not define the content and pass it to our
     
     
      <strong class="source-inline">
       
        recursiveContent()
       
      </strong>
     
     
      
       function.
      
     
    </li>
   </ol>
   <p>
    
     We’ve learned how to
    
    <a id="_idIndexMarker994">
    </a>
    
     return additional stack traces, and how these can help us to debug
    
    
     
      our applications.
     
    
   </p>
   <h2 id="_idParaDest-404">
    <a id="_idTextAnchor416">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, we make use of the
    
    <strong class="source-inline">
     
      --stack-trace-limit
     
    </strong>
    
     flag.
    
    
     This flag instructs the V8 JavaScript engine to retain more stacks.
    
    
     When an error occurs, the stack trace will show the preceding function calls up to the limit set with the flag.
    
    
     In the recipe, we extended this to 20
    
    
     
      stack frames.
     
    
   </p>
   <p>
    
     Note that it is also possible to set this limit from within your application code.
    
    
     The following line would set the stack trace limit
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       20
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
Error.stackTraceLimit = 20;</pre>
   <p>
    
     It is also possible to set the stack trace limit to
    
    <strong class="source-inline">
     
      Infinity
     
    </strong>
    
     ,  meaning all preceding function calls will
    
    
     
      be retained:
     
    
   </p>
   <pre class="source-code">
Error.stackTraceLimit = Infinity</pre>
   <p>
    
     Storing additional stack traces comes with a performance cost in terms of CPU and memory usage.
    
    
     You should consider the impact this may have on
    
    
     
      your application.
     
    
   </p>
   <h2 id="_idParaDest-405">
    <a id="_idTextAnchor417">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Asynchronous stack traces were added to Node.js 12 via the V8 JavaScript engine update; these can help us debug our
    
    
     
      asynchronous functions.
     
    
   </p>
   <p>
    
     Asynchronous stack traces help us to debug asynchronous functions in our programs.
    
    
     Let’s take a look at an asynchronous
    
    
     
      stack trace:
     
    
   </p>
   <ol>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        async-stack-trace.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch async-stack-trace.js</strong></pre>
    </li>
    <li>
     
      Add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        async-stack-trace.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
foo().then(
  () =&gt; console.log('success'),
  (error) =&gt; console.error(error.stack)
);
async function foo () {
  await bar();
}
async function bar () {
  await Promise.resolve();
  throw new Error('Fail');
}</pre>
     <p class="list-inset">
      
       This program contains an asynchronous function,
      
      <strong class="source-inline">
       
        foo()
       
      </strong>
      
       , that awaits a function named
      
      <strong class="source-inline">
       
        bar()
       
      </strong>
      
       .
      
      
       The
      
      <strong class="source-inline">
       
        bar()
       
      </strong>
      
       function automatically resolves
      
      <strong class="source-inline">
       
        Promise
       
      </strong>
      
       and then throws
      
      
       
        an error.
       
      
     </p>
    </li>
    <li>
     
      In versions of Node.js before Node.js 12, the following stack trace would be returned from
     
     <a id="_idIndexMarker995">
     </a>
     
      
       the program:
      
     
     <pre class="source-code">
<strong class="bold">$ node async-stack-trace.js</strong>
Error: Fail
    at bar (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/async-stack-trace.js:15:9)
    at process.runNextTicks [as _tickCallback] (internal/process/task_queues.js:52:5)
    at Function.Module.runMain (internal/modules/cjs/loader.js:880:11)
    at internal/main/run_main_module.js:21:11
(internal/bootstrap/node.js:623:3)</pre>
     <p class="list-inset">
      
       Observe that the trace just tells us the error is in the
      
      <strong class="source-inline">
       
        bar()
       
      </strong>
      
       function, followed by some internal function calls, such as
      
      <strong class="source-inline">
       
        process._tickCallback()
       
      </strong>
      
       .
      
      
       Prior to Node.js 12, stack traces were unable to effectively report the asynchronous function calls.
      
      
       Note that the stack frames do not show that the
      
      <strong class="source-inline">
       
        bar()
       
      </strong>
      
       function was called
      
      
       
        by
       
      
      
       <strong class="source-inline">
        
         foo()
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      However, thanks to an updated V8 engine, Node.js 12 and greater enable asynchronous
     
     <a id="_idIndexMarker996">
     </a>
     
      stack traces.
     
     
      We will now get the following stack output when we run the same program with
     
     
      
       Node.js 22:
      
     
     <pre class="source-code">
<strong class="bold">$ node async-stack-trace.js</strong>
Error: Fail
    at bar (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/async-stack-trace.js:15:9)
    at async foo (/Users/bgriggs/Node.js-Cookbook/Chapter12/stack-trace-app/async-stack-trace.js:9:3)</pre>
    </li>
   </ol>
   <p>
    
     The stack traces in newer versions of Node.js can show us that the
    
    <strong class="source-inline">
     
      bar()
     
    </strong>
    
     function was called by an asynchronous function
    
    
     
      named
     
    
    
     <strong class="source-inline">
      
       foo()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-406">
    <a id="_idTextAnchor418">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Logging with Node.js
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Enabling Node.js core debug logs
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Creating diagnostic reports
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-407">
    <a id="_idTextAnchor419">
    </a>
    
     Creating diagnostic reports
    
   </h1>
   <p>
    
     The diagnostic report utility has been available behind a process flag since Node.js v11.8.0.
    
    
     The diagnostic report utility allows you to generate a report containing diagnostic data on demand or when certain events occur.
    
    
     The situations where a report could be generated include when your application crashes, or when your application is experiencing slow performance or high
    
    
     
      CPU usage.
     
    
   </p>
   <p>
    
     A diagnostic report fulfills
    
    <a id="_idIndexMarker997">
    </a>
    
     a similar purpose to the Java Core file.
    
    
     The diagnostic report contains data and information that can aid with diagnosing problems in applications.
    
    
     The information reported includes the Node.js version, the event that triggered the report, stack traces,
    
    
     
      and more.
     
    
   </p>
   <p>
    
     Historically, the diagnostic report utility was available as a
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     module named
    
    <strong class="source-inline">
     
      node-report
     
    </strong>
    
     .
    
    
     But, to improve adoption and enhance the core diagnostic features, it was merged into
    
    
     
      Node.js core.
     
    
   </p>
   <p>
    
     In this recipe, we’ll learn how to enable and configure the diagnostic report utility and generate a report when an uncaught exception happens in
    
    
     
      our application.
     
    
   </p>
   <h2 id="_idParaDest-408">
    <a id="_idTextAnchor420">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To get started, we need to prepare our directory and
    
    
     
      some files.
     
    
   </p>
   <ol>
    <li>
     
      First, let’s create a directory
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        diagnostic-report
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir diagnostic-report</strong>
<strong class="bold">$ cd diagnostic-report</strong></pre>
    </li>
    <li>
     
      Now, let’s create a file to hold our server
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Let’s also create a directory to store
     
     
      
       the reports:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir reports</strong></pre>
    </li>
   </ol>
   <p>
    
     Now, we are ready to move on to the
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-409">
    <a id="_idTextAnchor421">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to use the diagnostic report utility to create a report on unhandled errors.
    
    
     We’ll set a custom directory and filename for the report.
    
    
     We’ll also inspect the generated
    
    <a id="_idIndexMarker998">
    </a>
    
     report for information about the
    
    
     
      unhandled errors:
     
    
   </p>
   <ol>
    <li>
     
      First, let’s import the core Node.js modules we need for the recipe
     
     
      
       into
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const http = require('node:http');
const path = require('node:path');</pre>
    </li>
    <li>
     
      Now, let’s set the directory for our diagnostic report to be
     
     
      
       captured in:
      
     
     <pre class="source-code">
process.report.directory = path.join(__dirname, 'reports');
process.report.filename = 'my-diagnostic-report.json';</pre>
    </li>
    <li>
     
      Now, we’ll send a request to a web server, but we’ll intentionally specify an invalid protocol.
     
     
      Add the following line
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
http.get('hello://localhost:3000', (response) =&gt; {});</pre>
    </li>
    <li>
     
      Now, if we run the application, we should expect to see the following uncaught
     
     
      <strong class="source-inline">
       
        ERR_INVALID_PROTOCOL
       
      </strong>
     
     
      
       error:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">node:_http_client:183</strong>
<strong class="bold">    throw new ERR_INVALID_PROTOCOL(protocol, expectedProtocol);</strong>
<strong class="bold">    ^</strong>
<strong class="bold">TypeError [ERR_INVALID_PROTOCOL]: Protocol "hello:" not supported. Expected "http:"</strong>
<strong class="bold">    at new ClientRequest (node:_http_client:183:11)</strong>
<strong class="bold">    at request (node:http:103:10)</strong>
<strong class="bold">    at Object.get (node:http:114:15)</strong>
<strong class="bold">    at Object.&lt;anonymous&gt; (/Users/bgriggs/Node.js-Cookbook/Chapter12/diagnostic-report/server.js:7:6)</strong>
<strong class="bold">    at Module._compile (node:internal/modules/cjs/loader:1358:14)</strong>
<strong class="bold">    at Module._extensions..js (node:internal/modules/cjs/loader:1416:10)</strong>
<strong class="bold">    at Module.load (node:internal/modules/cjs/loader:1208:32)</strong>
<strong class="bold">    at Module._load (node:internal/modules/cjs/loader:1024:12)</strong>
<strong class="bold">    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:174:12)</strong>
<strong class="bold">    at node:internal/main/run_main_module:28:49 {</strong>
<strong class="bold">  code: 'ERR_INVALID_PROTOCOL'</strong>
<strong class="bold">}</strong>
<strong class="bold">Node.js v22.9.0</strong></pre>
    </li>
    <li>
     
      To enable the diagnostic
     
     <a id="_idIndexMarker999">
     </a>
     
      report feature, we need to start the Node.js process with the
     
     <strong class="source-inline">
      
       --report-uncaught-exception
      
     </strong>
     
      flag.
     
     
      Expect to see the following snippet included in the output, showing that a report has
     
     
      
       been created:
      
     
     <pre class="source-code">
<strong class="bold">$ node --report-uncaught-exception server.js</strong>
<strong class="bold">...</strong>
<strong class="bold">Writing Node.js report to file: my-diagnostic-report.json</strong>
<strong class="bold">Node.js report completed</strong>
<strong class="bold">Node.js v22.9.0</strong></pre>
    </li>
    <li>
     
      Now, we can take a look at the report.
     
     
      It should have been created in the
     
     <strong class="source-inline">
      
       reports
      
     </strong>
     
      directory with the name
     
     <strong class="source-inline">
      
       my-diagnostic-report.json
      
     </strong>
     
      .
     
     
      Open the file in
     
     
      
       your editor.
      
     
    </li>
    <li>
     
      Identify the
     
     <strong class="source-inline">
      
       event
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       trigger
      
     </strong>
     
      property toward the top of the file and observe that it provides details about the event that triggered
     
     
      
       the error:
      
     
     <pre class="source-code">
<strong class="bold">    "event": "Exception",</strong>
<strong class="bold">    "trigger": "Exception",</strong></pre>
    </li>
    <li>
     
      Further down in the
     
     <a id="_idIndexMarker1000">
     </a>
     
      file, identify the
     
     <strong class="source-inline">
      
       javascriptStack
      
     </strong>
     
      property.
     
     
      It should provide the stack trace of
     
     
      
       the error:
      
     
     <pre class="source-code">
<strong class="bold">"javascriptStack": {</strong>
<strong class="bold">    "message": "TypeError [ERR_INVALID_PROTOCOL]: Protocol \"hello:\" not supported. Expected \"http:\"",</strong>
<strong class="bold">    "stack": [</strong>
<strong class="bold">      "at new ClientRequest (node:_http_client:183:11)",</strong>
<strong class="bold">      "at request (node:http:103:10)",</strong>
<strong class="bold">      "at Object.get (node:http:114:15)",</strong>
<strong class="bold">      "at Object.&lt;anonymous&gt; (/Users/bgriggs/Node.js-Cookbook/Chapter12/diagnostic-report/server.js:7:6)",</strong>
<strong class="bold">      "at Module._compile (node:internal/modules/cjs/loader:1358:14)",</strong>
<strong class="bold">      "at Module._extensions..js (node:internal/modules/cjs/loader:1416:10)",</strong>
<strong class="bold">      "at Module.load (node:internal/modules/cjs/loader:1208:32)",</strong>
<strong class="bold">      "at Module._load (node:internal/modules/cjs/loader:1024:12)",</strong>
<strong class="bold">      "at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:174:12)"</strong>
<strong class="bold">    ],</strong>
<strong class="bold">    "errorProperties": {</strong>
<strong class="bold">      "code": "ERR_INVALID_PROTOCOL"</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong></pre>
    </li>
   </ol>
   <p>
    
     Now, we’ve learned how to enable the diagnostic report utility on uncaught exceptions and how to inspect the report for
    
    
     
      diagnostic information.
     
    
   </p>
   <h2 id="_idParaDest-410">
    <a id="_idTextAnchor422">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The diagnostic report
    
    <a id="_idIndexMarker1001">
    </a>
    
     utility enables a diagnostic summary to be written in a file on certain conditions.
    
    
     The utility is built into the Node.js core and is enabled by passing one of the following command-line flags to the
    
    
     
      Node.js process:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       --report-uncaught-exception
      
     </strong>
     
      : As used in the recipe, it triggers a crash on an
     
     
      
       uncaught exception.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       --report-on-signal
      
     </strong>
     
      : This is used to configure which signal a report is triggered upon, such as
     
     <strong class="source-inline">
      
       SIGUSR1
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       SIGUSR2
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       SIGINT
      
     </strong>
     
      , or
     
     <strong class="source-inline">
      
       SIGTERM
      
     </strong>
     
      .
     
     
      The default
     
     
      
       is
      
     
     
      <strong class="source-inline">
       
        SIGUSR2
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       --report-on-fatalerror
      
     </strong>
     
      : A report is triggered on a fatal error, such as an
     
     
      
       out-of-memory error.
      
     
    </li>
   </ul>
   <p>
    
     Note that it is also possible to trigger the generation of the report from within your application using the
    
    
     
      following line:
     
    
   </p>
   <pre class="source-code">
process.report.writeReport();</pre>
   <p>
    
     In the recipe, we first set up a custom directory by assigning the
    
    <strong class="source-inline">
     
      process.report.directory
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      process.report.filename
     
    </strong>
    
     variables in the program.
    
    
     These can also be set via the
    
    <strong class="source-inline">
     
      --report-directory
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      --report-filename
     
    </strong>
    
     command-line arguments.
    
    
     Note that you may wish to append a timestamp to the filename – otherwise, the reports may
    
    
     
      get overwritten.
     
    
   </p>
   <p>
    
     Neither the directory nor the filename are required to be set.
    
    
     When the directory is omitted, the report will be generated in the directory from which we start the Node.js process.
    
    
     When omitting
    
    <a id="_idIndexMarker1002">
    </a>
    
     a specified filename, the utility will default to creating one with the following naming
    
    
     
      convention:
     
    
    
     <strong class="source-inline">
      
       report.20181126.091102.8480.0.001.json
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-411">
    <a id="_idTextAnchor423">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Enabling Node.js core debug logs
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Increasing stack trace output
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
  </div>
 </body></html>